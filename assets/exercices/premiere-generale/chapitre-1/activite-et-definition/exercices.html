<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Premi√®re ‚Äì Chapitre 1 ‚Äì Polyn√¥me du second degr√© ‚Äî Activit√© (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"],input[type="number"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .table td:last-child,.table th:last-child{text-align:center;white-space:nowrap}

  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}

  /* masque noir pour cacher les champs dans l‚Äô√©nonc√© PDF */
  .pdf-mask{display:block;height:14px;background:#000;border-radius:2px}

  @media print{ .controls{display:none !important;} }
</style>

<!-- MathJax v3 (LaTeX) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Premi√®re ‚Äì Chapitre 1 ‚Äì <strong>Polyn√¥me du second degr√©</strong> ‚Äî Activit√©</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
        <button id="btn-solution" class="btn">üí° Solution</button>
      </span>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Entr√©e ‚èé d√©clenche <b>V√©rifier</b>.</li>
        <li>Si ce n‚Äôest pas du second degr√©, laissez <b>a</b>, <b>b</b>, <b>c</b> vides.</li>
        <li>D√©cimales : virgule ou point. Produits implicites accept√©s (ex. <code>2x</code>, <code>(x+1)(x-3)</code>).</li>
        <li>Puissances accept√©es : <code>x^2</code>, <code>x ^ 2</code>, <code>x¬≤</code>, <code>x**2</code>, <code>(x)^2</code>, <code>(x+3)^2</code>, <code>(2x)^3</code>‚Ä¶</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- d√©pendances -->
  <script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
  <script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
  <script src="../../../../js/math-kbd.js" defer></script>
  <script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){
'use strict';

/* ========= petits helpers DOM ========= */
const $=(s,r)=> (r||document).querySelector(s);
const $$=(s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ========= attendre DevRules + algebraicEqual ========= */
function whenReady(cb){
  function ok(){return window.DevRules && window.algebraicEqual}
  if(ok()) return cb();
  let t=0, i=setInterval(()=>{ if(ok()){clearInterval(i);cb();} else if((t+=50)>6000){clearInterval(i);} },50);
}

/* ========= LaTeX helpers (depuis ¬´ exercices - Latex.html ¬ª) ========= */
function fixSigns(s){
  return String(s)
    .replace(/\u2212/g,'-')              // U+2212 ‚Üí ASCII pour LaTeX
    .replace(/\+\s*-\s*/g, ' - ')
    .replace(/-\s*\+\s*/g, ' - ')
    .replace(/-\s*-\s*/g, ' + ')
    .replace(/\+\s*\+\s*/g, ' + ')
    .replace(/\s{2,}/g, ' ')
    .trim();
}
function typesetAll(root){
  const run = () => MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  if (window.MathJax && MathJax.startup && MathJax.startup.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{ if(window.MathJax && MathJax.typesetPromise){ clearInterval(t); run(); } },60);
  }
}
function powLatex(p){
  if(p===0) return '';
  if(p===1) return 'x';
  return 'x^{' + p + '}';
}
function monoLatex(c,p,opt){
  opt = opt||{};
  const A = Math.abs(c);
  const body = (p===0 ? String(A) : (A===1 ? powLatex(p) : (A + powLatex(p))));
  let s = (c<0? '-' : '') + body;
  // Si c<0 ET on est un facteur : on parenth√®se √† droite (g√©r√© par appelant au besoin)
  return s;
}
function monoLatexAbs(c,p){ return monoLatex(Math.abs(c), p, {omitOne:true}); }
function polyLatexNoOne(poly){
  var out=[], first=true;
  for(var p=poly.length-1;p>=0;p--){
    var c=poly[p]; if(!c) continue;
    var seg = monoLatex(c,p,{omitOne:true});
    out.push(first ? ((c<0? '-' : '')+seg) : ((c<0? ' - ' : ' + ')+seg));
    first=false;
  }
  return fixSigns(out.length? out.join(''):'0');
}
function polyLatexDesc(P){
  let out=[], first=true;
  for(let p=P.length-1; p>=0; p--){
    const c=P[p]; if(!c) continue;
    const A=Math.abs(c);
    const seg = (p===0 ? String(A) : (A===1 ? powLatex(p) : (A+powLatex(p))));
    out.push(first ? (c<0?('-'+seg):seg) : (c<0?(' - '+seg):(' + '+seg)));
    first=false;
  }
  return out.length ? fixSigns(out.join('')) : '0';
  }
function L(tex){ return '\\( '+fixSigns(tex)+' \\)'; }
function parenIfNegNum(n){ return n<0 ? ('\\left('+n+'\\right)') : String(n); }
function sumTermsLatex(terms){
  // terms: [{c,p}]
  const items=[];
  let first=true;
  for(const t of terms||[]){
    if(!t || !t.c) continue;
    const c=t.c, p=t.p;
    const A=Math.abs(c);
    const seg = (p===0 ? String(A) : (A===1? powLatex(p) : (A+powLatex(p))));
    const pref = first ? (c<0? '-' : '') : (c<0? ' - ' : ' + ');
    items.push(pref + seg);
    first=false;
  }
  return items.length? items.join('') : '0';
}

/* ========= PDF (table clone) ========= */
function setColWidth(td, mm){ td.style.width = mm+'mm'; td.style.maxWidth = mm+'mm'; }
function cloneTableForPDF(root){
  const t = root.querySelector('.table'); if(!t) return '';
  const clone = t.cloneNode(true);

  Object.assign(clone.style, { borderCollapse:'collapse', border:'1px solid #000', tableLayout:'fixed', width:'100%' });
  clone.querySelectorAll('th,td').forEach(td=>{ td.style.border='1px solid #000'; });

  let ths = Array.from(clone.querySelectorAll('thead th'));
  if (ths.length) ths.at(-1).remove(); // colonne "Valider"

  ths = Array.from(clone.querySelectorAll('thead th'));
  const norm = s => s.replace(/\s+/g,' ').trim().toLowerCase();
  const labels = ths.map(th => norm(th.textContent));

  const isEx1 = (['a','b','c'].every(k => labels.includes(k)) || labels.some(l => /degr√©|trin[o√¥]me/.test(l)));
  const isEx2 = labels.some(l => /d√©veloppement|developpement/.test(l));

  const W1 = [12, 110, 26, 18, 18, 18];
  const W2 = [12,  70, 100, 18, 18, 18];
  const widths = isEx1 ? W1 : (isEx2 ? W2 : []);

  if (widths.length){
    clone.querySelectorAll('tr').forEach(tr=>{
      Array.from(tr.children).forEach((cell, idx)=>{
        if (widths[idx] != null) setColWidth(cell, widths[idx]);
      });
    });
  }

  clone.querySelectorAll('tbody tr').forEach(tr=>{
    const cells = Array.from(tr.children);
    if (cells.length) cells.at(-1).remove();
    Array.from(tr.children).forEach(td=>{
      if (td.querySelector('input,select,button')){ td.innerHTML = '<span class="pdf-mask"></span>'; }
    });
  });

  return clone.outerHTML;
}

/* ========= comparateur (inchang√©) ========= */
function polyToExpr(poly){
  let parts=[], lead=true;
  for(let p=poly.length-1;p>=0;p--){
    const c=poly[p]||0; if(!c) continue;
    const A=Math.abs(c), s=(c<0?(lead?'-':' - '):(lead?'':' + '));
    if(p===0) parts.push(s+A);
    else if(p===1) parts.push(s+(A===1?'x':A+'x'));
    else parts.push(s+(A===1?'x^'+p:A+'x^'+p));
    lead=false;
  }
  return parts.join('')||'0';
}
function equalPolyVsExpr(poly, expr){
  try{ return algebraicEqual(polyToExpr(poly), String(expr||'').trim()); }catch(_){ return false; }
}
function degOf(P){for(let p=P.length-1;p>=0;p--){if(P[p])return p}return 0}
function degreePhraseFr(it){
  const P = it.poly || [];
  const d = degOf(P);

  if (d === 0) {
    return 'La fonction f est constante.';
  }

  if (d === 1) {
    const isLinear = (P[0] || 0) === 0; // terme constant nul ‚Üí lin√©aire
    return 'La fonction f est ' + (isLinear ? 'lin√©aire' : 'affine') + '.';
  }

  if (d === 2) {
    const a = (it.a != null) ? it.a : (P[2] || 0);
    const b = (it.b != null) ? it.b : (P[1] || 0);
    const c = (it.c != null) ? it.c : (P[0] || 0);
    // a, b, c : tout en LaTeX (lettre, =, et nombre)
    return 'Le polyn√¥me est de degr√© 2 avec '
         + L('a = ' + a) + ', '
         + L('b = ' + b) + ', '
         + L('c = ' + c) + '.';
  }

  return 'Le polyn√¥me est de degr√© ' + d + '.';
}

/* ===================== Exercice 1 ===================== */
const ex1={
  id:'p1',
  title:'Identifier les trin√¥mes et donner a, b, c',
  gen(){
    function mkQuad(){
      const a=choice([-3,-2,-1,1,2,3]);
      const b=rnd(-6,6);
      const c=rnd(-6,6);
      const P=[]; P[0]=c; P[1]=b; P[2]=a;
      return {isQuad:true,a,b,c,poly:P};
    }
    function mkNonQuad(){
      const d=choice([0,1,3,4,5]);
      const P=Array(d+1).fill(0).map(()=>rnd(-6,6));
      if(d===2){ P[Math.random()<0.5?0:2]=0; } // pas un vrai trin√¥me
      return {isQuad:false,poly:P};
    }
    const items=[mkQuad(),mkQuad(),mkQuad(),mkNonQuad(),mkNonQuad(),mkNonQuad()].sort(()=>Math.random()-.5);

    function unorderedTex(P){
      const terms=[]; for(let p=0;p<P.length;p++){ const c=P[p]||0; if(c) terms.push({c,p}); }
      if(!terms.length) return '0';
      let sh=terms.slice().sort(()=>Math.random()-.5);
      let tries=4;
      while(tries--){
        const isDesc = sh.every((t,i)=> i===0 || sh[i-1].p>t.p);
        if(!isDesc) break;
        sh=terms.slice().sort(()=>Math.random()-.5);
      }
      let out=[], first=true;
      for(const t of sh){
        const A=Math.abs(t.c);
        const seg = (t.p===0? String(A) : (A===1? powLatex(t.p) : (A+powLatex(t.p))));
        out.push(first ? (t.c<0?('-'+seg):seg) : (t.c<0?(' - '+seg):(' + '+seg)));
        first=false;
      }
      return fixSigns(out.join(''));
    }

    items.forEach(it=>{ it.exprTex = unorderedTex(it.poly||[]); });
    return {items};
  },
  render(host,st){
    host.innerHTML=[
      '<div>Dans chaque cas, dire si c‚Äôest un polyn√¥me de degr√© 2. ',
      'Si Oui, donner \\(a\\), \\(b\\) et \\(c\\). Sinon, laisser \\(a\\), \\(b\\), \\(c\\) vides.</div>',
      '<table class="table"><thead><tr><th></th><th>Expression</th><th>Trin√¥me ?</th><th>a</th><th>b</th><th>c</th><th>Valider</th></tr></thead><tbody>',
      (st.items||[]).map((it,i)=>`
        <tr data-i="${i}">
          <td><strong>${String.fromCharCode(97+i)}.</strong></td>
          <td class="expr">${L('f(x) = ' + it.exprTex)}</td>
          <td>
            <select class="yn">
              <option>Oui</option><option selected>Non</option>
            </select>
          </td>
          <td><input class="a" type="text" inputmode="numeric" style="width:70px"></td>
          <td><input class="b" type="text" inputmode="numeric" style="width:70px"></td>
          <td><input class="c" type="text" inputmode="numeric" style="width:70px"></td>
          <td><button class="btn btn-row">Valider</button></td>
        </tr>`).join(''),
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    host.dataset.state=JSON.stringify(st);
    host.addEventListener('click',e=>{
      const b=e.target.closest('.btn-row'); if(!b) return;
      const tr=b.closest('tr'); checkRowEx1(host,tr,true);
    });
    typesetAll(host);
  },
  correct(host,st){
    let ok=0, tot=0; $$('.table tbody tr',host).forEach(tr=>{ const r=checkRowEx1(host,tr,true); if(r){ ok+=r.ok; tot+=r.total; }});
    $('#res',host).innerHTML = `<div class="steps"><div class="step">R√©sultat : <b>${ok} / ${tot}</b></div></div>`;
    typesetAll(host);
    return {ok,total:tot};
  },
  solution(host,st){
    const items=(st&&st.items)||[];
    const html = items.map((it,i)=>{
      const src = it.exprTex;
      const ord = polyLatexDesc(it.poly||[]);
      const lines = [
        `<div class="step">${L('f(x) = '+src)}</div>`,
        `<div class="step">${L('f(x) = '+ord)}</div>`,
        `<div class="step">${degreePhraseFr(it)}</div>`
		];
      const dedup = lines.filter((s,idx,a)=> idx===0 || s!==a[idx-1]);
      return `<div class="step" style="margin-top:.25rem"><strong>(${String.fromCharCode(97+i)})</strong></div>` + dedup.join('');
    }).join('');

    $('#res',host).innerHTML = `<div class="steps">${html}</div>`;
    typesetAll($('#res',host));
  },
  reset(host){ $('#res',host).textContent=''; }
};

function checkRowEx1(host,row,count){
  const st=JSON.parse(host.dataset.state||'{}'); const i=+row.dataset.i;
  const it=st.items && st.items[i]; if(!it) return null;
  const yn=$('.yn',row).value;
  const a=$('.a',row).value.trim(), b=$('.b',row).value.trim(), c=$('.c',row).value.trim();
  const answered=(yn==='Non' && !a && !b && !c) || (yn==='Oui' && a!=='' && b!=='' && c!=='');
  if(!answered){ row.style.outline=''; return null; }
  let good=false;
  if(yn==='Non') good = !it.isQuad && !a && !b && !c;
  if(yn==='Oui') good = it.isQuad && (+a===it.a && +b===it.b && +c===it.c);
  row.style.outline = good?'2px solid #11823b55':'2px solid #b0002050';
  if(count){ scoreTot++; if(good) scoreOK++; updateScore(); }
  return {ok:good?1:0,total:1};
}
// Marque une √©tape pour ne pas l‚Äôafficher dans la solution
function omitStep(s){ return { __omit: true, text: s }; }

/* ===================== Exercice 2 ===================== */
const ex2={
  id:'p2',
  title:'D√©velopper 6 expressions (si trin√¥me, donner a, b, c)',
  gen(){
    const cases=[];
    const UMIN = '-';

    /* 1) (ax+b)(cx+d) ‚Äî degr√© 2 ‚Äî version d√©taill√©e */
    (function(){
      let a = rnd(-5,5); while(a===0) a = rnd(-5,5);
      let c = rnd(-5,5); while(c===0) c = rnd(-5,5);
      const b = rnd(-5,5), d = rnd(-5,5);
      const A=[b,a], B=[d,c];
      const P = DevRules.polyMul(A,B);

      const ax = (a===1? 'x' : (a===-1? '-x' : (a+'x')));
      const bx = (b===0? '' : ((b>0?' + ':' - ') + Math.abs(b)));
      const Btex = polyLatexDesc(B);

      let step2 = `f(x) = ${ax}\\,\\big(${Btex}\\big)`;
      if (b !== 0){
        const bfac = (Math.abs(b)===1? '' : String(Math.abs(b)));
        step2 += (b>0? ' + ' : ' - ') + bfac + `\\,\\big(${Btex}\\big)`;
      }

      const four = [
        {c:a*c, p:2},
        {c:a*d, p:1},
        {c:b*c, p:1},
        {c:b*d, p:0}
      ];

      const steps = [
  `f(x) = \\big(${polyLatexDesc(A)}\\big)\\,\\big(${Btex}\\big)`,
  omitStep(step2),                        // ‚üµ masque la ligne ax(‚Ä¶)+b(‚Ä¶)
  `f(x) = ${sumTermsLatex(four)}`,
  `f(x) = ${polyLatexDesc(P)}`
];


      cases.push({ isQuad:true, poly:P, tex:`\\big(${polyLatexDesc(A)}\\big)\\,\\big(${Btex}\\big)`, steps });
    })();

    /* 2) (ax+b)^2 ‚àí (ax‚àíb)^2 ‚Äî degr√© 1 */
    (function(){
      let a = rnd(-5,5); while(a===0) a = rnd(-5,5);
      let b = rnd(-5,5); while(b===0) b = rnd(-5,5);
      const A=[b,a], B=[-b,a];
      const A2=DevRules.polyMul(A,A), B2=DevRules.polyMul(B,B);
      const P=[0, 4*a*b];

      const six = [
        {c:a*a,p:2},{c:2*a*b,p:1},{c:b*b,p:0},
        {c:-a*a,p:2},{c:2*a*b,p:1},{c:-b*b,p:0}
      ];

      const steps = [
        `f(x) = \\big(${polyLatexDesc(A)}\\big)^{2} - \\big(${polyLatexDesc(B)}\\big)^{2}`,
        `f(x) = \\big(${polyLatexDesc(A2)}\\big) - \\big(${polyLatexDesc(B2)}\\big)`,
        `f(x) = ${sumTermsLatex(six)}`,
        `f(x) = ${polyLatexDesc(P)}`
      ];

      cases.push({ isQuad:false, poly:P, tex:`\\big(${polyLatexDesc(A)}\\big)^{2} - \\big(${polyLatexDesc(B)}\\big)^{2}`, steps });
    })();

    /* 3) k(x+p)^2 + (l x + m) ‚Äî degr√© 2 */
    (function(){
// k ‚â† 0 et k ‚â† 1 (k = -1 reste autoris√©)
      let k = rnd(-5,5); while(k===0 || k===1) k = rnd(-5,5);      
	  let p = rnd(-5,5); while(p===0) p = rnd(-5,5);
      const l = rnd(-5,5), m = rnd(-5,5);

      const A=[p,1], B=[m,l];
      const A2=DevRules.polyMul(A,A);
      const P=[k*p*p + m, 2*k*p + l, k];

      const five = [
        {c:k, p:2},
        {c:2*k*p, p:1},
        {c:k*p*p, p:0},
        {c:l, p:1},
        {c:m, p:0}
      ];

      const ktex = (k===-1? '-' : String(k));
      const steps = [
        `f(x) = ${ktex}\\,\\big(${polyLatexDesc(A)}\\big)^{2} + \\big(${polyLatexDesc(B)}\\big)`,
        `f(x) = ${ktex}\\,\\big(${polyLatexDesc(A2)}\\big) + \\big(${polyLatexDesc(B)}\\big)`,
        `f(x) = ${sumTermsLatex(five)}`,
        `f(x) = ${polyLatexDesc(P)}`
      ];

      cases.push({ isQuad:true, poly:P, tex:`${ktex}\\,\\big(${polyLatexDesc(A)}\\big)^{2} + \\big(${polyLatexDesc(B)}\\big)`, steps });
    })();

    /* 4) (x+u)(x+v)(x+w) ‚Äî degr√© 3 */
    (function(){
      const u=rnd(-5,5), v=rnd(-5,5), w=rnd(-5,5);
      const A=[u,1], B=[v,1], C=[w,1];
      const AB=DevRules.polyMul(A,B);
      const P=DevRules.polyMul(AB,C);

      const uv=u*v, uPv=u+v;
      let step3 = `f(x) = x^{2}\\,\\big(${polyLatexDesc(C)}\\big)`;
      if (uPv!==0) step3 += (uPv>0?' + ':' - ') + (Math.abs(uPv)===1?'x':(Math.abs(uPv)+'x')) + `\\,\\big(${polyLatexDesc(C)}\\big)`;
      if (uv)      step3 += (uv>0?' + ':' - ') + parenIfNegNum(Math.abs(uv)) + `\\,\\big(${polyLatexDesc(C)}\\big)`;

      const six = [
        {c:1, p:3},
        {c:w, p:2},
        {c:u+v, p:2},
        {c:(u+v)*w, p:1},
        {c:u*v, p:1},
        {c:u*v*w, p:0}
      ];

     const steps = [
  `f(x) = \\big(${polyLatexDesc(A)}\\big)\\,\\big(${polyLatexDesc(B)}\\big)\\,\\big(${polyLatexDesc(C)}\\big)`,
  `f(x) = \\big(${polyLatexDesc(AB)}\\big)\\,\\big(${polyLatexDesc(C)}\\big)`,
  omitStep(step3),                        // ‚üµ masque x¬≤(‚Ä¶)+(u+v)x(‚Ä¶)+uv(‚Ä¶)
  `f(x) = ${sumTermsLatex(six)}`,
  `f(x) = ${polyLatexDesc(P)}`
];


      cases.push({ isQuad:false, poly:P, tex:`\\big(${polyLatexDesc(A)}\\big)\\,\\big(${polyLatexDesc(B)}\\big)\\,\\big(${polyLatexDesc(C)}\\big)`, steps });
    })();

    /* 5) (ax+u-b)^2 + (ax-u-b)^2 ‚Äî degr√© 2 (via d1, d2) */
    (function(){
      let a=rnd(-5,5); while(a===0) a=rnd(-5,5);
      let u=rnd(-5,5);
      let b=rnd(-5,5); while(b===u || b===-u) b=rnd(-5,5);

      const d1=u-b, d2=-(u+b);
      const L1=[d1,a], L2=[d2,a];
      const L1sq=DevRules.polyMul(L1,L1), L2sq=DevRules.polyMul(L2,L2);
      const P=[ 2*(u*u + b*b), -4*a*b, 2*a*a ];

      const six = [
        {c:a*a,p:2},{c:2*a*d1,p:1},{c:d1*d1,p:0},
        {c:a*a,p:2},{c:2*a*d2,p:1},{c:d2*d2,p:0}
      ];

      const steps = [
        `f(x) = \\big(${polyLatexDesc(L1)}\\big)^{2} + \\big(${polyLatexDesc(L2)}\\big)^{2}`,
        `f(x) = \\big(${polyLatexDesc(L1sq)}\\big) + \\big(${polyLatexDesc(L2sq)}\\big)`,
        `f(x) = ${sumTermsLatex(six)}`,
        `f(x) = ${polyLatexDesc(P)}`
      ];

      cases.push({ isQuad:true, poly:P, tex:`\\big(${polyLatexDesc(L1)}\\big)^{2} + \\big(${polyLatexDesc(L2)}\\big)^{2}`, steps });
    })();

    /* 6) (x+u)^2 (x+v)^2 ‚Äî degr√© 4 */
    (function(){
      const u=rnd(-3,3), v=rnd(-3,3);
      const A=[u,1], B=[v,1];
      const A2=DevRules.polyMul(A,A), B2=DevRules.polyMul(B,B);
      const P=DevRules.polyMul(A2,B2);

      const B2tex=polyLatexDesc(B2);
      const sCoeff = (k, monome) => {
        const s = k>=0 ? ' + ' : ' - ';
        const A=Math.abs(k);
        return s + (A===1 && monome ? monome : (A + (monome||'')));
      };
      let step4 = `f(x) = x^{2}\\,\\big(${B2tex}\\big)`;
      if (2*u) step4 += sCoeff(2*u, 'x') + `\\,\\big(${B2tex}\\big)`;
      if (u*u) step4 += sCoeff(u*u,  '') + `\\,\\big(${B2tex}\\big)`;

      const nine = [
        {c:1,p:4},{c:2*v,p:3},{c:v*v,p:2},
        {c:2*u,p:3},{c:4*u*v,p:2},{c:2*u*v*v,p:1},
        {c:u*u,p:2},{c:2*u*u*v,p:1},{c:u*u*v*v,p:0}
      ];

      const steps = [
  `f(x) = \\big(${polyLatexDesc(A)}\\big)^{2}\\,\\big(${polyLatexDesc(B)}\\big)^{2}`,
  `f(x) = \\big(${polyLatexDesc(A2)}\\big)\\,\\big(${polyLatexDesc(B2)}\\big)`,
  omitStep(step4),                        // ‚üµ masque la grande ligne de distribution
  `f(x) = ${sumTermsLatex(nine)}`,
  `f(x) = ${polyLatexDesc(P)}`
];


      cases.push({ isQuad:false, poly:P, tex:`\\big(${polyLatexDesc(A)}\\big)^{2}\\,\\big(${polyLatexDesc(B)}\\big)^{2}`, steps });
    })();

    cases.sort(()=>Math.random()-.6);

    const picked = cases.slice(0,6).map(it=>{
      const P = it.poly || [];
      const d = degOf(P);
      if(d === 2){
        it.isQuad = true;
        it.a = P[2] || 0;
        it.b = P[1] || 0;
        it.c = P[0] || 0;
      }
      return it;
    });
    return {cases: picked};
  },
  render(host,st){
    host.innerHTML=[
      '<div>Pour chaque expression : d√©velopper et r√©duire. Si le r√©sultat est un trin√¥me, indiquer \\(a\\), \\(b\\), \\(c\\). Sinon, laisser \\(a\\), \\(b\\), \\(c\\) vides.</div>',
      '<table class="table"><thead><tr><th></th><th>Expression</th><th>D√©veloppement</th><th>a</th><th>b</th><th>c</th><th>Valider</th></tr></thead><tbody>',
      (st.cases||[]).map((it,i)=>`
        <tr data-i="${i}">
          <td><strong>${String.fromCharCode(97+i)}.</strong></td>
          <td class="expr">${L('f(x) = '+it.tex)}</td>
          <td><input class="dev" type="text" placeholder="forme d√©velopp√©e"/></td>
          <td><input class="a" type="text" inputmode="numeric" style="width:70px"></td>
          <td><input class="b" type="text" inputmode="numeric" style="width:70px"></td>
          <td><input class="c" type="text" inputmode="numeric" style="width:70px"></td>
          <td><button class="btn btn-row">Valider</button></td>
        </tr>`).join(''),
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    host.dataset.state=JSON.stringify(st);
    host.addEventListener('click',e=>{
      const b=e.target.closest('.btn-row'); if(!b) return;
      const tr=b.closest('tr'); checkRowEx2(host,tr,true);
    });
    typesetAll(host);
  },
  correct(host,st){
    const rows=$$('.table tbody tr',host); let ok=0, tot=0;
    rows.forEach(tr=>{ const r=checkRowEx2(host,tr,true); if(r){ok+=r.ok; tot+=r.total;} });
    $('#res',host).innerHTML=`<div class="steps"><div class="step">R√©sultat : <b>${ok} / ${tot}</b></div></div>`;
    typesetAll(host);
    return {ok,total:tot};
  },
  solution(host,st){
    const arr=(st&&st.cases)||[];
    const S = arr.map((it,i)=>{
      
const raw = it.steps || [];

// 1) on enl√®ve les √©tapes marqu√©es {__omit:true}
const kept = raw
  .filter(s => !(s && typeof s === 'object' && s.__omit))
  .map(s => (typeof s === 'string' ? s : s.text));

// 2) normalisation + d√©doublonnage
const norm  = kept.map(s => fixSigns(s));
const dedup = norm.filter((s, i, a) => i === 0 || s !== a[i - 1]);

// 3) rendu
const chain = dedup.map(s => `<div class="step">${L(s)}</div>`).join('');
      const end = `<div class="step">${degreePhraseFr(it)}</div>`;

      return `<div class="step" style="margin-top:.25rem"><strong>${String.fromCharCode(97+i)})</strong></div>${chain}${end}`;
    }).join('');
    $('#res',host).innerHTML=`<div class="steps">${S}</div>`;
    typesetAll($('#res',host));
  },
  reset(host){ $('#res',host).textContent=''; }
};

function checkRowEx2(host,row,count){
  const st=JSON.parse(host.dataset.state||'{}'); const i=+row.dataset.i;
  const ex=st.cases&&st.cases[i]; if(!ex){ row.style.outline=''; return null; }
  const dev=$('.dev',row).value.trim(), a=$('.a',row).value.trim(), b=$('.b',row).value.trim(), c=$('.c',row).value.trim();
  if(!dev){ row.style.outline=''; return null; }
  let good = equalPolyVsExpr(ex.poly, dev);
  if(ex.isQuad){ good = good && (+a===ex.a && +b===ex.b && +c===ex.c); }
  else { good = good && (!a && !b && !c); }
  row.style.outline = good?'2px solid #11823b55':'2px solid #b0002050';
  if(count){ scoreTot++; if(good) scoreOK++; updateScore(); }
  return {ok:good?1:0,total:1};
}

/* ===== registre + UI ===== */
const REGISTRY=[ex1,ex2]; window.REGISTRY=REGISTRY;
function getDefById(id){ return REGISTRY.find(d=>d.id===id) || REGISTRY[0]; }

function buildOne(){
  const id=$("#exo-select").value;
  const def=getDefById(id), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd && MathKbd.attachAllInputs){ MathKbd.attachAllInputs(host); } }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st); scoreOK+=r.ok; scoreTot+=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

whenReady(function(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map(ex=>`<option value="${ex.id}">${ex.id==='p1'?'1':'2'} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange=buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value='p1';
  buildOne();

  /* ===== PDF : √©nonc√© = √©quation + TABLEAU ; correction = bloc gris sans tableau ===== */
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: document.title,
      max: 40,
      mountAfterSelector: '.card.small',
      beforeRender(def, st, withSolutions){
        const tmp=document.createElement('div'); tmp.style.position='fixed'; tmp.style.left='-10000px'; document.body.appendChild(tmp);
        const PRINT_STYLES = `
          <style>
            .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
            .table, .table th, .table td{border:1px solid #000;border-collapse:collapse}
          </style>`;
        try{
          def.render(tmp, st);
// Toujours inclure le 1er bloc d‚Äô√©nonc√© (le <div> au-dessus du tableau)
const firstBlock = Array.from(tmp.children).find(el => el.tagName !== 'TABLE');
const equ = firstBlock || null;
          const tbl = cloneTableForPDF(tmp);
          const statement = PRINT_STYLES + (equ?equ.outerHTML:'') + (tbl?('<div class="step" style="margin-top:6px">'+tbl+'</div>'):'');
          if(!withSolutions){ tmp.remove(); return statement; }

          try{ def.solution(tmp, st); }catch(_){}
          const solHTML = (tmp.querySelector('#res')||tmp).innerHTML;
          tmp.remove();
          return { statement, solution: PRINT_STYLES + solHTML };
        }catch(e){ tmp.remove(); return withSolutions?{statement:'',solution:'Corrig√© indisponible'}:'√ânonc√© indisponible'; }
      }
    });
  }
}); // whenReady
})(); // IIFE
</script>
</body>
</html>
