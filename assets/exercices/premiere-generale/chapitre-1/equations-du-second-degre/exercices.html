<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Premi√®re - Chapitre 1 ‚Äì √âquations du second degr√© (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  
  /* Espace horizontal entre x1 et x2 */
.table.xgap{
  border-collapse: separate;      /* au lieu de collapse */
  border-spacing: 20px 0;         /* ‚Üê espace entre les 2 colonnes */
}
.table.xgap th,
.table.xgap td{ border:1px solid #e5e5e5; padding:8px 12px; }

/* Optionnel : √©viter que les grandes formules se collent */
.table.xgap td{ min-width: 240px; white-space: nowrap; }

/* Un poil plus large dans le PDF si tu veux */
@media print{ .table.xgap{ border-spacing: 24px 0; } }

  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .step{margin:.2rem 0}
  .line{white-space:nowrap}
  .tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
  .tick.ok{color:#11823b}.tick.ko{color:#b00020}
  
  .answers{ display:flex; flex-wrap:wrap; gap:.4rem .5rem; }
  .answers .qa-row{
    flex-basis:100%;
    display:flex; 
    align-items:center; 
    gap:.4rem;
    margin-top:.35rem;
  }
  .answers .qa-row label{ margin-right:.3rem; }

  @media print{ .controls{display:none !important;} }
  /* +++ Espacement vertical des lignes de calcul +++ */
.table td .line,
.steps .line{
  margin: .32rem 0;      /* espace entre deux lignes */
  line-height: 1.9;      /* interligne interne aux formules */
}

/* S√©curit√© pour les fractions/racines qui ‚Äúdescendent‚Äù un peu */
.table td .line mjx-container{   /* √©l√©ment racine rendu par MathJax v3 */
  padding-bottom: .08em;
}

@media print{
  .table td .line,
  .steps .line{ 
    margin: .36rem 0;
    line-height: 2;
  }
}

</style>

<!-- MathJax (rendu LaTeX \( ... \) ) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem"><strong>Premi√®re - Chapitre 1 ‚Äì √âquations du second degr√©</strong> </h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Entr√©e ‚èé d√©clenche <b>V√©rifier</b>.</li>
        <li>Fractions possibles : √©crire <code>a/b</code> (affichage en \\(\\frac{a}{b}\\) c√¥t√© solution).</li>
        <li>√âviter <b>1x</b>, <b>‚àí1x</b>, <b>+0</b>, <b>‚àí0</b> ; l‚Äôoutil corrige et v√©rifie ces cas.</li>
        <li>Puissances : <code>x^2</code>, <code>x¬≤</code>, ‚Ä¶</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- D√©pendances -->
  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
  <script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

  <!-- === JS ‚Äî LaTeX only === -->
  <script>
'use strict';

  /* ===== Utilities ===== */
  const $  = (s,r)=> (r||document).querySelector(s);
  const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
  let scoreOK=0, scoreTot=0;
  function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
  const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const choice=a=>a[Math.floor(Math.random()*a.length)];
  const UMINUS = (window.DevRules && DevRules.consts && DevRules.consts.UMINUS) || '‚àí';
  function scanFractions(root){ try{ if(window.FractionSignClarity && FractionSignClarity.scan){ FractionSignClarity.scan(root||document); } }catch(_){ } }

  /* ===== Math helpers ===== */
  function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t;}return a||1;}
  function isSquare(n){ if(n<0) return false; const r=Math.floor(Math.sqrt(n)); return r*r===n; }

  // --- LaTeX helpers (inspir√© de ¬´ exercices - LATEX.html ¬ª) ---
  const wrap = tex => `\\(${tex}\\)`;
  const pm = k => k>0 ? ' + ' : ' - ';
  function simp(p,q){ if(q<0){p=-p;q=-q;} const g=gcd(Math.abs(p),Math.abs(q)); return [p/g,q/g]; }
  function texRatCore(p,q){
    const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
    if(q===1) return (neg?'-':'')+String(p);
    return (neg?'-':'')+`\\frac{${p}}{${q}}`;
  }
  function texRat([p,q]){ const s=simp(p,q); return texRatCore(s[0],s[1]); }
  function texRatRaw(p,q){ return texRatCore(p,q); }
  function texNum(n){ return String(n); }
  function texPow2(v){ return `${v}^{2}`; }
  function fmtAx2_tex(a){ return `2\\times ${a<0?`(${a})`:a}`; }
  function texPoly(a,b,c){
    // a x^2 + b x + c ‚Äî coefficients 0/¬±1 g√©r√©s
    let s='';
    if(a!==0){
      if(a===1) s = 'x^{2}';
      else if(a===-1) s = '-x^{2}';
      else s = `${a<0?'-':''}${Math.abs(a)}x^{2}`;
    }
    if(b!==0){
      const seg = (Math.abs(b)===1) ? 'x' : `${Math.abs(b)}x`;
      s += (s? (b>0?' + ':' - '): (b<0?'-':'')) + seg.replace(/^-/,''); 
    }
    if(c!==0){
      s += (s? (c>0?' + ':' - '): (c<0?'-':'')) + String(Math.abs(c));
    }
    return s || '0';
  }
const ax2 = a => (a===1 ? 'x^{2}' : a===-1 ? '-x^{2}' : `${a}x^{2}`);
const ax  = a => (a===1 ? 'x'     : a===-1 ? '-x'     : `${a}x`);

  /* ===== Numeric helpers ===== */
  function sqrtDecomp(N){ let k=1,n=N; for(let d=2; d*d<=n; d++){ while(n%(d*d)===0){ n/=d*d; k*=d; } } return [k,n]; }
  function numEval(expr){
    let s = String(expr||'').trim();
    s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*').replace(/‚àö/g,'Math.sqrt').replace(/\^/g,'**');
    s = s.replace(/(\\d),(\\d)/g,'$1.$2');
    // multiplications implicites
    s = s.replace(new RegExp("\\)\\s*\\(", "g"), ')*(')
         .replace(new RegExp("(\\d)\\s*\\(", "g"), '$1*(')
         .replace(new RegExp("\\)\\s*x", "g"), ')*x')
         .replace(new RegExp("x\\s*\\(", "g"), 'x*(')
         .replace(new RegExp("(\\d)\\s*x", "g"), '$1*x');
    try{ return Number(Function('"use strict";return ('+s+')')()); }catch(_){ return NaN; }
  }
  function almost(a,b,eps=1e-9){ return Math.abs(a-b)<=eps; }
  function poly(a,b,c,x){ return a*x*x + b*x + c; }

  /* ===== Helpers pour l'affichage en 4 lignes ===== */
  function pushIfNew(arr, html){ if(!arr.length || arr[arr.length-1]!==html) arr.push(html); }
function line(label, rhsTex){
  return '<div class="line" style="margin:.36rem 0; line-height:1.95">'
       + wrap(`${label} = ${rhsTex}`)
       + '</div>';
}

  /* ===== √ânonc√© ===== */
  function buildHostHTML(st){
    const P = texPoly(st.a,st.b,st.c);
    return `
      <div class="card">
        <div><strong>Soit</strong> ${wrap('P(x) = '+P)}. <strong>R√©soudre :</strong> ${wrap(P+' = 0')}</div>
        <div class="answers">
          <div class="qa-row">
            <label for="ansS"><strong>\\(S=\\)</strong></label>
            <input id="ansS" class="inp" placeholder="S = { ‚Ä¶ } ou ‚àÖ" style="min-width:280px">
            <span id="tickS" class="tick" style="margin-left:6px"></span>
          </div>

          <div class="qa-row">
            <label for="ansF"><strong>Forme factoris√©e (si possible) :</strong></label>
            <input id="ansF" class="inp" placeholder="(x ‚àí r1)(x ‚àí r2) ; (x ‚àí r)^2 ; ‚Ä¶" style="min-width:360px">
            <span id="tickF" class="tick" style="margin-left:6px"></span>
          </div>
        </div>
      </div>
      <div id="res"></div>
    `;
  }

  /* ===== Correction ===== */
  function solutionHTML(st){
  const a=st.a,b=st.b,c=st.c,D=st.delta;
  const out=[];
  out.push('<div class="step">'+wrap(`a=${a} \\; ;\\; b=${b} \\; \\text{et}\\; c=${c}`)+'</div>');

  { // Œî
      // calcul Œî
	  const A=st.a,B=st.b,C=st.c
  const prod4ac = 4 * A * C;
  const b2      = B * B;

  // √©criture du terme b¬≤ avec parenth√®ses si b<0
  // ex : b=-3 -> "(-3)^{2}"
  //      b=4  -> "4^{2}"
  const bSquaredTex = (B < 0)
    ? `(${B})^{2}`
    : `${B}^{2}`;

  // 4 √ó a √ó c avec parenth√®ses autour de a ou c si n√©gatifs
  const prettyProd = `4 \\times ${A<0?`(${A})`:A} \\times ${C<0?`(${C})`:C}`;

  // milieu apr√®s distribution du signe :
  // si 4ac est n√©gatif => b¬≤ + |4ac|
  // si 4ac est positif => b¬≤ - 4ac
  const middle = prod4ac < 0
    ? `${b2} + ${Math.abs(prod4ac)}`
    : `${b2} - ${prod4ac}`;

  const Delta   = b2 - prod4ac;
  const tail    = Delta>0 ? ' > 0' : (Delta<0 ? ' < 0' : ' ');
    out.push(`<div class="line" style="color:#b00020;font-weight:500">` +
          `\\(\\Delta = b^{2} - 4ac = ${bSquaredTex} - ${prettyProd} = ${middle} = ${Delta}${tail}\\)` +
          `</div>`);
  }

  // ===== Corps principal (inchang√© fonctionnellement) =====
  if(D<0){
    out.push('<div class="step">Ainsi l‚Äô√©quation n‚Äôadmet pas de solution r√©elle.</div>');
    out.push('<div class="step" style="text-align:center;font-weight:700">'+wrap('S = \\varnothing')+'</div>');
    out.push('<div class="step"><i>\\(P(x)\\)</i> n‚Äôa pas de forme factoris√©e.</div>');
  } else if(D===0){
    const L=[];
    L.push(line('\\alpha', `\\frac{-b}{2a}`));
    L.push(line('\\alpha', texRatRaw(-b, 2*a)));
    const g=gcd(Math.abs(-b), Math.abs(2*a));
    const Pn=(-b)/g, Qn=(2*a)/g;
    pushIfNew(L, line('\\alpha', Qn!==1 ? texRat([Pn,Qn]) : String(Pn)));
    const alpha = Pn/Qn;
    out.push('<div class="step">Ainsi l‚Äô√©quation admet une seule solution :</div>');
    out.push('<div class="step">'+L.join('')+'</div>');
    out.push('<div class="step" style="text-align:center;font-weight:700">'+wrap(`S = \\{ ${alpha} \\}`)+'</div>');
    const fac = `${a===1?'':String(a)}${a===1?'':'\\,'}\\left(x ${alpha<0?'+ '+Math.abs(alpha):'- '+Math.abs(alpha)}\\right)^{2}`;
    out.push('<div class="step">La forme factoris√©e est : '+wrap(`P(x) = ${fac}`)+'</div>');
  } else {
    function xiThreeLines(signPM){
      const label = signPM<0 ? 'x_{1}' : 'x_{2}';
      const pmS   = signPM<0 ? ' - '  : ' + ';
      const lines = [];
      lines.push(line(label, `\\frac{-b ${pmS} \\sqrt{\\Delta}}{2a}`));
      if(isSquare(D)){
        const r=Math.sqrt(D);
        lines.push(line(label, `\\frac{${-b} ${pmS} ${r}}{${fmtAx2_tex(a)}}`));
        const num = -b + (signPM<0 ? -r : r), den = 2*a;
        lines.push(line(label, texRatRaw(num, den)));
        const g=gcd(Math.abs(num), Math.abs(den));
        const Pn=num/g, Qn=den/g;
        pushIfNew(lines, line(label, Qn!==1 ? texRat([Pn,Qn]) : String(Pn)));
      } else {
        const [kfac,nrest]=sqrtDecomp(D);
        const num2 = `${-b} ${pmS} ${kfac>1 ? `${kfac}\\sqrt{${nrest}}` : `\\sqrt{${nrest}}`}`;
        lines.push(line(label, `\\frac{${num2}}{${fmtAx2_tex(a)}}`));
        lines.push(line(label, `\\frac{${num2}}{${2*a}}`));
        const g = gcd(gcd(Math.abs(b), Math.abs(kfac)), Math.abs(2*a));
        if(g>1){
          const num3 = `${(-b)/g} ${pmS} ${((kfac/g)>1) ? `${kfac/g}\\sqrt{${nrest}}` : `\\sqrt{${nrest}}`}`;
          pushIfNew(lines, line(label, `\\frac{${num3}}{${(2*a)/g}}`));
        }
      }
      return lines.join('');
    }

    if(isSquare(D)){
      out.push('<div class="step">Et '+wrap(`\\sqrt{\\Delta} = ${Math.sqrt(D)}`)+'</div>');
      out.push('<div class="step">Ainsi l‚Äô√©quation admet deux solutions r√©elles :</div>');
      const L = xiThreeLines(-1), R = xiThreeLines(+1);
      out.push(
        '<table class="table xgap" style="width:100%">' +
          '<thead><tr>' +
            '<th style="text-align:center; padding:8px 24px; border:1px solid #e5e5e5">\\(x_1\\)</th>' +
            '<th style="text-align:center; padding:8px 24px; border:1px solid #e5e5e5">\\(x_2\\)</th>' +
          '</tr></thead>' +
          '<tbody><tr>' +
            '<td style="vertical-align:top; padding:8px 28px; border:1px solid #e5e5e5; white-space:nowrap; line-height:1.95">'+L+'</td>' +
            '<td style="vertical-align:top; padding:8px 28px; border:1px solid #e5e5e5; white-space:nowrap; line-height:1.95">'+R+'</td>' +
          '</tr></tbody>' +
        '</table>'
      );
      const r=Math.sqrt(D); const x1 = (-b - r)/(2*a), x2 = (-b + r)/(2*a);
      const Ssorted = [x1,x2].sort((u,v)=>u-v);
      out.push('<div class="step" style="text-align:center;font-weight:700">'+wrap(`S = \\{ ${Ssorted[0]} \\; ; \\; ${Ssorted[1]} \\}`)+'</div>');
      const fac = `${a===1?'':String(a)}${a===1?'':'\\,'}\\left(x ${x1<0?'+ '+Math.abs(x1):'- '+Math.abs(x1)}\\right)\\left(x ${x2<0?'+ '+Math.abs(x2):'- '+Math.abs(x2)}\\right)`;
      out.push('<div class="step">La forme factoris√©e est : '+wrap(`P(x) = ${fac}`)+'</div>');
    } else {
      out.push('<div class="step">Et '+wrap(`\\sqrt{\\Delta} = \\sqrt{${D}}`)+'</div>');
      out.push('<div class="step">Ainsi l‚Äô√©quation admet deux solutions r√©elles :</div>');
      const L = xiThreeLines(-1), R = xiThreeLines(+1);
      out.push(
        '<table class="table xgap" style="width:100%">' +
          '<thead><tr>' +
            '<th style="text-align:center; padding:8px 24px; border:1px solid #e5e5e5">\\(x_1\\)</th>' +
            '<th style="text-align:center; padding:8px 24px; border:1px solid #e5e5e5">\\(x_2\\)</th>' +
          '</tr></thead>' +
          '<tbody><tr>' +
            '<td style="vertical-align:top; padding:8px 28px; border:1px solid #e5e5e5; white-space:nowrap">'+L+'</td>' +
            '<td style="vertical-align:top; padding:8px 28px; border:1px solid #e5e5e5; white-space:nowrap">'+R+'</td>' +
          '</tr></tbody>' +
        '</table>'
      );
      const [kfac,nrest]=sqrtDecomp(D);
      let den = 2*a; const gCommon = gcd(gcd(Math.abs(b), Math.abs(kfac)), Math.abs(den)); if(gCommon>1) den/=gCommon;
      const num1 = `${(-b/gCommon)||(-b)} - ${((kfac/gCommon)>1? (kfac/gCommon+`\\sqrt{${nrest}}`) : (`\\sqrt{${nrest}}`))}`;
      const num2 = `${(-b/gCommon)||(-b)} + ${((kfac/gCommon)>1? (kfac/gCommon+`\\sqrt{${nrest}}`) : (`\\sqrt{${nrest}}`))}`;
      const approx1 = (-b - Math.sqrt(D))/(2*a), approx2 = (-b + Math.sqrt(D))/(2*a);
      const pair = [{v:approx1, s:wrap(`\\frac{${num1}}{${den}}`)}, {v:approx2, s:wrap(`\\frac{${num2}}{${den}}`)}].sort((p,q)=>p.v-q.v);
      out.push('<div class="step" style="text-align:center;font-weight:700">'+`\\(S\\) = { ${pair[0].s} ; ${pair[1].s} }`+'</div>');
      const fac = `${a===1?'':String(a)}${a===1?'':'\\,'}\\left(x - ${pair[0].s.replace('\\(','').replace('\\)','')}\\right)\\left(x - ${pair[1].s.replace('\\(','').replace('\\)','')}\\right)`;
      out.push('<div class="step">La forme factoris√©e est : '+wrap(`P(x) = ${fac}`)+'</div>');
    }
  }

  // ===== Remarques int√©gr√©es (ex-remarkBlock) =====
 // --- push unique: √©vite d'afficher 2 fois la m√™me ligne cons√©cutive ---
function pushStepUnique(arr, innerHTML){
  const line = '<div class="step">'+innerHTML+'</div>';
  if (!arr.length || arr[arr.length-1] !== line) arr.push(line);
}

const R = [];
const pushR = s => pushStepUnique(R, s);   // ‚üµ remplace ton ancien pushR


  // Cas c = 0 (produit avec x)
  if(a!==0 && c===0 && b!==0){
    pushR('<b>Remarque :</b> Il est pr√©f√©rable d‚Äôutiliser la m√©thode suivante :');
    let eq = (a === 1) ? 'x^{2}' : (a === -1) ? '-x^{2}' : `${a}x^{2}`;
    if (b !== 0) eq += (b > 0 ? ' + ' : ' - ') + `${Math.abs(b)}x`;
    eq += ' = 0';
    pushR(wrap(eq));
    pushR(wrap(`x\\left(${a===1?'x':a===-1?'-x':(a+'x')} ${b>=0?'+':'-'} ${Math.abs(b)}\\right) = 0`));
    pushR(wrap(`x = 0 \\;\\text{ ou }\\; ${a===1?'x':a===-1?'-x':(a+'x')} ${b>=0?'+':'-'} ${Math.abs(b)} = 0`));
    const sAB = simp(-b,a);
    pushR(wrap(`x = 0 \\;\\text{ ou }\\; x = ${texRat(sAB)}`));
  }

  // Cas b = 0, c ‚â† 0  (x^2 = k)
  if(a!==0 && b===0 && c!==0){
    pushR('<b>Remarque :</b> Il est pr√©f√©rable d‚Äôutiliser la m√©thode suivante :');
   pushR(wrap(`${ax2(a)} ${c>=0?'+':'-'} ${Math.abs(c)} = 0`));
pushR(wrap(`${ax2(a)} = ${-c}`));

    const sAC = simp(-c,a);
    pushR(wrap(`x^{2} = ${texRat(sAC)}`));
    const t = (-c)/a;
    if(t<0){ pushR('Pas de solution r√©elle.'); }
    else if(t===0){ pushR(wrap('x = 0')); }
    else{
      const [pn,qn]=[Math.abs(sAC[0]), Math.abs(sAC[1])];
      const right = qn===1 ? String(pn) : `\\left( \\frac{${pn}}{${qn}} \\right)`;
      pushR(wrap(`x = -\\sqrt{${right}} \\;\\text{ ou }\\; x = \\sqrt{${right}}`));
      const rn = Math.sqrt(pn), rd = Math.sqrt(qn);
      if(Number.isInteger(rn) && Number.isInteger(rd)){
        const [sp,sq] = simp(rn|0, rd|0);
        if(sq===1){ pushR(wrap(`x = -${sp} \\;\\text{ ou }\\; x = ${sp}`)); }
        else{ pushR(wrap(`x = -${texRat([sp,sq])} \\;\\text{ ou }\\; x = ${texRat([sp,sq])}`)); }
      }
    }
  }

  // Cas b = 0, c = 0  (x^2 = 0)
  if(a!==0 && b===0 && c===0){
    pushR('<b>Remarque :</b> Il est pr√©f√©rable d‚Äôutiliser la m√©thode suivante :');
pushR(wrap(`${ax2(a)} = 0`));
    pushR(wrap(`x^{2} = 0`));
    pushR(wrap(`x = 0`));
  }

  // Cas Œî = 0 (factorisation au carr√© parfait)
  if(a!==0 && D===0){
    const sAB = simp(-b, 2*a);
    const alpha    = texRat(sAB);
    const alphaAbs = texRat([Math.abs(sAB[0]), sAB[1]]);
    const op = (sAB[0] < 0 ? ' + ' : ' - ');
    pushR('<b>Remarque :</b> On aurait pu utiliser la m√©thode suivante :');
const bx = b ? (b>0 ? ' + ' : ' - ') + (Math.abs(b)===1 ? 'x' : `${Math.abs(b)}x`) : '';
const cterm = c ? (c>0 ? ' + ' : ' - ') + `${Math.abs(c)}` : '';
pushR(wrap(`${ax2(a)}${bx}${cterm} = 0`));
    if (a !== 1) {
      const sb = simp(b, a), sc = simp(c, a);
      let termBx = '';
      if (b !== 0) {
        const signB = (sb[0] >= 0 ? ' + ' : ' - ');
        const magB  = Math.abs(sb[0]) === sb[1] ? '' : texRat([Math.abs(sb[0]), sb[1]]);
        termBx = signB + magB + 'x';
      }
      let termC  = '';
      if (c !== 0) {
        const signC = (sc[0] >= 0 ? ' + ' : ' - ');
        const magC  = texRat([Math.abs(sc[0]), sc[1]]);
        termC = signC + magC;
      }
      pushR(wrap(`${a}\\left(x^{2}${termBx}${termC}\\right) = 0`));
    }
    if (a !== 1) { pushR(wrap(`${a}\\left(x${op}${alphaAbs}\\right)^{2} = 0`)); }
    if (sAB[0] === 0) { pushR(wrap(`x^{2} = 0`)); pushR(wrap(`x = 0`)); }
    else { pushR(wrap(`\\left(x${op}${alphaAbs}\\right)^{2} = 0`)); pushR(wrap(`x${op}${alphaAbs} = 0`)); pushR(wrap(`x = ${alpha}`)); }
  }

  // ===== Jointure finale =====
  // Nettoyage petites collisions " + ‚àí " etc.
  let html = '<div class="steps">'+out.join('')+(R.length?('<div class="sep" style="height:1px;background:#e5e7eb;margin:.4rem 0"></div>'+R.join('')):'')+'</div>';
  html = html.replace(/\+\s*‚àí/g,' ‚àí ').replace(/‚àí\s*‚àí/g,' + ').replace(/‚àí\s*\+/g,' ‚àí ');
  return html;
}


  /* ===== V√©rification ===== */
  function parseSetInput(val){
    if(!val) return {empty:false, items:[]};
    let s = String(val).trim();
    s = s.replace(/^S\\s*=\\s*/i,'').trim();
    if (s==='‚àÖ' || /\\b(vide|aucun|aucune)\\b/i.test(s) || /ensemble\\s*vide/i.test(s)) return {empty:true, items:[]};
    s = s.replace(/^[{]/,'').replace(/[}]$/,'');
    if(!s.trim()) return {empty:false, items:[]};
    const items = s.split(/[;,]+/).map(t=>t.trim()).filter(Boolean);
    return {empty:false, items};
  }
  function setOK_S(a,b,c,delta, inp){
    const parsed = parseSetInput(inp);
    if(delta<0){
      return parsed.empty || parsed.items.length===0 || /‚àÖ/.test(inp);
    }
    const D = delta, r1 = (-b - Math.sqrt(D))/(2*a), r2 = (-b + Math.sqrt(D))/(2*a);
    const target = D===0 ? [r1] : [r1,r2];
    const nums = parsed.items.map(t=> numEval(t)).filter(v=> Number.isFinite(v));
    if(nums.length !== target.length) return false;
    const used = new Array(nums.length).fill(false);
    for(const t of target){
      let ok=false;
      for(let i=0;i<nums.length;i++){
        if(used[i]) continue;
        if(almost(nums[i], t, 1e-6)){ used[i]=true; ok=true; break; }
      }
      if(!ok) return false;
    }
    return true;
  }
  function evalFactorizedAt(expr,x){
    if(!expr) return NaN;
    let s = String(expr);
    s = s.replace(/‚àí/g,'-')
         .replace(/[√ó¬∑]/g,'*')
         .replace(/\\^/g,'**')
         .replace(/‚àö/g,'Math.sqrt')
         .replace(/sqrt/gi,'Math.sqrt');
    // * implicites
    s = s.replace(new RegExp("\\)\\s*\\(", "g"), ')*(')
         .replace(new RegExp("(\\d)\\s*\\(", "g"), '$1*(')
         .replace(new RegExp("\\)\\s*x", "g"), ')*x')
         .replace(new RegExp("x\\s*\\(", "g"), 'x*(')
         .replace(new RegExp("(\\d)\\s*x", "g"), '$1*x');
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
    try{ return Function('"use strict";return ('+s+')')(); }catch(_){ return NaN; }
  }
  function factorOK_S(a,b,c,delta, inp){
    if(!inp || !String(inp).trim()) return (delta<0);
    if(delta<0 && /non\\s*factoris/i.test(inp)) return true;
    if(delta<0 && /aucune/i.test(inp)) return true;
    const xs = [-3,-1,0,1,2,3,4];
    for(const x of xs){
      const got = evalFactorizedAt(inp, x);
      const ref = poly(a,b,c,x);
      if(!Number.isFinite(got) || Math.abs(got-ref)>1e-6) return false;
    }
    return true;
  }

  /* ===== G√©n√©rateurs ===== */
  function polyFromRoots(a, r1, r2){ return {a:a, b:-a*(r1+r2), c:a*r2*r1}; }
  function genDeltaPosSquare(){ const a=choice([1,-1,2,-2]); let r1=rnd(-8,8), r2=rnd(-8,8); while(r2===r1){ r2=rnd(-8,8); } const p=polyFromRoots(a,r1,r2); const delta=p.b*p.b-4*p.a*p.c; return {a:p.a,b:p.b,c:p.c,delta, kind:'D>0 (carr√© parfait)'}; }
  function genDeltaNeg(){ let a,b,c,D; for(let tries=0;tries<999;tries++){ a=choice([1,2,-1,-2]); b=rnd(-10,10); c=rnd(-10,10); D=b*b-4*a*c; if(D<0) return {a,b,c,delta:D, kind:'D<0'}; } return {a:1,b:2,c:5,delta:-16, kind:'D<0'}; }
  function genDeltaZero(){ const a=choice([1,2,-1,-2]); const r=rnd(-8,8); const p=polyFromRoots(a,r,r); return {a:p.a,b:p.b,c:p.c,delta:0, kind:'D=0'}; }
  function genDeltaPosNonSquare(){ let a,b,c,D; for(let tries=0;tries<999;tries++){ a=choice([1,2,-1,-2]); b=rnd(-12,12); c=rnd(-12,12); D=b*b-4*a*c; if(D>0 && !isSquare(D)) return {a,b,c,delta:D, kind:'D>0 (pas carr√©)'}; } return {a:1,b:1,c:-1,delta:5, kind:'D>0 (pas carr√©)'}; }

  /* ===== Affichage des ‚úì/‚úó pr√®s des champs ===== */
  function setTicks(host, tS, tF){
    const setTick=(sel,val)=>{ const el=$(sel,host); if(!el) return;
      el.className='tick '+(val===true?'ok':val===false?'ko':''); el.textContent=(val===true?'‚úì':val===false?'‚úó':'‚Äî');
    };
    setTick('#tickS', tS);
    setTick('#tickF', tF);
  }

  /* ===== Exercices ===== */
  const exDposPF = { id:'dpospf', title:'Œî > 0 (carr√© parfait)',
    gen(host){ const st=genDeltaPosSquare(); host.innerHTML=buildHostHTML(st); host.dataset.state=JSON.stringify(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    correct(host, st){
      const Sval=$('#ansS',host)?.value||''; const Fval=$('#ansF',host)?.value||'';
      const hasS=Sval.trim().length>0, hasF = (Fval.trim().length>0) || (st.delta<0);
      let add=0, ok=0; let tS=null,tF=null;
      if(hasS){ tS=setOK_S(st.a,st.b,st.c,st.delta,Sval); add++; ok+= tS?1:0; }
      if(hasF){ tF=factorOK_S(st.a,st.b,st.c,st.delta,Fval); add++; ok+= tF?1:0; }
      scoreTot+=add; scoreOK+=ok; updateScore();
      setTicks(host, hasS?tS:null, hasF?tF:null);
    },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTicks(host,null,null); }
  };
  const exDneg = { id:'dneg', title:'Œî < 0',
    gen(host){ const st=genDeltaNeg(); host.innerHTML=buildHostHTML(st); host.dataset.state=JSON.stringify(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    correct(host, st){
      const Sval=$('#ansS',host)?.value||''; const Fval=$('#ansF',host)?.value||'';
      const hasS=Sval.trim().length>0, hasF = (Fval.trim().length>0) || (st.delta<0);
      let add=0, ok=0; let tS=null,tF=null;
      if(hasS){ tS=setOK_S(st.a,st.b,st.c,st.delta,Sval); add++; ok+= tS?1:0; }
      if(hasF){ tF=factorOK_S(st.a,st.b,st.c,st.delta,Fval); add++; ok+= tF?1:0; }
      scoreTot+=add; scoreOK+=ok; updateScore();
      setTicks(host, hasS?tS:null, hasF?tF:null);
    },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTicks(host,null,null); }
  };
  const exDzero = { id:'dzero', title:'Œî = 0',
    gen(host){ const st=genDeltaZero(); host.innerHTML=buildHostHTML(st); host.dataset.state=JSON.stringify(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    correct(host, st){
      const Sval=$('#ansS',host)?.value||''; const Fval=$('#ansF',host)?.value||'';
      const hasS=Sval.trim().length>0, hasF = (Fval.trim().length>0) || (st.delta<0);
      let add=0, ok=0; let tS=null,tF=null;
      if(hasS){ tS=setOK_S(st.a,st.b,st.c,st.delta,Sval); add++; ok+= tS?1:0; }
      if(hasF){ tF=factorOK_S(st.a,st.b,st.c,st.delta,Fval); add++; ok+= tF?1:0; }
      scoreTot+=add; scoreOK+=ok; updateScore();
      setTicks(host, hasS?tS:null, hasF?tF:null);
    },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTicks(host,null,null); }
  };
  const exMix = { id:'mix', title:'M√©lange',
    gen(host){
      const r=Math.random(); let st;
      if(r<0.40) st=genDeltaPosSquare();
      else if(r<0.55) st=genDeltaNeg();
      else if(r<0.80) st=genDeltaZero();
      else st=genDeltaPosNonSquare();
      host.innerHTML=buildHostHTML(st); host.dataset.state=JSON.stringify(st);
      if (window.MathJax?.typeset) MathJax.typeset();
    },
    correct(host, st){
      const Sval=$('#ansS',host)?.value||''; const Fval=$('#ansF',host)?.value||'';
      const hasS=Sval.trim().length>0, hasF = (Fval.trim().length>0) || (st.delta<0);
      let add=0, ok=0; let tS=null,tF=null;
      if(hasS){ tS=setOK_S(st.a,st.b,st.c,st.delta,Sval); add++; ok+= tS?1:0; }
      if(hasF){ tF=factorOK_S(st.a,st.b,st.c,st.delta,Fval); add++; ok+= tF?1:0; }
      scoreTot+=add; scoreOK+=ok; updateScore();
      setTicks(host, hasS?tS:null, hasF?tF:null);
    },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTicks(host,null,null); }
  };

  const REG = [exDposPF, exDneg, exDzero, exMix];
  window.REG=REG; window.REGISTRY=REG;

  function mount(){
    const sel=$("#exo-select"); if(!sel) return;
    sel.innerHTML=REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');
    function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
    function newOne(){ const ex=get(); const host=$("#host"); ex.gen(host); scanFractions(host); }
    function check(){ const ex=get(); ex.correct($("#host"), JSON.parse($("#host").dataset.state||'{}')); }
    function sol(){ const ex=get(); ex.solution($("#host"), JSON.parse($("#host").dataset.state||'{}')); }
    function reset(){ const ex=get(); ex.reset($("#host")); }

    sel.onchange=newOne;
    $("#btn-new").onclick=newOne;
    $("#btn-check").onclick=check;
    $("#btn-solution").onclick=sol;
    $("#btn-reset").onclick=reset;

    document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});
    sel.value=REG[0].id; newOne();
  }
  document.addEventListener('DOMContentLoaded', mount);
  </script>

  <!-- === JS ‚Äî Remarques & Œî en LaTeX === -->


 <!-- === Adaptateur PDF c√¥t√© HTML (corrig√©) === -->
<script>
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
	        mountAfterSelector: '#host', // ‚üµ AJOUT ICI : le module sera ins√©r√© juste apr√®s #host

      beforeGen(def, _st, ctx){
        const host = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(host);
        let st = {};
        try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
        return st;
      },
      beforeRender(def, st, withSolutions){
        try{
          const host = document.createElement('div');
          host.id = 'pdf-host';
          host.style.position='fixed';
          host.style.left='-10000px';
          host.style.top='-10000px';
          document.body.appendChild(host);

          if (typeof window.buildHostHTML === 'function'){
            host.innerHTML = buildHostHTML(st);
          } else if (def && typeof def.render === 'function'){
            def.render(host, st);
          }
          host.dataset.state = JSON.stringify(st);

          if (withSolutions && def && typeof def.solution === 'function'){
            def.solution(host, st);
          }

          (host.querySelectorAll('input, textarea, select, [contenteditable="true"]')||[])
            .forEach(el=>{
              const t = document.createTextNode(el.value||' ');
              el.replaceWith(t);
            });

          const outHTML = withSolutions
            ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
            : host.innerHTML;

          document.body.removeChild(host);
          return outHTML;
        }catch(e){
          console.error('PDF beforeRender error:', e);
          return null;
        }
      }
    });
  });
})();
</script>

<!-- === SHIM universel (inchang√©) === -->
<script>
(function(){
  function isHost(x){ return x && x.nodeType===1; }
  function scaffold(host){
    if(!host) return;
    ['enonce','res','solution','statement'].forEach(function(id){
      if(!host.querySelector('#'+id)){ var d=document.createElement('div'); d.id=id; host.appendChild(d); }
    });
  }
  function wrapDef(def){
    if(!def || typeof def!=='object') return;

    // Wrap gen
    var oldGen = def.gen;
    if(typeof oldGen==='function'){
      def.gen = function(a,b){
        if(isHost(a)) return oldGen.call(this, a, b);
        var st = (a && typeof a==='object') ? a : (b && typeof b==='object' ? b : {});
        var host = document.createElement('div');
        scaffold(host);
        var r = oldGen.call(this, host, st);
        if(!host.dataset.state) try{ host.dataset.state = JSON.stringify(st||{}); }catch(_){}
        return host;
      };
      if(typeof def.render!=='function'){
        def.render = function(host, st){ scaffold(host); return oldGen.call(this, host, st); };
      }
    }

    var oldSol = def.solution;
    if(typeof oldSol==='function'){
      def.solution = function(a,b){
        if(isHost(a)) return oldSol.call(this, a, b);
        var st = (a && typeof a==='object') ? a : (b && typeof b==='object' ? b : {});
        var host = document.createElement('div'); scaffold(host);
        return oldSol.call(this, host, st);
      };
    }
  }

  function apply(){
    var list = (window.REGISTRY || window.REG || []);
    if(Array.isArray(list)) list.forEach(wrapDef);
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', apply); else apply();
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>