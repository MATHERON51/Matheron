<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Premi√®re ‚Äì Chapitre 1 ‚Äì Forme canonique ‚Äî Exercices (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  /* tableaux */
  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .table td:last-child,.table th:last-child{text-align:center;white-space:nowrap}

  /* zone solution */
  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .step{margin:.2rem 0}
  .small{color:#555}

  /* corrections */
  .corr-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .col{border:2px dotted #bbb;border-radius:12px;padding:12px}
  .col h4{margin:.2rem 0 .6rem;font-size:1rem}
  .hl{background:#fff3b0;padding:0 .2rem;border-radius:4px}
   .muted{color:#666}

  /* ‚úì / ‚úó */
  .tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
  .tick.ok{color:#11823b}
  .tick.ko{color:#b00020}

  /* ---- tableau variations compact ---- */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var tr > td:nth-child(2), table.var tr > th:nth-child(2){ border-right:none; }
  table.var tr > td:nth-child(3), table.var tr > th:nth-child(3){ border-left:none; border-right:none; }
  table.var tr > td:nth-child(4), table.var tr > th:nth-child(4){ border-left:none; }
  table.var tbody tr:first-child td:nth-child(3){ border-bottom:none; }
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* ====== D√©monstrations Q1/Q2 (table invisible 3 colonnes) ====== */
  .eq3{border-collapse:collapse;margin:.4rem 0}
  .eq3 td{border:none;padding:2px 6px;vertical-align:baseline}
  .eq3 .lhs{white-space:nowrap;font-weight:600}
  .eq3 .eq{width:1.2em;text-align:center}
  .eq3 .rhs{white-space:nowrap}
  .tbl3c{border-collapse:collapse;margin:.5rem 0}
  .tbl3c td{border:none;padding:2px 10px;vertical-align:baseline;white-space:nowrap}
  .tbl3c .eq{width:1.2em;text-align:center}
  
  /* table des √©quations (3 colonnes invisibles) */
.tbl3c { border-collapse: collapse; margin:.5rem 0; }
.tbl3c td { border:none; padding:2px 10px; vertical-align:baseline; white-space:nowrap; }
.tbl3c .eq { width:1.2em; text-align:center }

/* üëâ la cellule de gauche qui a le rowspan doit coller en haut */
.tbl3c td[rowspan],
.tbl3c tr > td:first-child {           /* au cas o√π */
  vertical-align: top !important;
}

@media print {
  .tbl3c td[rowspan],
  .tbl3c tr > td:first-child {
    vertical-align: top !important;
  }
}

/* Surlignage stable (pas de d√©passement) */
mjx-container .hlY, mjx-container .hlC,
.mjx-chtml .hlY, .mjx-chtml .hlC{
  display:inline-block;
  padding:0 .12em;
  border-radius:4px;
  background-clip:padding-box;
  box-decoration-break:clone;
}
mjx-container .hlY, .mjx-chtml .hlY{ background:#fff3b0; } /* jaune */
mjx-container .hlC, .mjx-chtml .hlC{ background:#bff0ff; } /* cyan  */

  @media print{ .controls{display:none !important;} }
    /* --- PDF helpers --- */
  .pdf-only{display:none}
  @media print{ .pdf-only{display:block} }

/* base */
table.pdf-tbl{
  border-collapse: separate;
  border-spacing: 0;
  border: none;
  margin: .4rem 0;
  position: relative; /* pour le pseudo-√©l√©ment cadre */
}
table.pdf-tbl th, table.pdf-tbl td{
  border: none;
  padding: 4px 6px;
  text-align: center;
  vertical-align: middle;
}
table.pdf-tbl th{ background:#f3f3f6 }

/* === Cadre ext√©rieur, une seule fois pour toute la table === */
table.pdf-tbl::before{
  content:"";
  position:absolute; inset:0;
  border:1.5px solid #000;
  pointer-events:none;   /* ne g√™ne pas les interactions */
}

/* === S√©parateur vertical apr√®s la 1 ≥·µâ colonne === */
table.pdf-tbl thead tr > *:first-child,
table.pdf-tbl tbody tr > *:first-child{
  border-right: 1.5px solid #000;
}

/* Ne PAS tracer ce s√©parateur sur les lignes ‚Äútechniques‚Äù */
table.pdf-tbl tbody tr.thin > *:first-child,
table.pdf-tbl tbody tr.gaprow > *:first-child{
  border-right: none !important;
}
table.pdf-tbl thead tr > *{
  border-bottom: 1.5px solid #000; /* s√©paration x / f(x) */
}
</style>

<!-- MathJax (LaTeX inline \( ... \) ) -->
<script>
  window.MathJax = {
  loader: {
    // forcer le chargement des extensions utilis√©es par tes macros
    load: ['[tex]/html', '[tex]/bbox']
  },
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true,
    packages: {'[+]': ['html','bbox']},
    macros: {
      frac: ['\\dfrac{#1}{#2}', 2],
      hlY:  ['\\class{hlY}{#1}', 1],
      hlC:  ['\\class{hlC}{#1}', 1]
    }
  },
  options: { skipHtmlTags: ['script','noscript','style','textarea'] },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};

</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Premi√®re ‚Äì Chapitre 1 ‚Äì <strong>Forme canonique</strong> ‚Äî Exercices</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Entr√©e ‚èé d√©clenche <b>V√©rifier</b>.</li>
        <li><b>Valeurs exactes</b> : entiers ou fractions (√©crire <code>a/b</code>).</li>
        <li>Puissances : <code>x^2</code>, <code>(x+3)^2</code>, ‚Ä¶</li>
        <li>Parenth√®ses pour nombres n√©gatifs.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- d√©pendances -->
  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
  <script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src='../../../../js/fraction-sign-clarity.dom.v3.js' defer></script>



<script>
(function(){
'use strict';

/* ==== utils DOM & score ==== */
const $=(s,r)=> (r||document).querySelector(s);
const $$=(s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function setTick(el, ok){
  let t = el.nextElementSibling;
  if(!t || !t.classList.contains('tick')){
    t=document.createElement('span'); t.className='tick'; el.after(t);
  }
  t.textContent = ok ? '‚úî' : '‚úó';
  t.classList.toggle('ok', ok);
  t.classList.toggle('ko', !ok);
}
// ‚Äî MathJax ready + typeset, √† l'√©preuve des courses ‚Äî
function mjxReady(){
  return (window.MathJax && MathJax.startup && MathJax.startup.promise)
    ? MathJax.startup.promise
    : new Promise(resolve=>{
        const t = setInterval(()=>{
          if (window.MathJax && MathJax.startup && MathJax.startup.promise){
            clearInterval(t); MathJax.startup.promise.then(resolve).catch(resolve);
          }
        }, 50);
      });
}
window.mjxReady = mjxReady;

function typesetAll(root){
  const nodes = root ? [root] : undefined;
  return mjxReady().then(()=> {
    if (window.MathJax && MathJax.typesetPromise){
      return MathJax.typesetPromise(nodes).catch(()=>{});
    }
  });
}

/* ==== RATIONNELS & TEX ==== */
function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b]}return a||1}
function simp(p,q){if(q<0){p=-p;q=-q}const g=gcd(p,q);return [p/g,q/g]}
function fromInt(n){return [n,1]}
function add([p1,q1],[p2,q2]){return simp(p1*q2+p2*q1,q1*q2)}
function sub(a,b){return add(a,[-b[0],b[1]])}
function mul([p1,q1],[p2,q2]){return simp(p1*p2,q1*q2)}
function div([p1,q1],[p2,q2]){return simp(p1*q2,q1*p2)}
function sq([p,q]){return simp(p*p,q*q)}

/* ===== TeX helpers (sans d√©limiteurs) ===== */
const pm = sgn => (sgn<0? ' - ' : ' + ');
const wrap = tex => `\\(${tex}\\)`;
const texNum = n => String(n);
const texPow2 = v => `${v}^{2}`;

// PATCH A ‚Äî helpers pour √©viter "x - -‚Ä¶" (double signe)
function texXminus(A){
  const s = simp(A[0], A[1]); const p = s[0], q = s[1];
  if (p === 0) return 'x';
  if (p < 0)   return `x + ${texRat([-p, q])}`;
  return `x - ${texRat([p, q])}`;
}
function texParenXminus(A){ return `\\left(${texXminus(A)}\\right)`; }

function texRatCore(p,q){
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg?'-':'')+String(p);
  return (neg?'-':'')+`\\frac{${p}}{${q}}`;
}
function texRat([p,q]){ const s=simp(p,q); return texRatCore(s[0],s[1]); }
function texRatRaw(p,q){ return texRatCore(p,q); }
function ratText([p,q]){ const s=simp(p,q); return s[1]===1? String(s[0]) : `\\frac{${s[0]}}{${s[1]}}`; }

/* ===== Œ±, Œ≤ ===== */
function alphaFrac(a,b){ return simp(-b,2*a) }
function betaFrac(a,b,c){
  const al=alphaFrac(a,b);
  return add( add( mul(fromInt(a), sq(al)), mul(fromInt(b), al) ), fromInt(c) );
}
function ratExpr(fr){
  const s = simp(fr[0], fr[1]); // d√©j√† dans ton code
  return (s[1] === 1) ? String(s[0]) : `${s[0]}/${s[1]}`; // "-9/4"
}

/* ===== Normalisation & comparaison ===== */
function normExpr(s){
  return String(s)
    .replace(/\u2212|\u2013|\u2014|\u2010|\uFE63|\uFF0D/g,'-')
    .replace(/\u00B2/g,'^2')
    .replace(/[√ó¬∑]/g,'*')
    .replace(/\s+/g,' ')
    .trim();
}
function algebraOK(exp, got){ try{ return algebraicEqual(normExpr(exp), normExpr(got)); }catch(_){ return false; } }

/* ===== Cha√Ænes TeX compl√®tes (sans d√©limiteurs) ===== */
function polyDevTex(a,b,c){
  const parts=[];
  // a x^2
  if(a===1){ parts.push(texPow2('x')); }
  else if(a===-1){ parts.push('-'+texPow2('x')); }
  else { parts.push(`${a}x^{2}`); }
  // + b x
  if(b){ parts.push( (b<0?' - ':' + ') + (Math.abs(b)===1?'x':`${Math.abs(b)}x`) ); }
  // + c
  if(c){ parts.push( (c<0?' - ':' + ')+Math.abs(c) ); }
  return `f(x) = ${parts.join('').replace(/\s\+\s-/g,' - ')||'0'}`;
}
function aPrefixTex(a){ return (a===1?'':(a===-1?'-':String(a))); }
function canonTex(a, A, B){
  const ap = aPrefixTex(a);
  const tail = (B[0]===0 ? '' : (B[0]<0 ? ` - ${texRat([-B[0],B[1]])}` : ` + ${texRat(B)}`));
  return `${ap}${ap?'':''}\\left(${texXminus(A)}\\right)^{2}${tail}`;
}


function factorizedTexFromRoots(a, r, s){
  const aPref = aPrefixTex(a);
  const f1 = (r>0? `x - ${r}` : (r<0? `x + ${-r}` : 'x'));
  const f2 = (s>0? `x - ${s}` : (s<0? `x + ${-s}` : 'x'));
  return `${aPref? aPref: ''}${aPref? '':''}\\left(${f1}\\right)\\left(${f2}\\right)`;
}

// Affiche " + c" / " - c" si c ‚â† 0, sinon rien
function texCst(c){
  return c===0 ? '' : `${pm(c)} ${Math.abs(c)}`;
}

/* ===================== Ex1 : Identifier la forme ===================== */
const exIdentify={ id:'id', title:'Diff√©rentes formes : identifier ¬´ d√©velopp√©e / canonique / factoris√©e ¬ª',
  gen(){
    const r=rnd(-5,5), s=rnd(-5,5), a=choice([-1,1]), b=-a*(r+s), c=a*r*s;
    const alpha=div(fromInt(-b), fromInt(2*a));
    const beta=sub(fromInt(c), div(fromInt(b*b), fromInt(4*a)));

    const Fdev = polyDevTex(a,b,c).replace(/^f\(x\)\s*=\s*/,'');
    const Fcan = canonTex(a, alpha, beta);
    const Ffac = factorizedTexFromRoots(a, r, s);

    const rows=[{expr:wrap(Fdev),label:'D√©velopp√©e'},
                {expr:wrap(Fcan),label:'Canonique'},
                {expr:wrap(Ffac),label:'Factoris√©e'}].sort(()=>Math.random()-.5);
    return {rows};
  },
  render(host,st){
    host.innerHTML=[
      '<div>Associer chaque √©criture √† son type.</div>',
      '<table class="table"><thead><tr><th>#</th><th>√âcriture</th><th>Type</th></tr></thead><tbody>',
      st.rows.map((r,i)=>`<tr data-i="${i}"><td><b>${String.fromCharCode(97+i)}.</b></td><td>${r.expr}</td>
      <td><select class="T"><option value=""></option><option>D√©velopp√©e</option><option>Canonique</option><option>Factoris√©e</option></select><span class="tick"></span></td></tr>`).join(''),
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    if (window.MathJax?.typeset) MathJax.typeset();
	typesetAll(host);
  },
  correct(host,st){
    let ok=0,tot=0;
    $$('.table tbody tr',host).forEach((tr,i)=>{
      const got=$('.T',tr).value; const want=st.rows[i].label;
      if(got){tot++; if(got===want){ok++;}}
      setTick($('.T',tr), got===want);
    });
    $('#res',host).innerHTML='<div class="steps"><div class="step">R√©sultat : <b>'+ok+' / '+tot+'</b></div></div>'; scoreTot+=tot; scoreOK+=ok; updateScore();
    if (window.MathJax?.typeset) MathJax.typeset();
  },
  solution(host,st){
    $('#res',host).innerHTML='<div class="steps">'+st.rows.map((r,i)=>'<div class="step">('+(i+1)+') : <b>'+r.label+'</b></div>').join('')+'</div>';
  typesetAll(host);
  
  },
  reset(host){ $('#res',host).textContent=''; }
};
// === V√©rif stricte de la forme canonique, ordre normal OU commut√© ===
function escRegex(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

// rend "p/q" entour√© de parenth√®ses si besoin (comme ratText)
function ratStr([p,q]){
  // ici on suppose p,q entiers (comme dans ton code)
  const g = (a,b)=>{a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b]}return a||1;};
  if(q<0){ p=-p; q=-q; }
  const d=g(p,q); p/=d; q/=d;
  return (q===1) ? String(p) : `(${p}/${q})`;
}

function canonRegexesFor(a, A, B){
  // helpers
  const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
  const aStr  = (a===1?'':(a===-1?'-':String(a)));
  const aAbs  = Math.abs(a);
  const mul   = (aAbs===1) ? '' : '(?:\\*|√ó|¬∑)?';

  // alpha (valeur absolue) en "p/q" (sans parenth√®ses)
  const simpAbs = ([p,q])=>{
    if(q<0){p=-p;q=-q}
    const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){[x,y]=[y,x%y]}return x||1};
    p=Math.abs(p); q=Math.abs(q); const d=g(p,q); return [p/d,q/d];
  };
  const fracStr = ([p,q])=> `${p}/${q}`;

  const [Ap,Aq] = simpAbs(A);
  const Aplain  = fracStr([Ap,Aq]);                           // "1/2"
  const Aopt    = '(?:' + esc(Aplain) + '|\\(' + esc(Aplain) + '\\))'; // "1/2" ou "(1/2)"

  // (x ¬± Œ±)^2
  const inner = '\\(x' + (A[0]<0 ? '\\+' : '\\-') + Aopt + '\\)\\^2';

  // Œ≤ (m√™me tol√©rance de parenth√®ses)
  const [Bp,Bq] = simpAbs(B);
  const Bplain  = fracStr([Bp,Bq]);                           // "19/4"
  const Bopt    = '(?:' + esc(Bplain) + '|\\(' + esc(Bplain) + '\\))';

  // ----- Ordre classique : a(...)^2 ¬± Œ≤ -----
  const tailClassic = (B[0]<0)
    ? '(?:\\-' + Bopt + '|\\+\\-' + Bopt + ')'
    : '\\+' + Bopt;
  const classic = new RegExp('^' + esc(aStr) + mul + inner + tailClassic + '$');

  // ----- Ordre commut√© : Œ≤ ¬± |a|(...)^2 -----
  const Bsigned = (B[0]<0 ? '\\-' : '') + Bopt;         // "-19/4" ou "19/4"
  const between = (a>0 ? '\\+' : '\\-');
  const coef = (aAbs===1) ? '' : esc(String(aAbs)) + mul;
  const commuted = new RegExp('^' + Bsigned + between + coef + inner + '$');

  return [classic, commuted];
}


function isCanonicalInput(str, a, A, B){
  const s = normExpr(str).replace(/\s+/g,''); // on supprime tous les espaces
  const regs = canonRegexesFor(a, A, B);
  return regs.some(re => re.test(s));
}


/* ===================== Ex2 : Deux m√©thodes ===================== */
const exTwoWays={ id:'2w', title:'Forme canonique ‚Äî 2 m√©thodes (tableau 2 colonnes)',
  gen(){
    let a=choice([-3,-2,-1,1,2,3]);
    let b=rnd(-6,6), c=rnd(-6,6);
    if(Math.abs(a)===1 && b%2!==0) b++; // √©viter Œ± demi quand a=¬±1
    return {a,b,c,alpha:alphaFrac(a,b),beta:betaFrac(a,b,c)};
  },
  render(host,st){
    const line = wrap(polyDevTex(st.a,st.b,st.c));
    host.innerHTML=[
      `<div class="statement">D√©terminer, par deux m√©thodes, la forme canonique des trin√¥mes d√©finies par : ${line}</div>`,
      '<table class="table"><thead><tr><th></th><th>R√©ponse</th></tr></thead><tbody>',
      '<tr><td>\\(Œ± =\\)</td><td><input class="alpha" type="text" style="width:160px"><span class="tick"></span></td></tr>',
      '<tr><td>\\(Œ≤ =\\)</td><td><input class="beta" type="text" style="width:160px"><span class="tick"></span></td></tr>',
      '<tr><td>\\(f(x) = \\)</td><td><input class="canon" type="text" style="width:360px" placeholder=""><span class="tick"></span></td></tr>',
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    host.dataset.state=JSON.stringify(st);
    if (window.MathJax?.typeset) MathJax.typeset();
	typesetAll(host);
  },
  textHTML(st){
  // √©nonc√© minimal, robuste, que le kit sait imprimer sans d√©pendre du DOM cach√©
  return `<div class="statement">
    D√©terminer, par deux m√©thodes, la forme canonique des trin√¥mes d√©finies par :
    ${wrap( polyDevTex(st.a, st.b, st.c) )}
  </div>`;
},

  correct(host,st){
  let ok=0, tot=0;

  // Œ± et Œ≤ : comparer sur "p/q" (arithm√©tique), pas sur LaTeX
  const a1=$('.alpha',host).value.trim();
  if(a1){
    const okA = algebraOK(ratExpr(st.alpha), a1);
    setTick($('.alpha',host), okA); tot++; if(okA) ok++;
  }

  const b1=$('.beta',host).value.trim();
  if(b1){
    const okB = algebraOK(ratExpr(st.beta), b1);
    setTick($('.beta',host), okB); tot++; if(okB) ok++;
  }

  // Forme canonique : on garde la v√©rif stricte d√©di√©e
  const c1=$('.canon',host).value.trim();
  if(c1){
    const okC = isCanonicalInput(c1, st.a, st.alpha, st.beta);
    setTick($('.canon',host), okC); tot++; if(okC) ok++;
  }

  $('#res',host).innerHTML =
    '<div class="steps"><div class="step">R√©sultat : <b>'+ok+' / '+tot+'</b></div></div>';
  scoreTot+=tot; scoreOK+=ok; updateScore();
},

  solution(host, st){
  const {a,b,c} = st;
  // Ligne "f(x) = ..." (LaTeX)
const fxLine = '<div class="equ" style="margin:.35rem 0">'
             +  wrap( polyDevTex(a,b,c) ) + '</div>';

  const A = st.alpha, B = st.beta;

  // --- Helpers TeX locaux (sans d√©limiteurs) ---
  function gcd(x,y){ x=Math.abs(x); y=Math.abs(y); while(y){ [x,y]=[y,x%y]; } return x||1; }
  function simp(p,q){ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return [p/g,q/g]; }
  const pm = n => (n<0 ? ' - ' : ' + ');
  const aPrefixTex = A => (A===1?'':(A===-1?'-':String(A)));
  function texRat([p,q]){ let [P,Q]=simp(p,q); const neg=(P<0)!==(Q<0); P=Math.abs(P); Q=Math.abs(Q);
    return Q===1 ? (neg?'-':'')+String(P) : (neg?'-':'')+`\\frac{${P}}{${Q}}`; }
  function texRatRaw(p,q){ const neg=(p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
    return q===1 ? (neg?'-':'')+String(p) : (neg?'-':'')+`\\frac{${p}}{${q}}`; }
  function texXminus(A){ const s=simp(A[0],A[1]); const p=s[0], q=s[1];
    if(p===0) return 'x';
    if(p<0)   return `x + ${texRat([-p,q])}`;
    return       `x - ${texRat([p,q])}`; }
  function x2_plus_kx_TEX(fr){ const s=simp(fr[0], fr[1]); const sign = s[0]<0 ? ' - ' : ' + ';
    const P=Math.abs(s[0]), Q=Math.abs(s[1]); const coef = (P===1 && Q===1) ? 'x' : `${texRat([P,Q])}x`;
    return `x^{2}${sign}${coef}`; }
  function x_pm_frac_TEX(fr){ const s=simp(fr[0],fr[1]);
    const seg = (s[0]<0? ` - ${texRat([-s[0],s[1]])}` : ` + ${texRat([s[0],s[1]])}`);
    return `\\left(${`x${seg}`}\\right)^{2}`; }
  function canonTex(a, A, B){
    const ap = aPrefixTex(a);
    const plusB = (B[0]<0? ` - ${texRat([-B[0],B[1]])}` : ` + ${texRat(B)}`);
    return `${ap}${ap?'':''}\\left(${texXminus(A)}\\right)^{2}${plusB}`;
  }
// === helper : met des parenth√®ses si la fraction est n√©gative ===
function texWrapIfNeg(fr){
  const s = simp(fr[0], fr[1]);       // d√©nominateur > 0
  return (s[0] < 0) ? `\\left(${texRat([s[0], s[1]])}\\right)` : texRat([s[0], s[1]]);
}

  if(b===0){
    $('#res',host).innerHTML = [
	  fxLine,                                        
      '<div class="steps">',
        '<div>a = ',a,' ; b = ',b,' ; c = ',c,'</div>',
        '<div>Comme b = 0, \\(f(x)\\)est d√©j√† sous forme canonique avec \\(\\alpha = 0\\) et \\(\\beta = ', texRat([c,1]) ,'\\).</div>',
        '<div>Donc \\(', aPrefixTex(a),'\\,(x - 0)^{2} ', (c<0?' - ':' + '), Math.abs(c) ,'\\)</div>',
      '</div>'
    ].join('');
    if (window.MathJax?.typeset) MathJax.typeset();
    return;
  }

  const b_a  = simp(st.b, st.a);
  const b_2a = simp(st.b, 2*st.a);
  const minus_a_square = (function(){ const t=simp(b_2a[0],b_2a[1]); return simp(-st.a * t[0]*t[0], t[1]*t[1]); })();
  const rawAlpha = texRatRaw(-st.b, 2*st.a), simpAlpha = texRat(A);
  const alphaLine = (rawAlpha===simpAlpha)
    ? `\\(\\alpha = -\\frac{b}{2a} = ${simpAlpha}\\)`
    : `\\(\\alpha = -\\frac{b}{2a} = ${rawAlpha} = ${simpAlpha}\\)`;
// facteurs pour Œ≤
const aFac = (a===1 ? '' : (a===-1 ? '-' : String(a)) ) + (Math.abs(a)===1 ? '' : '\\,');
const A2   = `(${texRat(A)})^{2}`;
const bXA  = `${pm(st.b)} ${Math.abs(st.b)}\\times ${texWrapIfNeg(A)}`;   // ‚Üê parenth√®ses si A<0
const cT   = `${pm(st.c)} ${Math.abs(st.c)}`;

const betaEq = `\\(\\beta = f(\\alpha) = ${aFac}${A2} ${bXA} ${cT} = ${texRat(B)}\\)`;

const left = `
  <h4>1<sup>√®re</sup> m√©thode : <span class="muted">avec Œ± et Œ≤</span></h4>
  \\(f(x) = a(x-\\alpha)^{2} + \\beta\\)<br>
  \\(\\text{Avec } a = ${st.a}\\ ;\\ b = ${st.b}\\ ;\\ c = ${st.c}\\)<br>
  ${alphaLine} \\(\\,\\text{ et}\\)<br>
  ${betaEq}<br><br>
  \\(f(x) = ${canonTex(st.a,A,B)}\\)
`;



// Remplace \bbox par \class : fond via CSS, aucune coupe de \left...\right
// APRES ‚Äî utilise les macros, c'est plus robuste
const HL_Y = t => `\\hlY{${t}}`;
const HL_C = t => `\\hlC{${t}}`;


// --- puis conserve exactement les m√™mes expressions qu'avant :
const startTex  = x2_plus_kx_TEX(b_a);        // "x^2 ¬± (b/a)x"
const squareTex = x_pm_frac_TEX(b_2a);        // "(x ¬± b/2a)^2"
const addTerm   = texRat(simp(b_2a[0]*b_2a[0], b_2a[1]*b_2a[1]));

// √âtape 1 (jaune uniquement √† l‚Äôint√©rieur des parenth√®ses)
const etape1 =
  `\\( f(x) = ${aPrefixTex(st.a)}\\left( ${HL_Y(startTex)} \\right)${texCst(st.c)} \\)`;

// √âtape 2 (trois lignes, une seule paire \( ‚Ä¶ \) par ligne)
const et2_1 = `\\(${HL_Y(startTex)}\\) est le d√©but de l‚Äôidentit√© remarquable \\(${squareTex}\\)`;
const et2_2 = `\\( ${squareTex} = ${HL_Y(startTex)} + ${addTerm} \\)`;
const et2_3 = `\\( ${HL_Y(startTex)} = ${HL_C(`${squareTex} - ${addTerm}`)} \\)`;
const etape2 = [et2_1, et2_2, et2_3].join('<br>');

// √âtape 3 ‚Äî on d√©veloppe par a la grande parenth√®se
const etape3_line1 =
  `\\( f(x) = ${aPrefixTex(st.a)}\\left( ${HL_C(`${squareTex} - ${addTerm}`)} \\right)${texCst(st.c)} \\)`;

// >>> PATCH : ligne interm√©diaire simplifi√©e (seulement si a ‚â† 1)
// calcule S = -a * (b/2a)^2 en fraction r√©duite

const sgnS = pm(minus_a_square[0]);               // " + " ou " - "
const absS = texRat([Math.abs(minus_a_square[0]), Math.abs(minus_a_square[1])]);

let etape3 = etape3_line1;
if (st.a !== 1) {
  // affiche directement le terme num√©rique (ex : "+ 3/4") au lieu de "‚àí(‚àí3) √ó 1/4"
 const etape3_mid =
  `\\( f(x) = ${aPrefixTex(st.a)}${squareTex} ${sgnS} ${absS}${texCst(st.c)} \\)`;
  etape3 += '<br>' + etape3_mid;
}

// Ligne finale : forme canonique
etape3 += '<br>' + `\\( f(x) = ${canonTex(st.a, A, B)} \\)`;



// Puis recompose `right` exactement comme tu le faisais :
const right = `
  <h4>2<sup>√®me</sup> m√©thode : <span class="muted">En identifiant une identit√© remarquable</span></h4>
  <b>Etape 1 :</b> On factorise par a les deux 1<sup>ers</sup> termes :<br>
  ${etape1}<br><br>
  <b>Etape 2 :</b> On cherche le d√©but d‚Äôune identit√© remarquable :<br>
  ${etape2}<br><br>
  <b>Etape 3 :</b> On d√©veloppe par a la grande parenth√®se :<br>
  ${etape3}
`;


const res = $('#res',host);
res.innerHTML =
fxLine + 
    `<div class="equ"><span class="muted">a = ${st.a} ; b = ${st.b} ; c = ${st.c}</span></div>`+
    `<div class="corr-grid"><div class="col">${left}</div><div class="col">${right}</div></div>`;

typesetAll(host);
  

},


reset(host){ $('#res',host).textContent=''; }

};

/* ===================== Ex3 : Tableau de variations ===================== */
const exVariations={ id:'var', title:'Tableau de variations √† compl√©ter (f en forme canonique)',
  gen(){ const a=choice([-3,-2,-1,1,2,3]); const alpha=fromInt(rnd(-5,5)); const beta=fromInt(rnd(-6,6)); return {a,alpha,beta}; },
  render(host,st){
    const line = wrap( `f(x) = ${canonTex(st.a, st.alpha, st.beta)}` );
    host.innerHTML=[
      `<div class="statement">On consid√®re ${line}.</div>`,
      '<div style="margin:.4rem 0">Sommet : \\(S \\)( <input class="alpha-q" type="text" style="width:110px"> ; <input class="beta-q" type="text" style="width:110px"> )<span class="tick"></span></div>',
      '<div class="var-wrap"><table class="var">',
      '<thead><tr><th>\\(x\\)</th><td>\\(‚àí‚àû\\)</td><td style="text-align:center"><input class="alpha-in" type="text" style="width:90px"></td><td>\\(+‚àû\\)</td></tr></thead>',
      '<tbody>',
      '<tr>',
        '<th rowspan="3">\\(f\\)</th>',
        '<td class="bigsel" rowspan="3"><select class="d-L"><option value=""></option><option>‚Üò</option><option>‚Üó</option></select></td>',
        '<td style="text-align:center"><input class="d-beta-top" type="text" placeholder="maximum"></td>',
        '<td class="bigsel" rowspan="3"><select class="d-R"><option value=""></option><option>‚Üò</option><option>‚Üó</option></select></td>',
      '</tr>',
      '<tr class="gaprow"><td></td></tr>',
      '<tr class="thin">',
        '<td style="text-align:center"><input class="d-beta-bot" type="text" placeholder="minimum"></td>',
      '</tr>',
      '</tbody></table></div>',
	     // üîΩ bloc offscreen demand√© (servira pour le PDF)
    `<div class="equ-offscreen" style="display:none">
      <p>Donner le <strong>tableau de variations</strong> de la fonction \\(f\\) d√©finie par : ${line} et les coordonn√©es du sommet \\(S\\) de la courbe.</p>
    </div>`,
      '<div id="res" class="small"></div>'
    ].join('');
    if (window.MathJax?.typeset) MathJax.typeset();
	typesetAll(host);

  },
  correct(host,st){
    let ok=0, tot=0;
    const alphaOK1 = algebraOK(ratText(st.alpha), $('.alpha-q',host).value.trim()); if($('.alpha-q',host).value.trim()) { setTick($('.alpha-q',host),alphaOK1); tot++; if(alphaOK1) ok++; }
    const betaOK1  = algebraOK(ratText(st.beta),  $('.beta-q',host).value.trim());  if($('.beta-q',host).value.trim())  { setTick($('.beta-q',host),betaOK1);  tot++; if(betaOK1)  ok++; }

    const alphaOK = algebraOK(ratText(st.alpha), $('.alpha-in',host).value.trim()); if($('.alpha-in',host).value.trim()){ setTick($('.alpha-in',host),alphaOK); tot++; if(alphaOK) ok++; }

    const expect = st.a>0? ['‚Üò','‚Üó','bot'] : ['‚Üó','‚Üò','top']; // bot=min, top=max
    const LT=$('.d-L',host).value, RT=$('.d-R',host).value;
    if(LT){ const LOK=(LT===expect[0]); setTick($('.d-L',host),LOK); tot++; if(LOK) ok++; }
    if(RT){ const ROK=(RT===expect[1]); setTick($('.d-R',host),ROK); tot++; if(ROK) ok++; }

    const betaTop = $('.d-beta-top',host).value.trim(), betaBot = $('.d-beta-bot',host).value.trim();
    if(betaTop || betaBot){
      let betaOK=false;
      if(expect[2]==='top'){
        betaOK = algebraOK(ratText(st.beta), betaTop) && betaBot==='' ;
        setTick($('.d-beta-top',host), algebraOK(ratText(st.beta), betaTop));
        if(betaBot) setTick($('.d-beta-bot',host), false);
      }else{
        betaOK = algebraOK(ratText(st.beta), betaBot) && betaTop==='' ;
        setTick($('.d-beta-bot',host), algebraOK(ratText(st.beta), betaBot));
        if(betaTop) setTick($('.d-beta-top',host), false);
      }
      tot++; if(betaOK) ok++;
    }
    $('#res',host).innerHTML = '<div class="steps"><div class="step">R√©sultat : <b>'+ok+' / '+tot+'</b></div></div>';
  },
  solution(host,st){
    const expectTop = st.a<0; // max en haut si a<0
    const top = expectTop ? wrap(texRat(st.beta)) : '';
    const bot = expectTop ? '' : wrap(texRat(st.beta));
    const sensL = st.a>0?'‚Üò':'‚Üó';
    const sensR = st.a>0?'‚Üó':'‚Üò';
    const res = $('#res',host);
	const aNote =
  (st.a > 0)
    ? `Ici \\( \\) \\(a=${st.a}>0\\) donc la parabole est tourn√©e vers le <b>haut</b>.`
    : `Ici \\( \\) \\(a=${st.a}<0\\) donc la parabole est tourn√©e vers le <b>bas</b>.`;

res.innerHTML = [
  '<div class="steps">',
    '  <div class="step"><b>Sommet :</b> \\(S\\)(',wrap(texRat(st.alpha)),' ; ',wrap(texRat(st.beta)),').</div>',
  '<div class="step">Tableau attendu :</div>',
  '<div class="step">On regarde le signe de \\( \\) \\(a\\)</div>',
  ` <div class="step small">${aNote}</div>`,          // ‚üµ AJOUT
  '<div class="var-wrap"><table class="pdf-tbl">',
      '<thead><tr><th>\\(x\\)</th><td>\\(‚àí‚àû\\)</td><td>' + wrap(texRat(st.alpha)) + '</td><td>\\(+‚àû\\)</td></tr></thead>',
      '<tbody>',
      '<tr><th rowspan="2">\\(f\\)</th><td class="bigsel" rowspan="2">',sensL,'</td><td style="text-align:center">',top,'</td><td class="bigsel" rowspan="2">',sensR,'</td></tr>',
      '<tr class="thin"><td style="text-align:center">',bot,'</td></tr>',
      '</tbody></table></div>',
      '</div>'
    ].join('');
typesetAll(host);  },
  reset(host){ $('#res',host).textContent=''; }
};

/* ===================== Ex4 : Forme adapt√©e (avec saisies) ‚Äî version LaTeX ===================== */
const exAdapt = {
  id:'ad',
  title:'Choisir la forme adapt√©e (image, √©quations, variations) ‚Äî LaTeX',

  // ==== PATCH : remplacer enti√®rement la fonction gen() de exAdapt ====
gen(){
  const a = 1;

  // r1, r2 non nuls et distincts  ‚Üí c ‚â† 0
 // r1 non nul
let r1; do { r1 = rnd(-5, 4); } while (r1 === 0);

// r2 non nul, ‚â† r1, et ‚â† -r1  ‚Üí  alpha ‚â† 0
let r2;
do { r2 = rnd(-6, 5); }
while (r2 === 0 || r2 === r1 || r2 === -r1);


  const b = -(r1 + r2);
  const c = r1 * r2;

  const alpha = alphaFrac(a, b);
  const beta  = betaFrac(a, b, c);

  // valeurs √† √©viter pour m :  |r1‚àír2|/2  ET  |r1+r2|/2  (sinon k=Œ≤+m¬≤=c)
  const halfDiff = Math.abs(r1 - r2) / 2;
  const halfSum  = Math.abs(r1 + r2) / 2;

  let pool = [1,2,3].filter(x => x !== halfDiff && x !== halfSum);
  if (pool.length === 0) pool = [1,2,3]; // s√©curit√©

  let m = choice(pool);
  let k = add(beta, fromInt(m*m));

  // filet de s√©curit√© : si jamais k==c, on prend une autre valeur de m
  const cRat = fromInt(c);
  const ratEqual = (r,s) => {
    const R = simp(r[0],r[1]), S = simp(s[0],s[1]);
    return R[0]===S[0] && R[1]===S[1];
  };
  let tries = 0;
  while (ratEqual(k, cRat) && tries < 3){
    pool = pool.filter(x => x !== m);
    m = pool.length ? pool[0] : ((m % 3) + 1);
    k = add(beta, fromInt(m*m));
    tries++;
  }

  // racine utilis√©e pour 3a (image d‚Äôune racine ‚Üí 0)
  const r = choice([r1, r2]);

  return { a, b, c, r1, r2, r, alpha, beta, k, m };
},

  render(host, st){
    const poly  = wrap( polyDevTex(st.a, st.b, st.c) );
    const canon = wrap( canonTex(st.a, st.alpha, st.beta) );
    const fact  = wrap( factorizedTexFromRoots(st.a, st.r1, st.r2) );

    host.innerHTML = [
  '<div class="statement">',                         // ‚Üê un SEUL wrapper .statement
    `<div>On consid√®re la fonction \\(f\\) sous sa forme d√©velopp√©e : ${poly}.</div>`,
    '<ol>',
      `<li>Montrer que ${fact} est une forme factoris√©e de \\(f\\).</li>`,
      `<li>Montrer que ${canon} est la forme canonique de \\(f\\).</li>`,
      '<li>Choisir la forme la mieux adapt√©e et r√©pondre :',
        '<ol type="a">',
          `<li>Calculer l‚Äôimage de \\(${st.r}\\) <input class="q3a_r1" style="width:110px"> <span class="tick"></span>, de \\(0\\) <input class="q3a_0" style="width:110px"> <span class="tick"></span> et de <b>${wrap(texRat(st.alpha))}</b> <input class="q3a_alpha" style="width:110px"> <span class="tick"></span></li>`,
          '<li>R√©soudre l‚Äô√©quation \\(f(x)=0\\) : \\(S=\\) <input class="q3bS" style="width:220px" placeholder="{ ‚Ä¶ }"> <span class="tick"></span></li>',
          `<li>R√©soudre l‚Äô√©quation \\(f(x)=${st.c}\\) : \\(S=\\) <input class="q3cS" style="width:220px" placeholder="{ ‚Ä¶ }"> <span class="tick"></span></li>`,
          `<li>R√©soudre l‚Äô√©quation ${wrap('f(x)=' + texRat(st.k))} : \\(S=\\) <input class="q3dS" style="width:220px" placeholder="{ ‚Ä¶ }"> <span class="tick"></span></li>`,
          '<li>D√©terminer les variations de \\(f\\) :</li>',
        '</ol>',
        '<div class="var-wrap" style="margin:.4rem 0 .6rem 0"><table class="var">',
          '<thead><tr><th>\\(x\\)</th><td>\\(‚àí‚àû\\)</td><td style="text-align:center"><input class="d-alpha" type="text" style="width:90px"></td><td>\\(+‚àû\\)</td></tr></thead>',
          '<tbody>',
            '<tr>',
              '<th rowspan="3">\\(f\\)</th>',
              '<td class="bigsel" rowspan="3"><select class="d-L"><option value=""></option><option>‚Üò</option><option>‚Üó</option></select></td>',
              '<td style="text-align:center"><input class="d-beta-top" type="text" placeholder="maximum"></td>',
              '<td class="bigsel" rowspan="3"><select class="d-R"><option value=""></option><option>‚Üò</option><option>‚Üó</option></select></td>',
            '</tr>',
            '<tr class="gaprow"><td></td></tr>',
            '<tr class="thin">',
              '<td style="text-align:center"><input class="d-beta-bot" type="text" placeholder="minimum"></td>',
            '</tr>',
          '</tbody></table></div>',
      '</li>',
    '</ol>',
  '</div>',                                            // ‚Üê fin du seul .statement
  '<div id="res" class="small"></div>'
].join('');

    if (window.MathJax?.typeset) MathJax.typeset();
	typesetAll(host);

  },
textHTML(st){
  const poly  = wrap( polyDevTex(st.a, st.b, st.c) );
  const canon = wrap( canonTex(st.a, st.alpha, st.beta) );
  const fact  = wrap( factorizedTexFromRoots(st.a, st.r1, st.r2) );
  return [
    '<div class="statement">',
      `<div>On consid√®re la fonction \\(f\\) sous sa forme d√©velopp√©e : ${poly}.</div>`,
      '<ol>',
        `<li>Montrer que ${fact} est une forme factoris√©e de \\(f\\).</li>`,
        `<li>Montrer que ${canon} est la forme canonique de \\(f\\).</li>`,
        '<li>Choisir la forme la mieux adapt√©e et r√©pondre :',
          '<ol type="a">',
            `<li>Calculer l‚Äôimage de \\(${st.r}\\), de \\(0\\) et de <b>${wrap(texRat(st.alpha))}</b>.</li>`,
            `<li>R√©soudre \\(f(x)=0\\).</li>`,
            `<li>R√©soudre \\(f(x)=${st.c}\\).</li>`,
            `<li>R√©soudre ${wrap('f(x)=' + texRat(st.k))}.</li>`,
            '<li>D√©terminer les variations de \\(f\\).</li>',
          '</ol>',
        '</li>',
      '</ol>',
    '</div>'
  ].join('');
},

  correct(host, st){
  let ok = 0, tot = 0;

  const a1OK = algebraOK("0", $('.q3a_r1',host).value.trim());
  if($('.q3a_r1',host).value.trim()){ setTick($('.q3a_r1',host), a1OK); tot++; if(a1OK) ok++; }

  const a2OK = algebraOK(String(st.c), $('.q3a_0',host).value.trim());
  if($('.q3a_0',host).value.trim()){ setTick($('.q3a_0',host), a2OK); tot++; if(a2OK) ok++; }

  // ‚¨áÔ∏è compare sur "-9/4" (arithm√©tique), pas sur "\frac{-9}{4}" (LaTeX)
  const a3OK = algebraOK(ratExpr(st.beta), $('.q3a_alpha',host).value.trim());
  if($('.q3a_alpha',host).value.trim()){ setTick($('.q3a_alpha',host), a3OK); tot++; if(a3OK) ok++; }

  // ‚Äî‚Äî‚Äî utilitaire pour valider { ‚Ä¶ } (ordre indiff√©rent)
  function setAnswerOK(inputStr, expectedVals){
    if(!inputStr) return false;
    const s = inputStr.replace(/\s+/g,'').replace(/^S=?/, '').replace(/^\{|\}$/g,'');
    const parts = s.split(/[;,]/).filter(Boolean);
    if(parts.length !== expectedVals.length) return false;

    const used = new Array(parts.length).fill(false);
    for(const exp of expectedVals){
      const fr = Array.isArray(exp) ? exp : fromInt(exp);      // attend un [p,q]
      let found = false;
      for(let i=0;i<parts.length;i++){
        if(used[i]) continue;
        if(algebraOK(ratExpr(fr), parts[i])){                  // ‚¨ÖÔ∏è compare sur "p/q"
          used[i] = true; found = true; break;
        }
      }
      if(!found) return false;
    }
    return true;
  }

  // 3b : f(x)=0 ‚Üí { r1 ; r2 }
  {
    const inB = $('.q3bS',host).value.trim();
    if(inB){
      const okB = setAnswerOK(inB, [st.r1, st.r2]);            // entiers OK
      setTick($('.q3bS',host), okB); tot++; if(okB) ok++;
    }
  }

  // 3c : f(x)=c ‚Üí ax^2+bx=c ‚áí ax^2+bx=0 ‚áí x=0 ou x=-b/a
  {
    const inC = $('.q3cS',host).value.trim();
    if(inC){
      const okC = setAnswerOK(inC, [0, [-st.b, st.a]]);        // ‚¨ÖÔ∏è passe la fraction [-b,a]
      setTick($('.q3cS',host), okC); tot++; if(okC) ok++;
    }
  }

  // 3d : f(x)=k = Œ≤ + m^2 ‚áí x = Œ± ¬± m
  {
    const inD = $('.q3dS',host).value.trim();
    if(inD){
      const s1 = add(st.alpha, fromInt(st.m));                 // [p,q]
      const s2 = sub(st.alpha, fromInt(st.m));
      const okD = setAnswerOK(inD, [s1, s2]);
      setTick($('.q3dS',host), okD); tot++; if(okD) ok++;
    }
  }

  // variations
  const expect = st.a>0? ['‚Üò','‚Üó','bot'] : ['‚Üó','‚Üò','top'];
  const A=$('.d-alpha',host).value.trim(), LT=$('.d-L',host).value, RT=$('.d-R',host).value;

  if(A){ const AOK = algebraOK(ratExpr(st.alpha), A); setTick($('.d-alpha',host), AOK); tot++; if(AOK) ok++; }
  if(LT){ const LOK=(LT===expect[0]); setTick($('.d-L',host),LOK); tot++; if(LOK) ok++; }
  if(RT){ const ROK=(RT===expect[1]); setTick($('.d-R',host),ROK); tot++; if(ROK) ok++; }

  const bTop=$('.d-beta-top',host).value.trim(), bBot=$('.d-beta-bot',host).value.trim();
  if(bTop || bBot){
    let bOK=false;
    if(expect[2]==='top'){
      bOK = algebraOK(ratExpr(st.beta), bTop) && bBot==='';            // ‚¨ÖÔ∏è ratExpr
      setTick($('.d-beta-top',host), algebraOK(ratExpr(st.beta), bTop));
      if(bBot) setTick($('.d-beta-bot',host), false);
    }else{
      bOK = algebraOK(ratExpr(st.beta), bBot) && bTop==='';            // ‚¨ÖÔ∏è ratExpr
      setTick($('.d-beta-bot',host), algebraOK(ratExpr(st.beta), bBot));
      if(bTop) setTick($('.d-beta-top',host), false);
    }
    tot++; if(bOK) ok++;
  }

  $('#res',host).innerHTML='<div class="steps"><div class="step">R√©sultat : <b>'+ok+' / '+tot+'</b></div></div>';
},

  solution(host, st){
  // === Helpers d‚Äôaffichage locaux (version LaTeX) ===
  const pm      = k => k>0 ? ' + ' : ' - ';
  const termX   = k => (Math.abs(k)===1 ? 'x' : Math.abs(k)+'x');
  const wrap    = s => `\\(${s}\\)`;

  // On suppose que texRat, texRatRaw, canonTex, factorizedTexFromRoots existent d√©j√†
  // (ils sont d√©finis ailleurs dans le fichier). Si besoin, tu peux les r√©utiliser ici.

  function polyLine(b,c){
    let s = 'x^{2}';
    if(b) s += pm(b) + termX(b);
    if(c) s += pm(c) + Math.abs(c);
    return s;
  }
  function foilLine(a1,b1,a1b1){
    const parts = ['x^{2}'];
    if(b1)   parts.push(pm(b1)   + termX(b1));
    if(a1)   parts.push(pm(a1)   + termX(a1));
    if(a1b1) parts.push(pm(a1b1) + Math.abs(a1b1));
    return parts.join('');
  }
function table3(exprFirstCol, lines){
  const first =
    `<tr>
       <td class="lhs" style="vertical-align:top">${exprFirstCol}</td>
       <td class="eq"  style="width:1.2em;text-align:center">=</td>
       <td class="rhs">${lines[0]}</td>
     </tr>`;

  const rest = lines.slice(1).map(rhs => `
     <tr>
       <td class="lhs"></td>  <!-- colonne 1 vide -->
       <td class="eq"  style="width:1.2em;text-align:center">=</td>
       <td class="rhs">${rhs}</td>
     </tr>`).join('');

  return `<table class="tbl3c"><tbody>${first}${rest}</tbody></table>`;
}

  const dedup = arr => arr.filter((x,i,a)=> i===0 || x!==a[i-1]);
  function factorStr(r){
    if(r===0) return wrap('x');
    return wrap(`\\left( x ${r>0? ' - '+r : ' + '+(-r)} \\right)`);
  }

  /* ===== Q1 (identique, formules en LaTeX) ===== */
  const a1 = -st.r1, b1 = -st.r2, a1b1 = a1*b1;
  const factStr = (factorStr(st.r1) + ' ' + factorStr(st.r2)).replace(/\s+/g,' ').trim();
  const lineFOIL = wrap(foilLine(a1,b1,a1b1));
  const lineReg  = wrap(polyLine(st.b, st.c));
  let stepsQ1 = [ lineFOIL, lineReg, wrap('f(x)') ];
  stepsQ1 = dedup(stepsQ1);

  /* ===== Q2 (identique, LaTeX) ===== */
  const canonExpr =
    wrap(`\\left( x ${st.b>=0 ? ' + ' + texRat([st.b,2]) : ' - ' + texRat([Math.abs(st.b),2])} \\right)^{2}`
      + (st.beta[0]<0 ? ' - ' + texRat([-st.beta[0],st.beta[1]]) : ' + ' + texRat(st.beta)));
  const bOver2sq = st.b ? texRat([st.b*st.b,4]) : '';
  let l2 = 'x^{2}';
  if(st.b)       l2 += pm(st.b) + termX(st.b);
  if(st.b)       l2 += ' + ' + bOver2sq;
  if(st.beta[0]) l2 += (st.beta[0]<0 ? ' - ' : ' + ') + texRat([Math.abs(st.beta[0]), Math.abs(st.beta[1])]);
  const fourC = 4*st.c;
  let l3 = 'x^{2}';
  if(st.b)   l3 += pm(st.b) + termX(st.b);
  if(fourC)  l3 += (fourC>0 ? ' + ' : ' - ') + texRat([Math.abs(fourC),4]);
  const l4 = polyLine(st.b, st.c);
  let stepsQ2 = [ wrap(l2), wrap(l3), wrap(l4), wrap('f(x)') ];
  stepsQ2 = dedup(stepsQ2);

  /* ===== Q3a : 3 phrases d√©taill√©es ===== */
  let dev0 = '0^{2}';
  if (st.b) dev0 += (st.b>0 ? ' + '+Math.abs(st.b)+' \\times 0' : ' - ' + Math.abs(st.b) + ' \\times 0');
  if (st.c) dev0 += (st.c>0 ? ' + '+Math.abs(st.c) : ' - ' + Math.abs(st.c));

  const alphaT   = texRat(st.alpha);
  const betaT    = texRat(st.beta);
  const alphaSignT = st.alpha[0]>0 ? ' - ' + texRat([st.alpha[0], st.alpha[1]]) : ' + ' + texRat([-st.alpha[0], st.alpha[1]]);
  const betaTailT = st.beta[0] < 0 ? ' - ' + texRat([-st.beta[0], st.beta[1]]) : ' + ' + betaT;

  const lineR =
    '<p>Pour '+st.r+', on utilise la forme factoris√©e : ' +
    wrap(`f(${st.r}) = (${st.r}${st.r1>0?`-${st.r1}`:`+${-st.r1}`})(${st.r}${st.r2>0?`-${st.r2}`:`+${-st.r2}`}) = 0`)+'.</p>';
  const line0 = '<p>Pour 0, on utilise la forme d√©velopp√©e : ' + wrap(`f(0) = ${dev0} = ${st.c}`) + '.</p>';
  const lineA =
    '<p>Pour&nbsp; '+wrap(alphaT)+', on utilise la forme canonique : ' +
    wrap(`f(${alphaT}) = \\left( ${alphaT}${alphaSignT} \\right)^{2}${betaTailT} = ${betaT}`) + '.</p>';

  /* ===== 3b/3c/3d : blocs r√©dig√©s ===== */
  const sol3b = [
    '<div class="step"><b>3b)</b></div>',
    '<div class="sol" style="padding:.4rem;margin:.25rem 0;border:0px solid #000">',
      '<p><b>On utilise la forme factoris√©e :</b> ',
        wrap(`\\left( x ${st.r1>0? ' - '+st.r1 : ' + '+(-st.r1)} \\right)\\left( x ${st.r2>0? ' - '+st.r2 : ' + '+(-st.r2)} \\right) = 0`),'.</p>',
      '<p>Un produit de facteur est nul si et seulement si un des facteurs est nul.</p>',
      '<p>',wrap(`x ${st.r1>0? ' - '+st.r1 : ' + '+(-st.r1)} = 0 \\;\\mathbf{ou}\\; x ${st.r2>0? ' - '+st.r2 : ' + '+(-st.r2)} = 0`),'</p>',
      '<p>',wrap(`x = ${st.r1}`),' <b>ou</b> ',wrap(`x = ${st.r2}`),'</p>',
'<p><b>' + wrap(`S = \\{ ${st.r1} \\; ; \\; ${st.r2} \\}`) + '</b></p>',
    '</div>'
  ].join('');

  const sol3c = [
    '<div class="step"><b>3c)</b></div>',
    '<div class="sol" style="padding:.4rem;margin:.25rem 0;border:0px solid #000">',
      '<p><b>On utilise la forme d√©velopp√©e :</b> ', wrap(`x^{2}${st.b? (st.b>0? ' + '+st.b+'x' : ' - '+(-st.b)+'x') : ''} = 0`),'.</p>',
      '<p>', wrap(`x^{2}${st.b? (st.b>0? ' + '+st.b+'x' : ' - '+(-st.b)+'x') : ''} = 0`), '</p>',
      '<p>', wrap(`x\\left( x ${st.b? (st.b>0? ' + '+st.b : ' - '+(-st.b)) : ''} \\right) = 0`), '</p>',
      '<p>', wrap(`x = 0 \\;\\mathbf{ou}\\; x ${st.b? (st.b>0? ' + '+st.b : ' - '+(-st.b)) : ''} = 0`), '</p>',
      '<p>', wrap(`x = 0 \\;\\mathbf{ou}\\; x = ${texRat([-st.b, st.a])}`), '</p>',
'<p><b>' + wrap(`S = \\{ 0 \\; ; \\; ${texRat([-st.b, st.a])} \\}`) + '</b></p>',
    '</div>'
  ].join('');

  // 3d) ‚Äî f(x)=k
  const alphaR = texRat(st.alpha);
  const betaR  = texRat(st.beta);
  const kR     = texRat(st.k);
  const kmBR   = texRat(sub(st.k, st.beta));           // k ‚àí Œ≤
  const m2R    = texRat(fromInt(st.m * st.m));
  const mR     = texRat(fromInt(st.m));
  const mNegR  = texRat(fromInt(-st.m));
  const xMinusAlpha2 = `\\left( x - ${alphaR} \\right)^{2}`;

  const L0 = '<p><b>On utilise la forme canonique :</b> ' + wrap(`${canonTex(st.a, st.alpha, st.beta)} = ${kR}`) + '.</p>';
  const L1 = '<p>' + wrap(`${xMinusAlpha2}${betaTailT} = ${kR}`) + '</p>';
  const L2 = '<p>' + wrap(`${xMinusAlpha2} = ${kmBR}`) + '</p>';
  const L3 = '<p>' + wrap(`${xMinusAlpha2} = ${m2R}`) + '</p>';
  const L4 = '<p>' + wrap(`x - ${alphaR} = ${mR} \\;\\mathbf{ou}\\; x - ${alphaR} = ${mNegR}`) + '</p>';
  const L5a = texRat(add(st.alpha, fromInt(st.m)));
  const L5b = texRat(sub(st.alpha, fromInt(st.m)));
  const L5 = '<p>' + wrap(`x = ${L5a} \\;\\mathbf{ou}\\; x = ${L5b}`) + '</p>';
// --- 3d : derni√®re ligne (ensemble des solutions)
const L6 = '<p><b>'+ wrap(`S = \\{ ${L5a} \\; ; \\; ${L5b} \\}`) +'</b></p>';

  const lines3d = dedup([L0, L1, L2, L3, L4, L5, L6]);

  const sol3d = [
    '<div class="step"><b>3d)</b></div>',
    '<div class="sol" style="padding:.4rem;margin:.25rem 0;border:0px solid #000">',
      ...lines3d,
    '</div>'
  ].join('');

  /* ===== variations (ex-3d ‚Üí 3e) ===== */
  const sensL2 = st.a>0?'‚Üò':'‚Üó', sensR2 = st.a>0?'‚Üó':'‚Üò';
  const expectTop = st.a<0, top = expectTop?wrap(betaR):'', bot = expectTop?'':wrap(betaR);

  const tableVar =
    '<div class="var-wrap"><table class="pdf-tbl">'+
      '<thead><tr><th>\\(x\\)</th><td>‚àí‚àû</td><td>'+wrap(alphaR)+'</td><td>+‚àû</td></tr></thead>'+
      '<tbody><tr><th rowspan="2">\\(f\\)</th><td class="bigsel" rowspan="2">'+sensL2+'</td><td style="text-align:center">'+top+'</td><td class="bigsel" rowspan="2">'+sensR2+'</td></tr><tr class="thin"><td style="text-align:center">'+bot+'</td></tr></tbody>'+
    '</table></div>';

  // ===== rendu final =====
  const html = [
    '<div class="steps">',
      '<div class="step"><b>1)</b></div>',
      table3(factStr, stepsQ1),

      '<div class="step"><b>2)</b></div>',
      table3(canonExpr, stepsQ2),

      '<div class="step"><b>3a)</b></div>',
      '<div class="sol" style="padding:.4rem;margin:.25rem 0">',
        lineR, line0, lineA,
      '</div>',

      sol3b,
      sol3c,
      sol3d,

      '<div class="step"><b>3e)</b> Tableau attendu :</div>',
      '<p>On utilise la forme canonique : ' + wrap(canonTex(st.a, st.alpha, st.beta))  + '.</p>',
      tableVar,
    '</div>'
  ].join('');


    const res = $('#res',host);
res.innerHTML = html;
typesetAll(host);
 },

  reset(host){ $('#res',host).textContent=''; }
};

/* ===== Registry & Mount ===== */
const REG=[exIdentify, exTwoWays, exVariations, exAdapt];
window.REGISTRY = window.REGISTRY && Array.isArray(window.REGISTRY) ? window.REGISTRY : REG;

function mount(){
  const sel = $("#exo-select");
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
  function newOne(){ scoreOK=0; scoreTot=0; updateScore(); const ex=get(); const st=ex.gen(); ex.render($("#host"),st); $("#host").dataset.state=JSON.stringify(st); }
  function check(){ const ex=get(); ex.correct($("#host"), JSON.parse($("#host").dataset.state||'{}')); }
  function sol(){ const ex=get(); ex.solution($("#host"), JSON.parse($("#host").dataset.state||'{}')); }
  function reset(){ const ex=get(); ex.reset($("#host")); scoreOK=0; scoreTot=0; updateScore(); }

  sel.onchange=newOne; $("#btn-new").onclick=newOne; $("#btn-check").onclick=check; $("#btn-solution").onclick=sol; $("#btn-reset").onclick=reset;
  document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ check(); }});

  // ‚¨áÔ∏è d√©marre APRES que MathJax soit pr√™t
  const boot = () => { sel.value = REG[0].id; newOne(); };
  (window.mjxReady ? mjxReady() : (window.MathJax?.startup?.promise || Promise.resolve()))
    .then(boot)
    .catch(boot); // s√©curit√©
}

document.addEventListener('DOMContentLoaded', mount);
})();
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

  ExoPDF.init({
    title: document.title.replace(/\s+‚Äì.+$/,'').trim(),
	  mountAfterSelector: '#host',   // PATCH B : la barre sera ins√©r√©e juste apr√®s le bloc #host

    beforeGen(def, st, opts){ return st; },

    /* ---- PDF : on rend exactement l'HTML de l'√©cran ; MathJax a le temps de typer avant capture ---- */
    beforeRender(def, st, withSolutions){
      try{
        const S = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
        function attachForStyles(node){
          const holder = document.createElement('div');
          holder.style.position='fixed'; holder.style.left='-10000px'; holder.style.top='-10000px';
          holder.style.width='0'; holder.style.height='0'; holder.style.overflow='hidden';
          holder.appendChild(node); document.body.appendChild(holder); return holder;
        }
        const tmp = document.createElement('div'); tmp.id='host';
        try{ if (def && typeof def.render==='function') def.render(tmp, st||{}); }catch(_){}
        const holder = attachForStyles(tmp);

        // Solution si demand√©
        if (withSolutions){
          let res = tmp.querySelector('#res'); if (!res){ res=document.createElement('div'); res.id='res'; tmp.appendChild(res); }
          try{ if (def && typeof def.solution==='function') def.solution(tmp, st||{}); }catch(_){}
        }

        // Laisser MathJax faire le rendu puis renvoyer l'HTML
        // Laisser MathJax faire le rendu puis renvoyer l'HTML
if (window.MathJax) {
  return mjxReady().then(()=> MathJax.typesetPromise([tmp]))
    .then(()=>{
      document.body.removeChild(holder);
      return (withSolutions ? (tmp.querySelector('#res')||tmp).outerHTML : tmp.innerHTML);
    })
    .catch(()=>{
      document.body.removeChild(holder);
      return (withSolutions ? (tmp.querySelector('#res')||tmp).outerHTML : tmp.innerHTML);
    });
} else {
  document.body.removeChild(holder);
  return (withSolutions ? (tmp.querySelector('#res')||tmp).outerHTML : tmp.innerHTML);
}

      }catch(e){
        console.error('PDF beforeRender error:', e);
        return null;
      }
    }
  });
});
</script>
<script>
/* UI confort (mobile, clavier, etc.) ‚Äì inchang√© */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn'); clone.type = 'button'; clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn'; fallback.type = 'button'; fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
