<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Première – Chapitre 1 – Forme canonique — Exercices (full v15)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .equ{font-variant-numeric:tabular-nums}
  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .table td:last-child,.table th:last-child{text-align:center;white-space:nowrap}

  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .step{margin:.2rem 0}
  .small{color:#555}

  /* fractions empilées */
  .frac{display:inline-flex;flex-direction:column;align-items:center;justify-content:center;vertical-align:middle;line-height:1}
  .frac .bar{display:block;border-top:1px solid #000;width:100%;margin:.08em 0}
  .frac .num,.frac .den{padding:0 .15em}
  .frac-sign{display:inline-block;margin-right:.08em;vertical-align:middle}

  /* corrections */
  .corr-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .col{border:2px dotted #bbb;border-radius:12px;padding:12px}
  .col h4{margin:.2rem 0 .6rem;font-size:1rem}
  .hl{background:#fff3b0;padding:0 .2rem;border-radius:4px}
  .muted{color:#666}

  /* ✓ / ✗ */
  .tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
  .tick.ok{color:#11823b}
  .tick.ko{color:#b00020}

  /* ---- tableau variations compact (Ex.3 & Ex.4-d) ---- */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000} /* contours noircis */
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}

  table.var input[type="text"]{width:110px;text-align:center}
  /* ---- Tableau variations : supprimer les séparations verticales autour de α ---- */
  table.var tr > td:nth-child(2),
  table.var tr > th:nth-child(2){ border-right: none; }
  table.var tr > td:nth-child(3),
  table.var tr > th:nth-child(3){ border-left: none; border-right: none; }
  table.var tr > td:nth-child(4),
  table.var tr > th:nth-child(4){ border-left: none; }
  table.var tbody tr:first-child td:nth-child(3){ border-bottom: none; }
  table.var .thin td{
    border-top: none;
    border-left: none;
    border-right: none;
    padding-top: 2px;
  }
  table.var tr > td:nth-child(2), table.var tr > th:nth-child(2){ border-right:none; }
  table.var tr > td:nth-child(3), table.var tr > th:nth-child(3){ border-left:none; border-right:none; }
  table.var tr > td:nth-child(4), table.var tr > th:nth-child(4){ border-left:none; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }

  /* ====== Alignement vertical des « = » pour les démonstrations (Ex.4 Q1 & Q2) ====== */
  .eq-steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .eq-steps .row{display:grid;grid-template-columns:auto 1.2em 1fr;gap:.4em;align-items:baseline;white-space:nowrap}
  .eq-steps .eq{text-align:center; font-weight:600}
  .eq-steps .lhs{min-width:0}
  .eq-steps .rhs{min-width:0}
  
  /* ====== Démonstrations Q1/Q2 (table 3 colonnes invisible) ====== */
.eq3{border-collapse:collapse;margin:.4rem 0}
.eq3 td{border:none;padding:2px 6px;vertical-align:baseline}
.eq3 .lhs{white-space:nowrap;font-weight:600}
.eq3 .eq{width:1.2em;text-align:center}
.eq3 .rhs{white-space:nowrap}

/* Tableau 3 colonnes invisible pour Q1 & Q2 */
.tbl3c{border-collapse:collapse;margin:.5rem 0}
.tbl3c td{border:none;padding:2px 10px;vertical-align:baseline;white-space:nowrap}
.tbl3c .eq{width:1.2em;text-align:center}





  @media print{ .controls{display:none !important;} }
  /* --- espacer automatiquement les éléments collés --- */
/* espace avant tout <b>/<strong> s’ils arrivent collés au texte */
.equ b, .equ strong,
.steps b, .steps strong { margin-left: .25em; }

/* un peu d’air autour des champs à trous de l’énoncé */
.equ input[type="text"],
.equ input[type="number"],
.equ select { margin: 0 .25em; }

/* cas fréquents de maths jolis (fractions) */
.equ .frac, .steps .frac { margin: 0 .25em; }

/* exponents très légers pour éviter x² collé à ce qui suit si c’est en gras */
.equ sup, .equ sub, .steps sup, .steps sub { margin-left: .05em; }

.math { margin: 0 0.25em; }

</style>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Première – Chapitre 1 – <strong>Forme canonique</strong> — Exercices</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; réponses acceptées :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Entrée ⏎ déclenche <b>Vérifier</b>.</li>
        <li><b>Valeurs exactes</b> : entiers ou fractions (écrire <code>a/b</code>).</li>
        <li>Puissances : <code>x^2</code>, <code>x²</code>, <code>(x+3)^2</code>, …</li>
        <li>Parenthèses pour nombres négatifs.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- dépendances -->
  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
  <script src='../../../../js/exo-pdf-kit.multiplicatif.js' defer></script>
  <script src='../../../../js/math-kbd.multiplicatif.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src='../../../../js/fraction-sign-clarity.dom.v3.js' defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

  ExoPDF.init({
    title: document.title.replace(/\s+–.+$/,'').trim(),
    beforeGen(def, st, opts){ return st; },

    beforeRender(def, st, withSolutions){
      try{
        const S = (sel,root=document)=>Array.from(root.querySelectorAll(sel));

        // --- helpers ---
        function inlineBorders(root){
          root.querySelectorAll('table').forEach(table=>{
            const csT = getComputedStyle(table);
            if (csT.borderCollapse) table.style.borderCollapse = csT.borderCollapse;
            if (csT.borderSpacing)  table.style.borderSpacing  = csT.borderSpacing;
            const hasOuter = ['Top','Right','Bottom','Left'].some(side=>csT['border'+side+'Width']!=='0px');
            if (hasOuter){
              table.style.borderTop    = `${csT.borderTopWidth} ${csT.borderTopStyle} ${csT.borderTopColor}`;
              table.style.borderRight  = `${csT.borderRightWidth} ${csT.borderRightStyle} ${csT.borderRightColor}`;
              table.style.borderBottom = `${csT.borderBottomWidth} ${csT.borderBottomStyle} ${csT.borderBottomColor}`;
              table.style.borderLeft   = `${csT.borderLeftWidth} ${csT.borderLeftStyle} ${csT.borderLeftColor}`;
            } else {
              table.style.border = 'none';
            }
            table.querySelectorAll('th,td').forEach(td=>{
              const cs = getComputedStyle(td);
              td.style.borderTop    = `${cs.borderTopWidth} ${cs.borderTopStyle} ${cs.borderTopColor}`;
              td.style.borderRight  = `${cs.borderRightWidth} ${cs.borderRightStyle} ${cs.borderRightColor}`;
              td.style.borderBottom = `${cs.borderBottomWidth} ${cs.borderBottomStyle} ${cs.borderBottomColor}`;
              td.style.borderLeft   = `${cs.borderLeftWidth} ${cs.borderLeftStyle} ${cs.borderLeftColor}`;
            });
          });
          return root;
        }
        function enforceBorders(root){
          root.querySelectorAll('table').forEach(table=>{
            table.style.borderCollapse='collapse';
            table.style.border='1px solid #000';
            S('th,td', table).forEach(td=>{ td.style.border='1px solid #000'; });
          });
          return root;
        }
        function enlargeTables(root){
          root.querySelectorAll('table').forEach(t=>{
            t.style.width='100%';
            S('th,td', t).forEach(td=>{
              td.style.padding='8px 10px';
              td.style.lineHeight='1.6';
              td.style.minHeight='28px';
              td.style.fontSize='1.02em';
              td.style.verticalAlign='middle';
            });
          });
          return root;
        }
        function removeInputs(root){
          // ENONCÉ : aucune trace d'input/select/etc.
          S('input, textarea, [contenteditable="true"], .answer, .ans, .blank, .slot, .input, .field', root).forEach(el=>{
            // on remplace par un espace discret pour éviter les mots collés
            el.replaceWith(document.createTextNode(' '));
          });
          S('select', root).forEach(sel=> sel.replaceWith(document.createTextNode(' ')));
          return root;
        }
        function attachForStyles(node){
          // Attacher hors écran pour que getComputedStyle reflète les vraies CSS
          const holder = document.createElement('div');
          holder.style.position='fixed';
          holder.style.left='-10000px';
          holder.style.top='-10000px';
          holder.style.width='0';
          holder.style.height='0';
          holder.style.overflow='hidden';
          holder.appendChild(node);
          document.body.appendChild(holder);
          return holder;
        }

        // --- render one exercise from def/st exactly like screen does ---
        const tmp = document.createElement('div');
        tmp.id = 'host';
        try{ if (def && typeof def.render==='function') def.render(tmp, st||{}); }catch(_){}

        // attach temporarily for accurate computed styles
        const holder = attachForStyles(tmp);

        // Determine exercise index via REGISTRY to apply Ex1/Ex2 rules
        const REG = window.REGISTRY || [];
        let idx = -1;
        if (def && def.id) idx = REG.findIndex(e=>e.id===def.id);

        let outHTML = '';
        if (!withSolutions){
          // === ENONCÉ ===
          removeInputs(tmp);
          // Bordures: Ex1&2 -> enforce + enlarge; Ex3&4 -> inline
          if (idx===0 || idx===1){
            enlargeTables(tmp);
            enforceBorders(tmp);
          } else {
            inlineBorders(tmp);
          }
          outHTML = tmp.innerHTML;
        } else {
          // === CORRIGÉ ===
          let res = tmp.querySelector('#res');
          if (!res){ res = document.createElement('div'); res.id='res'; tmp.appendChild(res); }
          try{ if (def && typeof def.solution==='function') def.solution(tmp, st||{}); }catch(_){}
          // align top pour éviter centrage vertical
          S('th,td', tmp).forEach(td=>{ td.style.verticalAlign='top'; });
          // Bordures: Ex3&4 -> inline; Ex1&2 -> on laisse tel quel (ou inline pour ne pas perdre contours)
          inlineBorders(tmp);
          const block = tmp.querySelector('#res') || tmp;
          outHTML = block.outerHTML;
        }

        // detach cleanup
        document.body.removeChild(holder);
        return outHTML;

      }catch(e){
        console.error('PDF beforeRender error:', e);
        return null;
      }
    }
  });
});
</script>

<script>
(function(){
'use strict';

/* ==== utils ==== */
const $=(s,r)=> (r||document).querySelector(s);
const $$=(s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
const U = ()=>DevRules.consts.UMINUS;
function scanFractions(root){ if(window.FractionSignClarity && FractionSignClarity.scan){ FractionSignClarity.scan(root||document); } }

/* rationnels exacts p/q */
function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b]}return a||1}
function simp(p,q){if(q<0){p=-p;q=-q}const g=gcd(p,q);return [p/g,q/g]}
function fromInt(n){return [n,1]}
function add([p1,q1],[p2,q2]){return simp(p1*q2+p2*q1,q1*q2)}
function sub(a,b){return add(a,[-b[0],b[1]])}
function mul([p1,q1],[p2,q2]){return simp(p1*p2,q1*q2)}
function div([p1,q1],[p2,q2]){return simp(p1*q2,q1*p2)}
function sq([p,q]){return simp(p*p,q*q)}
function htmlRat([p,q]){const s=simp(p,q);p=s[0];q=s[1];if(q===1)return String(p);const neg=p<0;p=Math.abs(p);return (neg?'<span class="frac-sign">'+U()+'</span>':'')+'<span class="frac"><span class="num">'+p+'</span><span class="bar"></span><span class="den">'+q+'</span></span>';}
function htmlRatRaw(p,q){const neg=(p<0 && q>0)||(p>0 && q<0);p=Math.abs(p);q=Math.abs(q);if(q===1)return (neg?'<span class="frac-sign">'+U()+'</span>':'')+String(p);return (neg?'<span class="frac-sign">'+U()+'</span>':'')+'<span class="frac"><span class="num">'+p+'</span><span class="bar"></span><span class="den">'+q+'</span></span>';}
function txtRat([p,q]){const s=simp(p,q);return s[1]===1? String(s[0]) : (s[0]+'/'+s[1]);}
function sup2(){ return DevRules.supPow(2); }

/* α et β exacts */
function alphaFrac(a,b){ return simp(-b,2*a) }
function betaFrac(a,b,c){ const al=alphaFrac(a,b); return add( add( mul(fromInt(a), sq(al)), mul(fromInt(b), al) ), fromInt(c) ); }

/* normalisation */
function normExpr(s){
  return String(s)
    .replace(/\\u2212|\\u2013|\\u2014|\\u2010|\\uFE63|\\uFF0D/g,'-')
    .replace(/\\u00B2/g,'^2')
    .replace(/[×·]/g,'*')
    .replace(/\\s+/g,' ')
    .trim();
}
function ratText([p,q]){ const s=simp(p,q); return (s[1]===1? String(s[0]) : '('+s[0]+'/'+s[1]+')'); }
function canonText(a,A,B){
  const pref = (a===1?'':(a===-1?'-':String(a))) + (Math.abs(a)===1?'':'*');
  return pref + '(x - '+ratText(A)+')^2 + ('+ratText(B)+')';
}
function algebraOK(exp, got){ try{ return algebraicEqual(normExpr(exp), normExpr(got)); }catch(_){ return false; } }

/* formatage */
function fmtPolyDev(a,b,c){
  const parts=[];
  if(a===1){ parts.push('x'+sup2()); }
  else if(a===-1){ parts.push(U()+' x'+sup2()); }
  else { parts.push( (a<0?U()+' '+Math.abs(a):a)+'x'+sup2() ); }
  if(b){ parts.push( (b<0?' '+U()+' ':' + ')+(Math.abs(b)===1?'x':Math.abs(b)+'x') ); }
  if(c){ parts.push( (c<0?' '+U()+' ':' + ')+Math.abs(c) ); }
  return 'f(x) = ' + (parts.join('')||'0');
}
function aPrefix(a){ return (a===1?'':(a===-1?U()+' ':a+' ')); }
function plusMinus(sign){ return sign<0?(' '+U()+' '):' + '; }
function x2_plus_kx(b_over_a){
  const sign = plusMinus(b_over_a[0]);
  const absn = Math.abs(b_over_a[0]);
  const den = Math.abs(b_over_a[1]);
  const coef = (absn===1 && den===1) ? 'x' : (htmlRat([absn,den])+'x');
  return 'x'+sup2()+ sign + coef;
}
function x_pm_frac(b_over_2a){
  const s = b_over_2a[0]<0 ? (' '+U()+' '+htmlRat([-b_over_2a[0],b_over_2a[1]])) : (' + '+htmlRat(b_over_2a));
  return '( x'+s+' )'+sup2();
}
function canonHTML(a, A, B){
  const pref = aPrefix(a);
  const xm = 'x ' + (A[0]===0? U()+' ' : (A[0]>0? U()+' ':' + ')) + htmlRat([Math.abs(A[0]),A[1]]);
  const bet = B[0]<0 ? (' '+U()+' '+htmlRat([-B[0],B[1]])) : (' + '+htmlRat(B));
  return pref+'( '+xm+' )'+sup2()+bet;
}
function setTick(el, ok){
  let t = el.nextElementSibling;
  if(!t || !t.classList.contains('tick')){
    t=document.createElement('span'); t.className='tick'; el.after(t);
  }
  t.textContent = ok ? '✔' : '✗';
  t.classList.toggle('ok', ok);
  t.classList.toggle('ko', !ok);
}
<!-- === Helpers globaux (remplacer l'ancien bloc) === -->

(function () {
  // Affiche proprement un facteur : (x+0)→x ; (x-0)→x ; (x)→x
  window.H_factTerm = function (r) {
    if (r === 0) return "x";
    return r > 0 ? "(x − " + r + ")" : "(x + " + (-r) + ")";
  };

  // Construit une ligne polynomiale propre : pas de +0, 0x, 1x
  window.H_polyLine = function (a, b, c) {
    var s = "", abs = Math.abs;
    if (a !== 0) s += (a === 1 ? "x²" : (a === -1 ? "−x²" : a + "x²"));
    if (b !== 0) s += (b > 0 ? (s ? " + " : "") : (s ? " − " : "−")) + (abs(b) === 1 ? "x" : abs(b) + "x");
    if (c !== 0) s += (c > 0 ? (s ? " + " : "") : (s ? " − " : "−")) + abs(c);
    return s || "0";
  };

  // Déduplique des étapes (consécutives ou non)
  window.H_dedup = function (arr) {
    var seen = Object.create(null), out = [], i, k;
    for (i = 0; i < arr.length; i++) {
      k = String(arr[i]);
      if (!seen[k]) { seen[k] = 1; out.push(arr[i]); }
    }
    return out;
  };

  // Tableau invisible à 3 colonnes : col1 = expression (seulement ligne 1), col2 = "=", col3 = étape
  window.H_table3 = function (exprHTML, stepsHTMLArray) {
    var rows = [];
    for (var i = 0; i < stepsHTMLArray.length; i++) {
      rows.push(
        '<tr>' +
          '<td class="lhs">' + (i === 0 ? exprHTML : '') + '</td>' +
          '<td class="eq">=</td>' +
          '<td class="rhs">' + stepsHTMLArray[i] + '</td>' +
        '</tr>'
      );
    }
    return '<table class="eq3" style="border-collapse:collapse;width:100%">' +
             '<tbody>' + rows.join('') + '</tbody>' +
           '</table>';
  };
})();


/* ===================== Ex1 : Identifier la forme ===================== */
const exIdentify={ id:'id', title:'Différentes formes : identifier « développée / canonique / factorisée »',
  gen(){
    const r=rnd(-5,5), s=rnd(-5,5), a=choice([-1,1]), b=-a*(r+s), c=a*r*s;
    const alpha=div(fromInt(-b), fromInt(2*a));
    const beta=sub(fromInt(c), div(fromInt(b*b), fromInt(4*a)));
    const Fdev = fmtPolyDev(a,b,c).replace('f(x) = ','');
    const pref=(a===1?'':(a===-1?U()+' ':a+' '));
    const xm = 'x ' + (alpha[0]===0? U()+' ' : (alpha[0]>0? U()+' ':' + ')) + htmlRat([Math.abs(alpha[0]),alpha[1]]);
    const Fcan = pref+'( '+xm+' )'+sup2() + (beta[0]<0?' '+U()+' '+htmlRat([-beta[0],beta[1]]):' + '+htmlRat(beta));
    const Fac  = (a===1?'':(a===-1?U()+' ':String(a)+' ')) + '( x ' + (r>0? U()+' '+r : (r<0? ' + '+(-r):'')) + ' )( x ' + (s>0? U()+' '+s : (s<0? ' + '+(-s):'')) + ' )';
    const rows=[{expr:Fdev,label:'Développée'},{expr:Fcan,label:'Canonique'},{expr:Fac,label:'Factorisée'}].sort(()=>Math.random()-.5);
    return {rows};
  },
  render(host,st){
    host.innerHTML=[
      '<div class="equ">Associer chaque écriture à son type.</div>',
      '<table class="table"><thead><tr><th>#</th><th>Écriture</th><th>Type</th></tr></thead><tbody>',
      st.rows.map((r,i)=>`<tr data-i="${i}"><td><b>${String.fromCharCode(97+i)}.</b></td><td>${r.expr}</td>
      <td><select class="T"><option value=""></option><option>Développée</option><option>Canonique</option><option>Factorisée</option></select><span class="tick"></span></td></tr>`).join(''),
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
  },
  correct(host,st){
    let ok=0,tot=0;
    $$('.table tbody tr',host).forEach((tr,i)=>{
      const got=$('.T',tr).value; const want=st.rows[i].label;
      if(got){tot++; if(got===want){ok++;}}
      setTick($('.T',tr), got===want);
    });
    $('#res',host).innerHTML='<div class="steps"><div class="step">Résultat : <b>'+ok+' / '+tot+'</b></div></div>'; scoreTot+=tot; scoreOK+=ok; updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML='<div class="steps">'+st.rows.map((r,i)=>'<div class="step">('+(i+1)+') : <b>'+r.label+'</b></div>').join('')+'</div>';
  },
  reset(host){ $('#res',host).textContent=''; }
};

/* ===================== Ex2 : Deux méthodes ===================== */
const exTwoWays={ id:'2w', title:'Forme canonique — 2 méthodes (tableau 2 colonnes)',
  gen(){
    let a=choice([-3,-2,-1,1,2,3]);
    let b=rnd(-6,6), c=rnd(-6,6);
    if(Math.abs(a)===1 && b%2!==0) b++; // éviter α demi quand a=±1
    return {a,b,c,alpha:alphaFrac(a,b),beta:betaFrac(a,b,c)};
  },
  render(host,st){
    host.innerHTML=[
      '<div class="equ">',fmtPolyDev(st.a,st.b,st.c),'</div>',
      '<table class="table"><thead><tr><th></th><th>Réponse</th></tr></thead><tbody>',
      '<tr><td>α =</td><td><input class="alpha" type="text" style="width:160px"><span class="tick"></span></td></tr>',
      '<tr><td>β =</td><td><input class="beta" type="text" style="width:160px"><span class="tick"></span></td></tr>',
      '<tr><td>f(x) =</td><td><input class="canon" type="text" style="width:360px" placeholder="a(x−α)^2 + β"><span class="tick"></span></td></tr>',
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    host.dataset.state=JSON.stringify(st);
  },
  correct(host,st){
    let ok=0, tot=0;
    const a1=$('.alpha',host).value.trim(); if(a1){ const okA = algebraOK(txtRat(st.alpha), a1); setTick($('.alpha',host), okA); tot++; if(okA) ok++; }
    const b1=$('.beta',host).value.trim();  if(b1){ const okB = algebraOK(txtRat(st.beta),  b1); setTick($('.beta',host),  okB); tot++; if(okB) ok++; }
    const c1=$('.canon',host).value.trim(); if(c1){ const okC = algebraOK(canonText(st.a, st.alpha, st.beta), c1); setTick($('.canon',host), okC); tot++; if(okC) ok++; }
    $('#res',host).innerHTML='<div class="steps"><div class="step">Résultat : <b>'+ok+' / '+tot+'</b></div></div>';
    scoreTot+=tot; scoreOK+=ok; updateScore();
  },
  solution(host,st){
    const {a,b,c}=st; const A=st.alpha, B=st.beta;
    if(b===0){
      $('#res',host).innerHTML = [
        '<div class="steps">',
          '<div>a = ',a,' ; b = ',b,' ; c = ',c,'</div>',
          '<div>Comme b = 0, <b>f(x)</b> est déjà sous forme canonique avec α = 0 et β = ',htmlRat([c,1]),'.</div>',
          '<div>Donc ', aPrefix(a),'( x ', U(),' 0 )',sup2(),' + ',htmlRat([c,1]),'</div>',
        '</div>'
      ].join('');
      scanFractions($('#res',host)); return;
    }
    const b_a = simp(st.b,st.a), b_2a = simp(st.b,2*st.a);
    const minus_a_square = mul(fromInt(-st.a), sq(b_2a));
    const rawAlpha = htmlRatRaw(-st.b,2*st.a), simpAlpha = htmlRat(A);
    const alphaLine = (rawAlpha===simpAlpha)
      ? `α = <span class="frac-sign">${U()}</span><span class="frac"><span class="num">b</span><span class="bar"></span><span class="den">2a</span></span> = ${simpAlpha}`
      : `α = <span class="frac-sign">${U()}</span><span class="frac"><span class="num">b</span><span class="bar"></span><span class="den">2a</span></span> = ${rawAlpha} = ${simpAlpha}`;

    const left = `
      <h4>1<sup>ère</sup> méthode : <span class="muted">avec α et β</span></h4>
      f(x) = a(x − α)${sup2()} + β<br>
      Avec a = ${st.a} ; b = ${st.b} ; c = ${st.c}<br>
      ${alphaLine} et<br>
      β = f(α) = ${st.a===1?'':(st.a===-1?U()+' ':st.a+' × ')}( ${htmlRat(A)} )${sup2()} ${plusMinus(st.b)} ${htmlRat([Math.abs(st.b),1])} × ${htmlRat(A)} ${plusMinus(st.c)} ${htmlRat([Math.abs(st.c),1])} = ${htmlRat(B)}<br><br>
      f(x) = ${canonHTML(st.a,A,B)}
    `;

    const right = `
      <h4>2<sup>ème</sup> méthode : <span class="muted">En identifiant une identité remarquable</span></h4>
      <b>Etape 1 :</b> On factorise par a les deux 1<sup>ers</sup> termes :<br>
      f(x) = ${aPrefix(st.a)}( ${x2_plus_kx(b_a)} ) ${plusMinus(st.c)} ${htmlRat([Math.abs(st.c),1])}<br><br>
      <b>Etape 2 :</b> <span class="hl">${x2_plus_kx(b_a)}</span> est le début de l’identité remarquable <span class="hl">${x_pm_frac(b_2a)}</span><br>
      ${x_pm_frac(b_2a)} = ${x2_plus_kx(b_a)} + ${htmlRat(sq(b_2a))}<br>
      <span class="hl">${x2_plus_kx(b_a)}</span> = ${x_pm_frac(b_2a)} ${U()} ${htmlRat(sq(b_2a))}<br><br>
      <b>Etape 3 :</b> On regroupe correctement puis on distribue a :<br>
      f(x) = ${aPrefix(st.a)}( ${x_pm_frac(b_2a)} ${U()} ${htmlRat(sq(b_2a))} ) ${plusMinus(st.c)} ${htmlRat([Math.abs(st.c),1])}<br>
      f(x) = ${aPrefix(st.a)}( x ${(b_2a[0]<0? ' '+U()+' '+htmlRat([-b_2a[0],b_2a[1]]) : ' + '+htmlRat(b_2a))} )${sup2()} ${plusMinus(minus_a_square[0])} ${htmlRat([Math.abs(minus_a_square[0]), minus_a_square[1]])} ${plusMinus(st.c)} ${htmlRat([Math.abs(st.c),1])}<br>
      f(x) = ${canonHTML(st.a,A,B)}
    `;
    $('#res',host).innerHTML = `<div class="equ"><span class="muted">a = ${st.a} ; b = ${st.b} ; c = ${st.c}</span></div><div class="corr-grid"><div class="col">${left}</div><div class="col">${right}</div></div>`;
    scanFractions($('#res',host));
  },
  reset(host){ $('#res',host).textContent=''; }
};

/* ===================== Ex3 : Tableau de variations ===================== */
const exVariations={ id:'var', title:'Tableau de variations à compléter (f en forme canonique)',
  gen(){ const a=choice([-3,-2,-1,1,2,3]); const alpha=fromInt(rnd(-5,5)); const beta=fromInt(rnd(-6,6)); return {a,alpha,beta}; },
  render(host,st){
    const pref=(st.a===1?'':(st.a===-1?U()+' ':st.a+' '));
    const xm = 'x ' + (st.alpha[0]===0? U()+' ' : (st.alpha[0]>0? U()+' ':' + ')) + htmlRat([Math.abs(st.alpha[0]),st.alpha[1]]);
    const bet = (st.beta[0]<0?' '+U()+' '+htmlRat([-st.beta[0],st.beta[1]]):' + '+htmlRat(st.beta));
    host.innerHTML=[
      '<div class="equ">On considère f(x) = ',pref,'( ',xm,' )',sup2(), bet,'.</div>',
      '<div style="margin:.4rem 0">Sommet : S( <input class="alpha-q" type="text" style="width:110px"> ; <input class="beta-q" type="text" style="width:110px"> )<span class="tick"></span></div>',
      '<div class="var-wrap"><table class="var">',
'<thead><tr><th>x</th><td>−∞</td><td style="text-align:center"><input class="alpha-in" type="text" style="width:90px"></td><td>+∞</td></tr></thead>',
      '<tbody>',
  '<tr>',
    '<th rowspan="3">f</th>',
    '<td class="bigsel" rowspan="3"><select class="d-L"><option value=""></option><option>↘</option><option>↗</option></select></td>',
    '<td style="text-align:center"><input class="d-beta-top" type="text" placeholder="maximum"></td>',
    '<td class="bigsel" rowspan="3"><select class="d-R"><option value=""></option><option>↘</option><option>↗</option></select></td>',
  '</tr>',
  '<tr class="gaprow"><td></td></tr>',
  '<tr class="thin">',
    '<td style="text-align:center"><input class="d-beta-bot" type="text" placeholder="minimum"></td>',
  '</tr>',
'</tbody></table></div>',
      '<div id="res" class="small"></div>'
    ].join('');
  },
  correct(host,st){
    let ok=0, tot=0;
    const alphaOK1 = algebraOK(txtRat(st.alpha), $('.alpha-q',host).value.trim()); if($('.alpha-q',host).value.trim()) { setTick($('.alpha-q',host),alphaOK1); tot++; if(alphaOK1) ok++; }
    const betaOK1  = algebraOK(txtRat(st.beta),  $('.beta-q',host).value.trim());  if($('.beta-q',host).value.trim())  { setTick($('.beta-q',host),betaOK1);  tot++; if(betaOK1)  ok++; }

    const alphaOK = algebraOK(txtRat(st.alpha), $('.alpha-in',host).value.trim()); if($('.alpha-in',host).value.trim()){ setTick($('.alpha-in',host),alphaOK); tot++; if(alphaOK) ok++; }

    const expect = st.a>0? ['↘','↗','bot'] : ['↗','↘','top']; // bot=min, top=max
    const leftFilled = $('.L',host).value!==''; const rightFilled=$('.R',host).value!=='';
    if(leftFilled){ const leftOK=$('.L',host).value===expect[0]; setTick($('.L',host),leftOK); tot++; if(leftOK) ok++; }
    if(rightFilled){ const rightOK=$('.R',host).value===expect[1]; setTick($('.R',host),rightOK); tot++; if(rightOK) ok++; }

    const betaTop = $('.beta-top',host).value.trim(), betaBot = $('.beta-bot',host).value.trim();
    if(betaTop || betaBot){
      let betaOK=false;
      if(expect[2]==='top'){
        betaOK = algebraOK(txtRat(st.beta), betaTop) && betaBot==='' ;
        setTick($('.beta-top',host), algebraOK(txtRat(st.beta), betaTop));
        if(betaBot) setTick($('.beta-bot',host), false);
      }else{
        betaOK = algebraOK(txtRat(st.beta), betaBot) && betaTop==='' ;
        setTick($('.beta-bot',host), algebraOK(txtRat(st.beta), betaBot));
        if(betaTop) setTick($('.beta-top',host), false);
      }
      tot++; if(betaOK) ok++;
    }
    $('#res',host).innerHTML = '<div class="steps"><div class="step">Résultat : <b>'+ok+' / '+tot+'</b></div></div>';
    scoreTot+=tot; scoreOK+=ok; updateScore();
  },
  solution(host,st){
    const expectTop = st.a<0; // max en haut si a<0
    const top = expectTop ? htmlRat(st.beta) : '';
    const bot = expectTop ? '' : htmlRat(st.beta);
    const sensL = st.a>0?'↘':'↗';
    const sensR = st.a>0?'↗':'↘';
    $('#res',host).innerHTML = [
      '<div class="steps"><div class="step"><b>Sommet :</b> S( ',htmlRat(st.alpha),' ; ',htmlRat(st.beta),' ).</div>',
      '<div class="step">Tableau attendu :</div>',
      '<div class="var-wrap"><table class="var">',
'<thead><tr><th>x</th><td>−∞</td><td>' + htmlRat(st.alpha) + '</td><td>+∞</td></tr></thead>',
      '<tbody>',
      '<tr><th rowspan="2">f</th><td class="bigsel" rowspan="2">',sensL,'</td><td style="text-align:center">',top,'</td><td class="bigsel" rowspan="2">',sensR,'</td></tr>',
      '<tr class="thin"><td style="text-align:center">',bot,'</td></tr>',
      '</tbody></table></div>',
      '</div>'
    ].join('');
    scanFractions($('#res',host));
  },
  reset(host){ $('#res',host).textContent=''; }
};


/* ===================== Ex4 : Forme adaptée (avec saisies) — FULL =====================
   Remplacement 1:1 de votre objet exAdapt. Q1 & Q2 conservés.
   Q3a => 3 phrases détaillées (pas de tableau). Q3b/c/d au format S = { … } ; variations deviennent 3e.
   Dépendances (inchangées) : U, sup2, htmlRat, htmlRatRaw, txtRat, fmtPolyDev, canonHTML,
   add, sub, fromInt, choice, rnd, algebraOK, setTick, scanFractions, $, etc.
*/
const exAdapt = {
  id:'ad',
  title:'Choisir la forme adaptée (image, équations, variations) — avec saisie',

  gen(){
    const a = 1;
    let r1 = rnd(-5,4);
    let r2 = r1; while(r2 === r1) r2 = rnd(-6,5);
    const b = -(r1 + r2), c = r1 * r2;
    const alpha = alphaFrac(a, b);
    const beta  = betaFrac(a, b, c);

    const half = Math.abs(r1 - r2) / 2;
    const pool = [1,2,3].filter(x => x !== half);
    const m = pool.length ? choice(pool) : 1;
    const k = add(beta, fromInt(a*m*m)); // β + m^2

    // racine affichée pour 3a (image d’une racine → 0)
    const r = choice([r1, r2]);

    return { a, b, c, r1, r2, r, alpha, beta, k, m };
  },

  render(host, st){
    const poly  = fmtPolyDev(st.a, st.b, st.c);
    const canon = canonHTML(st.a, st.alpha, st.beta);
    const fact  =
      (st.a===1?'':(st.a===-1?U()+' ':st.a+' ')) +
      '( x ' + (st.r1>0 ? U()+' '+st.r1 : (st.r1<0?' + '+(-st.r1):'')) + ' )' +
      '( x ' + (st.r2>0 ? U()+' '+st.r2 : (st.r2<0?' + '+(-st.r2):'')) + ' )';

    host.innerHTML = [
      '<div class="equ">On considère la fonction f sous sa forme développée : ', poly, '.</div>',
      '<ol>',
        '<li>Montrer que <span class="math">' + fact + '</span> est une forme factorisée de f.</li>',
        '<li>Montrer que <span class="math">' + canon + '</span> est la forme canonique de f.</li>',
        '<li>Choisir la forme la mieux adaptée et répondre :',
          '<ol type="a">',

            // a) images — inchangé (on garde les 3 saisies)
            '<li>Calculer l’image de <b>', st.r, '</b> ',
              '<input class="q3a_r1" style="width:110px"> <span class="tick"></span>, ',
              'de <b>0</b> <input class="q3a_0" style="width:110px"> <span class="tick"></span> ',
              'et de <b>', htmlRat(st.alpha), '</b> <input class="q3a_alpha" style="width:110px"> <span class="tick"></span></li>',

            // b) f(x)=0 → saisie ensemble
            '<li>Résoudre l’équation <b>f(x)=0</b> : ',
              'S = <input class="q3bS" style="width:220px" placeholder="{ … }"> <span class="tick"></span></li>',

            // c) f(x)=c (valeur numérique)
            '<li>Résoudre l’équation <b>f(x)=', st.c, '</b> : ',
              'S = <input class="q3cS" style="width:220px" placeholder="{ … }"> <span class="tick"></span></li>',

            // d) f(x)=k (β + m²) (affiche k numérique)
            '<li>Résoudre l’équation <b>f(x)=', htmlRat(st.k), '</b> : ',
              'S = <input class="q3dS" style="width:220px" placeholder="{ … }"> <span class="tick"></span></li>',

            // e) variations (ex-d)
            '<li>Déterminer les variations de f :</li>',
          '</ol>',

          // tableau variations (inchangé)
          '<div class="var-wrap" style="margin:.4rem 0 .6rem 0"><table class="var">',
            '<thead><tr><th>x</th><td>−∞</td><td style="text-align:center"><input class="d-alpha" type="text" style="width:90px"></td><td>+∞</td></tr></thead>',
            '<tbody>',
              '<tr>',
                '<th rowspan="3">f</th>',
                '<td class="bigsel" rowspan="3"><select class="d-L"><option value=""></option><option>↘</option><option>↗</option></select></td>',
                '<td style="text-align:center"><input class="d-beta-top" type="text" placeholder="maximum"></td>',
                '<td class="bigsel" rowspan="3"><select class="d-R"><option value=""></option><option>↘</option><option>↗</option></select></td>',
              '</tr>',
              '<tr class="gaprow"><td></td></tr>',
              '<tr class="thin">',
                '<td style="text-align:center"><input class="d-beta-bot" type="text" placeholder="minimum"></td>',
              '</tr>',
            '</tbody></table></div>',
        '</li>',
      '</ol>',
      '<div id="res" class="small"></div>'
    ].join('');
  },

  correct(host, st){
    let ok = 0, tot = 0;

    // === 3a (inchangé côté vérif)
    const a1OK = algebraOK("0", $('.q3a_r1',host).value.trim());
    if($('.q3a_r1',host).value.trim()){ setTick($('.q3a_r1',host), a1OK); tot++; if(a1OK) ok++; }

    const a2OK = algebraOK(txtRat(fromInt(st.c)), $('.q3a_0',host).value.trim());
    if($('.q3a_0',host).value.trim()){ setTick($('.q3a_0',host), a2OK); tot++; if(a2OK) ok++; }

    const a3OK = algebraOK(txtRat(st.beta), $('.q3a_alpha',host).value.trim());
    if($('.q3a_alpha',host).value.trim()){ setTick($('.q3a_alpha',host), a3OK); tot++; if(a3OK) ok++; }

    // === utilitaire ensembles : "S = { … }"
    function setAnswerOK(inputStr, expectedVals){
      if(!inputStr) return false;
      const s = inputStr.replace(/\s+/g,'').replace(/^S=?/, '').replace(/^\{|\}$/g,'');
      const parts = s.split(/[;,]/).filter(Boolean);
      if(parts.length !== expectedVals.length) return false;
      const used = new Array(parts.length).fill(false);
      for(const exp of expectedVals){
        let found = false;
        for(let i=0;i<parts.length;i++){
          if(used[i]) continue;
          if(algebraOK(txtRat(exp), parts[i]) || algebraOK(txtRat(fromInt(exp)), parts[i])){
            used[i]=true; found=true; break;
          }
        }
        if(!found) return false;
      }
      return true;
    }

    // === 3b : f(x)=0  → S={r1 ; r2}
    {
      const inB = $('.q3bS',host).value.trim();
      if(inB){
        const okB = setAnswerOK(inB, [st.r1, st.r2]);
        setTick($('.q3bS',host), okB); tot++; if(okB) ok++;
      }
    }

    // === 3c : f(x)=c  → ax²+bx+c=c ⇒ ax²+bx=0 ⇒ x=0 ou x=−b/a
    {
      const inC = $('.q3cS',host).value.trim();
      if(inC){
        const sols = [0, -st.b/st.a];
        const okC = setAnswerOK(inC, sols);
        setTick($('.q3cS',host), okC); tot++; if(okC) ok++;
      }
    }

    // === 3d : f(x)=k = β + m²  ⇒ x = α ± m
    {
      const inD = $('.q3dS',host).value.trim();
      if(inD){
        const s1 = add(st.alpha, fromInt(st.m));
        const s2 = sub(st.alpha, fromInt(st.m));
        const okD = setAnswerOK(inD, [s1, s2]);
        setTick($('.q3dS',host), okD); tot++; if(okD) ok++;
      }
    }

    // === 3e variations (ex-d)
    const expect = st.a>0? ['↘','↗','bot'] : ['↗','↘','top'];
    const A=$('.d-alpha',host).value.trim(), LT=$('.d-L',host).value, RT=$('.d-R',host).value;
    if(A){ const AOK=algebraOK(txtRat(st.alpha),A); setTick($('.d-alpha',host),AOK); tot++; if(AOK) ok++; }
    if(LT){ const LOK=(LT===expect[0]); setTick($('.d-L',host),LOK); tot++; if(LOK) ok++; }
    if(RT){ const ROK=(RT===expect[1]); setTick($('.d-R',host),ROK); tot++; if(ROK) ok++; }
    const bTop=$('.d-beta-top',host).value.trim(), bBot=$('.d-beta-bot',host).value.trim();
    if(bTop || bBot){
      let bOK=false;
      if(expect[2]==='top'){ bOK = algebraOK(txtRat(st.beta), bTop) && bBot===''; setTick($('.d-beta-top',host), algebraOK(txtRat(st.beta), bTop)); if(bBot) setTick($('.d-beta-bot',host), false); }
      else { bOK = algebraOK(txtRat(st.beta), bBot) && bTop===''; setTick($('.d-beta-bot',host), algebraOK(txtRat(st.beta), bBot)); if(bTop) setTick($('.d-beta-top',host), false); }
      tot++; if(bOK) ok++;
    }

    $('#res',host).innerHTML='<div class="steps"><div class="step">Résultat : <b>'+ok+' / '+tot+'</b></div></div>';
    scoreTot+=tot; scoreOK+=ok; updateScore();
  },

  solution(host, st){
    // === Helpers d’affichage locaux ===
    const pm = k => k>0 ? ' + ' : ' ' + U() + ' ';
    const termX = k => (Math.abs(k)===1 ? 'x' : Math.abs(k)+'x');

    function polyLine(b,c){
      let s = 'x' + sup2();
      if(b) s += pm(b) + termX(b);
      if(c) s += pm(c) + Math.abs(c);
      return s;
    }
    function foilLine(a1,b1,a1b1){
      const parts = ['x' + sup2()];
      if(b1)   parts.push(pm(b1)   + termX(b1));
      if(a1)   parts.push(pm(a1)   + termX(a1));
      if(a1b1) parts.push(pm(a1b1) + Math.abs(a1b1));
      return parts.join('');
    }
    function table3(exprFirstCol, lines){
      const rows = lines.map((rhs,i)=> i===0
        ? '<tr><td rowspan="'+lines.length+'">'+exprFirstCol+'</td><td class="eq">=</td><td>'+rhs+'</td></tr>'
        : '<tr><td class="eq">=</td><td>'+rhs+'</td></tr>'
      ).join('');
      return '<table class="tbl3c"><tbody>'+rows+'</tbody></table>';
    }
    const dedup = arr => arr.filter((x,i,a)=> i===0 || x!==a[i-1]);
    function factorStr(r){
      if(r===0) return 'x';
      return '( x ' + (r>0 ? U()+' '+r : ' + '+(-r)) + ' )';
    }

    /* ===== Q1 (inchangé) ===== */
    const a1 = -st.r1, b1 = -st.r2, a1b1 = a1*b1;
    const factStr = (factorStr(st.r1) + ' ' + factorStr(st.r2)).replace(/\s+/g,' ').trim();
    const lineFOIL = foilLine(a1,b1,a1b1);
    const lineReg  = polyLine(st.b, st.c);
    let stepsQ1 = [ lineFOIL, lineReg, 'f(x)' ];
    stepsQ1 = dedup(stepsQ1);

    /* ===== Q2 (inchangé) ===== */
    const canonExpr =
      '( x ' + (st.b>=0 ? ' + ' + htmlRat([st.b,2]) : ' ' + U() + ' ' + htmlRat([Math.abs(st.b),2])) + ' )'
      + sup2()
      + (st.beta[0]<0 ? ' ' + U() + ' ' + htmlRat([-st.beta[0],st.beta[1]]) : ' + ' + htmlRat(st.beta));
    const bOver2sq = st.b ? htmlRat([st.b*st.b,4]) : '';
    let l2 = 'x'+sup2();
    if(st.b)       l2 += pm(st.b) + termX(st.b);
    if(st.b)       l2 += ' + ' + bOver2sq;
    if(st.beta[0]) l2 += (st.beta[0]<0 ? ' ' + U() + ' ' : ' + ') + htmlRat([Math.abs(st.beta[0]), Math.abs(st.beta[1])]);
    const fourC = 4*st.c;
    let l3 = 'x'+sup2();
    if(st.b)   l3 += pm(st.b) + termX(st.b);
    if(fourC)  l3 += (fourC>0 ? ' + ' : ' ' + U() + ' ') + htmlRatRaw(Math.abs(fourC),4);
    const l4 = polyLine(st.b, st.c);
    let stepsQ2 = [ l2, l3, l4, 'f(x)' ];
    stepsQ2 = dedup(stepsQ2);

    /* ===== Q3a : 3 phrases détaillées (pas de tableau) ===== */
    let dev0 = '0'+sup2();
    if (st.b) dev0 += (st.b>0 ? ' + '+Math.abs(st.b)+' × 0' : ' ' + U() + ' ' + Math.abs(st.b) + ' × 0');
    if (st.c) dev0 += (st.c>0 ? ' + '+Math.abs(st.c) : ' ' + U() + ' ' + Math.abs(st.c));

    const alphaHTML = htmlRat(st.alpha);
    const betaHTML  = htmlRat(st.beta);
    const alphaSign = st.alpha[0]>0 ? ' ' + U() + ' ' + htmlRat([st.alpha[0], st.alpha[1]]) : ' + ' + htmlRat([-st.alpha[0], st.alpha[1]]);
    const betaTail  = st.beta[0] < 0 ? ' ' + U() + ' ' + htmlRat([-st.beta[0], st.beta[1]]) : ' + ' + betaHTML;

    const lineR =
      '<p>Pour ' + st.r + ', on utilise la forme factorisée : ' +
      'f(' + st.r + ') = (' + st.r + (st.r1>0? ' ' + U() + ' ' + st.r1 : ' + ' + (-st.r1)) + ')' +
      '(' + st.r + (st.r2>0? ' ' + U() + ' ' + st.r2 : ' + ' + (-st.r2)) + ') = 0.</p>';
    const line0 = '<p>Pour 0, on utilise la forme développée : f(0) = ' + dev0 + ' = ' + st.c + '.</p>';
    const lineA =
      '<p>Pour ' + alphaHTML + ', on utilise la forme canonique : ' +
      'f(' + alphaHTML + ') = ( ' + alphaHTML + alphaSign + ' )' + sup2() + betaTail + ' = ' + betaHTML + '.</p>';

    /* ===== 3b/3c/3d : blocs de solution rédigés ===== */
    const sol3b = [
      '<div class="step"><b>3b)</b></div>',
      '<div class="sol" style="padding:.4rem;margin:.25rem 0;border:0px solid #000">',
        '<p><b>On utilise la forme factorisée :</b> ( x ' + (st.r1>0? U()+' '+st.r1 : ' + '+(-st.r1)) + ' )( x ' +
        (st.r2>0? U()+' '+st.r2 : ' + '+(-st.r2)) + ' ) = 0.</p>',
        '<p>Un produit de facteur est nul si et seulement si un des facteurs est nul.</p>',
        '<p>x ' + (st.r1>0? U()+' '+st.r1 : ' + '+(-st.r1)) + ' = 0 <b>ou</b> x ' +
          (st.r2>0? U()+' '+st.r2 : ' + '+(-st.r2)) + ' = 0</p>',
        '<p>x = ' + st.r1 + ' <b>ou</b> x = ' + st.r2 + '</p>',
        '<p><b>S = { ' + st.r1 + ' ; ' + st.r2 + ' }</b></p>',
      '</div>'
    ].join('');

    const sol3c = [
      '<div class="step"><b>3c)</b></div>',
      '<div class="sol" style="padding:.4rem;margin:.25rem 0;border:0px solid #000">',
        '<p><b>On utilise la forme développée :</b> x', sup2(), (st.b? (st.b>0? ' + '+st.b+'x' : ' ' + U() + ' ' + (-st.b) + 'x') : ''), ' = 0.</p>',
        '<p>x', sup2(), (st.b? (st.b>0? ' + '+st.b+'x' : ' ' + U() + ' ' + (-st.b) + 'x') : ''), ' = 0</p>',
        '<p>x( x ', (st.b? (st.b>0? ' + '+st.b : ' ' + U() + ' ' + (-st.b)) : ''), ' ) = 0</p>',
        '<p>x = 0 <b>ou</b> x ', (st.b? (st.b>0? ' + '+st.b : ' ' + U() + ' ' + (-st.b)) : ''), ' = 0</p>',
        '<p>x = 0 <b>ou</b> x = ', txtRat(fromInt(-st.b/st.a)), '</p>',
        '<p><b>S = { 0 ; ', txtRat(fromInt(-st.b/st.a)), ' }</b></p>',
      '</div>'
    ].join('');

/* ===== 3d) Solution — f(x)=k (fractions en pile partout) ===== */
const alphaRat      = htmlRat(st.alpha);
const betaRat       = htmlRat(st.beta);
const kRat          = htmlRat(st.k);
const kMinusBetaRat = htmlRat(sub(st.k, st.beta));           // k − β
const mRat          = htmlRat(fromInt(st.m));
const mNegRat       = htmlRat(fromInt(-st.m));
const m2Rat         = htmlRat(fromInt(st.m*st.m));
const aPlusMRat     = htmlRat(add(st.alpha, fromInt(st.m))); // α + m
const aMinusMRat    = htmlRat(sub(st.alpha, fromInt(st.m))); // α − m

/* ===== 3d) Solution — f(x)=k (fractions en pile, sans doublons ni doubles signes) ===== */
const alphaR = htmlRat(st.alpha);
const betaR  = htmlRat(st.beta);
const kR     = htmlRat(st.k);
const kmBR   = htmlRat(sub(st.k, st.beta));                 // k − β
const m2R    = txtRat(fromInt(st.m * st.m));
const mR     = htmlRat(fromInt(st.m));
const mNegR  = htmlRat(fromInt(-st.m));
const xMinusAlpha2 = '( x − ' + alphaR + ' )' + sup2();



// lignes (certaines peuvent devenir identiques si β=0, on déduplique ensuite)
const L0 = '<p><b>On utilise la forme canonique :</b> ' + canonHTML(st.a, st.alpha, st.beta) + ' = ' + kR + '.</p>';
const L1 = '<p>' + xMinusAlpha2 + betaTail + ' = ' + kR + '</p>';
const L2 = '<p>' + xMinusAlpha2 + ' = ' + kmBR + '</p>';
const L3 = '<p>' + xMinusAlpha2 + ' = ' + m2R + '</p>';
const L4 = '<p>x − ' + alphaR + ' = ' + mR + ' <b>ou</b> x − ' + alphaR + ' = ' + mNegR + '</p>';
const L5a = htmlRat(add(st.alpha, fromInt(st.m)));
const L5b = htmlRat(sub(st.alpha, fromInt(st.m)));
const L5 = '<p>x = ' + L5a + ' <b>ou</b> x = ' + L5b + '</p>';
const L6 = '<p><b>S = { ' + L5a + ' ; ' + L5b + ' }</b></p>';

// dédoublonnage (supprime les répétitions consécutives)

const lines3d = dedup([L0, L1, L2, L3, L4, L5, L6]);

const sol3d = [
  '<div class="step"><b>3d)</b></div>',
  '<div class="sol" style="padding:.4rem;margin:.25rem 0;border:0px solid #000">',
    ...lines3d,
  '</div>'
].join('');





    /* ===== variations (ex-3d → 3e) ===== */
    const sensL2 = st.a>0?'↘':'↗', sensR2 = st.a>0?'↗':'↘';
    const expectTop = st.a<0, top = expectTop?htmlRat(st.beta):'', bot = expectTop?'':htmlRat(st.beta);
    const tableVar =
      '<div class="var-wrap"><table class="var">'+
        '<thead><tr><th>x</th><td>−∞</td><td>'+htmlRat(st.alpha)+'</td><td>+∞</td></tr></thead>'+
        '<tbody><tr><th rowspan="2">f</th><td class="bigsel" rowspan="2">'+sensL2+'</td><td style="text-align:center">'+top+'</td><td class="bigsel" rowspan="2">'+sensR2+'</td></tr><tr class="thin"><td style="text-align:center">'+bot+'</td></tr></tbody>'+
      '</table></div>';

    // ===== rendu final =====
    const html = [
      '<div class="steps">',
        '<div class="step"><b>1)</b></div>',
        table3(factStr, stepsQ1),

        '<div class="step"><b>2)</b></div>',
        table3(canonExpr, stepsQ2),

        '<div class="step"><b>3a)</b></div>',
        '<div class="sol" style="padding:.4rem;margin:.25rem 0">',
          lineR, line0, lineA,
        '</div>',

        sol3b,
        sol3c,
        sol3d,

'<div class="step"><b>3e)</b> Tableau attendu :</div>',
'<p>On utilise la forme canonique : ' + canonHTML(st.a, st.alpha, st.beta)  + '.</p>',
tableVar,

      '</div>'
    ].join('');

    $('#res', host).innerHTML = html;
    if (typeof scanFractions === 'function') scanFractions($('#res',host));
  },

  reset(host){ $('#res',host).textContent=''; }
};


/* ===== Registry & Mount (ordre demandé) ===== */
const REG=[exIdentify, exTwoWays, exVariations, exAdapt];
window.REGISTRY = window.REGISTRY && Array.isArray(window.REGISTRY) ? window.REGISTRY : REG;


function mount(){
  const sel=$("#exo-select"); sel.innerHTML=REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');
  function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
  function newOne(){ scoreOK=0;scoreTot=0;updateScore(); const ex=get(); const st=ex.gen(); ex.render($("#host"),st); $("#host").dataset.state=JSON.stringify(st); scanFractions($("#host")); }
  function check(){ const ex=get(); ex.correct($("#host"), JSON.parse($("#host").dataset.state||'{}')); scanFractions($("#host")); }
  function sol(){ const ex=get(); ex.solution($("#host"), JSON.parse($("#host").dataset.state||'{}')); scanFractions($("#host")); }
  function reset(){ const ex=get(); ex.reset($("#host")); scoreOK=0;scoreTot=0;updateScore(); }

  sel.onchange=newOne; $("#btn-new").onclick=newOne; $("#btn-check").onclick=check; $("#btn-solution").onclick=sol; $("#btn-reset").onclick=reset;
  document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id; newOne();
}
document.addEventListener('DOMContentLoaded', mount);
})();
</script>
</body>
</html>
