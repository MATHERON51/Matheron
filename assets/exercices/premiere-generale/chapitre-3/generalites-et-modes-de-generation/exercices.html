<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Première — Suites numériques (LATEX)</title>

<!-- mêmes feuilles que ton modèle -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles à l’écran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de réponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
</style>

<!-- MathJax comme dans ton modèle -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- mêmes libs partagées -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Première — <strong>Suites numériques</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contrôle identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-sol" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- Hôte d’exercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & réponses acceptées" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & réponses acceptées :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> acceptées
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenthèses/accolades, soulignés, <code>*</code> ou <code>×</code> sont normalisés).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = '−';

/* ===== Utilitaires génériques (mêmes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tolère u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, ×, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/×|\*/g,'');
  s = s.replace(/[−–—]/g,'-');

  // normaliser les écritures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'✓':'✗'; }
// ✓ / ✗ / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='✓'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='✗'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] → an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "−" collés
  let s = parts.join(' + ').replace(/\+\s*−/g, UMINUS).replace(/−\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/− en LaTeX
  s = s.replace(/\+/g,'+').replace(/−/g, UMINUS);
  return s || '0';
}

/* =====  EXERCICES  ===== */
function makeExos(){
  const L=[];

  /* === Ex. 1 — u_n = f(n) (premiers termes & u_5) === */
  /* === Ex. 1 — u_n = f(n) (sélecteur + mélange + u_k, k∈[8..20]) === */
L.push({
  id:'ex1_f_de_n',
  title:"Ex. 1 — Suite définie par une fonction (choix de f)",

 /* ---------- Utils ---------- */
  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){ if(d===0) return {n:NaN,d:0}; if(d<0){n=-n;d=-d} const g=this._gcd(n,d); return {n:n/g,d:d/g}; },
  _isSquare(N){ if(N<0) return false; const r=Math.floor(Math.sqrt(N)); return r*r===N; },
_fmtIntOrFrac(n,d){
  // Cas dégénérés
  if (d === 0) return '\\text{indéfini}';

  // Toujours simplifier et mettre le dénominateur > 0
  const s = this._simp(n,d); // -> {n,d} avec d>0

  // -0 -> 0
  if (s.n === 0) return '0';

  // Si c'est un entier après simplification
  if (s.d === 1) return String(s.n);

  // Signe *devant* la fraction, numérateur toujours positif
  const sign = (s.n < 0) ? '−' : '';
  return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
},
_normStep(s){
  return s
    // espaces exotiques → espace
    .replace(/[\u00A0\u2009\u200A\u202F]/g, ' ')
    // unifier les différents "moins" en hyphen ASCII pour comparer
    .replace(/[−–—]/g, '-')
    // nettoyage général
    .replace(/\s+/g, ' ')
    .replace(/\s*×\s*/g, ' × ')
    .replace(/\+\s*-/g, '-')     // "+ -" → "-"
    .replace(/-\s*\+/g, '-')     // "- +" → "-"
    .replace(/\s*=\s*/g, ' = ')
    .replace(/([\-+])\s+(\d)/g, '$1$2') // "- 6" → "-6"
    .trim();
}
,

_dedup(lines){
  const out = [];
  let prevN = '';
  for(const L of lines){
    if(!L) continue;
    const curN = this._normStep(L);
    if(curN !== prevN){
      out.push(L);              // on garde la version originale pour l’affichage
      prevN = curN;
    }
  }
  return out;
},



/* ---------- Helpers affichage (jamais 1 ou −1 devant une variable) ---------- */
// Premier terme d’une somme (pas de " + " en tête)
_termFirst(k, body, isVarLike, X){ // k: coeff, body: "n", "n^2", "3^3", ..., isVarLike: true si variable/puissance, X = s.times ("\\times")
  if(k===0) return '';
  const A = Math.abs(k);
  const sgn = (k<0 ? '−' : '');
  if(A===1) return sgn + body;                 // ±1 → signe seul, pas de "×"
  return sgn + A + ' ' + X + ' ' + body;       // autre coeff → "a × body"
},
// Terme suivant (ajoute " + " ou " − ")
_termNext(k, body, isVarLike, X){
  if(k===0) return '';
  const A = Math.abs(k);
  const lead = (k<0 ? ' − ' : ' + ');
  if(A===1) return lead + body;                // ±1 → pas de "×"
  return lead + A + ' ' + X + ' ' + body;
},
// a·n + b avec ±1 masqué (pour jolis (an+b)/(cn+d))
_linExpr(a,b,X){
  let s = '';
  if(a){
    s += this._termFirst(a,'n',true,X);
  }
  if(b){
    s += (b<0 ? ' − ' + Math.abs(b) : (s ? ' + ' + b : String(b)));
  }
  return s || '0';
},
// Version LaTeX pour fLatex de l’homographique
_linLatex(a,b){
  let s='';
  if(a){
    if(a===1) s+='n';
    else if(a===-1) s+='−n';
    else s+=(a<0?'−':'')+'{'+Math.abs(a)+'}n';
  }
  if(b){
    if(!s) s += String(b);
    else s += (b<0? '−'+Math.abs(b) : '+'+b);
  }
  return s || '0';
},
// (dans tes helpers)
_powBody(n,p){              // corps : n, n^2, n^3
  return p===3 ? `${n}^3` : p===2 ? `${n}^2` : `${n}`;
},

// 1er terme après substitution : on MASQUE ±1 mais on NE SUPPRIME PAS n=0
_subFirst(k,n,p,X){
  if (k===0) return '';
  const A   = Math.abs(k);
  const sgn = (k<0 ? '−' : '');
  const body = this._powBody(n,p);            // ex: "0^2"
  if (A===1) return sgn + body;               // ±1 → pas de "×"
  return sgn + A + ' ' + X + ' ' + body;      // autre coeff → "a × body"
},



// Terme suivant (ajoute " + " ou " − ") — on garde k×0 quand n=0 (ex: −3 × 0)
// Terme suivant (ajoute " + " ou " − ") — conserve l'exposant si n=0
_subNext(k, n, p, X){
  if (k === 0) return '';
  const lead = (k < 0 ? ' − ' : ' + ');
  const A = Math.abs(k);

  if (n === 0){
    const body0 = this._powBody(0, p);     // "0", "0^2", "0^3"
    // pas de "1 × …" ; sinon on garde le produit k × 0^p
    return A === 1 ? (lead + body0) : (lead + A + ' ' + X + ' ' + body0);
  }

  // cas général
  const body = this._powBody(n, p);
  return A === 1 ? (lead + body) : (lead + A + ' ' + X + ' ' + body);
},



// Ajout de la constante en fin
_constNext(c){
  if(!c) return '';
  return (c<0 ? ' − ' + Math.abs(c) : ' + ' + c);
},

  gen(){
    const host = document.querySelector('#host');
    const rawKind = host?.dataset?.e1kind || 'mix';   // 'mix' par défaut
    const KINDS = ['lineaire','affine','carre','cube','poly2','poly3','inverse','homographique','alternance','racine'];
    const kind = (rawKind==='mix') ? KINDS[Math.floor(Math.random()*KINDS.length)] : rawKind;
    const kIndex = rint(8,20);

    // Petits helpers d’écriture
    const plus = (b)=> b? (b<0?` - ${Math.abs(b)}`:` + ${b}`) : '';
    const t = (x)=> String(x).replace(/-/g,'−'); // joli moins visuel
    const times = '\\times';

    let fLatex='', fEval=(n)=>0, params={}, remark='';

    if(kind==='lineaire'){                       // m n, m≠0
      let m=rint(-6,6); if(m===0) m=2;
fLatex = `${m<0?'−':''}${Math.abs(m)===1?'':'{'+Math.abs(m)+'}'}n`;                 // lineaire
      fEval = n => m*n;
      params={m};
    }
    else if(kind==='affine'){                    // m n + p, m≠0, p≠0
      let m=rint(-6,6); if(m===0) m=2;
      let p=rint(-9,9); if(p===0) p=3;
fLatex = `${m<0?'−':''}${Math.abs(m)===1?'':'{'+Math.abs(m)+'}'}n${plus(p)}`;       // affine
      fEval = n => m*n + p;
      params={m,p};
    }
    else if(kind==='carre'){ fLatex=`n^2`; fEval=n=>n*n; params={}; }
    else if(kind==='cube'){  fLatex=`n^3`; fEval=n=>n*n*n; params={}; }

    else if(kind==='poly2'){                     // a n^2 + b n + c, a≠0
      let a=rint(-5,5); if(a===0) a=2;
      let b=rint(-4,4), c=rint(-6,6);
      const m2 = (A,P)=> (A===0?'':`${A<0?'−':''}${Math.abs(A)===1?'':'{'+Math.abs(A)+'}'}n${P===2?'^2':''}`);
      let parts = [m2(a,2), m2(b,1), (c? t(c):'')].filter(Boolean);
      fLatex = parts.join(' + ').replace(/\+\s*−/g,'−').replace(/−\s*\+/g,'−').replace(/^\+\s*/,'');
      fEval = n => a*n*n + b*n + c;
      params={a,b,c};
    }
   // dans gen(), bloc poly3 → fLatex
else if(kind==='poly3'){                     // a n^3 + b n^2 + c n + d
  let a=rint(-3,3); if(a===0) a=2;
  let b=rint(-3,3), c=rint(-4,4), d=rint(-6,6);

  // NE PAS écrire ^1
  const m3 = (A,P)=> (
    A===0 ? '' :
    `${A<0?'−':''}${Math.abs(A)===1?'':'{'+Math.abs(A)+'}'}n${P>1 ? '^'+P : ''}`
  );

  let parts = [m3(a,3), m3(b,2), m3(c,1), (d? String(d).replace(/-/g,'−') :'')].filter(Boolean);
  fLatex = parts.join(' + ')
                .replace(/\+\s*−/g,'−')
                .replace(/−\s*\+/g,'−')
                .replace(/^\+\s*/,'');
  fEval = n => a*n*n*n + b*n*n + c*n + d;
  params={a,b,c,d};
}

    else if(kind==='inverse'){                   // 1/n
      fLatex = `\\dfrac{1}{n}`;
      fEval = n => 1/n;
      remark='(n≥1)';
      params={};
    
    } else if(kind==='homographique'){ // (an+b)/(cn+d) ; éviter zéros
  let a=rint(-3,3), b=rint(-6,6), c=choice([-2,-1,1,2]), d=rint(-6,6);
  const bad = new Set([0,1,2,kIndex]);
  let tries=0;
  while(tries++<60 && Array.from(bad).some(n => c*n + d === 0)){ d=rint(-6,6); }
  const Nlatex = this._linLatex(a,b);
  const Dlatex = this._linLatex(c,d);
  fLatex = `\\dfrac{${Nlatex}}{${Dlatex}}`;
  fEval = n => (a*n + b)/(c*n + d);
  remark='(simplifier la fraction)';
  params={a,b,c,d};
}
    else if(kind==='alternance'){                // k(-1)^n + b
      let k=choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]), b=rint(-6,6);
fLatex = `${k<0?'−':''}${Math.abs(k)===1?'':'{'+Math.abs(k)+'}'}(-1)^n${plus(b)}`;  // alternance
      fEval = n => k*Math.pow(-1,n) + b;
      params={k,b};
    }
    else {                                       // racine : √(n + d)
      let d=rint(0,10);
      fLatex = `\\sqrt{n${plus(d)}}`;
      fEval = n => Math.sqrt(n + d);
      remark='(laisser sous la racine si non carré parfait)';
      params={d};
    }

    // Indices à calculer en (a)
    const idxs = (kind==='inverse') ? [1,2,3] : [0,1,2];
    const values = idxs.map(n=>fEval(n));
    const uk = fEval(kIndex);

    return { rawKind, kind, fLatex, fEval, params, remark, idxs, values, kIndex, uk, times };
  },

  render(host,s){
    host.dataset.state='';
    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Choisir \\(f\\) :
            <select id="e1-kind">
              <option value="mix">mélange (aléatoire)</option>
              <option value="lineaire">fonction linéaire </option>
              <option value="affine">fonction affine</option>
              <option value="carre">carré</option>
              <option value="cube">cube</option>
              <option value="poly2">Polynôme du second degré </option>
              <option value="poly3">Polynôme du troisième degré </option>
              <option value="inverse">inverse 1/n</option>
              <option value="homographique">homographique</option>
              <option value="alternance">k(-1)ⁿ+b</option>
              <option value="racine">racine carrée </option>
            </select>
          </p>

          <p>Soit \\((u_n)\\) la suite définie, pour tout entier naturel \\(n\\), par :
             \\[ u_n = ${s.fLatex} \\] ${s.remark?`<span class="hint">${s.remark}</span>`:''}
             ${s.rawKind==='mix' ? `<br><span class="hint">Mode mélange : fonction tirée = <b>${s.kind}</b>.</span>` : ''}
          </p>

          <p>a) Calculer les trois premiers termes.<br>
             \\(u_{${s.idxs[0]}}=\\) ${mkInput('e1',100)} <span id="t1" class="tick"></span> &nbsp;
             \\(u_{${s.idxs[1]}}=\\) ${mkInput('e2',100)} <span id="t2" class="tick"></span> &nbsp;
             \\(u_{${s.idxs[2]}}=\\) ${mkInput('e3',100)} <span id="t3" class="tick"></span></p>

          <p>b) Calculer \\(u_{${s.kIndex}}\\). &nbsp; \\(u_{${s.kIndex}}=\\) ${mkInput('e4',120)} <span id="t4" class="tick"></span></p>
        <div class="equ-offscreen" style="display:none">
 <p>Soit \\((u_n)\\) la suite définie, pour tout entier naturel \\(n\\), par :
             \\[ u_n = ${s.fLatex} \\] 
          </p>
          <p>a) Calculer les trois premiers termes.<br>
          <p>b) Calculer \\(u_{${s.kIndex}}\\). </p>
        </div>
		
		</div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;
    retypeMath(host);
    host.__state = s;

    const sel = host.querySelector('#e1-kind');
    if(sel){
      sel.value = s.rawKind;
      sel.addEventListener('change', ()=>{
        const h = document.querySelector('#host');
        if(h) h.dataset.e1kind = sel.value;
        renderActiveSafe('e1-kind.change');
      });
    }
  },

  check(host){
  const s = host.__state;

  const a = val('e1').trim();
  const b = val('e2').trim();
  const c = val('e3').trim();
  const d = val('e4').trim();

  const ok1 = a==='' ? null : near(parseNumber(a), s.values[0]);
  const ok2 = b==='' ? null : near(parseNumber(b), s.values[1]);
  const ok3 = c==='' ? null : near(parseNumber(c), s.values[2]);
  const ok4 = d==='' ? null : near(parseNumber(d), s.uk);

  tickTri($('#t1',host), ok1);
  tickTri($('#t2',host), ok2);
  tickTri($('#t3',host), ok3);
  tickTri($('#t4',host), ok4);

  const hasBlank = (a==='' || b==='' || c==='' || d==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3) && (!!ok4);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    return ok;
  }
  return false; // on ne score pas tant que tout n’est pas rempli
},


  /* ---------- Fabrique les étapes d'un calcul u_n selon le type ---------- */
  _stepsFor(s, n){
    const X = s.times; const P = s.params;
    const lines = [];
    const eq = (rhs)=>`u_{${n}} = ${rhs}`;
const push = (rhs)=>{
  const L = eq(rhs);
  const prev = lines.length ? lines[lines.length-1] : '';
  if(this._normStep(L) !== this._normStep(prev)) lines.push(L);
};

if(s.kind==='lineaire'){
  const m = P.m;
  const L1 = (n===0 && Math.abs(m)===1) ? '0' : this._subFirst(m,n,1,X);
  lines.push(eq(L1));
  lines.push(eq(`${m*n}`));
}


    else if(s.kind==='affine'){
  const m = P.m, p = P.p;

  // L1 — substitution propre (masque ±1, garde k×0 quand n=0)
  let l1 = this._subFirst(m, n, 1, X) + this._constNext(p);
  l1 = l1.replace(/^\s*\+\s*/,'').replace(/\+\s*−/g,'−').replace(/−\s*\+/g,'−');
  lines.push(eq(l1));

  // L2 — produits numériques (sans "+ 0")
  const mn = m*n;
  let l2 = '';
  if (mn !== 0) l2 = `${mn}`;
  if (p){
    if (!l2) l2 = `${p}`;
    else l2 += (p < 0 ? ` − ${Math.abs(p)}` : ` + ${p}`);
  }
  lines.push(eq(l2 || '0'));

  // L3 — résultat final
  lines.push(eq(`${mn + (p||0)}`));
}

    else if(s.kind==='carre'){
      lines.push(eq(`${n}^2`));
      lines.push(eq(`${n*n}`));
    }
    else if(s.kind==='cube'){
      lines.push(eq(`${n}^3`));
      lines.push(eq(`${n*n*n}`));
    }
    else if(s.kind==='poly2'){
  const a=P.a,b=P.b,c=P.c;

  // L1 — première ligne : pas de 1/−1 devant, et si n=0 alors " + 0"
  let l1 = this._subFirst(a,n,2,X) + this._subNext(b,n,1,X) + this._constNext(c);
  l1 = l1.replace(/^\s*\+\s*/,'').replace(/\+\s*−/g,'−').replace(/−\s*\+/g,'−');
  lines.push(eq(l1));



// terme en n (b*n) — on garde juste le produit numérique, sans "×"
const bn = b*n;



  // L3 — a·n² évalué + éventuels autres termes (sans +0)
  const a2 = a*(n*n);
  const l3 = [`${a2}`];
  if (bn) l3.push(bn<0 ? `− ${Math.abs(bn)}` : `+ ${bn}`);
  if (c)  l3.push(c<0  ? `− ${Math.abs(c)}` : `+ ${c}`);
  lines.push(eq(l3.join(' ')));

  // L4 — résultat final
  lines.push(eq(`${a2 + bn + (c||0)}`));
}


   else if(s.kind==='poly3'){
  const a=P.a, b=P.b, c=P.c, d=P.d;

  // L1
  let l1 = this._subFirst(a,n,3,X) + this._subNext(b,n,2,X) + this._subNext(c,n,1,X) + this._constNext(d);
  l1 = l1.replace(/^\s*\+\s*/,'').replace(/\+\s*−/g,'−').replace(/−\s*\+/g,'−');
  push(l1);

  // L2
  const n3=n*n*n, n2=n*n;
  let head2='';
  if(n3===0) head2='0';
  else if(a===1) head2=`${n3}`;
  else if(a===-1) head2=`− ${n3}`;
  else head2=`${a} ${X} ${n3}`;

  const l2=[head2];
  const b2=b*n2; if(b2) l2.push(b2<0?`− ${Math.abs(b2)}`:`+ ${b2}`);
  const c1=c*n;  if(c1) l2.push(c1<0?`− ${Math.abs(c1)}`:`+ ${c1}`);
  if(d)          l2.push(d<0?`− ${Math.abs(d)}`:`+ ${d}`);
  push(l2.join(' ').replace(/^\s*\+\s*/,'') || '0');

  // L3 (numérique intermédiaire)
  const a3=a*n3;
  const l3=[];
  if(a3) l3.push(`${a3}`);
  if(b2) l3.push(b2<0?`− ${Math.abs(b2)}`:`+ ${b2}`);
  if(c1) l3.push(c1<0?`− ${Math.abs(c1)}`:`+ ${c1}`);
  if(d)  l3.push(d<0?`− ${Math.abs(d)}`:`+ ${d}`);
  const L3txt = (l3.join(' ').replace(/^\s*\+\s*/,'')) || '0';

  // L4 (résultat)
  const val = (a3||0) + (b2||0) + (c1||0) + (d||0);
  const L4txt = `${val}`;

  // On n’ajoute L3 que si différente de L4 (après normalisation)
  if(this._normStep(`u_{${n}} = ${L3txt}`) !== this._normStep(`u_{${n}} = ${L4txt}`)){
    push(L3txt);
  }
  push(L4txt);
}


    else if(s.kind==='inverse'){
      if(n===0){ lines.push(eq(`\\text{indéfini}`)); }
      else{
        const num=1, den=n; const simp=this._simp(num,den);
        lines.push(eq(`\\dfrac{1}{${n}}`));
        lines.push(eq(this._fmtIntOrFrac(simp.n,simp.d)));
      }
    }
    else if(s.kind==='homographique'){
  const a=P.a, b=P.b, c=P.c, d=P.d;
  const norm = s => s.replace(/^\s*\+\s*/,'').replace(/\+\s*−/g,'−').replace(/−\s*\+/g,'−');

  // L1 — substitution propre dans chaque membre (an+b)/(cn+d)
  const top1 = norm(this._subFirst(a, n, 1, X) + this._constNext(b)) || '0';
  const bot1 = norm(this._subFirst(c, n, 1, X) + this._constNext(d)) || '0';
  lines.push(eq(`\\dfrac{${top1}}{${bot1}}`));

  // L2 — fractions numériques (an+b)/(cn+d)
  const N = a*n + b;
  const D = c*n + d;
  if (D === 0){
    lines.push(eq(`\\text{indéfini}`));
    return lines;
  }
  lines.push(eq(`\\dfrac{${N}}{${D}}`));

  // L3 — écriture "entier ou fraction" (non réduite)
  lines.push(eq(this._fmtIntOrFrac(N, D)));

  // L4 — simplification éventuelle
  const simp = this._simp(N, D);
  if (!(simp.n===N && simp.d===D)) {
    lines.push(eq(this._fmtIntOrFrac(simp.n, simp.d)));
  }
}

    else if(s.kind==='alternance'){
  const sgnVal  = Math.pow(-1,n);          // 1 ou -1
  const sgnShow = (sgnVal === 1) ? '1' : '(−1)';  // () seulement pour -1

  // L1 — on garde les parenthèses autour de -1 dans la puissance
  lines.push(eq(`${P.k} ${X} (-1)^{${n}} ${P.b?(P.b<0?`- ${Math.abs(P.b)}`:`+ ${P.b}`):''}`));

  // L2 — pas de parenthèses autour de 1
  lines.push(eq(`${P.k} ${X} ${sgnShow} ${P.b?(P.b<0?`- ${Math.abs(P.b)}`:`+ ${P.b}`):''}`));

  // L3 — produit numérique
  lines.push(eq(`${(sgnVal*P.k)} ${P.b?(P.b<0?`- ${Math.abs(P.b)}`:`+ ${P.b}`):''}`));

  // L4 — résultat final
  lines.push(eq(`${sgnVal*P.k + (P.b||0)}`));
}

    else { // racine
      const inside = n + (P.d||0);
      if(this._isSquare(inside)){
        const r = Math.round(Math.sqrt(inside));
        lines.push(eq(`\\sqrt{${n}${P.d?(P.d<0?`- ${Math.abs(P.d)}`:`+ ${P.d}`):''}}`));
        lines.push(eq(`\\sqrt{${inside}}`));
        lines.push(eq(`${r}`));
      }else{
        lines.push(eq(`\\sqrt{${n}${P.d?(P.d<0?`- ${Math.abs(P.d)}`:`+ ${P.d}`):''}}`));
        lines.push(eq(`\\sqrt{${inside}}`));
      }
    }
    return this._dedup(lines);
  },

  solution(host){
    const s=host.__state;
    const W=$('#steps',host);

    // (a) — 3 colonnes
    const colsHtml = s.idxs.map(n=>{
      const lines = this._stepsFor(s,n).map(txt=>`<div class="step">\\(${txt}\\)</div>`).join('');
      return `<div class="steps">${lines}</div>`;
    }).join('');
    // (b) — u_k
    const linesB = this._stepsFor(s, s.kIndex).map(txt=>`<div class="step">\\(${txt}\\)</div>`).join('');

    W.innerHTML = `
      <div class="sol-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">${colsHtml}</div>
      <div class="steps" style="margin-top:8px">${linesB}</div>
    `;
    retypeMath(W);

    /* Auto-remplissage des champs (sans décimaux) */
    function setFracOrInt(id, valNum, kind, n){
      if(kind==='inverse'){
        if(n===0) return;
        const obj={n:1,d:n};
        const g = (function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a})(obj.n,obj.d);
        const N=obj.n/g, D=obj.d/g;
        return;
      }
      if(kind==='homographique'){
        const P=s.params, N=P.a*n+P.b, D=P.c*n+P.d;
        const g = (function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a})(N,D);
        const n2=N/g, d2=D/g;
        return;
      }
      if(kind==='racine'){ return; } // pas de décimal
    }
    setFracOrInt('e1', s.values[0], s.kind, s.idxs[0]);
    setFracOrInt('e2', s.values[1], s.kind, s.idxs[1]);
    setFracOrInt('e3', s.values[2], s.kind, s.idxs[2]);
    setFracOrInt('e4', s.uk,        s.kind, s.kIndex);
  }
});


 L.push({
  id:'ex2_recurrence_1',
  title:"Ex. 2 — Suite récurrente : u_{n+1}=f(u_n)",

  /* === Helpers locaux === */
  _gcd:function(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ var t=a%b; a=b; b=t; } return a||1; },
  _simp:function(n,d){ if(d===0) return {n:NaN,d:0}; if(d<0){n=-n;d=-d} var g=this._gcd(n,d); return {n:n/g,d:d/g}; },
  _fmtIntOrFrac:function(n,d){ if(d===1) return String(n); var s=n<0?'−':''; return s+"\\dfrac{"+Math.abs(n)+"}{"+d+"}"; },
  _dedup:function(lines){
    function norm(s){ return String(s).replace(/[\u00A0\u2009\u200A\u202F]/g,' ')
      .replace(/[−–—]/g,'-').replace(/\s+/g,' ').replace(/\+\s*-/g,'-')
      .replace(/-\s*\+/g,'-').replace(/\s*=\s*/g,' = ').trim(); }
    var out=[], prev=''; for(var i=0;i<lines.length;i++){ var L=lines[i]; if(norm(L)!==norm(prev)){ out.push(L); prev=L; } }
    return out;
  },
  _plus:function(b){ return b ? (b<0? " − "+Math.abs(b) : " + "+b) : ""; },
  _pow:function(body,p){ return p===3?body+"^{3}" : p===2?body+"^{2}" : body; },
  _varMonome:function(coeff, lab, pow){
    if(coeff===0) return '';
    var A=Math.abs(coeff), sgn=coeff<0?'−':'', v=this._pow(lab,pow);
    return (A===1)? (sgn+v) : (sgn+"{"+A+"}"+v);
  },
  _num:function(x){ return String(x).replace(/-/g,'−'); },          // nombre avec joli “−”
  _par:function(x){ var s=this._num(x); return (x<0? "("+s+")" : s); }, // parenthèses si négatif
  _timesNum:function(A,x){                                         // A × x, parenthèses si x<0
    return A+" \\times "+this._par(x);
  },

  /* === Fabrique f (SANS alternance) — showNum corrigé === */
  _makeF:function(kind){
    var plus=this._plus.bind(this), self=this;

    if(kind==='lineaire'){
  var m=rint(-6,6); if(m===0) m=2;
  return {
    kind:kind, params:{m:m}, remark:'',
    showVar:function(lab){ return self._varMonome(m,lab,1) || '0'; },
    showNum:function(x){
      if(m===1)  return self._num(x);                          // pas "(x)"
      if(m===-1) return "−" + (x<0 ? "("+self._num(x)+")" : self._num(x));
      return self._timesNum(m,x);                               // m × (x) (parenthèses si x<0)
    },
    f:function(u){ return m*u; }
  };
}



    if(kind==='affine'){
  var m2=rint(-6,6); if(m2===0) m2=2;
  var p=rint(-9,9);  if(p===0)  p=3;
  return {
    kind:kind, params:{m:m2,p:p}, remark:'',
    showVar:function(lab){
      var s = self._varMonome(m2,lab,1) + (p? (p<0?' − '+Math.abs(p):' + '+p) : '');
      return s.replace(/^\s*\+\s*/,'') || '0';
    },
    // ⬇️ pas de parenthèses si m=1 (terme seul) ; parenthèses uniquement en produit ou pour "−(x)"
    showNum:function(x){
      var head;
      if(m2===1){
        head = self._num(x);                           // ex: u_{n+1}=u_n+p  →  -9 - 9 (sans ())
      }else if(m2===-1){
        head = "−" + (x<0 ? "("+self._num(x)+")" : self._num(x));  // −(x) si x<0
      }else{
        head = self._timesNum(m2,x);                   // m × (x) → parenthèses si x<0 (déjà géré)
      }
      var s = head + (p ? (p<0 ? ' − '+Math.abs(p) : ' + '+p) : '');
      return s.replace(/^\s*\+\s*/,'') || '0';
    },
    f:function(u){ return m2*u + p; }
  };
}


    if(kind==='carre'){
      return {
        kind:kind, params:{}, remark:'',
        showVar:function(l){return l+"^{2}";},
        showNum:function(x){ return self._par(x)+"^{2}"; },  // (x)^2 si x<0
        f:function(u){return u*u;}
      };
    }

    if(kind==='cube'){
      return {
        kind:kind, params:{}, remark:'',
        showVar:function(l){return l+"^{3}";},
        showNum:function(x){ return self._par(x)+"^{3}"; },  // (x)^3 si x<0
        f:function(u){return u*u*u;}
      };
    }

    if(kind==='poly2'){
      var a=rint(-5,5); if(a===0) a=2; var b=rint(-4,4), c=rint(-6,6);
      return {
        kind:kind, params:{a:a,b:b,c:c}, remark:'',
        showVar:function(lab){
          var s = self._varMonome(a,lab,2);
          if(b){
            if(Math.abs(b)===1) s += (b<0?' − ':' + ')+lab;
            else s += (b<0?' − '+Math.abs(b)+lab:' + '+Math.abs(b)+lab);
          }
          s += plus(c);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        showNum:function(x){
          var s='';
          // a·u^2
          if(a){
            var x2 = self._par(x)+"^{2}";
            if(a===1) s += x2;
            else if(a===-1) s += "−"+x2;
            else s += self._timesNum(a, self._par(x)+"^{2}".replace(/^\((.*)\)\^\{2\}$/,'$1^{2}')); // garde (x)^2
          }
          // b·u
          if(b){
            if(Math.abs(b)===1){
              // éviter "+ (−3)" -> " − 3"
              s += ( (b>0 && x<0) ? ' − '+Math.abs(x) :
                    (b<0 && x<0) ? ' + '+Math.abs(x) :
                    (b<0) ? ' − '+self._num(x) : ' + '+self._num(x) );
            }else{
              s += (b<0? ' − '+Math.abs(b)+' \\times '+self._par(x)
                     : ' + '+Math.abs(b)+' \\times '+self._par(x));
            }
          }
          // + c
          s += plus(c);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        f:function(u){ return a*u*u + b*u + c; }
      };
    }

    if(kind==='poly3'){
      var a3=rint(-3,3); if(a3===0) a3=2; var b3=rint(-3,3), c3=rint(-4,4), d3=rint(-6,6);
      return {
        kind:kind, params:{a:a3,b:b3,c:c3,d:d3}, remark:'',
        showVar:function(lab){
          var s = self._varMonome(a3,lab,3);
          if(b3){
            if(Math.abs(b3)===1) s += (b3<0?' − ':' + ')+lab+"^{2}";
            else s += (b3<0?' − '+Math.abs(b3)+lab+'^{2}':' + '+Math.abs(b3)+lab+'^{2}');
          }
          if(c3){
            if(Math.abs(c3)===1) s += (c3<0?' − ':' + ')+lab;
            else s += (c3<0?' − '+Math.abs(c3)+lab:' + '+Math.abs(c3)+lab);
          }
          s += plus(d3);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        showNum:function(x){
          var s='';
          // a3·u^3
          if(a3){
            var x3 = self._par(x)+"^{3}";
            if(a3===1) s += x3;
            else if(a3===-1) s += "−"+x3;
            else s += (a3+" \\times "+x3);
          }
          // b3·u^2
          if(b3){
            var x2 = self._par(x)+"^{2}";
            if(Math.abs(b3)===1) s += (b3<0?' − ':' + ')+x2;
            else s += (b3<0?' − '+Math.abs(b3)+' \\times '+x2:' + '+Math.abs(b3)+' \\times '+x2);
          }
          // c3·u
          if(c3){
            if(Math.abs(c3)===1){
              s += ( (c3>0 && x<0) ? ' − '+Math.abs(x) :
                     (c3<0 && x<0) ? ' + '+Math.abs(x) :
                     (c3<0) ? ' − '+self._num(x) : ' + '+self._num(x) );
            }else{
              s += (c3<0?' − '+Math.abs(c3)+' \\times '+self._par(x)
                   :' + '+Math.abs(c3)+' \\times '+self._par(x));
            }
          }
          // + d3
          s += plus(d3);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        f:function(u){ return a3*u*u*u + b3*u*u + c3*u + d3; }
      };
    }

    if(kind==='inverse'){
      return {
        kind:kind, params:{}, remark:'(défini si \\(u_n\\neq 0\\))',
        showVar:function(lab){ return "\\dfrac{1}{"+lab+"}"; },
        showNum:function(x){ return "\\dfrac{1}{"+(x<0? "("+self._num(x)+")" : self._num(x))+"}"; },
        f:function(u){ return 1/u; }
      };
    }

    if(kind==='homographique'){
      var a4=rint(-3,3), b4=rint(-6,6), c4=choice([-2,-1,1,2]), d4=rint(-6,6);
      function lin(A,B,lab){
        var s = self._varMonome(A,lab,1) + (B? (B<0?' − '+Math.abs(B):' + '+B) : '');
        s = s.replace(/^\s*\+\s*/,''); return s||'0';
      }
      return {
        kind:kind, params:{a:a4,b:b4,c:c4,d:d4}, remark:'(simplifier ; \\(c\\,u_n + d\\neq 0\\))',
        showVar:function(lab){ return "\\dfrac{"+lin(a4,b4,lab)+"}{"+lin(c4,d4,lab)+"}"; },
        showNum:function(x){
          var top = a4+" \\times "+self._par(x) + (b4? (b4<0?' − '+Math.abs(b4):' + '+b4):'');
          var bot = c4+" \\times "+self._par(x) + (d4? (d4<0?' − '+Math.abs(d4):' + '+d4):'');
          return "\\dfrac{"+top+"}{"+bot+"}";
        },
        f:function(u){ return (a4*u + b4)/(c4*u + d4); }
      };
    }

    // ... dans _makeF(kind) :
/* === racine : suite stationnaire pour forcer des carrés parfaits à chaque étape === */
var d, r;
if(kind==='racine'){
  r = rint(0,5);                // u0 dans [0..5]
  d = r*r - r;                  // ainsi u_{n+1} = sqrt(u_n + d) = sqrt(r^2) = r (constante)
  return {
    kind:'racine',
    params:{ d:d, r:r },
    remark:'(on a choisi d tel que \\(\\sqrt{u_n+d}=\\sqrt{r^2}\\) à chaque étape)',
    showVar:function(lab){
      return "\\sqrt{"+lab+(d? (d<0?' − '+Math.abs(d):' + '+d):'')+"}";
    },
    showNum:function(x){
      return "\\sqrt{"+self._num(x)+(d? (d<0?' − '+Math.abs(d):' + '+d):'')+"}";
    },
    f:function(u){ return Math.sqrt(u + d); }
  };
}

  },

  /* === Génération === */
  gen:function(){
  var host=document.querySelector('#host');
  var rawKind = (host && host.dataset && host.dataset.e2kind) ? host.dataset.e2kind : 'mix';
  var KINDS=['lineaire','affine','carre','cube','poly2','poly3','inverse','homographique','racine'];
  var kind = (rawKind==='mix') ? choice(KINDS) : rawKind;

  // (b) pas trop gros : pour carré/cube/poly2/poly3 -> k ∈ {5,6}, sinon k ∈ [8..12]
  var kIndex = (['carre','cube','poly2','poly3'].includes(kind)) ? choice([5,6]) : rint(8,12);

  var tries=0, ok=false, u0=0, desc=null, seq=null;

  while(tries++<250){
    desc=this._makeF(kind);

    // u0 dans [-5;5] ; pour racine on impose u0 = r (stationnaire)
    u0 = (desc.kind==='racine') ? desc.params.r : rint(-5,5);

    // Domaines
    if(desc.kind==='inverse' && u0===0){ if(rawKind!=='mix') u0=1; else { continue; } }
    if(desc.kind==='homographique' && (desc.params.c*u0 + desc.params.d === 0)){ if(rawKind!=='mix'){ desc=this._makeF('affine'); kind='affine'; } else { kind=choice(KINDS); continue; } }
    if(desc.kind==='racine' && (u0 + (desc.params?desc.params.d:0) < 0)){ continue; }

    // Construire toute la suite jusqu'à kIndex (on la gardera pour les étapes & l'auto-fill)
    seq=[u0]; ok=true;
    for(var i=1;i<=kIndex;i++){
      var prev=seq[i-1];
      if(desc.kind==='inverse' && prev===0){ ok=false; break; }
      if(desc.kind==='homographique' && (desc.params.c*prev + desc.params.d === 0)){ ok=false; break; }
      if(desc.kind==='racine' && (prev + (desc.params?desc.params.d:0) < 0)){ ok=false; break; }
      var next=desc.f(prev);
      if(!isFinite(next)){ ok=false; break; }
      seq.push(next);
    }
	
    if(ok) break;
    if(rawKind==='mix') kind=choice(KINDS);
  }

  if(!ok){
    desc=this._makeF('affine'); kind='affine'; u0=rint(-5,5); seq=[u0];
    for(var j=1;j<=kIndex;j++) seq.push(desc.f(seq[j-1]));
  }

  // ... après avoir construit: seq=[u0, u1, ..., ukIndex]
var that=this;
function _g(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){var t=a%b;a=b;b=t} return a||1; }
function simp(n,d){ if(d<0){n=-n;d=-d;} var g=_g(n,d); return {n:n/g,d:d/g}; }

var Qseq=[ {n:u0, d:1} ];
for(var i=1;i<=kIndex;i++){
  var p=Qseq[i-1], cur;
  if(desc.kind==='inverse'){
    cur=simp(p.d, p.n);
  }else if(desc.kind==='homographique'){
    var A=desc.params.a, B=desc.params.b, C=desc.params.c, D=desc.params.d;
    cur=simp(A*p.n + B*p.d, C*p.n + D*p.d);
  }else if(desc.kind==='racine' && 'b' in desc.params){
    var ssum = (p.n/p.d) + desc.params.b;           // ici c’est un entier
    cur=simp(Math.abs(ssum), 1);
  }else{
    cur=simp(seq[i], 1);
  }
  Qseq.push(cur);
}
return { rawKind:rawKind, kind:kind, kIndex:kIndex, u0:u0, u1:seq[1], u2:seq[2], uk:seq[kIndex], seq:seq, Qseq:Qseq, desc:desc };

},


  render:function(host,s){
  host.innerHTML =
    '<div class="row norepere">'+
      '<div class="statement">'+
        '<p>Choisir \\(f\\) : '+
          '<select id="e2-kind">'+
            '<option value="mix">mélange (aléatoire)</option>'+
            '<option value="lineaire">linéaire (m·u)</option>'+
            '<option value="affine">affine (m·u+p)</option>'+
            '<option value="carre">carré (u^2)</option>'+
            '<option value="cube">cube (u^3)</option>'+
            '<option value="poly2">polynôme degré 2</option>'+
            '<option value="poly3">polynôme degré 3</option>'+
            '<option value="inverse">inverse (1/u)</option>'+
            '<option value="homographique">homographique</option>'+
            '<option value="racine">racine carrée</option>'+
          '</select>'+
        '</p>'+
        '<p>On considère la suite \\((u_n)\\) définie par :<br>'+
           '\\[ u_0='+s.u0+',\\qquad u_{n+1} = '+s.desc.showVar('u_n')+' \\] '+
           (s.desc.remark?'<span class="hint">'+s.desc.remark+'</span>':'')+
           (s.rawKind==="mix"?'<br><span class="hint">Mode mélange : <b>'+s.kind+'</b>.</span>':'')+
        '</p>'+
        '<p>Calculer les trois premiers termes.<br>'+
           '\\(u_0=\\) '+mkInput('r1',90)+' <span id="t1" class="tick"></span> &nbsp; '+
           '\\(u_1=\\) '+mkInput('r2',90)+' <span id="t2" class="tick"></span> &nbsp; '+
           '\\(u_2=\\) '+mkInput('r3',90)+' <span id="t3" class="tick"></span></p>'+
        // '<p>b) Calculer \\(u_{'+s.kIndex+'}\\). &nbsp; \\(u_{'+s.kIndex+'}=\\) '+mkInput('r4',120)+' <span id="t4" class="tick"></span></p>'+
        
        // ---------- Bloc énoncé pour le PDF (hors UI) ----------
        '<div class="equ-offscreen" style="display:none">'+
          '<p>On considère la suite \\((u_n)\\) définie par :</p>'+
          '<p>\\[ u_0='+s.u0+',\\qquad u_{n+1} = '+s.desc.showVar('u_n')+' \\]</p>'+
          '<p>Calculer les trois premiers termes : \\(u_0,\\ u_1,\\ u_2\\).</p>'+
        '</div>'+

      '</div>'+
      '<div><div class="steps" id="steps"></div></div>'+
    '</div>';
  retypeMath(host);
  host.__state=s;

  var sel=host.querySelector('#e2-kind'); sel.value=s.rawKind;
  sel.addEventListener('change', function(){
    var h=document.querySelector('#host'); if(h) h.dataset.e2kind=sel.value;
    renderActiveSafe('e2-kind.change');
  });
},


check(host){
  const s = host.__state;

  const a = val('r1').trim(); // u0
  const b = val('r2').trim(); // u1
  const c = val('r3').trim(); // u2
  //const d = val('r4').trim(); // uk

  const ok1 = a==='' ? null : near(parseNumber(a), s.u0);
  const ok2 = b==='' ? null : near(parseNumber(b), s.u1);
  const ok3 = c==='' ? null : near(parseNumber(c), s.u2);
  //const ok4 = c==='' ? null : near(parseNumber(d), s.uk);

  tickTri($('#t1',host), ok1);
  tickTri($('#t2',host), ok2);
  tickTri($('#t3',host), ok3);
  tickTri($('#t4',host), ok4);

  const hasBlank = (a==='' || b==='' || c==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    return ok;
  }
  return false;
},

  /* === Étapes === */
  _stepsFor:function(s, i){
  var L=[], ul="u_{"+i+"}", ulm1="u_{"+(i-1)+"}";
  var prev = s.seq[i-1];
  var pq   = (s.Qseq && s.Qseq[i-1]) ? s.Qseq[i-1] : {n:prev,d:1};

  var self=this;
  function numTex(x){ return String(x).replace(/-/g,'−'); }
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){var t=a%b;a=b;b=t} return a||1; }

  // fraction réduite -> {tex,neg} ; si d=1 on renvoie l'entier (pas "…/1")
  function fracToTex(n,d){
    if(d<0){ n=-n; d=-d; }
    var g=gcd(n,d); n/=g; d/=g;
    if(d===1) return { tex:numTex(n), neg:(n<0) };
    var core="\\dfrac{"+Math.abs(n)+"}{"+d+"}";
    return { tex:(n<0?"−"+core:core), neg:(n<0) };
  }
  function parIfNeg(fr){ return fr.neg ? "\\left("+fr.tex+"\\right)" : fr.tex; }

  // coef * valeur, en masquant 1 et -1 ; parenthèse si valeur négative
  function timesCoeff(A, frObj){
    const inside = parIfNeg(frObj);
    if(A===1)  return inside;
    if(A===-1) return "−"+inside;
    return A+" \\times "+inside;
  }

  L.push(ul+" = "+s.desc.showVar(ulm1));

  if(s.kind==='inverse'){
    const FR = fracToTex(pq.n,pq.d);
    L.push(ul+" = \\dfrac{1}{"+parIfNeg(FR)+"}");
    const S = self._simp(pq.d,pq.n);
    L.push(ul+" = "+self._fmtIntOrFrac(S.n,S.d));
  }
  else if(s.kind==='homographique'){
    const P=s.desc.params, FR=fracToTex(pq.n,pq.d);
    const top = timesCoeff(P.a,FR) + (P.b? (P.b<0?' − '+Math.abs(P.b):' + '+P.b):'');
    const bot = timesCoeff(P.c,FR) + (P.d? (P.d<0?' − '+Math.abs(P.d):' + '+P.d):'');
    L.push(ul+" = \\dfrac{"+top+"}{"+bot+"}");

    const N=P.a*pq.n + P.b*pq.d, D=P.c*pq.n + P.d*pq.d;
    L.push(ul+" = "+self._fmtIntOrFrac(N,D));
    const S2=self._simp(N,D);
    if(S2.n!==N || S2.d!==D) L.push(ul+" = "+self._fmtIntOrFrac(S2.n,S2.d));
  }
  else if(s.kind==='racine' && s.desc.params && 'b' in s.desc.params){
    var b=s.desc.params.b, sign=(b<0?' − '+Math.abs(b):' + '+b);
    L.push(ul+" = \\sqrt{("+numTex(prev)+sign+")^{2}}");
    var sum = prev + b;
    L.push(ul+" = \\left|"+numTex(sum)+"\\right|");
    L.push(ul+" = "+Math.abs(sum));
  }
  else{
    // autres types : showNum gère déjà les cas ±1 correctement (voir patch B)
    L.push(ul+" = "+s.desc.showNum(prev));
    L.push(ul+" = "+numTex(s.seq[i]));
  }

  return this._dedup(L);
},


  solution:function(host){
  var s=host.__state, W=document.querySelector('#steps');

  // Fabrique les colonnes (u1, u2) et le bloc (b) via _stepsFor
  var col1 = '<div class="steps">'+this._stepsFor(s,1,s.u0).map(function(t){return '<div class="step">\\('+t+'\\)</div>';}).join('')+'</div>';
  var col2 = '<div class="steps">'+this._stepsFor(s,2,s.u1).map(function(t){return '<div class="step">\\('+t+'\\)</div>';}).join('')+'</div>';

  // (b) — on affiche TOUT le calcul de u_k (jamais un nombre décimal)
  var prevK = s.seq[s.kIndex-1];
  var bK = '<div class="steps">'+this._stepsFor(s, s.kIndex, prevK).map(function(t){return '<div class="step">\\('+t+'\\)</div>';}).join('')+'</div>';

  W.innerHTML =
    '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">'+
      '<div class="steps"><div class="step">\\(u_0='+s.u0+'\\)</div></div>'+
      col1 + col2 +
    '</div>'
	//+ bK;
  retypeMath(W);

  // -------- Auto-remplissage des champs en entier OU fraction "a/b" (jamais de décimal) --------
  var self=this;
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ var t=a%b; a=b; b=t; } return a||1; }
  function asFracStr(n,d){
    if(d===0) return '';        // indéfini : on ne remplit pas
    if(d<0){ n=-n; d=-d; }
    var g=gcd(n,d); n/=g; d/=g;
    return (d===1)? String(n) : ((n<0?'-':'')+Math.abs(n)+'/'+d);
  }
  function valueStringAt(index){   // index = 0..k
    // u0 est un entier affichable tel quel
    if(index===0) return String(s.u0);

    if(s.kind==='inverse'){
      var prev = s.seq[index-1];
      if(prev===0) return ''; // indéfini
      return asFracStr(1, prev);
    }
    if(s.kind==='homographique'){
      var prev = s.seq[index-1], P=s.desc.params;
      var N=P.a*prev + P.b, D=P.c*prev + P.d;
      if(D===0) return ''; // indéfini
      return asFracStr(N, D);
    }
    // racine & autres : c'est un entier dans notre génération
    return String(s.seq[index]);
  }


}

});

/* === Ex. 3 — u_{n+2} = a u_{n+1} + b u_n (u2..u4) === */
L.push({
  id:'ex3_recurrence_2',
  title:"Ex. 3 — Suite récurrente d’ordre 2",
  gen(){
    // Compteur pour forcer Fibonacci tous les 5 tirages
    window.__ex3_count = (window.__ex3_count||0) + 1;
    const forceFibo = (window.__ex3_count % 5 === 0);

    // tirage (a,b)
    let a = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let b = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
   

    // init u0,u1
    let u0 = rint(-5,5), u1 = rint(-5,5);

    // Cas Fibonacci
    let fibo = false;
    if(forceFibo){
      a = 1; b = 1; u0 = 0; u1 = 1; fibo = true;
    }

    // Écriture LaTeX de la relation (sans "1" ni "−1" affichés)
    const UMINUS = '−';
    const t = (x)=> String(x).replace(/-/g,UMINUS);
    const term = (coef, lab)=> {
      if(coef===0) return '';
      if(coef===1)  return lab;
      if(coef===-1) return UMINUS + lab;
      return (coef<0? UMINUS : '') + '{'+Math.abs(coef)+'}'+lab;
    };
    let left = term(a,'u_{n+1}');
    if(b){
      left += (b<0? ' '+UMINUS+' ' : ' + ')
            + (Math.abs(b)===1 ? 'u_n' : '{'+Math.abs(b)+'}u_n');
    }
    if(!left) left = '0';
    const fLatex = `u_{n+2} = ${left}`;

    // progression
    const step = (x,y)=> a*y + b*x; // (u_n, u_{n+1}) -> u_{n+2}
    const seq=[u0,u1];
    for(let k=0;k<3;k++) seq.push(step(seq[seq.length-2], seq[seq.length-1]));
    const [u2,u3,u4] = seq.slice(2);

    return {a,b,u0,u1,fLatex,u2,u3,u4,fibo};
  },

  render(host,s){
    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Soit la suite \\((u_n)\\) définie par
            \\[ u_0=${s.u0},\\quad u_1=${s.u1},\\qquad ${s.fLatex} \\]
            ${s.fibo?'<br><span class="hint">Il s’agit de la <b>suite de Fibonacci</b>.</span>':''}
          </p>
          <p>Déterminer \\(u_2, u_3, u_4\\).<br>
             \\(u_2=\\) ${mkInput('a',90)} <span id="t1" class="tick"></span> &nbsp;
             \\(u_3=\\) ${mkInput('b',90)} <span id="t2" class="tick"></span> &nbsp;
             \\(u_4=\\) ${mkInput('c',90)} <span id="t3" class="tick"></span>
          </p>
		          <div class="equ-offscreen" style="display:none">
 <p>Soit la suite \\((u_n)\\) définie par
            \\[ u_0=${s.u0},\\quad u_1=${s.u1},\\qquad ${s.fLatex} \\] 
          </p>
          <p>Déterminer \\(u_2, u_3, u_4\\)</p>
                </div>
        </div>
        <div><div class="steps" id="steps"></div></div>
      </div>`;
    retypeMath(host);
    host.__state = s;
  },

  check(host){
  const s = host.__state;

  const a = val('a').trim(); // u2
  const b = val('b').trim(); // u3
  const c = val('c').trim(); // u4

  const ok1 = a==='' ? null : near(parseNumber(a), s.u2);
  const ok2 = b==='' ? null : near(parseNumber(b), s.u3);
  const ok3 = c==='' ? null : near(parseNumber(c), s.u4);

  tickTri($('#t1',host), ok1);
  tickTri($('#t2',host), ok2);
  tickTri($('#t3',host), ok3);

  const hasBlank = (a==='' || b==='' || c==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    return ok;
  }
  return false;
},

  solution(host){
  const s=host.__state;
  const UMINUS = '−';
  const num = x => String(x).replace(/-/g,UMINUS);
  const par = x => x<0 ? `\\left(${num(x)}\\right)` : num(x);

  // --- helpers ---
  // Affiche A·x en tête (isHead=true) ou en second terme (isHead=false),
  // en MASQUANT 1 et −1, et en écrivant correctement les signes.
  function timesShow(A, x, isHead){
    if (A===0 || x===0) return '';                      // on laissera sumShow gérer le "0" global
    const n = num(x), absN = num(Math.abs(x));

    if (isHead){
      if (A===1)  return n;                             // ex: "1" ou "−3"
      if (A===-1) return (x<0 ? absN : '−'+n);          // −(−3) devient +3 en tête
      // A ≠ ±1
      return (A<0? '−' : '') + `${Math.abs(A)} \\times ${par(x)}`;
    } else {
      if (A===1)  return (x<0 ? ' − '+absN : ' + '+n);  // +x ou −|x|
      if (A===-1) return (x<0 ? ' + '+absN : ' − '+n);  // −x ; si x<0 → +|x|
      // A ≠ ±1
      return (A<0? ' − ' : ' + ') + `${Math.abs(A)} \\times ${par(x)}`;
    }
  }

  // Construit "A*x + B*y" proprement (pas de "0 + …", pas de "+ 0")
  function sumShow(A, xa, B, xb){
    const zeroA = (A===0 || xa===0);
    const zeroB = (B===0 || xb===0);
    if (zeroA && zeroB) return '0';
    if (zeroA)          return (timesShow(B, xb, true) || '0');
    let s  = timesShow(A, xa, true);
    if (!zeroB) s += timesShow(B, xb, false);
    return s.replace(/^\s*\+\s*/,'') || '0';
  }

  // "a u_{k}+ b u_{k-1}" (symbole, sans 1 ni −1)
  function symShow(a,b,lab1,lab0){
    const head = (a===0)? '' : (a===1? lab1 : (a===-1? UMINUS+lab1 : (a<0? UMINUS : '')+'{'+Math.abs(a)+'}'+lab1));
    let tail='';
    if(b){
      tail = (b<0? ' '+UMINUS+' ' : ' + ')
           + (Math.abs(b)===1 ? lab0 : '{'+Math.abs(b)+'}'+lab0);
    }
    const s = (head + tail).replace(/^\s*\+\s*/,'');
    return s || '0';
  }

  // dédoublonnage simple (même ligne affichée deux fois → une seule)
  function dedup(arr){
    const out=[]; let prev='';
    const norm = t => String(t).replace(/\s+/g,' ').replace(/[−–—]/g,'-').trim();
    for(const L of arr){
      if(!L) continue;
      const n = norm(L);
      if(n!==prev){ out.push(L); prev=n; }
    }
    return out;
  }

  // colonnes u2, u3, u4
  const cols = [
    {
      sym : `u_{2} = ${symShow(s.a, s.b, 'u_{1}','u_{0}')}`,
      sub : `u_{2} = ${sumShow(s.a, s.u1, s.b, s.u0)}`,
      val : `u_{2} = ${num(s.u2)}`
    },
    {
      sym : `u_{3} = ${symShow(s.a, s.b, 'u_{2}','u_{1}')}`,
      sub : `u_{3} = ${sumShow(s.a, s.u2, s.b, s.u1)}`,
      val : `u_{3} = ${num(s.u3)}`
    },
    {
      sym : `u_{4} = ${symShow(s.a, s.b, 'u_{3}','u_{2}')}`,
      sub : `u_{4} = ${sumShow(s.a, s.u3, s.b, s.u2)}`,
      val : `u_{4} = ${num(s.u4)}`
    },
  ];

  // tableau 3 colonnes avec lignes dédoublonnées
  const html = `
    <div class="sol-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
      ${cols.map(c => {
        const lines = dedup([c.sym, c.sub, c.val]);
        return `
          <div class="steps">
            ${lines.map(t=>`<div class="step">\\(${t}\\)</div>`).join('')}
          </div>`;
      }).join('')}
    </div>`;
  $('#steps',host).innerHTML = html;
  retypeMath(host);

  // auto-fill
}

});


 /* === Ex. 4 — Suite définie par une phrase (avec Remarque & solution en tableau) === */
L.push({
  id:'ex4_phrase',
  title:"Ex. 4 — Suite définie par une phrase",

  gen(){
  // 35% geo / 35% ari / 30% ag
  const r = Math.random();
  let kind = r < 0.35 ? 'geo' : (r < 0.70 ? 'ari' : 'ag');

  const u0 = rint(-6,6);

  // petit helper de rédaction
  const plusMoins = (k)=> k<0 ? `en enlevant ${Math.abs(k)}` : `en ajoutant ${k}`;

  if(kind==='geo'){
    let q = choice([-3,-2,-1,2,3,4]); // q ≠ 0
    const phrase   = `Soit \\((u_n)\\) la suite définie par son premier terme \\(u_0=${u0}\\), et telle qu’en multipliant un terme par \\(${q}\\), on obtienne le terme suivant.`;
const sgn  = (q < 0 ? '−' : '');
const coef = (Math.abs(q) === 1 ? '' : '{'+Math.abs(q)+'}');
const relation = `u_{n+1}=${sgn}${coef}\\,u_n`;    
const remark   = `On appelle \\((u_n)\\) une <b>suite géométrique</b> de raison \\(${q}\\) et de premier terme \\(u_0=${u0}\\).`;
    const next = (x)=> q*x;
    return {kind,u0,q,a:null,b:null, phrase, relation, remark, next};
  }

  if(kind==='ari'){
    let r_ = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);  // 0 exclu
    const phrase   = `Soit \\((u_n)\\) la suite définie par son premier terme \\(u_0=${u0}\\), et telle qu’${plusMoins(r_)} à un terme, on obtienne le terme suivant.`;
    const relation = `u_{n+1}=u_n${r_<0?` − ${Math.abs(r_)}`:` + ${r_}`}`;
    const remark   = `On appelle \\((u_n)\\) une <b>suite arithmétique</b> de raison \\(${r_}\\) et de premier terme \\(u_0=${u0}\\).`;
    const next = (x)=> x + r_;
    return {kind,u0,q:null,a:null,b:r_, phrase, relation, remark, next};
  }

  // arithmético-géométrique
let a = choice([-3,-2,-1,2,3]);
let b = rint(-5,5);
const phrase   = `Soit \\((u_n)\\) la suite définie par son premier terme \\(u_0=${u0}\\), et telle qu’en multipliant un terme par \\(${a}\\) puis ${plusMoins(b)} , on obtienne le terme suivant.`;

// NEW: show the sign for any negative a (not only a===-1)
const sgnA  = (a < 0 ? '−' : '');
const coefA = (Math.abs(a) === 1 ? '' : '{' + Math.abs(a) + '}');
const relation = `u_{n+1}=${sgnA}${coefA}\\,u_n${b ? (b < 0 ? ` − ${Math.abs(b)}` : ` + ${b}`) : ''}`;

const remark   = `On appelle \\((u_n)\\) une <b>suite arithmético-géométrique</b>.`;
const next = (x)=> a*x + b;
return {kind,u0,q:null,a,b, phrase, relation, remark, next};

},


  render(host,s){
    // u1,u2,u3 pour l’énoncé
    const u1 = s.next(s.u0);
    const u2 = s.next(u1);
    const u3 = s.next(u2);
    host.__state = Object.assign({}, s, {u1,u2,u3});

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>${s.phrase}</p>
          <p>a) Déterminer les termes \\(u_1, u_2\\) et \\(u_3\\).</p>
          <p>b) Donner une relation reliant \\(u_{n+1}\\) et \\(u_n\\).</p>
          <p class="hint" style="margin-top:.5rem"><strong>Remarque :</strong> ${s.remark}</p>

          <p style="margin-top:10px">
            \\(u_1=\\) ${mkInput('p1',90)} <span id="t1" class="tick"></span> &nbsp;
            \\(u_2=\\) ${mkInput('p2',90)} <span id="t2" class="tick"></span> &nbsp;
            \\(u_3=\\) ${mkInput('p3',90)} <span id="t3" class="tick"></span>
          </p>
          <p>
            Relation : ${mkInput('peq',260)} <span id="t4" class="tick"></span>
          </p>
		  <div class="equ-offscreen" style="display:none">
<p>${s.phrase}</p>
          <p>a) Déterminer les termes \\(u_1, u_2\\) et \\(u_3\\).</p>
          <p>b) Donner une relation reliant \\(u_{n+1}\\) et \\(u_n\\).</p>
                </div>
        </div>
        <div><div class="steps" id="steps"></div></div>
      </div>`;
    retypeMath(host);
  },

  check(host){
  const s = host.__state;

  // helper pour tick tri-état (true/false/null)
  function setTick(el, state){
    if(!el) return;
    el.classList.remove('ok','ko');
    if(state===true){ el.classList.add('ok'); el.textContent='✓'; }
    else if(state===false){ el.classList.add('ko'); el.textContent='✗'; }
    else { el.textContent=''; } // neutre si champ vide
  }

  // --- valeurs saisies
  const r1 = val('p1').trim(), r2 = val('p2').trim(), r3 = val('p3').trim(), req = val('peq').trim();

  // --- tests numériques (ne teste que si rempli)
  const ok1 = r1==='' ? null : near(parseNumber(r1), s.u1);
  const ok2 = r2==='' ? null : near(parseNumber(r2), s.u2);
  const ok3 = r3==='' ? null : near(parseNumber(r3), s.u3);

  // --- test relation (tolérant aux écritures demandées)
  const target = normRelation(s.relation);
  const user   = req==='' ? '' : normRelation(req);
  const ok4    = req==='' ? null : (user === target);

  // --- ticks
  setTick($('#t1',host), ok1);
  setTick($('#t2',host), ok2);
  setTick($('#t3',host), ok3);
  setTick($('#t4',host), ok4);

  // --- score : on ne touche PAS au score s'il reste des champs vides
  const hasBlank = (r1==='' || r2==='' || r3==='' || req==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3) && (!!ok4);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
  }
  return (!hasBlank) && (!!ok1) && (!!ok2) && (!!ok3) && (!!ok4);
},


  solution(host){
  const s = host.__state;
  const UMINUS='−';
  const num = x => String(x).replace(/-/g, UMINUS);
  const par = x => x<0 ? `\\left(${num(x)}\\right)` : num(x);

  // ---- helpers produits (pour les termes "en u") ----
  function prodHead(A, x){
    if (A===0 || x===0) return '0';
    if (A===1)  return num(x);
    if (A===-1) return (x<0 ? num(Math.abs(x)) : UMINUS+num(x)); // −x ; si x<0 → +|x| en tête
    return (A<0? UMINUS : '') + `${Math.abs(A)} \\times ${par(x)}`;
  }
  function prodTail(A, x){
    if (A===0 || x===0) return '';
    if (A===1)  return (x<0 ? ` − ${num(Math.abs(x))}` : ` + ${num(x)}`);
    if (A===-1) return (x<0 ? ` + ${num(Math.abs(x))}` : ` − ${num(x)}`);
    return (A<0? ' − ' : ' + ') + `${Math.abs(A)} \\times ${par(x)}`;
  }

  // ---- helpers pour les constantes (plus jamais "× 1") ----
  const headConst = B => (B<0 ? `−${Math.abs(B)}` : String(B));
  const tailConst = B => (B<0 ? ` − ${Math.abs(B)}` : ` + ${B}`);

  // Somme A*x + B*(constante). Si isConstB=true, on traite B comme un PUR nombre.
  function sumShow(A, xa, B, xb, isConstB){
    const zA = (A===0 || xa===0);
    const zB = (B===0 || (isConstB ? false : xb===0));

    if (zA && zB) return '0';
    if (zA) return isConstB ? headConst(B) : prodHead(B, xb);

    let s = prodHead(A, xa);
    if (!zB) s += isConstB ? tailConst(B) : prodTail(B, xb);
    return s.replace(/^\s*\+\s*/,'') || '0';
  }

  // ---- lignes symboliques instanciées u1/u2/u3 ----
  const coefU = (A, lab) => (
    A===0 ? '0' :
    A===1 ? lab :
    A===-1 ? UMINUS+lab :
    (A<0? UMINUS:'') + Math.abs(A) + lab
  );
  const symGeo = (q,k)=> `u_{${k}} = ${coefU(q, 'u_{'+(k-1)+'}')}`;
  const symAri = (r,k)=> `u_{${k}} = u_{${k-1}}${r? (r<0?` ${UMINUS} ${Math.abs(r)}`:` + ${r}`):''}`.replace(/\+\s*$/,'');
  const symAG  = (a,b,k)=> {
    let left = (a===0)? '' : coefU(a, 'u_{'+(k-1)+'}');
    if (b) left += (b<0? ` ${UMINUS} ${Math.abs(b)}` : ` + ${b}`);
    return `u_{${k}} = ${left || '0'}`;
  };

  // ---- construit les 3 colonnes (u1,u2,u3) ----
  const u=[s.u0,s.u1,s.u2,s.u3];
  const steps=[];
  if(s.kind==='geo'){
    for(let k=1;k<=3;k++){
      steps.push([
        symGeo(s.q,k),
        `u_{${k}} = ${prodHead(s.q, u[k-1])}`,
        `u_{${k}} = ${num(u[k])}`
      ]);
    }
  }else if(s.kind==='ari'){
    for(let k=1;k<=3;k++){
      steps.push([
        symAri(s.b,k),
        `u_{${k}} = ${sumShow(1, u[k-1], s.b, 1, true)}`, // ← b traité comme constante
        `u_{${k}} = ${num(u[k])}`
      ]);
    }
  }else{ // arithmético-géométrique
    for(let k=1;k<=3;k++){
      steps.push([
        symAG(s.a,s.b,k),
        `u_{${k}} = ${sumShow(s.a, u[k-1], s.b, 1, true)}`, // ← b constant (pas de ×1)
        `u_{${k}} = ${num(u[k])}`
      ]);
    }
  }

  // dédoublonnage doux
  function dedup(col){
    const out=[]; let prev='';
    const norm=t=>String(t).replace(/\s+/g,' ').replace(/[−–—]/g,'-').trim();
    for(const L of col){ if(!L) continue; const n=norm(L); if(n!==prev){ out.push(L); prev=n; } }
    return out;
  }

  const html = `
    <div class="sol-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
      ${steps.map(col=>{
        const lines = dedup(col);
        return `<div class="steps">${lines.map(t=>`<div class="step">\\(${t}\\)</div>`).join('')}</div>`;
      }).join('')}
    </div>
    <div class="steps" style="margin-top:8px">
      <div class="step">\\(\\text{Relation : } ${s.relation}\\)</div>
    </div>`;
  $('#steps',host).innerHTML = html;
  retypeMath(host);

  // auto-fill
}


});


  return L;
}

/* ===== REGISTRY & UI (mêmes hooks que ton modèle) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // Entrée => Vérifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d’affichage :</b> ${e.message}<br>Ouvre la console pour le détail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit prêt et que le kit soit chargé
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: 'Première — Suites numériques',
        max: 50,
        // Monte l'UI PDF juste après ta carte "Saisie & réponses"
        mountAfterSelector: '#info-saisie',
        // Texte d’amorce par type (affiché avant chaque exo dans le PDF)
                // Optionnel : laisse à false pour ne pas lancer l’impression automatiquement
        autoPrint: false
      });
    } else {
      // réessaie brièvement si le kit ou REGISTRY n’est pas encore prêts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui évitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas référencer ok4 si la Q(b) est commentée
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un éventuel tick fantôme #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit s’écrire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
