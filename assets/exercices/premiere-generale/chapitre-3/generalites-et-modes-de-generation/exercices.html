<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Premi√®re ‚Äî Suites num√©riques (LATEX)</title>

<!-- m√™mes feuilles que ton mod√®le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles √† l‚Äô√©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de r√©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
</style>

<!-- MathJax comme dans ton mod√®le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- m√™mes libs partag√©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Premi√®re ‚Äî <strong>Suites num√©riques</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contr√¥le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- H√¥te d‚Äôexercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & r√©ponses accept√©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> accept√©es
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenth√®ses/accolades, soulign√©s, <code>*</code> ou <code>√ó</code> sont normalis√©s).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = '‚àí';

/* ===== Utilitaires g√©n√©riques (m√™mes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tol√®re u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, √ó, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/√ó|\*/g,'');
  s = s.replace(/[‚àí‚Äì‚Äî]/g,'-');

  // normaliser les √©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'‚úì':'‚úó'; }
// ‚úì / ‚úó / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] ‚Üí an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "‚àí" coll√©s
  let s = parts.join(' + ').replace(/\+\s*‚àí/g, UMINUS).replace(/‚àí\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/‚àí en LaTeX
  s = s.replace(/\+/g,'+').replace(/‚àí/g, UMINUS);
  return s || '0';
}

/* =====  EXERCICES  ===== */
function makeExos(){
  const L=[];

  /* === Ex. 1 ‚Äî u_n = f(n) (premiers termes & u_5) === */
  /* === Ex. 1 ‚Äî u_n = f(n) (s√©lecteur + m√©lange + u_k, k‚àà[8..20]) === */
L.push({
  id:'ex1_f_de_n',
  title:"Ex. 1 ‚Äî Suite d√©finie par une fonction (choix de f)",

 /* ---------- Utils ---------- */
  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){ if(d===0) return {n:NaN,d:0}; if(d<0){n=-n;d=-d} const g=this._gcd(n,d); return {n:n/g,d:d/g}; },
  _isSquare(N){ if(N<0) return false; const r=Math.floor(Math.sqrt(N)); return r*r===N; },
_fmtIntOrFrac(n,d){
  // Cas d√©g√©n√©r√©s
  if (d === 0) return '\\text{ind√©fini}';

  // Toujours simplifier et mettre le d√©nominateur > 0
  const s = this._simp(n,d); // -> {n,d} avec d>0

  // -0 -> 0
  if (s.n === 0) return '0';

  // Si c'est un entier apr√®s simplification
  if (s.d === 1) return String(s.n);

  // Signe *devant* la fraction, num√©rateur toujours positif
  const sign = (s.n < 0) ? '‚àí' : '';
  return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
},
_normStep(s){
  return s
    // espaces exotiques ‚Üí espace
    .replace(/[\u00A0\u2009\u200A\u202F]/g, ' ')
    // unifier les diff√©rents "moins" en hyphen ASCII pour comparer
    .replace(/[‚àí‚Äì‚Äî]/g, '-')
    // nettoyage g√©n√©ral
    .replace(/\s+/g, ' ')
    .replace(/\s*√ó\s*/g, ' √ó ')
    .replace(/\+\s*-/g, '-')     // "+ -" ‚Üí "-"
    .replace(/-\s*\+/g, '-')     // "- +" ‚Üí "-"
    .replace(/\s*=\s*/g, ' = ')
    .replace(/([\-+])\s+(\d)/g, '$1$2') // "- 6" ‚Üí "-6"
    .trim();
}
,

_dedup(lines){
  const out = [];
  let prevN = '';
  for(const L of lines){
    if(!L) continue;
    const curN = this._normStep(L);
    if(curN !== prevN){
      out.push(L);              // on garde la version originale pour l‚Äôaffichage
      prevN = curN;
    }
  }
  return out;
},



/* ---------- Helpers affichage (jamais 1 ou ‚àí1 devant une variable) ---------- */
// Premier terme d‚Äôune somme (pas de " + " en t√™te)
_termFirst(k, body, isVarLike, X){ // k: coeff, body: "n", "n^2", "3^3", ..., isVarLike: true si variable/puissance, X = s.times ("\\times")
  if(k===0) return '';
  const A = Math.abs(k);
  const sgn = (k<0 ? '‚àí' : '');
  if(A===1) return sgn + body;                 // ¬±1 ‚Üí signe seul, pas de "√ó"
  return sgn + A + ' ' + X + ' ' + body;       // autre coeff ‚Üí "a √ó body"
},
// Terme suivant (ajoute " + " ou " ‚àí ")
_termNext(k, body, isVarLike, X){
  if(k===0) return '';
  const A = Math.abs(k);
  const lead = (k<0 ? ' ‚àí ' : ' + ');
  if(A===1) return lead + body;                // ¬±1 ‚Üí pas de "√ó"
  return lead + A + ' ' + X + ' ' + body;
},
// a¬∑n + b avec ¬±1 masqu√© (pour jolis (an+b)/(cn+d))
_linExpr(a,b,X){
  let s = '';
  if(a){
    s += this._termFirst(a,'n',true,X);
  }
  if(b){
    s += (b<0 ? ' ‚àí ' + Math.abs(b) : (s ? ' + ' + b : String(b)));
  }
  return s || '0';
},
// Version LaTeX pour fLatex de l‚Äôhomographique
_linLatex(a,b){
  let s='';
  if(a){
    if(a===1) s+='n';
    else if(a===-1) s+='‚àín';
    else s+=(a<0?'‚àí':'')+'{'+Math.abs(a)+'}n';
  }
  if(b){
    if(!s) s += String(b);
    else s += (b<0? '‚àí'+Math.abs(b) : '+'+b);
  }
  return s || '0';
},
// (dans tes helpers)
_powBody(n,p){              // corps : n, n^2, n^3
  return p===3 ? `${n}^3` : p===2 ? `${n}^2` : `${n}`;
},

// 1er terme apr√®s substitution : on MASQUE ¬±1 mais on NE SUPPRIME PAS n=0
_subFirst(k,n,p,X){
  if (k===0) return '';
  const A   = Math.abs(k);
  const sgn = (k<0 ? '‚àí' : '');
  const body = this._powBody(n,p);            // ex: "0^2"
  if (A===1) return sgn + body;               // ¬±1 ‚Üí pas de "√ó"
  return sgn + A + ' ' + X + ' ' + body;      // autre coeff ‚Üí "a √ó body"
},



// Terme suivant (ajoute " + " ou " ‚àí ") ‚Äî on garde k√ó0 quand n=0 (ex: ‚àí3 √ó 0)
// Terme suivant (ajoute " + " ou " ‚àí ") ‚Äî conserve l'exposant si n=0
_subNext(k, n, p, X){
  if (k === 0) return '';
  const lead = (k < 0 ? ' ‚àí ' : ' + ');
  const A = Math.abs(k);

  if (n === 0){
    const body0 = this._powBody(0, p);     // "0", "0^2", "0^3"
    // pas de "1 √ó ‚Ä¶" ; sinon on garde le produit k √ó 0^p
    return A === 1 ? (lead + body0) : (lead + A + ' ' + X + ' ' + body0);
  }

  // cas g√©n√©ral
  const body = this._powBody(n, p);
  return A === 1 ? (lead + body) : (lead + A + ' ' + X + ' ' + body);
},



// Ajout de la constante en fin
_constNext(c){
  if(!c) return '';
  return (c<0 ? ' ‚àí ' + Math.abs(c) : ' + ' + c);
},

  gen(){
    const host = document.querySelector('#host');
    const rawKind = host?.dataset?.e1kind || 'mix';   // 'mix' par d√©faut
    const KINDS = ['lineaire','affine','carre','cube','poly2','poly3','inverse','homographique','alternance','racine'];
    const kind = (rawKind==='mix') ? KINDS[Math.floor(Math.random()*KINDS.length)] : rawKind;
    const kIndex = rint(8,20);

    // Petits helpers d‚Äô√©criture
    const plus = (b)=> b? (b<0?` - ${Math.abs(b)}`:` + ${b}`) : '';
    const t = (x)=> String(x).replace(/-/g,'‚àí'); // joli moins visuel
    const times = '\\times';

    let fLatex='', fEval=(n)=>0, params={}, remark='';

    if(kind==='lineaire'){                       // m n, m‚â†0
      let m=rint(-6,6); if(m===0) m=2;
fLatex = `${m<0?'‚àí':''}${Math.abs(m)===1?'':'{'+Math.abs(m)+'}'}n`;                 // lineaire
      fEval = n => m*n;
      params={m};
    }
    else if(kind==='affine'){                    // m n + p, m‚â†0, p‚â†0
      let m=rint(-6,6); if(m===0) m=2;
      let p=rint(-9,9); if(p===0) p=3;
fLatex = `${m<0?'‚àí':''}${Math.abs(m)===1?'':'{'+Math.abs(m)+'}'}n${plus(p)}`;       // affine
      fEval = n => m*n + p;
      params={m,p};
    }
    else if(kind==='carre'){ fLatex=`n^2`; fEval=n=>n*n; params={}; }
    else if(kind==='cube'){  fLatex=`n^3`; fEval=n=>n*n*n; params={}; }

    else if(kind==='poly2'){                     // a n^2 + b n + c, a‚â†0
      let a=rint(-5,5); if(a===0) a=2;
      let b=rint(-4,4), c=rint(-6,6);
      const m2 = (A,P)=> (A===0?'':`${A<0?'‚àí':''}${Math.abs(A)===1?'':'{'+Math.abs(A)+'}'}n${P===2?'^2':''}`);
      let parts = [m2(a,2), m2(b,1), (c? t(c):'')].filter(Boolean);
      fLatex = parts.join(' + ').replace(/\+\s*‚àí/g,'‚àí').replace(/‚àí\s*\+/g,'‚àí').replace(/^\+\s*/,'');
      fEval = n => a*n*n + b*n + c;
      params={a,b,c};
    }
   // dans gen(), bloc poly3 ‚Üí fLatex
else if(kind==='poly3'){                     // a n^3 + b n^2 + c n + d
  let a=rint(-3,3); if(a===0) a=2;
  let b=rint(-3,3), c=rint(-4,4), d=rint(-6,6);

  // NE PAS √©crire ^1
  const m3 = (A,P)=> (
    A===0 ? '' :
    `${A<0?'‚àí':''}${Math.abs(A)===1?'':'{'+Math.abs(A)+'}'}n${P>1 ? '^'+P : ''}`
  );

  let parts = [m3(a,3), m3(b,2), m3(c,1), (d? String(d).replace(/-/g,'‚àí') :'')].filter(Boolean);
  fLatex = parts.join(' + ')
                .replace(/\+\s*‚àí/g,'‚àí')
                .replace(/‚àí\s*\+/g,'‚àí')
                .replace(/^\+\s*/,'');
  fEval = n => a*n*n*n + b*n*n + c*n + d;
  params={a,b,c,d};
}

    else if(kind==='inverse'){                   // 1/n
      fLatex = `\\dfrac{1}{n}`;
      fEval = n => 1/n;
      remark='(n‚â•1)';
      params={};
    
    } else if(kind==='homographique'){ // (an+b)/(cn+d) ; √©viter z√©ros
  let a=rint(-3,3), b=rint(-6,6), c=choice([-2,-1,1,2]), d=rint(-6,6);
  const bad = new Set([0,1,2,kIndex]);
  let tries=0;
  while(tries++<60 && Array.from(bad).some(n => c*n + d === 0)){ d=rint(-6,6); }
  const Nlatex = this._linLatex(a,b);
  const Dlatex = this._linLatex(c,d);
  fLatex = `\\dfrac{${Nlatex}}{${Dlatex}}`;
  fEval = n => (a*n + b)/(c*n + d);
  remark='(simplifier la fraction)';
  params={a,b,c,d};
}
    else if(kind==='alternance'){                // k(-1)^n + b
      let k=choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]), b=rint(-6,6);
fLatex = `${k<0?'‚àí':''}${Math.abs(k)===1?'':'{'+Math.abs(k)+'}'}(-1)^n${plus(b)}`;  // alternance
      fEval = n => k*Math.pow(-1,n) + b;
      params={k,b};
    }
    else {                                       // racine : ‚àö(n + d)
      let d=rint(0,10);
      fLatex = `\\sqrt{n${plus(d)}}`;
      fEval = n => Math.sqrt(n + d);
      remark='(laisser sous la racine si non carr√© parfait)';
      params={d};
    }

    // Indices √† calculer en (a)
    const idxs = (kind==='inverse') ? [1,2,3] : [0,1,2];
    const values = idxs.map(n=>fEval(n));
    const uk = fEval(kIndex);

    return { rawKind, kind, fLatex, fEval, params, remark, idxs, values, kIndex, uk, times };
  },

  render(host,s){
    host.dataset.state='';
    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Choisir \\(f\\) :
            <select id="e1-kind">
              <option value="mix">m√©lange (al√©atoire)</option>
              <option value="lineaire">fonction lin√©aire </option>
              <option value="affine">fonction affine</option>
              <option value="carre">carr√©</option>
              <option value="cube">cube</option>
              <option value="poly2">Polyn√¥me du second degr√© </option>
              <option value="poly3">Polyn√¥me du troisi√®me degr√© </option>
              <option value="inverse">inverse 1/n</option>
              <option value="homographique">homographique</option>
              <option value="alternance">k(-1)‚Åø+b</option>
              <option value="racine">racine carr√©e </option>
            </select>
          </p>

          <p>Soit \\((u_n)\\) la suite d√©finie, pour tout entier naturel \\(n\\), par :
             \\[ u_n = ${s.fLatex} \\] ${s.remark?`<span class="hint">${s.remark}</span>`:''}
             ${s.rawKind==='mix' ? `<br><span class="hint">Mode m√©lange : fonction tir√©e = <b>${s.kind}</b>.</span>` : ''}
          </p>

          <p>a) Calculer les trois premiers termes.<br>
             \\(u_{${s.idxs[0]}}=\\) ${mkInput('e1',100)} <span id="t1" class="tick"></span> &nbsp;
             \\(u_{${s.idxs[1]}}=\\) ${mkInput('e2',100)} <span id="t2" class="tick"></span> &nbsp;
             \\(u_{${s.idxs[2]}}=\\) ${mkInput('e3',100)} <span id="t3" class="tick"></span></p>

          <p>b) Calculer \\(u_{${s.kIndex}}\\). &nbsp; \\(u_{${s.kIndex}}=\\) ${mkInput('e4',120)} <span id="t4" class="tick"></span></p>
        <div class="equ-offscreen" style="display:none">
 <p>Soit \\((u_n)\\) la suite d√©finie, pour tout entier naturel \\(n\\), par :
             \\[ u_n = ${s.fLatex} \\] 
          </p>
          <p>a) Calculer les trois premiers termes.<br>
          <p>b) Calculer \\(u_{${s.kIndex}}\\). </p>
        </div>
		
		</div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;
    retypeMath(host);
    host.__state = s;

    const sel = host.querySelector('#e1-kind');
    if(sel){
      sel.value = s.rawKind;
      sel.addEventListener('change', ()=>{
        const h = document.querySelector('#host');
        if(h) h.dataset.e1kind = sel.value;
        renderActiveSafe('e1-kind.change');
      });
    }
  },

  check(host){
  const s = host.__state;

  const a = val('e1').trim();
  const b = val('e2').trim();
  const c = val('e3').trim();
  const d = val('e4').trim();

  const ok1 = a==='' ? null : near(parseNumber(a), s.values[0]);
  const ok2 = b==='' ? null : near(parseNumber(b), s.values[1]);
  const ok3 = c==='' ? null : near(parseNumber(c), s.values[2]);
  const ok4 = d==='' ? null : near(parseNumber(d), s.uk);

  tickTri($('#t1',host), ok1);
  tickTri($('#t2',host), ok2);
  tickTri($('#t3',host), ok3);
  tickTri($('#t4',host), ok4);

  const hasBlank = (a==='' || b==='' || c==='' || d==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3) && (!!ok4);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    return ok;
  }
  return false; // on ne score pas tant que tout n‚Äôest pas rempli
},


  /* ---------- Fabrique les √©tapes d'un calcul u_n selon le type ---------- */
  _stepsFor(s, n){
    const X = s.times; const P = s.params;
    const lines = [];
    const eq = (rhs)=>`u_{${n}} = ${rhs}`;
const push = (rhs)=>{
  const L = eq(rhs);
  const prev = lines.length ? lines[lines.length-1] : '';
  if(this._normStep(L) !== this._normStep(prev)) lines.push(L);
};

if(s.kind==='lineaire'){
  const m = P.m;
  const L1 = (n===0 && Math.abs(m)===1) ? '0' : this._subFirst(m,n,1,X);
  lines.push(eq(L1));
  lines.push(eq(`${m*n}`));
}


    else if(s.kind==='affine'){
  const m = P.m, p = P.p;

  // L1 ‚Äî substitution propre (masque ¬±1, garde k√ó0 quand n=0)
  let l1 = this._subFirst(m, n, 1, X) + this._constNext(p);
  l1 = l1.replace(/^\s*\+\s*/,'').replace(/\+\s*‚àí/g,'‚àí').replace(/‚àí\s*\+/g,'‚àí');
  lines.push(eq(l1));

  // L2 ‚Äî produits num√©riques (sans "+ 0")
  const mn = m*n;
  let l2 = '';
  if (mn !== 0) l2 = `${mn}`;
  if (p){
    if (!l2) l2 = `${p}`;
    else l2 += (p < 0 ? ` ‚àí ${Math.abs(p)}` : ` + ${p}`);
  }
  lines.push(eq(l2 || '0'));

  // L3 ‚Äî r√©sultat final
  lines.push(eq(`${mn + (p||0)}`));
}

    else if(s.kind==='carre'){
      lines.push(eq(`${n}^2`));
      lines.push(eq(`${n*n}`));
    }
    else if(s.kind==='cube'){
      lines.push(eq(`${n}^3`));
      lines.push(eq(`${n*n*n}`));
    }
    else if(s.kind==='poly2'){
  const a=P.a,b=P.b,c=P.c;

  // L1 ‚Äî premi√®re ligne : pas de 1/‚àí1 devant, et si n=0 alors " + 0"
  let l1 = this._subFirst(a,n,2,X) + this._subNext(b,n,1,X) + this._constNext(c);
  l1 = l1.replace(/^\s*\+\s*/,'').replace(/\+\s*‚àí/g,'‚àí').replace(/‚àí\s*\+/g,'‚àí');
  lines.push(eq(l1));



// terme en n (b*n) ‚Äî on garde juste le produit num√©rique, sans "√ó"
const bn = b*n;



  // L3 ‚Äî a¬∑n¬≤ √©valu√© + √©ventuels autres termes (sans +0)
  const a2 = a*(n*n);
  const l3 = [`${a2}`];
  if (bn) l3.push(bn<0 ? `‚àí ${Math.abs(bn)}` : `+ ${bn}`);
  if (c)  l3.push(c<0  ? `‚àí ${Math.abs(c)}` : `+ ${c}`);
  lines.push(eq(l3.join(' ')));

  // L4 ‚Äî r√©sultat final
  lines.push(eq(`${a2 + bn + (c||0)}`));
}


   else if(s.kind==='poly3'){
  const a=P.a, b=P.b, c=P.c, d=P.d;

  // L1
  let l1 = this._subFirst(a,n,3,X) + this._subNext(b,n,2,X) + this._subNext(c,n,1,X) + this._constNext(d);
  l1 = l1.replace(/^\s*\+\s*/,'').replace(/\+\s*‚àí/g,'‚àí').replace(/‚àí\s*\+/g,'‚àí');
  push(l1);

  // L2
  const n3=n*n*n, n2=n*n;
  let head2='';
  if(n3===0) head2='0';
  else if(a===1) head2=`${n3}`;
  else if(a===-1) head2=`‚àí ${n3}`;
  else head2=`${a} ${X} ${n3}`;

  const l2=[head2];
  const b2=b*n2; if(b2) l2.push(b2<0?`‚àí ${Math.abs(b2)}`:`+ ${b2}`);
  const c1=c*n;  if(c1) l2.push(c1<0?`‚àí ${Math.abs(c1)}`:`+ ${c1}`);
  if(d)          l2.push(d<0?`‚àí ${Math.abs(d)}`:`+ ${d}`);
  push(l2.join(' ').replace(/^\s*\+\s*/,'') || '0');

  // L3 (num√©rique interm√©diaire)
  const a3=a*n3;
  const l3=[];
  if(a3) l3.push(`${a3}`);
  if(b2) l3.push(b2<0?`‚àí ${Math.abs(b2)}`:`+ ${b2}`);
  if(c1) l3.push(c1<0?`‚àí ${Math.abs(c1)}`:`+ ${c1}`);
  if(d)  l3.push(d<0?`‚àí ${Math.abs(d)}`:`+ ${d}`);
  const L3txt = (l3.join(' ').replace(/^\s*\+\s*/,'')) || '0';

  // L4 (r√©sultat)
  const val = (a3||0) + (b2||0) + (c1||0) + (d||0);
  const L4txt = `${val}`;

  // On n‚Äôajoute L3 que si diff√©rente de L4 (apr√®s normalisation)
  if(this._normStep(`u_{${n}} = ${L3txt}`) !== this._normStep(`u_{${n}} = ${L4txt}`)){
    push(L3txt);
  }
  push(L4txt);
}


    else if(s.kind==='inverse'){
      if(n===0){ lines.push(eq(`\\text{ind√©fini}`)); }
      else{
        const num=1, den=n; const simp=this._simp(num,den);
        lines.push(eq(`\\dfrac{1}{${n}}`));
        lines.push(eq(this._fmtIntOrFrac(simp.n,simp.d)));
      }
    }
    else if(s.kind==='homographique'){
  const a=P.a, b=P.b, c=P.c, d=P.d;
  const norm = s => s.replace(/^\s*\+\s*/,'').replace(/\+\s*‚àí/g,'‚àí').replace(/‚àí\s*\+/g,'‚àí');

  // L1 ‚Äî substitution propre dans chaque membre (an+b)/(cn+d)
  const top1 = norm(this._subFirst(a, n, 1, X) + this._constNext(b)) || '0';
  const bot1 = norm(this._subFirst(c, n, 1, X) + this._constNext(d)) || '0';
  lines.push(eq(`\\dfrac{${top1}}{${bot1}}`));

  // L2 ‚Äî fractions num√©riques (an+b)/(cn+d)
  const N = a*n + b;
  const D = c*n + d;
  if (D === 0){
    lines.push(eq(`\\text{ind√©fini}`));
    return lines;
  }
  lines.push(eq(`\\dfrac{${N}}{${D}}`));

  // L3 ‚Äî √©criture "entier ou fraction" (non r√©duite)
  lines.push(eq(this._fmtIntOrFrac(N, D)));

  // L4 ‚Äî simplification √©ventuelle
  const simp = this._simp(N, D);
  if (!(simp.n===N && simp.d===D)) {
    lines.push(eq(this._fmtIntOrFrac(simp.n, simp.d)));
  }
}

    else if(s.kind==='alternance'){
  const sgnVal  = Math.pow(-1,n);          // 1 ou -1
  const sgnShow = (sgnVal === 1) ? '1' : '(‚àí1)';  // () seulement pour -1

  // L1 ‚Äî on garde les parenth√®ses autour de -1 dans la puissance
  lines.push(eq(`${P.k} ${X} (-1)^{${n}} ${P.b?(P.b<0?`- ${Math.abs(P.b)}`:`+ ${P.b}`):''}`));

  // L2 ‚Äî pas de parenth√®ses autour de 1
  lines.push(eq(`${P.k} ${X} ${sgnShow} ${P.b?(P.b<0?`- ${Math.abs(P.b)}`:`+ ${P.b}`):''}`));

  // L3 ‚Äî produit num√©rique
  lines.push(eq(`${(sgnVal*P.k)} ${P.b?(P.b<0?`- ${Math.abs(P.b)}`:`+ ${P.b}`):''}`));

  // L4 ‚Äî r√©sultat final
  lines.push(eq(`${sgnVal*P.k + (P.b||0)}`));
}

    else { // racine
      const inside = n + (P.d||0);
      if(this._isSquare(inside)){
        const r = Math.round(Math.sqrt(inside));
        lines.push(eq(`\\sqrt{${n}${P.d?(P.d<0?`- ${Math.abs(P.d)}`:`+ ${P.d}`):''}}`));
        lines.push(eq(`\\sqrt{${inside}}`));
        lines.push(eq(`${r}`));
      }else{
        lines.push(eq(`\\sqrt{${n}${P.d?(P.d<0?`- ${Math.abs(P.d)}`:`+ ${P.d}`):''}}`));
        lines.push(eq(`\\sqrt{${inside}}`));
      }
    }
    return this._dedup(lines);
  },

  solution(host){
    const s=host.__state;
    const W=$('#steps',host);

    // (a) ‚Äî 3 colonnes
    const colsHtml = s.idxs.map(n=>{
      const lines = this._stepsFor(s,n).map(txt=>`<div class="step">\\(${txt}\\)</div>`).join('');
      return `<div class="steps">${lines}</div>`;
    }).join('');
    // (b) ‚Äî u_k
    const linesB = this._stepsFor(s, s.kIndex).map(txt=>`<div class="step">\\(${txt}\\)</div>`).join('');

    W.innerHTML = `
      <div class="sol-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">${colsHtml}</div>
      <div class="steps" style="margin-top:8px">${linesB}</div>
    `;
    retypeMath(W);

    /* Auto-remplissage des champs (sans d√©cimaux) */
    function setFracOrInt(id, valNum, kind, n){
      if(kind==='inverse'){
        if(n===0) return;
        const obj={n:1,d:n};
        const g = (function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a})(obj.n,obj.d);
        const N=obj.n/g, D=obj.d/g;
        return;
      }
      if(kind==='homographique'){
        const P=s.params, N=P.a*n+P.b, D=P.c*n+P.d;
        const g = (function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a})(N,D);
        const n2=N/g, d2=D/g;
        return;
      }
      if(kind==='racine'){ return; } // pas de d√©cimal
    }
    setFracOrInt('e1', s.values[0], s.kind, s.idxs[0]);
    setFracOrInt('e2', s.values[1], s.kind, s.idxs[1]);
    setFracOrInt('e3', s.values[2], s.kind, s.idxs[2]);
    setFracOrInt('e4', s.uk,        s.kind, s.kIndex);
  }
});


 L.push({
  id:'ex2_recurrence_1',
  title:"Ex. 2 ‚Äî Suite r√©currente : u_{n+1}=f(u_n)",

  /* === Helpers locaux === */
  _gcd:function(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ var t=a%b; a=b; b=t; } return a||1; },
  _simp:function(n,d){ if(d===0) return {n:NaN,d:0}; if(d<0){n=-n;d=-d} var g=this._gcd(n,d); return {n:n/g,d:d/g}; },
  _fmtIntOrFrac:function(n,d){ if(d===1) return String(n); var s=n<0?'‚àí':''; return s+"\\dfrac{"+Math.abs(n)+"}{"+d+"}"; },
  _dedup:function(lines){
    function norm(s){ return String(s).replace(/[\u00A0\u2009\u200A\u202F]/g,' ')
      .replace(/[‚àí‚Äì‚Äî]/g,'-').replace(/\s+/g,' ').replace(/\+\s*-/g,'-')
      .replace(/-\s*\+/g,'-').replace(/\s*=\s*/g,' = ').trim(); }
    var out=[], prev=''; for(var i=0;i<lines.length;i++){ var L=lines[i]; if(norm(L)!==norm(prev)){ out.push(L); prev=L; } }
    return out;
  },
  _plus:function(b){ return b ? (b<0? " ‚àí "+Math.abs(b) : " + "+b) : ""; },
  _pow:function(body,p){ return p===3?body+"^{3}" : p===2?body+"^{2}" : body; },
  _varMonome:function(coeff, lab, pow){
    if(coeff===0) return '';
    var A=Math.abs(coeff), sgn=coeff<0?'‚àí':'', v=this._pow(lab,pow);
    return (A===1)? (sgn+v) : (sgn+"{"+A+"}"+v);
  },
  _num:function(x){ return String(x).replace(/-/g,'‚àí'); },          // nombre avec joli ‚Äú‚àí‚Äù
  _par:function(x){ var s=this._num(x); return (x<0? "("+s+")" : s); }, // parenth√®ses si n√©gatif
  _timesNum:function(A,x){                                         // A √ó x, parenth√®ses si x<0
    return A+" \\times "+this._par(x);
  },

  /* === Fabrique f (SANS alternance) ‚Äî showNum corrig√© === */
  _makeF:function(kind){
    var plus=this._plus.bind(this), self=this;

    if(kind==='lineaire'){
  var m=rint(-6,6); if(m===0) m=2;
  return {
    kind:kind, params:{m:m}, remark:'',
    showVar:function(lab){ return self._varMonome(m,lab,1) || '0'; },
    showNum:function(x){
      if(m===1)  return self._num(x);                          // pas "(x)"
      if(m===-1) return "‚àí" + (x<0 ? "("+self._num(x)+")" : self._num(x));
      return self._timesNum(m,x);                               // m √ó (x) (parenth√®ses si x<0)
    },
    f:function(u){ return m*u; }
  };
}



    if(kind==='affine'){
  var m2=rint(-6,6); if(m2===0) m2=2;
  var p=rint(-9,9);  if(p===0)  p=3;
  return {
    kind:kind, params:{m:m2,p:p}, remark:'',
    showVar:function(lab){
      var s = self._varMonome(m2,lab,1) + (p? (p<0?' ‚àí '+Math.abs(p):' + '+p) : '');
      return s.replace(/^\s*\+\s*/,'') || '0';
    },
    // ‚¨áÔ∏è pas de parenth√®ses si m=1 (terme seul) ; parenth√®ses uniquement en produit ou pour "‚àí(x)"
    showNum:function(x){
      var head;
      if(m2===1){
        head = self._num(x);                           // ex: u_{n+1}=u_n+p  ‚Üí  -9 - 9 (sans ())
      }else if(m2===-1){
        head = "‚àí" + (x<0 ? "("+self._num(x)+")" : self._num(x));  // ‚àí(x) si x<0
      }else{
        head = self._timesNum(m2,x);                   // m √ó (x) ‚Üí parenth√®ses si x<0 (d√©j√† g√©r√©)
      }
      var s = head + (p ? (p<0 ? ' ‚àí '+Math.abs(p) : ' + '+p) : '');
      return s.replace(/^\s*\+\s*/,'') || '0';
    },
    f:function(u){ return m2*u + p; }
  };
}


    if(kind==='carre'){
      return {
        kind:kind, params:{}, remark:'',
        showVar:function(l){return l+"^{2}";},
        showNum:function(x){ return self._par(x)+"^{2}"; },  // (x)^2 si x<0
        f:function(u){return u*u;}
      };
    }

    if(kind==='cube'){
      return {
        kind:kind, params:{}, remark:'',
        showVar:function(l){return l+"^{3}";},
        showNum:function(x){ return self._par(x)+"^{3}"; },  // (x)^3 si x<0
        f:function(u){return u*u*u;}
      };
    }

    if(kind==='poly2'){
      var a=rint(-5,5); if(a===0) a=2; var b=rint(-4,4), c=rint(-6,6);
      return {
        kind:kind, params:{a:a,b:b,c:c}, remark:'',
        showVar:function(lab){
          var s = self._varMonome(a,lab,2);
          if(b){
            if(Math.abs(b)===1) s += (b<0?' ‚àí ':' + ')+lab;
            else s += (b<0?' ‚àí '+Math.abs(b)+lab:' + '+Math.abs(b)+lab);
          }
          s += plus(c);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        showNum:function(x){
          var s='';
          // a¬∑u^2
          if(a){
            var x2 = self._par(x)+"^{2}";
            if(a===1) s += x2;
            else if(a===-1) s += "‚àí"+x2;
            else s += self._timesNum(a, self._par(x)+"^{2}".replace(/^\((.*)\)\^\{2\}$/,'$1^{2}')); // garde (x)^2
          }
          // b¬∑u
          if(b){
            if(Math.abs(b)===1){
              // √©viter "+ (‚àí3)" -> " ‚àí 3"
              s += ( (b>0 && x<0) ? ' ‚àí '+Math.abs(x) :
                    (b<0 && x<0) ? ' + '+Math.abs(x) :
                    (b<0) ? ' ‚àí '+self._num(x) : ' + '+self._num(x) );
            }else{
              s += (b<0? ' ‚àí '+Math.abs(b)+' \\times '+self._par(x)
                     : ' + '+Math.abs(b)+' \\times '+self._par(x));
            }
          }
          // + c
          s += plus(c);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        f:function(u){ return a*u*u + b*u + c; }
      };
    }

    if(kind==='poly3'){
      var a3=rint(-3,3); if(a3===0) a3=2; var b3=rint(-3,3), c3=rint(-4,4), d3=rint(-6,6);
      return {
        kind:kind, params:{a:a3,b:b3,c:c3,d:d3}, remark:'',
        showVar:function(lab){
          var s = self._varMonome(a3,lab,3);
          if(b3){
            if(Math.abs(b3)===1) s += (b3<0?' ‚àí ':' + ')+lab+"^{2}";
            else s += (b3<0?' ‚àí '+Math.abs(b3)+lab+'^{2}':' + '+Math.abs(b3)+lab+'^{2}');
          }
          if(c3){
            if(Math.abs(c3)===1) s += (c3<0?' ‚àí ':' + ')+lab;
            else s += (c3<0?' ‚àí '+Math.abs(c3)+lab:' + '+Math.abs(c3)+lab);
          }
          s += plus(d3);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        showNum:function(x){
          var s='';
          // a3¬∑u^3
          if(a3){
            var x3 = self._par(x)+"^{3}";
            if(a3===1) s += x3;
            else if(a3===-1) s += "‚àí"+x3;
            else s += (a3+" \\times "+x3);
          }
          // b3¬∑u^2
          if(b3){
            var x2 = self._par(x)+"^{2}";
            if(Math.abs(b3)===1) s += (b3<0?' ‚àí ':' + ')+x2;
            else s += (b3<0?' ‚àí '+Math.abs(b3)+' \\times '+x2:' + '+Math.abs(b3)+' \\times '+x2);
          }
          // c3¬∑u
          if(c3){
            if(Math.abs(c3)===1){
              s += ( (c3>0 && x<0) ? ' ‚àí '+Math.abs(x) :
                     (c3<0 && x<0) ? ' + '+Math.abs(x) :
                     (c3<0) ? ' ‚àí '+self._num(x) : ' + '+self._num(x) );
            }else{
              s += (c3<0?' ‚àí '+Math.abs(c3)+' \\times '+self._par(x)
                   :' + '+Math.abs(c3)+' \\times '+self._par(x));
            }
          }
          // + d3
          s += plus(d3);
          s = s.replace(/^\s*\+\s*/,''); return s||'0';
        },
        f:function(u){ return a3*u*u*u + b3*u*u + c3*u + d3; }
      };
    }

    if(kind==='inverse'){
      return {
        kind:kind, params:{}, remark:'(d√©fini si \\(u_n\\neq 0\\))',
        showVar:function(lab){ return "\\dfrac{1}{"+lab+"}"; },
        showNum:function(x){ return "\\dfrac{1}{"+(x<0? "("+self._num(x)+")" : self._num(x))+"}"; },
        f:function(u){ return 1/u; }
      };
    }

    if(kind==='homographique'){
      var a4=rint(-3,3), b4=rint(-6,6), c4=choice([-2,-1,1,2]), d4=rint(-6,6);
      function lin(A,B,lab){
        var s = self._varMonome(A,lab,1) + (B? (B<0?' ‚àí '+Math.abs(B):' + '+B) : '');
        s = s.replace(/^\s*\+\s*/,''); return s||'0';
      }
      return {
        kind:kind, params:{a:a4,b:b4,c:c4,d:d4}, remark:'(simplifier ; \\(c\\,u_n + d\\neq 0\\))',
        showVar:function(lab){ return "\\dfrac{"+lin(a4,b4,lab)+"}{"+lin(c4,d4,lab)+"}"; },
        showNum:function(x){
          var top = a4+" \\times "+self._par(x) + (b4? (b4<0?' ‚àí '+Math.abs(b4):' + '+b4):'');
          var bot = c4+" \\times "+self._par(x) + (d4? (d4<0?' ‚àí '+Math.abs(d4):' + '+d4):'');
          return "\\dfrac{"+top+"}{"+bot+"}";
        },
        f:function(u){ return (a4*u + b4)/(c4*u + d4); }
      };
    }

    // ... dans _makeF(kind) :
/* === racine : suite stationnaire pour forcer des carr√©s parfaits √† chaque √©tape === */
var d, r;
if(kind==='racine'){
  r = rint(0,5);                // u0 dans [0..5]
  d = r*r - r;                  // ainsi u_{n+1} = sqrt(u_n + d) = sqrt(r^2) = r (constante)
  return {
    kind:'racine',
    params:{ d:d, r:r },
    remark:'(on a choisi d tel que \\(\\sqrt{u_n+d}=\\sqrt{r^2}\\) √† chaque √©tape)',
    showVar:function(lab){
      return "\\sqrt{"+lab+(d? (d<0?' ‚àí '+Math.abs(d):' + '+d):'')+"}";
    },
    showNum:function(x){
      return "\\sqrt{"+self._num(x)+(d? (d<0?' ‚àí '+Math.abs(d):' + '+d):'')+"}";
    },
    f:function(u){ return Math.sqrt(u + d); }
  };
}

  },

  /* === G√©n√©ration === */
  gen:function(){
  var host=document.querySelector('#host');
  var rawKind = (host && host.dataset && host.dataset.e2kind) ? host.dataset.e2kind : 'mix';
  var KINDS=['lineaire','affine','carre','cube','poly2','poly3','inverse','homographique','racine'];
  var kind = (rawKind==='mix') ? choice(KINDS) : rawKind;

  // (b) pas trop gros : pour carr√©/cube/poly2/poly3 -> k ‚àà {5,6}, sinon k ‚àà [8..12]
  var kIndex = (['carre','cube','poly2','poly3'].includes(kind)) ? choice([5,6]) : rint(8,12);

  var tries=0, ok=false, u0=0, desc=null, seq=null;

  while(tries++<250){
    desc=this._makeF(kind);

    // u0 dans [-5;5] ; pour racine on impose u0 = r (stationnaire)
    u0 = (desc.kind==='racine') ? desc.params.r : rint(-5,5);

    // Domaines
    if(desc.kind==='inverse' && u0===0){ if(rawKind!=='mix') u0=1; else { continue; } }
    if(desc.kind==='homographique' && (desc.params.c*u0 + desc.params.d === 0)){ if(rawKind!=='mix'){ desc=this._makeF('affine'); kind='affine'; } else { kind=choice(KINDS); continue; } }
    if(desc.kind==='racine' && (u0 + (desc.params?desc.params.d:0) < 0)){ continue; }

    // Construire toute la suite jusqu'√† kIndex (on la gardera pour les √©tapes & l'auto-fill)
    seq=[u0]; ok=true;
    for(var i=1;i<=kIndex;i++){
      var prev=seq[i-1];
      if(desc.kind==='inverse' && prev===0){ ok=false; break; }
      if(desc.kind==='homographique' && (desc.params.c*prev + desc.params.d === 0)){ ok=false; break; }
      if(desc.kind==='racine' && (prev + (desc.params?desc.params.d:0) < 0)){ ok=false; break; }
      var next=desc.f(prev);
      if(!isFinite(next)){ ok=false; break; }
      seq.push(next);
    }
	
    if(ok) break;
    if(rawKind==='mix') kind=choice(KINDS);
  }

  if(!ok){
    desc=this._makeF('affine'); kind='affine'; u0=rint(-5,5); seq=[u0];
    for(var j=1;j<=kIndex;j++) seq.push(desc.f(seq[j-1]));
  }

  // ... apr√®s avoir construit: seq=[u0, u1, ..., ukIndex]
var that=this;
function _g(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){var t=a%b;a=b;b=t} return a||1; }
function simp(n,d){ if(d<0){n=-n;d=-d;} var g=_g(n,d); return {n:n/g,d:d/g}; }

var Qseq=[ {n:u0, d:1} ];
for(var i=1;i<=kIndex;i++){
  var p=Qseq[i-1], cur;
  if(desc.kind==='inverse'){
    cur=simp(p.d, p.n);
  }else if(desc.kind==='homographique'){
    var A=desc.params.a, B=desc.params.b, C=desc.params.c, D=desc.params.d;
    cur=simp(A*p.n + B*p.d, C*p.n + D*p.d);
  }else if(desc.kind==='racine' && 'b' in desc.params){
    var ssum = (p.n/p.d) + desc.params.b;           // ici c‚Äôest un entier
    cur=simp(Math.abs(ssum), 1);
  }else{
    cur=simp(seq[i], 1);
  }
  Qseq.push(cur);
}
return { rawKind:rawKind, kind:kind, kIndex:kIndex, u0:u0, u1:seq[1], u2:seq[2], uk:seq[kIndex], seq:seq, Qseq:Qseq, desc:desc };

},


  render:function(host,s){
  host.innerHTML =
    '<div class="row norepere">'+
      '<div class="statement">'+
        '<p>Choisir \\(f\\) : '+
          '<select id="e2-kind">'+
            '<option value="mix">m√©lange (al√©atoire)</option>'+
            '<option value="lineaire">lin√©aire (m¬∑u)</option>'+
            '<option value="affine">affine (m¬∑u+p)</option>'+
            '<option value="carre">carr√© (u^2)</option>'+
            '<option value="cube">cube (u^3)</option>'+
            '<option value="poly2">polyn√¥me degr√© 2</option>'+
            '<option value="poly3">polyn√¥me degr√© 3</option>'+
            '<option value="inverse">inverse (1/u)</option>'+
            '<option value="homographique">homographique</option>'+
            '<option value="racine">racine carr√©e</option>'+
          '</select>'+
        '</p>'+
        '<p>On consid√®re la suite \\((u_n)\\) d√©finie par :<br>'+
           '\\[ u_0='+s.u0+',\\qquad u_{n+1} = '+s.desc.showVar('u_n')+' \\] '+
           (s.desc.remark?'<span class="hint">'+s.desc.remark+'</span>':'')+
           (s.rawKind==="mix"?'<br><span class="hint">Mode m√©lange : <b>'+s.kind+'</b>.</span>':'')+
        '</p>'+
        '<p>Calculer les trois premiers termes.<br>'+
           '\\(u_0=\\) '+mkInput('r1',90)+' <span id="t1" class="tick"></span> &nbsp; '+
           '\\(u_1=\\) '+mkInput('r2',90)+' <span id="t2" class="tick"></span> &nbsp; '+
           '\\(u_2=\\) '+mkInput('r3',90)+' <span id="t3" class="tick"></span></p>'+
        // '<p>b) Calculer \\(u_{'+s.kIndex+'}\\). &nbsp; \\(u_{'+s.kIndex+'}=\\) '+mkInput('r4',120)+' <span id="t4" class="tick"></span></p>'+
        
        // ---------- Bloc √©nonc√© pour le PDF (hors UI) ----------
        '<div class="equ-offscreen" style="display:none">'+
          '<p>On consid√®re la suite \\((u_n)\\) d√©finie par :</p>'+
          '<p>\\[ u_0='+s.u0+',\\qquad u_{n+1} = '+s.desc.showVar('u_n')+' \\]</p>'+
          '<p>Calculer les trois premiers termes : \\(u_0,\\ u_1,\\ u_2\\).</p>'+
        '</div>'+

      '</div>'+
      '<div><div class="steps" id="steps"></div></div>'+
    '</div>';
  retypeMath(host);
  host.__state=s;

  var sel=host.querySelector('#e2-kind'); sel.value=s.rawKind;
  sel.addEventListener('change', function(){
    var h=document.querySelector('#host'); if(h) h.dataset.e2kind=sel.value;
    renderActiveSafe('e2-kind.change');
  });
},


check(host){
  const s = host.__state;

  const a = val('r1').trim(); // u0
  const b = val('r2').trim(); // u1
  const c = val('r3').trim(); // u2
  //const d = val('r4').trim(); // uk

  const ok1 = a==='' ? null : near(parseNumber(a), s.u0);
  const ok2 = b==='' ? null : near(parseNumber(b), s.u1);
  const ok3 = c==='' ? null : near(parseNumber(c), s.u2);
  //const ok4 = c==='' ? null : near(parseNumber(d), s.uk);

  tickTri($('#t1',host), ok1);
  tickTri($('#t2',host), ok2);
  tickTri($('#t3',host), ok3);
  tickTri($('#t4',host), ok4);

  const hasBlank = (a==='' || b==='' || c==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    return ok;
  }
  return false;
},

  /* === √âtapes === */
  _stepsFor:function(s, i){
  var L=[], ul="u_{"+i+"}", ulm1="u_{"+(i-1)+"}";
  var prev = s.seq[i-1];
  var pq   = (s.Qseq && s.Qseq[i-1]) ? s.Qseq[i-1] : {n:prev,d:1};

  var self=this;
  function numTex(x){ return String(x).replace(/-/g,'‚àí'); }
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){var t=a%b;a=b;b=t} return a||1; }

  // fraction r√©duite -> {tex,neg} ; si d=1 on renvoie l'entier (pas "‚Ä¶/1")
  function fracToTex(n,d){
    if(d<0){ n=-n; d=-d; }
    var g=gcd(n,d); n/=g; d/=g;
    if(d===1) return { tex:numTex(n), neg:(n<0) };
    var core="\\dfrac{"+Math.abs(n)+"}{"+d+"}";
    return { tex:(n<0?"‚àí"+core:core), neg:(n<0) };
  }
  function parIfNeg(fr){ return fr.neg ? "\\left("+fr.tex+"\\right)" : fr.tex; }

  // coef * valeur, en masquant 1 et -1 ; parenth√®se si valeur n√©gative
  function timesCoeff(A, frObj){
    const inside = parIfNeg(frObj);
    if(A===1)  return inside;
    if(A===-1) return "‚àí"+inside;
    return A+" \\times "+inside;
  }

  L.push(ul+" = "+s.desc.showVar(ulm1));

  if(s.kind==='inverse'){
    const FR = fracToTex(pq.n,pq.d);
    L.push(ul+" = \\dfrac{1}{"+parIfNeg(FR)+"}");
    const S = self._simp(pq.d,pq.n);
    L.push(ul+" = "+self._fmtIntOrFrac(S.n,S.d));
  }
  else if(s.kind==='homographique'){
    const P=s.desc.params, FR=fracToTex(pq.n,pq.d);
    const top = timesCoeff(P.a,FR) + (P.b? (P.b<0?' ‚àí '+Math.abs(P.b):' + '+P.b):'');
    const bot = timesCoeff(P.c,FR) + (P.d? (P.d<0?' ‚àí '+Math.abs(P.d):' + '+P.d):'');
    L.push(ul+" = \\dfrac{"+top+"}{"+bot+"}");

    const N=P.a*pq.n + P.b*pq.d, D=P.c*pq.n + P.d*pq.d;
    L.push(ul+" = "+self._fmtIntOrFrac(N,D));
    const S2=self._simp(N,D);
    if(S2.n!==N || S2.d!==D) L.push(ul+" = "+self._fmtIntOrFrac(S2.n,S2.d));
  }
  else if(s.kind==='racine' && s.desc.params && 'b' in s.desc.params){
    var b=s.desc.params.b, sign=(b<0?' ‚àí '+Math.abs(b):' + '+b);
    L.push(ul+" = \\sqrt{("+numTex(prev)+sign+")^{2}}");
    var sum = prev + b;
    L.push(ul+" = \\left|"+numTex(sum)+"\\right|");
    L.push(ul+" = "+Math.abs(sum));
  }
  else{
    // autres types : showNum g√®re d√©j√† les cas ¬±1 correctement (voir patch B)
    L.push(ul+" = "+s.desc.showNum(prev));
    L.push(ul+" = "+numTex(s.seq[i]));
  }

  return this._dedup(L);
},


  solution:function(host){
  var s=host.__state, W=document.querySelector('#steps');

  // Fabrique les colonnes (u1, u2) et le bloc (b) via _stepsFor
  var col1 = '<div class="steps">'+this._stepsFor(s,1,s.u0).map(function(t){return '<div class="step">\\('+t+'\\)</div>';}).join('')+'</div>';
  var col2 = '<div class="steps">'+this._stepsFor(s,2,s.u1).map(function(t){return '<div class="step">\\('+t+'\\)</div>';}).join('')+'</div>';

  // (b) ‚Äî on affiche TOUT le calcul de u_k (jamais un nombre d√©cimal)
  var prevK = s.seq[s.kIndex-1];
  var bK = '<div class="steps">'+this._stepsFor(s, s.kIndex, prevK).map(function(t){return '<div class="step">\\('+t+'\\)</div>';}).join('')+'</div>';

  W.innerHTML =
    '<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">'+
      '<div class="steps"><div class="step">\\(u_0='+s.u0+'\\)</div></div>'+
      col1 + col2 +
    '</div>'
	//+ bK;
  retypeMath(W);

  // -------- Auto-remplissage des champs en entier OU fraction "a/b" (jamais de d√©cimal) --------
  var self=this;
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ var t=a%b; a=b; b=t; } return a||1; }
  function asFracStr(n,d){
    if(d===0) return '';        // ind√©fini : on ne remplit pas
    if(d<0){ n=-n; d=-d; }
    var g=gcd(n,d); n/=g; d/=g;
    return (d===1)? String(n) : ((n<0?'-':'')+Math.abs(n)+'/'+d);
  }
  function valueStringAt(index){   // index = 0..k
    // u0 est un entier affichable tel quel
    if(index===0) return String(s.u0);

    if(s.kind==='inverse'){
      var prev = s.seq[index-1];
      if(prev===0) return ''; // ind√©fini
      return asFracStr(1, prev);
    }
    if(s.kind==='homographique'){
      var prev = s.seq[index-1], P=s.desc.params;
      var N=P.a*prev + P.b, D=P.c*prev + P.d;
      if(D===0) return ''; // ind√©fini
      return asFracStr(N, D);
    }
    // racine & autres : c'est un entier dans notre g√©n√©ration
    return String(s.seq[index]);
  }


}

});

/* === Ex. 3 ‚Äî u_{n+2} = a u_{n+1} + b u_n (u2..u4) === */
L.push({
  id:'ex3_recurrence_2',
  title:"Ex. 3 ‚Äî Suite r√©currente d‚Äôordre 2",
  gen(){
    // Compteur pour forcer Fibonacci tous les 5 tirages
    window.__ex3_count = (window.__ex3_count||0) + 1;
    const forceFibo = (window.__ex3_count % 5 === 0);

    // tirage (a,b)
    let a = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let b = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
   

    // init u0,u1
    let u0 = rint(-5,5), u1 = rint(-5,5);

    // Cas Fibonacci
    let fibo = false;
    if(forceFibo){
      a = 1; b = 1; u0 = 0; u1 = 1; fibo = true;
    }

    // √âcriture LaTeX de la relation (sans "1" ni "‚àí1" affich√©s)
    const UMINUS = '‚àí';
    const t = (x)=> String(x).replace(/-/g,UMINUS);
    const term = (coef, lab)=> {
      if(coef===0) return '';
      if(coef===1)  return lab;
      if(coef===-1) return UMINUS + lab;
      return (coef<0? UMINUS : '') + '{'+Math.abs(coef)+'}'+lab;
    };
    let left = term(a,'u_{n+1}');
    if(b){
      left += (b<0? ' '+UMINUS+' ' : ' + ')
            + (Math.abs(b)===1 ? 'u_n' : '{'+Math.abs(b)+'}u_n');
    }
    if(!left) left = '0';
    const fLatex = `u_{n+2} = ${left}`;

    // progression
    const step = (x,y)=> a*y + b*x; // (u_n, u_{n+1}) -> u_{n+2}
    const seq=[u0,u1];
    for(let k=0;k<3;k++) seq.push(step(seq[seq.length-2], seq[seq.length-1]));
    const [u2,u3,u4] = seq.slice(2);

    return {a,b,u0,u1,fLatex,u2,u3,u4,fibo};
  },

  render(host,s){
    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Soit la suite \\((u_n)\\) d√©finie par
            \\[ u_0=${s.u0},\\quad u_1=${s.u1},\\qquad ${s.fLatex} \\]
            ${s.fibo?'<br><span class="hint">Il s‚Äôagit de la <b>suite de Fibonacci</b>.</span>':''}
          </p>
          <p>D√©terminer \\(u_2, u_3, u_4\\).<br>
             \\(u_2=\\) ${mkInput('a',90)} <span id="t1" class="tick"></span> &nbsp;
             \\(u_3=\\) ${mkInput('b',90)} <span id="t2" class="tick"></span> &nbsp;
             \\(u_4=\\) ${mkInput('c',90)} <span id="t3" class="tick"></span>
          </p>
		          <div class="equ-offscreen" style="display:none">
 <p>Soit la suite \\((u_n)\\) d√©finie par
            \\[ u_0=${s.u0},\\quad u_1=${s.u1},\\qquad ${s.fLatex} \\] 
          </p>
          <p>D√©terminer \\(u_2, u_3, u_4\\)</p>
                </div>
        </div>
        <div><div class="steps" id="steps"></div></div>
      </div>`;
    retypeMath(host);
    host.__state = s;
  },

  check(host){
  const s = host.__state;

  const a = val('a').trim(); // u2
  const b = val('b').trim(); // u3
  const c = val('c').trim(); // u4

  const ok1 = a==='' ? null : near(parseNumber(a), s.u2);
  const ok2 = b==='' ? null : near(parseNumber(b), s.u3);
  const ok3 = c==='' ? null : near(parseNumber(c), s.u4);

  tickTri($('#t1',host), ok1);
  tickTri($('#t2',host), ok2);
  tickTri($('#t3',host), ok3);

  const hasBlank = (a==='' || b==='' || c==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    return ok;
  }
  return false;
},

  solution(host){
  const s=host.__state;
  const UMINUS = '‚àí';
  const num = x => String(x).replace(/-/g,UMINUS);
  const par = x => x<0 ? `\\left(${num(x)}\\right)` : num(x);

  // --- helpers ---
  // Affiche A¬∑x en t√™te (isHead=true) ou en second terme (isHead=false),
  // en MASQUANT 1 et ‚àí1, et en √©crivant correctement les signes.
  function timesShow(A, x, isHead){
    if (A===0 || x===0) return '';                      // on laissera sumShow g√©rer le "0" global
    const n = num(x), absN = num(Math.abs(x));

    if (isHead){
      if (A===1)  return n;                             // ex: "1" ou "‚àí3"
      if (A===-1) return (x<0 ? absN : '‚àí'+n);          // ‚àí(‚àí3) devient +3 en t√™te
      // A ‚â† ¬±1
      return (A<0? '‚àí' : '') + `${Math.abs(A)} \\times ${par(x)}`;
    } else {
      if (A===1)  return (x<0 ? ' ‚àí '+absN : ' + '+n);  // +x ou ‚àí|x|
      if (A===-1) return (x<0 ? ' + '+absN : ' ‚àí '+n);  // ‚àíx ; si x<0 ‚Üí +|x|
      // A ‚â† ¬±1
      return (A<0? ' ‚àí ' : ' + ') + `${Math.abs(A)} \\times ${par(x)}`;
    }
  }

  // Construit "A*x + B*y" proprement (pas de "0 + ‚Ä¶", pas de "+ 0")
  function sumShow(A, xa, B, xb){
    const zeroA = (A===0 || xa===0);
    const zeroB = (B===0 || xb===0);
    if (zeroA && zeroB) return '0';
    if (zeroA)          return (timesShow(B, xb, true) || '0');
    let s  = timesShow(A, xa, true);
    if (!zeroB) s += timesShow(B, xb, false);
    return s.replace(/^\s*\+\s*/,'') || '0';
  }

  // "a u_{k}+ b u_{k-1}" (symbole, sans 1 ni ‚àí1)
  function symShow(a,b,lab1,lab0){
    const head = (a===0)? '' : (a===1? lab1 : (a===-1? UMINUS+lab1 : (a<0? UMINUS : '')+'{'+Math.abs(a)+'}'+lab1));
    let tail='';
    if(b){
      tail = (b<0? ' '+UMINUS+' ' : ' + ')
           + (Math.abs(b)===1 ? lab0 : '{'+Math.abs(b)+'}'+lab0);
    }
    const s = (head + tail).replace(/^\s*\+\s*/,'');
    return s || '0';
  }

  // d√©doublonnage simple (m√™me ligne affich√©e deux fois ‚Üí une seule)
  function dedup(arr){
    const out=[]; let prev='';
    const norm = t => String(t).replace(/\s+/g,' ').replace(/[‚àí‚Äì‚Äî]/g,'-').trim();
    for(const L of arr){
      if(!L) continue;
      const n = norm(L);
      if(n!==prev){ out.push(L); prev=n; }
    }
    return out;
  }

  // colonnes u2, u3, u4
  const cols = [
    {
      sym : `u_{2} = ${symShow(s.a, s.b, 'u_{1}','u_{0}')}`,
      sub : `u_{2} = ${sumShow(s.a, s.u1, s.b, s.u0)}`,
      val : `u_{2} = ${num(s.u2)}`
    },
    {
      sym : `u_{3} = ${symShow(s.a, s.b, 'u_{2}','u_{1}')}`,
      sub : `u_{3} = ${sumShow(s.a, s.u2, s.b, s.u1)}`,
      val : `u_{3} = ${num(s.u3)}`
    },
    {
      sym : `u_{4} = ${symShow(s.a, s.b, 'u_{3}','u_{2}')}`,
      sub : `u_{4} = ${sumShow(s.a, s.u3, s.b, s.u2)}`,
      val : `u_{4} = ${num(s.u4)}`
    },
  ];

  // tableau 3 colonnes avec lignes d√©doublonn√©es
  const html = `
    <div class="sol-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
      ${cols.map(c => {
        const lines = dedup([c.sym, c.sub, c.val]);
        return `
          <div class="steps">
            ${lines.map(t=>`<div class="step">\\(${t}\\)</div>`).join('')}
          </div>`;
      }).join('')}
    </div>`;
  $('#steps',host).innerHTML = html;
  retypeMath(host);

  // auto-fill
}

});


 /* === Ex. 4 ‚Äî Suite d√©finie par une phrase (avec Remarque & solution en tableau) === */
L.push({
  id:'ex4_phrase',
  title:"Ex. 4 ‚Äî Suite d√©finie par une phrase",

  gen(){
  // 35% geo / 35% ari / 30% ag
  const r = Math.random();
  let kind = r < 0.35 ? 'geo' : (r < 0.70 ? 'ari' : 'ag');

  const u0 = rint(-6,6);

  // petit helper de r√©daction
  const plusMoins = (k)=> k<0 ? `en enlevant ${Math.abs(k)}` : `en ajoutant ${k}`;

  if(kind==='geo'){
    let q = choice([-3,-2,-1,2,3,4]); // q ‚â† 0
    const phrase   = `Soit \\((u_n)\\) la suite d√©finie par son premier terme \\(u_0=${u0}\\), et telle qu‚Äôen multipliant un terme par \\(${q}\\), on obtienne le terme suivant.`;
const sgn  = (q < 0 ? '‚àí' : '');
const coef = (Math.abs(q) === 1 ? '' : '{'+Math.abs(q)+'}');
const relation = `u_{n+1}=${sgn}${coef}\\,u_n`;    
const remark   = `On appelle \\((u_n)\\) une <b>suite g√©om√©trique</b> de raison \\(${q}\\) et de premier terme \\(u_0=${u0}\\).`;
    const next = (x)=> q*x;
    return {kind,u0,q,a:null,b:null, phrase, relation, remark, next};
  }

  if(kind==='ari'){
    let r_ = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);  // 0 exclu
    const phrase   = `Soit \\((u_n)\\) la suite d√©finie par son premier terme \\(u_0=${u0}\\), et telle qu‚Äô${plusMoins(r_)} √† un terme, on obtienne le terme suivant.`;
    const relation = `u_{n+1}=u_n${r_<0?` ‚àí ${Math.abs(r_)}`:` + ${r_}`}`;
    const remark   = `On appelle \\((u_n)\\) une <b>suite arithm√©tique</b> de raison \\(${r_}\\) et de premier terme \\(u_0=${u0}\\).`;
    const next = (x)=> x + r_;
    return {kind,u0,q:null,a:null,b:r_, phrase, relation, remark, next};
  }

  // arithm√©tico-g√©om√©trique
let a = choice([-3,-2,-1,2,3]);
let b = rint(-5,5);
const phrase   = `Soit \\((u_n)\\) la suite d√©finie par son premier terme \\(u_0=${u0}\\), et telle qu‚Äôen multipliant un terme par \\(${a}\\) puis ${plusMoins(b)} , on obtienne le terme suivant.`;

// NEW: show the sign for any negative a (not only a===-1)
const sgnA  = (a < 0 ? '‚àí' : '');
const coefA = (Math.abs(a) === 1 ? '' : '{' + Math.abs(a) + '}');
const relation = `u_{n+1}=${sgnA}${coefA}\\,u_n${b ? (b < 0 ? ` ‚àí ${Math.abs(b)}` : ` + ${b}`) : ''}`;

const remark   = `On appelle \\((u_n)\\) une <b>suite arithm√©tico-g√©om√©trique</b>.`;
const next = (x)=> a*x + b;
return {kind,u0,q:null,a,b, phrase, relation, remark, next};

},


  render(host,s){
    // u1,u2,u3 pour l‚Äô√©nonc√©
    const u1 = s.next(s.u0);
    const u2 = s.next(u1);
    const u3 = s.next(u2);
    host.__state = Object.assign({}, s, {u1,u2,u3});

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>${s.phrase}</p>
          <p>a) D√©terminer les termes \\(u_1, u_2\\) et \\(u_3\\).</p>
          <p>b) Donner une relation reliant \\(u_{n+1}\\) et \\(u_n\\).</p>
          <p class="hint" style="margin-top:.5rem"><strong>Remarque :</strong> ${s.remark}</p>

          <p style="margin-top:10px">
            \\(u_1=\\) ${mkInput('p1',90)} <span id="t1" class="tick"></span> &nbsp;
            \\(u_2=\\) ${mkInput('p2',90)} <span id="t2" class="tick"></span> &nbsp;
            \\(u_3=\\) ${mkInput('p3',90)} <span id="t3" class="tick"></span>
          </p>
          <p>
            Relation : ${mkInput('peq',260)} <span id="t4" class="tick"></span>
          </p>
		  <div class="equ-offscreen" style="display:none">
<p>${s.phrase}</p>
          <p>a) D√©terminer les termes \\(u_1, u_2\\) et \\(u_3\\).</p>
          <p>b) Donner une relation reliant \\(u_{n+1}\\) et \\(u_n\\).</p>
                </div>
        </div>
        <div><div class="steps" id="steps"></div></div>
      </div>`;
    retypeMath(host);
  },

  check(host){
  const s = host.__state;

  // helper pour tick tri-√©tat (true/false/null)
  function setTick(el, state){
    if(!el) return;
    el.classList.remove('ok','ko');
    if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
    else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
    else { el.textContent=''; } // neutre si champ vide
  }

  // --- valeurs saisies
  const r1 = val('p1').trim(), r2 = val('p2').trim(), r3 = val('p3').trim(), req = val('peq').trim();

  // --- tests num√©riques (ne teste que si rempli)
  const ok1 = r1==='' ? null : near(parseNumber(r1), s.u1);
  const ok2 = r2==='' ? null : near(parseNumber(r2), s.u2);
  const ok3 = r3==='' ? null : near(parseNumber(r3), s.u3);

  // --- test relation (tol√©rant aux √©critures demand√©es)
  const target = normRelation(s.relation);
  const user   = req==='' ? '' : normRelation(req);
  const ok4    = req==='' ? null : (user === target);

  // --- ticks
  setTick($('#t1',host), ok1);
  setTick($('#t2',host), ok2);
  setTick($('#t3',host), ok3);
  setTick($('#t4',host), ok4);

  // --- score : on ne touche PAS au score s'il reste des champs vides
  const hasBlank = (r1==='' || r2==='' || r3==='' || req==='');
  if(!hasBlank){
    const ok = (!!ok1) && (!!ok2) && (!!ok3) && (!!ok4);
    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
  }
  return (!hasBlank) && (!!ok1) && (!!ok2) && (!!ok3) && (!!ok4);
},


  solution(host){
  const s = host.__state;
  const UMINUS='‚àí';
  const num = x => String(x).replace(/-/g, UMINUS);
  const par = x => x<0 ? `\\left(${num(x)}\\right)` : num(x);

  // ---- helpers produits (pour les termes "en u") ----
  function prodHead(A, x){
    if (A===0 || x===0) return '0';
    if (A===1)  return num(x);
    if (A===-1) return (x<0 ? num(Math.abs(x)) : UMINUS+num(x)); // ‚àíx ; si x<0 ‚Üí +|x| en t√™te
    return (A<0? UMINUS : '') + `${Math.abs(A)} \\times ${par(x)}`;
  }
  function prodTail(A, x){
    if (A===0 || x===0) return '';
    if (A===1)  return (x<0 ? ` ‚àí ${num(Math.abs(x))}` : ` + ${num(x)}`);
    if (A===-1) return (x<0 ? ` + ${num(Math.abs(x))}` : ` ‚àí ${num(x)}`);
    return (A<0? ' ‚àí ' : ' + ') + `${Math.abs(A)} \\times ${par(x)}`;
  }

  // ---- helpers pour les constantes (plus jamais "√ó 1") ----
  const headConst = B => (B<0 ? `‚àí${Math.abs(B)}` : String(B));
  const tailConst = B => (B<0 ? ` ‚àí ${Math.abs(B)}` : ` + ${B}`);

  // Somme A*x + B*(constante). Si isConstB=true, on traite B comme un PUR nombre.
  function sumShow(A, xa, B, xb, isConstB){
    const zA = (A===0 || xa===0);
    const zB = (B===0 || (isConstB ? false : xb===0));

    if (zA && zB) return '0';
    if (zA) return isConstB ? headConst(B) : prodHead(B, xb);

    let s = prodHead(A, xa);
    if (!zB) s += isConstB ? tailConst(B) : prodTail(B, xb);
    return s.replace(/^\s*\+\s*/,'') || '0';
  }

  // ---- lignes symboliques instanci√©es u1/u2/u3 ----
  const coefU = (A, lab) => (
    A===0 ? '0' :
    A===1 ? lab :
    A===-1 ? UMINUS+lab :
    (A<0? UMINUS:'') + Math.abs(A) + lab
  );
  const symGeo = (q,k)=> `u_{${k}} = ${coefU(q, 'u_{'+(k-1)+'}')}`;
  const symAri = (r,k)=> `u_{${k}} = u_{${k-1}}${r? (r<0?` ${UMINUS} ${Math.abs(r)}`:` + ${r}`):''}`.replace(/\+\s*$/,'');
  const symAG  = (a,b,k)=> {
    let left = (a===0)? '' : coefU(a, 'u_{'+(k-1)+'}');
    if (b) left += (b<0? ` ${UMINUS} ${Math.abs(b)}` : ` + ${b}`);
    return `u_{${k}} = ${left || '0'}`;
  };

  // ---- construit les 3 colonnes (u1,u2,u3) ----
  const u=[s.u0,s.u1,s.u2,s.u3];
  const steps=[];
  if(s.kind==='geo'){
    for(let k=1;k<=3;k++){
      steps.push([
        symGeo(s.q,k),
        `u_{${k}} = ${prodHead(s.q, u[k-1])}`,
        `u_{${k}} = ${num(u[k])}`
      ]);
    }
  }else if(s.kind==='ari'){
    for(let k=1;k<=3;k++){
      steps.push([
        symAri(s.b,k),
        `u_{${k}} = ${sumShow(1, u[k-1], s.b, 1, true)}`, // ‚Üê b trait√© comme constante
        `u_{${k}} = ${num(u[k])}`
      ]);
    }
  }else{ // arithm√©tico-g√©om√©trique
    for(let k=1;k<=3;k++){
      steps.push([
        symAG(s.a,s.b,k),
        `u_{${k}} = ${sumShow(s.a, u[k-1], s.b, 1, true)}`, // ‚Üê b constant (pas de √ó1)
        `u_{${k}} = ${num(u[k])}`
      ]);
    }
  }

  // d√©doublonnage doux
  function dedup(col){
    const out=[]; let prev='';
    const norm=t=>String(t).replace(/\s+/g,' ').replace(/[‚àí‚Äì‚Äî]/g,'-').trim();
    for(const L of col){ if(!L) continue; const n=norm(L); if(n!==prev){ out.push(L); prev=n; } }
    return out;
  }

  const html = `
    <div class="sol-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px">
      ${steps.map(col=>{
        const lines = dedup(col);
        return `<div class="steps">${lines.map(t=>`<div class="step">\\(${t}\\)</div>`).join('')}</div>`;
      }).join('')}
    </div>
    <div class="steps" style="margin-top:8px">
      <div class="step">\\(\\text{Relation : } ${s.relation}\\)</div>
    </div>`;
  $('#steps',host).innerHTML = html;
  retypeMath(host);

  // auto-fill
}


});


  return L;
}

/* ===== REGISTRY & UI (m√™mes hooks que ton mod√®le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // Entr√©e => V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d‚Äôaffichage :</b> ${e.message}<br>Ouvre la console pour le d√©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit pr√™t et que le kit soit charg√©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: 'Premi√®re ‚Äî Suites num√©riques',
        max: 50,
        // Monte l'UI PDF juste apr√®s ta carte "Saisie & r√©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte d‚Äôamorce par type (affich√© avant chaque exo dans le PDF)
                // Optionnel : laisse √† false pour ne pas lancer l‚Äôimpression automatiquement
        autoPrint: false
      });
    } else {
      // r√©essaie bri√®vement si le kit ou REGISTRY n‚Äôest pas encore pr√™ts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui √©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas r√©f√©rencer ok4 si la Q(b) est comment√©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un √©ventuel tick fant√¥me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit s‚Äô√©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
