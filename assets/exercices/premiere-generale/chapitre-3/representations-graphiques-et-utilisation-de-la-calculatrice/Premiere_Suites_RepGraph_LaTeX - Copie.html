<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Première — Suites numériques — Représentation graphique (version LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{padding:.5rem .7rem;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.controls .btn:hover{background:#f7f7f7}
.controls select{padding:.4rem .5rem;border:1px solid #ddd;border-radius:8px;background:#fff}
.controls input[type="number"]{width:64px;padding:.35rem .45rem;border:1px solid #ddd;border-radius:8px}
.score{font-weight:700}
.small{font-size:.92rem;color:#666}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
/* Boîte grisée de correction (sans sous-divs) */
#host #res.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
#host #res.steps p{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;user-select:none}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chip.active{ border-color:#222; background:#eef }
svg text{pointer-events:none}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }

/* Ticks de validation */
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

/* Inputs inline */
.perline{display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center}
.expr{cursor:pointer}
.expr.focus{background:#fff3;border:1px solid #bbb;border-radius:8px}

.badge{display:inline-block;padding:.08rem .5rem;border-radius:999px;border:1px solid #ddd;background:#f9f9f9;font-size:.82rem}

/* Listes déroulantes */
select.slim{padding:.28rem .5rem;border:1px solid #ddd;border-radius:8px;background:#fff}

/* Axes labels style */
.labelC{font-size:12px;fill:#0a84ff}
.labelD{font-size:12px;fill:#333}
</style>

<!-- MathJax v3 (LaTeX inline \\( ... \\) only) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <!-- DevRules in inputs-only mode -->
  <script>window.DEVRULES_MODE='inputs-only';</script>
  <script src="../../../../js/dev-rules-clean.dedup.vB.inputs-only.js" defer></script>
  <script src="../../../../js/math-kbd.js" defer></script>
  <script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
  <script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Première – <strong>Suites numériques</strong> — Représentation graphique</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
      <span id="status" class="small"></span>
    </div>

    <!-- Amplitude globale -->
    <div class="controls card" id="ampbar">
      <strong>Amplitude du repère (globale)</strong>
      <label>x ∈ [ <input type="number" id="xmin" value="-2"> ; <input type="number" id="xmax" value="8"> ]</label>
      <label>y ∈ [ <input type="number" id="ymin" value="-2"> ; <input type="number" id="ymax" value="8"> ]</label>
      <button class="btn" id="amp-apply">Appliquer</button>
      <span class="small">(utilisée pour tout nouvel énoncé)</span>
    </div>

    <div id="host" class="card"></div>

    <div class="card kbd-host hide-print">
      <div><strong>Clavier math</strong> — Utilise les touches pour écrire : \(x^2\), \(\sqrt{x}\), fractions <code>a/b</code>…</div>
      <div class="kbd"></div>
    </div>
	
	   <!-- Bloc "Saisie & réponses acceptées" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & réponses acceptées :</strong>
      <ul>
       </ul>
    </div>
  </div>

<script>
(function(){'use strict';

/* ============ Utils ============ */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const UMINUS='−'; // pour l'affichage "texte" des axes/labels SVG uniquement
function uminusStr(n){ return (n<0?UMINUS:'')+String(Math.abs(n)); }

function MJ(host){ try{ if(window.MathJax && MathJax.typesetPromise){ MathJax.typesetPromise([host]).catch(()=>{}); } }catch(e){} }

/* Amplitude par défaut */
let AMP={ xmin:-2, xmax:8, ymin:-2, ymax:8 };

/* ============ REPÈRE ============ */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.points=[]; this.user=[]; this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const s=document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
    const defs=document.createElementNS(s.namespaceURI,'defs');
    const marker=document.createElementNS(s.namespaceURI,'marker');
    marker.setAttribute('id','arrow'); marker.setAttribute('orient','auto');
    marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8');
    marker.setAttribute('refX','0'); marker.setAttribute('refY','3');
    const path=document.createElementNS(s.namespaceURI,'path');
    path.setAttribute('d','M0,0 L0,6 L8,3 z'); path.setAttribute('fill','#000');
    marker.appendChild(path); defs.appendChild(marker); s.appendChild(defs);
    this.gGrid=document.createElementNS(s.namespaceURI,'g');
    this.gAxes=document.createElementNS(s.namespaceURI,'g');
    this.gPts=document.createElementNS(s.namespaceURI,'g');
    this.gUser=document.createElementNS(s.namespaceURI,'g');
    [this.gGrid,this.gAxes,this.gPts,this.gUser].forEach(g=>s.appendChild(g));

    // clic (précis, sans arrondi)
    s.addEventListener('click', ev=>{
      if(!this.clickable||!this.onClick) return;
      const r=s.getBoundingClientRect(), X=ev.clientX-r.left, Y=ev.clientY-r.top;
      const c=this.screenToCoord(X,Y);
      this.onClick({x:c.x,y:c.y});
    });
    return s;
  }
  innerLimits(){ return { xmin:this.R.xmin+1, xmax:this.R.xmax-1, ymin:this.R.ymin+1, ymax:this.R.ymax-1 }; }
  set(R){ this.R={...this.R,...R}; this.redraw(); }
  coordToScreen(x,y){
    const R=this.R, w=420, h=420;
    const X = (x-R.xmin)/(R.xmax-R.xmin)*w;
    const Y = h - (y-R.ymin)/(R.ymin< this.R.ymax ? (R.ymax-R.ymin) : 1)*h;
    return {x:X,y:Y};
  }
  screenToCoord(X,Y){
    const R=this.R, w=420, h=420;
    const x = R.xmin + X/w*(R.xmax-R.xmin);
    const y = R.ymin + (h-Y)/h*(R.ymax-R.ymin);
    return {x,y};
  }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){
      g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','11'); t.setAttribute('fill',color); t.textContent=label;
      g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g);
    }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
    t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }
drawGivenLine(id,color,pts){
  let L=this.gPts.querySelector(`line[data-id="${id}"]`);
  if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.gPts.appendChild(L); }
  const a=this.coordToScreen(pts[0].x,pts[0].y), b=this.coordToScreen(pts[1].x,pts[1].y);
  L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
  L.setAttribute('stroke',color||'#000'); L.setAttribute('stroke-width','3');
  return L; // ⬅️ ajouté
}

drawUserLine(id,color,pts){
  let L=this.gUser.querySelector(`line[data-id="${id}"]`);
  if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.gUser.appendChild(L); }
  const a=this.coordToScreen(pts[0].x,pts[0].y), b=this.coordToScreen(pts[1].x,pts[1].y);
  L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
  L.setAttribute('stroke',color||'#0a84ff'); L.setAttribute('stroke-width','2.5');
  return L; // ⬅️ ajouté
}

  drawUserInfiniteLine(id,color,P,Q){
    if(P.x===Q.x){
      this.drawUserLine(id,color,[{x:P.x,y:this.R.ymin},{x:P.x,y:this.R.ymax}]);
      return;
    }
    const m=(Q.y-P.y)/(Q.x-P.x), b=P.y - m*P.x;
    const x1=this.R.xmin, y1=m*x1+b;
    const x2=this.R.xmax, y2=m*x2+b;
    this.drawUserLine(id,color,[{x:x1,y:y1},{x:x2,y:y2}]);
  }
  redraw(){
    const R=this.R; this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gPts.innerHTML='';
    const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line'); L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2); L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.5:1); return L; };
    for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
    for(let t=R.ymin;t<=R.ymax;t++){ const q1=this.coordToScreen(R.xmin,t), q2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(q1.x,q1.y,q2.x,q2.y)); }
    const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
    const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
    axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)'); this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);
    // graduations & labels
    for(let t=R.xmin;t<=R.xmax;t++){
      const u=this.coordToScreen(t,(R.ymin+R.ymax)/2+0.15), v=this.coordToScreen(t,(R.ymin+R.ymax)/2-0.15);
      this.gAxes.appendChild(mkLine(u.x,u.y,v.x,v.y));
      if(t!==0 && t!==1){ const tx=document.createElementNS(this.el.namespaceURI,'text'); tx.setAttribute('x',this.coordToScreen(t,0).x+3); tx.setAttribute('y',this.coordToScreen(0,0).y+12); tx.setAttribute('font-size','11'); tx.textContent=uminusStr(t); this.gAxes.appendChild(tx); }
    }
    for(let t=R.ymin;t<=R.ymax;t++){
      const u=this.coordToScreen((R.xmin+R.xmax)/2+0.15,t), v=this.coordToScreen((R.xmin+R.xmax)/2-0.15,t);
      this.gAxes.appendChild(mkLine(u.x,u.y,v.x,v.y));
      if(t!==0 && t!==1){ const ty=document.createElementNS(this.el.namespaceURI,'text'); ty.setAttribute('x',this.coordToScreen(0,0).x-18); ty.setAttribute('y',this.coordToScreen(0,t).y+4); ty.setAttribute('font-size','11'); ty.textContent=uminusStr(t); this.gAxes.appendChild(ty); }
    }
    // O, I, J
    const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
    const mkTxt=(pt,label)=>{ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',pt.x+6); t.setAttribute('y',pt.y-6); t.setAttribute('font-size','12'); t.textContent=label; return t; };
    const mkPt=(pt)=>{ const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',pt.x); c.setAttribute('cy',pt.y); c.setAttribute('r','3.5'); c.setAttribute('fill','#000'); return c; };
    this.gAxes.appendChild(mkPt(O)); this.gAxes.appendChild(mkTxt(O,'O'));
    this.gAxes.appendChild(mkPt(I)); this.gAxes.appendChild(mkTxt(I,'I'));
    this.gAxes.appendChild(mkPt(J)); this.gAxes.appendChild(mkTxt(J,'J'));
  }
}

/* Helpers DOM */
function renderWithRepere(host,opts){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const left=document.createElement('div'); const right=document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);
  const rep=new Repere(opts.R||AMP,{}); left.appendChild(rep.el);
  const equ=document.createElement('div'); equ.className='equ'; right.appendChild(equ);
  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  return {rep,left,right,equ,actions,res};
}
function mkInput(id,w=120,ph=''){ return `<input id="${id}" style="width:${w}px" placeholder="${ph}">`; }
function setVal(host,id,val){ const i=$('#'+id,host); if(i) i.value=val; }
function getVal(host,id){ const i=$('#'+id,host); return i ? String(i.value||'').trim() : ''; }

/* Amplitude */
function applyAMPInputs(){
  AMP.xmin = clamp(parseInt($('#xmin').value||-2,10), -12, 12);
  AMP.xmax = clamp(parseInt($('#xmax').value|| 8,10), -12, 12);
  AMP.ymin = clamp(parseInt($('#ymin').value||-2,10), -12, 12);
  AMP.ymax = clamp(parseInt($('#ymax').value|| 8,10), -12, 12);
  if(AMP.xmin>=AMP.xmax) AMP.xmax=AMP.xmin+1;
  if(AMP.ymin>=AMP.ymax) AMP.ymax=AMP.ymin+1;
  buildOne();
}
function derivAt(f,x){ const h=1e-4;
  const a=f(x+h), b=f(x-h);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return NaN;
  return (a-b)/(2*h);
}

/* ============ GÉNÉRATEURS f(x) ============ */
function families(){
  const F=[];

  // 1) f(x) = sqrt(2x + k) avec point fixe entier s = 1 + m
  F.push({
    id:'sqrt',
    toLatex:(p,k)=> (p===1?`\\sqrt{x ${k>=0?`+ ${k}`:`${UMINUS}${Math.abs(k)}`}}` : `\\sqrt{${p}x ${k>=0?`+ ${k}`:`${UMINUS}${Math.abs(k)}`}}`),
    make(R){
      const RX={ xmin:-1, xmax:8, ymin:-1, ymax:8 };
      const m = rnd(2,4);        // s = 1+m ∈ {3,4,5}
      const p = 2;
      const k = m*m - 1;         // Δ=4m^2 → racine entière
      const s = 1 + m;           // point fixe entier
      const f = x => Math.sqrt(Math.max(0, p*x + k));
      return { f, R:RX, params:{p,k}, fixed:s, poles:[] };
    }
  });

  // 2) f(x) = (a x + b)/(x + d) avec point fixe entier s
  F.push({
    id:'homo1',
    toLatex:(a,b,d)=>`\\dfrac{${a}x ${b>=0?`+ ${b}`:`${UMINUS}${Math.abs(b)}`} }{x ${d>=0?`+ ${d}`:`${UMINUS}${Math.abs(d)}`}}`,
    make(R){
      const RX={ xmin:-1, xmax:6, ymin:-1, ymax:6 };
      const a = rnd(1,3), d = rnd(2,5);
      // choisir un s entier dans la fenêtre, s ≠ -d
      let s = rnd(RX.xmin+1, RX.xmax-1);
      if(s===-d) s += 1;
      // imposer s fixe : x^2 + (d-a)x - b = 0 → b = -(s^2 + (d-a)s)
      const b = - (s*s + (d - a)*s);
      const f = x => (x===-d? NaN : (a*x + b)/(x + d));
      return { f, R:RX, params:{a,b,d}, fixed:s, poles:[-d] };
    }
  });

  // 3) f(x) = A − B/(x + E) avec point fixe entier s
  F.push({
    id:'a_minus_b_over',
    toLatex:(A,B,E)=>`${A} ${UMINUS} \\dfrac{${B}}{x ${E>=0?`+ ${E}`:`${UMINUS}${Math.abs(E)}`}}`,
    make(R){
      const RX={ xmin:-2, xmax:8, ymin:-2, ymax:8 };
      const A=rnd(3,6), E=rnd(1,3);
      let s = rnd(RX.xmin+1, RX.xmax-1);
      if(s===-E) s += 1;
      // x^2 + (E-A)x + (B - AE) = 0 → B = AE - s^2 - (E-A)s
      const B = A*E - s*s - (E - A)*s;
      const f = x => (x===-E? NaN : A - B/(x + E));
      return { f, R:RX, params:{A,B,E}, fixed:s, poles:[-E] };
    }
  });

  // 4) f(x) = x/(x^2 + 1), point fixe entier s = 0
  F.push({
    id:'x_over_x2p1',
    toLatex:()=>`\\dfrac{x}{x^2 + 1}`,
    make(R){
      const RX={ xmin:-1, xmax:2, ymin:-0.5, ymax:1.5 };
      const f = x=> x/(x*x + 1);
      const s = 0;
      return { f, R:RX, params:{}, fixed:s, poles:[] };
    }
  });

  // 5) f(x) = (m x + p)/(q x + r) avec point fixe entier s
  F.push({
    id:'homo2',
    toLatex:(m,p,q,r)=>`\\dfrac{${m}x ${p>=0?`+ ${p}`:`${UMINUS}${Math.abs(p)}`} }{${q}x ${r>=0?`+ ${r}`:`${UMINUS}${Math.abs(r)}`}}`,
    make(R){
      const RX={ xmin:-1, xmax:6, ymin:-1, ymax:6 };
      const m=rnd(1,3), q=rnd(1,2), r=rnd(3,6);
      let s = rnd(RX.xmin+1, RX.xmax-1);
      if(q*s + r === 0) s += 1;
      // qx^2 + (r-m)x - p = 0 → p = - (q s^2 + (r-m)s)
      const p = - (q*s*s + (r - m)*s);
      const f = x => (Math.abs(q*x + r)<1e-9? NaN : (m*x + p)/(q*x + r));
      return { f, R:RX, params:{m,p,q,r}, fixed:s, poles:[-r/q] };
    }
  });

  return F;
}


/* Dessin d’une fonction continue par morceaux */
function drawFunction(rep, f, color='#0a84ff'){
  const R=rep.R, W=320;
  let pathD='';
  let penUp=true;
  for(let i=0;i<=W;i++){
    const x = R.xmin + (i/W)*(R.xmax-R.xmin);
    let y = f(x);
    if(!Number.isFinite(y) || isNaN(y)) { penUp=true; continue; }
    if(y<R.ymin-1 || y>R.ymax+1){ penUp=true; continue; }
    const p = rep.coordToScreen(x,y);
    pathD += (penUp?`M${p.x.toFixed(2)},${p.y.toFixed(2)} `:`L${p.x.toFixed(2)},${p.y.toFixed(2)} `);
    penUp=false;
  }
  const path=document.createElementNS(rep.el.namespaceURI,'path');
  path.setAttribute('d',pathD.trim());
  path.setAttribute('fill','none'); path.setAttribute('stroke',color); path.setAttribute('stroke-width','2.5');
  rep.gPts.appendChild(path);
  return path;
}

/* ============ Exercices ============ */
function makeExos(){ const L=[];

L.push({
  id:'suite_graph',
  title:'Ex. 1 — Suite définie par \\(u_{n+1}=f(u_n)\\) (représentation graphique)',
  // outils
  _iter(f,u0,k){ const U=[u0]; for(let i=0;i<k;i++){ let u=U[U.length-1]; let v=f(u); if(!Number.isFinite(v)) return null; U.push(v); } return U; },
  _trend(U){ const d1=U[1]-U[0], d2=U[2]-U[1], d3=U[3]-U[2]; const s=[d1,d2,d3]; const allPos=s.every(x=>x>0.0001), allNeg=s.every(x=>x<-0.0001); return allPos?'croissante':allNeg?'décroissante':'ni'; },
  _limit(f,u0){ let u=u0; for(let i=0;i<200;i++){ const v=f(u); if(!Number.isFinite(v)) return {ok:false}; if(Math.abs(v-u)<1e-6) return {ok:true, L:v}; u=v; } return {ok:false}; },
  _fmt(x){ const s = Math.abs(x)<1e-6 ? '0' : (Math.abs(x)>=1000 ? x.toExponential(2).replace('e','\\times 10^{')+'}' : (Math.abs(x)<1e-4? x.toExponential(2).replace('e','\\times 10^{')+'}' : x.toFixed(3).replace(/\.?0+$/,''))); return s; },

  gen(){
  const fams = families();
  const innerMargin = 0.3;                     // garder visible
  const minInitDist = 1.5;                     // |u0 - s| ≥ 1.5
  const minFinalDist = 0.8;                    // |u3 - s| ≥ 0.8
  const slopeMax = 0.95;                       // |f'(s)| ≤ 0.95 ~ contraction douce
  let def=null, tries=0;

  while(tries++<200){
    const F = fams[rnd(0,fams.length-1)];
    const made = F.make({...AMP});
    const R = made.R || AMP;
    const f = made.f, sfix = made.fixed, poles = made.poles||[];

    // sécurité : point fixe entier bien dedans
    if(!(Number.isInteger(sfix) && sfix>=R.xmin+1 && sfix<=R.xmax-1)) continue;

    // point fixe attractif "raisonnable"
    const df = derivAt(f, sfix);
    if(!Number.isFinite(df) || Math.abs(df) > slopeMax) continue;

    // choisir u0 (entier) pas trop près du point fixe, et tel que u3 reste lisible
    let u0 = null, ok=false, guard=0;
    while(guard++<120 && !ok){
      // écarter u0 du point fixe
      const shift = rnd(2,4) * (Math.random()<0.5? -1 : +1);
      const cand = sfix + shift;
      if(cand<=R.xmin+1 || cand>=R.xmax-1) continue;

      // éviter les pôles connus
      if(poles.some(p=>Number.isFinite(p) && Math.abs(cand - p) < 0.2)) continue;

      const U = this._iter(f, cand, 3);
      if(!U) continue;

      // tout dans la fenêtre utile
      const xmin=R.xmin+innerMargin, xmax=R.xmax-innerMargin;
      if(U.some(u=>u<xmin || u>xmax)) continue;

      // éviter les pôles durant l’itération
      if(poles.length && U.some(u=>poles.some(p=>Number.isFinite(p) && Math.abs(u-p)<0.2))) continue;

      // visuel : u3 pas trop proche de la limite (intersection)
      if(Math.abs(U[3] - sfix) < minFinalDist) continue;

      // ok !
      u0 = cand; ok = true;
    }
    if(!ok) continue;

    // On fige la définition
    const U = this._iter(f,u0,3);
    const tr = this._trend(U);
    const lim = this._limit(f,u0);
    def = { Fid:F.id, R, f, u0, U, trend:tr, limit:lim, params:made.params, toLatex:F.toLatex };
    break;
  }

  // repli ultra-sûr (ne devrait pas servir)
  if(!def){
    const R={...AMP}, p=2, k=8, f=(x)=>Math.sqrt(Math.max(0,2*x+8)), u0=2;
    const U=this._iter(f,u0,3);
    def = { Fid:'sqrt', R, f, u0, U, trend:this._trend(U), limit:this._limit(f,u0),
            params:{p,k}, toLatex:(p,k)=>`\\sqrt{${p}x+${k}}` };
  }

  return { R:def.R, kind:def.Fid, params:def.params||{}, u0:def.u0, U:def.U,
           trend:def.trend, limit:def.limit, toLatex:def.toLatex };
},


  render(host,s){
    host.innerHTML=''; const ui=renderWithRepere(host,{R:s.R}); host._ui=ui;
    const rep=ui.rep; rep.set(s.R);
   // Droite D : y = x
const lineD = rep.drawGivenLine('D','#333',[{x:s.R.xmin,y:s.R.xmin},{x:s.R.xmax,y:s.R.xmax}]);
lineD.style.cursor='pointer'; lineD.setAttribute('stroke-linecap','round');

// Courbe C : y = f(x)
const f = buildF(s);
const pathC = drawFunction(rep, f, '#0a84ff');
pathC.style.pointerEvents='stroke';
pathC.style.cursor='pointer';

    // Labels
    const endX = s.R.xmax-0.6;
    const pD = rep.coordToScreen(endX,endX);
    const tD=document.createElementNS(rep.el.namespaceURI,'text'); tD.setAttribute('x',pD.x); tD.setAttribute('y',pD.y-6); tD.setAttribute('class','labelD'); tD.textContent='D : y = x'; rep.gPts.appendChild(tD);
    const pC = rep.coordToScreen(endX, f(endX));
    const tC=document.createElementNS(rep.el.namespaceURI,'text'); tC.setAttribute('x',pC.x); tC.setAttribute('y',pC.y-6); tC.setAttribute('class','labelC'); tC.textContent='C : y = f(x)'; rep.gPts.appendChild(tC);

    // Énoncé (LaTeX)
    const fLatex = s.kind==='sqrt' ? s.toLatex(s.params.p, s.params.k)
                  : s.kind==='homo1' ? s.toLatex(s.params.a, s.params.b, s.params.d)
                  : s.kind==='a_minus_b_over' ? s.toLatex(s.params.A, s.params.B, s.params.E)
                  : s.kind==='x_over_x2p1' ? s.toLatex()
                  : s.kind==='homo2' ? s.toLatex(s.params.m, s.params.p, s.params.q, s.params.r)
                  : 'f(x)';
    ui.equ.innerHTML = `
      <p>On considère la suite \\((u_n)\\) définie par \\(u_{n+1} = f(u_n)\\) avec \\(u_0 = ${s.u0}\\).</p>
      <p>On a tracé la droite \\(D: y = x\\) et la courbe \\(C: y = f(x)\\) où \\(f(x) = ${fLatex}\\).</p>
      <p><span class="badge">Consigne</span> : <strong>placer</strong> sans calcul, sur l’axe des abscisses, les 4 premiers termes \\(u_0, u_1, u_2, u_3\\). Puis <strong>conjecturer</strong> le sens de variation et la convergence.</p>
    `;
    MJ(ui.equ);

    // Actions : clics et champs
    const chips = document.createElement('div'); chips.className='chips';
    chips.innerHTML = ['u₀','u₁','u₂','u₃'].map((lab,i)=>`<span class="chip" id="chip${i}"><span class="dot" style="background:${i? '#0a84ff':'#ef6c00'}"></span>${lab}</span>`).join('');
    const sens = document.createElement('select'); sens.id='sel-sens'; sens.className='slim';
    sens.innerHTML = `<option value="">— sens de variation —</option><option value="croissante">croissante</option><option value="décroissante">décroissante</option><option value="ni">ni l’un ni l’autre</option>`;
    const conv = document.createElement('select'); conv.id='sel-conv'; conv.className='slim';
    conv.innerHTML = `<option value="">— convergence —</option><option value="conv">convergente</option><option value="div">divergente</option>`;
    const lim = document.createElement('input'); lim.id='in-lim'; lim.placeholder='limite (si convergente)'; lim.style.width='160px';
    ui.actions.appendChild(chips); ui.actions.appendChild(sens); ui.actions.appendChild(conv); ui.actions.appendChild(lim);
    const hint = document.createElement('div'); hint.className='hint'; hint.textContent='Clique près de l’axe (y ≈ 0) pour placer u₀, u₁, u₂, u₃ — un 2ᵉ clic sur le même index remplace la valeur.';
    ui.actions.appendChild(hint);

    // --- État de placement & mode ---
host._placed = [null, null, null, null]; // on laisse l'élève placer u0
let nextIndex = 0;                        // 0->u0, 1->u1, 2->u2, 3->u3
let mode = 'place-u0';                    // puis 'curve' / 'diag' / 'done'
let imgPt = null;                         // (u_n, f(u_n)) mémorisé après clic courbe

// puces d’étapes
function updateChips(){
  for(let i=0;i<4;i++){
    const c = $('#chip'+i,host);
    c.classList.toggle('active', i===nextIndex);
  }
}
updateChips();

// message d’aide (réutilise l’élément `hint` créé plus haut)
hint.innerHTML = '1) Clique près de l’axe pour placer \\(u_0\\).<br>'+
                 '2) Pour chaque terme suivant : clique <em>sur la courbe C</em> (verticale pointillée), puis <em>sur la droite D : y=x</em> (horizontale + verticale).';
MJ(hint);


// tolérances
const tolAxisY = 0.6;

// 1) Placement de u0 : clic sur le repère (axe des abscisses)
rep.clickable = true;
rep.onClick = (P)=>{
  if(mode!=='place-u0') return;
  if(Math.abs(P.y) > tolAxisY) return;    // uniquement près de l’axe x
  const x = P.x;
  host._placed[0] = x;
  rep.placeUser('u0', x, 0, '#ef6c00');
  nextIndex = 1;
  mode = 'curve';
  updateChips();
};

// 2) Clic sur la courbe C : trace la verticale pointillée jusqu’à l’image
pathC.addEventListener('click', (ev)=>{
  if(mode!=='curve') return;
  const u_prev = host._placed[nextIndex-1];
  if(typeof u_prev!=='number') return;

  const y = f(u_prev);
  if(!Number.isFinite(y)) return;

  // verticale en pointillés : (u_n,0) -> (u_n,f(u_n))
  const L = rep.drawUserLine(`v-${nextIndex-1}`,'#2e7d32',[{x:u_prev,y:0},{x:u_prev,y:y}]);
  L.setAttribute('stroke-dasharray','6 4');

  imgPt = {x:u_prev, y:y};
  mode = 'diag';
});

// 3) Clic sur la droite D : horizontale vers D puis verticale vers l’axe, place u_{n+1}
lineD.addEventListener('click', (ev)=>{
  if(mode!=='diag' || !imgPt) return;

  const xn1 = imgPt.y; // u_{n+1} = f(u_n)

  // horizontale : (u_n,f(u_n)) -> (f(u_n),f(u_n))
  rep.drawUserLine(`h-${nextIndex-1}`,'#ef6c00',[{x:imgPt.x,y:imgPt.y},{x:xn1,y:xn1}]);

  // verticale : (f(u_n),f(u_n)) -> (f(u_n),0)
  rep.drawUserLine(`vv-${nextIndex-1}`,'#ef6c00',[{x:xn1,y:xn1},{x:xn1,y:0}]);

  // poser u_{n+1} sur l’axe
  rep.placeUser('u'+nextIndex, xn1, 0, '#0a84ff');
  host._placed[nextIndex] = xn1;

  // étape suivante
  nextIndex += 1;
  imgPt = null;
  mode = (nextIndex>=4 ? 'done' : 'curve');
  updateChips();
});


    // Helpers accès
    host.dataset.active=this.id;
    host.dataset.state=JSON.stringify(s);
  },

  correct(host,s){
    const ui = host._ui, rep=ui?.rep;
    const f = buildF(s);
    const U = this._iter(f,s.u0,3);
    const trend = this._trend(U);
    const lim = this._limit(f,s.u0);

    const placed = host._placed || [];
    const tol = Math.max(0.15, (s.R.xmax-s.R.xmin)/80);
    const okPlace = placed.length===4 && placed.every((x,i)=> typeof x==='number' && isFinite(x) && Math.abs(x - U[i]) <= tol );
    const ansSens = $('#sel-sens',host)?.value || '';
    const okSens = ansSens && ansSens===trend;
    const ansConv = $('#sel-conv',host)?.value || '';
    let okConv=false;
    if(ansConv==='div') okConv = !lim.ok;
    if(ansConv==='conv'){
      const v = parseFloat(($('#in-lim',host)?.value||'').replace(',','.'));
      okConv = lim.ok && (Number.isFinite(v) ? Math.abs(v - lim.L) <= Math.max(0.1, (s.R.xmax-s.R.xmin)/60) : true);
    }

    const res = ui.res; res.className='steps'; res.innerHTML='';
    const pf = (x)=> this._fmt(x);
    res.innerHTML += `<p><strong>Placements :</strong> ${okPlace?'<span class="res-ok">OK</span>':'<span class="res-ko">à revoir</span>'} — attendu : \\(u_0=${pf(U[0])}\\), \\(u_1=${pf(U[1])}\\), \\(u_2=${pf(U[2])}\\), \\(u_3=${pf(U[3])}\\).</p>`;
    res.innerHTML += `<p><strong>Sens :</strong> ${okSens?'<span class="res-ok">OK</span>':'<span class="res-ko">non</span>'} — attendu : <em>${trend}</em>.</p>`;
    if(ansConv==='div'){ res.innerHTML += `<p><strong>Convergence :</strong> ${okConv?'<span class="res-ok">OK</span>':'<span class="res-ko">non</span>'} — attendu : <em>divergente</em>.</p>`; }
    else if(ansConv==='conv'){
      res.innerHTML += `<p><strong>Convergence :</strong> ${okConv?'<span class="res-ok">OK</span>':'<span class="res-ko">non</span>'} — attendu : <em>convergente</em>${lim.ok?` vers \\(${pf(lim.L)}\\)`:''}.</p>`;
    } else {
      res.innerHTML += `<p><strong>Convergence :</strong> <span class="res-ko">non renseignée</span>.</p>`;
    }
    MJ(res);
    return { ok: okPlace && okSens && okConv };
  },

  solution(host,s){
    const ui=host._ui, rep=ui?.rep;
    const f = buildF(s);
    const U = this._iter(f, s.u0, 3);
    // Placer u0..u3
    rep.placeUser('u0',U[0],0,'#ef6c00');
    rep.placeUser('u1',U[1],0,'#0a84ff');
    rep.placeUser('u2',U[2],0,'#0a84ff');
    rep.placeUser('u3',U[3],0,'#0a84ff');

    // Escargot (toile d’araignée)
    const steps=[
      [{x:U[0],y:0},{x:U[0],y:f(U[0])}], // vertical
      [{x:U[0],y:f(U[0])},{x:U[1],y:U[1]}], // horizontal
      [{x:U[1],y:0},{x:U[1],y:f(U[1])}],
      [{x:U[1],y:f(U[1])},{x:U[2],y:U[2]}],
      [{x:U[2],y:0},{x:U[2],y:f(U[2])}],
      [{x:U[2],y:f(U[2])},{x:U[3],y:U[3]}],
    ];
    steps.forEach((seg,i)=>rep.drawUserLine('w'+i,'#ef6c00',seg));

    // Texte
    const pf = (x)=> this._fmt(x);
    const res=ui.res; res.className='steps';
    const trend = this._trend(U);
    const lim = this._limit(f, s.u0);
    res.innerHTML = `
      <p>\\(u_1 = f(u_0) \\approx ${pf(U[1])}\\), \\(u_2 = f(u_1) \\approx ${pf(U[2])}\\), \\(u_3 = f(u_2) \\approx ${pf(U[3])}\\).</p>
      <p><strong>Conjecture :</strong> la suite est <em>${trend}</em>${lim.ok?` et semble converger vers \\(\\ell \\approx ${pf(lim.L)}\\)`:` et ne semble pas converger`}. (lecture graphique)</p>
    `;
    MJ(res);
  },

  reset(host){
    const ui=host._ui; if(!ui) return;
    ui.res.textContent='';
    var __ss=$('#sel-sens',host); if(__ss) __ss.selectedIndex = 0;
    var __sc=$('#sel-conv',host); if(__sc) __sc.selectedIndex = 0;
    var __sl=$('#in-lim',host); if(__sl) __sl.value='';
    ui.rep.clearUser();
host._placed = [null, null, null, null];
host._ui.rep.clickable = true;
host._mode = 'place-u0'; // info utile si tu veux l’exposer
// réactive le guidage visuel
const hintEl = $('.hint', host);
 if(hintEl){
   hintEl.innerHTML = '1) Clique près de l’axe pour placer \\(u_0\\).<br>'+
                      '2) Pour chaque terme suivant : clique <em>sur la courbe C</em> (verticale pointillée), puis <em>sur la droite D : y=x</em> (horizontale + verticale).';
   MJ(hintEl);
 }
// Puces
const chipsHost = host.querySelector('.chips');
if(chipsHost){
  chipsHost.querySelectorAll('.chip').forEach(c=>c.classList.remove('active'));
  const c0 = chipsHost.querySelector('#chip0'); if(c0) c0.classList.add('active');
}
}
});

// Construit f(x) à partir de l’état s
function buildF(s){
  if(s.kind==='sqrt'){ const p=s.params.p, k=s.params.k; return (x)=>Math.sqrt(Math.max(0, p*x + k)); }
  if(s.kind==='homo1'){ const {a,b,d}=s.params; return (x)=> (x===-d? NaN : (a*x + b)/(x + d)); }
  if(s.kind==='a_minus_b_over'){ const {A,B,E}=s.params; return (x)=> (x===-E? NaN : A - B/(x + E)); }
  if(s.kind==='x_over_x2p1'){ return (x)=> x/(x*x + 1); }
  if(s.kind==='homo2'){ const {m,p,q,r}=s.params; return (x)=> (Math.abs(q*x + r)<1e-9? NaN : (m*x + p)/(q*x + r)); }
  return x=>x;
}

return L;
}

/* ====== Score & cycle ====== */
let scoreOK=0, scoreTot=0; function updateScore(){ $('#score').textContent = `${scoreOK} / ${scoreTot}`; }

function buildOne(){ const sel=$('#exo-select'), host=$('#host'); const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def){ host.textContent='(Aucun exercice)'; return; }
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st);
  $('#res',host).textContent=''; }
function check(){
  const host=$('#host');
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st);
  // ✅ Le score n'avance que quand la réponse est complète ET correcte
  if(r && r.ok){
    scoreOK+=1;
    scoreTot+=1;
    updateScore();
  }
}
function solution(){ const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ scoreOK=0; scoreTot=0; updateScore(); const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def) def.reset(host); }

let REGISTRY=[];
window.REGISTRY = REGISTRY;
window.pickDef = id => (window.REGISTRY||[]).find(d=>d.id===id) || null;

/* Init */
document.addEventListener('DOMContentLoaded',function(){
  try{
    REGISTRY = makeExos();
    window.REGISTRY = REGISTRY;
    const sel=$('#exo-select');
    if(!REGISTRY || !REGISTRY.length){ $('#status').textContent='(Init: aucune entrée)'; return; }
    REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
    sel.addEventListener('change',buildOne);
    $('#btn-new').addEventListener('click',buildOne);
    $('#btn-check').addEventListener('click',check);
    $('#btn-solution').addEventListener('click',solution);
    $('#btn-reset').addEventListener('click',resetAll);
    $('#amp-apply').addEventListener('click',applyAMPInputs);
    sel.value=REGISTRY[0].id; buildOne(); updateScore(); $('#status').textContent='(OK)';
  }catch(err){
    console.error(err);
    $('#status').textContent='Erreur d’init : '+(err?.message||err);
  }
});

/* =============== PDF via exo-pdf-kit (hooks) =============== */
window.addEventListener('load', function(){
  if(!(window.ExoPDF && ExoPDF.init)) return;

  // Palette
  const PDF_PALETTE = ['#1565c0','#d32f2f','#2e7d32','#6a1b9a','#ef6c00','#00897b'];

  // remplace les <input> par une “ligne” imprimable, supprime ticks/boutons
  function sanitizeEquHTML(equNode){
    const clone = equNode.cloneNode(true);
    clone.querySelectorAll('input').forEach(inp=>{
      const w = Math.max(60, parseInt(inp.style.width)||0);
      const span = document.createElement('span');
      span.style.display='inline-block';
      span.style.minWidth = (w||60)+'px';
      span.style.borderBottom='1px solid #000';
      span.style.height='1.1em';
      span.style.verticalAlign='bottom';
      inp.replaceWith(span);
    });
    clone.querySelectorAll('button,.tick').forEach(el=>el.remove());
    return clone.outerHTML;
  }

  function twoCol(svgHTML, rightHTML){
    return `
    <table style="width:100%;border-collapse:collapse;table-layout:fixed">
      <tr>
        <td style="width:50%;vertical-align:top;padding-right:12px">${svgHTML}</td>
        <td style="width:50%;vertical-align:top">${rightHTML}</td>
      </tr>
    </table>`;
  }

  ExoPDF.init({
        mountAfterSelector: '#info-saisie',
    getItems(withSolutions){
      // reconstruit l’UI en mémoire pour capturer SVG + texte
      const host = document.createElement('div'); host.style.display='none'; document.body.appendChild(host);
      try{
        const def = pickDef($('#exo-select').value);
        const st = JSON.parse($('#host').dataset.state||'{}');
        def.render(host, st);
        const tmp = host;
        const eq = tmp.querySelector('.equ');
        const right = eq ? sanitizeEquHTML(eq) : '(Énoncé)';
        const svgHTML = (window.cloneCurveForPDF ? cloneCurveForPDF(tmp, { widthPx: 340, heightPx: 340, blockWidth: '100%' }) : (tmp.querySelector('svg')?.outerHTML||''));

        if(!withSolutions){
          return [{
            title: def.title,
            html: twoCol(svgHTML, right)
          }];
        }

        // Avec solution : dessiner la cobweb + bloc texte
        def.solution(tmp, st);
        const solText = (tmp.querySelector('#res')?.outerHTML)||'';
        const solSVG = (window.cloneCurveForPDF ? cloneCurveForPDF(tmp, { widthPx: 340, heightPx: 340, blockWidth: '100%' }) : (tmp.querySelector('svg')?.outerHTML||''));

        return [{
          title: def.title + ' — Corrigé',
          html: twoCol(solSVG, solText)
        }];
      } finally {
        host.remove();
      }
    }
  });
});


})(); 
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;
  // clavier math
  if (window.MathKbdInit) MathKbdInit({ mount: document.querySelector('.kbd') });

  // Entrée -> Vérifier
  document.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      const tag = (e.target||{}).tagName||'';
      if (tag === 'INPUT' || tag === 'TEXTAREA') {
        e.preventDefault();
        const btn = document.querySelector('#btn-check');
        if (btn) btn.click();
      }
    }
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
