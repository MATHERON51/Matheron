<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Première — Suites numériques — Représentation graphique (version LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{padding:.5rem .7rem;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.controls .btn:hover{background:#f7f7f7}
.controls select{padding:.4rem .5rem;border:1px solid #ddd;border-radius:8px;background:#fff}
.controls input[type="number"]{width:64px;padding:.35rem .45rem;border:1px solid #ddd;border-radius:8px}
.score{font-weight:700}
.small{font-size:.92rem;color:#666}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
/* Boîte grisée de correction (sans sous-divs) */
#host #res.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
#host #res.steps p{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;user-select:none}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chip.active{ border-color:#222; background:#eef }
svg text{pointer-events:none}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }

/* Ticks de validation */
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

/* Inputs inline */
.perline{display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center}
.expr{cursor:pointer}
.expr.focus{background:#fff3;border:1px solid #bbb;border-radius:8px}

.badge{display:inline-block;padding:.08rem .5rem;border-radius:999px;border:1px solid #ddd;background:#f9f9f9;font-size:.82rem}

/* Listes déroulantes */
select.slim{padding:.28rem .5rem;border:1px solid #ddd;border-radius:8px;background:#fff}

/* Axes labels style */
.labelC{font-size:12px;fill:#0a84ff}
.labelD{font-size:12px;fill:#333}
</style>

<!-- MathJax v3 (LaTeX inline \\( ... \\) only) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <!-- DevRules in inputs-only mode -->
  <script>window.DEVRULES_MODE='inputs-only';</script>
  <script src="../../../../js/dev-rules-clean.dedup.vB.inputs-only.js" defer></script>
  <script src="../../../../js/math-kbd.js" defer></script>
  <script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
  <script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Première – <strong>Suites numériques</strong> — Représentation graphique</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
      <span id="status" class="small"></span>
    </div>



    <div id="host" class="card"></div>

    <div class="card kbd-host hide-print">
      <div><strong>Clavier math</strong> — Utilise les touches pour écrire : \(x^2\), \(\sqrt{x}\), fractions <code>a/b</code>…</div>
      <div class="kbd"></div>
    </div>
	
	   <!-- Bloc "Saisie & réponses acceptées" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & réponses acceptées :</strong>
      <ul>
       </ul>
    </div>
  </div>

<script>
(function(){'use strict';

/* ============ Utils ============ */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const UMINUS='−'; // pour l'affichage "texte" des axes/labels SVG uniquement
const TOL_LIMIT = 0.2;
// --- Ticks (✓ / ✗) ---
function setTick(el, status){ // status: 'ok' | 'ko' | '' (vide = pas de tick)
  if(!el) return;
  el.classList.remove('ok','ko');
  if(status==='ok'){ el.textContent='✓'; el.classList.add('ok'); el.style.display='inline'; }
  else if(status==='ko'){ el.textContent='✗'; el.classList.add('ko'); el.style.display='inline'; }
  else{ el.textContent=''; el.style.display='none'; }
}

// Assure une marge >= m autour des axes x=0 et y=0
function ensureAxesMargin(R, m=1){
  let {xmin,xmax,ymin,ymax} = R;
  if (0 - xmin < m) xmin = 0 - m;          // marge à gauche de l'axe y
  if (xmax - 0 < m) xmax = 0 + m;          // marge à droite de l'axe y
  if (0 - ymin < m) ymin = 0 - m;          // marge sous l'axe x
  if (ymax - 0 < m) ymax = 0 + m;          // marge au-dessus de l'axe x
  return { xmin, xmax, ymin, ymax };
}

// ========= Helpers LaTeX + tirage =========
// ----- formatage & LaTeX -----
function fmtNum(x){
  const s = Number(x).toFixed(4);
  return s.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
}
function toLatexRecurrence(kind,p){
  const n='u_n', f=fmtNum;
  if(kind==='sqrt'){ const {p:pp,k}=p; return `u_{n+1} = \\sqrt{${pp===1?`${n}`:`${f(pp)}\\,${n}`} ${k>=0?'+ '+f(k):'- '+f(-k)}}`; }
  if(kind==='homo1'){ const {a,b,d}=p; return `u_{n+1} = \\dfrac{${f(a)}${n} ${b>=0?'+ '+f(b):'- '+f(-b)}}{${n} ${d>=0?'+ '+f(d):'- '+f(-d)}}`; }
  if(kind==='a_minus_b_over'){ const {A,B,E}=p; return `u_{n+1} = ${f(A)} - \\dfrac{${f(B)}}{${n} ${E>=0?'+ '+f(E):'- '+f(-E)}}`; }
  if(kind==='x_over_x2p1'){ return `u_{n+1} = \\dfrac{${n}}{${n}^2 + 1}`; }
  if(kind==='homo2'){ const {m,p:pp,q,r}=p; return `u_{n+1} = \\dfrac{${f(m)}${n} ${pp>=0?'+ '+f(pp):'- '+f(-pp)}}{${f(q)}${n} ${r>=0?'+ '+f(r):'- '+f(-r)}}`; }
  if(kind==='affine'){ const {m,p:pp}=p; return `u_{n+1} = ${f(m)}${n} ${pp>=0?'+ '+f(pp):'- '+f(-pp)}`; }
  return `u_{n+1}=f(u_n)`;
}

// ----- parsing (simple) de la saisie élève f(x) et test par échantillon -----
// ----- parsing (tolérant) de la saisie élève f(x) -----
function makeUserF(expr){
  if(!expr) return null;
  let s = String(expr);

  // normalisations générales
  s = s.replace(/,/g, '.')
       .replace(/\s+/g, '')
       .replace(/[·×]/g, '*')
       .replace(/\^/g, '**')
       .replace(/[{}]/g, m => (m==='{'?'(' : ')'))
       .replace(/X/g, 'x');      // accepte X majuscule

  // unifier racines : rac(), sqrt(), ou symbole √
  s = s.replace(/√/g, 'sqrt')
       .replace(/\brac\b/gi, 'sqrt');

  // produits implicites AVANT de convertir sqrt -> Math.sqrt
  s = s.replace(/(\d)([a-zA-Z])/g, '$1*$2')   // 2x -> 2*x
       .replace(/([a-zA-Z])(\d)/g, '$1*$2')   // x2 -> x*2
       .replace(/(\d|\)|x)\(/g, '$1*(');      // 2(x+1) ou x(x+1) -> 2*(...) / x*(...)

  // sqrt avec et sans parenthèses
  s = s.replace(/sqrt\(/gi, 'Math.sqrt(')          // sqrt( ... ) -> Math.sqrt(
       .replace(/sqrt([A-Za-z0-9_.]+)/gi, 'Math.sqrt($1)'); // sqrtx -> Math.sqrt(x)

  try{
    // eslint-disable-next-line no-new-func
    const fn = new Function('x','"use strict"; return ('+s+');');
    void fn(0.5); // test rapide
    return fn;
  }catch(_){
    return null;
  }
}

function equivalentFx(userExpr, f, R, poles){
  const g = makeUserF(userExpr);
  if(!g) return false;
  const xs=[];
  for(let i=0;i<70;i++){
    const x = R.xmin + (i+0.5)/70*(R.xmax-R.xmin);
    if(poles && poles.some(p=>Number.isFinite(p)&&Math.abs(x-p)<1e-6)) continue;
    xs.push(x);
  }
  let ok=0, tried=0;
  for(const x of xs){
    const y = f(x);
    if(!Number.isFinite(y)) continue;
    let u; try{ u = g(x); }catch(_){ continue; }
    if(!Number.isFinite(u)) continue;
    tried++;
    if(Math.abs(u-y) <= 1e-3 + 1e-3*Math.abs(y)) ok++;
  }
  return tried>=20 && ok/tried>0.9;
}

function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
// --- Domaine strict pour l'itération (pas de "max(0,·)" ici !) ---
function buildFStrict(s){
  if(s.kind==='sqrt'){ const {p,k}=s.params; return x => {
    const v = p*x + k; return (v < 0) ? NaN : Math.sqrt(v);
  }; }
  if(s.kind==='homo1'){ const {a,b,d}=s.params; return x => (x===-d)?NaN:(a*x+b)/(x+d); }
  if(s.kind==='a_minus_b_over'){ const {A,B,E}=s.params; return x => (x===-E)?NaN:(A - B/(x+E)); }
  if(s.kind==='x_over_x2p1'){ return x => x/(x*x+1); }
  if(s.kind==='homo2'){ const {m,p,q,r}=s.params; return x => (Math.abs(q*x+r)<1e-12)?NaN:(m*x+p)/(q*x+r); }
  if(s.kind==='affine'){ const {m,p}=s.params; return x => m*x+p; }
  return x=>NaN;
}

// --- valide une entrée de la banque : u0 dans le domaine, u1..u3 définis et dans la fenêtre ---
function entryIsValid(it){
  const f = buildFStrict(it);
  const inner = 0.3;               // petite marge
  const xmin = it.R.xmin + inner, xmax = it.R.xmax - inner;

  // u0 doit être dans le domaine (et visible dans la fenêtre)
  if(!(Number.isFinite(it.u0) && it.u0>xmin && it.u0<xmax)) return false;
  if(!Number.isFinite(f(it.u0))) return false;

  // u1, u2, u3 doivent exister et rester visibles
  let u = it.u0;
  for(let k=0;k<3;k++){
    u = f(u);
    if(!Number.isFinite(u)) return false;
    if(u<=xmin || u>=xmax) return false;
  }
  return true;
}

// ========= BANQUE 150 (30 par famille) =========
function makeBank150(){
  const B=[];
  const shifts = [-4,-3,-2, 2,3,4];
  const S=[]; for(let t=2; t<=6; t+=0.5) S.push(Number(t.toFixed(1))); // points fixes visibles

  // 1) 30 racines  f(x)=sqrt(p x + k)  avec f(s)=s
  let toggle=0;
  for(const s of S){
    const p = (toggle++%2===0?1:2);
    const k = s*s - p*s;
    const R = repereAroundS(s,10,10);
    const local = [-3,-2,3];
    for(const sh of local){ B.push({kind:'sqrt', params:{p,k}, u0:s+sh, R}); }
    if(B.filter(x=>x.kind==='sqrt').length>=27) break;
  }
  // 3 de plus
  for(let i=0;i<3;i++){
    const s = S[i]; const p = (i%2?2:1); const k=s*s-p*s; const R=repereAroundS(s,10,10);
    B.push({kind:'sqrt', params:{p,k}, u0:s+4, R});
  }

  // 2) 15 homographiques type (a x + b)/(x + d)  avec f(s)=s
  const A1=[1,2,3], D1=[2,3,4,5];
  outer_h1:
  for(const a of A1) for(const d of D1) for(const s of S){
    const b = s*(s + d - a);
    const R = repereAroundS(s,10,10);
    for(const sh of shifts){
      const u0 = s+sh;
      if(Math.abs(u0 + d) < 0.25) continue;   // évite le pôle
      B.push({kind:'homo1', params:{a,b,d}, u0, R});
      if(B.filter(x=>x.kind==='homo1').length>=15) break outer_h1;
    }
  }

  // 3) 15 homographiques type  A - B/(x + E)  avec f(s)=s
  const AA=[4,5,6], EE=[1,2,3];
  outer_h2:
  for(const A of AA) for(const E of EE) for(const s of S){
    const Bv = (A - s)*(s + E);
    const R = repereAroundS(s,10,10);
    for(const sh of shifts){
      const u0 = s+sh;
      if(Math.abs(u0 + E) < 0.25) continue;   // évite le pôle
      B.push({kind:'a_minus_b_over', params:{A, B:Bv, E}, u0, R});
      if(B.filter(x=>x.kind==='a_minus_b_over').length>=15) break outer_h2;
    }
  }

  // 4) 30 affines  f(x)=m x + p  avec s=p/(1-m)
  const M=[0.5, 2/3, 0.8, 0.6, 0.75, 0.4, 0.7, 0.3, 0.55, 0.65];
  outer_aff:
  for(const m of M) for(const s of S){
    const p = (1-m)*s;
    const R = repereAroundS(s,10,10);
    for(const sh of [-3,-2,2]){
      B.push({kind:'affine', params:{m,p}, u0:s+sh, R});
      if(B.filter(x=>x.kind==='affine').length>=30) break outer_aff;
    }
  }

  // 5) 30 du type x/(x^2+1)
  const U0 = [-2.5,-2.2,-2.0,-1.8,-1.6,-1.5,-1.4,-1.2,-1.1,-1.0,-0.9,-0.8,-0.6,-0.5,-0.4,
               0.4,0.5,0.6,0.8,0.9,1.0,1.1,1.2,1.4,1.5,1.6,1.8,2.0,2.2,2.5];
  for(const u0 of U0){
    B.push({kind:'x_over_x2p1', params:{}, u0, R:{xmin:-3,xmax:3,ymin:-1,ymax:2}});
  }

  // 6) 30 BONUS (homo2)  f(x)=(m x + p)/(q x + r) avec f(s)=s
  const MM=[1,2,3], QQ=[1,2], RR=[3,4,5,6];
  outer_homo2:
  for(const m of MM) for(const q of QQ) for(const r of RR) for(const s of S){
    if(Math.abs(q*s + r) < 1e-9) continue;
    const p = s*(q*s + r - m);
    const R = repereAroundS(s,10,10);
    for(const sh of shifts){
      const u0 = s+sh;
      if(Math.abs(q*u0 + r) < 0.25) continue; // loin du pôle
      B.push({kind:'homo2', params:{m,p,q,r}, u0, R});
      if(B.filter(x=>x.kind==='homo2').length>=30) break outer_homo2;
    }
  }

  return B;
}

// Construit la banque et prépare un deck aléatoire sans répétition
const BANK = makeBank150().filter(entryIsValid);
// filet de sécurité : si jamais tout est filtré (improbable), on retombe sur la banque brute
if(BANK.length === 0) console.warn('BANK vidée par le filtre; utilisation de la banque brute');
const _FALLBACK_BANK = (BANK.length ? BANK : makeBank150());

let DECK = [];
function refillDeck(){
  // on brasse la banque filtrée (ou la brute en repli)
  const src = (BANK.length ? BANK : _FALLBACK_BANK);
  DECK = src.map((_,i)=>i);
  // shuffle
  for(let i=DECK.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [DECK[i],DECK[j]]=[DECK[j],DECK[i]]; }
}
function drawFromBank(){
  if(DECK.length===0) refillDeck();
  const src = (BANK.length ? BANK : _FALLBACK_BANK);
  return src[DECK.pop()];
}


function uminusStr(n){ return (n<0?UMINUS:'')+String(Math.abs(n)); }

function MJ(host){ try{ if(window.MathJax && MathJax.typesetPromise){ MathJax.typesetPromise([host]).catch(()=>{}); } }catch(e){} }

/* Amplitude par défaut */
let AMP={ xmin:-2, xmax:8, ymin:-2, ymax:8 };

/* ============ REPÈRE ============ */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.points=[]; this.user=[]; this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const s=document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
    const defs=document.createElementNS(s.namespaceURI,'defs');
    const marker=document.createElementNS(s.namespaceURI,'marker');
    marker.setAttribute('id','arrow'); marker.setAttribute('orient','auto');
    marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8');
    marker.setAttribute('refX','0'); marker.setAttribute('refY','3');
    const path=document.createElementNS(s.namespaceURI,'path');
    path.setAttribute('d','M0,0 L0,6 L8,3 z'); path.setAttribute('fill','#000');
    marker.appendChild(path); defs.appendChild(marker); s.appendChild(defs);
    this.gGrid=document.createElementNS(s.namespaceURI,'g');
    this.gAxes=document.createElementNS(s.namespaceURI,'g');
    this.gPts=document.createElementNS(s.namespaceURI,'g');
    this.gUser=document.createElementNS(s.namespaceURI,'g');
    [this.gGrid,this.gAxes,this.gPts,this.gUser].forEach(g=>s.appendChild(g));

    // clic (précis, sans arrondi)
    s.addEventListener('click', ev=>{
      if(!this.clickable||!this.onClick) return;
      const r=s.getBoundingClientRect(), X=ev.clientX-r.left, Y=ev.clientY-r.top;
      const c=this.screenToCoord(X,Y);
      this.onClick({x:c.x,y:c.y});
    });
    return s;
  }
  innerLimits(){ return { xmin:this.R.xmin+1, xmax:this.R.xmax-1, ymin:this.R.ymin+1, ymax:this.R.ymax-1 }; }
  set(R){ this.R={...this.R,...R}; this.redraw(); }
  coordToScreen(x,y){
    const R=this.R, w=420, h=420;
    const X = (x-R.xmin)/(R.xmax-R.xmin)*w;
    const Y = h - (y-R.ymin)/(R.ymin< this.R.ymax ? (R.ymax-R.ymin) : 1)*h;
    return {x:X,y:Y};
  }
  screenToCoord(X,Y){
    const R=this.R, w=420, h=420;
    const x = R.xmin + X/w*(R.xmax-R.xmin);
    const y = R.ymin + (h-Y)/h*(R.ymax-R.ymin);
    return {x,y};
  }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){
      g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','11'); t.setAttribute('fill',color); t.textContent=label;
      g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g);
    }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
    t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }
drawGivenLine(id,color,pts){
  let L=this.gPts.querySelector(`line[data-id="${id}"]`);
  if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.gPts.appendChild(L); }
  const a=this.coordToScreen(pts[0].x,pts[0].y), b=this.coordToScreen(pts[1].x,pts[1].y);
  L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
  L.setAttribute('stroke',color||'#000'); L.setAttribute('stroke-width','3');
  return L; // ⬅️ ajouté
}

drawUserLine(id,color,pts){
  let L=this.gUser.querySelector(`line[data-id="${id}"]`);
  if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.gUser.appendChild(L); }
  const a=this.coordToScreen(pts[0].x,pts[0].y), b=this.coordToScreen(pts[1].x,pts[1].y);
  L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
  L.setAttribute('stroke',color||'#0a84ff'); L.setAttribute('stroke-width','2.5');
  return L; // ⬅️ ajouté
}

  drawUserInfiniteLine(id,color,P,Q){
    if(P.x===Q.x){
      this.drawUserLine(id,color,[{x:P.x,y:this.R.ymin},{x:P.x,y:this.R.ymax}]);
      return;
    }
    const m=(Q.y-P.y)/(Q.x-P.x), b=P.y - m*P.x;
    const x1=this.R.xmin, y1=m*x1+b;
    const x2=this.R.xmax, y2=m*x2+b;
    this.drawUserLine(id,color,[{x:x1,y:y1},{x:x2,y:y2}]);
  }
  redraw(){
    const R=this.R; this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gPts.innerHTML='';
    const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line'); L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2); L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.5:1); return L; };
    for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
    for(let t=R.ymin;t<=R.ymax;t++){ const q1=this.coordToScreen(R.xmin,t), q2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(q1.x,q1.y,q2.x,q2.y)); }
    const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
    const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
    axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)'); this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);
    // graduations & labels
    for(let t=R.xmin;t<=R.xmax;t++){
      const u=this.coordToScreen(t,(R.ymin+R.ymax)/2+0.15), v=this.coordToScreen(t,(R.ymin+R.ymax)/2-0.15);
      this.gAxes.appendChild(mkLine(u.x,u.y,v.x,v.y));
      if(t!==0 && t!==1){ const tx=document.createElementNS(this.el.namespaceURI,'text'); tx.setAttribute('x',this.coordToScreen(t,0).x+3); tx.setAttribute('y',this.coordToScreen(0,0).y+12); tx.setAttribute('font-size','11'); tx.textContent=uminusStr(t); this.gAxes.appendChild(tx); }
    }
    for(let t=R.ymin;t<=R.ymax;t++){
      const u=this.coordToScreen((R.xmin+R.xmax)/2+0.15,t), v=this.coordToScreen((R.xmin+R.xmax)/2-0.15,t);
      this.gAxes.appendChild(mkLine(u.x,u.y,v.x,v.y));
      if(t!==0 && t!==1){ const ty=document.createElementNS(this.el.namespaceURI,'text'); ty.setAttribute('x',this.coordToScreen(0,0).x-18); ty.setAttribute('y',this.coordToScreen(0,t).y+4); ty.setAttribute('font-size','11'); ty.textContent=uminusStr(t); this.gAxes.appendChild(ty); }
    }
    // O, I, J
    const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
    const mkTxt=(pt,label)=>{ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',pt.x+6); t.setAttribute('y',pt.y-6); t.setAttribute('font-size','12'); t.textContent=label; return t; };
    const mkPt=(pt)=>{ const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',pt.x); c.setAttribute('cy',pt.y); c.setAttribute('r','3.5'); c.setAttribute('fill','#000'); return c; };
    this.gAxes.appendChild(mkPt(O)); this.gAxes.appendChild(mkTxt(O,'O'));
    this.gAxes.appendChild(mkPt(I)); this.gAxes.appendChild(mkTxt(I,'I'));
    this.gAxes.appendChild(mkPt(J)); this.gAxes.appendChild(mkTxt(J,'J'));
  }
}

/* Helpers DOM */
function renderWithRepere(host,opts){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const left=document.createElement('div'); const right=document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);
  const rep=new Repere(opts.R||AMP,{}); left.appendChild(rep.el);
  const equ=document.createElement('div'); equ.className='equ'; right.appendChild(equ);
  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  return {rep,left,right,equ,actions,res};
}
function mkInput(id,w=120,ph=''){ return `<input id="${id}" style="width:${w}px" placeholder="${ph}">`; }
function setVal(host,id,val){ const i=$('#'+id,host); if(i) i.value=val; }
function getVal(host,id){ const i=$('#'+id,host); return i ? String(i.value||'').trim() : ''; }

/* Amplitude */
function applyAMPInputs(){
  AMP.xmin = clamp(parseInt($('#xmin').value||-2,10), -12, 12);
  AMP.xmax = clamp(parseInt($('#xmax').value|| 8,10), -12, 12);
  AMP.ymin = clamp(parseInt($('#ymin').value||-2,10), -12, 12);
  AMP.ymax = clamp(parseInt($('#ymax').value|| 8,10), -12, 12);
  if(AMP.xmin>=AMP.xmax) AMP.xmax=AMP.xmin+1;
  if(AMP.ymin>=AMP.ymax) AMP.ymax=AMP.ymin+1;
  buildOne();
}
function repereAroundS(s, w=9, h=9){
  // repère centré sur s, graduations entières
  const xmin = Math.floor(s) - Math.floor(w/2);
  const ymin = Math.floor(s) - Math.floor(h/2);
  return { xmin, xmax:xmin+w, ymin, ymax:ymin+h };
}
function derivAt(f,x){ const h=1e-4;
  const a=f(x+h), b=f(x-h);
  if(!Number.isFinite(a)||!Number.isFinite(b)) return NaN;
  return (a-b)/(2*h);
}


function ensurePointFixeVisible(R,s){
  const w=R.xmax-R.xmin, h=R.ymax-R.ymin;
  let {xmin,xmax,ymin,ymax}=R;
  if(s<=xmin+1 || s>=xmax-1){ xmin=Math.floor(s-w/2); xmax=xmin+w; }
  if(s<=ymin+1 || s>=ymax-1){ ymin=Math.floor(s-h/2); ymax=ymin+h; }
  return {xmin,xmax,ymin,ymax};
}
function tune(fid){
  // seuils adaptés par famille
  return {
    slopeMax: (fid==='x_over_x2p1' ? 1.05 : 0.98),          // autorise f'(s)=1 pour x/(x^2+1)
    minStep: 0.30,                                          // |u1-u0| (évite stationnaire)
    minFinal: (fid==='sqrt'||fid==='x_over_x2p1') ? 0.30 : 0.60, // u3 pas trop collé à s
    shiftMin: (fid==='sqrt' ? 3 : 2),                       // u0 = s ± shift
    shiftMax: (fid==='sqrt' ? 6 : 5)
  };
}
function rndFloat(a,b){ return a + Math.random()*(b-a); }
function fmtNum(x){ const s = Number(x.toFixed(4)).toString(); return s.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1'); }
function toLatexFor(kind,p){
  const sgn = v => v>=0 ? `+ ${fmtNum(v)}` : `- ${fmtNum(-v)}`;
  if(kind==='sqrt'){ const {p:pp,k}=p; return `\\sqrt{${pp===1?'x':fmtNum(pp)+'x'} ${k>=0?'+ '+fmtNum(k):'- '+fmtNum(-k)}}`; }
  if(kind==='homo1'){ const {a,b,d}=p; return `\\dfrac{${fmtNum(a)}x ${b>=0?'+ '+fmtNum(b):'- '+fmtNum(-b)}}{x ${d>=0?'+ '+fmtNum(d):'- '+fmtNum(-d)}}`; }
  if(kind==='a_minus_b_over'){ const {A,B,E}=p; return `${fmtNum(A)} - \\dfrac{${fmtNum(B)}}{x ${E>=0?'+ '+fmtNum(E):'- '+fmtNum(-E)}}`; }
  if(kind==='x_over_x2p1'){ return `\\dfrac{x}{x^2 + 1}`; }
  if(kind==='homo2'){ const {m,p:pp,q,r}=p; return `\\dfrac{${fmtNum(m)}x ${pp>=0?'+ '+fmtNum(pp):'- '+fmtNum(-pp)}}{${fmtNum(q)}x ${r>=0?'+ '+fmtNum(r):'- '+fmtNum(-r)}}`; }
  if(kind==='affine'){ const {m,p:pp}=p; return `${fmtNum(m)}x ${pp>=0?'+ '+fmtNum(pp):'- '+fmtNum(-pp)}`; }
  return 'f(x)';
}

/* ============ GÉNÉRATEURS f(x) ============ */
function families(){
  const F=[];

  // 1) sqrt : f(x) = sqrt(2x + k), point fixe entier s ∈ {3,4,5}
  F.push({
    id:'sqrt',
    toLatex:(p,k)=>`\\sqrt{${p===1?'':p}x ${k>=0?`+ ${k}`:`${UMINUS}${Math.abs(k)}`}}`,
    make(){
      const s = rndFloat(2.0, 5.5);         // au lieu de s entier
const p = 2, k = s*s - 2*s;
      const f = x => { const v = p*x + k; return v < 0 ? NaN : Math.sqrt(v); };
      const R = repereAroundS(s, 10, 10);      // intersection bien au centre
      return { f, R, params:{p,k}, fixed:s, poles:[] };
    }
  });

  // 2) homographique simple : (a x + b)/(x + d)
  F.push({
    id:'homo1',
    toLatex:(a,b,d)=>`\\dfrac{${a}x ${b>=0?`+ ${b}`:`${UMINUS}${Math.abs(b)}`}}{x ${d>=0?`+ ${d}`:`${UMINUS}${Math.abs(d)}`}}`,
    make(){
     const a=rnd(1,3), d=rnd(2,5);
const s = rndFloat(2.0, 5.5);
const b = s*(s + d - a);     
      const f = x => (x===-d? NaN : (a*x + b)/(x + d));
      const R = repereAroundS(s, 10, 10);
      return { f, R, params:{a,b,d}, fixed:s, poles:[-d] };
    }
  });

  // 3) A - B/(x + E)
  F.push({
    id:'a_minus_b_over',
    toLatex:(A,B,E)=>`${A} ${UMINUS} \\dfrac{${B}}{x ${E>=0?`+ ${E}`:`${UMINUS}${Math.abs(E)}`}}`,
    make(){
      const A=rnd(3,6), E=rnd(1,3);
const s = rndFloat(2.0, 5.5);
const B = (A - s)*(s + E);   
      const f = x => (x===-E? NaN : A - B/(x + E));
      const R = repereAroundS(s, 10, 10);
      return { f, R, params:{A,B,E}, fixed:s, poles:[-E] };
    }
  });

  // 4) x/(x^2+1) : point fixe s=0
  F.push({
    id:'x_over_x2p1',
    toLatex:()=>`\\dfrac{x}{x^2 + 1}`,
    make(){
      const s=0;
      const f = x => x/(x*x+1);
      const R = { xmin:-4, xmax:6, ymin:-3, ymax:7 };    // s visible
      return { f, R, params:{}, fixed:s, poles:[] };
    }
  });

  // 5) (m x + p)/(q x + r)
  F.push({
    id:'homo2',
    toLatex:(m,p,q,r)=>`\\dfrac{${m}x ${p>=0?`+ ${p}`:`${UMINUS}${Math.abs(p)}`}}{${q}x ${r>=0?`+ ${r}`:`${UMINUS}${Math.abs(r)}`}}`,
    make(){
      const m=rnd(1,3), q=rnd(1,2), r=rnd(3,6);
const s = rndFloat(2.0, 5.5);
const p = s*(q*s + r - m);            // f(s)=s
      const f = x => (Math.abs(q*x + r)<1e-9? NaN : (m*x + p)/(q*x + r));
      const R = repereAroundS(s, 10, 10);
      return { f, R, params:{m,p,q,r}, fixed:s, poles:[-r/q] };
    }
  });

  return F;
}



/* Dessin d’une fonction continue par morceaux */
function drawFunction(rep, f, color='#0a84ff'){
  const R=rep.R, W=320;
  let pathD='';
  let penUp=true;
  for(let i=0;i<=W;i++){
    const x = R.xmin + (i/W)*(R.xmax-R.xmin);
    let y = f(x);
    if(!Number.isFinite(y) || isNaN(y)) { penUp=true; continue; }
    if(y<R.ymin-1 || y>R.ymax+1){ penUp=true; continue; }
    const p = rep.coordToScreen(x,y);
    pathD += (penUp?`M${p.x.toFixed(2)},${p.y.toFixed(2)} `:`L${p.x.toFixed(2)},${p.y.toFixed(2)} `);
    penUp=false;
  }
  const path=document.createElementNS(rep.el.namespaceURI,'path');
  path.setAttribute('d',pathD.trim());
  path.setAttribute('fill','none'); path.setAttribute('stroke',color); path.setAttribute('stroke-width','2.5');
  rep.gPts.appendChild(path);
  return path;
}

/* ============ Exercices ============ */
function makeExos(){ const L=[];

L.push({
  id:'suite_graph',
  title:'Ex. 1 — Suite définie par \\(u_{n+1}=f(u_n)\\) (représentation graphique)',
  // outils
  _iter(f,u0,k){ const U=[u0]; for(let i=0;i<k;i++){ let u=U[U.length-1]; let v=f(u); if(!Number.isFinite(v)) return null; U.push(v); } return U; },
  _trend(U){ const d1=U[1]-U[0], d2=U[2]-U[1], d3=U[3]-U[2]; const s=[d1,d2,d3]; const allPos=s.every(x=>x>0.0001), allNeg=s.every(x=>x<-0.0001); return allPos?'croissante':allNeg?'décroissante':'ni croissante, ni décroissante'; },
  _limit(f,u0){ let u=u0; for(let i=0;i<200;i++){ const v=f(u); if(!Number.isFinite(v)) return {ok:false}; if(Math.abs(v-u)<1e-6) return {ok:true, L:v}; u=v; } return {ok:false}; },
  _fmt(x){ const s = Math.abs(x)<1e-6 ? '0' : (Math.abs(x)>=1000 ? x.toExponential(2).replace('e','\\times 10^{')+'}' : (Math.abs(x)<1e-4? x.toExponential(2).replace('e','\\times 10^{')+'}' : x.toFixed(3).replace(/\.?0+$/,''))); return s; },

gen(){
  const it = drawFromBank();
  const f = buildF(it);
  const U = this._iter(f, it.u0, 3);
  const tr = this._trend(U);
  const lim = this._limit(f, it.u0);

  // 🔧 garantit axes visibles avec 1 unité de marge
  const Rfix = ensureAxesMargin(it.R, 1);

  return { R:Rfix, kind:it.kind, params:it.params, u0:it.u0, U, trend:tr, limit:lim };
},




  render(host,s){
    host.innerHTML=''; const ui=renderWithRepere(host,{R:s.R}); host._ui=ui;
    const rep=ui.rep; rep.set(s.R);
   // Droite D : y = x
const lineD = rep.drawGivenLine('D','#333',[{x:s.R.xmin,y:s.R.xmin},{x:s.R.xmax,y:s.R.xmax}]);
lineD.style.cursor='pointer'; lineD.setAttribute('stroke-linecap','round');

// Courbe C : y = f(x)
const f = buildF(s);
const pathC = drawFunction(rep, f, '#0a84ff');
pathC.style.pointerEvents='stroke';
pathC.style.cursor='pointer';

    // Labels
    const endX = s.R.xmax-0.6;
    const pD = rep.coordToScreen(endX,endX);
    const tD=document.createElementNS(rep.el.namespaceURI,'text'); tD.setAttribute('x',pD.x); tD.setAttribute('y',pD.y-6); tD.setAttribute('class','labelD'); tD.textContent='D : y = x'; rep.gPts.appendChild(tD);
    const pC = rep.coordToScreen(endX, f(endX));
    const tC=document.createElementNS(rep.el.namespaceURI,'text'); tC.setAttribute('x',pC.x); tC.setAttribute('y',pC.y-6); tC.setAttribute('class','labelC'); tC.textContent='C : y = f(x)'; rep.gPts.appendChild(tC);

    // Énoncé (LaTeX)
// -------- ENONCE (questions + emplacements de saisie) --------
const recLatex = toLatexRecurrence(s.kind, s.params);
ui.equ.innerHTML = `
  <p>On définit la suite \\((u_n)\\) par son 1<sup>er</sup> terme :
     \\(u_0 = ${fmtNum(s.u0)}\\)<br>
     et la relation de récurrence : \\(${recLatex}\\).</p>

  <ol class="exo-steps">
    <li>La relation de récurrence est du type \\(u_{n+1}=f(u_n)\\).
      <ol type="a">
        <li>Donner l’expression \\(f(x)\\) :
          <div id="slot-1a"></div>
        </li>
        <li>La courbe de cette fonction est donnée ci-contre.</li>
      </ol>
    </li>
    <li>Construire \\(u_0, u_1, u_2, u_3\\) sur l’axe des abscisses.
        <div id="slot-2"></div>
    </li>
    <li>Que peut-on conjecturer sur les variations de \\((u_n)\\) ?
        <div id="slot-3"></div>
    </li>
    <li>Que peut-on conjecturer sur la convergence de \\((u_n)\\) ?
        Donner sa limite à l’infini.
        <div id="slot-4"></div>
    </li>
	<div class="equ-offscreen" style="display:none">
	 

  <p>On définit la suite \\((u_n)\\) par son 1<sup>er</sup> terme :
     \\(u_0 = ${fmtNum(s.u0)}\\)<br>
     et la relation de récurrence : \\(${recLatex}\\).</p>
	  <ol class="exo-steps">
           <li>La relation de récurrence est du type \\(u_{n+1}=f(u_n)\\).
      <ol type="a">
        <li>Donner l’expression \\(f(x)\\) :
        </li>
        <li>La courbe de cette fonction est donnée ci-contre.</li>
      </ol>
    </li>
    <li>Construire \\(u_0, u_1, u_2, u_3\\) sur l’axe des abscisses.
    </li>
    <li>Que peut-on conjecturer sur les variations de \\((u_n)\\) ?
    </li>
    <li>Que peut-on conjecturer sur la convergence de \\((u_n)\\) ?
        Donner sa limite à l’infini.
    </li>
               </ol> </div>  

  </ol>
`;
MJ(ui.equ);

// ---- 1a) saisie f(x)
const s1a = $('#slot-1a', ui.equ);
const inFx = document.createElement('input');
inFx.id = 'in-fx';
inFx.placeholder = 'Ex.: (2x+3)/(x+5), sqrt(2x+8) ou 0.5x+2';
inFx.style.width = '320px';
s1a.appendChild(inFx);

// ---- 2) construction u0..u3 (chips + hint) sous la question 2
const s2 = $('#slot-2', ui.equ);
const chips = document.createElement('div'); chips.className='chips';
chips.innerHTML = ['u₀','u₁','u₂','u₃']
  .map((lab,i)=>`<span class="chip" id="chip${i}"><span class="dot" style="background:${i? '#0a84ff':'#ef6c00'}"></span>${lab}</span>`).join('');
s2.appendChild(chips);
const hint = document.createElement('div'); hint.className='hint';
hint.innerHTML = '1) Clique près de l’axe pour placer \\(u_0\\).<br>2) Pour chaque terme suivant : clique <em>sur la courbe C</em> (verticale pointillée), puis <em>sur la droite</em> \\(y=x\\) (horizontale puis verticale).';
s2.appendChild(hint); MJ(hint);

// ---- 3) sens sous la question 3
const s3 = $('#slot-3', ui.equ);
const sens = document.createElement('select'); sens.id='sel-sens'; sens.className='slim';
sens.innerHTML = `<option value="">— sens de variation —</option>
<option value="croissante">croissante</option>
<option value="décroissante">décroissante</option>
<option value="ni">ni l’un ni l’autre</option>`;
s3.appendChild(sens);

// ---- 4) convergence + limite sous la question 4
const s4 = $('#slot-4', ui.equ);
const conv = document.createElement('select'); conv.id='sel-conv'; conv.className='slim';
conv.innerHTML = `<option value="">— convergence —</option>
<option value="conv">convergente</option>
<option value="div">divergente</option>`;
const lim = document.createElement('input'); lim.id='in-lim';
lim.placeholder='limite (si convergente)'; lim.style.width='160px';
s4.appendChild(conv); s4.appendChild(lim);

// ------- (le reste de ta méthode render ne change pas) -------



    // --- État de placement & mode ---
host._placed = [null, null, null, null]; // on laisse l'élève placer u0
let nextIndex = 0;                        // 0->u0, 1->u1, 2->u2, 3->u3
let mode = 'place-u0';                    // puis 'curve' / 'diag' / 'done'
let imgPt = null;                         // (u_n, f(u_n)) mémorisé après clic courbe

// puces d’étapes
function updateChips(){
  for(let i=0;i<4;i++){
    const c = $('#chip'+i,host);
    c.classList.toggle('active', i===nextIndex);
  }
}
updateChips();

// message d’aide (réutilise l’élément `hint` créé plus haut)
hint.innerHTML = '1) Clique près de l’axe pour placer \\(u_0\\).<br>'+
                 '2) Pour chaque terme suivant : clique <em>sur la courbe C</em> (verticale pointillée), puis <em>sur la droite D : y=x</em> (horizontale + verticale).';
MJ(hint);
const self = this;            // pour accéder à _iter, _trend, etc.
const tolPlace = Math.max(0.15, (s.R.xmax - s.R.xmin) / 80);

// ========== 1a) f(x) ==========
{
  const s1a = $('#slot-1a', ui.equ);
  const inFx = $('#in-fx', ui.equ);
  const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Valider 1a';
  const tk  = document.createElement('span');   tk.className='tick'; tk.id='tick-1a';
  s1a.appendChild(btn); s1a.appendChild(tk);

  btn.addEventListener('click', ()=>{
    const expr = (inFx?.value||'').trim();
    if(!expr){ setTick(tk,''); return; }              // pas de sanction si vide
    let poles=[];
    if(s.kind==='homo1') poles=[-s.params.d];
    else if(s.kind==='a_minus_b_over') poles=[-s.params.E];
    else if(s.kind==='homo2') poles=[-s.params.r/s.params.q];
    const ok = equivalentFx(expr, f, s.R, poles);
    setTick(tk, ok?'ok':'ko');
  });
}

// ========== 2) Placements u0..u3 ==========
{
  const s2 = $('#slot-2', ui.equ);
  const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Valider placements';
  const tk  = document.createElement('span');   tk.className='tick'; tk.id='tick-2';
  s2.appendChild(btn); s2.appendChild(tk);

  btn.addEventListener('click', ()=>{
    const U = self._iter(f, s.u0, 3);
    const placed = host._placed || [];
    const done = placed.filter(x => typeof x==='number' && isFinite(x)).length === 4;
    if(!done){ setTick(tk,''); return; }             // pas tous placés → pas de tick
    const ok = placed.every((x,i)=> Math.abs(x - U[i]) <= tolPlace);
    setTick(tk, ok?'ok':'ko');
  });
}

// ========== 3) Sens ==========
{
  const s3 = $('#slot-3', ui.equ);
  const sens = $('#sel-sens', ui.equ);
  const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Valider sens';
  const tk  = document.createElement('span');   tk.className='tick'; tk.id='tick-3';
  s3.appendChild(document.createTextNode(' ')); s3.appendChild(btn); s3.appendChild(tk);

  btn.addEventListener('click', ()=>{
    const v = sens?.value||'';
    if(!v){ setTick(tk,''); return; }
    const U = self._iter(f, s.u0, 3);
    const trend = self._trend(U);
    setTick(tk, v===trend ? 'ok' : 'ko');
  });
}

// ========== 4) Convergence & limite ==========
{
  const s4 = $('#slot-4', ui.equ);
  const conv = $('#sel-conv', ui.equ), lim = $('#in-lim', ui.equ);
  const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Valider convergence/limite';
  const tk  = document.createElement('span');   tk.className='tick'; tk.id='tick-4';
  s4.appendChild(document.createElement('br'));
  s4.appendChild(btn); s4.appendChild(tk);

  btn.addEventListener('click', ()=>{
    const choice = conv?.value||'';
    if(!choice){ setTick(tk,''); return; }
    const L = self._limit(f, s.u0);
    let ok=false;
    if(choice==='div'){ ok = !L.ok; }
    if(choice==='conv'){
      const v = parseFloat((lim?.value||'').replace(',','.'));
      ok = L.ok && (Number.isFinite(v) ? Math.abs(v - L.L) <= TOL_LIMIT : true);
    }
    setTick(tk, ok?'ok':'ko');
  });
}


// tolérances
const tolAxisY = 0.6;

// 1) Placement de u0 : clic sur le repère (axe des abscisses)
rep.clickable = true;
rep.onClick = (P)=>{
  if(mode!=='place-u0') return;
  if(Math.abs(P.y) > tolAxisY) return;    // uniquement près de l’axe x
  const x = P.x;
  host._placed[0] = x;
  rep.placeUser('u0', x, 0, '#ef6c00');
  nextIndex = 1;
  mode = 'curve';
  updateChips();
};

// 2) Clic sur la courbe C : trace la verticale pointillée jusqu’à l’image
pathC.addEventListener('click', (ev)=>{
  if(mode!=='curve') return;
  const u_prev = host._placed[nextIndex-1];
  if(typeof u_prev!=='number') return;

  const y = f(u_prev);
  if(!Number.isFinite(y)) return;

  // verticale en pointillés : (u_n,0) -> (u_n,f(u_n))
  const L = rep.drawUserLine(`v-${nextIndex-1}`,'#2e7d32',[{x:u_prev,y:0},{x:u_prev,y:y}]);
  L.setAttribute('stroke-dasharray','6 4');

  imgPt = {x:u_prev, y:y};
  mode = 'diag';
});

// 3) Clic sur la droite D : horizontale vers D puis verticale vers l’axe, place u_{n+1}
lineD.addEventListener('click', (ev)=>{
  if(mode!=='diag' || !imgPt) return;

  const xn1 = imgPt.y; // u_{n+1} = f(u_n)

  // horizontale : (u_n,f(u_n)) -> (f(u_n),f(u_n))
  rep.drawUserLine(`h-${nextIndex-1}`,'#ef6c00',[{x:imgPt.x,y:imgPt.y},{x:xn1,y:xn1}]);

  // verticale : (f(u_n),f(u_n)) -> (f(u_n),0)
  rep.drawUserLine(`vv-${nextIndex-1}`,'#ef6c00',[{x:xn1,y:xn1},{x:xn1,y:0}]);

  // poser u_{n+1} sur l’axe
  rep.placeUser('u'+nextIndex, xn1, 0, '#0a84ff');
  host._placed[nextIndex] = xn1;

  // étape suivante
  nextIndex += 1;
  imgPt = null;
  mode = (nextIndex>=4 ? 'done' : 'curve');
  updateChips();
});


    // Helpers accès
    host.dataset.active=this.id;
    host.dataset.state=JSON.stringify(s);
  },

  correct(host,s){
    const ui = host._ui, rep=ui?.rep;
    const f = buildF(s);
    const U = this._iter(f,s.u0,3);
    const trend = this._trend(U);
    const lim = this._limit(f,s.u0);
const tolPlace = Math.max(0.15, (s.R.xmax - s.R.xmin) / 80); // placements (comme avant)
const tolLim   = TOL_LIMIT;   
    const placed = host._placed || [];
    const tol = Math.max(0.15, (s.R.xmax-s.R.xmin)/80);
const okPlace = placed.length===4 && placed.every((x,i)=>
  typeof x==='number' && isFinite(x) && Math.abs(x - U[i]) <= tolPlace
);    const ansSens = $('#sel-sens',host)?.value || '';
    const okSens = ansSens && ansSens===trend;
    const ansConv = $('#sel-conv',host)?.value || '';
    let okConv=false;
    if(ansConv==='div') okConv = !lim.ok;
    if(ansConv==='conv'){
  const v = parseFloat(($('#in-lim',host)?.value||'').replace(',','.'));
  okConv = lim.ok && (Number.isFinite(v) ? Math.abs(v - lim.L) <= tolLim : true);
}

    const res = ui.res; res.className='steps'; res.innerHTML='';
    const pf = (x)=> this._fmt(x);
    res.innerHTML += `<p><strong>Placements :</strong> ${okPlace?'<span class="res-ok">OK</span>':'<span class="res-ko">à revoir</span>'} — attendu : \\(u_0=${pf(U[0])}\\), \\(u_1=${pf(U[1])}\\), \\(u_2=${pf(U[2])}\\), \\(u_3=${pf(U[3])}\\).</p>`;
    res.innerHTML += `<p><strong>Sens :</strong> ${okSens?'<span class="res-ok">OK</span>':'<span class="res-ko">non</span>'} — attendu : <em>${trend}</em>.</p>`;
    if(ansConv==='div'){ res.innerHTML += `<p><strong>Convergence :</strong> ${okConv?'<span class="res-ok">OK</span>':'<span class="res-ko">non</span>'} — attendu : <em>divergente</em>.</p>`; }
    else if(ansConv==='conv'){
      res.innerHTML += `<p><strong>Convergence :</strong> ${okConv?'<span class="res-ok">OK</span>':'<span class="res-ko">non</span>'} — attendu : <em>convergente</em>${lim.ok?` vers \\(${pf(lim.L)}\\)`:''}.</p>`;
    } else {
      res.innerHTML += `<p><strong>Convergence :</strong> <span class="res-ko">non renseignée</span>.</p>`;
    }
    MJ(res);
    return { ok: okPlace && okSens && okConv };
  },

  solution(host,s){
    const ui=host._ui, rep=ui?.rep;
    const f = buildF(s);
    const U = this._iter(f, s.u0, 3);
    // Placer u0..u3
    rep.placeUser('u0',U[0],0,'#ef6c00');
    rep.placeUser('u1',U[1],0,'#0a84ff');
    rep.placeUser('u2',U[2],0,'#0a84ff');
    rep.placeUser('u3',U[3],0,'#0a84ff');

    // Escargot (toile d’araignée)
// Escargot coloré : rouge + vert
const red   = '#d32f2f';   // axe -> point image
const green = '#2e7d32';   // point image -> droite y=x -> axe

for(let k=0;k<3;k++){
  const xk   = U[k];
  const yk   = f(xk);      // f(u_k)
  const xk1  = U[k+1];     // u_{k+1} = f(u_k)

  // rouge : (u_k,0) -> (u_k, f(u_k))
  rep.drawUserLine(`sol-v-${k}`,  red,   [{x:xk,  y:0},     {x:xk,  y:yk}]);

  // vert : (u_k, f(u_k)) -> (u_{k+1}, u_{k+1})  (horizontal vers y=x)
  rep.drawUserLine(`sol-h-${k}`,  green, [{x:xk,  y:yk},    {x:xk1, y:xk1}]);

  // vert : (u_{k+1}, u_{k+1}) -> (u_{k+1}, 0)  (verticale vers l’axe)
  rep.drawUserLine(`sol-v2-${k}`, green, [{x:xk1, y:xk1},   {x:xk1, y:0}]);
}



    // Texte
    const pf = (x)=> this._fmt(x);
    const res=ui.res; res.className='steps';
    const trend = this._trend(U);
    const lim = this._limit(f, s.u0);
    res.innerHTML = `
      <p>\\(u_1 = f(u_0) \\approx ${pf(U[1])}\\), \\(u_2 = f(u_1) \\approx ${pf(U[2])}\\), \\(u_3 = f(u_2) \\approx ${pf(U[3])}\\).</p>
      <p><strong>Conjecture :</strong> la suite semble <em>${trend}</em>${lim.ok?` et semble converger vers \\(\\ell \\approx ${pf(lim.L)}\\)`:` et ne semble pas converger`}. (lecture graphique)</p>
    `;
    MJ(res);
  },

  reset(host){
    const ui=host._ui; if(!ui) return;
    ui.res.textContent='';
    var __ss=$('#sel-sens',host); if(__ss) __ss.selectedIndex = 0;
    var __sc=$('#sel-conv',host); if(__sc) __sc.selectedIndex = 0;
    var __sl=$('#in-lim',host); if(__sl) __sl.value='';
    ui.rep.clearUser();
host._placed = [null, null, null, null];
host._ui.rep.clickable = true;
host._mode = 'place-u0'; // info utile si tu veux l’exposer
// réactive le guidage visuel
const hintEl = $('.hint', host);
 if(hintEl){
   hintEl.innerHTML = '1) Clique près de l’axe pour placer \\(u_0\\).<br>'+
                      '2) Pour chaque terme suivant : clique <em>sur la courbe C</em> (verticale pointillée), puis <em>sur la droite D : y=x</em> (horizontale + verticale).';
   MJ(hintEl);
 }
// Puces
const chipsHost = host.querySelector('.chips');
if(chipsHost){
  chipsHost.querySelectorAll('.chip').forEach(c=>c.classList.remove('active'));
  const c0 = chipsHost.querySelector('#chip0'); if(c0) c0.classList.add('active');
}
// efface tous les ticks locaux
(host.querySelectorAll('.tick')||[]).forEach(el=> setTick(el,'') );
const inFxEl = host.querySelector('#in-fx'); if(inFxEl) inFxEl.value='';

}
});

// Construit f(x) à partir de l’état s
function buildF(s){
if(s.kind==='sqrt'){ const {p,k}=s.params;
  return x => { const v = p*x + k; return v < 0 ? NaN : Math.sqrt(v); };
}  if(s.kind==='homo1'){ const {a,b,d}=s.params; return (x)=> (x===-d? NaN : (a*x + b)/(x + d)); }
  if(s.kind==='a_minus_b_over'){ const {A,B,E}=s.params; return (x)=> (x===-E? NaN : A - B/(x + E)); }
  if(s.kind==='x_over_x2p1'){ return (x)=> x/(x*x + 1); }
  if(s.kind==='homo2'){ const {m,p,q,r}=s.params; return (x)=> (Math.abs(q*x + r)<1e-9? NaN : (m*x + p)/(q*x + r)); }
  if(s.kind==='affine'){ const {m,p}=s.params; return x => m*x + p; }

  return x=>x;
}

return L;
}

/* ====== Score & cycle ====== */
let scoreOK=0, scoreTot=0; function updateScore(){ $('#score').textContent = `${scoreOK} / ${scoreTot}`; }

function buildOne(){ const sel=$('#exo-select'), host=$('#host'); const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def){ host.textContent='(Aucun exercice)'; return; }
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st);
  $('#res',host).textContent=''; }
function check(){
  const host=$('#host');
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st);
  // ✅ Le score n'avance que quand la réponse est complète ET correcte
  if(r && r.ok){
    scoreOK+=1;
    scoreTot+=1;
    updateScore();
  }
}
function solution(){ const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ scoreOK=0; scoreTot=0; updateScore(); const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def) def.reset(host); }

let REGISTRY=[];
window.REGISTRY = REGISTRY;
window.pickDef = id => (window.REGISTRY||[]).find(d=>d.id===id) || null;

/* Init */
document.addEventListener('DOMContentLoaded',function(){
  try{
    REGISTRY = makeExos();
    window.REGISTRY = REGISTRY;
    const sel=$('#exo-select');
    if(!REGISTRY || !REGISTRY.length){ $('#status').textContent='(Init: aucune entrée)'; return; }
    REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
    sel.addEventListener('change',buildOne);
    $('#btn-new').addEventListener('click',buildOne);
    $('#btn-check').addEventListener('click',check);
    $('#btn-solution').addEventListener('click',solution);
    $('#btn-reset').addEventListener('click',resetAll);
    sel.value=REGISTRY[0].id; buildOne(); updateScore(); $('#status').textContent='(OK)';
  }catch(err){
    console.error(err);
    $('#status').textContent='Erreur d’init : '+(err?.message||err);
  }
});

/* =============== PDF via exo-pdf-kit (hooks) =============== */
window.addEventListener('load', function(){
  if(!(window.ExoPDF && ExoPDF.init)) return;

  // Petit sanitize pour l’énoncé (remplace inputs par lignes, retire boutons/ticks)
  function sanitizeEquHTML(equNode){
    if(!equNode) return '(Énoncé)';
    const clone = equNode.cloneNode(true);
    clone.querySelectorAll('input').forEach(inp=>{
      const w = Math.max(60, parseInt(inp.style.width)||0);
      const span = document.createElement('span');
      span.style.display='inline-block';
      span.style.minWidth = (w||60)+'px';
      span.style.borderBottom='1px solid #000';
      span.style.height='1.1em';
      span.style.verticalAlign='bottom';
      inp.replaceWith(span);
    });
    clone.querySelectorAll('button,.tick').forEach(el=>el.remove());
    return clone.outerHTML;
  }

  // 2 colonnes pour le PDF (50/50)
  function twoCol(leftHTML, rightHTML){
    return `
      <table style="width:100%;border-collapse:collapse;table-layout:fixed">
        <tr>
          <td style="width:50%;vertical-align:top;padding-right:12px">${leftHTML||''}</td>
          <td style="width:50%;vertical-align:top">${rightHTML||''}</td>
        </tr>
      </table>`;
  }

  ExoPDF.init({
    mountAfterSelector: '#info-saisie',
    // ❤️ Le hook clé de ta version du kit
    beforeRender(def, st, isSolution){
      // Monter l’UI hors écran (pas display:none, pour que les tailles existent)
      const host = document.createElement('div');
      host.style.position = 'fixed';
      host.style.left = '-10000px';
      host.style.top = '-10000px';
      host.style.visibility = 'hidden';
      document.body.appendChild(host);

      try{
        // 1) Rendu standard
        def.render(host, st);

        // 2) Cloner le repère (SVG) — helper fourni par le kit
        //    -> on force un carré 340x340 pour être net dans le PDF
        const svgLeft = (typeof window.cloneCurveForPDF==='function')
          ? cloneCurveForPDF(host, { widthPx: 340, heightPx: 340, blockWidth: '100%' })
          : (host.querySelector('svg')?.outerHTML || '(repère manquant)');

        if(!isSolution){
          // ===== ÉNONCÉ =====
          // Priorité au bloc statique .equ-offscreen (évite inputs/placeholders)
          const off = host.querySelector('.equ-offscreen');
          const right = off ? off.innerHTML : sanitizeEquHTML(host.querySelector('.equ'));
          return twoCol(svgLeft, right);
        }else{
          // ===== CORRIGÉ =====
          if (typeof def.solution === 'function') {
            def.solution(host, st);  // dessine l’escargot + remplit #res
          } else if (typeof def.correct === 'function') {
            def.correct(host, st);
          }

          // Re-cloner le repère maintenant qu’il est "corrigé"
          const svgSolved = (typeof window.cloneCurveForPDF==='function')
            ? cloneCurveForPDF(host, { widthPx: 340, heightPx: 340, blockWidth: '100%' })
            : (host.querySelector('svg')?.outerHTML || '');

          // Extraire le texte de correction (#res .steps de ton UI)
          const resNode =
              host.querySelector('#res .steps') ||
              host.querySelector('#res') ||
              host.querySelector('.steps') ||
              host.querySelector('.solution') ||
              host.querySelector('.equ');

          const right = resNode ? (resNode.outerHTML || resNode.innerHTML) : '';
          return twoCol(svgSolved, right);
        }
      } finally {
        host.remove();
      }
    }
  });
});





})(); 
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;
  // clavier math
  if (window.MathKbdInit) MathKbdInit({ mount: document.querySelector('.kbd') });

  // Entrée -> Vérifier
  document.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      const tag = (e.target||{}).tagName||'';
      if (tag === 'INPUT' || tag === 'TEXTAREA') {
        e.preventDefault();
        const btn = document.querySelector('#btn-check');
        if (btn) btn.click();
      }
    }
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
