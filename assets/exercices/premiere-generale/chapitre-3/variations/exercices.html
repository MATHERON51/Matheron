<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Premi√®re ‚Äî Suites num√©riques ‚Äî Sens de variations (LaTeX)</title>

<!-- m√™mes feuilles que ton mod√®le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.55}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr;gap:14px;align-items:start}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:inline-block;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

/* Fractions jolies */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}

@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes √† trous imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input, .blank-wrap select{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
</style>

<!-- MathJax -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- libs partag√©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Premi√®re ‚Äî <strong>Suites num√©riques</strong> ‚Äî Sens de variations</h1>
  </div>

  <div class="wrap">
    <!-- Barre de contr√¥le -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    

    <div class="card">
      <div id="host"></div>
    </div>
<div class="card" id="info-saisie">
      <strong>Saisie & r√©ponses accept√©es</strong>
      <ul class="small" style="margin:.35rem 0 .15rem 1.1rem">
        <li>R√©pondre par : <em>croissante</em>, <em>d√©croissante</em>, <em>constante</em>, ou <em>ni croissante ni d√©croissante</em> (les variantes ¬´ strictement ‚Ä¶ ¬ª sont accept√©es).</li>
        <li>Entr√©e ‚èé d√©clenche <span class="kbd">V√©rifier</span>. Les champs vides ne sanctionnent pas.</li>
      </ul>
    </div>
    <div class="card kbd-host"><div data-math-kbd></div></div>
  </div>

<script>
(function(){
"use strict";

/* ===== Helpers ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
  else { el.textContent=''; }
}
const MINUS = '‚àí';
function cleanSigns(s){
  return String(s)
    .replace(/\u2212/g, MINUS)          // normalise le "‚àí" unicode
    .replace(/\+\s*[‚àí-]\s*/g, ' ‚àí ')    // "+ -" ou "+ ‚àí" -> " ‚àí "
    .replace(/[‚àí-]\s*\+\s*/g, ' ‚àí ')    // "- +" ou "‚àí +" -> " ‚àí "
    .replace(/[‚àí-]\s*[‚àí-]\s*/g, ' + ')  // "--" ou "‚àí ‚àí" -> " + "
    .replace(/\s+/g,' ')
    .trim();
}
function joinPlus(lhs, termLatex){
  let t = String(termLatex).trim();

  // Cas 1 : le terme commence par {-...}  ‚Üí signe n√©gatif dans les accolades
  if (/^\{\s*[‚àí-]/.test(t)) {
    // on enl√®ve le signe √† l'int√©rieur, et on met " ‚àí " devant
    t = t.replace(/^\{\s*[‚àí-]\s*/, '{');
    return `${lhs} ‚àí ${t}`;
  }

  // Cas 2 : le terme commence directement par un signe
  if (/^[‚àí-]/.test(t)) return `${lhs} ‚àí ${t.replace(/^[‚àí-]\s*/, '')}`;
  if (/^\+/.test(t))   return `${lhs} + ${t.replace(/^\+\s*/, '')}`;

  // Cas g√©n√©ral : on ajoute un plus
  return `${lhs} + ${t}`;
}

function toJSExpr(s){
  s = String(s||'')
    .replace(/,/g,'.')
    .replace(/\u2212/g,'-')       // "‚àí" ‚Üí "-"
    .replace(/¬≤/g,'^2').replace(/¬≥/g,'^3')
    .replace(/\^/g,'**')          // puissance
    .replace(/\s+/g,'');
  // multiplications implicites : 2n, n(, )n, n n
  s = s.replace(/(\d)([a-z(])/gi,'$1*$2')
       .replace(/([a-z\)])(\d)/gi,'$1*$2')
       .replace(/([a-z])\(/gi,'$1*(')
       .replace(/\)([a-z])/gi,')*$1')
       .replace(/([a-z])([a-z])/gi,'$1*$2');
	   // Force -n^3 ‚Üí -(n**3) pour √©viter les ambigu√Øt√©s JavaScript
s = s.replace(/^-([a-z0-9(].*)/i, '-($1)');


  return s;
}
function sameExprToFn(expr, fn){
  if(!expr) return false;
  try{
    const F = new Function('n', 'return '+toJSExpr(expr)+';');
    for(let n=0;n<=8;n++){
      const v = F(n);
      if(!Number.isFinite(v) || Math.abs(v - fn(n)) > 1e-9) return false;
    }
    return true;
  }catch(e){ return false; }
}
function numEq(expr, target){
  try{
    const v = Function('"use strict";return ('+toJSExpr(expr)+')')();
    return Number.isFinite(v) && Math.abs(v - target) < 1e-9;
  }catch{ return false; }
}

// --- M√©moire du choix de fonction ---
const LSKEY = {
  e1: 'MatHeron_sensvar_e1_kind',
  e2: 'MatHeron_sensvar_e2_kind'
};
function saveKind(which, val){ try{ localStorage.setItem(LSKEY[which], val); }catch(e){} }
function loadKind(which, def){ try{ return localStorage.getItem(LSKEY[which]) || def; }catch(e){ return def; } }

function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];

function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${(w||160)}px" autocomplete="off"><span class="blank" style="width:${(w||160)-14}px"></span></span>`; }
function mkSelect(id, opts){
  return `<span class="blank-wrap"><select id="${id}">${opts.map(([v,t])=>`<option value="${v}">${t}</option>`).join('')}</select><span class="blank" style="width:80px"></span></span>`;
}
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }

/* Normalisations */
function normTxt(s){
  s = (s||'').toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ').trim();
  // synonymes
  if(/constante?/.test(s)) return 'constante';
  if(/^ni(.*)croiss(.*)ni(.*)decroiss|^ni$/.test(s)) return 'ni';
  if(/decroiss/.test(s)) return 'decroissante';
  if(/croiss/.test(s)) return 'croissante';
  return s;
}
function normSet(s){
  s = (s || '').toString();

  // enl√®ve les espaces
  s = s.replace(/\s/g,'');

  // unifie les infinis : +‚àû, ‚àû, +oo ‚Üí +oo
  s = s.replace(/\+?‚àû/gi, '+oo');

  // ENSEMBLES CLASSIQUES
  if(/^(n|\u2115)$/i.test(s))        return 'N';
  if(/^(n\*|\u2115\*)$/i.test(s))    return 'N*';
  if(/^(r|\u211d)$/i.test(s))        return 'R';

  // R+ : soit "R+", soit un intervalle [0;+oo[
  if(/^r\+$/i.test(s))               return 'R+';
  if(/^\[0;\+oo\[$/i.test(s))        return 'R+';

  // R+* : R+*, R*+, R*+? ou un intervalle ]0;+oo[
  if(/^r\+\*$/i.test(s))             return 'R+*';
  if(/^r\*\+$/i.test(s))             return 'R+*';
  if(/^\]0;\+oo\[$/i.test(s))        return 'R+*';

  // on garde tel quel pour d'autres cas √©ventuels
  return s;
}



/* Fractions jolies (num√©riques) pour la correction */
function fracHTML(p,q){
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg? '‚àí':'')+String(p);
  return (neg? '<span class="frac-sign">‚àí</span>':'' )+
         '<span class="frac"><span class="num">'+p+
         '</span><span class="bar"></span><span class="den">'+q+
         '</span></span>';
}
function labelKindE1(t){
  return { const:'constante', lin:'lin√©aire (m¬∑n)', aff:'affine (m¬∑n + p)',
           sq:'carr√© (n^2)', cu:'cube (n^3)', quadneg:'polyn√¥me (Œî<0)' }[t] || '';
}
function labelKindE2(k){
  return { lineaire:'lin√©aire (m¬∑n)', affine:'affine (m¬∑n + p)', carre:'carr√©e',
           inverse:'inverse (1/n ou 1/(n+k))', poly2:'polyn√¥me du second degr√©' }[k] || '';
}

/* ====== EXERCICES ====== */
function makeExos(){
  const L=[];

  /* =======================================================
     EX. 1 ‚Äî Suite r√©currente : u_{n+1}=u_n+f(n) (UNE SUITE)
     Phrases √† compl√©ter (comme le screen)
  ======================================================= */
  L.push({
    id:'ex1_recurrent_fill',
    title:'Ex. 1 ‚Äî R√©currence : compl√©ter les phrases',
    gen(){
const kindSel = `<select id="e1-kind" style="margin-left:.3rem">
  <option value="mix">m√©lange (al√©atoire)</option>
  <option value="const">constante</option>
  <option value="lin">lin√©aire (m¬∑n)</option>
  <option value="aff">affine (m¬∑n + p)</option>
  <option value="sq">carr√© (n^2)</option>
  <option value="cu">cube (n^3)</option>
  <option value="quadneg">polyn√¥me (Œî<0)</option>
</select>`;




      // tirer une fonction en accord avec le s√©lecteur (ou valeur par d√©faut)
      const pick = ()=>{
  // lit la pr√©f√©rence sauvegard√©e (d√©faut: m√©lange)
  const wanted = $('#e1-kind')?.value || loadKind('e1','mix');
const k = wanted === 'mix'
  ? choice(['const','lin','aff','sq','cu','quadneg'])
  : wanted;
  if(k==='const'){
    const K=rint(-6,6);
    const fLatex=(K<0?'‚àí'+Math.abs(K):String(K));
    return {kind:k, fLatex, info:{type:'const',K}, f:()=>K};
  }
  if(k==='lin'){
    let m=rint(-6,6); if(m===0) m=2;
    const lt=cleanSigns((m<0?'‚àí':'')+(Math.abs(m)===1?'':'{'+Math.abs(m)+'}')+'n');
    return {kind:k, fLatex:lt, info:{type:'lin',m}, f:n=>m*n};
  }
 if (k === 'aff') {
  const m = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);   // m ‚â† 0
  const p = (m > 0 ? 1 : -1) * rint(1,6);              // p de m√™me signe que m
  const mLatex = (m<0?'‚àí':'') + (Math.abs(m)===1?'':'{'+Math.abs(m)+'}');
  const raw = mLatex + 'n' + (p>0 ? ' + ' + p : ' ‚àí ' + Math.abs(p));
  const fLatex = cleanSigns(raw);
  const n0 = -p / m;                                   // < 0
  return { kind:'aff', fLatex, info:{type:'aff', m, p, n0}, f:(n)=>m*n+p };
}


  if(k==='sq'){
    const a=choice([-1,1]);
    return {kind:k, fLatex:(a<0?'‚àí':'')+'n^2', info:{type:'sq',a}, f:n=>a*n*n};
  }
  if(k==='cu'){
    const a=choice([-1,1]);
    return {kind:k, fLatex:(a<0?'‚àí':'')+'n^3', info:{type:'cu',a}, f:n=>a*n*n*n};
  }
  // quadneg : Œî<0
  while(true){
    const a=choice([-3,-2,-1,1,2,3]), b=rint(-5,5), c=rint(-6,6);
    const D=b*b-4*a*c;
    if(D<0){
      const s1=a===1?'':(a===-1?'‚àí':'{'+a+'}');
      const s2=b?(b>0?' + '+b+'n':' ‚àí '+Math.abs(b)+'n'):'';
      const s3=c?(c>0?' + '+c:' ‚àí '+Math.abs(c)):'';
      const latex=cleanSigns(`${s1}n^2${s2}${s3}`);
      return {kind:k, fLatex:latex, info:{type:'quadneg',a,b,c,D}, f:n=>a*n*n+b*n+c};
    }
  }
};


this._obj = pick();
      const o = this._obj;

    
 const bloc1 = `
  <p>Compl√©ter :  ${kindSel}</p>

  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\), on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}
     ${mkSelect('e1s0',[['ge0','‚â• 0'],['le0','‚â§ 0'],['eq0','= 0']])}
     <span id="t_e1_fx1" class="tick"></span>
     <span id="t_e1_s0" class="tick"></span>
  </p>

  <p>
    \\(u_{n+1}\\) ${mkSelect('e1s1',[['ge','‚â•'],['le','‚â§'],['eq','=']])} \\(u_n\\).
    <span id="t_e1_s1" class="tick"></span>
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)}
    <span id="t_e1_class" class="tick"></span>
    sur ${mkInput('e1_txt_set',80)}.
    <span id="t_e1_set" class="tick"></span>
    <span id="t_e1_all" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


      const info = o.info||{};

     
   const bloc2 = `
  <p>Compl√©ter :  ${kindSel}</p>

  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\), on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.
     <span id="t_e1_fx1_q" class="tick"></span>
  </p>

  <p>Il faut chercher le signe de \\(f\\) d√©finie par
     \\(f(n)=\\) ${mkInput('e1_fx2',180)}.
     <span id="t_e1_fx2_q" class="tick"></span>
  </p>
  <p>\\(\\Delta=\\) ${mkInput('e1_D',120)}
     <span id="t_e1_D" class="tick"></span>
     et \\(a\\) ${mkSelect('e1a',[['gt','>0'],['lt','<0']])}.
     <span id="t_e1_a" class="tick"></span>
  </p>
  <p>Ainsi pour tout r√©el \\(n\\),, \\(f(n)\\)
     ${mkSelect('e1signF',[['gt','>0'],['lt','<0']])}.
     <span id="t_e1_signF" class="tick"></span>
  </p>
  <p>
    Donc \\(u_{n+1}\\)
    ${mkSelect('e1s1b',[['ge','>'],['le','<']])} \\(u_n\\).
    <span id="t_e1_s1b" class="tick"></span>
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class2',180)}
    <span id="t_e1_class2" class="tick"></span>
    sur ${mkInput('e1_txt_set2',80)}.
    <span id="t_e1_set2" class="tick"></span>
    <span id="t_e1_all2" class="tick"></span>
  </p>

  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;

const blocAff = `
  <p>Compl√©ter :  ${kindSel}</p>

  <p>On consid√®re pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.</p>

  <p>En r√©solvant \\(f(n)\\le 0\\), on obtient
     \\(n\\), ${mkSelect('e1_ineq_aff', [['le','‚â§'],['ge','‚â•']])}
     ${mkInput('e1_n0',120)}.</p>

  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)}
     sur ${mkInput('e1_txt_set',80)}.
     <span id="t_e1_all_aff" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
  <p>On consid√®re pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      let html = `<div class="row" data-kind="e1">`;
      html += `<div class="statement">`;
      if(info.type==='quadneg') html += bloc2; else html += bloc1;
      html += `</div><div id="steps" class="steps" style="display:none"></div></div>`;

      $('#host').dataset.active = this.id;
      $('#host').innerHTML = html;
	  const selE1 = $('#e1-kind');
if(selE1){
  selE1.value = loadKind('e1','mix');
  selE1.addEventListener('change', ()=>{ saveKind('e1', selE1.value); this.gen(); });
}

      retypeMath($('#host'));
      SCORE=[0,0]; scoreSet(0,0);
	        return this._obj;   // <-- indispensable pour le kit PDF

    },
	
	render(host, st){
  this._obj = st && (st.f || st.info) ? st : (this.gen(), this._obj);
  const o = this._obj, info = o.info || {};
  const kindTxt = labelKindE1(info.type);

  // blocs d‚Äô√©nonc√© SANS <select> (le kit remplacera inputs par des lignes)
  const bloc1 = `
  <p>Compl√©ter :  ${kindSel}</p>

  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\), on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}
     ${mkSelect('e1s0',[['ge0','‚â• 0'],['le0','‚â§ 0'],['eq0','= 0']])}
     <span id="t_e1_fx1" class="tick"></span>
     <span id="t_e1_s0" class="tick"></span>
  </p>

  <p>
    \\(u_{n+1}\\) ${mkSelect('e1s1',[['ge','‚â•'],['le','‚â§'],['eq','=']])} \\(u_n\\).
    <span id="t_e1_s1" class="tick"></span>
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)}
    <span id="t_e1_class" class="tick"></span>
    sur ${mkInput('e1_txt_set',80)}.
    <span id="t_e1_set" class="tick"></span>
    <span id="t_e1_all" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;



     
   const bloc2 = `
  <p>Compl√©ter :  ${kindSel}</p>

  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\), on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.
     <span id="t_e1_fx1_q" class="tick"></span>
  </p>

  <p>Il faut chercher le signe de \\(f\\) d√©finie par
     \\(f(n)=\\) ${mkInput('e1_fx2',180)}.
     <span id="t_e1_fx2_q" class="tick"></span>
  </p>
  <p>\\(\\Delta=\\) ${mkInput('e1_D',120)}
     <span id="t_e1_D" class="tick"></span>
     et \\(a\\) ${mkSelect('e1a',[['gt','>0'],['lt','<0']])}.
     <span id="t_e1_a" class="tick"></span>
  </p>
  <p>Ainsi pour tout r√©el \\(n\\),, \\(f(n)\\)
     ${mkSelect('e1signF',[['gt','>0'],['lt','<0']])}.
     <span id="t_e1_signF" class="tick"></span>
  </p>
  <p>
    Donc \\(u_{n+1}\\)
    ${mkSelect('e1s1b',[['ge','>'],['le','<']])} \\(u_n\\).
    <span id="t_e1_s1b" class="tick"></span>
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class2',180)}
    <span id="t_e1_class2" class="tick"></span>
    sur ${mkInput('e1_txt_set2',80)}.
    <span id="t_e1_set2" class="tick"></span>
    <span id="t_e1_all2" class="tick"></span>
  </p>

  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


const blocAff = `

  <p>On consid√®re pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.</p>

  <p>En r√©solvant \\(f(n)\\le 0\\), on obtient
     \\(n\\), ${mkSelect('e1_ineq_aff', [['le','‚â§'],['ge','‚â•']])}
     ${mkInput('e1_n0',120)}.</p>

  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)}
     sur ${mkInput('e1_txt_set',80)}.
     <span id="t_e1_all_aff" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
  <p>On consid√®re pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

  host.innerHTML =
    `<div class="row" data-kind="e1"><div class="statement">${
        info.type==='quadneg' ? bloc2 : bloc1
     }</div><div id="steps" class="steps" style="display:none"></div></div>`;
  retypeMath(host);
},

 _expect(){
  const o=this._obj, t=o.info.type;

  const signOnN = (fn)=>{
    const vals = Array.from({length:41}, (_,n)=>fn(n)); // n = 0..40
    const allGE0 = vals.every(v => v >= 0);
    const allLE0 = vals.every(v => v <= 0);
    const allEQ0 = vals.every(v => v === 0);
    return { allGE0, allLE0, allEQ0 };
  };

  if(t === 'quadneg'){
    const D = o.info.D, a = o.info.a;
    return {
      mode:'quadneg',
      Delta:D,
      aSign:(a>0?'gt':'lt'),
      signF:(a>0?'gt':'lt'),
      ineq:(a>0?'ge':'le'),
      cls:(a>0?'croissante':'d√©croissante'),
      set:'N'
    };
  }

  // Tous les autres cas (constante, lin√©aire, affine, n¬≤, n¬≥) ‚Üí mode 'basic'
  const S = signOnN(o.f);
  let s0, ineq, cls;
  if(S.allEQ0){ s0='eq0'; ineq='eq'; cls='constante'; }
  else if(S.allGE0){ s0='ge0'; ineq='ge'; cls='croissante'; }
  else if(S.allLE0){ s0='le0'; ineq='le'; cls='d√©croissante'; }
  else { s0='mix'; ineq=''; cls='ni'; } // ne devrait pas arriver
  return { mode:'basic', s0, ineq, cls, set:'N' };
},

check(host){
  if(!this._obj) return;
  const E = this._expect();
  let good = 0, tot = 0;

  /* ========= CAS BASIC (const, lin, affine, n¬≤, n¬≥) ========= */
  if (E.mode === 'basic') {
    const v_fx1   = val('e1_fx1');
    const v_s0    = val('e1s0');
    const v_s1    = val('e1s1');
    const v_cls   = normTxt(val('e1_txt_class'));
    const rawSet  = val('e1_txt_set');
    const v_set   = normSet(rawSet);

    const hasFx1  = v_fx1 !== '';
    const hasS0   = !!v_s0;
    const hasS1   = !!v_s1;
    const hasCls  = v_cls !== '';
    const hasSet  = rawSet.trim() !== '';

    const allFilled = hasFx1 && hasS0 && hasS1 && hasCls && hasSet;

    // u_{n+1}-u_n
    if (hasFx1) {
      const ok = sameExprToFn(v_fx1, this._obj.f);
      tickTri($('#t_e1_fx1',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e1_fx1',host), null);
    }

    // signe de la diff√©rence (select) ‚Üí neutre tant que tout n'est pas rempli
    if (hasS0) {
      const ok = (v_s0 === E.s0);
      tickTri($('#t_e1_s0',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e1_s0',host), null);
    }

    // comparaison u_{n+1} / u_n (select) ‚Üí idem
    if (hasS1) {
      const ok = (v_s1 === E.ineq);
      tickTri($('#t_e1_s1',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e1_s1',host), null);
    }

    // nature de la suite
    if (hasCls) {
      const target = (E.cls === 'ni'
        ? 'ni croissante ni d√©croissante'
        : E.cls);
      const ok = (v_cls === normTxt(target));
      tickTri($('#t_e1_class',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e1_class',host), null);
    }

    // ensemble
    if (hasSet) {
      const ok = (v_set === E.set);
      tickTri($('#t_e1_set',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e1_set',host), null);
    }

    // Tick global : seulement quand tout est rempli
    const expectedBasic = 5; // fx1, s0, s1, class, set
    if (allFilled) {
      tickTri($('#t_e1_all',host), good === expectedBasic);
    } else {
      tickTri($('#t_e1_all',host), null);
    }

    SCORE = [good, tot || 1];
    scoreSet(SCORE[0], SCORE[1]);
    return;
  }

  /* ========= CAS QUADNEG (polyn√¥me Œî<0) ========= */
  if (E.mode === 'quadneg') {
    const v_fx1    = val('e1_fx1');
    const v_fx2    = val('e1_fx2');
    const v_D      = val('e1_D');
    const v_a      = val('e1a');
    const v_signF  = val('e1signF');
    const v_s1b    = val('e1s1b');
    const v_cls2   = normTxt(val('e1_txt_class2'));
    const rawSet2  = val('e1_txt_set2');
    const v_set2   = normSet(rawSet2);

    const hasFx1   = v_fx1 !== '';
    const hasFx2   = v_fx2 !== '';
    const hasD     = v_D !== '';
    const hasA     = !!v_a;
    const hasSignF = !!v_signF;
    const hasS1b   = !!v_s1b;
    const hasCls2  = v_cls2 !== '';
    const hasSet2  = rawSet2.trim() !== '';

    const allFilled = hasFx1 && hasFx2 && hasD && hasA &&
                      hasSignF && hasS1b && hasCls2 && hasSet2;

    // u_{n+1}-u_n
    if (hasFx1) {
      const ok = sameExprToFn(v_fx1, this._obj.f);
      tickTri($('#t_e1_fx1_q',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_fx1_q',host), null);

    // f(n)
    if (hasFx2) {
      const ok = sameExprToFn(v_fx2, this._obj.f);
      tickTri($('#t_e1_fx2_q',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_fx2_q',host), null);

    // Œî
    if (hasD) {
      const ok = Number(v_D) === E.Delta;
      tickTri($('#t_e1_D',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_D',host), null);

    // signe de a (select)
    if (hasA) {
      const ok = (v_a === E.aSign);
      tickTri($('#t_e1_a',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_a',host), null);

    // signe de f (select)
    if (hasSignF) {
      const ok = (v_signF === E.signF);
      tickTri($('#t_e1_signF',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_signF',host), null);

    // comparaison u_{n+1} / u_n (select)
    if (hasS1b) {
      const ok = (v_s1b === E.ineq);
      tickTri($('#t_e1_s1b',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_s1b',host), null);

    // nature
    if (hasCls2) {
      const ok = (v_cls2 === normTxt(E.cls));
      tickTri($('#t_e1_class2',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_class2',host), null);

    // ensemble
    if (hasSet2) {
      const ok = (v_set2 === E.set);
      tickTri($('#t_e1_set2',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e1_set2',host), null);

    const expectedQuad = 8;
    if (allFilled) {
      tickTri($('#t_e1_all2',host), good === expectedQuad);
    } else {
      tickTri($('#t_e1_all2',host), null);
    }

    SCORE = [good, tot || 1];
    scoreSet(SCORE[0], SCORE[1]);
  }
},


solution(host, st){
	  if(st) this._obj = st;          // <-- important pour le PDF

      if(!this._obj) return;
      const o=this._obj, E=this._expect();
      const L=[];
      if(E.mode==='basic'){
        const phraseS0 = (E.s0==='eq0'?'= 0':(E.s0==='ge0'?'‚â• 0':'‚â§ 0'));
        const sym = E.ineq==='ge'?'‚â•':(E.ineq==='le'?'‚â§':'=');
        L.push(`Pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n=${o.fLatex}\\ ${phraseS0}.\\)`);
        L.push(`Donc \\(u_{n+1}\\ ${sym}\\ u_n\\). Ainsi la suite \\((u_n)\\) est \\(\\text{${E.cls==='ni'?'ni croissante ni d√©croissante':E.cls}}\\) sur \\(\\mathbb{N}\\).`);
      }else if (this._obj.info?.type === 'aff') {
  const { m, p, n0 } = this._obj.info;
  const lines = [
  (m>0 ? `Pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n=${o.fLatex}>0\\).`
            : `Pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n=${o.fLatex}<0\\)`),
        ` ` +
      (m>0 ? `Donc \\(u_{n+1}>u_n\\).`
            : `Donc \\(u_{n+1} < u_n\\)`),
    (m>0
      ? `Ainsi la suite \\((u_n)\\) est croissante sur \\(\\mathbb{N}\\).`
      : `Ainsi la suite \\((u_n)\\) est d√©croissante sur \\(\\mathbb{N}\\).`)
  ];
  $('#steps',host).style.display='block';
  $('#steps',host).innerHTML = lines.map(s=>`<div class="step">${s}</div>`).join('');
  retypeMath(host);
  return;
}

else{
        const sym = E.ineq==='ge'?'>':'<';
		L.push(`Il faut chercher le signe de \\(f\\) d√©finie par \\(f(n)=${o.fLatex}\\).`);

        L.push(`\\(\\Delta=b^2-4ac=${E.Delta}&lt;0\\) et \\(a${E.aSign==='gt'?'>':'<'}0\\).`);
        L.push(`Ainsi, pour tout r√©el \\(n\\),, \\(f(n)${E.signF==='gt'?'>':'<'}0\\).`);
        L.push(`Donc pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n${E.signF==='gt'?'>':'<'}0\\) et \\(u_{n+1}\\ ${sym}\\ u_n\\).`);
        L.push(`Ainsi la suite \\((u_n)\\) est \\(\\text{${E.cls}}\\) sur \\(\\mathbb{N}\\).`);
      }
	  
      $('#steps',host).style.display='block';
      $('#steps',host).innerHTML = L.map(s=>`<div class="step">${s}</div>`).join('');
      retypeMath(host);
    }
  });

  /* =======================================================
     EX. 2 ‚Äî Suite explicite : u_n = f(n) (UNE SUITE)
     Phrases √† compl√©ter selon la nature de f
  ======================================================= */
  L.push({
    id:'ex2_explicite_fill',
    title:'Ex. 2 ‚Äî Explicite : compl√©ter les phrases',
    gen(){
const kindSel = `<select id="e2-kind" style="margin-left:.3rem">
  <option value="mix">m√©lange (al√©atoire)</option>
  <option value="lineaire">lin√©aire</option>
  <option value="affine">affine</option>
  <option value="carre">carr√©</option>
  <option value="inverse_n">inverse 1/n</option>
  <option value="inverse_shift">inverse 1/(n + d)</option>
  <option value="poly2">polyn√¥me du second degr√©</option>
</select>`;




      const pick = ()=>{
        const wanted = $('#e2-kind')?.value || loadKind('e2','mix');
        const k = wanted === 'mix'
          ? choice(['lineaire','affine','carre','inverse_n','inverse_shift','poly2'])
          : wanted;

        if(k==='lineaire'){
          let m=rint(-6,6); if(m===0) m=2;     // m ‚â† 0
          const raw=(m<0?'‚àí':'')+(Math.abs(m)===1?'':'{'+Math.abs(m)+'}')+'n';
          const fLatex=cleanSigns(raw);
          return {kind:'lineaire', fLatex, params:{m, p:0}};
        }

        if(k==='affine'){
          let m=rint(-6,6); if(m===0) m=2;
          let p=rint(-6,6); if(p===0) p= rint(1,6); // p ‚â† 0
          const raw=(m<0?'‚àí':'')+(Math.abs(m)===1?'':'{'+Math.abs(m)+'}')+'n'
                    +(p>0?' + '+p:' ‚àí '+Math.abs(p));
          const fLatex=cleanSigns(raw);
          return {kind:'affine', fLatex, params:{m,p}};
        }

        if(k==='carre'){
          return {kind:'carre', fLatex:'n^2', params:{a:1}};
        }

        // === Cas inverse 1/n (d=0) ou 1/(n+d) (d‚â•1) ===
        if(k==='inverse_n' || k==='inverse_shift'){
          const d = (k==='inverse_n') ? 0 : rint(1,4);
          const fLatex = `\\dfrac{1}{n${d?( ' + '+d):''}}`;
          return {kind:'inverse', fLatex, params:{d}};
        }

        // poly2 ‚Äî on force alpha = -b/(2a) < 0 ...
        let a = choice([-2,-1,1,2]);
        let b = (a > 0 ? 1 : -1) * rint(1,5);
        let c = rint(-6,6);
        const fl = cleanSigns(`${a===1?'':(a===-1?'‚àí':a+' ')}n^2${
          b?(b>0?' + '+b+'n':' ‚àí '+Math.abs(b)+'n'):''}${
          c?(c>0?' + '+c:' ‚àí '+Math.abs(c)):''}`);
        const alpha = -b/(2*a);
        return {kind:'poly2', fLatex:fl, params:{a,b,c,alpha}};
      };




this._obj = pick();
      const o=this._obj;

const bloc_lin = `
  <p>Compl√©ter :  ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}
     <span id="t_e2_fk" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)}
     <span id="t_e2_monoF" class="tick"></span>
     sur ${mkInput('e2_f_set',80)}
     <span id="t_e2_setF" class="tick"></span>
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}
     <span id="t_e2_reason" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)}
     <span id="t_e2_monoU" class="tick"></span>
     sur ${mkInput('e2_u_set',80)}
     <span id="t_e2_setU" class="tick"></span>.
     <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


const bloc_aff = `
  <p>Compl√©ter :  ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}
     <span id="t_e2_fk" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)}
     <span id="t_e2_monoF" class="tick"></span>
     sur ${mkInput('e2_f_set',80)}
     <span id="t_e2_setF" class="tick"></span>
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}
     <span id="t_e2_reason" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)}
     <span id="t_e2_monoU" class="tick"></span>
     sur ${mkInput('e2_u_set',80)}
     <span id="t_e2_setU" class="tick"></span>.
     <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


      const artFunc = (o.kind === 'inverse' && o.params?.d > 0) ? 'une' : 'la';

    const bloc_car = `
  <p>Compl√©ter :  ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est ${artFunc} fonction ${mkInput('e2_f_name',120)}.
     <span id="t_e2_name" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2_f_mono2',150)}
     <span id="t_e2_monoF2" class="tick"></span>
     sur ${mkInput('e2_f_set2',80)}
     <span id="t_e2_setF2" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono2',180)}
     <span id="t_e2_monoU2" class="tick"></span>
     sur ${mkInput('e2_u_set2',80)}
     <span id="t_e2_setU2" class="tick"></span>.
     <span id="t_e2_b" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;



      const a=o.params?.a, alpha=o.params?.alpha;
      const bloc_p2 = `
  <p>Compl√©ter : ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est une fonction ${mkInput('e2p_kind',180)}
     <span id="t_e2_kind" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2p_m1',220)}
     <span id="t_e2_m1" class="tick"></span>
     sur ${mkInput('e2p_I1',180)}
     <span id="t_e2_I1" class="tick"></span>
     car ${mkInput('e2p_car',120)}
     <span id="t_e2_car" class="tick"></span>
     et \\(\\alpha=\\) ${mkInput('e2p_alpha',90)}
     <span id="t_e2_alpha" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2p_u',220)}
     <span id="t_e2_u" class="tick"></span>
     sur ${mkInput('e2p_set',80)}
     <span id="t_e2_set" class="tick"></span>.
     <span id="t_e2_c" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


      let html = `<div class="row" data-kind="e2"><div class="statement">`;
      if(o.kind==='affine') html += bloc_aff;
	       else if(o.kind==='lineaire') html += bloc_lin;

      else if(o.kind==='carre' || o.kind==='inverse') html += bloc_car;
      else html += bloc_p2;
      html += `</div><div id="steps" class="steps" style="display:none"></div></div>`;

      $('#host').dataset.active=this.id;
      $('#host').innerHTML=html;
	  const selE2 = $('#e2-kind');
if(selE2){
  selE2.value = loadKind('e2','mix');
  selE2.addEventListener('change', ()=>{ saveKind('e2', selE2.value); this.gen(); });
}

      $('#e2-kind')?.addEventListener('change',()=>this.gen());
      retypeMath($('#host'));
      SCORE=[0,0]; scoreSet(0,0);
	        return this._obj;   // <-- indispensable pour le kit PDF

    },
	
	render(host, st){
  this._obj = st && (st.kind || st.params) ? st : (this.gen(), this._obj);
  const o = this._obj;
  const kindTxt = labelKindE2(o.kind);

  const bloc_lin = `
  <p>Compl√©ter :  ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}
     <span id="t_e2_fk" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)}
     <span id="t_e2_monoF" class="tick"></span>
     sur ${mkInput('e2_f_set',80)}
     <span id="t_e2_setF" class="tick"></span>
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}
     <span id="t_e2_reason" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)}
     <span id="t_e2_monoU" class="tick"></span>
     sur ${mkInput('e2_u_set',80)}
     <span id="t_e2_setU" class="tick"></span>.
     <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


const bloc_aff = `
  <p>Compl√©ter :  ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}
     <span id="t_e2_fk" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)}
     <span id="t_e2_monoF" class="tick"></span>
     sur ${mkInput('e2_f_set',80)}
     <span id="t_e2_setF" class="tick"></span>
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}
     <span id="t_e2_reason" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)}
     <span id="t_e2_monoU" class="tick"></span>
     sur ${mkInput('e2_u_set',80)}
     <span id="t_e2_setU" class="tick"></span>.
     <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;



    const artFunc = (o.kind === 'inverse' && o.params?.d > 0) ? 'une' : 'la';

    const bloc_car = `
  <p>Compl√©ter :  ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est ${artFunc} fonction ${mkInput('e2_f_name',120)}.
     <span id="t_e2_name" class="tick"></span>.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono2',150)}
     <span id="t_e2_monoF2" class="tick"></span>
     sur ${mkInput('e2_f_set2',80)}
     <span id="t_e2_setF2" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono2',180)}
     <span id="t_e2_monoU2" class="tick"></span>
     sur ${mkInput('e2_u_set2',80)}
     <span id="t_e2_setU2" class="tick"></span>.
     <span id="t_e2_b" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


      const a=o.params?.a, alpha=o.params?.alpha;
     const bloc_p2 = `
  <p>Compl√©ter : ${kindSel}</p>
  <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) o√π \\(f\\) est une fonction ${mkInput('e2p_kind',180)}
     <span id="t_e2_kind" class="tick"></span>.
  </p>
  <p>Cette fonction est ${mkInput('e2p_m1',220)}
     <span id="t_e2_m1" class="tick"></span>
     sur ${mkInput('e2p_I1',180)}
     <span id="t_e2_I1" class="tick"></span>
     car ${mkInput('e2p_car',120)}
     <span id="t_e2_car" class="tick"></span>
     et \\(\\alpha=\\) ${mkInput('e2p_alpha',90)}
     <span id="t_e2_alpha" class="tick"></span>.
  </p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2p_u',220)}
     <span id="t_e2_u" class="tick"></span>
     sur ${mkInput('e2p_set',80)}
     <span id="t_e2_set" class="tick"></span>.
     <span id="t_e2_c" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
    <p>On consid√®re pour tout entier naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
    <p>Donner le sens de variations de la suite \\((u_n)\\)</p>
  </div>
`;


  const body =
    o.kind==='lineaire' ? bloc_lin :
    o.kind==='affine'   ? bloc_aff :
    (o.kind==='carre'||o.kind==='inverse') ? bloc_car : bloc_p2;

  host.innerHTML = `<div class="row" data-kind="e2"><div class="statement">${body}</div><div id="steps" class="steps" style="display:none"></div></div>`;
  retypeMath(host);
},

_expect(){
  const o=this._obj;

  // --- fonction lin√©aire m¬∑n ---
  if(o.kind==='lineaire'){
    const m=o.params.m;
    const fKind='lineaire';
    const monoF = m>0?'croissante':(m<0?'d√©croissante':'constante');
    return {
      mode:'lineaire',
      fKind,
      monoF,
      setF:'R+',                 // f sur R+  ‚â° [0;+oo[
      reason:(m>0?'mpos':(m<0?'mneg':'mzero')),
      monoU:monoF,
      setU:'N'                   // suite sur N
    };
  }

  // --- fonction affine m¬∑n + p ---
  if(o.kind==='affine'){
    const m=o.params.m, p=o.params.p;
    const fKind='affine';
    const monoF = m>0?'croissante':(m<0?'d√©croissante':'constante');
    return {
      mode:'affine',
      fKind,
      monoF,
      setF:'R+',                 // idem
      reason:(m>0?'mpos':(m<0?'mneg':'mzero')),
      monoU:monoF,
      setU:'N'
    };
  }

  // --- fonction carr√©e ---
  if(o.kind==='carre'){
    return {
      mode:'carre',
      name:'carr√©e',
      monoF:'croissante',
      setF:'R+',                 // R+ ‚â° [0;+oo[
      reason:'sq',
      monoU:'croissante',
      setU:'N'
    };
  }

  // --- fonction inverse ---
  if(o.kind==='inverse'){
    const d=o.params.d;

    if(d===0){
      // f(x)=1/x : sur ]0;+oo[  ‚â° R+*  ; suite sur N*
      return {
        mode:'inverse',
        name:'inverse',
        monoF:'d√©croissante',
        setF:'R+*',              // R+* ‚â° ]0;+oo[
        reason:'inv',
        monoU:'d√©croissante',
        setU:'N*'
      };
    }

    // d>0 : f(x)=1/(x+d) : sur [0;+oo[ ‚â° R+ ; suite sur N
    return {
      mode:'inverse',
      name:'inverse',
      monoF:'d√©croissante',
      setF:'R+',
      reason:'inv',
      monoU:'d√©croissante',
      setU:'N'
    };
  }

// --- polyn√¥me du second degr√© ---
const a = o.params.a, alpha = o.params.alpha;

// sur R+ : d√©croissante si a<0, croissante si a>0
const monoF = (a > 0 ? 'croissante' : 'd√©croissante');

return {
  mode:'poly2',
  kindLabel:'poly2',          // on ne s‚Äôen sert que comme marqueur
  monoF,                      // d√©croissante ou croissante
  setF:'R+',                  // R+ ‚â° [0;+oo[
  car:(a>0?'a>0':'a<0'),
  alpha: alpha,               // < 0
  u:(a>0 ? 'croissante' : 'd√©croissante'),
  set:'N'
};

}
,
check(host){
  if(!this._obj) return;
  const E = this._expect();
  let good = 0, tot = 0;

  /* ===== LIN√âAIRE / AFFINE ===== */
  if (E.mode === 'lineaire' || E.mode === 'affine') {
    const v_fk     = normTxt(val('e2_f_kind'));
    const v_monoF  = normTxt(val('e2_f_mono'));
    const rawSetF  = val('e2_f_set');
    const v_setF   = normSet(rawSetF);
    const v_reason = val('e2_reason_m');
    const v_monoU  = normTxt(val('e2_u_mono'));
    const rawSetU  = val('e2_u_set');
    const v_setU   = normSet(rawSetU);

    const hasFk     = v_fk !== '';
    const hasMonoF  = v_monoF !== '';
    const hasSetF   = rawSetF.trim() !== '';
    const hasReason = !!v_reason;
    const hasMonoU  = v_monoU !== '';
    const hasSetU   = rawSetU.trim() !== '';

    const allFilled = hasFk && hasMonoF && hasSetF && hasReason && hasMonoU && hasSetU;

    // f_kind
    if (hasFk){
      const ok = (v_fk === E.fKind);
      tickTri($('#t_e2_fk',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_fk',host), null);

    // f_mono
    if (hasMonoF){
      const ok = (v_monoF === normTxt(E.monoF));
      tickTri($('#t_e2_monoF',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_monoF',host), null);

    // set f
    if (hasSetF){
      const ok = (v_setF === E.setF);
      tickTri($('#t_e2_setF',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_setF',host), null);

    // reason (select) ‚Üí neutre tant que tout n'est pas rempli
    if (hasReason){
      const ok = (v_reason === E.reason);
      tickTri($('#t_e2_reason',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_reason',host), null);

    // u_mono
    if (hasMonoU){
      const ok = (v_monoU === normTxt(E.monoU));
      tickTri($('#t_e2_monoU',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_monoU',host), null);

    // set u
    if (hasSetU){
      const ok = (v_setU === E.setU);
      tickTri($('#t_e2_setU',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_setU',host), null);

    // tick global
    if (allFilled){
      const expected = 6;
      tickTri($('#t_e2_a',host), good === expected);
    } else {
      tickTri($('#t_e2_a',host), null);
    }

    SCORE = [good, tot || 1];
    scoreSet(SCORE[0], SCORE[1]);
    return;
  }

  /* ===== CARR√â / INVERSE ===== */
  if (E.mode === 'carre' || E.mode === 'inverse') {
    const v_name    = normTxt(val('e2_f_name'));
    const v_monoF2  = normTxt(val('e2_f_mono2'));
    const rawSetF2  = val('e2_f_set2');
    const v_setF2   = normSet(rawSetF2);
    const v_reason2 = val('e2_reason_ci');
    const v_monoU2  = normTxt(val('e2_u_mono2'));
    const rawSetU2  = val('e2_u_set2');
    const v_setU2   = normSet(rawSetU2);

    const hasName    = v_name !== '';
    const hasMonoF2  = v_monoF2 !== '';
    const hasSetF2   = rawSetF2.trim() !== '';
    const hasReason2 = !!v_reason2;
    const hasMonoU2  = v_monoU2 !== '';
    const hasSetU2   = rawSetU2.trim() !== '';

    const allFilled = hasName && hasMonoF2 && hasSetF2 && hasMonoU2 && hasSetU2;

    if (hasName){
      const ok = (v_name === normTxt(E.name));
      tickTri($('#t_e2_name',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_name',host), null);

    if (hasMonoF2){
      const ok = (v_monoF2 === normTxt(E.monoF));
      tickTri($('#t_e2_monoF2',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_monoF2',host), null);

    if (hasSetF2){
      const ok = (v_setF2 === E.setF);
      tickTri($('#t_e2_setF2',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_setF2',host), null);

    if (hasReason2){
      const ok = (v_reason2 === E.reason);
      tickTri($('#t_e2_reason2',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_reason2',host), null);

    if (hasMonoU2){
      const ok = (v_monoU2 === normTxt(E.monoU));
      tickTri($('#t_e2_monoU2',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_monoU2',host), null);

    if (hasSetU2){
      const ok = (v_setU2 === E.setU);
      tickTri($('#t_e2_setU2',host), ok);
      tot++; if (ok) good++;
    } else tickTri($('#t_e2_setU2',host), null);

    if (allFilled){
      const expected = hasReason2 ? 6 : 5;
      tickTri($('#t_e2_b',host), good === expected);
    } else {
      tickTri($('#t_e2_b',host), null);
    }

    SCORE = [good, tot || 1];
    scoreSet(SCORE[0], SCORE[1]);
    return;
  }

  /* ===== POLYN√îME 2·µâ DEGR√â ===== */
  if (E.mode === 'poly2') {
    // valeurs brutes
    const rawKind  = val('e2p_kind');
    const rawM1    = val('e2p_m1');
    const rawI1    = val('e2p_I1');
    const rawCar   = val('e2p_car');
    const rawAlpha = val('e2p_alpha');
    const rawU     = val('e2p_u');
    const rawSet   = val('e2p_set');

    // valeurs normalis√©es
    const v_kind = normTxt(rawKind);
    const v_m1   = normTxt(rawM1);
    const v_I1   = normSet(rawI1);     // IMPORTANT : on passe par normSet ici
    const v_car  = normTxt(rawCar);
    const v_u    = normTxt(rawU);
    const v_set  = normSet(rawSet);

    const hasKind  = rawKind.trim()  !== '';
    const hasM1    = rawM1.trim()    !== '';
    const hasI1    = rawI1.trim()    !== '';
    const hasCar   = rawCar.trim()   !== '';
    const hasAlpha = rawAlpha.trim() !== '';
    const hasU     = rawU.trim()     !== '';
    const hasSet   = rawSet.trim()   !== '';

    const allFilled = hasKind && hasM1 && hasI1 && hasCar &&
                      hasAlpha && hasU && hasSet;

    // 1) Type de fonction : accepter plusieurs formulations
    if (hasKind) {
      const ok = [
        'trinome',
        'polynome du second degre',
        'polynome 2nd degre',
        '2nd degre',
        'second degre'
      ].includes(v_kind);
      tickTri($('#t_e2_kind',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_kind',host), null);
    }

    // 2) Monotonie de f (croissante / d√©croissante)
    if (hasM1) {
      const ok = (v_m1 === normTxt(E.monoF)); // E.monoF = 'croissante' ou 'd√©croissante'
      tickTri($('#t_e2_m1',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_m1',host), null);
    }

    // 3) Intervalle / ensemble de d√©finition de f : R+ ou [0;+oo[
    if (hasI1) {
      const ok = (v_I1 === E.setF);           // E.setF doit valoir 'R+'
      tickTri($('#t_e2_I1',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_I1',host), null);
    }

    // 4) ¬´ car a>0 ¬ª ou ¬´ car a<0 ¬ª
    if (hasCar) {
      const ok = (v_car === normTxt(E.car));  // E.car = 'a>0' ou 'a<0'
      tickTri($('#t_e2_car',host), allFilled ? ok : null);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_car',host), null);
    }

    // 5) Œ±
    if (hasAlpha) {
      const aNum = parseFloat(rawAlpha.replace(',','.'));
      const ok = (!isNaN(aNum) && Math.abs(aNum - E.alpha) < 1e-9);
      tickTri($('#t_e2_alpha',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_alpha',host), null);
    }

    // 6) Monotonie de la suite
    if (hasU) {
      const ok = (v_u === normTxt(E.u));      // 'croissante' ou 'd√©croissante'
      tickTri($('#t_e2_u',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_u',host), null);
    }

    // 7) Ensemble de d√©finition de la suite : N
    if (hasSet) {
      const ok = (v_set === E.set);           // 'N'
      tickTri($('#t_e2_set',host), ok);
      tot++; if (ok) good++;
    } else {
      tickTri($('#t_e2_set',host), null);
    }

    // Tick global : seulement si tout est rempli
    if (allFilled) {
      const expected = 7;
      tickTri($('#t_e2_c',host), good === expected);
    } else {
      tickTri($('#t_e2_c',host), null);
    }

    SCORE = [good, tot || 1];
    scoreSet(SCORE[0], SCORE[1]);
  }

},


solution(host, st){
	  if(st) this._obj = st;          // <-- important pour le PDF

      if(!this._obj) return;
      const E=this._expect(), o=this._obj;
      const L=[];
      if(E.mode==='lineaire'){
  L.push(`\\(u_n=f(n)=${o.fLatex}.\\)`);
  L.push(`\\(f\\) est une fonction lin√©aire. Comme \\(m=${o.params.m}\\), la fonction est ${E.monoF} sur \\([0; +\\infty[\\).`);
  L.push(`Donc la suite \\((u_n)\\) est ${E.monoU} sur \\(\\mathbb{N}\\).`);
}
else if(E.mode==='affine'){
  L.push(`\\(u_n=f(n)=${o.fLatex}.\\)`);
  L.push(`\\(f\\) est une fonction affine. Comme \\(m=${o.params.m}\\), la fonction est ${E.monoF} sur \\([0; +\\infty[\\).`);
  L.push(`Donc la suite \\((u_n)\\) est ${E.monoU} sur \\(\\mathbb{N}\\).`);
}
else if(this._obj.kind==='carre'){
  L.push(`\\(u_n=f(n)=n^2.\\)`);
  L.push(`La fonction carr√©e est croissante sur \\([0; +\\infty[\\).`);
  L.push(`Ainsi \\((u_n)\\) est croissante sur \\(\\mathbb{N}\\).`);
}
else if(this._obj.kind==='inverse'){
  const d=o.params.d;
  L.push(`\\(u_n=f(n)=\\dfrac{1}{n${d?(d>0?' + '+d:' ‚àí '+Math.abs(d)):''}}.\\)`);
  if(d===0){
    L.push(`La fonction inverse est d√©croissante sur \\(]0; +\\infty[\\).`);
    L.push(`Ainsi \\((u_n)\\) est d√©croissante sur \\(\\mathbb{N}^*\\).`);
  }else{
    L.push(`La fonction \\(f\\) est d√©croissante sur \\([0; +\\infty[\\),`);
    L.push(`la suite \\((u_n)\\) est d√©croissante sur \\(\\mathbb{N}\\).`);
  }
}
else { // poly2
  const a = o.params.a, alpha = o.params.alpha; // alpha<0
  L.push(`\\(u_n=f(n)=${o.fLatex}.\\)`);
  L.push(`\\(f\\) est une fonction polyn√¥me du second degr√© avec \\(a=${a}\\) et \\(\\alpha=-\\dfrac{b}{2a}=${alpha}<0\\).`);
  // Sur [0; +‚àû[, f est monotone car le sommet est √† gauche de 0
  if(a>0){
    L.push(`Comme \\(a>0\\), \\(f\\) est croissante sur \\([\\alpha ; +\\infty[\\) donc sur \\([0 ; +\\infty[\\).`);
    L.push(`Donc la suite \\((u_n)\\) est croissante sur \\(\\mathbb{N}\\).`);
  }else{
    L.push(`Comme \\(a<0\\), \\(f\\) est d√©croissante sur \\([\\alpha ; +\\infty[\\) donc sur \\([0 ; +\\infty[\\).`);
    L.push(`Donc la suite \\((u_n)\\) est d√©croissante sur \\(\\mathbb{N}\\).`);
  }
}


      $('#steps',host).style.display='block';
      $('#steps',host).innerHTML = L.map(s=>`<div class="step">${s}</div>`).join('');
      retypeMath(host);
    }
  });

  return L;
}

/* ===== REGISTRY & UI ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY;

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.gen();
  }catch(err){
    console.error('[renderActiveSafe]', source, err);
    host.innerHTML = '<p style="color:#b00020">Une erreur est survenue lors du rendu de l‚Äôexercice.</p>';
  }
}

function attachSelectHandlers(){
  const sel=document.querySelector('#exo-select');
  if(!sel) return;
  sel.addEventListener('change', ()=>renderActiveSafe('select'));
}

/* Entr√©e ‚Üí V√©rifier (toute la page) */
window.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){
    e.preventDefault();
    $('#btn-check')?.click();
  }
});

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });


  // init PDF quand REGISTRY pr√™t
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: 'Premi√®re ‚Äî Suites num√©riques ‚Äî Sens de variations',
        max: 50,
        mountAfterSelector: '#info-saisie',
        autoPrint: false
      });
    } else {
      setTimeout(waitForPDF, 60);
    }
  })();
});

// Rattrapage : si une page externe attend #steps au clic "Solution"
(function(){
  const origAddEvent = Element.prototype.addEventListener;
  Element.prototype.addEventListener = function(type, listener, opts){
    if(type==='click' && this.id==='btn-sol'){
      const host=document.querySelector('#host');
      const def = window.REGISTRY.find(e => e.id === host.dataset.active);
      if(def && typeof def.solution==='function'){
        const _old = def.solution;
        def.solution = function(host){
          const W = host.querySelector('#steps');
          if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
          return _old.call(this, host);
        };
      }
    }
    return origAddEvent.call(this, type, listener, opts);
  };
})();
})(); // IIFE
</script>
</body>
</html>
