<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Première — Suites numériques — Sens de variations (LaTeX)</title>

<!-- mêmes feuilles que ton modèle -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.55}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr;gap:14px;align-items:start}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:inline-block;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

/* Fractions jolies */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}

@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes à trous imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input, .blank-wrap select{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
</style>

<!-- MathJax -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<!-- libs partagées -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Première — <strong>Suites numériques</strong> — Sens de variations</h1>
  </div>

  <div class="wrap">
    <!-- Barre de contrôle -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-sol" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    

    <div class="card">
      <div id="host"></div>
    </div>
<div class="card" id="info-saisie">
      <strong>Saisie & réponses acceptées</strong>
      <ul class="small" style="margin:.35rem 0 .15rem 1.1rem">
        <li>Répondre par : <em>croissante</em>, <em>décroissante</em>, <em>constante</em>, ou <em>ni croissante ni décroissante</em> (les variantes « strictement … » sont acceptées).</li>
        <li>Entrée ⏎ déclenche <span class="kbd">Vérifier</span>. Les champs vides ne sanctionnent pas.</li>
      </ul>
    </div>
    <div class="card kbd-host"><div data-math-kbd></div></div>
  </div>

<script>
(function(){
"use strict";

/* ===== Helpers ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='✓'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='✗'; }
  else { el.textContent=''; }
}
const MINUS = '−';
function cleanSigns(s){
  return String(s)
    .replace(/\u2212/g, MINUS)          // normalise le "−" unicode
    .replace(/\+\s*[−-]\s*/g, ' − ')    // "+ -" ou "+ −" -> " − "
    .replace(/[−-]\s*\+\s*/g, ' − ')    // "- +" ou "− +" -> " − "
    .replace(/[−-]\s*[−-]\s*/g, ' + ')  // "--" ou "− −" -> " + "
    .replace(/\s+/g,' ')
    .trim();
}
function joinPlus(lhs, termLatex){
  let t = String(termLatex).trim();

  // Cas 1 : le terme commence par {-...}  → signe négatif dans les accolades
  if (/^\{\s*[−-]/.test(t)) {
    // on enlève le signe à l'intérieur, et on met " − " devant
    t = t.replace(/^\{\s*[−-]\s*/, '{');
    return `${lhs} − ${t}`;
  }

  // Cas 2 : le terme commence directement par un signe
  if (/^[−-]/.test(t)) return `${lhs} − ${t.replace(/^[−-]\s*/, '')}`;
  if (/^\+/.test(t))   return `${lhs} + ${t.replace(/^\+\s*/, '')}`;

  // Cas général : on ajoute un plus
  return `${lhs} + ${t}`;
}

function toJSExpr(s){
  s = String(s||'')
    .replace(/,/g,'.')
    .replace(/\u2212/g,'-')       // "−" → "-"
    .replace(/²/g,'^2').replace(/³/g,'^3')
    .replace(/\^/g,'**')          // puissance
    .replace(/\s+/g,'');
  // multiplications implicites : 2n, n(, )n, n n
  s = s.replace(/(\d)([a-z(])/gi,'$1*$2')
       .replace(/([a-z\)])(\d)/gi,'$1*$2')
       .replace(/([a-z])\(/gi,'$1*(')
       .replace(/\)([a-z])/gi,')*$1')
       .replace(/([a-z])([a-z])/gi,'$1*$2');
  return s;
}
function sameExprToFn(expr, fn){
  if(!expr) return false;
  try{
    const F = new Function('n', 'return '+toJSExpr(expr)+';');
    for(let n=0;n<=8;n++){
      const v = F(n);
      if(!Number.isFinite(v) || Math.abs(v - fn(n)) > 1e-9) return false;
    }
    return true;
  }catch(e){ return false; }
}
function numEq(expr, target){
  try{
    const v = Function('"use strict";return ('+toJSExpr(expr)+')')();
    return Number.isFinite(v) && Math.abs(v - target) < 1e-9;
  }catch{ return false; }
}

// --- Mémoire du choix de fonction ---
const LSKEY = {
  e1: 'MatHeron_sensvar_e1_kind',
  e2: 'MatHeron_sensvar_e2_kind'
};
function saveKind(which, val){ try{ localStorage.setItem(LSKEY[which], val); }catch(e){} }
function loadKind(which, def){ try{ return localStorage.getItem(LSKEY[which]) || def; }catch(e){ return def; } }

function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];

function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${(w||160)}px" autocomplete="off"><span class="blank" style="width:${(w||160)-14}px"></span></span>`; }
function mkSelect(id, opts){
  return `<span class="blank-wrap"><select id="${id}">${opts.map(([v,t])=>`<option value="${v}">${t}</option>`).join('')}</select><span class="blank" style="width:80px"></span></span>`;
}
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }

/* Normalisations */
function normTxt(s){
  s = (s||'').toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ').trim();
  // synonymes
  if(/constante?/.test(s)) return 'constante';
  if(/^ni(.*)croiss(.*)ni(.*)decroiss|^ni$/.test(s)) return 'ni';
  if(/decroiss/.test(s)) return 'decroissante';
  if(/croiss/.test(s)) return 'croissante';
  return s;
}
function normSet(s){
  s = s.replace(/\s/g,'');
  if(/^(n|\u2115)$/.test(s)) return 'N';
  if(/^(n\*|\u2115\*)$/.test(s)) return 'N*';
  if(/^(r|\u211d)$/.test(s)) return 'R';
  if(/^r\+$/.test(s)) return 'R+';
  if(/^r\+\*$/.test(s)) return 'R+*';
  return s;
}

/* Fractions jolies (numériques) pour la correction */
function fracHTML(p,q){
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg? '−':'')+String(p);
  return (neg? '<span class="frac-sign">−</span>':'' )+
         '<span class="frac"><span class="num">'+p+
         '</span><span class="bar"></span><span class="den">'+q+
         '</span></span>';
}
function labelKindE1(t){
  return { const:'constante', lin:'linéaire (m·n)', aff:'affine (m·n + p)',
           sq:'carré (n^2)', cu:'cube (n^3)', quadneg:'polynôme (Δ<0)' }[t] || '';
}
function labelKindE2(k){
  return { lineaire:'linéaire (m·n)', affine:'affine (m·n + p)', carre:'carrée',
           inverse:'inverse (1/n ou 1/(n+k))', poly2:'polynôme du second degré' }[k] || '';
}

/* ====== EXERCICES ====== */
function makeExos(){
  const L=[];

  /* =======================================================
     EX. 1 — Suite récurrente : u_{n+1}=u_n+f(n) (UNE SUITE)
     Phrases à compléter (comme le screen)
  ======================================================= */
  L.push({
    id:'ex1_recurrent_fill',
    title:'Ex. 1 — Récurrence : compléter les phrases',
    gen(){
const kindSel = `<select id="e1-kind" style="margin-left:.3rem">
  <option value="mix">mélange (aléatoire)</option>
  <option value="const">constante</option>
  <option value="lin">linéaire (m·n)</option>
  <option value="aff">affine (m·n + p)</option>
  <option value="sq">carré (n^2)</option>
  <option value="cu">cube (n^3)</option>
  <option value="quadneg">polynôme (Δ<0)</option>
</select>`;




      // tirer une fonction en accord avec le sélecteur (ou valeur par défaut)
      const pick = ()=>{
  // lit la préférence sauvegardée (défaut: mélange)
  const wanted = $('#e1-kind')?.value || loadKind('e1','mix');
const k = wanted === 'mix'
  ? choice(['const','lin','aff','sq','cu','quadneg'])
  : wanted;
  if(k==='const'){
    const K=rint(-6,6);
    const fLatex=(K<0?'−'+Math.abs(K):String(K));
    return {kind:k, fLatex, info:{type:'const',K}, f:()=>K};
  }
  if(k==='lin'){
    let m=rint(-6,6); if(m===0) m=2;
    const lt=cleanSigns((m<0?'−':'')+(Math.abs(m)===1?'':'{'+Math.abs(m)+'}')+'n');
    return {kind:k, fLatex:lt, info:{type:'lin',m}, f:n=>m*n};
  }
 if (k === 'aff') {
  const m = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);   // m ≠ 0
  const p = (m > 0 ? 1 : -1) * rint(1,6);              // p de même signe que m
  const mLatex = (m<0?'−':'') + (Math.abs(m)===1?'':'{'+Math.abs(m)+'}');
  const raw = mLatex + 'n' + (p>0 ? ' + ' + p : ' − ' + Math.abs(p));
  const fLatex = cleanSigns(raw);
  const n0 = -p / m;                                   // < 0
  return { kind:'aff', fLatex, info:{type:'aff', m, p, n0}, f:(n)=>m*n+p };
}


  if(k==='sq'){
    const a=choice([-1,1]);
    return {kind:k, fLatex:(a<0?'−':'')+'n^2', info:{type:'sq',a}, f:n=>a*n*n};
  }
  if(k==='cu'){
    const a=choice([-1,1]);
    return {kind:k, fLatex:(a<0?'−':'')+'n^3', info:{type:'cu',a}, f:n=>a*n*n*n};
  }
  // quadneg : Δ<0
  while(true){
    const a=choice([-3,-2,-1,1,2,3]), b=rint(-5,5), c=rint(-6,6);
    const D=b*b-4*a*c;
    if(D<0){
      const s1=a===1?'':(a===-1?'−':'{'+a+'}');
      const s2=b?(b>0?' + '+b+'n':' − '+Math.abs(b)+'n'):'';
      const s3=c?(c>0?' + '+c:' − '+Math.abs(c)):'';
      const latex=cleanSigns(`${s1}n^2${s2}${s3}`);
      return {kind:k, fLatex:latex, info:{type:'quadneg',a,b,c,D}, f:n=>a*n*n+b*n+c};
    }
  }
};


this._obj = pick();
      const o = this._obj;

    
const bloc1 = `
  <p>Compléter :  ${kindSel}</p>

<p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}
     ${mkSelect('e1s0',[['ge0','≥ 0'],['le0','≤ 0'],['eq0','= 0']])}
  </p>

  <p>
    \\(u_{n+1}\\) ${mkSelect('e1s1',[['ge','≥'],['le','≤'],['eq','=']])} \\(u_n\\).
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)} sur ${mkInput('e1_txt_set',80)}.
    <span id="t_e1_all" class="tick"></span>
  </p>
    <div class="equ-offscreen" style="display:none">
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      const info = o.info||{};
     const bloc2 = `
  <p>Compléter :  ${kindSel}</p>
    <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.</p>

  <p>Il faut chercher le signe de \\(f\\) définie par
     \\(f(n)=\\) ${mkInput('e1_fx2',180)}.</p>
  <p>\\(\\Delta=\\) ${mkInput('e1_D',120)} et \\(a\\) ${mkSelect('e1a',[['gt','>0'],['lt','<0']])}.</p>
  <p>Ainsi pour tout réel \\(n\\),, \\(f(n)\\) ${mkSelect('e1signF',[['gt','>0'],['lt','<0']])}.</p>
  <p>
    Donc \\(u_{n+1}\\) ${mkSelect('e1s1b',[['ge','>'],['le','<']])} \\(u_n\\).
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class2',180)} sur ${mkInput('e1_txt_set2',80)}.
    <span id="t_e1_all2" class="tick"></span>
  </p>
    <div class="equ-offscreen" style="display:none">
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

const blocAff = `
  <p>Compléter :  ${kindSel}</p>

  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.</p>

  <p>En résolvant \\(f(n)\\le 0\\), on obtient
     \\(n\\), ${mkSelect('e1_ineq_aff', [['le','≤'],['ge','≥']])}
     ${mkInput('e1_n0',120)}.</p>

  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)}
     sur ${mkInput('e1_txt_set',80)}.
     <span id="t_e1_all_aff" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      let html = `<div class="row" data-kind="e1">`;
      html += `<div class="statement">`;
      if(info.type==='quadneg') html += bloc2; else html += bloc1;
      html += `</div><div id="steps" class="steps" style="display:none"></div></div>`;

      $('#host').dataset.active = this.id;
      $('#host').innerHTML = html;
	  const selE1 = $('#e1-kind');
if(selE1){
  selE1.value = loadKind('e1','mix');
  selE1.addEventListener('change', ()=>{ saveKind('e1', selE1.value); this.gen(); });
}

      retypeMath($('#host'));
      SCORE=[0,0]; scoreSet(0,0);
	        return this._obj;   // <-- indispensable pour le kit PDF

    },
	
	render(host, st){
  this._obj = st && (st.f || st.info) ? st : (this.gen(), this._obj);
  const o = this._obj, info = o.info || {};
  const kindTxt = labelKindE1(info.type);

  // blocs d’énoncé SANS <select> (le kit remplacera inputs par des lignes)
  const bloc1 = `

<p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}
     ${mkSelect('e1s0',[['ge0','≥ 0'],['le0','≤ 0'],['eq0','= 0']])}
  </p>

  <p>
    \\(u_{n+1}\\) ${mkSelect('e1s1',[['ge','≥'],['le','≤'],['eq','=']])} \\(u_n\\).
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)} sur ${mkInput('e1_txt_set',80)}.
    <span id="t_e1_all" class="tick"></span>
  </p>
    <div class="equ-offscreen" style="display:none">
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


     
     const bloc2 = `
    <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.</p>

  <p>Il faut chercher le signe de \\(f\\) définie par
     \\(f(n)=\\) ${mkInput('e1_fx2',180)}.</p>
  <p>\\(\\Delta=\\) ${mkInput('e1_D',120)} et \\(a\\) ${mkSelect('e1a',[['gt','>0'],['lt','<0']])}.</p>
  <p>Ainsi pour tout réel \\(n\\),, \\(f(n)\\) ${mkSelect('e1signF',[['gt','>0'],['lt','<0']])}.</p>
  <p>
    Donc \\(u_{n+1}\\) ${mkSelect('e1s1b',[['ge','>'],['le','<']])} \\(u_n\\).
    Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class2',180)} sur ${mkInput('e1_txt_set2',80)}.
    <span id="t_e1_all2" class="tick"></span>
  </p>
    <div class="equ-offscreen" style="display:none">
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

const blocAff = `

  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>Pour tout entier naturel \\(n\\),, on a :
     \\(u_{n+1}-u_n =\\) ${mkInput('e1_fx1',180)}.</p>

  <p>En résolvant \\(f(n)\\le 0\\), on obtient
     \\(n\\), ${mkSelect('e1_ineq_aff', [['le','≤'],['ge','≥']])}
     ${mkInput('e1_n0',120)}.</p>

  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e1_txt_class',180)}
     sur ${mkInput('e1_txt_set',80)}.
     <span id="t_e1_all_aff" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_{n+1}=${joinPlus('u_n', o.fLatex)}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

  host.innerHTML =
    `<div class="row" data-kind="e1"><div class="statement">${
        info.type==='quadneg' ? bloc2 : bloc1
     }</div><div id="steps" class="steps" style="display:none"></div></div>`;
  retypeMath(host);
},

    _expect(){
  const o=this._obj, t=o.info.type;

  const signOnN = (fn)=>{
    const vals = Array.from({length:41}, (_,n)=>fn(n)); // n = 0..40
    const allGE0 = vals.every(v => v >= 0);
    const allLE0 = vals.every(v => v <= 0);
    const allEQ0 = vals.every(v => v === 0);
    return { allGE0, allLE0, allEQ0 };
  };
if (t === 'aff') {
  return {
    mode: 'aff',
    n0: this._obj.info.n0,   // < 0
    cls: 'croissante',       // m>0 et p>0 ⇒ f(n)=mn+p > 0 pour tout n∈ℕ
    set: 'N'
  };
}

  if(t==='quadneg'){
    const D=o.info.D, a=o.info.a;
    return {
      mode:'quadneg',
      Delta:D,
      aSign:(a>0?'gt':'lt'),
      signF:(a>0?'gt':'lt'),
      ineq:(a>0?'ge':'le'),
      cls:(a>0?'croissante':'décroissante'),
      set:'N'
    };
  }else{
    const S = signOnN(o.f);
    let s0, ineq, cls;
    if(S.allEQ0){ s0='eq0'; ineq='eq'; cls='constante'; }
    else if(S.allGE0){ s0='ge0'; ineq='ge'; cls='croissante'; }
    else if(S.allLE0){ s0='le0'; ineq='le'; cls='décroissante'; }
    else { s0='mix'; ineq=''; cls='ni'; } // (ne devrait pas arriver avec nos familles)
    return { mode:'basic', s0, ineq, cls, set:'N' };
  }
}
,
    check(host){
      if(!this._obj) return;
      const E=this._expect();
      let ok=true, tot=0, good=0;

      if(E.mode==='basic'){
  // 6 vérifications : f0, f1, signe, inégalité, nature, ensemble
  const okfx0 = sameExprToFn(val('e1_fx0'), this._obj.f);
  const okfx1 = sameExprToFn(val('e1_fx1'), this._obj.f);
  const ok_s0 = (val('e1s0') && val('e1s0')===E.s0);
  const ok_s1 = (val('e1s1') && val('e1s1')===E.ineq);
  const ok_cls = (normTxt(val('e1_txt_class'))===E.cls);
  const ok_set = (normSet(val('e1_txt_set'))===E.set);

  tickTri($('#t_e1_all',host), okfx0 && okfx1 && ok_s0 && ok_s1 && ok_cls && ok_set);

  const good = [okfx0,okfx1,ok_s0,ok_s1,ok_cls,ok_set].filter(Boolean).length;
  SCORE=[good,6]; scoreSet(SCORE[0],SCORE[1]);
}
else if (E.mode === 'aff') {
  // si un e1_fx0 existe (selon ta version), on le corrige ; sinon on l’ignore
  const okfx0 = document.getElementById('e1_fx0')
    ? sameExprToFn(val('e1_fx0'), this._obj.f)
    : true;

  const okfx1 = sameExprToFn(val('e1_fx1'), this._obj.f);
  const okineq= (val('e1_ineq_aff') === E.ineq);
  const okn0  = numEq(val('e1_n0'), E.n0);
  const okc   = (normTxt(val('e1_txt_class')) === E.cls);
  const oks   = (normSet(val('e1_txt_set')) === E.set);

  const parts = [okfx1, okineq, okn0, okc, oks];
  if (document.getElementById('e1_fx0')) parts.push(okfx0);

  tickTri($('#t_e1_all_aff',host), parts.every(Boolean));
  const good = parts.filter(Boolean).length;
  SCORE=[good, parts.length]; scoreSet(SCORE[0], SCORE[1]);
}


else{
  // QUADNEG
  tot+=6;
  const okD  = val('e1_D') ? (Number(val('e1_D'))===E.Delta) : false;
  const oka  = val('e1a') ? (val('e1a')===E.aSign) : false;
  const okf  = val('e1signF') ? (val('e1signF')===E.signF) : false;
  const oki  = val('e1s1b') ? (val('e1s1b')===E.ineq) : false;
  const okc  = normTxt(val('e1_txt_class2'))===E.cls;
  const oks  = normSet(val('e1_txt_set2'))===E.set;

  // nouveaux contrôles : f(n)
  const okfx1 = sameExprToFn(val('e1_fx1'), this._obj.f);
  const okfx2 = sameExprToFn(val('e1_fx2'), this._obj.f);

  tickTri($('#t_e1_all2',host), oka && okf && oki && okc && oks && okD && okfx1 && okfx2);
  const arr = [okD,oka,okf,oki,okc,oks,okfx1,okfx2];
  const good = arr.filter(Boolean).length;
  SCORE=[Math.min(good,6),6]; // on borne à 6 pour le score affiché
  scoreSet(SCORE[0],SCORE[1]);
}

    },
solution(host, st){
	  if(st) this._obj = st;          // <-- important pour le PDF

      if(!this._obj) return;
      const o=this._obj, E=this._expect();
      const L=[];
      if(E.mode==='basic'){
        const phraseS0 = (E.s0==='eq0'?'= 0':(E.s0==='ge0'?'≥ 0':'≤ 0'));
        const sym = E.ineq==='ge'?'≥':(E.ineq==='le'?'≤':'=');
        L.push(`Pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n=${o.fLatex}\\ ${phraseS0}.\\)`);
        L.push(`Donc \\(u_{n+1}\\ ${sym}\\ u_n\\). Ainsi la suite \\((u_n)\\) est \\(\\text{${E.cls==='ni'?'ni croissante ni décroissante':E.cls}}\\) sur \\(\\mathbb{N}\\).`);
      }else if (this._obj.info?.type === 'aff') {
  const { m, p, n0 } = this._obj.info;
  const lines = [
  (m>0 ? `Pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n=${o.fLatex}>0\\).`
            : `Pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n=${o.fLatex}<0\\)`),
        ` ` +
      (m>0 ? `Donc \\(u_{n+1}>u_n\\).`
            : `Donc \\(u_{n+1} < u_n\\)`),
    (m>0
      ? `Ainsi la suite \\((u_n)\\) est croissante sur \\(\\mathbb{N}\\).`
      : `Ainsi la suite \\((u_n)\\) est décroissante sur \\(\\mathbb{N}\\).`)
  ];
  $('#steps',host).style.display='block';
  $('#steps',host).innerHTML = lines.map(s=>`<div class="step">${s}</div>`).join('');
  retypeMath(host);
  return;
}

else{
        const sym = E.ineq==='ge'?'>':'<';
		L.push(`Il faut chercher le signe de \\(f\\) définie par \\(f(n)=${o.fLatex}\\).`);

        L.push(`\\(\\Delta=b^2-4ac=${E.Delta}&lt;0\\) et \\(a${E.aSign==='gt'?'>':'<'}0\\).`);
        L.push(`Ainsi, pour tout réel \\(n\\),, \\(f(n)${E.signF==='gt'?'>':'<'}0\\).`);
        L.push(`Donc pour tout \\(n\\in\\mathbb{N}\\), \\(u_{n+1}-u_n${E.signF==='gt'?'>':'<'}0\\) et \\(u_{n+1}\\ ${sym}\\ u_n\\).`);
        L.push(`Ainsi la suite \\((u_n)\\) est \\(\\text{${E.cls}}\\) sur \\(\\mathbb{N}\\).`);
      }
	  
      $('#steps',host).style.display='block';
      $('#steps',host).innerHTML = L.map(s=>`<div class="step">${s}</div>`).join('');
      retypeMath(host);
    }
  });

  /* =======================================================
     EX. 2 — Suite explicite : u_n = f(n) (UNE SUITE)
     Phrases à compléter selon la nature de f
  ======================================================= */
  L.push({
    id:'ex2_explicite_fill',
    title:'Ex. 2 — Explicite : compléter les phrases',
    gen(){
const kindSel = `<select id="e2-kind" style="margin-left:.3rem">
  <option value="mix">mélange (aléatoire)</option>
  <option value="lineaire">linéaire</option>
  <option value="affine">affine</option>
  <option value="carre">carré</option>
  <option value="inverse">inverse</option>
  <option value="poly2">polynôme du second degré</option>
</select>`;



      const pick = ()=>{
  const wanted = $('#e2-kind')?.value || loadKind('e2','mix');
  const k = wanted === 'mix'
    ? choice(['lineaire','affine','carre','inverse','poly2'])
    : wanted;

  if(k==='lineaire'){
    let m=rint(-6,6); if(m===0) m=2;     // m ≠ 0
    const raw=(m<0?'−':'')+(Math.abs(m)===1?'':'{'+Math.abs(m)+'}')+'n';
    const fLatex=cleanSigns(raw);
    return {kind:k, fLatex, params:{m, p:0}};
  }

  if(k==='affine'){
    let m=rint(-6,6); if(m===0) m=2;
    let p=rint(-6,6); if(p===0) p= rint(1,6); // p ≠ 0 pour distinguer d'un linéaire
    const raw=(m<0?'−':'')+(Math.abs(m)===1?'':'{'+Math.abs(m)+'}')+'n'+(p>0?' + '+p:' − '+Math.abs(p));
    const fLatex=cleanSigns(raw);
    return {kind:k, fLatex, params:{m,p}};
  }

  if(k==='carre'){
    return {kind:k, fLatex:'n^2', params:{a:1}};
  }

  if(k==='inverse'){
    const d=rint(0,4); // d=0 -> 1/n ; d>0 -> 1/(n+d)
    const fLatex = `\\dfrac{1}{n${d?(d>0?' + '+d:' − '+Math.abs(d)):''}}`;
    return {kind:k, fLatex, params:{d}};
  }

 // poly2 — on force alpha = -b/(2a) < 0  ⇔  b et a de même signe, b≠0
let a = choice([-2,-1,1,2]);
let b = (a > 0 ? 1 : -1) * rint(1,5);  // b a le même signe que a, donc alpha<0
let c = rint(-6,6);
const fl = cleanSigns(`${a===1?'':(a===-1?'−':a+' ')}n^2${
  b?(b>0?' + '+b+'n':' − '+Math.abs(b)+'n'):''}${
  c?(c>0?' + '+c:' − '+Math.abs(c)):''}`);
const alpha = -b/(2*a);  // < 0 garanti
return {kind:'poly2', fLatex:fl, params:{a,b,c,alpha}};

};



this._obj = pick();
      const o=this._obj;

      const bloc_lin = `
  <p>Compléter :  ${kindSel}</p>
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) où \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)} sur ${mkInput('e2_f_set',80)}
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}.</p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)} sur ${mkInput('e2_u_set',80)}.
    <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

const bloc_aff = `
  <p>Compléter :  ${kindSel}</p>
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) où \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)} sur ${mkInput('e2_f_set',80)}
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}.</p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)} sur ${mkInput('e2_u_set',80)}.
    <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      const bloc_car = `
  <p>Compléter :  ${kindSel}</p>
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) où \\(f\\) est la fonction ${mkInput('e2_f_name',120)}.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono2',150)} sur ${mkInput('e2_f_set2',80)}.</p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono2',180)} sur ${mkInput('e2_u_set2',80)}.
    <span id="t_e2_b" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      const a=o.params?.a, alpha=o.params?.alpha;
      const bloc_p2 = `
        <p>Compléter : ${kindSel}</p>
        <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

        <p>\\(u_n=f(n)\\) où \\(f\\) est une fonction ${mkInput('e2p_kind',180)}.</p>
        <p>Cette fonction est ${mkInput('e2p_m1',220)} sur ${mkInput('e2p_I1',180)}
           ${'car'} ${mkInput('e2p_car',120)} et \\(\\alpha=\\) ${mkInput('e2p_alpha',90)}.</p>
        <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2p_u',220)} sur ${mkInput('e2p_set',80)}.
          <span id="t_e2_c" class="tick"></span>
        </p>
		<div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

      let html = `<div class="row" data-kind="e2"><div class="statement">`;
      if(o.kind==='affine') html += bloc_aff;
      else if(o.kind==='carre' || o.kind==='inverse') html += bloc_car;
      else html += bloc_p2;
      html += `</div><div id="steps" class="steps" style="display:none"></div></div>`;

      $('#host').dataset.active=this.id;
      $('#host').innerHTML=html;
	  const selE2 = $('#e2-kind');
if(selE2){
  selE2.value = loadKind('e2','mix');
  selE2.addEventListener('change', ()=>{ saveKind('e2', selE2.value); this.gen(); });
}

      $('#e2-kind')?.addEventListener('change',()=>this.gen());
      retypeMath($('#host'));
      SCORE=[0,0]; scoreSet(0,0);
	        return this._obj;   // <-- indispensable pour le kit PDF

    },
	
	render(host, st){
  this._obj = st && (st.kind || st.params) ? st : (this.gen(), this._obj);
  const o = this._obj;
  const kindTxt = labelKindE2(o.kind);

  const bloc_lin = `
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) où \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)} sur ${mkInput('e2_f_set',80)}
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}.</p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)} sur ${mkInput('e2_u_set',80)}.
    <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

const bloc_aff = `
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) où \\(f\\) est une fonction ${mkInput('e2_f_kind',120)}.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono',150)} sur ${mkInput('e2_f_set',80)}
     car ${mkSelect('e2_reason_m',[['mpos','m>0'],['mneg','m<0'],['mzero','m=0']])}.</p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono',180)} sur ${mkInput('e2_u_set',80)}.
    <span id="t_e2_a" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      const bloc_car = `
  <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
  <p>Donner le sens de variations de la suite \\((u_n)\\)</p>

  <p>\\(u_n=f(n)\\) où \\(f\\) est la fonction ${mkInput('e2_f_name',120)}.</p>
  <p>Cette fonction est ${mkInput('e2_f_mono2',150)} sur ${mkInput('e2_f_set2',80)}.</p>
  <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2_u_mono2',180)} sur ${mkInput('e2_u_set2',80)}.
    <span id="t_e2_b" class="tick"></span>
  </p>
  <div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;


      const a=o.params?.a, alpha=o.params?.alpha;
      const bloc_p2 = `
        <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>

        <p>\\(u_n=f(n)\\) où \\(f\\) est une fonction ${mkInput('e2p_kind',180)}.</p>
        <p>Cette fonction est ${mkInput('e2p_m1',220)} sur ${mkInput('e2p_I1',180)}
           ${'car'} ${mkInput('e2p_car',120)} et \\(\\alpha=\\) ${mkInput('e2p_alpha',90)}.</p>
        <p>Ainsi la suite \\((u_n)\\) est ${mkInput('e2p_u',220)} sur ${mkInput('e2p_set',80)}.
          <span id="t_e2_c" class="tick"></span>
        </p>
		<div class="equ-offscreen" style="display:none">
 <p>On considère pour tout eniter naturel \\(n\\), \\(u_n=${o.fLatex}\\).</p>
		<p>Donner le sens de variations de la suite \\((u_n)\\)</p>
                </div>
		`;

  const body =
    o.kind==='lineaire' ? bloc_lin :
    o.kind==='affine'   ? bloc_aff :
    (o.kind==='carre'||o.kind==='inverse') ? bloc_car : bloc_p2;

  host.innerHTML = `<div class="row" data-kind="e2"><div class="statement">${body}</div><div id="steps" class="steps" style="display:none"></div></div>`;
  retypeMath(host);
},

    _expect(){
      const o=this._obj;
      if(o.kind==='lineaire'){
  const m=o.params.m;
  const fKind='lineaire';
  const monoF = m>0?'croissante':(m<0?'décroissante':'constante');
  return {mode:'lineaire', fKind, monoF, setF:'R', reason:(m>0?'mpos':(m<0?'mneg':'mzero')),
          monoU:monoF, setU:'N' };
}
if(o.kind==='affine'){
  const m=o.params.m, p=o.params.p;
  const fKind='affine';
  const monoF = m>0?'croissante':(m<0?'décroissante':'constante');
  return {mode:'affine', fKind, monoF, setF:'R', reason:(m>0?'mpos':(m<0?'mneg':'mzero')),
          monoU:monoF, setU:'N' };
}
if(o.kind==='carre'){
  return {mode:'carre', name:'carrée', monoF:'croissante', setF:'R+', reason:'sq',
          monoU:'croissante', setU:'N'};
}
if(o.kind==='inverse'){
  // d=0 -> 1/n  (suite définie sur N*), d>0 -> 1/(n+d) (définie sur N)
  const d=o.params.d;
  return {mode:'inverse', name:'inverse', monoF:'décroissante',
          setF:(d===0?'R+*':'R+'), reason:'inv',
          monoU:'décroissante', setU:(d===0?'N*':'N')};
}

      // poly2 — avec alpha<0, f est monotone sur [0; +∞[
const a = o.params.a, alpha = o.params.alpha;
const dirStr = (a>0
  ? 'décroissante sur ]-\\infty;\\alpha] et croissante sur [\\alpha;+\\infty['
  : 'croissante sur ]-\\infty;\\alpha] et décroissante sur [\\alpha;+\\infty[');
// ⚠️ On laisse m1/I1 pour le check comme avant (sur R), mais on change la MONOTONIE de la SUITE
return {
  mode:'poly2',
  kind:'polynôme du second degré',
  m1: dirStr,
  I1:'\\(\\mathbb{R}\\)',
  car:(a>0?'a>0':'a<0'),
  alpha: alpha,              // < 0
  u: (a>0 ? 'croissante' : 'décroissante'),  // suite monotone sur N
  set:'N'
};

    },
    check(host){
      if(!this._obj) return;
      const E=this._expect(); let good=0, tot=0;

      if(E.mode==='affine'){
        tot=5;
        if(val('e2_f_kind')) if(normTxt(val('e2_f_kind'))===E.fKind) good++;
        if(val('e2_f_mono')) if(normTxt(val('e2_f_mono'))===normTxt(E.monoF)) good++;
        if(val('e2_f_set')) if(normSet(val('e2_f_set'))===E.setF) good++;
        if(val('e2_reason_m')) if(val('e2_reason_m')===E.reason) good++;
        if(val('e2_u_mono')) if(normTxt(val('e2_u_mono'))===normTxt(E.monoU)) good++;
        if(val('e2_u_set')) if(normSet(val('e2_u_set'))===E.setU) good++;
        tickTri($('#t_e2_a',host), good>=5);
        SCORE=[Math.min(good,5),5]; scoreSet(SCORE[0],SCORE[1]);
      }else if(this._obj.kind==='carre' || this._obj.kind==='inverse'){
        tot=5;
        if(val('e2_f_name')) if(normTxt(val('e2_f_name'))===normTxt(E.name)) good++;
        if(val('e2_f_mono2')) if(normTxt(val('e2_f_mono2'))===normTxt(E.monoF)) good++;
        if(val('e2_f_set2')) if(normSet(val('e2_f_set2'))===E.setF) good++;
        if(val('e2_reason_ci')) if(val('e2_reason_ci')===E.reason) good++;
        if(val('e2_u_mono2')) if(normTxt(val('e2_u_mono2'))===normTxt(E.monoU)) good++;
        if(val('e2_u_set2')) if(normSet(val('e2_u_set2'))===E.setU) good++;
        tickTri($('#t_e2_b',host), good>=5);
        SCORE=[Math.min(good,5),5]; scoreSet(SCORE[0],SCORE[1]);
      }else{ // poly2
        tot=5;
        if(val('e2p_kind')) if(normTxt(val('e2p_kind'))===normTxt(E.kind)) good++;
        if(val('e2p_m1')) if(normTxt(val('e2p_m1'))===normTxt(E.m1)) good++;
        if(val('e2p_I1')) if(normTxt(val('e2p_I1'))===normTxt(E.I1)) good++;
        if(val('e2p_car')) if(normTxt(val('e2p_car'))===normTxt(E.car)) good++;
        if(val('e2p_alpha')){ const a=parseFloat(val('e2p_alpha').replace(',','.')); if(!isNaN(a) && Math.abs(a-E.alpha)<1e-9) good++; }
        if(val('e2p_u')) if(normTxt(val('e2p_u'))===normTxt(E.u)) good++;
        if(val('e2p_set')) if(normSet(val('e2p_set'))===E.set) good++;
        tickTri($('#t_e2_c',host), good>=5);
        SCORE=[Math.min(good,5),5]; scoreSet(SCORE[0],SCORE[1]);
      }
    },
solution(host, st){
	  if(st) this._obj = st;          // <-- important pour le PDF

      if(!this._obj) return;
      const E=this._expect(), o=this._obj;
      const L=[];
      if(E.mode==='lineaire'){
  L.push(`\\(u_n=f(n)=${o.fLatex}.\\)`);
  L.push(`\\(f\\) est une fonction linéaire. Comme \\(m=${o.params.m}\\), la fonction est ${E.monoF} sur \\([0; +\\infty[\\).`);
  L.push(`Donc la suite \\((u_n)\\) est ${E.monoU} sur \\(\\mathbb{N}\\).`);
}
else if(E.mode==='affine'){
  L.push(`\\(u_n=f(n)=${o.fLatex}.\\)`);
  L.push(`\\(f\\) est une fonction affine. Comme \\(m=${o.params.m}\\), la fonction est ${E.monoF} sur \\([0; +\\infty[\\).`);
  L.push(`Donc la suite \\((u_n)\\) est ${E.monoU} sur \\(\\mathbb{N}\\).`);
}
else if(this._obj.kind==='carre'){
  L.push(`\\(u_n=f(n)=n^2.\\)`);
  L.push(`La fonction carrée est croissante sur \\([0; +\\infty[\\).`);
  L.push(`Ainsi \\((u_n)\\) est croissante sur \\(\\mathbb{N}\\).`);
}
else if(this._obj.kind==='inverse'){
  const d=o.params.d;
  L.push(`\\(u_n=f(n)=\\dfrac{1}{n${d?(d>0?' + '+d:' − '+Math.abs(d)):''}}.\\)`);
  if(d===0){
    L.push(`La fonction inverse est décroissante sur \\(]0; +\\infty[\\).`);
    L.push(`Ainsi \\((u_n)\\) est décroissante sur \\(\\mathbb{N}^*\\).`);
  }else{
    L.push(`La fonction \\(f\\) est décroissante sur \\([0; +\\infty[\\),`);
    L.push(`la suite \\((u_n)\\) est décroissante sur \\(\\mathbb{N}\\).`);
  }
}
else { // poly2
  const a = o.params.a, alpha = o.params.alpha; // alpha<0
  L.push(`\\(u_n=f(n)=${o.fLatex}.\\)`);
  L.push(`\\(f\\) est une fonction polynôme du second degré avec \\(a=${a}\\) et \\(\\alpha=-\\dfrac{b}{2a}=${alpha}<0\\).`);
  // Sur [0; +∞[, f est monotone car le sommet est à gauche de 0
  if(a>0){
    L.push(`Comme \\(a>0\\), \\(f\\) est croissante sur \\([\\alpha ; +\\infty[\\) donc sur \\([0 ; +\\infty[\\).`);
    L.push(`Donc la suite \\((u_n)\\) est croissante sur \\(\\mathbb{N}\\).`);
  }else{
    L.push(`Comme \\(a<0\\), \\(f\\) est décroissante sur \\([\\alpha ; +\\infty[\\) donc sur \\([0 ; +\\infty[\\).`);
    L.push(`Donc la suite \\((u_n)\\) est décroissante sur \\(\\mathbb{N}\\).`);
  }
}


      $('#steps',host).style.display='block';
      $('#steps',host).innerHTML = L.map(s=>`<div class="step">${s}</div>`).join('');
      retypeMath(host);
    }
  });

  return L;
}

/* ===== REGISTRY & UI ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY;

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.gen();
  }catch(err){
    console.error('[renderActiveSafe]', source, err);
    host.innerHTML = '<p style="color:#b00020">Une erreur est survenue lors du rendu de l’exercice.</p>';
  }
}

function attachSelectHandlers(){
  const sel=document.querySelector('#exo-select');
  if(!sel) return;
  sel.addEventListener('change', ()=>renderActiveSafe('select'));
}

/* Entrée → Vérifier (toute la page) */
window.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){
    e.preventDefault();
    $('#btn-check')?.click();
  }
});

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });


  // init PDF quand REGISTRY prêt
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: 'Première — Suites numériques — Sens de variations',
        max: 50,
        mountAfterSelector: '#info-saisie',
        autoPrint: false
      });
    } else {
      setTimeout(waitForPDF, 60);
    }
  })();
});

// Rattrapage : si une page externe attend #steps au clic "Solution"
(function(){
  const origAddEvent = Element.prototype.addEventListener;
  Element.prototype.addEventListener = function(type, listener, opts){
    if(type==='click' && this.id==='btn-sol'){
      const host=document.querySelector('#host');
      const def = window.REGISTRY.find(e => e.id === host.dataset.active);
      if(def && typeof def.solution==='function'){
        const _old = def.solution;
        def.solution = function(host){
          const W = host.querySelector('#steps');
          if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
          return _old.call(this, host);
        };
      }
    }
    return origAddEvent.call(this, type, listener, opts);
  };
})();
})(); // IIFE
</script>
</body>
</html>
