<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Premi√®re ‚Äì Probabilit√©s conditionnelles (d√©finitions & propri√©t√©s)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #ddd;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap;margin-left:auto}
.small{font-size:.92rem;color:#666}

.hint{opacity:.9;margin:.2rem 0 .6rem}
.consigne .c-label{font-weight:600; margin-right:.35em}

.row{
  display:grid;
  grid-template-columns:1fr;
  grid-template-areas:
    'lab'
    'inp'
    'res';
  gap:10px; align-items:start;
}
.row .col-label{grid-area:lab}
.row .input-line{grid-area:inp}
.row .input-line input[type=text]{width:100%}
.row .res{grid-area:res; padding:12px;border-radius:10px;background:#f7f7f7}
.res-ok{background:#ecfdf5;border:1px solid #a7f3d0}
.res-ko{background:#fef2f2;border:1px solid #fecaca}

.eq em { margin: 0 .28em; }
.mx { display:inline-block; margin:0 .28em; }
sub { font-size: .8em; vertical-align: -0.25em; }

.equ-offscreen{position:absolute !important; left:-10000px !important; width:1px !important; height:1px !important; overflow:hidden !important;}
@media print{
  .hint{display:none !important;}
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
  .equ-offscreen .c-label{display:none !important;}
}

.row.right{
  display:grid;
  grid-template-columns: 1fr minmax(220px, 320px);
  grid-template-areas:
    "lab inp"
    "res res";
  gap:10px 14px;
  align-items:center;
}
.row.right .col-label{ grid-area:lab; }
.row.right .input-line{ grid-area:inp; display:flex; justify-content:flex-end; }
.row.right .input-line input[type=text]{ width:100% }

@media (max-width:680px){
  .row.right{
    grid-template-columns:1fr;
    grid-template-areas: "lab" "inp" "res";
  }
}

.tbl{border-collapse:collapse;border:1px solid #bbb}
.tbl td,.tbl th{border:1px solid #bbb;padding:6px;text-align:center}
@media print{
  .tbl{border:1px solid #000}
  .tbl td,.tbl th{border:1px solid #000}
}

.tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
.tick.ok{color:#059669}
.tick.ko{color:#dc2626}

.mselect{position:relative; display:inline-block; min-width:180px}
.ms-btn{display:flex; align-items:center; justify-content:space-between; width:100%;
  padding:8px 10px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer}
.ms-menu{position:absolute; z-index:20; top:100%; left:0; right:0; max-height:240px; overflow:auto;
  border:1px solid #ddd; background:#fff; border-radius:8px; margin-top:4px; box-shadow:0 6px 16px rgba(0,0,0,.08); display:none}
.ms-item{padding:8px 10px; cursor:pointer}
.ms-item:hover{background:#f3f4f6}
.mselect.open .ms-menu{display:block}

</style>

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <div class="wrap" style="padding:0 18px">
      <div class="controls">
        <label for="exo-select">Type d‚Äôexercice :</label>
        <select id="exo-select"></select>
        <button id="btn-new" class="btn">üîÄ Nouvel √©nonc√©</button>
        <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
        <button id="btn-solution" class="btn">üí° Solution</button>
        <button id="btn-reset" class="btn">‚ôªÔ∏è R√©initialiser</button>
        <div class="score" id="score">Score : 0 / 0</div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div id="host"></div>
    </div>

    <div class="card small">
      <div><strong>Saisie & r√©ponses accept√©es :</strong></div>
      <ul class="tips">
        <li>D√©cimaux : virgule <em>ou</em> point (ex. <code>0,375</code> ou <code>0.375</code>).</li>
        <li>Fractions : forme <code>a/b</code> (ex. <code>3/8</code>).</li>
        <li>Pourcentages : forme <code>xx%</code> (ex. <code>37,5%</code>). Si le champ <strong>exige</strong> un ¬´ % ¬ª, la forme d√©cimale est refus√©e.</li>
        <li>Quand une r√©ponse demande une <strong>notation</strong>, √©crire au format \(P(A)\), \(P(A\\cap B)\), \(P_{A}(B)\) (i.e. \(P(B\\mid A)\)), \(P(A\\cup B)\), etc.</li>
        <li>Entr√©e ‚èé d√©clenche ¬´ V√©rifier ¬ª depuis une barre de saisie de l‚Äô√©nonc√©.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<script>
(() => {
/* ========= Mini utilitaires ========= */
const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = L => L[rnd(0,L.length-1)];
function innerHost(host){ if(!host.dataset.active){ host.dataset.active=''; host.innerHTML='<div class="inner"></div>'; } return host.querySelector('.inner'); }

function retypeset(root=document){
  try{
    if (window.MathJax?.typesetPromise) return MathJax.typesetPromise([root]);
    if (window.MathJax?.typeset) MathJax.typeset([root]);
  }catch(_){}
}

/* ===== parse nombres / % / fractions ===== */
const stripSignUnicode = s => String(s||'').replace(/‚àí/g,'-');
function parseNumberFR(s){
  s = stripSignUnicode(String(s||'').trim());
  if(!s) return NaN;
  if(/%/.test(s)) return NaN;
  s = s.replace(',', '.');
  return parseFloat(s);
}
function parsePercent(s){
  s = stripSignUnicode(String(s||'').trim());
  const m = s.match(/^([-+]?[0-9]+(?:[.,][0-9]+)?)\s*%$/);
  if(!m) return NaN;
  return parseFloat(m[1].replace(',', '.'))/100;
}
// accepte d√©cimal, fraction, % ‚Äî renvoie un nombre dans [0,1]
function parseProbFlexible(s){
  s = stripSignUnicode(String(s||'').trim());
  // fraction a/b
  let m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
  if(m){
    const a = parseInt(m[1],10), b = parseInt(m[2],10);
    if(b>0) return a/b;
  }
  // %
  const p = parsePercent(s);
  if(Number.isFinite(p)) return p;
  // d√©cimal
  const d = parseFloat(s.replace(',', '.'));
  return Number.isFinite(d) ? d : NaN;
}
function same(a,b,eps=1e-6){ return Math.abs(a-b)<=eps; }

/* ====== rendu commun ====== */
function stripHints(html){ return String(html||'').replace(/<small[\s\S]*?<\/small>/gi,''); }

function renderRows(host, consigneText, blocks, right=false){
  const root = innerHost(host); root.innerHTML='';
  const hint = document.createElement('div');
  hint.className='hint consigne';
  hint.innerHTML='<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
  root.appendChild(hint);

  const off = document.createElement('div');
  off.className='equ-offscreen';
  off.innerHTML = '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div>'
    + blocks.map(b => '<div class="equation">'+ stripHints(b.labelHTML||'') +'</div>').join('');
  root.appendChild(off);

  blocks.forEach(b=>{
    const row=document.createElement('div'); row.className = right ? 'row right' : 'row';
    const lab=document.createElement('div'); lab.className='col-label'; lab.innerHTML=b.labelHTML||''; row.appendChild(lab);
    const incol=document.createElement('div'); incol.className='input-line';
    if(b.rightHTML!==undefined) incol.innerHTML=b.rightHTML;
    else if(b.id) incol.innerHTML='<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
    row.appendChild(incol);
    root.appendChild(row);
  });
  root.appendChild(Object.assign(document.createElement('div'),{className:'res',id:'res'}));
  retypeset(root);
}

function addTicks(){
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    if(!inp.nextElementSibling || !inp.nextElementSibling.classList?.contains('tick'))
      inp.insertAdjacentHTML('afterend','<span class="tick"></span>');
  });
}
function setTick(inp, state){
  const t = inp.nextElementSibling?.classList?.contains('tick') ? inp.nextElementSibling : null;
  if(!t) return;
  if(state==null){ t.textContent=''; t.classList.remove('ok','ko'); return; }
  if(state){ t.textContent='‚úî'; t.classList.add('ok'); t.classList.remove('ko'); }
  else     { t.textContent='‚úò'; t.classList.add('ko'); t.classList.remove('ok'); }
}
function allFilled(){
  let ok=true;
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    if((inp.value||'').trim()==='') ok=false;
  });
  return ok;
}

// affiche avec au plus 2 d√©cimales (trim des z√©ros), √©vite les horreurs binaires
const d2 = x => {
  const v = Math.round(x*100)/100;
  let s = v.toFixed(2);
  s = s.replace(/\.?0+$/,'');   // "0.50" -> "0.5", "0.00" -> "0"
  return s;
};
// --- POLYFILL : rendu "plusieurs questions l'une sous l'autre" ---
if (typeof renderRowsUnderQuestions === 'undefined') {
  function renderRowsUnderQuestions(host, consigneText, blocks){
    const root = (function innerHost(h){
      if(!h.dataset.active){ h.dataset.active=''; h.innerHTML='<div class="inner"></div>'; }
      return h.querySelector('.inner');
    })(host);
    root.innerHTML = '';

    // Consigne visible
    const hint = document.createElement('div');
    hint.className = 'hint consigne';
    hint.innerHTML = '<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
    root.appendChild(hint);

    // Version "offscreen" pour export PDF
    const off = document.createElement('div');
    off.className = 'equ-offscreen';
    off.innerHTML =
      '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'
      + consigneText + '</span></div>'
      + blocks.map(b => '<div class="equation">'+ (b.labelHTML||'') +'</div>').join('');
    root.appendChild(off);

    // Questions + inputs
    blocks.forEach(b=>{
      const row = document.createElement('div'); row.className='row';
      const lab = document.createElement('div'); lab.className='col-label';
      lab.innerHTML = b.labelHTML || '';
      row.appendChild(lab);

      const incol = document.createElement('div'); incol.className='input-line';
      if (b.rightHTML !== undefined) incol.innerHTML = b.rightHTML;
      else if (b.id) incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
      row.appendChild(incol);

      root.appendChild(row);
    });

    // Zone r√©sultat
    root.appendChild(Object.assign(document.createElement('div'), { className:'res', id:'res' }));

    // (si MathJax est l√†)
    try{ if(window.MathJax?.typesetPromise) MathJax.typesetPromise([root]); else if(window.MathJax?.typeset) MathJax.typeset([root]); }catch(_){}
  }
}

// --- POLYFILL : rendu "question √† gauche, saisie/SELECT √† droite"
if (typeof renderRowsInputRight === 'undefined') {
  function renderRowsInputRight(host, consigneText, blocks){
    // 1) host / inner
    function innerHost(h){
      if(!h.dataset.active){ h.dataset.active=''; h.innerHTML='<div class="inner"></div>'; }
      return h.querySelector('.inner');
    }
    const root = innerHost(host);
    root.innerHTML = '';

    // 2) Consigne visible
    const hint = document.createElement('div');
    hint.className = 'hint consigne';
    hint.innerHTML = '<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
    root.appendChild(hint);

    // 3) Version offscreen (PDF)
    const off = document.createElement('div');
    off.className = 'equ-offscreen';
    off.innerHTML =
      '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div>' +
      blocks.map(b => '<div class="equation">'+ (b.labelHTML||'') +'</div>').join('');
    root.appendChild(off);

    // 4) Lignes : libell√© √† gauche, champ √† droite
    blocks.forEach(b=>{
      const row = document.createElement('div'); row.className = 'row right';
      const lab = document.createElement('div'); lab.className = 'col-label';
      lab.innerHTML = b.labelHTML || '';
      row.appendChild(lab);

      const incol = document.createElement('div'); incol.className = 'input-line';
      if (b.rightHTML !== undefined) {
        incol.innerHTML = b.rightHTML;                      // ex. <select ‚Ä¶>
      } else if (b.id) {
        incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
      } else {
        incol.innerHTML = '';
      }
      row.appendChild(incol);

      root.appendChild(row);
    });

    // 5) Zone r√©sultat
    root.appendChild(Object.assign(document.createElement('div'), { className:'res', id:'res' }));

    // 6) MathJax
    try{
      if (window.MathJax?.typesetPromise) MathJax.typesetPromise([root]);
      else if (window.MathJax?.typeset)   MathJax.typeset([root]);
    }catch(_){}
  }
}


// sujets f√©minins (sinon masculin)
const FEM_SUBJECTS = new Set([
  'pi√®ces','analyses','commandes','factures','machines','candidatures',
  'questions','exp√©ditions','√©chantillons'
]);

function toSingularFR(plur){ return String(plur||'').trim().replace(/s$/,''); }
function startsWithVowelLikeFR(w){ return /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(String(w||'')); }
function defDetFR(noun, isFem){ return startsWithVowelLikeFR(noun) ? "l‚Äô"+noun : (isFem?"la ":"le ")+noun; }
function indefDetFR(noun, isFem){ return (isFem?"une ":"un ")+noun; }

// met la proposition au singulier (verbes + quelques adjectifs fr√©quents)
function singularizePropFR(s, isFem=false){
  let t = String(s||'').trim();

  // verbes au d√©but
  const vb = [
    [/^sont\b/i, 'est'],
    [/^ont\b/i, 'a'],
    [/^proviennent\b/i, 'provient'],
    [/^contiennent\b/i, 'contient'],
    [/^arrivent\b/i, 'arrive'],
    [/^concernent\b/i, 'concerne'],
    [/^commandent\b/i, 'commande'],
    [/^paient\b/i, 'paie'],
    [/^utilisent\b/i, 'utilise'],
    [/^respectent\b/i, 'respecte'],
  ];
  vb.forEach(([re, rep]) => { t = t.replace(re, rep); });

  // pluriels fr√©quents ‚Üí singuliers
  const adj = [
    [/\burgents\b/gi, 'urgent'],
    [/\bf√©ri√©s\b/gi, 'f√©ri√©'],
    [/\bfragiles\b/gi, 'fragile'],
    [/\bpublics\b/gi, 'public'],
    [/\br√©serv√©s\b/gi, 'r√©serv√©'],
    [/\btermin√©s\b/gi, 'termin√©'],
    [/\bdirects\b/gi, 'direct'],
    [/\b√©lectriques\b/gi, '√©lectrique'],
    [/\bmeubl√©s\b/gi, 'meubl√©'],
    [/\bcomplets\b/gi, 'complet'],
    [/\br√©gl√©s\b/gi, 'r√©gl√©'],
    [/\bannul√©s\b/gi, 'annul√©'],

    // f√©minins pluriels
    [/\bcompl√®tes\b/gi, 'compl√®te'],
    [/\br√©gl√©es\b/gi, 'r√©gl√©e'],
    [/\bannul√©es\b/gi, 'annul√©e'],
    [/\binternationales\b/gi, 'internationale'],
    [/\burgentes\b/gi, 'urgente'],
  ];
  adj.forEach(([re, rep]) => { t = t.replace(re, rep); });

  // "des X‚Ä¶" ‚Üí "un/une X‚Ä¶" quand √ßa suit un verbe de contenu (concerne/contient/provient‚Ä¶)
  t = t.replace(/\bdes\s+([a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º\-']+?)s\b/gi, (_m, w) => (isFem?'une ':'un ')+w);

  return t;
}

// AÃÖ / BÃÖ en texte (fonctionne dans <option>)
const BAR = {
  A: 'A\u0305',   // AÃÖ
  B: 'B\u0305'    // BÃÖ
};
function msOptionsLatex(){
  return [
    {v:'', latex:'\\text{‚Äî choisir ‚Äî}'},
    {v:'PA', latex:'P(A)'}, {v:'PB', latex:'P(B)'},
    {v:'PnotA', latex:'P(\\overline{A})'}, {v:'PnotB', latex:'P(\\overline{B})'},
    {v:'interAB', latex:'P(A\\cap B)'},
    {v:'interAbarB', latex:'P(A\\cap \\overline{B})'},
    {v:'interABarB', latex:'P(\\overline{A}\\cap B)'},
    {v:'unionAB', latex:'P(A\\cup B)'},
    {v:'unionAbarB', latex:'P(A\\cup \\overline{B})'},
    {v:'unionABarB', latex:'P(\\overline{A}\\cup B)'},
    {v:'condAB', latex:'P_{A}(B)'},
    {v:'condABbar', latex:'P_{A}(\\overline{B})'},
    {v:'condBA', latex:'P_{B}(A)'},
    {v:'condBAbar', latex:'P_{B}(\\overline{A})'},
  ];
}

function mkMathSelectHTML(selectId, width=220){
  const opts = msOptionsLatex();
  const items = opts.map(o =>
    `<div class="ms-item" data-v="${o.v}" data-latex="${o.latex}">\\(${o.latex}\\)</div>`
  ).join('');
return `
  <div class="mselect" data-for="${selectId}" style="min-width:${width}px">
    <button type="button" class="ms-btn">
      <span class="ms-label">\\(\\text{‚Äî choisir ‚Äî}\\)</span><span>‚ñæ</span>
    </button>
    <div class="ms-menu">${items}</div>
    <input type="hidden" id="${selectId}" value="">
    <span class="tick"></span>      
  </div>`;

}


// Active le composant (√† appeler apr√®s insertion dans le DOM)
function initMathSelect(root=document){
  root.querySelectorAll('.mselect').forEach(box=>{
    if(box.dataset.bound) return; box.dataset.bound='1';
    const btn = box.querySelector('.ms-btn');
    const menu = box.querySelector('.ms-menu');
    const label= box.querySelector('.ms-label');
    const hidden= box.querySelector('input[type=hidden]');
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('.mselect.open').forEach(b=>{ if(b!==box) b.classList.remove('open'); });
      box.classList.toggle('open');
    });
    menu.addEventListener('click', e=>{
  const it = e.target.closest('.ms-item'); if(!it) return;
  hidden.value = it.dataset.v || '';
  // Injecte EXACTEMENT une paire de d√©limiteurs LaTeX :
  label.innerHTML = '\\(' + (it.dataset.latex || '') + '\\)';
  box.classList.remove('open');
  try{ MathJax.typesetPromise([box]); }catch(_){}
});

  });
  // fermeture globale
  document.addEventListener('click', e=>{
    if(!e.target.closest('.mselect')) document.querySelectorAll('.mselect.open').forEach(b=>b.classList.remove('open'));
  }, {passive:true});
}

function setTickForInput(el, state){
  // el = <input type="hidden"> du s√©lecteur ou un vrai input
  if(!el) return;
  // cherche d‚Äôabord un tick dans le s√©lecteur custom
  let box = el.closest('.mselect');
  let t = box ? box.querySelector('.tick') : null;

  // sinon, fallback : tick plac√© juste apr√®s l‚Äôinput (cas texte)
  if(!t && el.nextElementSibling && el.nextElementSibling.classList?.contains('tick')){
    t = el.nextElementSibling;
  }
  if(!t) return;

  if(state==null){ t.textContent=''; t.classList.remove('ok','ko'); return; }
  if(state){ t.textContent='‚úî'; t.classList.add('ok'); t.classList.remove('ko'); }
  else     { t.textContent='‚úò'; t.classList.add('ko'); t.classList.remove('ok'); }
}

/* ======= EXERCICES ======= */

/* ===== Exercice 1 ‚Äî S√©lecteur (Type 1..4 ou M√©lange) =====
   Types :
   1) Soient A,B : P(A), P(B), P(A‚à©B) ‚Üí P_A(B)      (i.e. P(B|A))
   2) Soient A,B : P(A), P_A(B), P(B) ‚Üí P(A‚à©B), P_B(A)
   3) Soient E,F : P(E), P_E(F) ‚Üí P(E‚à©F)
   4) Soient A,B : P(A), P(B), P(A‚à™B) ‚Üí P(A‚à©B), P_B(A), P_A(B)
*/
const ex1 = {
  id:'pc_mix4',
  title:'Probas & probas conditionnelles ‚Äî s√©lecteur (ou m√©lange)',
gen(){
  const rInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const asDec = n => +(n/100).toFixed(2);
const gcd = (a,b)=> b?gcd(b,a%b):Math.abs(a);
const lcm = (a,b)=> Math.abs(a*b)/gcd(a,b);

  // ------- Type 1 : P(B|A)=P(A‚à©B)/P(A) -> 2 d√©cimales garanties
  // Choix : pA = a/100, pB = b/100 (a,b en points). On fixe i = (a*k)/100
  // avec k multiple de 100/gcd(a,100) -> P(B|A)=k/100 a ‚â§ 2 d√©cimales.
function gen_t1(){
  while(true){
    const a = rInt(20,85);            // P(A) en points
    const b = rInt(20,85);            // P(B) en points
    if (Math.abs(a-b) < 5) continue;  // <-- anti-√©galit√© / trop proches

    const step = 100 / gcd(a,100);
    const kMax = Math.floor(100*Math.min(a,b)/a);
    const Ks=[];
    for(let k=step; k<=Math.min(95,kMax); k+=step) Ks.push(k);
    if(!Ks.length) continue;

    const k = Ks[rInt(0,Ks.length-1)];
    const i = Math.floor(a*k/100);        // intersection (points)
    const cond = i / a;                   // P(B|A)
    if(cond >= 0.05 && cond <= 0.95)
      return { pA:asDec(a), pB:asDec(b), pInt:asDec(i) };
  }
}

// === Type 2 : 0.05 ‚â§ P_A(B) ‚â§ 0.95, 0.05 ‚â§ P_B(A) ‚â§ 0.95 et |P(A)-P(B)| ‚â• 0.05
function gen_t2(){
  while(true){
    const a = rInt(25,85);                         // P(A)
    const step = 100 / gcd(a,100);
    const Ks=[]; for(let k=step; k<=95; k+=step) if(k>=5 && k<=95) Ks.push(k);
    if(!Ks.length) continue;
    const k = Ks[rInt(0,Ks.length-1)];             // P_A(B)=k/100

    const i = Math.floor(a*k/100);                 // intersection en points
    const CAND = [20,25,40,50,60,75,80];           // b avec 2 d√©c. garanties
    const okB = CAND.filter(b => b >= i+2 && b <= 90 && (100*i)%b===0 && Math.abs(b-a)>=5);
    if(!okB.length) continue;

    const b = okB[rInt(0,okB.length-1)];
    const condBA = i / b;                          // P_B(A)
    if(condBA >= 0.05 && condBA <= 0.95)
      return { pA:asDec(a), pB:asDec(b), pInt:asDec(i), pA_B:asDec(k) };
  }
}

  // ------- Type 3 : P(E‚à©F)=P(E)*P_E(F) avec produit √† 2 d√©c.
  // Choix : pE=a/100 et P_E(F)=k/100 avec k multiple de 100/gcd(a,100) -> (a*k)/10000 a 2 d√©cimales.
// ------- Type 3 (patch) : garantit un k multiple du pas ; produit √† 2 d√©c. ; jamais NaN
function gen_t3(){
  while (true) {
    const a = rInt(20, 80);              // P(E) en points
    const g = gcd(a, 100);
    const step = 100 / g;                // k doit √™tre multiple de ce pas

    // candidats k dans [5,95] multiples de step
    const Ks = [];
    const start = Math.ceil(Math.max(5, step) / step) * step;
    for (let k = start; k <= 95; k += step) Ks.push(k);

    if (!Ks.length) continue;            // pas de k possible ‚Üí on retente un autre a

    const k = Ks[rInt(0, Ks.length - 1)];
    return { pE: asDec(a), pF_E: asDec(k) };
  }
}


  // ------- Type 4 : pA, pB pris dans {20,25,40,50,80} (diviseurs de 100).
  // On tire une intersection m/100 coh√©rente -> P_B(A)=m/b et P_A(B)=m/a ont ‚â§2 d√©c.
 function gen_t4(){
  const D = [20,25,40,50,60,75,80];
  while(true){
    const a = D[rInt(0,D.length-1)];
    let b = D[rInt(0,D.length-1)];
    if (Math.abs(a-b) < 5) continue;               // <-- anti-√©galit√© / trop proches

    const mMin = Math.max(1, a + b - 100);
    const mMax = Math.min(a, b) - 2;

    const gA = gcd(a,100), gB = gcd(b,100);
    const stepM = lcm(a/gA, b/gB);                 // 2 d√©c. pour m/a et m/b

    const Ms=[]; const start = Math.ceil(mMin/stepM)*stepM;
    for(let m=start; m<=mMax; m+=stepM){
      const pa = m/a, pb = m/b;
      if(pa >= 0.05 && pa <= 0.95 && pb >= 0.05 && pb <= 0.95) Ms.push(m);
    }
    if(!Ms.length) continue;

    const m = Ms[rInt(0,Ms.length-1)];
    const u = a + b - m;
    return { pA:asDec(a), pB:asDec(b), pU:asDec(u), pInt:asDec(m) };
  }
}

  return {
    bank: { t1: gen_t1(), t2: gen_t2(), t3: gen_t3(), t4: gen_t4() },
    variant: 'mix'
  };
},



  /* petit utilitaire : r√©cup√®re le type actif (t1..t4), en tirant si 'mix' */
  _activeType(st){
    if(st.variant && st.variant!=='mix') return st.variant;
    const L=['t1','t2','t3','t4'];
    return L[Math.floor(Math.random()*L.length)];
  },

  render(host, st){
  // 1) √©tat courant (m√©morise le choix utilisateur)
  const prev = host.dataset.variant || st.variant || 'mix';
  host.dataset.variant = prev;

  const typeNow = (prev==='mix') ? this._activeType(st) : prev;
  host.dataset.typeNow = typeNow; // utilis√© par correct/solution

  // 2) Construire les blocs en fonction du type
  const B=[];
  if(typeNow==='t1'){
    const {pA,pB,pInt}=st.bank.t1;
    B.push({labelHTML:`Soient \\(A\\) et \\(B\\) deux √©v√©nements tels que : \\(P(A)=${pA}\\), \\(P(B)=${pB}\\) et \\(P(A\\cap B)=${pInt}\\).<br> Calculer \\(P_A(B)\\).`, id:'q1'});
  }
  if(typeNow==='t2'){
    const {pA,pB,pInt,pA_B}=st.bank.t2;
B.push({labelHTML:`Soient \\(A\\) et \\(B\\) deux √©v√©nements tels que : \\(P(A)=${pA}\\), \\(P_A(B)=${pA_B}\\) et \\(P(B)=${pB}\\).<br> Calculer \\(P(A\\cap B)\\).`, id:'q2'});
B.push({labelHTML:`Puis calculer \\(P_B(A)\\).`, id:'q2b'});

  }
  if(typeNow==='t3'){
    const {pE,pF_E}=st.bank.t3;
    B.push({labelHTML:`Soient \\(E\\) et \\(F\\) deux √©v√©nements tels que : \\(P(E)=${pE}\\) et \\(P_E(F)=${pF_E}\\).<br> Calculer \\(P(E\\cap F)\\).`, id:'q3'});
  }
  if(typeNow==='t4'){
    const {pA,pB,pU}=st.bank.t4;
    B.push({labelHTML:`Soient \\(A\\) et \\(B\\) deux √©v√©nements tels que : \\(P(A)=${pA}\\), \\(P(B)=${pB}\\) et \\(P(A\\cup B)=${pU}\\).<br> Calculer \\(P(A\\cap B)\\).`, id:'q4'});
    B.push({labelHTML:`Puis \\(P_B(A)\\).`, id:'q4b'});
    B.push({labelHTML:`Et \\(P_A(B)\\).`, id:'q4c'});
  }

  // 3) Rendu principal
  renderRows(host, 'R√©pondre en d√©cimal, fraction ou % (quand pertinent).', B);

  // 4) Ins√©rer le s√©lecteur tout en haut (apr√®s que renderRows a vid√©/pos√© le DOM)
  const selectHTML =
    `<div class="controls" style="gap:8px;margin-bottom:8px">
       <label style="font-weight:600">Type :</label>
       <select id="ex1-type">
         <option value="mix">üîÄ M√©lange</option>
         <option value="t1">Type 1 ‚Äî \\(P_A(B)\\) avec \\(P(A),P(B),P(A\\cap B)\\)</option>
         <option value="t2">Type 2 ‚Äî \\(P(A\\cap B)\\), \\(P_B(A)\\) avec \\(P(A),P_A(B),P(B)\\)</option>
         <option value="t3">Type 3 ‚Äî \\(P(E\\cap F)\\) avec \\(P(E),P_E(F)\\)</option>
         <option value="t4">Type 4 ‚Äî depuis \\(P(A),P(B),P(A\\cup B)\\)</option>
       </select>
     </div>`;

  const inner = document.querySelector('#host .inner');
  inner.insertAdjacentHTML('afterbegin', selectHTML);
  const sel = document.querySelector('#ex1-type');
  sel.value = prev; // refl√®te le choix actuel

  // 5) Changement de type sans r√©g√©n√©rer les nombres
  sel.addEventListener('change', (e)=>{
    host.dataset.variant = e.target.value;     // m√©morise
    this.render(host, st);                     // re-render (les valeurs de st.bank restent)
  });

  retypeset(inner);
}
,

  correct(host, st){
    const typeNow = host.dataset.typeNow || this._activeType(st);
    // parseur flexible proba
    const parseProb = s => {
      s = String(s||'').trim();
      let m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
      if(m){ const a=parseInt(m[1],10), b=parseInt(m[2],10); return b>0 ? a/b : NaN; }
      const p = s.match(/^([-+]?[0-9]+(?:[.,][0-9]+)?)\s*%$/);
      if(p) return parseFloat(p[1].replace(',', '.'))/100;
      const d = parseFloat(s.replace(',', '.'));
      return Number.isFinite(d) ? d : NaN;
    };

    let ok=false;
    if(typeNow==='t1'){
      const {pA,pB,pInt}=st.bank.t1;
      const v = parseProb($('#q1',host).value);
      ok = Number.isFinite(v) && Math.abs(v - pInt/pA) <= 1e-3;
    }
    if(typeNow==='t2'){
      const {pA,pB,pInt}=st.bank.t2;
      const v1 = parseProb($('#q2',host).value);
      const v2 = parseProb($('#q2b',host).value);
      ok = Number.isFinite(v1) && Number.isFinite(v2)
        && Math.abs(v1 - pInt) <= 1e-3
        && Math.abs(v2 - pInt/pB) <= 1e-3;
    }
    if(typeNow==='t3'){
      const {pE,pF_E}=st.bank.t3;
      const v = parseProb($('#q3',host).value);
      ok = Number.isFinite(v) && Math.abs(v - pE*pF_E) <= 1e-3;
    }
    if(typeNow==='t4'){
      const {pA,pB,pU,pInt}=st.bank.t4;
      const inter = pA + pB - pU;
      const v = parseProb($('#q4',host).value);
      const vB = parseProb($('#q4b',host).value);
      const vA = parseProb($('#q4c',host).value);
      ok = Number.isFinite(v) && Number.isFinite(vB) && Number.isFinite(vA)
        && Math.abs(v - inter) <= 1e-3
        && Math.abs(vB - inter/pB) <= 1e-3
        && Math.abs(vA - inter/pA) <= 1e-3;
    }

    $('#res',host).innerHTML = ok ? '‚úî' :
      '‚úò Formules utiles : \\(P(B\\mid A)=\\frac{P(A\\cap B)}{P(A)}\\), \\(P(A\\cap B)=P(A)+P(B)-P(A\\cup B)\\).';
    $('#res',host).className = ok ? 'res-ok':'res-ko';
    return {ok,total:1};
  },

  solution(host, st){
    const typeNow = host.dataset.typeNow || this._activeType(st);
    let html='';
    if(typeNow==='t1'){
  const {pA,pInt}=st.bank.t1;
  html = `<p>\\(P_A(B)=\\dfrac{P(A\\cap B)}{P(A)}=\\dfrac{${pInt}}{${pA}}=${d2(pInt/pA)}\\).</p>`;
}

if(typeNow==='t2'){
  const {pA,pB,pInt,pA_B}=st.bank.t2;
  html = `<p>\\(P(A\\cap B)=P(A)\\times P_A(B)=${pA}\\times ${pA_B}=${d2(pInt)}\\).</p>
          <p>\\(P_B(A)=\\dfrac{P(A\\cap B)}{P(B)}=\\dfrac{${pInt}}{${pB}}=${d2(pInt/pB)}\\).</p>`;
}

if(typeNow==='t3'){
  const {pE,pF_E}=st.bank.t3;
  html = `<p>\\(P(E\\cap F)=P(E)\\times P_E(F)=${pE}\\times ${pF_E}=${d2(pE*pF_E)}\\).</p>`;
}

if(typeNow==='t4'){
  const {pA,pB,pU}=st.bank.t4;
  const inter = pA + pB - pU;
  html = `<p>\\(P(A\\cap B)=P(A)+P(B)-P(A\\cup B)=${pA}+${pB}-${pU}=${d2(inter)}\\).</p>
          <p>\\(P_B(A)=\\dfrac{P(A\\cap B)}{P(B)}=\\dfrac{${d2(inter)}}{${pB}}=${d2(inter/ st.bank.t4.pB)}\\)
             <br> \\(P_A(B)=\\dfrac{P(A\\cap B)}{P(A)}=\\dfrac{${d2(inter)}}{${pA}}=${d2(inter/ st.bank.t4.pA)}\\).</p>`;
}

    $('#res',host).innerHTML = html; $('#res',host).className='res-ok'; retypeset($('#res',host));
  },

  reset(host){ innerHost(host).innerHTML=''; }
};



/* ========= Exercice 2 ‚Äî Identifier la bonne notation =========
   Objectif : √©crire la notation correspondant √† chaque phrase.
   ‚Ä¢ Deux conditionnelles (P_A(B) et P_B(A) ‚Äî on accepte aussi P(B|A), P(A|B))
   ‚Ä¢ Une intersection (P(A‚à©B))
   ‚Ä¢ Une r√©union      (P(A‚à™B))
   Les phrases sont contextuelles : sujet + deux propri√©t√©s naturelles.
*/
/* ========= Exercice 2 ‚Äî Identifier la notation (2 conditionnelles, 1 ‚à©, 1 ‚à™, avec au moins une n√©gation) ========= */
const ex2 = {
  id: 'classif_cond_union_inter',
  title: 'Identifier la notation (2 conditionnelles, 1 intersection, 1 r√©union ‚Äî avec n√©gations possibles)',

  /* ---------- Banque de contextes : sujet + A et B en 2 formes (sg/pl) ---------- */
/* ---------- Banque de 50 contextes (A/B en sg + pl, genre indiqu√©) ---------- */
/* ---------- Banque de 50 contextes (A/B en sg + pl, genre indiqu√©) ---------- */
_CTX: [
  { subj:'courriels', g:'m',
    A:{sg:"provient d‚Äôun client",                 pl:"proviennent d‚Äôun client"},
    B:{sg:"contient le mot ¬´ urgent ¬ª",           pl:"contiennent le mot ¬´ urgent ¬ª"} },

  { subj:'pi√®ces', g:'f',
    A:{sg:"est conforme",                         pl:"sont conformes"},
    B:{sg:"est contr√¥l√©e au laser",               pl:"sont contr√¥l√©es au laser"} },

  { subj:'dossiers', g:'m',
    A:{sg:"est complet",                          pl:"sont complets"},
    B:{sg:"est valid√© par le responsable",        pl:"sont valid√©s par le responsable"} },

  { subj:'√©l√®ves', g:'m',
    A:{sg:"a rendu le devoir",                    pl:"ont rendu le devoir"},
    B:{sg:"participe au club de maths",           pl:"participent au club de maths"} },

  { subj:'√©tudiants', g:'m',
    A:{sg:"suit l‚Äôoption informatique",           pl:"suivent l‚Äôoption informatique"},
    B:{sg:"fait du sport universitaire",          pl:"font du sport universitaire"} },

  { subj:'livres', g:'m',
    A:{sg:"est emprunt√©",                         pl:"sont emprunt√©s"},
    B:{sg:"est un ouvrage scientifique",          pl:"sont des ouvrages scientifiques"} },

  { subj:'v√©hicules', g:'m',
    A:{sg:"est √©lectrique",                       pl:"sont √©lectriques"},
    B:{sg:"est utilitaire",                       pl:"sont utilitaires"} },

  { subj:'logements', g:'m',
    A:{sg:"est meubl√©",                           pl:"sont meubl√©s"},
    B:{sg:"dispose d‚Äôun balcon",                  pl:"disposent d‚Äôun balcon"} },

  { subj:'commandes', g:'f',
    A:{sg:"est livr√©e √† l‚Äôheure",                 pl:"sont livr√©es √† l‚Äôheure"},
    B:{sg:"est exp√©di√©e en express",              pl:"sont exp√©di√©es en express"} },

  { subj:'paquets', g:'m',
    A:{sg:"est fragile",                          pl:"sont fragiles"},
    B:{sg:"est assur√©",                           pl:"sont assur√©s"} },

  { subj:'jours', g:'m',
    A:{sg:"est pluvieux",                         pl:"sont pluvieux"},
    B:{sg:"est venteux",                          pl:"sont venteux"} },

  /* #12 corrig√© : deux propri√©t√©s compatibles */
  { subj:'trajets', g:'m',
    A:{sg:"subit un retard",                      pl:"subissent un retard"},
    B:{sg:"passe par une d√©viation",              pl:"passent par une d√©viation"} },

  { subj:'trains', g:'m',
    A:{sg:"est direct",                           pl:"sont directs"},
    B:{sg:"arrive √† l‚Äôheure",                     pl:"arrivent √† l‚Äôheure"} },

  { subj:'candidatures', g:'f',
    A:{sg:"est admissible",                       pl:"sont admissibles"},
    B:{sg:"est prioritaire",                      pl:"sont prioritaires"} },

  { subj:'capteurs', g:'m',
    A:{sg:"est calibr√©",                          pl:"sont calibr√©s"},
    B:{sg:"est connect√©",                         pl:"sont connect√©s"} },

  { subj:'projets', g:'m',
    A:{sg:"respecte le budget",                   pl:"respectent le budget"},
    B:{sg:"respecte le d√©lai",                    pl:"respectent le d√©lai"} },

  { subj:'produits', g:'m',
    A:{sg:"est en stock",                         pl:"sont en stock"},
    B:{sg:"est bio",                              pl:"sont bio"} },

  { subj:'fichiers', g:'m',
    A:{sg:"est compress√©",                        pl:"sont compress√©s"},
    B:{sg:"est chiffr√©",                          pl:"sont chiffr√©s"} },

  { subj:'questions', g:'f',
    A:{sg:"porte sur l‚Äôalg√®bre",                  pl:"portent sur l‚Äôalg√®bre"},
    B:{sg:"est √† choix multiple",                 pl:"sont √† choix multiple"} },

  { subj:'√©chantillons', g:'m',
    A:{sg:"est conforme",                         pl:"sont conformes"},
    B:{sg:"est st√©rile",                          pl:"sont st√©riles"} },

  { subj:'visites', g:'f',
    A:{sg:"est guid√©e",                           pl:"sont guid√©es"},
    B:{sg:"est gratuite",                         pl:"sont gratuites"} },

  { subj:'photos', g:'f',
    A:{sg:"est nette",                            pl:"sont nettes"},
    B:{sg:"est sous-expos√©e",                     pl:"sont sous-expos√©es"} },

  { subj:'articles', g:'m',
    A:{sg:"est publi√© en ligne",                  pl:"sont publi√©s en ligne"},
    B:{sg:"est relu par un pair",                 pl:"sont relus par un pair"} },

  { subj:'messages', g:'m',
    A:{sg:"est non lu",                           pl:"sont non lus"},
    B:{sg:"contient une pi√®ce jointe",            pl:"contiennent une pi√®ce jointe"} },

  /* #25 corrig√© : plus de contradiction avec ¬´ manqu√© ¬ª */
  { subj:'appels', g:'m',
    A:{sg:"provient d‚Äôun contact connu",          pl:"proviennent d‚Äôun contact connu"},
    B:{sg:"dure plus de cinq minutes",            pl:"durent plus de cinq minutes"} },

  { subj:'livraisons', g:'f',
    A:{sg:"est partielle",                        pl:"sont partielles"},
    B:{sg:"est r√©frig√©r√©e",                       pl:"sont r√©frig√©r√©es"} },

  { subj:'colis', g:'m',
    A:{sg:"est volumineux",                       pl:"sont volumineux"},
    B:{sg:"est suivi",                            pl:"sont suivis"} },

  /* #28 ajust√© : ¬´ pay√©e ¬ª compatible avec ¬´ r√©gl√©e par virement ¬ª */
  { subj:'factures', g:'f',
    A:{sg:"est pay√©e",                            pl:"sont pay√©es"},
    B:{sg:"est r√©gl√©e par virement",              pl:"sont r√©gl√©es par virement"} },

  /* #30 ajust√© : les deux peuvent coexister */
  { subj:'r√©unions', g:'f',
    A:{sg:"est pr√©vue aujourd‚Äôhui",               pl:"sont pr√©vues aujourd‚Äôhui"},
    B:{sg:"se tient en visioconf√©rence",          pl:"se tiennent en visioconf√©rence"} },

  { subj:'machines', g:'f',
    A:{sg:"est en maintenance",                   pl:"sont en maintenance"},
    B:{sg:"est connect√©e au r√©seau",              pl:"sont connect√©es au r√©seau"} },

  { subj:'interventions', g:'f',
    A:{sg:"est urgente",                          pl:"sont urgentes"},
    B:{sg:"est planifi√©e",                        pl:"sont planifi√©es"} },

  { subj:'tickets', g:'m',
    A:{sg:"est r√©solu",                           pl:"sont r√©solus"},
    B:{sg:"est prioritaire",                      pl:"sont prioritaires"} },

  { subj:'r√©servations', g:'f',
    A:{sg:"est remboursable",                     pl:"sont remboursables"},
    B:{sg:"est modifiable",                       pl:"sont modifiables"} },

  { subj:'chambres', g:'f',
    A:{sg:"donne sur la mer",                     pl:"donnent sur la mer"},
    B:{sg:"est climatis√©e",                       pl:"sont climatis√©es"} },

  { subj:'patients', g:'m',
    A:{sg:"est diab√©tique",                       pl:"sont diab√©tiques"},
    B:{sg:"est suivi chaque mois",                pl:"sont suivis chaque mois"} },

  { subj:'clients', g:'m',
    A:{sg:"est fid√®le depuis trois ans",          pl:"sont fid√®les depuis trois ans"},
    B:{sg:"est abonn√© √† la newsletter",           pl:"sont abonn√©s √† la newsletter"} },

  { subj:'comptes', g:'m',
    A:{sg:"est v√©rifi√©",                          pl:"sont v√©rifi√©s"},
    B:{sg:"est premium",                          pl:"sont premium"} },

  { subj:'publications', g:'f',
    A:{sg:"est en acc√®s libre",                   pl:"sont en acc√®s libre"},
    B:{sg:"est illustr√©e",                        pl:"sont illustr√©es"} },

  { subj:'exp√©riences', g:'f',
    A:{sg:"est reproductible",                    pl:"sont reproductibles"},
    B:{sg:"est document√©e",                       pl:"sont document√©es"} },

  { subj:'mesures', g:'f',
    A:{sg:"est pr√©cise",                          pl:"sont pr√©cises"},
    B:{sg:"est sup√©rieure au seuil",              pl:"sont sup√©rieures au seuil"} },

  { subj:'capteurs IoT', g:'m',
    A:{sg:"√©met un signal anormal",               pl:"√©mettent un signal anormal"},
    B:{sg:"est aliment√© par batterie",            pl:"sont aliment√©s par batterie"} },

  { subj:'emails marketing', g:'m',
    A:{sg:"est ouvert",                           pl:"sont ouverts"},
    B:{sg:"contient un coupon",                   pl:"contiennent un coupon"} },

  { subj:'sessions', g:'f',
    A:{sg:"est active",                           pl:"sont actives"},
    B:{sg:"est s√©curis√©e",                        pl:"sont s√©curis√©es"} },

  { subj:'profils', g:'m',
    A:{sg:"est public",                           pl:"sont publics"},
    B:{sg:"est complet",                          pl:"sont complets"} },

  { subj:'r√©ponses', g:'f',
    A:{sg:"est correcte",                         pl:"sont correctes"},
    B:{sg:"est justifi√©e",                        pl:"sont justifi√©es"} },

  { subj:'trajets domicile-travail', g:'m',
    A:{sg:"se fait en v√©lo",                      pl:"se font en v√©lo"},
    B:{sg:"prend moins de vingt minutes",         pl:"prennent moins de vingt minutes"} },

  /* #47 corrig√© : deux propri√©t√©s compatibles */
  { subj:'commandes en ligne', g:'f',
    A:{sg:"est livr√©e √† domicile",                pl:"sont livr√©es √† domicile"},
    B:{sg:"est livr√©e dans la journ√©e",           pl:"sont livr√©es dans la journ√©e"} },

  { subj:'inscriptions', g:'f',
    A:{sg:"est valid√©e",                          pl:"sont valid√©es"},
    B:{sg:"est pay√©e par carte",                  pl:"sont pay√©es par carte"} },

  { subj:'vols', g:'m',
    A:{sg:"est long-courrier",                    pl:"sont long-courriers"},
    B:{sg:"part √† l‚Äôheure",                       pl:"partent √† l‚Äôheure"} },

  { subj:'livraisons express', g:'f',
    A:{sg:"est internationale",                   pl:"sont internationales"},
    B:{sg:"est suivie",                           pl:"sont suivies"} }
],



  /* ---------------------- Outils grammaire & tirages ---------------------- */
  _defDet(noun, g){ return /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(noun) ? "l‚Äô"+noun : (g==='f'?"la ":"le ")+noun; },
  _indefDet(noun, g){ return (g==='f'?"une ":"un ")+noun; },
  _singular(pl){ return String(pl).replace(/s$/,''); },

  _negate(phrase){
  let p = phrase.trim();

  // Correction pour les verbes compos√©s (commence par "provient", "contient", etc.)
  const verbNeg = [
    [/^est\b/i,             "n‚Äôest pas"],
    [/^sont\b/i,            "ne sont pas"],
    [/^a\b/i,               "n‚Äôa pas"],
    [/^ont\b/i,             "n‚Äôont pas"],
    [/^fait\b/i,            "ne fait pas"],
    [/^font\b/i,            "ne font pas"],
    [/^contient\b/i,        "ne contient pas"],
    [/^contiennent\b/i,     "ne contiennent pas"],
    [/^provient\b/i,        "ne provient pas"],
    [/^proviennent\b/i,     "ne proviennent pas"],
    [/^dispose\b/i,         "ne dispose pas"],
    [/^disposent\b/i,       "ne disposent pas"],
    [/^respecte\b/i,        "ne respecte pas"],
    [/^respectent\b/i,      "ne respectent pas"],
    [/^arrive\b/i,          "n‚Äôarrive pas"],
    [/^arrivent\b/i,        "n‚Äôarrivent pas"],
    [/^porte\b/i,           "ne porte pas"],
    [/^portent\b/i,         "ne portent pas"],
    [/^donne\b/i,           "ne donne pas"],
    [/^donnent\b/i,         "ne donnent pas"],
    [/^prend\b/i,           "ne prend pas"],
    [/^prennent\b/i,        "ne prennent pas"],
    [/^se fait\b/i,         "ne se fait pas"],
    [/^se font\b/i,         "ne se font pas"]
  ];

  for (const [re, rep] of verbNeg) {
    if (re.test(p)) return p.replace(re, rep);
  }

  // Cas g√©n√©rique : si √ßa commence par une voyelle ‚Üí "n‚Äô", sinon "ne"
  const startsVowel = /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(p);
  return (startsVowel ? "n‚Äô" : "ne ") + p + " pas";
},


  _shareTooMuch(a,b){ // rejette A/B trop proches lexicalement
    const tok = s => s.toLowerCase().normalize('NFD').replace(/[^a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º\-']/g,' ').split(/\s+/).filter(x=>x.length>=4);
    const A = new Set(tok(a)), B = new Set(tok(b));
    let common=0; A.forEach(w=>{ if(B.has(w)) common++; });
    const small = Math.min(A.size||1, B.size||1);
    return common / small >= 0.6; // >60% commun -> trop proche
  },

  _pct(a,b){ return Math.floor(Math.random()*(b-a+1))+a; },

  gen(){
    // 1) contexte distinct (√©vite A/B trop proches)
    let ctx;
    for(let tries=0; tries<30; tries++){
      const c = this._CTX[Math.floor(Math.random()*this._CTX.length)];
      if(!this._shareTooMuch(c.A.sg, c.B.sg)) { ctx=c; break; }
    }
    if(!ctx) ctx = this._CTX[0];

    // 2) % r√©alistes
    const pctUnion = this._pct(35,90);
    const pctInter = this._pct(5,40);
    const pctCond  = ()=> this._pct(12,88);

    // 3) Fabrique les 4 items (ordre m√©lang√©)
    const make = {
      union : { tag:'union', txt: p => `${p}% des ${ctx.subj} ${ctx.A.pl} ou ${ctx.B.pl}.`, p: pctUnion },
      inter : { tag:'inter', txt: p => `${p}% des ${ctx.subj} ${ctx.A.pl} et ${ctx.B.pl}.`,       p: pctInter },
      condAB: { tag:'condAB',txt: p => `Parmi les ${ctx.subj} qui ${ctx.A.pl}, ${p}% ${ctx.B.pl} aussi.`,       p: pctCond() },
      condBA: { tag:'condBA',txt: p => `Sur les ${ctx.subj} qui ${ctx.B.pl}, ${p}% ${ctx.A.pl} √©galement.`,     p: pctCond() },
    };
    let pool = [make.union, make.inter, make.condAB, make.condBA].map(o => ({...o, p: (typeof o.p==='function'?o.p():o.p)}));

    // 4) Injecte une N√âGATION dans l‚Äôun des 4 (al√©atoirement)
    const negIdx = Math.floor(Math.random()*pool.length);
    pool = pool.map((o,i)=>{
      if(i!==negIdx) return o;
      if(o.tag==='union'){
        // A ‚à™ \bar B (ou \bar A ‚à™ B) -> choisissez une des deux
        const flip = Math.random()<0.5;
        const txt = flip
          ? (p => `${p}% des ${ctx.subj} ${ctx.A.pl} ou ${this._negate(ctx.B.pl)}.`)
          : (p => `${p}% des ${ctx.subj} ${this._negate(ctx.A.pl)} ou ${ctx.B.pl}.`);
        return {...o, tag: flip?'unionAbarB':'unionABarB', txt};
      }
      if(o.tag==='inter'){
        // A ‚à© \bar B (ou \bar A ‚à© B)
        const flip = Math.random()<0.5;
        const txt = flip
          ? (p => `${p}% des ${ctx.subj} ${ctx.A.pl} et ${this._negate(ctx.B.pl)}.`)
          : (p => `${p}% des ${ctx.subj} ${this._negate(ctx.A.pl)} et ${ctx.B.pl}.`);
        return {...o, tag: flip?'interAbarB':'interABarB', txt};
      }
      if(o.tag==='condAB'){
        // P( \bar B | A )
        const txt = p => `Parmi les ${ctx.subj} qui ${ctx.A.pl}, ${p}% ${this._negate(ctx.B.pl)}.`;
        return {...o, tag:'condABbar', txt};
      }
      if(o.tag==='condBA'){
        // P( \bar A | B )
        const txt = p => `Sur les ${ctx.subj} qui ${ctx.B.pl}, ${p}% ${this._negate(ctx.A.pl)}.`;
        return {...o, tag:'condBAbar', txt};
      }
      return o;
    });

    // 5) M√©lange et num√©rote
    pool.sort(()=>Math.random()-0.5);
    const labels=['a','b','c','d'];
    const items = pool.map((o,i)=>({ id:`q${i+1}`, letter:labels[i], tag:o.tag, text:o.txt(o.p) }));

    return { ctx, items };
  },

  /* ====== 1) Liste d'options propos√©es dans le <select> ====== */
_options(){
  const Abar = BAR.A, Bbar = BAR.B;
  return [
    {v:'',                text:'‚Äî choisir ‚Äî'},

    // simples
    {v:'PA',              text:'P(A)'},
    {v:'PB',              text:'P(B)'},
    {v:'PnotA',           text:`P(${Abar})`},
    {v:'PnotB',           text:`P(${Bbar})`},

    // intersections
    {v:'interAB',         text:'P(A‚à©B)'},
    {v:'interAbarB',      text:`P(A‚à©${Bbar})`},
    {v:'interABarB',      text:`P(${Abar}‚à©B)`},

    // r√©unions
    {v:'unionAB',         text:'P(A‚à™B)'},
    {v:'unionAbarB',      text:`P(A‚à™${Bbar})`},
    {v:'unionABarB',      text:`P(${Abar}‚à™B)`},

    // conditionnelles (sachant en indice)
    {v:'condAB',          text:'P_A(B)'},
    {v:'condABbar',       text:`P_A(${Bbar})`},
    {v:'condBA',          text:'P_B(A)'},
    {v:'condBAbar',       text:`P_B(${Abar})`},
  ];
},


/* ====== 2) Rendu : intro + 4 phrases + SELECT (au lieu d‚Äôinput texte) ====== */
render(host, st){
  const sing = this._singular(st.ctx.subj);
  const intro =
    `On choisit au hasard ${this._indefDet(sing, st.ctx.g)}. <br>`+
    `On consid√®re les √©v√©nements suivants : <br>`+
    `\\(A\\) : ¬´ ${this._defDet(sing, st.ctx.g)} ${st.ctx.A.sg} ¬ª, `+
    `\\(B\\) : ¬´ ${this._defDet(sing, st.ctx.g)} ${st.ctx.B.sg} ¬ª.`;

  const hint =
    `Choisir la notation : <em>conditionnelle</em> \\(P(\\cdot\\mid\\cdot)\\) ou \\(P_{\\,\\cdot}(\\cdot)\\), `+
    `<em>intersection</em> \\(P(\\cdot\\cap\\cdot)\\), <em>r√©union</em> \\(P(\\cdot\\cup\\cdot)\\). `+
    `Pour les phrases n√©gatives, les options avec \\(A'\\) / \\(B'\\) sont disponibles.`;

  const opts = this._options().map(o=>`<option value="${o.v}">${o.text}</option>`).join('');

  const blocks = [
    { labelHTML: intro },
   ... st.items.map(it => ({
  labelHTML: `${it.letter} ) ${it.text}<br>`,
  rightHTML: mkMathSelectHTML(it.id, 220)   // ‚Üê remplace <select>
}))

  ];

  renderRowsInputRight(
    host,
    "Pour chaque affirmation, indiquer s‚Äôil s‚Äôagit d‚Äôune probabilit√© conditionnelle, d‚Äôune intersection ou d‚Äôune r√©union en donnant la notation correspondante.",
    blocks
  );
initMathSelect(host);
try{ MathJax.typesetPromise([host]); }catch(_){}

retypeset(host);
},

/* ====== 3) Correction : compare le code s√©lectionn√© au tag attendu ====== */
correct(host, st){
  const ACCEPT = {
    condAB:['condAB'], condBA:['condBA'],
    condABbar:['condABbar'], condBAbar:['condBAbar'],
    inter:['interAB'], interAbarB:['interAbarB'], interABarB:['interABarB'],
    union:['unionAB'], unionAbarB:['unionAbarB'], unionABarB:['unionABarB'],
  };

  let anyWrong = false;
  let anyAnswered = false;
  let allAnswered = true;

  st.items.forEach(it=>{
    const sel = document.getElementById(it.id); // <input type="hidden">
    const val = sel ? sel.value : '';

    if(!val){            // rien de choisi -> pas de tick, pas de sanction
      setTickForInput(sel, null);
      allAnswered = false;
      return;
    }

    anyAnswered = true;
    const ok = (ACCEPT[it.tag] || []).includes(val);
    setTickForInput(sel, ok);
    if(!ok) anyWrong = true;
  });

  

  // Score : on ne compte point que si tout est r√©pondu ET correct
  return { ok: allAnswered && !anyWrong, total: 1 };
},



/* ====== 4) (Optionnel) Solution : affiche la bonne option en LaTeX ====== */
solution(host, st){
  const latex = {
    condAB:'\\(P_A(B)\\)', condBA:'\\(P_B(A)\\)',
    condABbar:'\\(P_A(\\overline{B})\\)', condBAbar:'\\(P_B(\\overline{A})\\)',
    inter:'\\(P(A\\cap B)\\)', interAbarB:'\\(P(A\\cap \\overline{B})\\)', interABarB:'\\(P(\\overline{A}\\cap B)\\)',
    union:'\\(P(A\\cup B)\\)', unionAbarB:'\\(P(A\\cup \\overline{B})\\)', unionABarB:'\\(P(\\overline{A}\\cup B)\\)'
  };
  const html = st.items.map(it => `<p>${it.letter}) ${latex[it.tag]||''}</p>`).join('');
  $('#res',host).innerHTML = html;
  $('#res',host).className='res-ok';
  retypeset($('#res',host));
},


  reset(host){ innerHost(host).innerHTML=''; }
};


/* ===== Exercice 3 ‚Äî Banque (20) type ¬´ CDD / moins de 30 ans ¬ª ===== */
const EX3_BANK = (() => {
  const ctxs = [
    {D:'l‚Äôemploy√© est en CDD', J:'l‚Äôemploy√© a moins de 30 ans', d:'D', j:'J', pop:'Dans l‚Äôadministration'},
    {D:'le client poss√®de un abonnement Premium', J:'le client a moins de 25 ans', d:'P', j:'J', pop:'Dans la base clients'},
    {D:'le v√©hicule est √©lectrique', J:'le v√©hicule a moins de 3 ans', d:'E', j:'A', pop:'Dans le parc auto'},
    {D:'le patient est fumeur', J:'le patient a moins de 30 ans', d:'F', j:'J', pop:'Dans le cabinet'}
  ];
  const L=[];
  for(let k=0;k<20;k++){
    const c = choice(ctxs);
    const pD = rnd(15,35)/100;
    const pJ_D = rnd(45,80)/100;      // ¬´ 60% des CDD ont <30 ans ¬ª-like
    const pJ_notD = rnd(15,45)/100;   // ¬´ 30% des CDI ont <30 ans ¬ª-like
    L.push({c, pD, pJ_D, pJ_notD});
  }
  return L;
})();

const ex3 = {
  id:'bank_cdd30',
  title:'Traduire les donn√©es & calculer une conjonction',
  gen(){ return choice(EX3_BANK); },
  render(host, st){
    const c = st.c;
    const pD = Math.round(st.pD*100);
    const pJ_D = Math.round(st.pJ_D*100);
    const pJ_notD = Math.round(st.pJ_notD*100);
    const rows = [
      {labelHTML:`${c.pop}. On consid√®re \\(D:\\) ¬´ ${c.D} ¬ª et \\(J:\\) ¬´ ${c.J} ¬ª.`, rightHTML:''},
      {labelHTML:`a) Traduire : \\(P(${c.d})\\), \\(P_{${c.d}}(${c.j})\\), \\(P_{\\overline{${c.d}}}(${c.j})\\).<br><small>D‚Äôapr√®s : ${pD}% ; ${pJ_D}% ; ${pJ_notD}%</small>`, id:'e3a'},
      {labelHTML:`b) D√©terminer \\(P(${c.d}\\cap ${c.j})\\).`, id:'e3b'}
    ];
    renderRows(host,'√âcrire les probabilit√©s puis calculer une conjonction. Les valeurs peuvent √™tre en %, fraction ou d√©cimal.', rows, true);
  },
  correct(host, st){
    const c=st.c, pD=st.pD, pJ_D=st.pJ_D;
    // a) on attend un texte qui contient les 3 notations (on reste souple)
    const a = String($('#e3a',host).value||'').replace(/\s+/g,'');
    const okA = a.includes(`P(${c.d})`) && a.includes(`P_${c.d}(${c.j})`) && a.includes(`P_\\overline{${c.d}}(${c.j})`);
    const b = parseProbFlexible($('#e3b',host).value);
    const exp = pD * pJ_D;
    const okB = Number.isFinite(b) && same(b,exp,1e-3);
    const ok = okA && okB;
    $('#res',host).innerHTML = ok ? '‚úî' : '‚úò Astuce : \\(P(D\\cap J)=P(D)\\times P_D(J)\\).';
    $('#res',host).className = ok?'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const c=st.c;
    const L = [
      `a) \\(P(${c.d})=${st.pD.toFixed(2)}\\), \\(P_{${c.d}}(${c.j})=${st.pJ_D.toFixed(2)}\\), \\(P_{\\overline{${c.d}}}(${c.j})=${st.pJ_notD.toFixed(2)}\\).`,
      `b) \\(P(${c.d}\\cap ${c.j})=P(${c.d})\\times P_{${c.d}}(${c.j})=${(st.pD*st.pJ_D).toFixed(3)}\\).`
    ].map(x=>`<p>${x}</p>`).join('');
    $('#res',host).innerHTML=L; $('#res',host).className='res-ok'; retypeset($('#res',host));
  },
  reset(host){ innerHost(host).innerHTML=''; }
};

/* ===== Exercice 4 ‚Äî Banque (20) type ¬´ SAV : pannes A/B ¬ª ===== */
const EX4_BANK = (() => {
  const scenes = [
    {A:'panne A', B:'panne B', a:'A', b:'B', who:'Un SAV a constat√©'},
    {A:'d√©faut majeur', B:'d√©faut mineur', a:'M', b:'m', who:'Un contr√¥le qualit√© observe'},
    {A:'bug logiciel', B:'d√©faut mat√©riel', a:'L', b:'H', who:'Un service technique note'}
  ];
  const L=[];
  for(let k=0;k<20;k++){
    const s=choice(scenes);
    const pA=rnd(20,45)/100, pB=rnd(25,55)/100;
    let pAB=rnd(2,10)/100; // intersection
    if(pAB>Math.min(pA,pB)-0.01) pAB=Math.min(pA,pB)-0.02;
    L.push({s,pA,pB,pAB});
  }
  return L;
})();
const ex4 = {
  id:'bank_sav',
  title:'Conditionnelle ¬´ donn√©e A ¬ª : calculer \(P_B(A)\) ou \(P_A(B)\)',
  gen(){ return choice(EX4_BANK); },
  render(host, st){
    const s=st.s;
    const rows = [
      {labelHTML:`${s.who} que les retours sont dus √† \\(${Math.round(st.pA*100)}\\,\\%\\) √† ¬´ ${s.A} ¬ª, √† \\(${Math.round(st.pB*100)}\\,\\%\\) √† ¬´ ${s.B} ¬ª et √† \\(${Math.round(st.pAB*100)}\\,\\%\\) √† leur simultan√©it√©.`, rightHTML:''},
      {labelHTML:`Un appareil pr√©sente ¬´ ${s.A} ¬ª. D√©terminer la probabilit√© pour qu‚Äôil ait aussi ¬´ ${s.B} ¬ª.`, id:'e4'}
    ];
    renderRows(host,'R√©pondre en %, fraction ou d√©cimal.', rows, true);
  },
  correct(host, st){
    const v = parseProbFlexible($('#e4',host).value);
    const exp = st.pAB / st.pA; // P(B|A) = P(A‚à©B)/P(A)
    const ok = Number.isFinite(v) && same(v,exp,1e-3);
    $('#res',host).innerHTML = ok ? '‚úî' : '‚úò Formule : \\(P_{A}(B)=\\dfrac{P(A\\cap B)}{P(A)}\\).';
    $('#res',host).className = ok?'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    $('#res',host).innerHTML =
      `<p>\\(P_{A}(B)=\\dfrac{P(A\\cap B)}{P(A)}=\\dfrac{${st.pAB.toFixed(3)}}{${st.pA.toFixed(3)}}=${(st.pAB/st.pA).toFixed(3)}\\).</p>`;
    $('#res',host).className='res-ok'; retypeset($('#res',host));
  },
  reset(host){ innerHost(host).innerHTML=''; }
};

/* ===== Exercice 5 ‚Äî Banque (20) type ¬´ Commerciaux / voiture de fonction ¬ª ===== */
const EX5_BANK = (() => {
  const places = [
    {C:'l‚Äôemploy√© interrog√© est un commercial', V:'l‚Äôemploy√© poss√®de une voiture de fonction', c:'C', v:'V', who:'Dans l‚Äôentreprise'},
    {C:'l‚Äôagent interrog√© travaille au service support', V:'l‚Äôagent dispose d‚Äôun poste portable', c:'S', v:'P', who:'Dans l‚Äôorganisation'},
    {C:'l‚Äô√©tudiant interrog√© suit la fili√®re info', V:'l‚Äô√©tudiant dispose d‚Äôun ordinateur pr√™t√©', c:'I', v:'O', who:'Dans la promo'}
  ];
  const L=[];
  for(let k=0;k<20;k++){
    const p=choice(places);
    const pC = rnd(55,85)/100;
    const pV_C = rnd(60,90)/100;
    const pV_notC = rnd(5,25)/100;
    L.push({p, pC, pV_C, pV_notC});
  }
  return L;
})();

const ex5 = {
  id:'bank_commercial_voiture',
  title:'D√©duire & calculer \(P(C\\cap V)\) et \(P(\\overline{C}\\cap V)\)',
  gen(){ return choice(EX5_BANK); },
  render(host, st){
    const p = st.p;
    const rows = [
      {labelHTML:`${p.who}, on interroge au hasard un employ√©. Soient \\(C:\\) ¬´ ${p.C} ¬ª et \\(V:\\) ¬´ ${p.V} ¬ª.`, rightHTML:''},
      {labelHTML:`1a) Donner \\(P(${p.c})\\) et \\(P(\\overline{${p.c}})\\).`, id:'e5_1a'},
      {labelHTML:`1b) Donner \\(P_{${p.c}}(${p.v})\\) et \\(P_{\\overline{${p.c}}}(${p.v})\\).`, id:'e5_1b'},
      {labelHTML:`2a) D√©finir par une phrase l‚Äô√©v√©nement \\(${p.c}\\cap ${p.v}\\). Puis calculer \\(P(${p.c}\\cap ${p.v})\\).`, id:'e5_2a'},
      {labelHTML:`2b) D√©finir par une phrase l‚Äô√©v√©nement \\(\\overline{${p.c}}\\cap ${p.v}\\). Puis calculer \\(P(\\overline{${p.c}}\\cap ${p.v})\\).`, id:'e5_2b'}
    ];
    renderRows(host, 'Compl√©ter : notations puis calculs (valeurs en %, d√©cimal ou fraction).', rows);
  },
  correct(host, st){
    const p=st.p;
    // 1a / 1b : on v√©rifie juste que les notations attendues apparaissent (souplesse)
    const a = String($('#e5_1a',host).value||'').replace(/\s+/g,'');
    const b = String($('#e5_1b',host).value||'').replace(/\s+/g,'');
    const ok1a = a.includes(`P(${p.c})`) && a.includes(`P(\\overline{${p.c}})`);
    const ok1b = b.includes(`P_${p.c}(${p.v})`) && b.includes(`P_\\overline{${p.c}}(${p.v})`);
    // 2a : texte + nombre
    const t2a = String($('#e5_2a',host).value||'');
    const num2a = parseProbFlexible(t2a);
    const exp2a = st.pC * st.pV_C;
    const ok2aText = /commercial|voiture|fonction|portable|support|info|ordinateur|pr√™t√©/i.test(t2a);
    const ok2aNum = Number.isFinite(num2a) && same(num2a, exp2a, 1e-3);
    // 2b
    const t2b = String($('#e5_2b',host).value||'');
    const num2b = parseProbFlexible(t2b);
    const exp2b = (1-st.pC) * st.pV_notC;
    const ok2bText = /non|pas|sans|n‚Äô/i.test(t2b) || /overline/.test(t2b);
    const ok2bNum = Number.isFinite(num2b) && same(num2b, exp2b, 1e-3);

    const ok = ok1a && ok1b && ok2aText && ok2aNum && ok2bText && ok2bNum;
    $('#res',host).innerHTML = ok ? '‚úî' :
      '‚úò Rappels : \\(P(C\\cap V)=P(C)\\,P_C(V)\\) et \\(P(\\overline{C}\\cap V)=P(\\overline{C})\\,P_{\\overline{C}}(V)\\).';
    $('#res',host).className = ok?'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const p=st.p, pc=st.pC, pvC=st.pV_C, pvNc=st.pV_notC;
    const html = [
      `1a) \\(P(${p.c})=${pc.toFixed(2)}\\) ; \\(P(\\overline{${p.c}})=${(1-pc).toFixed(2)}\\).`,
      `1b) \\(P_{${p.c}}(${p.v})=${pvC.toFixed(2)}\\) ; \\(P_{\\overline{${p.c}}}(${p.v})=${pvNc.toFixed(2)}\\).`,
      `2a) \\(${p.c}\\cap ${p.v}\\) : ¬´ ${p.C} ET ${p.V} ¬ª. \\(P=${(pc*pvC).toFixed(3)}\\).`,
      `2b) \\(\\overline{${p.c}}\\cap ${p.v}\\) : ¬´ non-${p.C} ET ${p.V} ¬ª. \\(P=${((1-pc)*pvNc).toFixed(3)}\\).`
    ].map(x=>`<p>${x}</p>`).join('');
    $('#res',host).innerHTML = html; $('#res',host).className='res-ok'; retypeset($('#res',host));
  },
  reset(host){ innerHost(host).innerHTML=''; }
};

/* ====== REGISTRY + moteur ====== */
const REGISTRY = [ex1, ex2, ex3, ex4, ex5];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $('#score').textContent = `Score : ${scoreOK} / ${scoreTot}`; }

function buildOne(){
  const host=$('#host'); const sel=$('#exo-select');
  const def = REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st = def.gen();
  host.dataset.active = def.id;
  host.dataset.state = JSON.stringify(st);
  def.render(host, st);
  const res = $('#res',host); if(res){ res.textContent=''; res.className='res'; }
  addTicks();
}
function check(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  if(!allFilled()){ $('#res',host).textContent=''; $('#res',host).className='res'; return; }
  const st = JSON.parse(host.dataset.state||'{}');
  const r = def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def||!def.solution) return;
  const st = JSON.parse(host.dataset.state||'{}'); def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def&&def.reset) def.reset(host);
}

document.addEventListener('DOMContentLoaded', ()=>{
  innerHost(document.getElementById('host'));
  const sel=$('#exo-select');
  REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change', buildOne);
  $('#btn-new').addEventListener('click', buildOne);
  $('#btn-check').addEventListener('click', check);
  $('#btn-solution').addEventListener('click', solution);
  $('#btn-reset').addEventListener('click', resetAll);
  sel.value=REGISTRY[0].id; buildOne(); updateScore();

  document.addEventListener('keydown', ev=>{
    const a=document.activeElement;
    if(ev.key==='Enter' && a && a.matches('#host input[type=text]') && !a.closest('.equ-offscreen')){
      ev.preventDefault(); try{ check(); }catch(_){}
    }
  });

  // PDF si pr√©sent (m√™me API que tes fiches)
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Premi√®re ‚Äì Probabilit√©s conditionnelles',
      max:50,
      mountAfterSelector:'.card.small',
      beforeRender(def, st, withSolutions){
        const tmp = document.createElement('div');
        tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
        def.render(tmp, st);
        if(!withSolutions){
          const off = tmp.querySelector('.equ-offscreen');
          return off ? off.innerHTML : '';
        } else if(def.solution){
          def.solution(tmp, st);
          return tmp.querySelector('#res')?.innerHTML || '';
        }
        return '';
      }
    });
  }
});
})();
</script>

<!-- JS fournis -->
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/fraction-sign-clarity.dom.v3.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn'); clone.type='button'; clone.removeAttribute('id');
          clone.addEventListener('click',(e)=>{e.preventDefault(); src.click();});
          bar.appendChild(clone);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center',behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r=parseFloat(c.getAttribute('r')||'5'); if(r<10) c.setAttribute('r','12'); c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
