<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Premi√®re ‚Äì Probabilit√©s conditionnelles (d√©finitions & propri√©t√©s)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #ddd;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap;margin-left:auto}
.small{font-size:.92rem;color:#666}

.hint{opacity:.9;margin:.2rem 0 .6rem}
.consigne .c-label{font-weight:600; margin-right:.35em}




.eq em { margin: 0 .28em; }
.mx { display:inline-block; margin:0 .28em; }
sub { font-size: .8em; vertical-align: -0.25em; }

.equ-offscreen{position:absolute !important; left:-10000px !important; width:1px !important; height:1px !important; overflow:hidden !important;}
@media print{
  .hint{display:none !important;}
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
  .equ-offscreen .c-label{display:none !important;}
}



/* une ligne = juste label + (√©ventuellement) input ; pas de zone 'res' dans la grille */
.row{
  display:grid;
  grid-template-columns:1fr;
  grid-template-areas:
    'lab'
    'inp';
  gap:10px; align-items:start;
}

/* r√©sultat global (#res) styl√© hors des .row */
.res{ padding:12px; border-radius:10px; background:#f7f7f7 }
.res-ok{background:#ecfdf5;border:1px solid #a7f3d0}
.res-ko{background:#fef2f2;border:1px solid #fecaca}

/* layout √† droite uniquement s‚Äôil y a un input (ton JS le fait d√©j√†) */
.row.right{
  display:grid;
  grid-template-columns: 1fr minmax(220px, 320px);
  grid-template-areas: "lab inp";
  gap:10px 14px;
  align-items:center;
}

@media (max-width:680px){
  .row.right{
    grid-template-columns:1fr;
    grid-template-areas: "lab" "inp";
  }
}


.tbl{border-collapse:collapse;border:1px solid #bbb}
.tbl td,.tbl th{border:1px solid #bbb;padding:6px;text-align:center}
@media print{
  .tbl{border:1px solid #000}
  .tbl td,.tbl th{border:1px solid #000}
}

.tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
.tick.ok{color:#059669}
.tick.ko{color:#dc2626}

.mselect{position:relative; display:inline-block; min-width:180px}
.ms-btn{display:flex; align-items:center; justify-content:space-between; width:100%;
  padding:8px 10px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer}
.ms-menu{position:absolute; z-index:20; top:100%; left:0; right:0; max-height:240px; overflow:auto;
  border:1px solid #ddd; background:#fff; border-radius:8px; margin-top:4px; box-shadow:0 6px 16px rgba(0,0,0,.08); display:none}
.ms-item{padding:8px 10px; cursor:pointer}
.ms-item:hover{background:#f3f4f6}
.mselect.open .ms-menu{display:block}

.line-full { margin: 6px 0 10px; }
.line-full p { margin: 0; }


</style>

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <div class="wrap" style="padding:0 18px">
      <div class="controls">
        <label for="exo-select">Type d‚Äôexercice :</label>
        <select id="exo-select"></select>
        <button id="btn-new" class="btn">üîÄ Nouvel √©nonc√©</button>
        <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
        <button id="btn-solution" class="btn">üí° Solution</button>
        <button id="btn-reset" class="btn">‚ôªÔ∏è R√©initialiser</button>
        <div class="score" id="score">Score : 0 / 0</div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div id="host"></div>
    </div>

    <div class="card small">
      <div><strong>Saisie & r√©ponses accept√©es :</strong></div>
      <ul class="tips">
        <li>D√©cimaux : virgule <em>ou</em> point (ex. <code>0,375</code> ou <code>0.375</code>).</li>
        <li>Fractions : forme <code>a/b</code> (ex. <code>3/8</code>).</li>
        <li>Pourcentages : forme <code>xx%</code> (ex. <code>37,5%</code>). Si le champ <strong>exige</strong> un ¬´ % ¬ª, la forme d√©cimale est refus√©e.</li>
        <li>Quand une r√©ponse demande une <strong>notation</strong>, √©crire au format \(P(A)\), \(P(A\\cap B)\), \(P_{A}(B)\) (i.e. \(P(B\\mid A)\)), \(P(A\\cup B)\), etc.</li>
        <li>Entr√©e ‚èé d√©clenche ¬´ V√©rifier ¬ª depuis une barre de saisie de l‚Äô√©nonc√©.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<script>
(() => {
/* ========= Mini utilitaires ========= */
const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = L => L[rnd(0,L.length-1)];
function innerHost(host){ if(!host.dataset.active){ host.dataset.active=''; host.innerHTML='<div class="inner"></div>'; } return host.querySelector('.inner'); }

function retypeset(root=document){
  try{
    if (window.MathJax?.typesetPromise) return MathJax.typesetPromise([root]);
    if (window.MathJax?.typeset) MathJax.typeset([root]);
  }catch(_){}
}

/* ===== parse nombres / % / fractions ===== */
const stripSignUnicode = s => String(s||'').replace(/‚àí/g,'-');
function parseNumberFR(s){
  s = stripSignUnicode(String(s||'').trim());
  if(!s) return NaN;
  if(/%/.test(s)) return NaN;
  s = s.replace(',', '.');
  return parseFloat(s);
}
function parsePercent(s){
  s = stripSignUnicode(String(s||'').trim());
  const m = s.match(/^([-+]?[0-9]+(?:[.,][0-9]+)?)\s*%$/);
  if(!m) return NaN;
  return parseFloat(m[1].replace(',', '.'))/100;
}
// accepte d√©cimal, fraction, % ‚Äî renvoie un nombre dans [0,1]
function parseProbFlexible(s){
  s = stripSignUnicode(String(s||'').trim());
  // fraction a/b
  let m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
  if(m){
    const a = parseInt(m[1],10), b = parseInt(m[2],10);
    if(b>0) return a/b;
  }
  // %
  const p = parsePercent(s);
  if(Number.isFinite(p)) return p;
  // d√©cimal
  const d = parseFloat(s.replace(',', '.'));
  return Number.isFinite(d) ? d : NaN;
}
function same(a,b,eps=1e-6){ return Math.abs(a-b)<=eps; }

/* ====== rendu commun ====== */
function stripHints(html){ return String(html||'').replace(/<small[\s\S]*?<\/small>/gi,''); }

function renderRows(host, consigneText, blocks, right=false){
  const root = innerHost(host); root.innerHTML='';
  const hint = document.createElement('div');
  hint.className='hint consigne';
  hint.innerHTML='<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
  root.appendChild(hint);

  const off = document.createElement('div');
  off.className='equ-offscreen';
  off.innerHTML = '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div>'
    + blocks.map(b => '<div class="equation">'+ stripHints(b.labelHTML||'') +'</div>').join('');
  root.appendChild(off);

 blocks.forEach(b=>{
  const hasInput = (b.rightHTML !== undefined) || !!b.id;

  // ‚¨áÔ∏è TEXTE SEUL ‚Üí pas de .row, juste un bloc plein large
  if (!hasInput) {
    const div = document.createElement('div');
    div.className = 'line-full';
    div.innerHTML = b.labelHTML || '';
    root.appendChild(div);
    return; // <- important
  }

  // ‚¨áÔ∏è LIGNE AVEC CHAMP ‚Üí grille √† droite
  const row = document.createElement('div');
  row.className = (right ? 'row right' : 'row');

  const lab = document.createElement('div');
  lab.className = 'col-label';
  lab.innerHTML = b.labelHTML || '';
  row.appendChild(lab);

  const incol = document.createElement('div');
  incol.className = 'input-line';
  if (b.rightHTML !== undefined) incol.innerHTML = b.rightHTML;
  else if (b.id) incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
  row.appendChild(incol);

  root.appendChild(row);
});

  root.appendChild(Object.assign(document.createElement('div'),{className:'res',id:'res'}));
  retypeset(root);
}

function addTicks(){
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    if(!inp.nextElementSibling || !inp.nextElementSibling.classList?.contains('tick'))
      inp.insertAdjacentHTML('afterend','<span class="tick"></span>');
  });
}
function setTick(inp, state){
  const t = inp.nextElementSibling?.classList?.contains('tick') ? inp.nextElementSibling : null;
  if(!t) return;
  if(state==null){ t.textContent=''; t.classList.remove('ok','ko'); return; }
  if(state){ t.textContent='‚úî'; t.classList.add('ok'); t.classList.remove('ko'); }
  else     { t.textContent='‚úò'; t.classList.add('ko'); t.classList.remove('ok'); }
}
function allFilled(){
  let ok=true;
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    if((inp.value||'').trim()==='') ok=false;
  });
  return ok;
}

// affiche avec au plus 2 d√©cimales (trim des z√©ros), √©vite les horreurs binaires
const d2 = x => {
  const v = Math.round(x*100)/100;
  let s = v.toFixed(2);
  s = s.replace(/\.?0+$/,'');   // "0.50" -> "0.5", "0.00" -> "0"
  return s;
};
// --- POLYFILL : rendu "plusieurs questions l'une sous l'autre" ---
if (typeof renderRowsUnderQuestions === 'undefined') {
  function renderRowsUnderQuestions(host, consigneText, blocks){
    const root = (function innerHost(h){
      if(!h.dataset.active){ h.dataset.active=''; h.innerHTML='<div class="inner"></div>'; }
      return h.querySelector('.inner');
    })(host);
    root.innerHTML = '';

    // Consigne visible
    const hint = document.createElement('div');
    hint.className = 'hint consigne';
    hint.innerHTML = '<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
    root.appendChild(hint);

    // Version "offscreen" pour export PDF
    const off = document.createElement('div');
    off.className = 'equ-offscreen';
    off.innerHTML =
      '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'
      + consigneText + '</span></div>'
      + blocks.map(b => '<div class="equation">'+ (b.labelHTML||'') +'</div>').join('');
    root.appendChild(off);

    // Questions + inputs
blocks.forEach(b=>{
  const hasInput = (b.rightHTML !== undefined) || !!b.id;

  // ‚¨áÔ∏è TEXTE SEUL ‚Üí pas de .row, juste un bloc plein large
  if (!hasInput) {
    const div = document.createElement('div');
    div.className = 'line-full';
    div.innerHTML = b.labelHTML || '';
    root.appendChild(div);
    return; // <- important
  }

  // ‚¨áÔ∏è LIGNE AVEC CHAMP ‚Üí grille √† droite
  const row = document.createElement('div');
  row.className = (right ? 'row right' : 'row');

  const lab = document.createElement('div');
  lab.className = 'col-label';
  lab.innerHTML = b.labelHTML || '';
  row.appendChild(lab);

  const incol = document.createElement('div');
  incol.className = 'input-line';
  if (b.rightHTML !== undefined) incol.innerHTML = b.rightHTML;
  else if (b.id) incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
  row.appendChild(incol);

  root.appendChild(row);
});


    // Zone r√©sultat
    root.appendChild(Object.assign(document.createElement('div'), { className:'res', id:'res' }));

    // (si MathJax est l√†)
    try{ if(window.MathJax?.typesetPromise) MathJax.typesetPromise([root]); else if(window.MathJax?.typeset) MathJax.typeset([root]); }catch(_){}
  }
}

// --- POLYFILL : rendu "question √† gauche, saisie/SELECT √† droite"
// --- POLYFILL : rendu "question √† gauche, saisie/SELECT √† droite" (auto-pleine largeur si pas d'input)
if (typeof renderRowsInputRight === 'undefined') {
  function renderRowsInputRight(host, consigneText, blocks){
    // 1) host / inner
    function innerHost(h){
      if(!h.dataset.active){ h.dataset.active=''; h.innerHTML='<div class="inner"></div>'; }
      return h.querySelector('.inner');
    }
    const root = innerHost(host);
    root.innerHTML = '';

    // 2) Consigne visible
    const hint = document.createElement('div');
    hint.className = 'hint consigne';
    hint.innerHTML = '<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
    root.appendChild(hint);

    // 3) Version offscreen (PDF)
    const off = document.createElement('div');
    off.className = 'equ-offscreen';
    off.innerHTML =
      '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div>' +
      blocks.map(b => '<div class="equation">'+ (b.labelHTML||'') +'</div>').join('');
    root.appendChild(off);

    // 4) Lignes : libell√© √† gauche, champ √† droite SI et seulement si un input existe
    blocks.forEach(b=>{
      const hasInput = (b.rightHTML !== undefined) || !!b.id;

      const row = document.createElement('div');
      row.className = hasInput ? 'row right' : 'row';

      const lab = document.createElement('div');
      lab.className = 'col-label';
      lab.innerHTML = b.labelHTML || '';
      row.appendChild(lab);

      if (hasInput) {
        const incol = document.createElement('div');
        incol.className = 'input-line';
        if (b.rightHTML !== undefined) {
          incol.innerHTML = b.rightHTML;                // ex. <select ‚Ä¶> ou mselect custom
        } else if (b.id) {
          incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
        }
        row.appendChild(incol);
      }

      root.appendChild(row);
    });

    // 5) Zone r√©sultat
    root.appendChild(Object.assign(document.createElement('div'), { className:'res', id:'res' }));

    // 6) MathJax
    try{
      if (window.MathJax?.typesetPromise) MathJax.typesetPromise([root]);
      else if (window.MathJax?.typeset)   MathJax.typeset([root]);
    }catch(_){}
  }
}



// sujets f√©minins (sinon masculin)
const FEM_SUBJECTS = new Set([
  'pi√®ces','analyses','commandes','factures','machines','candidatures',
  'questions','exp√©ditions','√©chantillons'
]);

function toSingularFR(plur){ return String(plur||'').trim().replace(/s$/,''); }
function startsWithVowelLikeFR(w){ return /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(String(w||'')); }
function defDetFR(noun, isFem){ return startsWithVowelLikeFR(noun) ? "l‚Äô"+noun : (isFem?"la ":"le ")+noun; }
function indefDetFR(noun, isFem){ return (isFem?"une ":"un ")+noun; }

// met la proposition au singulier (verbes + quelques adjectifs fr√©quents)
function singularizePropFR(s, isFem=false){
  let t = String(s||'').trim();

  // verbes au d√©but
  const vb = [
    [/^sont\b/i, 'est'],
    [/^ont\b/i, 'a'],
    [/^proviennent\b/i, 'provient'],
    [/^contiennent\b/i, 'contient'],
    [/^arrivent\b/i, 'arrive'],
    [/^concernent\b/i, 'concerne'],
    [/^commandent\b/i, 'commande'],
    [/^paient\b/i, 'paie'],
    [/^utilisent\b/i, 'utilise'],
    [/^respectent\b/i, 'respecte'],
  ];
  vb.forEach(([re, rep]) => { t = t.replace(re, rep); });

  // pluriels fr√©quents ‚Üí singuliers
  const adj = [
    [/\burgents\b/gi, 'urgent'],
    [/\bf√©ri√©s\b/gi, 'f√©ri√©'],
    [/\bfragiles\b/gi, 'fragile'],
    [/\bpublics\b/gi, 'public'],
    [/\br√©serv√©s\b/gi, 'r√©serv√©'],
    [/\btermin√©s\b/gi, 'termin√©'],
    [/\bdirects\b/gi, 'direct'],
    [/\b√©lectriques\b/gi, '√©lectrique'],
    [/\bmeubl√©s\b/gi, 'meubl√©'],
    [/\bcomplets\b/gi, 'complet'],
    [/\br√©gl√©s\b/gi, 'r√©gl√©'],
    [/\bannul√©s\b/gi, 'annul√©'],

    // f√©minins pluriels
    [/\bcompl√®tes\b/gi, 'compl√®te'],
    [/\br√©gl√©es\b/gi, 'r√©gl√©e'],
    [/\bannul√©es\b/gi, 'annul√©e'],
    [/\binternationales\b/gi, 'internationale'],
    [/\burgentes\b/gi, 'urgente'],
  ];
  adj.forEach(([re, rep]) => { t = t.replace(re, rep); });

  // "des X‚Ä¶" ‚Üí "un/une X‚Ä¶" quand √ßa suit un verbe de contenu (concerne/contient/provient‚Ä¶)
  t = t.replace(/\bdes\s+([a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º\-']+?)s\b/gi, (_m, w) => (isFem?'une ':'un ')+w);

  return t;
}

// AÃÖ / BÃÖ en texte (fonctionne dans <option>)
const BAR = {
  A: 'A\u0305',   // AÃÖ
  B: 'B\u0305'    // BÃÖ
};
function msOptionsLatex(){
  return [
    {v:'', latex:'\\text{‚Äî choisir ‚Äî}'},
    {v:'PA', latex:'P(A)'}, {v:'PB', latex:'P(B)'},
    {v:'PnotA', latex:'P(\\overline{A})'}, {v:'PnotB', latex:'P(\\overline{B})'},
    {v:'interAB', latex:'P(A\\cap B)'},
    {v:'interAbarB', latex:'P(A\\cap \\overline{B})'},
    {v:'interABarB', latex:'P(\\overline{A}\\cap B)'},
    {v:'unionAB', latex:'P(A\\cup B)'},
    {v:'unionAbarB', latex:'P(A\\cup \\overline{B})'},
    {v:'unionABarB', latex:'P(\\overline{A}\\cup B)'},
    {v:'condAB', latex:'P_{A}(B)'},
    {v:'condABbar', latex:'P_{A}(\\overline{B})'},
    {v:'condBA', latex:'P_{B}(A)'},
    {v:'condBAbar', latex:'P_{B}(\\overline{A})'},
  ];
}

function mkMathSelectHTML(selectId, width=220){
  const opts = msOptionsLatex();
  const items = opts.map(o =>
    `<div class="ms-item" data-v="${o.v}" data-latex="${o.latex}">\\(${o.latex}\\)</div>`
  ).join('');
return `
  <div class="mselect" data-for="${selectId}" style="min-width:${width}px">
    <button type="button" class="ms-btn">
      <span class="ms-label">\\(\\text{‚Äî choisir ‚Äî}\\)</span><span>‚ñæ</span>
    </button>
    <div class="ms-menu">${items}</div>
    <input type="hidden" id="${selectId}" value="">
    <span class="tick"></span>      
  </div>`;

}


// Active le composant (√† appeler apr√®s insertion dans le DOM)
function initMathSelect(root=document){
  root.querySelectorAll('.mselect').forEach(box=>{
    if(box.dataset.bound) return; box.dataset.bound='1';
    const btn = box.querySelector('.ms-btn');
    const menu = box.querySelector('.ms-menu');
    const label= box.querySelector('.ms-label');
    const hidden= box.querySelector('input[type=hidden]');
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('.mselect.open').forEach(b=>{ if(b!==box) b.classList.remove('open'); });
      box.classList.toggle('open');
    });
    menu.addEventListener('click', e=>{
  const it = e.target.closest('.ms-item'); if(!it) return;
  hidden.value = it.dataset.v || '';
  // Injecte EXACTEMENT une paire de d√©limiteurs LaTeX :
  label.innerHTML = '\\(' + (it.dataset.latex || '') + '\\)';
  box.classList.remove('open');
  try{ MathJax.typesetPromise([box]); }catch(_){}
});

  });
  // fermeture globale
  document.addEventListener('click', e=>{
    if(!e.target.closest('.mselect')) document.querySelectorAll('.mselect.open').forEach(b=>b.classList.remove('open'));
  }, {passive:true});
}

function setTickForInput(el, state){
  // el = <input type="hidden"> du s√©lecteur ou un vrai input
  if(!el) return;
  // cherche d‚Äôabord un tick dans le s√©lecteur custom
  let box = el.closest('.mselect');
  let t = box ? box.querySelector('.tick') : null;

  // sinon, fallback : tick plac√© juste apr√®s l‚Äôinput (cas texte)
  if(!t && el.nextElementSibling && el.nextElementSibling.classList?.contains('tick')){
    t = el.nextElementSibling;
  }
  if(!t) return;

  if(state==null){ t.textContent=''; t.classList.remove('ok','ko'); return; }
  if(state){ t.textContent='‚úî'; t.classList.add('ok'); t.classList.remove('ko'); }
  else     { t.textContent='‚úò'; t.classList.add('ko'); t.classList.remove('ok'); }
}
// helper minimal pour g√©n√©rer un <input> largeur w (px)
window.mkInput = function mkInput(id, w = 120, placeholder = ""){
  return `<input id="${id}" class="in" style="width:${w}px"
           autocomplete="off" inputmode="decimal" placeholder="${placeholder}">`;
};


function negatePl(frase){
  let s = String(frase||'').trim();

  // Si d√©j√† n√©gative, on ne touche pas
  if (/\bne\b|\bn‚Äô|\bn'/i.test(s)) return s;

  // Cas cibl√©s (pluriel)
  const R = [
    [/^sont\b/i, "ne sont pas"],
    [/^ont\b/i, "n‚Äôont pas"],
    [/^utilisent\b/i, "n‚Äôutilisent pas"],
    [/^parlent\b/i, "ne parlent pas"],
    [/^voyagent\b/i, "ne voyagent pas"],
    [/^suivent\b/i, "ne suivent pas"],
    [/^trient\b/i, "ne trient pas"],
    [/^poss√®dent\b/i, "ne poss√®dent pas"],
    [/^s‚Äôentra√Ænent\b/i, "ne s‚Äôentra√Ænent pas"],
    [/^participent\b/i, "ne participent pas"],
    [/^travaillent\b/i, "ne travaillent pas"],
    [/^postent\b/i, "ne postent pas"],
    [/^prennent\b/i, "ne prennent pas"],
    [/^b√©n√©ficient\b/i, "ne b√©n√©ficient pas"],
    [/^d√©tiennent\b/i, "ne d√©tiennent pas"],
    [/^font\b/i, "ne font pas"],
    [/^habitent\b/i, "n‚Äôhabitent pas"],
    [/^lisent\b/i, "ne lisent pas"],
    [/^pr√©f√®rent\b/i, "ne pr√©f√®rent pas"],
    [/^se\b/i, "ne se"],              // ex. "se tiennent" ‚Üí "ne se tiennent pas"
    [/^s([‚Äô'])/i, "ne s$1"]          // ex. "s‚Äôabsentent" ‚Üí "ne s‚Äôabsentent pas"
  ];
  for (const [re, rep] of R){ if (re.test(s)) { s = s.replace(re, rep); break; } }

  // Si on n'a pas match√© un verbe connu : n√©gation g√©n√©rique
  if (!/\bne\b|\bn‚Äô|\bn'/i.test(s)) {
    const startsVowel = /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(s);
    s = (startsVowel ? "n‚Äô" : "ne ") + s + " pas";
  }
  // Compl√©ter le "pas" pour les formes "ne se ‚Ä¶"
  if (/^ne se\b/i.test(s) && !/\bpas\b/i.test(s)) s += " pas";
  if (/^ne s[‚Äô']/i.test(s) && !/\bpas\b/i.test(s)) s += " pas";
  return s;
}




// Version "avec population" (si tu l'utilises encore)
function phraseDonnees(c, pD, pJ_D, pJ_notD) {
  const P = x => `${Math.round(x * 100)}%`;
  const s1 = `${c.pop}, ${P(pD)} des ${c.group} ${c.Dpl}.`;
  const s2 = `Parmi eux, ${P(pJ_D)} ${c.Jpl}.`;
  const s3 = `Parmi ceux qui ${negatePl(c.Dpl)}, ${P(pJ_notD)} ${c.Jpl}.`;
  return `${s1} ${s2} ${s3}`;
}

// Version "sans pop" (utilis√©e dans ex3.render via leadHTML)
function phraseStatsSansPop(c, pD, pJ_D, pJ_notD){
  const P = x => `${Math.round(x*100)}%`;
  const s1 = `${P(pD)} des ${c.group} ${c.Dpl}.<br>`;
  const s2 = `Parmi eux, ${P(pJ_D)} ${c.Jpl}.<br>`;
  const s3 = `Parmi ceux qui ${negatePl(c.Dpl)}, ${P(pJ_notD)} ${c.Jpl}.`;
  return `${s1} ${s2} ${s3}`;
}


// Heuristique : "son/sa" selon le mot qui suit ("son" si voyelle, "sa" si f√©minin probable, sinon "son")
function _possessifSingulier(nextWord){
  const w = String(nextWord||'').trim();
  if (/^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(w)) return 'son';      // voyelle ‚Üí "son"
  if (/[√©e]$/i.test(w)) return 'sa';                           // f√©minin probable ‚Üí "sa"
  return 'son';                                                // d√©faut
}

// Passe "pluriel ‚Üí singulier" + mini post-traitements d'accords
function _toSingPhrase(txt){
  let t = String(txt||'').trim();

  // Verbes fr√©quents au pluriel ‚Üí singulier
  const vb = [
    [/^sont\b/i,'est'], [/^ont\b/i,'a'], [/^utilisent\b/i,'utilise'],
    [/^parlent\b/i,'parle'], [/^voyagent\b/i,'voyage'], [/^suivent\b/i,'suit'],
    [/^trient\b/i,'trie'], [/^poss√®dent\b/i,'poss√®de'], [/^s‚Äôentra√Ænent\b/i,'s‚Äôentra√Æne'],
    [/^participent\b/i,'participe'], [/^travaillent\b/i,'travaille'], [/^postent\b/i,'poste'],
    [/^prennent\b/i,'prend'], [/^b√©n√©ficient\b/i,'b√©n√©ficie'], [/^d√©tiennent\b/i,'d√©tient'],
    [/^font\b/i,'fait'], [/^habitent\b/i,'habite'], [/^lisent\b/i,'lit'],
    [/^pr√©f√®rent\b/i,'pr√©f√®re'], [/^mangent\b/i,'mange']
  ];
  vb.forEach(([re, rep]) => { t = t.replace(re, rep); });

  // Accord juste apr√®s "est" (cas typique : "est propri√©taires" ‚Üí "est propri√©taire")
  t = t.replace(/\best\s+([a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º\-']+?)s(\b)/gi, 'est $1$2');

  // Possessifs pluriels ‚Üí singulier
  t = t.replace(/\bleurs\b/gi, 'ses');

  // "leur + nom" ‚Üí "son/sa + nom"
  t = t.replace(/\bleur\s+([a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º\-']+)/gi, (_m, w) => _possessifSingulier(w) + ' ' + w);

  return t;
}

function buildDJDefs(c){
  // nom du groupe au singulier + d√©terminant d√©fini
  const sing = (c.groupSing || c.group || '').trim().replace(/s$/,'');
  const det  = /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(sing) ? "l‚Äô" : (c.g==='f' ? "la " : "le ");

  return {
    Ddef: `${det}${sing} ${_toSingPhrase(c.Dpl)}`,
    Jdef: `${det}${sing} ${_toSingPhrase(c.Jpl)}`
  };
}



// --- Phrase statistiques SANS r√©p√©ter c.pop (on l‚Äô√©crira nous-m√™mes avant) ---


function msOptionsLatexLetters(L='A', M='B'){
  const Lbar = `\\overline{${L}}`, Mbar = `\\overline{${M}}`;
  return [
    {v:'',                 latex:'\\text{‚Äî choisir ‚Äî}'},
    // simples
    {v:`P${L}`,            latex:`P(${L})`},
    {v:`P${M}`,            latex:`P(${M})`},
    {v:`Pnot${L}`,         latex:`P(${Lbar})`},
    {v:`Pnot${M}`,         latex:`P(${Mbar})`},
    // intersections
    {v:`inter${L}${M}`,    latex:`P(${L}\\cap ${M})`},
    {v:`inter${L}bar${M}`, latex:`P(${L}\\cap ${Mbar})`},
    {v:`interbar${L}${M}`, latex:`P(${Lbar}\\cap ${M})`},
    // r√©unions (utile si tu en veux plus tard)
    {v:`union${L}${M}`,    latex:`P(${L}\\cup ${M})`},
    {v:`union${L}bar${M}`, latex:`P(${L}\\cup ${Mbar})`},
    {v:`unionbar${L}${M}`, latex:`P(${Lbar}\\cup ${M})`},
    // conditionnelles (sachant en indice)
    {v:`cond${L}_${M}`,        latex:`P_{${L}}(${M})`},          // P_M(L) si tu inverses L/M
    {v:`cond${L}_bar${M}`,     latex:`P_{${L}}(${Mbar})`},
    {v:`cond${M}_${L}`,        latex:`P_{${M}}(${L})`},
    {v:`cond${M}_bar${L}`,     latex:`P_{${M}}(${Lbar})`},
    // conditionnelles avec "sachant" compl√©mentaire
    {v:`condbar${L}_${M}`,     latex:`P_{${Lbar}}(${M})`},
    {v:`condbar${M}_${L}`,     latex:`P_{${Mbar}}(${L})`}
  ];
}

function mkMathSelectHTMLLetters(selectId, width=220, L='A', M='B'){
  const opts = msOptionsLatexLetters(L,M);
  const items = opts.map(o =>
    `<div class="ms-item" data-v="${o.v}" data-latex="${o.latex}">\\(${o.latex}\\)</div>`
  ).join('');
  return `
    <div class="mselect" data-for="${selectId}" style="min-width:${width}px">
      <button type="button" class="ms-btn">
        <span class="ms-label">\\(\\text{‚Äî choisir ‚Äî}\\)</span><span>‚ñæ</span>
      </button>
      <div class="ms-menu">${items}</div>
      <input type="hidden" id="${selectId}" value="">
      <span class="tick"></span>
    </div>`;
}



/* ======= EXERCICES ======= */

/* ===== Exercice 1 ‚Äî S√©lecteur (Type 1..4 ou M√©lange) =====
   Types :
   1) Soient A,B : P(A), P(B), P(A‚à©B) ‚Üí P_A(B)      (i.e. P(B|A))
   2) Soient A,B : P(A), P_A(B), P(B) ‚Üí P(A‚à©B), P_B(A)
   3) Soient E,F : P(E), P_E(F) ‚Üí P(E‚à©F)
   4) Soient A,B : P(A), P(B), P(A‚à™B) ‚Üí P(A‚à©B), P_B(A), P_A(B)
*/
const ex1 = {
  id:'pc_mix4',
  title:'Calculs et propri√©tes',
gen(){
  const rInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const asDec = n => +(n/100).toFixed(2);
const gcd = (a,b)=> b?gcd(b,a%b):Math.abs(a);
const lcm = (a,b)=> Math.abs(a*b)/gcd(a,b);

  // ------- Type 1 : P(B|A)=P(A‚à©B)/P(A) -> 2 d√©cimales garanties
  // Choix : pA = a/100, pB = b/100 (a,b en points). On fixe i = (a*k)/100
  // avec k multiple de 100/gcd(a,100) -> P(B|A)=k/100 a ‚â§ 2 d√©cimales.
function gen_t1(){
  while(true){
    const a = rInt(20,85);            // P(A) en points
    const b = rInt(20,85);            // P(B) en points
    if (Math.abs(a-b) < 5) continue;  // <-- anti-√©galit√© / trop proches

    const step = 100 / gcd(a,100);
    const kMax = Math.floor(100*Math.min(a,b)/a);
    const Ks=[];
    for(let k=step; k<=Math.min(95,kMax); k+=step) Ks.push(k);
    if(!Ks.length) continue;

    const k = Ks[rInt(0,Ks.length-1)];
    const i = Math.floor(a*k/100);        // intersection (points)
    const cond = i / a;                   // P(B|A)
    if(cond >= 0.05 && cond <= 0.95)
      return { pA:asDec(a), pB:asDec(b), pInt:asDec(i) };
  }
}

// === Type 2 : 0.05 ‚â§ P_A(B) ‚â§ 0.95, 0.05 ‚â§ P_B(A) ‚â§ 0.95 et |P(A)-P(B)| ‚â• 0.05
function gen_t2(){
  while(true){
    const a = rInt(25,85);                         // P(A)
    const step = 100 / gcd(a,100);
    const Ks=[]; for(let k=step; k<=95; k+=step) if(k>=5 && k<=95) Ks.push(k);
    if(!Ks.length) continue;
    const k = Ks[rInt(0,Ks.length-1)];             // P_A(B)=k/100

    const i = Math.floor(a*k/100);                 // intersection en points
    const CAND = [20,25,40,50,60,75,80];           // b avec 2 d√©c. garanties
    const okB = CAND.filter(b => b >= i+2 && b <= 90 && (100*i)%b===0 && Math.abs(b-a)>=5);
    if(!okB.length) continue;

    const b = okB[rInt(0,okB.length-1)];
    const condBA = i / b;                          // P_B(A)
    if(condBA >= 0.05 && condBA <= 0.95)
      return { pA:asDec(a), pB:asDec(b), pInt:asDec(i), pA_B:asDec(k) };
  }
}

  // ------- Type 3 : P(E‚à©F)=P(E)*P_E(F) avec produit √† 2 d√©c.
  // Choix : pE=a/100 et P_E(F)=k/100 avec k multiple de 100/gcd(a,100) -> (a*k)/10000 a 2 d√©cimales.
// ------- Type 3 (patch) : garantit un k multiple du pas ; produit √† 2 d√©c. ; jamais NaN
function gen_t3(){
  while (true) {
    const a = rInt(20, 80);              // P(E) en points
    const g = gcd(a, 100);
    const step = 100 / g;                // k doit √™tre multiple de ce pas

    // candidats k dans [5,95] multiples de step
    const Ks = [];
    const start = Math.ceil(Math.max(5, step) / step) * step;
    for (let k = start; k <= 95; k += step) Ks.push(k);

    if (!Ks.length) continue;            // pas de k possible ‚Üí on retente un autre a

    const k = Ks[rInt(0, Ks.length - 1)];
    return { pE: asDec(a), pF_E: asDec(k) };
  }
}


  // ------- Type 4 : pA, pB pris dans {20,25,40,50,80} (diviseurs de 100).
  // On tire une intersection m/100 coh√©rente -> P_B(A)=m/b et P_A(B)=m/a ont ‚â§2 d√©c.
 function gen_t4(){
  const D = [20,25,40,50,60,75,80];
  while(true){
    const a = D[rInt(0,D.length-1)];
    let b = D[rInt(0,D.length-1)];
    if (Math.abs(a-b) < 5) continue;               // <-- anti-√©galit√© / trop proches

    const mMin = Math.max(1, a + b - 100);
    const mMax = Math.min(a, b) - 2;

    const gA = gcd(a,100), gB = gcd(b,100);
    const stepM = lcm(a/gA, b/gB);                 // 2 d√©c. pour m/a et m/b

    const Ms=[]; const start = Math.ceil(mMin/stepM)*stepM;
    for(let m=start; m<=mMax; m+=stepM){
      const pa = m/a, pb = m/b;
      if(pa >= 0.05 && pa <= 0.95 && pb >= 0.05 && pb <= 0.95) Ms.push(m);
    }
    if(!Ms.length) continue;

    const m = Ms[rInt(0,Ms.length-1)];
    const u = a + b - m;
    return { pA:asDec(a), pB:asDec(b), pU:asDec(u), pInt:asDec(m) };
  }
}

  return {
    bank: { t1: gen_t1(), t2: gen_t2(), t3: gen_t3(), t4: gen_t4() },
    variant: 'mix'
  };
},



  /* petit utilitaire : r√©cup√®re le type actif (t1..t4), en tirant si 'mix' */
  _activeType(st){
    if(st.variant && st.variant!=='mix') return st.variant;
    const L=['t1','t2','t3','t4'];
    return L[Math.floor(Math.random()*L.length)];
  },

  render(host, st){
  // 1) √©tat courant (m√©morise le choix utilisateur)
  const prev = host.dataset.variant || st.variant || 'mix';
  host.dataset.variant = prev;

  const typeNow = (prev==='mix') ? this._activeType(st) : prev;
  host.dataset.typeNow = typeNow; // utilis√© par correct/solution

  // 2) Construire les blocs en fonction du type
  const B=[];
  if(typeNow==='t1'){
    const {pA,pB,pInt}=st.bank.t1;
    B.push({labelHTML:`Soient \\(A\\) et \\(B\\) deux √©v√©nements tels que : \\(P(A)=${pA}\\), \\(P(B)=${pB}\\) et \\(P(A\\cap B)=${pInt}\\).<br> Calculer \\(P_A(B)\\).`, id:'q1'});
  }
  if(typeNow==='t2'){
    const {pA,pB,pInt,pA_B}=st.bank.t2;
B.push({labelHTML:`Soient \\(A\\) et \\(B\\) deux √©v√©nements tels que : \\(P(A)=${pA}\\), \\(P_A(B)=${pA_B}\\) et \\(P(B)=${pB}\\).<br> Calculer \\(P(A\\cap B)\\).`, id:'q2'});
B.push({labelHTML:`Puis calculer \\(P_B(A)\\).`, id:'q2b'});

  }
  if(typeNow==='t3'){
    const {pE,pF_E}=st.bank.t3;
    B.push({labelHTML:`Soient \\(E\\) et \\(F\\) deux √©v√©nements tels que : \\(P(E)=${pE}\\) et \\(P_E(F)=${pF_E}\\).<br> Calculer \\(P(E\\cap F)\\).`, id:'q3'});
  }
  if(typeNow==='t4'){
    const {pA,pB,pU}=st.bank.t4;
    B.push({labelHTML:`Soient \\(A\\) et \\(B\\) deux √©v√©nements tels que : \\(P(A)=${pA}\\), \\(P(B)=${pB}\\) et \\(P(A\\cup B)=${pU}\\).<br> Calculer \\(P(A\\cap B)\\).`, id:'q4'});
    B.push({labelHTML:`Puis \\(P_B(A)\\).`, id:'q4b'});
    B.push({labelHTML:`Et \\(P_A(B)\\).`, id:'q4c'});
  }

  // 3) Rendu principal
  renderRows(host, 'R√©pondre en d√©cimal, fraction ou % (quand pertinent).', B);

  // 4) Ins√©rer le s√©lecteur tout en haut (apr√®s que renderRows a vid√©/pos√© le DOM)
  const selectHTML =
    `<div class="controls" style="gap:8px;margin-bottom:8px">
       <label style="font-weight:600">Type :</label>
       <select id="ex1-type">
         <option value="mix">üîÄ M√©lange</option>
         <option value="t1">Type 1 ‚Äî \\(P_A(B)\\) avec \\(P(A),P(B),P(A\\cap B)\\)</option>
         <option value="t2">Type 2 ‚Äî \\(P(A\\cap B)\\), \\(P_B(A)\\) avec \\(P(A),P_A(B),P(B)\\)</option>
         <option value="t3">Type 3 ‚Äî \\(P(E\\cap F)\\) avec \\(P(E),P_E(F)\\)</option>
         <option value="t4">Type 4 ‚Äî depuis \\(P(A),P(B),P(A\\cup B)\\)</option>
       </select>
     </div>`;

  const inner = document.querySelector('#host .inner');
  inner.insertAdjacentHTML('afterbegin', selectHTML);
  const sel = document.querySelector('#ex1-type');
  sel.value = prev; // refl√®te le choix actuel

  // 5) Changement de type sans r√©g√©n√©rer les nombres
  sel.addEventListener('change', (e)=>{
    host.dataset.variant = e.target.value;     // m√©morise
    this.render(host, st);                     // re-render (les valeurs de st.bank restent)
  });

  retypeset(inner);
}
,

  correct(host, st){
    const typeNow = host.dataset.typeNow || this._activeType(st);
    // parseur flexible proba
    const parseProb = s => {
      s = String(s||'').trim();
      let m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
      if(m){ const a=parseInt(m[1],10), b=parseInt(m[2],10); return b>0 ? a/b : NaN; }
      const p = s.match(/^([-+]?[0-9]+(?:[.,][0-9]+)?)\s*%$/);
      if(p) return parseFloat(p[1].replace(',', '.'))/100;
      const d = parseFloat(s.replace(',', '.'));
      return Number.isFinite(d) ? d : NaN;
    };

    let ok=false;
    if(typeNow==='t1'){
      const {pA,pB,pInt}=st.bank.t1;
      const v = parseProb($('#q1',host).value);
      ok = Number.isFinite(v) && Math.abs(v - pInt/pA) <= 1e-3;
    }
    if(typeNow==='t2'){
      const {pA,pB,pInt}=st.bank.t2;
      const v1 = parseProb($('#q2',host).value);
      const v2 = parseProb($('#q2b',host).value);
      ok = Number.isFinite(v1) && Number.isFinite(v2)
        && Math.abs(v1 - pInt) <= 1e-3
        && Math.abs(v2 - pInt/pB) <= 1e-3;
    }
    if(typeNow==='t3'){
      const {pE,pF_E}=st.bank.t3;
      const v = parseProb($('#q3',host).value);
      ok = Number.isFinite(v) && Math.abs(v - pE*pF_E) <= 1e-3;
    }
    if(typeNow==='t4'){
      const {pA,pB,pU,pInt}=st.bank.t4;
      const inter = pA + pB - pU;
      const v = parseProb($('#q4',host).value);
      const vB = parseProb($('#q4b',host).value);
      const vA = parseProb($('#q4c',host).value);
      ok = Number.isFinite(v) && Number.isFinite(vB) && Number.isFinite(vA)
        && Math.abs(v - inter) <= 1e-3
        && Math.abs(vB - inter/pB) <= 1e-3
        && Math.abs(vA - inter/pA) <= 1e-3;
    }

    $('#res',host).innerHTML = ok ? '‚úî' :
      '‚úò Formules utiles : \\(P(B\\mid A)=\\frac{P(A\\cap B)}{P(A)}\\), \\(P(A\\cap B)=P(A)+P(B)-P(A\\cup B)\\).';
    $('#res',host).className = ok ? 'res-ok':'res-ko';
    return {ok,total:1};
  },

  solution(host, st){
    const typeNow = host.dataset.typeNow || this._activeType(st);
    let html='';
    if(typeNow==='t1'){
  const {pA,pInt}=st.bank.t1;
  html = `<p>\\(P_A(B)=\\dfrac{P(A\\cap B)}{P(A)}=\\dfrac{${pInt}}{${pA}}=${d2(pInt/pA)}\\).</p>`;
}

if(typeNow==='t2'){
  const {pA,pB,pInt,pA_B}=st.bank.t2;
  html = `<p>\\(P(A\\cap B)=P(A)\\times P_A(B)=${pA}\\times ${pA_B}=${d2(pInt)}\\).</p>
          <p>\\(P_B(A)=\\dfrac{P(A\\cap B)}{P(B)}=\\dfrac{${pInt}}{${pB}}=${d2(pInt/pB)}\\).</p>`;
}

if(typeNow==='t3'){
  const {pE,pF_E}=st.bank.t3;
  html = `<p>\\(P(E\\cap F)=P(E)\\times P_E(F)=${pE}\\times ${pF_E}=${d2(pE*pF_E)}\\).</p>`;
}

if(typeNow==='t4'){
  const {pA,pB,pU}=st.bank.t4;
  const inter = pA + pB - pU;
  html = `<p>\\(P(A\\cap B)=P(A)+P(B)-P(A\\cup B)=${pA}+${pB}-${pU}=${d2(inter)}\\).</p>
          <p>\\(P_B(A)=\\dfrac{P(A\\cap B)}{P(B)}=\\dfrac{${d2(inter)}}{${pB}}=${d2(inter/ st.bank.t4.pB)}\\)
             <br> \\(P_A(B)=\\dfrac{P(A\\cap B)}{P(A)}=\\dfrac{${d2(inter)}}{${pA}}=${d2(inter/ st.bank.t4.pA)}\\).</p>`;
}

    $('#res',host).innerHTML = html; $('#res',host).className='res-ok'; retypeset($('#res',host));
  },

  reset(host){ innerHost(host).innerHTML=''; }
};



/* ========= Exercice 2 ‚Äî Identifier la bonne notation =========
   Objectif : √©crire la notation correspondant √† chaque phrase.
   ‚Ä¢ Deux conditionnelles (P_A(B) et P_B(A) ‚Äî on accepte aussi P(B|A), P(A|B))
   ‚Ä¢ Une intersection (P(A‚à©B))
   ‚Ä¢ Une r√©union      (P(A‚à™B))
   Les phrases sont contextuelles : sujet + deux propri√©t√©s naturelles.
*/
/* ========= Exercice 2 ‚Äî Identifier la notation (2 conditionnelles, 1 ‚à©, 1 ‚à™, avec au moins une n√©gation) ========= */
const ex2 = {
  id: 'classif_cond_union_inter',
  title: 'Identifier la notation',

  /* ---------- Banque de contextes : sujet + A et B en 2 formes (sg/pl) ---------- */
/* ---------- Banque de 50 contextes (A/B en sg + pl, genre indiqu√©) ---------- */
/* ---------- Banque de 50 contextes (A/B en sg + pl, genre indiqu√©) ---------- */
_CTX: [
  { subj:'courriels', g:'m',
    A:{sg:"provient d‚Äôun client",                 pl:"proviennent d‚Äôun client"},
    B:{sg:"contient le mot ¬´ urgent ¬ª",           pl:"contiennent le mot ¬´ urgent ¬ª"} },

  { subj:'pi√®ces', g:'f',
    A:{sg:"est conforme",                         pl:"sont conformes"},
    B:{sg:"est contr√¥l√©e au laser",               pl:"sont contr√¥l√©es au laser"} },

  { subj:'dossiers', g:'m',
    A:{sg:"est complet",                          pl:"sont complets"},
    B:{sg:"est valid√© par le responsable",        pl:"sont valid√©s par le responsable"} },

  { subj:'√©l√®ves', g:'m',
    A:{sg:"a rendu le devoir",                    pl:"ont rendu le devoir"},
    B:{sg:"participe au club de maths",           pl:"participent au club de maths"} },

  { subj:'√©tudiants', g:'m',
    A:{sg:"suit l‚Äôoption informatique",           pl:"suivent l‚Äôoption informatique"},
    B:{sg:"fait du sport universitaire",          pl:"font du sport universitaire"} },

  { subj:'livres', g:'m',
    A:{sg:"est emprunt√©",                         pl:"sont emprunt√©s"},
    B:{sg:"est un ouvrage scientifique",          pl:"sont des ouvrages scientifiques"} },

  { subj:'v√©hicules', g:'m',
    A:{sg:"est √©lectrique",                       pl:"sont √©lectriques"},
    B:{sg:"est utilitaire",                       pl:"sont utilitaires"} },

  { subj:'logements', g:'m',
    A:{sg:"est meubl√©",                           pl:"sont meubl√©s"},
    B:{sg:"dispose d‚Äôun balcon",                  pl:"disposent d‚Äôun balcon"} },

  { subj:'commandes', g:'f',
    A:{sg:"est livr√©e √† l‚Äôheure",                 pl:"sont livr√©es √† l‚Äôheure"},
    B:{sg:"est exp√©di√©e en express",              pl:"sont exp√©di√©es en express"} },

  { subj:'paquets', g:'m',
    A:{sg:"est fragile",                          pl:"sont fragiles"},
    B:{sg:"est assur√©",                           pl:"sont assur√©s"} },

  { subj:'jours', g:'m',
    A:{sg:"est pluvieux",                         pl:"sont pluvieux"},
    B:{sg:"est venteux",                          pl:"sont venteux"} },

  /* #12 corrig√© : deux propri√©t√©s compatibles */
  { subj:'trajets', g:'m',
    A:{sg:"subit un retard",                      pl:"subissent un retard"},
    B:{sg:"passe par une d√©viation",              pl:"passent par une d√©viation"} },

  { subj:'trains', g:'m',
    A:{sg:"est direct",                           pl:"sont directs"},
    B:{sg:"arrive √† l‚Äôheure",                     pl:"arrivent √† l‚Äôheure"} },

  { subj:'candidatures', g:'f',
    A:{sg:"est admissible",                       pl:"sont admissibles"},
    B:{sg:"est prioritaire",                      pl:"sont prioritaires"} },

  { subj:'capteurs', g:'m',
    A:{sg:"est calibr√©",                          pl:"sont calibr√©s"},
    B:{sg:"est connect√©",                         pl:"sont connect√©s"} },

  { subj:'projets', g:'m',
    A:{sg:"respecte le budget",                   pl:"respectent le budget"},
    B:{sg:"respecte le d√©lai",                    pl:"respectent le d√©lai"} },

  { subj:'produits', g:'m',
    A:{sg:"est en stock",                         pl:"sont en stock"},
    B:{sg:"est bio",                              pl:"sont bio"} },

  { subj:'fichiers', g:'m',
    A:{sg:"est compress√©",                        pl:"sont compress√©s"},
    B:{sg:"est chiffr√©",                          pl:"sont chiffr√©s"} },

  { subj:'questions', g:'f',
    A:{sg:"porte sur l‚Äôalg√®bre",                  pl:"portent sur l‚Äôalg√®bre"},
    B:{sg:"est √† choix multiple",                 pl:"sont √† choix multiple"} },

  { subj:'√©chantillons', g:'m',
    A:{sg:"est conforme",                         pl:"sont conformes"},
    B:{sg:"est st√©rile",                          pl:"sont st√©riles"} },

  { subj:'visites', g:'f',
    A:{sg:"est guid√©e",                           pl:"sont guid√©es"},
    B:{sg:"est gratuite",                         pl:"sont gratuites"} },

  { subj:'photos', g:'f',
    A:{sg:"est nette",                            pl:"sont nettes"},
    B:{sg:"est sous-expos√©e",                     pl:"sont sous-expos√©es"} },

  { subj:'articles', g:'m',
    A:{sg:"est publi√© en ligne",                  pl:"sont publi√©s en ligne"},
    B:{sg:"est relu par un pair",                 pl:"sont relus par un pair"} },

  { subj:'messages', g:'m',
    A:{sg:"est non lu",                           pl:"sont non lus"},
    B:{sg:"contient une pi√®ce jointe",            pl:"contiennent une pi√®ce jointe"} },

  /* #25 corrig√© : plus de contradiction avec ¬´ manqu√© ¬ª */
  { subj:'appels', g:'m',
    A:{sg:"provient d‚Äôun contact connu",          pl:"proviennent d‚Äôun contact connu"},
    B:{sg:"dure plus de cinq minutes",            pl:"durent plus de cinq minutes"} },

  { subj:'livraisons', g:'f',
    A:{sg:"est partielle",                        pl:"sont partielles"},
    B:{sg:"est r√©frig√©r√©e",                       pl:"sont r√©frig√©r√©es"} },

  { subj:'colis', g:'m',
    A:{sg:"est volumineux",                       pl:"sont volumineux"},
    B:{sg:"est suivi",                            pl:"sont suivis"} },

  /* #28 ajust√© : ¬´ pay√©e ¬ª compatible avec ¬´ r√©gl√©e par virement ¬ª */
  { subj:'factures', g:'f',
    A:{sg:"est pay√©e",                            pl:"sont pay√©es"},
    B:{sg:"est r√©gl√©e par virement",              pl:"sont r√©gl√©es par virement"} },

  /* #30 ajust√© : les deux peuvent coexister */
  { subj:'r√©unions', g:'f',
    A:{sg:"est pr√©vue aujourd‚Äôhui",               pl:"sont pr√©vues aujourd‚Äôhui"},
    B:{sg:"se tient en visioconf√©rence",          pl:"se tiennent en visioconf√©rence"} },

  { subj:'machines', g:'f',
    A:{sg:"est en maintenance",                   pl:"sont en maintenance"},
    B:{sg:"est connect√©e au r√©seau",              pl:"sont connect√©es au r√©seau"} },

  { subj:'interventions', g:'f',
    A:{sg:"est urgente",                          pl:"sont urgentes"},
    B:{sg:"est planifi√©e",                        pl:"sont planifi√©es"} },

  { subj:'tickets', g:'m',
    A:{sg:"est r√©solu",                           pl:"sont r√©solus"},
    B:{sg:"est prioritaire",                      pl:"sont prioritaires"} },

  { subj:'r√©servations', g:'f',
    A:{sg:"est remboursable",                     pl:"sont remboursables"},
    B:{sg:"est modifiable",                       pl:"sont modifiables"} },

  { subj:'chambres', g:'f',
    A:{sg:"donne sur la mer",                     pl:"donnent sur la mer"},
    B:{sg:"est climatis√©e",                       pl:"sont climatis√©es"} },

  { subj:'patients', g:'m',
    A:{sg:"est diab√©tique",                       pl:"sont diab√©tiques"},
    B:{sg:"est suivi chaque mois",                pl:"sont suivis chaque mois"} },

  { subj:'clients', g:'m',
    A:{sg:"est fid√®le depuis trois ans",          pl:"sont fid√®les depuis trois ans"},
    B:{sg:"est abonn√© √† la newsletter",           pl:"sont abonn√©s √† la newsletter"} },

  { subj:'comptes', g:'m',
    A:{sg:"est v√©rifi√©",                          pl:"sont v√©rifi√©s"},
    B:{sg:"est premium",                          pl:"sont premium"} },

  { subj:'publications', g:'f',
    A:{sg:"est en acc√®s libre",                   pl:"sont en acc√®s libre"},
    B:{sg:"est illustr√©e",                        pl:"sont illustr√©es"} },

  { subj:'exp√©riences', g:'f',
    A:{sg:"est reproductible",                    pl:"sont reproductibles"},
    B:{sg:"est document√©e",                       pl:"sont document√©es"} },

  { subj:'mesures', g:'f',
    A:{sg:"est pr√©cise",                          pl:"sont pr√©cises"},
    B:{sg:"est sup√©rieure au seuil",              pl:"sont sup√©rieures au seuil"} },

  { subj:'capteurs IoT', g:'m',
    A:{sg:"√©met un signal anormal",               pl:"√©mettent un signal anormal"},
    B:{sg:"est aliment√© par batterie",            pl:"sont aliment√©s par batterie"} },

  { subj:'emails marketing', g:'m',
    A:{sg:"est ouvert",                           pl:"sont ouverts"},
    B:{sg:"contient un coupon",                   pl:"contiennent un coupon"} },

  { subj:'sessions', g:'f',
    A:{sg:"est active",                           pl:"sont actives"},
    B:{sg:"est s√©curis√©e",                        pl:"sont s√©curis√©es"} },

  { subj:'profils', g:'m',
    A:{sg:"est public",                           pl:"sont publics"},
    B:{sg:"est complet",                          pl:"sont complets"} },

  { subj:'r√©ponses', g:'f',
    A:{sg:"est correcte",                         pl:"sont correctes"},
    B:{sg:"est justifi√©e",                        pl:"sont justifi√©es"} },

  { subj:'trajets domicile-travail', g:'m',
    A:{sg:"se fait en v√©lo",                      pl:"se font en v√©lo"},
    B:{sg:"prend moins de vingt minutes",         pl:"prennent moins de vingt minutes"} },

  /* #47 corrig√© : deux propri√©t√©s compatibles */
  { subj:'commandes en ligne', g:'f',
    A:{sg:"est livr√©e √† domicile",                pl:"sont livr√©es √† domicile"},
    B:{sg:"est livr√©e dans la journ√©e",           pl:"sont livr√©es dans la journ√©e"} },

  { subj:'inscriptions', g:'f',
    A:{sg:"est valid√©e",                          pl:"sont valid√©es"},
    B:{sg:"est pay√©e par carte",                  pl:"sont pay√©es par carte"} },

  { subj:'vols', g:'m',
    A:{sg:"est long-courrier",                    pl:"sont long-courriers"},
    B:{sg:"part √† l‚Äôheure",                       pl:"partent √† l‚Äôheure"} },

  { subj:'livraisons express', g:'f',
    A:{sg:"est internationale",                   pl:"sont internationales"},
    B:{sg:"est suivie",                           pl:"sont suivies"} }
],



  /* ---------------------- Outils grammaire & tirages ---------------------- */
  _defDet(noun, g){ return /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(noun) ? "l‚Äô"+noun : (g==='f'?"la ":"le ")+noun; },
  _indefDet(noun, g){ return (g==='f'?"une ":"un ")+noun; },
  _singular(pl){ return String(pl).replace(/s$/,''); },

  _negate(phrase){
  let p = phrase.trim();

  // Correction pour les verbes compos√©s (commence par "provient", "contient", etc.)
  const verbNeg = [
    [/^est\b/i,             "n‚Äôest pas"],
    [/^sont\b/i,            "ne sont pas"],
    [/^a\b/i,               "n‚Äôa pas"],
    [/^ont\b/i,             "n‚Äôont pas"],
    [/^fait\b/i,            "ne fait pas"],
    [/^font\b/i,            "ne font pas"],
    [/^contient\b/i,        "ne contient pas"],
    [/^contiennent\b/i,     "ne contiennent pas"],
    [/^provient\b/i,        "ne provient pas"],
    [/^proviennent\b/i,     "ne proviennent pas"],
    [/^dispose\b/i,         "ne dispose pas"],
    [/^disposent\b/i,       "ne disposent pas"],
    [/^respecte\b/i,        "ne respecte pas"],
    [/^respectent\b/i,      "ne respectent pas"],
    [/^arrive\b/i,          "n‚Äôarrive pas"],
    [/^arrivent\b/i,        "n‚Äôarrivent pas"],
    [/^porte\b/i,           "ne porte pas"],
    [/^portent\b/i,         "ne portent pas"],
    [/^donne\b/i,           "ne donne pas"],
    [/^donnent\b/i,         "ne donnent pas"],
    [/^prend\b/i,           "ne prend pas"],
    [/^prennent\b/i,        "ne prennent pas"],
    [/^se fait\b/i,         "ne se fait pas"],
    [/^se font\b/i,         "ne se font pas"]
  ];

  for (const [re, rep] of verbNeg) {
    if (re.test(p)) return p.replace(re, rep);
  }

  // Cas g√©n√©rique : si √ßa commence par une voyelle ‚Üí "n‚Äô", sinon "ne"
  const startsVowel = /^[aeiouyh√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º]/i.test(p);
  return (startsVowel ? "n‚Äô" : "ne ") + p + " pas";
},


  _shareTooMuch(a,b){ // rejette A/B trop proches lexicalement
    const tok = s => s.toLowerCase().normalize('NFD').replace(/[^a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º\-']/g,' ').split(/\s+/).filter(x=>x.length>=4);
    const A = new Set(tok(a)), B = new Set(tok(b));
    let common=0; A.forEach(w=>{ if(B.has(w)) common++; });
    const small = Math.min(A.size||1, B.size||1);
    return common / small >= 0.6; // >60% commun -> trop proche
  },

  _pct(a,b){ return Math.floor(Math.random()*(b-a+1))+a; },

  gen(){
    // 1) contexte distinct (√©vite A/B trop proches)
    let ctx;
    for(let tries=0; tries<30; tries++){
      const c = this._CTX[Math.floor(Math.random()*this._CTX.length)];
      if(!this._shareTooMuch(c.A.sg, c.B.sg)) { ctx=c; break; }
    }
    if(!ctx) ctx = this._CTX[0];

    // 2) % r√©alistes
    const pctUnion = this._pct(35,90);
    const pctInter = this._pct(5,40);
    const pctCond  = ()=> this._pct(12,88);

    // 3) Fabrique les 4 items (ordre m√©lang√©)
    const make = {
      union : { tag:'union', txt: p => `${p}% des ${ctx.subj} ${ctx.A.pl} ou ${ctx.B.pl}.`, p: pctUnion },
      inter : { tag:'inter', txt: p => `${p}% des ${ctx.subj} ${ctx.A.pl} et ${ctx.B.pl}.`,       p: pctInter },
      condAB: { tag:'condAB',txt: p => `Parmi les ${ctx.subj} qui ${ctx.A.pl}, ${p}% ${ctx.B.pl} aussi.`,       p: pctCond() },
      condBA: { tag:'condBA',txt: p => `Sur les ${ctx.subj} qui ${ctx.B.pl}, ${p}% ${ctx.A.pl} √©galement.`,     p: pctCond() },
    };
    let pool = [make.union, make.inter, make.condAB, make.condBA].map(o => ({...o, p: (typeof o.p==='function'?o.p():o.p)}));

    // 4) Injecte une N√âGATION dans l‚Äôun des 4 (al√©atoirement)
    const negIdx = Math.floor(Math.random()*pool.length);
    pool = pool.map((o,i)=>{
      if(i!==negIdx) return o;
      if(o.tag==='union'){
        // A ‚à™ \bar B (ou \bar A ‚à™ B) -> choisissez une des deux
        const flip = Math.random()<0.5;
        const txt = flip
          ? (p => `${p}% des ${ctx.subj} ${ctx.A.pl} ou ${this._negate(ctx.B.pl)}.`)
          : (p => `${p}% des ${ctx.subj} ${this._negate(ctx.A.pl)} ou ${ctx.B.pl}.`);
        return {...o, tag: flip?'unionAbarB':'unionABarB', txt};
      }
      if(o.tag==='inter'){
        // A ‚à© \bar B (ou \bar A ‚à© B)
        const flip = Math.random()<0.5;
        const txt = flip
          ? (p => `${p}% des ${ctx.subj} ${ctx.A.pl} et ${this._negate(ctx.B.pl)}.`)
          : (p => `${p}% des ${ctx.subj} ${this._negate(ctx.A.pl)} et ${ctx.B.pl}.`);
        return {...o, tag: flip?'interAbarB':'interABarB', txt};
      }
      if(o.tag==='condAB'){
        // P( \bar B | A )
        const txt = p => `Parmi les ${ctx.subj} qui ${ctx.A.pl}, ${p}% ${this._negate(ctx.B.pl)}.`;
        return {...o, tag:'condABbar', txt};
      }
      if(o.tag==='condBA'){
        // P( \bar A | B )
        const txt = p => `Sur les ${ctx.subj} qui ${ctx.B.pl}, ${p}% ${this._negate(ctx.A.pl)}.`;
        return {...o, tag:'condBAbar', txt};
      }
      return o;
    });

    // 5) M√©lange et num√©rote
    pool.sort(()=>Math.random()-0.5);
    const labels=['a','b','c','d'];
    const items = pool.map((o,i)=>({ id:`q${i+1}`, letter:labels[i], tag:o.tag, text:o.txt(o.p) }));

    return { ctx, items };
  },

  /* ====== 1) Liste d'options propos√©es dans le <select> ====== */
_options(){
  const Abar = BAR.A, Bbar = BAR.B;
  return [
    {v:'',                text:'‚Äî choisir ‚Äî'},

    // simples
    {v:'PA',              text:'P(A)'},
    {v:'PB',              text:'P(B)'},
    {v:'PnotA',           text:`P(${Abar})`},
    {v:'PnotB',           text:`P(${Bbar})`},

    // intersections
    {v:'interAB',         text:'P(A‚à©B)'},
    {v:'interAbarB',      text:`P(A‚à©${Bbar})`},
    {v:'interABarB',      text:`P(${Abar}‚à©B)`},

    // r√©unions
    {v:'unionAB',         text:'P(A‚à™B)'},
    {v:'unionAbarB',      text:`P(A‚à™${Bbar})`},
    {v:'unionABarB',      text:`P(${Abar}‚à™B)`},

    // conditionnelles (sachant en indice)
    {v:'condAB',          text:'P_A(B)'},
    {v:'condABbar',       text:`P_A(${Bbar})`},
    {v:'condBA',          text:'P_B(A)'},
    {v:'condBAbar',       text:`P_B(${Abar})`},
  ];
},


/* ====== 2) Rendu : intro + 4 phrases + SELECT (au lieu d‚Äôinput texte) ====== */
render(host, st){
  const sing = this._singular(st.ctx.subj);
  const intro =
    `On choisit au hasard ${this._indefDet(sing, st.ctx.g)}. <br>`+
    `On consid√®re les √©v√©nements suivants : <br>`+
    `\\(A\\) : ¬´ ${this._defDet(sing, st.ctx.g)} ${st.ctx.A.sg} ¬ª, `+
    `\\(B\\) : ¬´ ${this._defDet(sing, st.ctx.g)} ${st.ctx.B.sg} ¬ª.`;

  const hint =
    `Choisir la notation : <em>conditionnelle</em> \\(P(\\cdot\\mid\\cdot)\\) ou \\(P_{\\,\\cdot}(\\cdot)\\), `+
    `<em>intersection</em> \\(P(\\cdot\\cap\\cdot)\\), <em>r√©union</em> \\(P(\\cdot\\cup\\cdot)\\). `+
    `Pour les phrases n√©gatives, les options avec \\(A'\\) / \\(B'\\) sont disponibles.`;

  const opts = this._options().map(o=>`<option value="${o.v}">${o.text}</option>`).join('');

  const blocks = [
    { labelHTML: intro },
   ... st.items.map(it => ({
  labelHTML: `${it.letter} ) ${it.text}<br>`,
  rightHTML: mkMathSelectHTML(it.id, 220)   // ‚Üê remplace <select>
}))

  ];

  renderRowsInputRight(
    host,
    "Pour chaque affirmation, indiquer s‚Äôil s‚Äôagit d‚Äôune probabilit√© conditionnelle, d‚Äôune intersection ou d‚Äôune r√©union en donnant la notation correspondante.",
    blocks
  );
initMathSelect(host);
try{ MathJax.typesetPromise([host]); }catch(_){}

retypeset(host);
},

/* ====== 3) Correction : compare le code s√©lectionn√© au tag attendu ====== */
correct(host, st){
  const ACCEPT = {
    condAB:['condAB'], condBA:['condBA'],
    condABbar:['condABbar'], condBAbar:['condBAbar'],
    inter:['interAB'], interAbarB:['interAbarB'], interABarB:['interABarB'],
    union:['unionAB'], unionAbarB:['unionAbarB'], unionABarB:['unionABarB'],
  };

  let anyWrong = false;
  let anyAnswered = false;
  let allAnswered = true;

  st.items.forEach(it=>{
    const sel = document.getElementById(it.id); // <input type="hidden">
    const val = sel ? sel.value : '';

    if(!val){            // rien de choisi -> pas de tick, pas de sanction
      setTickForInput(sel, null);
      allAnswered = false;
      return;
    }

    anyAnswered = true;
    const ok = (ACCEPT[it.tag] || []).includes(val);
    setTickForInput(sel, ok);
    if(!ok) anyWrong = true;
  });

  

  // Score : on ne compte point que si tout est r√©pondu ET correct
  return { ok: allAnswered && !anyWrong, total: 1 };
},



/* ====== 4) (Optionnel) Solution : affiche la bonne option en LaTeX ====== */
solution(host, st){
  const latex = {
    condAB:'\\(P_A(B)\\)', condBA:'\\(P_B(A)\\)',
    condABbar:'\\(P_A(\\overline{B})\\)', condBAbar:'\\(P_B(\\overline{A})\\)',
    inter:'\\(P(A\\cap B)\\)', interAbarB:'\\(P(A\\cap \\overline{B})\\)', interABarB:'\\(P(\\overline{A}\\cap B)\\)',
    union:'\\(P(A\\cup B)\\)', unionAbarB:'\\(P(A\\cup \\overline{B})\\)', unionABarB:'\\(P(\\overline{A}\\cup B)\\)'
  };
  const html = st.items.map(it => `<p>${it.letter}) ${latex[it.tag]||''}</p>`).join('');
  $('#res',host).innerHTML = html;
  $('#res',host).className='res-ok';
  retypeset($('#res',host));
},


  reset(host){ innerHost(host).innerHTML=''; }
};


/* ===== Exercice 3 ‚Äî Banque (20) type ¬´ CDD / moins de 30 ans ¬ª ===== */
const EX3_BANK = (() => {
  const ctxs = [
    { pop:"Parmi les internautes", group:"internautes",
      Dpl:"poss√®dent un smartphone Android",
      Jpl:"utilisent quotidiennement les r√©seaux sociaux" },

    { pop:"Dans une grande entreprise", group:"salari√©s",
      Dpl:"t√©l√©travaillent r√©guli√®rement",
      Jpl:"habitent √† plus de 30 km du lieu de travail" },

    { pop:"Dans une √©tude sur la sant√©", group:"patients",
      Dpl:"sont fumeurs",
      Jpl:"ont moins de 30 ans" },

    { pop:"Dans un lyc√©e europ√©en", group:"√©l√®ves",
      Dpl:"ont particip√© au voyage scolaire",
      Jpl:"parlent couramment anglais" },

    { pop:"Chez les licenci√©s d‚Äôun club sportif", group:"sportifs",
      Dpl:"s‚Äôentra√Ænent plus de 5 fois par semaine",
      Jpl:"suivent un r√©gime sp√©cifique" },

    { pop:"Dans le parc automobile", group:"v√©hicules",
      Dpl:"sont √©lectriques",
      Jpl:"ont moins de 3 ans" },

    { pop:"Dans une commune fran√ßaise", group:"habitants",
      Dpl:"trient leurs d√©chets",
      Jpl:"poss√®dent un composteur" },

    { pop:"Parmi les bacheliers", group:"candidats",
      Dpl:"ont obtenu une mention",
      Jpl:"sont en fili√®re g√©n√©rale" },

    { pop:"Parmi les voyageurs d‚Äôun train", group:"voyageurs",
      Dpl:"ont une carte de r√©duction",
      Jpl:"voyagent en premi√®re classe" },

    { pop:"Dans une √©tude sur les logements", group:"logements",
      Dpl:"sont chauff√©s au gaz",
      Jpl:"sont r√©cents (moins de 10 ans)" },

    { pop:"Dans une √©cole d‚Äôing√©nieurs", group:"√©tudiants",
  Dpl:"suivent un double dipl√¥me", 
  Jpl:"participent √† un programme d‚Äô√©change" },

{ pop:"Dans une √©cole d‚Äôing√©nieurs", group:"√©tudiants",
  Dpl:"suivent un double dipl√¥me",
  Jpl:"participent √† un programme d‚Äô√©change" },

{ pop:"Parmi les foyers sond√©s", group:"m√©nages",
  Dpl:"sont propri√©taires de leur logement",
  Jpl:"d√©tiennent un animal domestique" },

{ pop:"Chez les automobilistes fran√ßais", group:"conducteurs",
  Dpl:"ont plus de dix ans de permis",
  Jpl:"ont d√©j√† eu un accident responsable" },

{ pop:"Dans un service hospitalier", group:"patients",
  Dpl:"sont en hospitalisation de jour",
  Jpl:"b√©n√©ficient d‚Äôun suivi psychologique" },

{ pop:"Parmi les √©l√®ves d‚Äôun coll√®ge", group:"coll√©giens",
  Dpl:"prennent le bus scolaire",
  Jpl:"mangent √† la cantine" },

{ pop:"Chez les usagers d‚Äôun r√©seau social", group:"utilisateurs",
  Dpl:"postent chaque semaine",
  Jpl:"suivent plus de cent comptes" },

{ pop:"Dans une entreprise de transport", group:"chauffeurs",
  Dpl:"travaillent de nuit",
  Jpl:"font des trajets longue distance" },

{ pop:"Dans un sondage sur l‚Äô√©nergie", group:"habitants",
  Dpl:"utilisent le chauffage √©lectrique",
  Jpl:"poss√®dent des panneaux solaires" },

{ pop:"Parmi les salari√©s d‚Äôune start-up", group:"employ√©s",
  Dpl:"t√©l√©travaillent au moins trois jours par semaine",
  Jpl:"participent √† des projets open-source" },

{ pop:"Dans un club de lecture", group:"membres",
  Dpl:"lisent plus de dix livres par an",
  Jpl:"pr√©f√®rent les romans contemporains" }


  ];

  const L = [];
  for (let k=0; k<20; k++){
    const c = ctxs[k % ctxs.length];
    const pD       = rnd(15,35)/100;
    const pJ_D     = rnd(45,80)/100;
    const pJ_notD  = rnd(15,45)/100;
    L.push({ c, pD, pJ_D, pJ_notD });
  }
  return L;
})();






const ex3 = {
  id:'bank_cdd30',
  title:'Traduire des donn√©es',
  gen(){ return choice(EX3_BANK); },
render(host, st){
  const {c, pD, pJ_D, pJ_notD} = st;
  const P = x => `${Math.round(x*100)}%`;
  const {Ddef, Jdef} = buildDJDefs(c);

  // ----- 1) √âNONC√â (qui sera rendu hors .row)
  const leadHTML =
    `${c.pop}, ` + phraseStatsSansPop(c, pD, pJ_D, pJ_notD)
    + `<br>On consid√®re \\(D:\\) ¬´ ${Ddef} ¬ª et \\(J:\\) ¬´ ${Jdef} ¬ª.`
    + `<br><br>a) Traduire les donn√©es en terme de probabilit√©s, en utilisant les √©v√©nements \\(D\\) et \\(J\\).`;

  // ----- 2) LIGNES AVEC CHAMP (seulement celles-ci passent par renderRows)
  const rowsRest = [
    { labelHTML: `‚Ä¢ ${P(pD)} des ${c.group} ${c.Dpl}.`,
      rightHTML: mkMathSelectHTMLLetters('e3s1', 220, 'D','J') },
    { labelHTML: `‚Ä¢ Parmi ceux qui ${c.Dpl}, ${P(pJ_D)} ${c.Jpl}.`,
      rightHTML: mkMathSelectHTMLLetters('e3s2', 220, 'D','J') },
    { labelHTML: `‚Ä¢ Parmi ceux qui ${negatePl(c.Dpl)}, ${P(pJ_notD)} ${c.Jpl}.`,
      rightHTML: mkMathSelectHTMLLetters('e3s3', 220, 'D','J') },
    { labelHTML:`b) D√©terminer \\(P(D\\cap J)\\).`,
      rightHTML:`<input id="e3b" class="in" style="width:120px"> <span id="t3b" class="tick"></span>` }
  ];

  // Rendu des SEULES lignes avec input (mise en page √† droite)
  renderRows(host, '', rowsRest, true);

  // ----- 3) INS√âRER L‚Äô√âNONC√â en dehors des .row
  const inner = host.querySelector('.inner');
  const hint  = inner.querySelector('.hint.consigne');     // juste apr√®s la consigne √©ventuelle
  (hint || inner).insertAdjacentHTML('afterend', `<div class="lead">${leadHTML}</div>`);

  // ----- 4) Version offscreen (PDF) : on ajoute l‚Äô√©nonc√© juste apr√®s la consigne
  const off = inner.querySelector('.equ-offscreen');
  const consOff = off?.querySelector('.consigne');
  if (consOff) consOff.insertAdjacentHTML('afterend', `<div class="equation">${stripHints(leadHTML)}</div>`);

  // ----- 5) Activer les s√©lecteurs + MathJax
  initMathSelect(host);
  try{ MathJax.typesetPromise([host]); }catch(_){}
},



correct(host, st){
  const get = id => $('#'+id,host);
  const val = id => (get(id)?.value || '').trim();

  // 1) S√©lecteurs : attendus avec mkMathSelectHTMLLetters('D','J')
  // e3s1 : P(D)           -> 'PD'
  // e3s2 : P_D(J)         -> 'condD_J'
  // e3s3 : P_{\bar D}(J)  -> 'condbarD_J'
  const s1 = get('e3s1'), s2 = get('e3s2'), s3 = get('e3s3');

  let anyWrong = false, allAnswered = true;

  function checkSelect(el, expected){
    if(!el) return;
    const v = (el.value||'').trim();
    if(!v){ setTickForInput(el, null); allAnswered = false; return; }
    const ok = (v === expected);
    setTickForInput(el, ok);
    if(!ok) anyWrong = true;
  }
  checkSelect(s1, 'PD');
  checkSelect(s2, 'condD_J');
  checkSelect(s3, 'condbarD_J');

  // 2) Conjonction b) : P(D‚à©J) = P(D) √ó P_D(J)
  const bVal = parseProbFlexible(val('e3b'));
  const bExp = st.pD * st.pJ_D;

  if(!Number.isFinite(bVal)){
    setTick(get('e3b'), null);
    allAnswered = false;
  }else{
    const okb = same(bVal, bExp, 1e-3);
    setTick(get('e3b'), okb ? 'ok' : 'ko');
    if(!okb) anyWrong = true;
  }

  const okGlobal = allAnswered && !anyWrong;


  return { ok: okGlobal, total: 1 };
}
,
  solution(host, st){
  const { c, pD, pJ_D, pJ_notD } = st;
  const P = x => (Math.round(x * 1000) / 1000).toString().replace('.', ',');
    const P1 = x => `${Math.round(x*100)}%`;

  const html = `
  <p><b>a)</b><br>
  ‚Ä¢ ${P1(pD)} des ${c.group} ${c.Dpl}, donc&nbsp;\\(P(D)=${pD.toFixed(2)}\\).<br>
  ‚Ä¢ Parmi ceux qui ${c.Dpl}, ${P1(pJ_D)} ${c.Jpl} donc&nbsp;\\(P_{D}(J)=${pJ_D.toFixed(2)}\\).<br>
  ‚Ä¢ Parmi ceux qui ${negatePl(c.Dpl)}, ${P1(pJ_notD)} ${c.Jpl} donc&nbsp;\\(P_{\\overline{D}}(J)=${pJ_notD.toFixed(2)}\\).</p>

  <p><b>b)</b><br>
  \\(P(D\\cap J)=P(D)\\times P_D(J)=${pD.toFixed(2)}\\times ${pJ_D.toFixed(2)}=${(pD*pJ_D).toFixed(2)}\\).</p>
  `;

  $('#res',host).innerHTML = html;
  $('#res',host).className = 'res-ok';
  retypeset($('#res',host));
}

,
  reset(host){ innerHost(host).innerHTML=''; }
};

/* ===== Exercice 4 ‚Äî Banque (20) √©nonc√©s contextuels "vrais" ===== */
const EX4_BANK = (() => {
  const ctxs = [
    {
      txt: `Dans une population, {PA} % des m√©nages poss√®dent une voiture, {PB} % poss√®dent un deux-roues et {PU} % poss√®dent au moins un v√©hicule (l‚Äôun des deux).`,
      A: 'V', B: 'D',
      Asg: 'poss√®de une voiture', Bsg: 'poss√®de un deux-roues',
      Apl: 'poss√®dent une voiture', Bpl: 'poss√®dent un deux-roues',
      unit: 'un m√©nage'
    },
    {
      txt: `Dans une entreprise, {PA} % des employ√©s travaillent sur site, {PB} % t√©l√©travaillent r√©guli√®rement et {PU} % exercent au moins l‚Äôune de ces deux modalit√©s.`,
      A: 'S', B: 'T',
      Asg: 'travaille sur site', Bsg: 't√©l√©travaille r√©guli√®rement',
      Apl: 'travaillent sur site', Bpl: 't√©l√©travaillent r√©guli√®rement',
      unit: 'un employ√©'
    },
    {
      txt: `Parmi les abonn√©s d‚Äôune plateforme, {PA} % ont un abonnement annuel, {PB} % ont choisi l‚Äôoption ¬´ premium ¬ª et {PU} % disposent d‚Äôau moins l‚Äôun des deux avantages.`,
      A: 'A', B: 'P',
      Asg: 'a un abonnement annuel', Bsg: 'a choisi l‚Äôoption premium',
      Apl: 'ont un abonnement annuel', Bpl: 'ont choisi l‚Äôoption premium',
      unit: 'un abonn√©'
    },
    {
      txt: `Dans un lyc√©e, {PA} % des √©l√®ves pratiquent un sport collectif, {PB} % un instrument de musique et {PU} % au moins une de ces activit√©s.`,
      A: 'S', B: 'M',
      Asg: 'pratique un sport collectif', Bsg: 'pratique un instrument de musique',
      Apl: 'pratiquent un sport collectif', Bpl: 'pratiquent un instrument de musique',
      unit: 'un √©l√®ve'
    },
    {
      txt: `Chez les clients d‚Äôun magasin, {PA} % paient par carte, {PB} % en esp√®ces et {PU} % utilisent au moins un de ces deux moyens.`,
      A: 'C', B: 'E',
      Asg: 'paie par carte', Bsg: 'paie en esp√®ces',
      Apl: 'paient par carte', Bpl: 'paient en esp√®ces',
      unit: 'un client'
    },
    {
      txt: `Dans un sondage, {PA} % des Fran√ßais boivent du caf√©, {PB} % du th√©, et {PU} % consomment au moins l‚Äôun des deux.`,
      A: 'C', B: 'T',
      Asg: 'boit du caf√©', Bsg: 'boit du th√©',
      Apl: 'boivent du caf√©', Bpl: 'boivent du th√©',
      unit: 'un individu'
    },
    {
      txt: `Dans une ville, {PA} % des habitants poss√®dent un chien, {PB} % un chat, et {PU} % ont au moins un des deux animaux.`,
      A: 'C', B: 'H',
      Asg: 'poss√®de un chien', Bsg: 'poss√®de un chat',
      Apl: 'poss√®dent un chien', Bpl: 'poss√®dent un chat',
      unit: 'un habitant'
    },
    {
      txt: `Parmi les √©tudiants d‚Äôune universit√©, {PA} % sont boursiers, {PB} % logent au CROUS et {PU} % sont dans au moins une de ces situations.`,
      A: 'B', B: 'L',
      Asg: 'est boursier', Bsg: 'loge au CROUS',
      Apl: 'sont boursiers', Bpl: 'logent au CROUS',
      unit: 'un √©tudiant'
    },
    {
      txt: `Dans une entreprise, {PA} % des salari√©s ont re√ßu une formation interne, {PB} % une formation externe, et {PU} % au moins une des deux.`,
      A: 'I', B: 'E',
      Asg: 'a re√ßu une formation interne', Bsg: 'a re√ßu une formation externe',
      Apl: 'ont re√ßu une formation interne', Bpl: 'ont re√ßu une formation externe',
      unit: 'un salari√©'
    },
    {
      txt: `Parmi les m√©nages d‚Äôun quartier, {PA} % poss√®dent un jardin, {PB} % ont un balcon, et {PU} % disposent d‚Äôau moins l‚Äôun des deux.`,
      A: 'J', B: 'B',
      Asg: 'poss√®de un jardin', Bsg: 'a un balcon',
      Apl: 'poss√®dent un jardin', Bpl: 'ont un balcon',
      unit: 'un m√©nage'
    },
    {
      txt: `Dans un coll√®ge, {PA} % des √©l√®ves ont un t√©l√©phone portable, {PB} % une tablette, et {PU} % au moins l‚Äôun des deux.`,
      A: 'T', B: 'P',
      Asg: 'a un t√©l√©phone portable', Bsg: 'a une tablette',
      Apl: 'ont un t√©l√©phone portable', Bpl: 'ont une tablette',
      unit: 'un √©l√®ve'
    },
    {
      txt: `Parmi les automobilistes, {PA} % ont une assurance tous risques, {PB} % un v√©hicule √©lectrique, et {PU} % au moins une de ces caract√©ristiques.`,
      A: 'A', B: 'E',
      Asg: 'a une assurance tous risques', Bsg: 'a un v√©hicule √©lectrique',
      Apl: 'ont une assurance tous risques', Bpl: 'ont un v√©hicule √©lectrique',
      unit: 'un automobiliste'
    },
    {
      txt: `Dans une entreprise, {PA} % des salari√©s parlent anglais, {PB} % parlent espagnol, et {PU} % parlent au moins une des deux langues.`,
      A: 'A', B: 'S',
      Asg: 'parle anglais', Bsg: 'parle espagnol',
      Apl: 'parlent anglais', Bpl: 'parlent espagnol',
      unit: 'un salari√©'
    },
    {
      txt: `Chez les clients d‚Äôun site e-commerce, {PA} % commandent depuis un smartphone, {PB} % la nuit, et {PU} % effectuent au moins l‚Äôun des deux comportements.`,
      A: 'S', B: 'N',
      Asg: 'commande depuis un smartphone', Bsg: 'commande la nuit',
      Apl: 'commandent depuis un smartphone', Bpl: 'commandent la nuit',
      unit: 'un client'
    },
    {
      txt: `Dans une entreprise, {PA} % des employ√©s sont cadres, {PB} % ont plus de 45 ans, et {PU} % sont dans au moins une de ces situations.`,
      A: 'C', B: 'A',
      Asg: 'est cadre', Bsg: 'a plus de 45 ans',
      Apl: 'sont cadres', Bpl: 'ont plus de 45 ans',
      unit: 'un employ√©'
    },
    {
      txt: `Dans un centre de loisirs, {PA} % des enfants font du foot, {PB} % de la natation, et {PU} % pratiquent au moins l‚Äôun des deux sports.`,
      A: 'F', B: 'N',
      Asg: 'fait du foot', Bsg: 'fait de la natation',
      Apl: 'font du foot', Bpl: 'font de la natation',
      unit: 'un enfant'
    },
    {
      txt: `Parmi les internautes, {PA} % regardent des s√©ries en ligne, {PB} % jouent √† des jeux vid√©o, et {PU} % font au moins l‚Äôun des deux.`,
      A: 'S', B: 'J',
      Asg: 'regarde des s√©ries en ligne', Bsg: 'joue √† des jeux vid√©o',
      Apl: 'regardent des s√©ries en ligne', Bpl: 'jouent √† des jeux vid√©o',
      unit: 'un individu'
    },
    {
      txt: `Dans une entreprise, {PA} % des salari√©s utilisent un ordinateur portable, {PB} % un smartphone professionnel, et {PU} % disposent d‚Äôau moins l‚Äôun des deux.`,
      A: 'O', B: 'S',
      Asg: 'utilise un ordinateur portable', Bsg: 'utilise un smartphone professionnel',
      Apl: 'utilisent un ordinateur portable', Bpl: 'utilisent un smartphone professionnel',
      unit: 'un salari√©'
    },
    {
      txt: `Dans une √©tude, {PA} % des m√©nages poss√®dent un composteur, {PB} % un potager, et {PU} % au moins un des deux.`,
      A: 'C', B: 'P',
      Asg: 'poss√®de un composteur', Bsg: 'poss√®de un potager',
      Apl: 'poss√®dent un composteur', Bpl: 'poss√®dent un potager',
      unit: 'un m√©nage'
    },
    {
      txt: `Parmi les voyageurs d‚Äôun train, {PA} % ont une carte de r√©duction, {PB} % voyagent en premi√®re classe, et {PU} % pr√©sentent au moins l‚Äôun des deux avantages.`,
      A: 'R', B: 'P',
      Asg: 'a une carte de r√©duction', Bsg: 'voyage en premi√®re classe',
      Apl: 'ont une carte de r√©duction', Bpl: 'voyagent en premi√®re classe',
      unit: 'un voyageur'
    }
  ];

  // g√©n√©ration al√©atoire coh√©rente
  const L = [];
  for (let i = 0; i < ctxs.length; i++) {
    const c = ctxs[i];
    const pA = rnd(30, 85) / 100;
    const pB = rnd(20, 70) / 100;
    const interMax = Math.min(pA, pB) - 0.01;
    const interMin = Math.max(0.01, pA + pB - 0.99);
    const pAB = +(rnd(Math.floor(interMin*100), Math.floor(interMax*100)) / 100).toFixed(2);
    const pU = +(pA + pB - pAB).toFixed(2);
    L.push({ c, pA, pB, pU });
  }
  return L;
})();


const ex4 = {
  id: 'bank_inter_union_then_cond',
  title: 'Intersection puis conditionnelle',

  gen(){ return EX4_BANK[Math.floor(Math.random()*EX4_BANK.length)]; },

 render(host, st){
  const { c, pA, pB, pU } = st;

  // Intro avec les pourcentages
  const intro = c.txt
    .replace('{PA}', Math.round(pA*100))
    .replace('{PB}', Math.round(pB*100))
    .replace('{PU}', Math.round(pU*100));

  // üîπ Nouvelle ligne d‚Äô√©v√©nements : lettres & contenus du contexte (forme plurielle)
  const evLine = `On consid√®re les √©v√©nements :<br>` +
                 `<b>${c.A}</b> : ¬´ ${c.unit} ${c.Asg} ¬ª et <b>${c.B}</b> : ¬´ ${c.unit} ${c.Bsg} ¬ª.`;

  // Questions
  const qA = `a) On choisit ${c.unit} au hasard dans la population. ` +
             `D√©terminer la probabilit√© qu‚Äôil ${c.Asg} et ${c.Bsg}.`;

  const qB = `b) On choisit au hasard ${c.unit} ` +
             `qui ${c.Asg}. D√©terminer la probabilit√© qu‚Äôil ${c.Bsg}.`;

  // Rendu : intro, ligne √©v√©nements, puis questions
  const rows = [
    { labelHTML: intro },
    { labelHTML: evLine },
    { labelHTML: qA, id: 'e4_inter' },
    { labelHTML: qB, id: 'e4_cond' }
  ];

  renderRows(host, 'R√©pondre en %, fraction ou d√©cimal.', rows, true);
}
,

  correct(host, st){
  const interExp = st.pA + st.pB - st.pU;   // P(A‚à©B)
  const condExp  = interExp / st.pA;        // P_A(B)

  const iEl = document.getElementById('e4_inter');
  const cEl = document.getElementById('e4_cond');

  const vInter = parseProbFlexible(iEl?.value);
  const vCond  = parseProbFlexible(cEl?.value);

  const okInter = Number.isFinite(vInter) && same(vInter, interExp, 1e-3);
  const okCond  = Number.isFinite(vCond)  && same(vCond,  condExp,  1e-3);

  // ‚úî/‚úò sur les champs (booleans, pas "ok"/"ko")
  setTick(iEl, Number.isFinite(vInter) ? okInter : null);
  setTick(cEl, Number.isFinite(vCond)  ? okCond  : null);

  const allFilledNow = Number.isFinite(vInter) && Number.isFinite(vCond);
  const ok = allFilledNow && okInter && okCond;

  // Message r√©sultat (on peut rester ‚Äúverbal‚Äù ici, la notation formelle est pour la solution)
  let msg = '';
  if (!allFilledNow){
    msg = 'Compl√®te les deux r√©ponses puis clique sur ¬´ V√©rifier ¬ª.';
  } else if (ok){
    msg = '‚úî Bien jou√© ! Les deux probabilit√©s sont correctes.';
  } else {
    msg = '‚úò Indice : l‚Äôintersection se d√©duit de ¬´ au moins un des deux ¬ª ; la probabilit√© conditionnelle est ‚Äúparmi ceux qui ‚Ä¶‚Äù.';
  }

  const res = document.getElementById('res');
  res.innerHTML = msg;
  res.className = ok ? 'res res-ok' : 'res res-ko';
  try{ MathJax.typesetPromise([res]); }catch(_){}

  return { ok, total: 1 };
},


  solution(host, st){
    const { A, B } = st.c;
    const inter = st.pA + st.pB - st.pU;
    const html =
      `<p>a) \\(P(${A}\\cap ${B}) = P(${A}) + P(${B}) - P(${A}\\cup ${B}) = ${st.pA.toFixed(2)} + ${st.pB.toFixed(2)} - ${st.pU.toFixed(2)} = ${inter.toFixed(2)}\\).</p>
       <p>b) \\(P_{${A}}(${B}) = \\dfrac{P(${A}\\cap ${B})}{P(${A})} = \\dfrac{${inter.toFixed(2)}}{${st.pA.toFixed(2)}} = ${(inter/st.pA).toFixed(2)}\\).</p>`;
    const res = document.getElementById('res'); res.innerHTML = html; res.className = 'res-ok';
    try{ MathJax.typesetPromise([res]); }catch(_){}
  },

  reset(host){ innerHost(host).innerHTML=''; }
};



/* ===== Exercice 5 ‚Äî Banque (20) type ¬´ Commerciaux / voiture de fonction ¬ª ===== */
const EX5_BANK = (() => {
  const places = [
    {C:'l‚Äôemploy√© interrog√© est un commercial', V:'l‚Äôemploy√© poss√®de une voiture de fonction', c:'C', v:'V', who:'Dans l‚Äôentreprise'},
    {C:'l‚Äôagent interrog√© travaille au service support', V:'l‚Äôagent dispose d‚Äôun poste portable', c:'S', v:'P', who:'Dans l‚Äôorganisation'},
    {C:'l‚Äô√©tudiant interrog√© suit la fili√®re info', V:'l‚Äô√©tudiant dispose d‚Äôun ordinateur pr√™t√©', c:'I', v:'O', who:'Dans la promo'}
  ];
  const L=[];
  for(let k=0;k<20;k++){
    const p=choice(places);
    const pC = rnd(55,85)/100;
    const pV_C = rnd(60,90)/100;
    const pV_notC = rnd(5,25)/100;
    L.push({p, pC, pV_C, pV_notC});
  }
  return L;
})();

const ex5 = {
  id:'bank_commercial_voiture',
  title:'Phrase et calcul',
  gen(){ return choice(EX5_BANK); },
  render(host, st){
    const p = st.p;
    const rows = [
      {labelHTML:`${p.who}, on interroge au hasard un employ√©. Soient \\(C:\\) ¬´ ${p.C} ¬ª et \\(V:\\) ¬´ ${p.V} ¬ª.`, rightHTML:''},
      {labelHTML:`1a) Donner \\(P(${p.c})\\) et \\(P(\\overline{${p.c}})\\).`, id:'e5_1a'},
      {labelHTML:`1b) Donner \\(P_{${p.c}}(${p.v})\\) et \\(P_{\\overline{${p.c}}}(${p.v})\\).`, id:'e5_1b'},
      {labelHTML:`2a) D√©finir par une phrase l‚Äô√©v√©nement \\(${p.c}\\cap ${p.v}\\). Puis calculer \\(P(${p.c}\\cap ${p.v})\\).`, id:'e5_2a'},
      {labelHTML:`2b) D√©finir par une phrase l‚Äô√©v√©nement \\(\\overline{${p.c}}\\cap ${p.v}\\). Puis calculer \\(P(\\overline{${p.c}}\\cap ${p.v})\\).`, id:'e5_2b'}
    ];
    renderRows(host, 'Compl√©ter : notations puis calculs (valeurs en %, d√©cimal ou fraction).', rows);
  },
  correct(host, st){
    const p=st.p;
    // 1a / 1b : on v√©rifie juste que les notations attendues apparaissent (souplesse)
    const a = String($('#e5_1a',host).value||'').replace(/\s+/g,'');
    const b = String($('#e5_1b',host).value||'').replace(/\s+/g,'');
    const ok1a = a.includes(`P(${p.c})`) && a.includes(`P(\\overline{${p.c}})`);
    const ok1b = b.includes(`P_${p.c}(${p.v})`) && b.includes(`P_\\overline{${p.c}}(${p.v})`);
    // 2a : texte + nombre
    const t2a = String($('#e5_2a',host).value||'');
    const num2a = parseProbFlexible(t2a);
    const exp2a = st.pC * st.pV_C;
    const ok2aText = /commercial|voiture|fonction|portable|support|info|ordinateur|pr√™t√©/i.test(t2a);
    const ok2aNum = Number.isFinite(num2a) && same(num2a, exp2a, 1e-3);
    // 2b
    const t2b = String($('#e5_2b',host).value||'');
    const num2b = parseProbFlexible(t2b);
    const exp2b = (1-st.pC) * st.pV_notC;
    const ok2bText = /non|pas|sans|n‚Äô/i.test(t2b) || /overline/.test(t2b);
    const ok2bNum = Number.isFinite(num2b) && same(num2b, exp2b, 1e-3);

    const ok = ok1a && ok1b && ok2aText && ok2aNum && ok2bText && ok2bNum;
    $('#res',host).innerHTML = ok ? '‚úî' :
      '‚úò Rappels : \\(P(C\\cap V)=P(C)\\,P_C(V)\\) et \\(P(\\overline{C}\\cap V)=P(\\overline{C})\\,P_{\\overline{C}}(V)\\).';
    $('#res',host).className = ok?'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const p=st.p, pc=st.pC, pvC=st.pV_C, pvNc=st.pV_notC;
    const html = [
      `1a) \\(P(${p.c})=${pc.toFixed(2)}\\) ; \\(P(\\overline{${p.c}})=${(1-pc).toFixed(2)}\\).`,
      `1b) \\(P_{${p.c}}(${p.v})=${pvC.toFixed(2)}\\) ; \\(P_{\\overline{${p.c}}}(${p.v})=${pvNc.toFixed(2)}\\).`,
      `2a) \\(${p.c}\\cap ${p.v}\\) : ¬´ ${p.C} ET ${p.V} ¬ª. \\(P=${(pc*pvC).toFixed(3)}\\).`,
      `2b) \\(\\overline{${p.c}}\\cap ${p.v}\\) : ¬´ non-${p.C} ET ${p.V} ¬ª. \\(P=${((1-pc)*pvNc).toFixed(3)}\\).`
    ].map(x=>`<p>${x}</p>`).join('');
    $('#res',host).innerHTML = html; $('#res',host).className='res-ok'; retypeset($('#res',host));
  },
  reset(host){ innerHost(host).innerHTML=''; }
};

/* ====== REGISTRY + moteur ====== */
const REGISTRY = [ex1, ex2, ex3, ex4, ex5];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $('#score').textContent = `Score : ${scoreOK} / ${scoreTot}`; }

function buildOne(){
  const host=$('#host'); const sel=$('#exo-select');
  const def = REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st = def.gen();
  host.dataset.active = def.id;
  host.dataset.state = JSON.stringify(st);
  def.render(host, st);
  const res = $('#res',host); if(res){ res.textContent=''; res.className='res'; }
  addTicks();
}
function check(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  if(!allFilled()){ $('#res',host).textContent=''; $('#res',host).className='res'; return; }
  const st = JSON.parse(host.dataset.state||'{}');
  const r = def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def||!def.solution) return;
  const st = JSON.parse(host.dataset.state||'{}'); def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def&&def.reset) def.reset(host);
}

document.addEventListener('DOMContentLoaded', ()=>{
  innerHost(document.getElementById('host'));
  const sel=$('#exo-select');
  REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change', buildOne);
  $('#btn-new').addEventListener('click', buildOne);
  $('#btn-check').addEventListener('click', check);
  $('#btn-solution').addEventListener('click', solution);
  $('#btn-reset').addEventListener('click', resetAll);
  sel.value=REGISTRY[0].id; buildOne(); updateScore();

  document.addEventListener('keydown', ev=>{
    const a=document.activeElement;
    if(ev.key==='Enter' && a && a.matches('#host input[type=text]') && !a.closest('.equ-offscreen')){
      ev.preventDefault(); try{ check(); }catch(_){}
    }
  });

  // PDF si pr√©sent (m√™me API que tes fiches)
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Premi√®re ‚Äì Probabilit√©s conditionnelles',
      max:50,
      mountAfterSelector:'.card.small',
      beforeRender(def, st, withSolutions){
        const tmp = document.createElement('div');
        tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
        def.render(tmp, st);
        if(!withSolutions){
          const off = tmp.querySelector('.equ-offscreen');
          return off ? off.innerHTML : '';
        } else if(def.solution){
          def.solution(tmp, st);
          return tmp.querySelector('#res')?.innerHTML || '';
        }
        return '';
      }
    });
  }
});
})();
</script>

<!-- JS fournis -->
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/fraction-sign-clarity.dom.v3.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn'); clone.type='button'; clone.removeAttribute('id');
          clone.addEventListener('click',(e)=>{e.preventDefault(); src.click();});
          bar.appendChild(clone);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center',behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r=parseFloat(c.getAttribute('r')||'5'); if(r<10) c.setAttribute('r','12'); c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
