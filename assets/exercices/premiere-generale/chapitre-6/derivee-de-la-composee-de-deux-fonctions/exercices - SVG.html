<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äî D√©rivation : Fonction compos√©e</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc d'√©tapes / correction */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:center;
  gap:.4rem;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
}

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}

/* tableau 2 colonnes m√©thode 1 / m√©thode 2 */
.twocol-solution{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  width:auto;
}
.twocol-solution td{
  vertical-align:top;
  padding:0 16px;
  border:none;
  white-space:nowrap;
  line-height:1.75;
  font-size:0.95rem;
}
/* barre verticale SEULEMENT entre les 2 colonnes */
.twocol-solution td.col-gauche{
  border-right:2px solid #999;
  padding-right:24px;
}
.twocol-solution td.col-droite{
  padding-left:24px;
}
.twocol-solution .line{
  margin:.3rem 0;
}
.twocol-solution .line mjx-container{
  padding-bottom:.08em;
}

/* mini tableau u / u' / g / g' en colonne gauche */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{
    padding:4px 40px 4px 0;
  }
}

@media print{ .controls{display:none !important;} }

</style>

<!-- MathJax SVG (inline + display) -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true,
    packages: { '[+]': ['bbox','ams'] },
    macros: { frac: ['\\dfrac{#1}{#2}', 2] }
  },
  options: {
    skipHtmlTags: ['script','noscript','style','textarea'],
    renderActions: { assistiveMml: [] }
  },
  startup: { typeset:true }
};
</script>
<script defer src="../../../../es5/tex-svg.js"></script>
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1√®re ‚Äì D√©rivation : Fonction compos√©e</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
    <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
    <button id="btn-solution" class="btn">üí° Solution</button>
    <button id="btn-reset" class="btn">üßπ R√©initialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; r√©ponses accept√©es :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x¬≤</code>‚Ä¶</li>
      <li>Racines : <code>sqrt(‚Ä¶)</code>, <code>rac(‚Ä¶)</code>, <code>‚àö(‚Ä¶)</code>.</li>
      <li>Fractions : <code>a/b</code>. Multiplications implicites accept√©es.</li>
    </ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- D√©pendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ====== util DOM + score ====== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){
  const el=$("#score");
  if(el) el.textContent = scoreOK+" / "+scoreTot;
}
function scanFractions(root){
  try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){}
}

/* ====== random helpers ====== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

/* ===== normalisation / √©val saisie ===== */
function normalizeRac(s){
  s = String(s||'');

  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  s = s.replace(/(\d|\))\s*‚àö\s*\(/g, '$1*sqrt(');
  s = s.replace(/(\d|\))\s*‚àö\s*x\b/gi, '$1*sqrt(x)');
  s = s.replace(/‚àö\s*\(/g,   'sqrt(')
       .replace(/‚àö\s*x\b/gi, 'sqrt(x)');

  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
  return s;
}
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');
  s = normalizeRac(s);

  // puissances unicode -> ^ -> **
  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }
}
function almost(a,b,eps=1e-8){
  return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b)));
}

/* ===== helpers d'affichage pour affines / polyn√¥mes courts ===== */
function affineLatex(A,B){
  const absA=Math.abs(A), absB=Math.abs(B);
  // terme en x
  let sA = (absA===1?'x':`${absA}x`);
  if(A<0) sA='-'+sA;
  // constante
  let sB='';
  if(B!==0){
    if(B>0) sB = ' + '+absB;
    else    sB = ' - '+absB;
  }
  return sA + sB;
}
function affineToJS(A,B){
  const absA=Math.abs(A);
  let tA = (absA===1?'x':`${absA}*x`);
  if(A<0) tA='-('+tA+')';
  let expr=tA;
  if(B!==0){
    if(B>0) expr += `+${B}`;
    else    expr += `${B}`;
  }
  return expr;
}
function affineDerivLatex(A){
  // u'(x)=A (constante)
  return String(A);
}

/* polyn√¥me degr√©>=2 pour exo2 */
function randPoly(minDeg,maxDeg){
  const deg = rnd(minDeg,maxDeg);
  const coeffs=[];
  for(let i=0;i<=deg;i++){
    let c=rnd(-5,5);
    if(i===deg){
      while(c===0) c=rnd(-5,5); // coef dominant ‚â†0
    }
    coeffs.push(c);
  }
  return coeffs;
}
function polyToLatex(p){
  const terms=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    const absA=Math.abs(a);
    let seg='';
    if(i===0){
      seg = String(absA);
    }else if(i===1){
      seg = (absA===1)?'x':`${absA}x`;
    }else{
      seg = (absA===1)?`x^{${i}}`:`${absA}x^{${i}}`;
    }
    seg = (a<0?'-':'+' )+' '+seg;
    terms.push(seg);
  }
  if(!terms.length) return '0';
  return terms.join(' ').replace(/^\+\s*/,'').trim();
}
function polyToJS(p){
  const parts=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    let seg='';
    if(i===0){
      seg=String(Math.abs(a));
    }else if(i===1){
      seg=(Math.abs(a)===1)?'x':`${Math.abs(a)}*x`;
    }else{
      seg=(Math.abs(a)===1)?`x**${i}`:`${Math.abs(a)}*x**${i}`;
    }
    if(a<0) parts.push(`-(${seg})`);
    else parts.push(seg);
  }
  if(!parts.length) return '0';
  let expr=parts.join('+');
  expr=expr.replace(/\+\-\(/g,'-(');
  return expr;
}
function polyDeriv(p){
  if(p.length<=1) return [0];
  const d=[];
  for(let i=1;i<p.length;i++){
    d.push(p[i]*i);
  }
  return d;
}

/* petites fonctions utilitaires pour affichage propre */
function cleanSignsDisplay(str){
  // supprime "+ 0", "- 0" en fin, r√©pare "+ -" -> "-" etc.
  if(!str) return str;
  let out = String(str);

  out = out.replace(/\+\s*-\s*/g,' - ');
  out = out.replace(/-\s*-\s*/g,' + ');
  out = out.replace(/\+\s*\+\s*/g,' + ');
  out = out.replace(/-\s*\+\s*/g,' - ');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/^\+\s*/,''); // retire + en t√™te
  out = out.replace(/(\+|‚àí|-)\s*0($|[^0-9])/g, ' $2'); // virer "+ 0" isol√©s
  out = out.replace(/\s+/g,' ').trim();
  return out;
}

// essaie de simplifier le num√©rateur k * dU par 2
// renvoie une string LaTeX sans le /2 si possible, sinon ""
function buildAfterDivide2(k, dULatex, uLatex){
  // k : entier (coeff devant la racine, genre -2, 3, etc.)
  // dULatex : d√©riv√©e u'(x) d√©j√† substitu√©e (ex "10x-1" ou "(10x-1)" selon parenth√®ses)
  // uLatex : le u(x) explicite (ex "5x^2 - x + 3")
  //
  // On part de   (k * dU) / ( 2 sqrt(u) )
  // Si k est multiple de 2 -> (k/2 * dU) / sqrt(u)
  // Sinon pas de simplification => retourne "" (c√†d pas de ligne suppl√©mentaire)

  if(k % 2 !== 0) return "";

  const half = k/2; // peut √™tre n√©gatif
  // Cas sp√©cial : half = 1 ou -1 ‚Üí on ne veut pas "1√ó"
  let numLatex;
  if(half === 1){
    numLatex = dULatex.replace(/^\((.*)\)$/,'$1'); // enl√®ve parenth√®ses inutiles autour (10x-1)
  }else if(half === -1){
    // "-1 √ó (10x-1)" => "-(10x-1)"
    // si dULatex est d√©j√† parenth√©s√© "(10x-1)" : devient "-(10x-1)"
    // si pas parenth√©s√© "10x-1" : devient "-(10x-1)" quand m√™me pour bien montrer le bloc
    const core = dULatex.match(/^\((.*)\)$/) ? dULatex : `(${dULatex})`;
    numLatex = `-${core}`;
  }else{
    // g√©n√©ral : "c √ó (10x-1)" (si dULatex pas d√©j√† parenth√©s√© ET contient un "+"/"-", on le parenth√®se)
    let core = dULatex;
    if(!/^\(.*\)$/.test(core) && /[+\-]/.test(core)){
      core = `(${core})`;
    }
    numLatex = `${half} ${core}`;
  }

  return `\\dfrac{${numLatex}}{\\sqrt{${uLatex}}}`;
}


/* =========================================================
   EXERCICE 1
   u(x) affine ; g = puissance OU racine (avec coeff k devant possible)
   Deux m√©thodes dans la correction.
   ========================================================= */
function genEx1(){
  // on choisit un type : puissance ( (ax+b)^n ) ou racine k‚àö(ax+b)
  const kind = choice(["pow","sqrt"]);

  // g√©n√®re u(x)=ax+b avec a‚â†0
  const a = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);
  const b = rnd(-6,6);

  const uLatex = affineLatex(a,b);
  const uPrime = a; // constante
  const uJS = '('+affineToJS(a,b)+')';

  let title = "Exercice 1 : D√©rivation d‚Äôune compos√©e (avec u affine)";
  let enonce = "";
  let solHTML = "";
  let latexF = "";
  let fpJS;  // fonction JS de f'
  let fJS;   // fonction JS de f

  if(kind==="pow"){
    // puissance n, entre 2 et 7
    const n = rnd(2,7);

    latexF = `(${uLatex})^{${n}}`;

    // f(x) = (u(x))^n
    // f'(x) = n * (u(x))^{n-1} * u'(x)
    // pour la m√©thode 1 on veut la forme g(u(x)) avec g(x)=x^n
    // g'(x)= n x^{n-1}
    const gLatex   = `x^{${n}}`;
    const gPrime   = `${n}x^{${n-1}}`;

    // Substitution g'(u(x)) = n(u(x))^{n-1}
    // attention au signe de u'(x) dans le produit final :
    // On affiche (u'(x)) entre parenth√®ses si u'(x)<0.
    const uPrimeLatex = String(uPrime);
    const uPrimePar = (uPrime<0?`(${uPrimeLatex})`:uPrimeLatex);

   // M√©thode 1 (cha√Æne g‚àòu)
const method1Lines = [
  `\\(f(x)=g(u(x))\\( \\) \\text{ avec } u(x)=${uLatex},\\ u'(x)=${uPrimeLatex},\\ g(x)=${gLatex},\\ g'(x)=${gPrime}\\)`,
  `\\(f'(x)=g'(u(x))\\times u'(x)\\)`,
  `\\(f'(x)= ${n}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}\\)`
];

// M√©thode 2 (formule directe (u^n)' = n u^{n-1} u')
const method2Lines = [
  `\\(f(x)=(${uLatex})^{${n}}\\)`,
  `\\(f'(x)= ${n}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}\\)`
];

// r√©sultat simplifi√© Latex final :
const finalLatex = `${n}\\,(${uLatex})^{${n-1}}\\times ${uPrimePar}`;

enonce =
  `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
  `\\[ f(x)=(${uLatex})^{${n}} \\]`;
// pr√©paration avant le template HTML
// ---------------------------------

// version "propre" de g'(x) sans exposant 1
const gPrimeNice =
  (n === 2)
    ? `${n}x`
    : `${n}x^{${n-1}}`;

// g'(u(x)) d√©j√† nettoy√© plus haut :
const gPrimeComposeLatex =
  (n === 2)
    ? `${n}\\,u(x)`
    : `${n}\\,(u(x))^{${n-1}}`;

// f'(x)= ... sans puissance 1
const derivGeneric_uLatex =
  (n === 2)
    ? `${n}\\,u(x)u'(x)`
    : `${n}\\,(u(x))^{${n-1}}u'(x)`;

// version d√©velopp√©e avec u(x)=... et u'(x)=...
const derivExpandedLatex =
  (n === 2)
    ? `${n}\\,(${uLatex}) \\times ${uPrimePar}`
    : `${n}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}`;

// Conclusion finale propre
const finalLatexClean =
  (n === 2)
    ? `${n}\\,(${uLatex}) \\times ${uPrimePar}`
    : `${n}\\,(${uLatex})^{${n-1}}\\times ${uPrimePar}`;


const uPrimeNum = uPrime; // uPrime √©tait d√©j√† le nombre d√©riv√© de u(x) (ex: -3)

const coeffNum = n * uPrimeNum; // nombre pur
function coeffLatex(c){
  // si c = -1 ou 1 on garde le ¬±1 explicite, pas besoin de ruser,
  // parce que tu montres bien le coefficient num√©rique final tel quel.
  return `${c}`;
}

const derivFinalSimplifiedLatex =
  (n === 2)
    ? `${coeffLatex(coeffNum)}\\,(${uLatex})`
    : `${coeffLatex(coeffNum)}\\,(${uLatex})^{${n-1}}`;

// 7. C'est cette version qu'on veut afficher en DERNI√àRE ligne
//    dans chaque colonne, et dans "Conclusion :"
const finalLatexClean2 = derivFinalSimplifiedLatex;


solHTML = `
<div class="steps">
  <table class="twocol-solution">
    <tr>
      <td class="col-gauche">
        <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

        <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
        <table class="uvtab">
          <tr>
            <td>\\(u(x)=${uLatex}\\)</td>
            <td>\\(g(x)=${gLatex}\\)</td>
          </tr>
          <tr>
            <td>\\(u'(x)=${uPrimeLatex}\\)</td>
            <td>\\(g'(x)=${gPrimeNice}\\)</td>
          </tr>
          <tr>
            <td></td>
            <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
          </tr>
        </table>

        <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
        <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>

        <div class="line">\\(f'(x)= ${derivExpandedLatex}\\)</div>
				  <div class="line">\\(f'(x)= ${finalLatexClean2}\\)</div>

      </td>

      <td class="col-droite">
        <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>
        <div class="line">\\(f(x)=(u(x))^{${n}}\\) \\( \\) avec :</div>
        <table class="uvtab">
          <tr>
            <td>\\(u(x)=${uLatex}\\)</td>
          </tr>
          <tr>
            <td>\\(u'(x)=${uPrimeLatex}\\)</td>
          </tr>
        </table>

        <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>

        <div class="line">\\(f'(x)= ${derivExpandedLatex}\\)</div>
		  <div class="line">\\(f'(x)= ${finalLatexClean2}\\)</div>
      </td>
    </tr>
  </table>


</div>`;




    // fonctions JS num pour check
    fJS = x => {
      const u = Function("x","return "+uJS+";")(x);
      return Math.pow(u,n);
    };
    fpJS = x => {
      const u  = Function("x","return "+uJS+";")(x);
      const du = uPrime;
      return n*Math.pow(u,n-1)*du;
    };

  } else { // kind==="sqrt"
    // k * sqrt(ax+b)
    // k non nul, √©viter k=1 affich√© comme "1‚àö", on g√®re texte
    let k = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);
    // √©viter k=1 affich√© "1‚àö", on ne l'affiche pas si 1 ; si -1 on affiche juste "‚àí"
    const kAbs = Math.abs(k);
    let kPrefix;
    if(k===1){ kPrefix = ""; }
    else if(k===-1){ kPrefix = "‚àí"; }
    else{
      kPrefix = (k<0? "‚àí"+kAbs : String(kAbs));
    }

    latexF = `${kPrefix}\\sqrt{${uLatex}}`;

    // Ici f(x)=k‚àö(u(x)).
    // Posons u(x)=ax+b.
    // g(t)=k‚àöt ‚Üí g'(t)=k * 1/(2‚àöt).
    // M√©thode 1 : g‚àòu.
    const gLatex   = `${kPrefix}\\sqrt{x}`.replace(/‚àí-/g,'‚àí'); // affichage g(x)
    // g'(x)=k/(2‚àöx). Attention kPrefix pour la d√©riv√©e :
    // si k=‚àí1 on veut - 1/(2‚àöx) ‚Üí "- \\dfrac{1}{2\\sqrt{x}}"
    let gPrimeLatex;
    if(k===1){
      gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
    }else if(k===-1){
      gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
    }else{
      gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
    }

    // substitution : g'(u(x)) = k/(2‚àö(u(x)))
    // puis * u'(x)=a
    const uPrimeLatex = String(uPrime);
    // parenth√®ses autour de u'(x) si n√©gatif pour la ligne produit
    const uPrimePar = (uPrime<0?`(${uPrimeLatex})`:uPrimeLatex);

    const uPrimePar2 = (uPrime<0?`${uPrimeLatex}`:uPrimeLatex);

    // M√©thode 1 lignes
    // On va aussi simplifier comme dans ton screen :
    // f'(x)= k * u'(x) / (2‚àö(u(x)))
    // puis r√©duire k*a /2 etc.
    // Calcul du num√©rateur final k*a
    const numFinal = k*uPrime;
    // Denom 2‚àö(u(x))
    // Forme mise au propre : numFinal / (2‚àö(u(x)))
    // ex : k=-2, a=5 ‚Üí numFinal=-10 ‚Üí f'(x)= -10/(2‚àö(...)) = -5/‚àö(...)
    // On va faire la simplification finale nous-m√™mes pour l'affichage "Conclusion".
    const rawNum   = k*uPrime;
    const rawDen   = 2;
    // simplif fraction k*a /2
    function fracSimplif(n,d){
      // on essaie juste de /2 si possible
      if(n%d===0){ return [n/d,1]; }
      return [n,d];
    }
    const [simpNum, simpDen] = fracSimplif(rawNum,rawDen);

    let finalFracLatex;
    if(simpDen===1){
      // ex -5 / ‚àö(u)
      // si simpNum = ¬±1 on veut juste "-" devant ?
      if(simpNum===1){
        finalFracLatex = `\\dfrac{1}{\\sqrt{${uLatex}}}`;
      }else if(simpNum===-1){
        finalFracLatex = `-\\dfrac{1}{\\sqrt{${uLatex}}}`;
      }else{
        finalFracLatex = `\\dfrac{${simpNum}}{\\sqrt{${uLatex}}}`;
      }
    }else{
      // ex num/2‚àö(u)
      // si rawNum = 1 ‚Üí 1/(2‚àö(...)), si -1 ‚Üí -1/(2‚àö(...)), sinon n/(2‚àö(...))
      if(rawNum===1){
        finalFracLatex = `\\dfrac{1}{2\\sqrt{${uLatex}}}`;
      }else if(rawNum===-1){
        finalFracLatex = `-\\dfrac{1}{2\\sqrt{${uLatex}}}`;
      }else{
        finalFracLatex = `\\dfrac{${rawNum}}{2\\sqrt{${uLatex}}}`;
      }
    }
// On veut g√©rer proprement l'affichage quand k = 1 ou k = -1
// kPrefix = "" si k=1, "-" si k=-1, sinon "k"
// (tu l'as d√©j√† dans ton code, je le r√©utilise tel quel)

// 1. g'(x) = k / (2‚àöx)
//    -> si k = 1 on veut 1/(2‚àöx) (√ßa va, pas de "1√ó" implicite)
//    -> si k = -1, on veut -1/(2‚àöx) OK
//    pas besoin de changer g'(x) ici

// 2. g'(u(x)) = k / (2‚àö(u(x)))
//    pareille logique, pas de "1√ó" ici donc c'est d√©j√† bien

// 3. f'(x) = [k u'(x)] / [2‚àö(u(x))]
//    si k = 1 -> u'(x) / (2‚àö(u(x)))
//    si k = -1 -> -u'(x) / (2‚àö(u(x)))
//    si k = autre -> (k u'(x)) / (...)
//
let fracGeneric_no1;
if (k === 1) {
  fracGeneric_no1 = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
} else if (k === -1) {
  // k=-1 : -u'(x)/(2‚àöu(x))
  fracGeneric_no1 = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
} else {
  fracGeneric_no1 = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
}

// 4. version avec substitution u'(x)=uPrimePar et u(x)=uLatex
//    ex avant:  (k √ó uPrimePar)/(2‚àö(uLatex))
//    si k = 1 -> (uPrimePar)/(2‚àö(...))
//    si k = -1 -> (-uPrimePar)/(2‚àö(...))
//    pas de "1 √ó" ni "1 √ó (...)".
//    Pas de "k √ó" quand k=1.
//
let fracExpanded_no1;
if (k === 1) {
  // juste uPrimePar au num√©rateur
  fracExpanded_no1 = `\\dfrac{${uPrimePar2}}{2\\sqrt{${uLatex}}}`;
} else if (k === -1) {
  // -uPrimePar
  fracExpanded_no1 = `\\dfrac{-\\,${uPrimePar}}{2\\sqrt{${uLatex}}}`;
} else {
  fracExpanded_no1 = `\\dfrac{${k}\\times ${uPrimePar}}{2\\sqrt{${uLatex}}}`;
}

// 5. M√©thode 2 : premi√®re ligne "f(x)= k‚àö{u(x)}"
//    si k = 1 -> "f(x)=‚àö{u(x)}"
//    si k = -1 -> "f(x)= -\\sqrt{u(x)}"
//    sinon "f(x)= k\\sqrt{u(x)}"
let fxMethod2;
if (k === 1) {
  fxMethod2 = `f(x)=\\sqrt{u(x)}`;
} else if (k === -1) {
  fxMethod2 = `f(x)=-\\sqrt{u(x)}`;
} else {
  fxMethod2 = `f(x)=${k}\\sqrt{u(x)}`;
}

// 6. Dans la fraction finale que tu appelles finalFracLatex,
//    tu dois t'assurer qu'elle n'a pas "1√ó" dedans non plus.
//    On suppose que finalFracLatex c'est d√©j√† la forme r√©duite genre "-2 / ‚àö(-4x-4)".
//    Si jamais tu la construis encore avec `k * uPrimePar`, pense √† appliquer
//    la m√™me logique que ci-dessus. Mais je la garde telle que tu la fournis.

const method1HTML = `

  <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>

  <table class="uvtab">
    <tr>
      <td>\\(u(x)=${uLatex}\\)</td>
      <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
    </tr>
    <tr>
      <td>\\(u'(x)=${uPrimeLatex}\\)</td>
      <td>\\(g'(x)=${gPrimeLatex}\\)</td>
    </tr>
    <tr>
      <td></td>
      <td>\\(g'(u(x))=\\dfrac{${k}}{2\\sqrt{u(x)}}\\)</td>
    </tr>
  </table>

  <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

  <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

  <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>

  <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
`;

// M√©thode 2 : formule sp√©cifique (k‚àöu)' = k * u' / (2‚àöu)
const method2HTML = `
  <div class="line">\\(${fxMethod2}\\) \\( \\) avec :</div>
  <table class="uvtab">
    <tr>
      <td>\\(u(x)=${uLatex}\\)</td>
    </tr>
    <tr>
      <td>\\(u'(x)=${uPrimeLatex}\\)</td>
    </tr>
  </table>

  <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

  <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>

  <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
`;

enonce =
  `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
  `\\[ f(x)= ${kPrefix}\\sqrt{${uLatex}} \\]`;

solHTML = `
<div class="steps">
  <table class="twocol-solution">
    <tr>
      <td class="col-gauche">
        <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>
        ${method1HTML}
      </td>
      <td class="col-droite">
        <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>
        ${method2HTML}
      </td>
    </tr>
  </table>
</div>`;


    // fonctions JS num pour check :
    fJS = x => {
      const u = Function("x","return "+uJS+";")(x);
      return k*Math.sqrt(u);
    };
    fpJS = x => {
      const u  = Function("x","return "+uJS+";")(x);
      const du = uPrime;
      // d√©riv√©e num : k * du / (2 sqrt(u))
      return k*du/(2*Math.sqrt(u));
    };
  }

  return {
    title,
    enonce,
    solHTML,
    latexF,
    fJS,
    fpJS,
    // pour PDF :
    latexFp_raw: '', // pas besoin ici mais on laisse pour compat
    latexFp: ''      // idem
  };
}

/* =========================================================
   EXERCICE 2
   u(x) NON affine (polyn√¥me deg>=2 OU 1/x), g = puissance ou racine (avec coeff k)
   M√™me pr√©sentation 2 colonnes.
   ========================================================= */
function genEx2(){
  // sc√©narios possibles :
  // 1) f(x) = (P(x))^n     (P degr√© 2..3)
  // 2) f(x) = k‚àö(P(x))     (P degr√© 2..3)
  // 3) f(x) = (1/x)^n
  // 4) f(x) = k‚àö(1/x)
  const kind = choice(["powPoly","sqrtPoly","powInv","sqrtInv"]);

  // petit helper : proprement √©crire un coefficient num√©rique final
  const coeffTex = c => `${c}`;

  let title="Exercice 2 : D√©rivation d‚Äôune compos√©e (u non affine)";
  let enonce="", solHTML="";
  let latexF="";
  let fJS, fpJS;

  /* ====== CAS A : f(x) = (P(x))^n avec P polyn√¥me deg‚â•2 ====== */
  if(kind==="powPoly"){
    const P = randPoly(2,3);
    const dP = polyDeriv(P);

    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    // n entre 2 et 7
    const n = rnd(2,7);

    latexF = `(${Platex})^{${n}}`;
    enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)=(${Platex})^{${n}} \\]`;

    // g(x)=x^n , g'(x)=n x^{n-1}   -> √©criture sans ^1
    const gPrimeNice =
      (n===2)
        ? `${n}x`
        : `${n}x^{${n-1}}`;

    // g'(u(x))
    const gPrimeComposeLatex =
      (n===2)
        ? `${n}\\,u(x)`
        : `${n}\\,(u(x))^{${n-1}}`;

    // f'(x)= n(u(x))^{n-1}u'(x) sans puissance 1
    const derivGeneric_uLatex =
      (n===2)
        ? `${n}\\,u(x)u'(x)`
        : `${n}\\,(u(x))^{${n-1}}u'(x)`;

    // Substitution u(x)=P(x), u'(x)=P'(x)
    const derivExpandedLatex =
      (n===2)
        ? `${n}\\,(${Platex})  (${dPlatex})`
        : `${n}\\,(${Platex})^{${n-1}} (${dPlatex})`;

    // derni√®re ligne = derivExpandedLatex (on ne peut pas r√©duire plus proprement)
    const derivFinalSimplifiedLatex = derivExpandedLatex;

    solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

            <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=${Platex}\\)</td>
                <td>\\(g(x)=x^{${n}}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=${dPlatex}\\)</td>
                <td>\\(g'(x)=${gPrimeNice}\\)</td>
              </tr>
              <tr>
                <td></td>
                <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
              </tr>
            </table>

            <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

            <div class="line">\\(f(x)=(u(x))^{${n}}\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr><td>\\(u(x)=${Platex}\\)</td></tr>
              <tr><td>\\(u'(x)=${dPlatex}\\)</td></tr>
            </table>

            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
          </td>

        </tr>
      </table>
    </div>`;

    // num check
    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);
    fJS  = x => {
      const u=Function("x","return ("+Pjs+");")(x);
      return Math.pow(u,n);
    };
    fpJS = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      const du= Function("x","return ("+dPjs+");")(x);
      return n*Math.pow(u,n-1)*du;
    };

    // >>>>>>> IMPORTANT : on RETOURNE L'√âTAT ICI <<<<<<<<
    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  /* ====== CAS B : f(x)=k‚àö(P(x)) ====== */
  if(kind==="sqrtPoly"){
    const P = randPoly(2,3);
    const dP = polyDeriv(P);

    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    let k = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);

    // coeff visuel devant la racine
    const kAbs = Math.abs(k);
    let kPrefix;
    if(k===1){ kPrefix=""; }
    else if(k===-1){ kPrefix="‚àí"; }
    else{ kPrefix=(k<0? "‚àí"+kAbs : String(kAbs)); }

    latexF = `${kPrefix}\\sqrt{${Platex}}`;
    enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)= ${kPrefix}\\sqrt{${Platex}} \\]`;

    // g(x)=k‚àöx ; g'(x)=k/(2‚àöx) (sans "1√ó")
    let gPrimeLatex;
    if(k===1){
      gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
    }else if(k===-1){
      gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
    }else{
      gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
    }

    // g'(u(x))
    let gPrimeOfU;
    if(k===1){
      gPrimeOfU = `\\dfrac{1}{2\\sqrt{u(x)}}`;
    }else if(k===-1){
      gPrimeOfU = `-\\dfrac{1}{2\\sqrt{u(x)}}`;
    }else{
      gPrimeOfU = `\\dfrac{${k}}{2\\sqrt{u(x)}}`;
    }

    // forme g√©n√©rique : k u'(x)/(2‚àö(u(x)))
    let derivGeneric_uLatex;
    if(k===1){
      derivGeneric_uLatex = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
    }else if(k===-1){
      derivGeneric_uLatex = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
    }else{
      derivGeneric_uLatex = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
    }

    // substitution u(x)=P(x), u'(x)=P'(x)
    let derivExpandedLatex;
    if(k===1){
      derivExpandedLatex = `\\dfrac{${dPlatex}}{2\\sqrt{${Platex}}}`;
    }else if(k===-1){
      derivExpandedLatex = `\\dfrac{-\\,(${dPlatex})}{2\\sqrt{${Platex}}}`;
    }else{
      derivExpandedLatex = `\\dfrac{${k}(${dPlatex})}{2\\sqrt{${Platex}}}`;
    }

    const derivFinalSimplifiedLatex = derivExpandedLatex;
	// dPlatex = u'(x) = d√©riv√©e du polyn√¥me, ex "10x-1"
// ATTENTION : dans fracExpanded_no1 tu mets parfois (${dPlatex}) avec parenth√®ses.
// On pr√©pare une version "dULatex" sans le "√ók" d√©j√†, juste u'(x).
// Ici dULatex c'est dPlatex tel quel (ex "10x-1")
// S‚Äôil contient un + ou -, buildAfterDivide2 va ajouter les parenth√®ses si besoin.

let fracAfterDivide2 = "";
if (k % 2 === 0){
  fracAfterDivide2 = buildAfterDivide2(
    k,            // le coeff k devant la racine
    dPlatex,      // u'(x) sans facteur k
    Platex        // u(x)
  );
}


    solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

            <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=${Platex}\\)</td>
                <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=${dPlatex}\\)</td>
                <td>\\(g'(x)=${gPrimeLatex}\\)</td>
              </tr>
              <tr>
                <td></td>
                <td>\\(g'(u(x))=${gPrimeOfU}\\)</td>
              </tr>
            </table>

            <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
			
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
			${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }

          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

            <div class="line">\\(f(x)=${kPrefix}\\sqrt{u(x)}\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr><td>\\(u(x)=${Platex}\\)</td></tr>
              <tr><td>\\(u'(x)=${dPlatex}\\)</td></tr>
            </table>

            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
				${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }
          </td>

        </tr>
      </table>
    </div>`;

    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);
    fJS  = x => {
      const u=Function("x","return ("+Pjs+");")(x);
      return k*Math.sqrt(u);
    };
    fpJS = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      const du= Function("x","return ("+dPjs+");")(x);
      return k*du/(2*Math.sqrt(u));
    };

    // >>>>>>> IMPORTANT : on RETOURNE L'√âTAT ICI <<<<<<<<
    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  /* ====== CAS C : f(x) = (1/x)^n ====== */
  if (kind === "powInv") {
    const n = rnd(2,6);

    const uLatex        = `\\dfrac{1}{x}`;
    const uPrimeLatex   = `-\\dfrac{1}{x^{2}}`;

    latexF = `(\\dfrac{1}{x})^{${n}}`;
    enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles `+
      `de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)=\\left(\\dfrac{1}{x}\\right)^{${n}} \\]`;

    const gPrimeNice =
      (n === 2)
        ? `${n}x`
        : `${n}x^{${n-1}}`;

    const gPrimeComposeLatex =
      (n === 2)
        ? `${n}\\,u(x)`
        : `${n}\\,\\big(u(x)\\big)^{${n-1}}`;

    const derivGeneric_uLatex =
      (n === 2)
        ? `${n}\\,u(x)\\,u'(x)`
        : `${n}\\,\\big(u(x)\\big)^{${n-1}}\\,u'(x)`;

    const derivExpandedLatex =
      (n === 2)
        ? `${n}\\,\\left(${uLatex}\\right) \\times \\left(${uPrimeLatex}\\right)`
        : `${n}\\,\\left(${uLatex}\\right)^{${n-1}} \\times \\left(${uPrimeLatex}\\right)`;

    const finalFracLatex = `-\\dfrac{${n}}{x^{${n+1}}}`;

    solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

            <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=\\dfrac{1}{x}\\)</td>
                <td>\\(g(x)=x^{${n}}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td>
                <td>\\(g'(x)=${gPrimeNice}\\)</td>
              </tr>
              <tr>
                <td></td>
                <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
              </tr>
            </table>

            <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

            <div class="line">
              \\(f'(x)= ${derivGeneric_uLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${derivExpandedLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${finalFracLatex}\\)
            </div>
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

            <div class="line">
              \\(f(x)=\\big(u(x)\\big)^{${n}}\\) \\( \\) avec :
            </div>
            <table class="uvtab">
              <tr><td>\\(u(x)=\\dfrac{1}{x}\\)</td></tr>
              <tr><td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td></tr>
            </table>

            <div class="line">
              \\(f'(x)= ${derivGeneric_uLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${derivExpandedLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${finalFracLatex}\\)
            </div>
          </td>

        </tr>
      </table>
    </div>`;

    fJS  = x => Math.pow(1/x,n);
    fpJS = x => -n*Math.pow(x,-(n+1));

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  /* ====== CAS D : f(x) = k‚àö(1/x) ====== */
    /* ====== CAS D : f(x) = k‚àö(1/x) ====== */
  { // sqrtInv
  let k = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);

  // u(x)=1/x
  const uLatex      = `\\dfrac{1}{x}`;
  const uPrimeLatex = `-\\dfrac{1}{x^{2}}`;

  // affichage du k devant la racine
  const kAbs = Math.abs(k);
  let kPrefix;
  if (k === 1){
    kPrefix = "";
  } else if (k === -1){
    kPrefix = "‚àí";
  } else {
    kPrefix = (k<0? "‚àí"+kAbs : String(kAbs));
  }

  const latexF = `${kPrefix}\\sqrt{\\dfrac{1}{x}}`;

  // g(x)=k‚àöx ; g'(x)=k/(2‚àöx) sans "1√ó"
  let gPrimeLatex;
  if (k === 1){
    gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
  } else if (k === -1){
    gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
  } else {
    gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
  }

  // g'(u(x)) = k/(2‚àö(u(x)))
  let gPrimeOfU;
  if (k === 1){
    gPrimeOfU = `\\dfrac{1}{2\\sqrt{u(x)}}`;
  } else if (k === -1){
    gPrimeOfU = `-\\dfrac{1}{2\\sqrt{u(x)}}`;
  } else {
    gPrimeOfU = `\\dfrac{${k}}{2\\sqrt{u(x)}}`;
  }

  // f'(x)=g'(u(x))√óu'(x) (forme g√©n√©rique)
  let fracGeneric_no1;
  if (k === 1){
    fracGeneric_no1 = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
  } else if (k === -1){
    fracGeneric_no1 = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
  } else {
    fracGeneric_no1 = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
  }

  // remplacement explicite u'(x) = -1/x¬≤ etc.
  const uPrimeWithParIfK =
    (k === 1)
    ? `-\\dfrac{1}{x^{2}}`
    : `\\left(-\\dfrac{1}{x^{2}}\\right)`;

  let fracExpanded_no1;
  if (k === 1){
    fracExpanded_no1 = `\\dfrac{-\\dfrac{1}{x^{2}}}{2\\sqrt{\\dfrac{1}{x}}}`;
  } else if (k === -1){
    // (-1)*(-1/x¬≤) = +1/x¬≤
    fracExpanded_no1 = `\\dfrac{\\dfrac{1}{x^{2}}}{2\\sqrt{\\dfrac{1}{x}}}`;
  } else {
    fracExpanded_no1 = `\\dfrac{${k}\\times ${uPrimeWithParIfK}}{2\\sqrt{\\dfrac{1}{x}}}`;
  }

  // -------- Construction du f'(x) final propre (avec bon signe) --------
  // Th√©orie : f'(x) = -(k‚àöx)/(2x¬≤)
  // => coefficient global devant ‚àöx/(2x¬≤) = -k
  const coef_brut = -k;

  // on va remplir finalLatex
  let finalLatex = "";

  if (coef_brut % 2 === 0) {
    // coef_brut pair -> on simplifie /2
    const half = coef_brut / 2; // entier

    if (half === 1) {
      // +1 * ‚àöx / x¬≤
      finalLatex = `\\dfrac{\\sqrt{x}}{x^{2}}`;
    } else if (half === -1) {
      // -1 * ‚àöx / x¬≤
      finalLatex = `-\\dfrac{\\sqrt{x}}{x^{2}}`;
    } else {
      // half ‚â† ¬±1
      if (half === 0) {
        finalLatex = `0`;
      } else if (half > 0) {
        finalLatex = `\\dfrac{${half}\\,\\sqrt{x}}{x^{2}}`;
      } else {
        const absHalf = Math.abs(half);
        finalLatex = `-\\dfrac{${absHalf}\\,\\sqrt{x}}{x^{2}}`;
      }
    }
  } else {
    // pas divisible par 2 -> coef_brut / (2 ...)
    if (coef_brut === 1) {
      finalLatex = `\\dfrac{\\sqrt{x}}{2x^{2}}`;
    } else if (coef_brut === -1) {
      finalLatex = `-\\dfrac{\\sqrt{x}}{2x^{2}}`;
    } else if (coef_brut > 0) {
      finalLatex = `\\dfrac{${coef_brut}\\,\\sqrt{x}}{2x^{2}}`;
    } else {
      const absCoef = Math.abs(coef_brut);
      finalLatex = `-\\dfrac{${absCoef}\\,\\sqrt{x}}{2x^{2}}`;
    }
  }

  // Ligne interm√©diaire "apr√®s simplification par 2" (si k pair)
  let fracAfterDivide2 = "";
  if (k % 2 === 0){
    fracAfterDivide2 = buildAfterDivide2(
      k,
      "-\\dfrac{1}{x^{2}}",
      "\\dfrac{1}{x}"
    );
  }

  // M√©thode 1 HTML
  const method1HTML = `
    <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
    <table class="uvtab">
      <tr>
        <td>\\(u(x)=\\dfrac{1}{x}\\)</td>
        <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${uPrimeLatex}\\)</td>
        <td>\\(g'(x)=${gPrimeLatex}\\)</td>
      </tr>
      <tr>
        <td></td>
        <td>\\(g'(u(x))=${gPrimeOfU}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

    <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

    <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>
    ${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }

    <div class="line">\\(f'(x)= ${finalLatex}\\)</div>
  `;

  // M√©thode 2 HTML
  let fxMethod2;
  if (k === 1){
    fxMethod2 = `f(x)=\\sqrt{u(x)}`;
  } else if (k === -1){
    fxMethod2 = `f(x)=-\\sqrt{u(x)}`;
  } else {
    fxMethod2 = `f(x)=${k}\\sqrt{u(x)}`;
  }

  const method2HTML = `
    <div class="line">\\(${fxMethod2}\\) \\( \\) avec :</div>
    <table class="uvtab">
      <tr><td>\\(u(x)=\\dfrac{1}{x}\\)</td></tr>
      <tr><td>\\(u'(x)=${uPrimeLatex}\\)</td></tr>
    </table>

    <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

    <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>
    ${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }

    <div class="line">\\(f'(x)= ${finalLatex}\\)</div>
  `;

  const enonce =
    `D√©river la fonction suivante, sans se pr√©occuper des ensembles `+
    `de d√©finition/d√©rivabilit√© :<br><br>`+
    `\\[ f(x)= ${kPrefix}\\sqrt{\\dfrac{1}{x}} \\]`;

  const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>
          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>
            ${method1HTML}
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

  const fJS  = x => k * Math.sqrt(1/x);
  const fpJS = x => (-(k*Math.sqrt(x)) / (2*x*x));

  return {
    title:"Exercice 2 : D√©rivation d‚Äôune compos√©e (u non affine)",
    enonce,
    solHTML,
    latexF,
    fJS,
    fpJS,
    latexFp_raw:'',
    latexFp:''
  };
}

}



/* =========================================================
   RENDU BLOC EXO + v√©rification
   ========================================================= */
function buildHostHTML(st){
  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>
      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansF" class="inp" style="min-width:360px">
          <span id="tickF" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}

function setTick(ok){
  const el = $('#tickF');
  if(!el) return;
  el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
  el.textContent = ok===true?'‚úì': ok===false?'‚úó':'‚Äî';
}

function checkAnswer(st){
  const inp = $('#ansF');
  if(!inp){ setTick(null); return {count:0,good:0}; }
  const val = inp.value||'';
  if(!val.trim()){
    setTick(null);
    return {count:0,good:0};
  }

  // test num√©rique sur quelques x (positifs pour racines / 1/x)
  const xs=[1.2,1.8,2.5,3.7,5.1];
  let ok=true;
  for(const x of xs){
    const got=numEval(val,x);
    const ref=st.fpJS(x);
    if(!Number.isFinite(got)||!Number.isFinite(ref)||!almost(got,ref,1e-6)){
      ok=false;break;
    }
  }
  setTick(ok);
  return {count:1,good:(ok?1:0)};
}

/* =========================================================
   REGISTRY
   ========================================================= */
const EXO1 = {
  id:'exo1',
  title:'Exercice 1 ‚Äî u affine',
  gen(host){
    const st=genEx1();
    if(host){
      host.innerHTML=buildHostHTML(st);
      host.__state=st;
      host.dataset.state = JSON.stringify({
        title:st.title,
        enonce:st.enonce,
        latexF:st.latexF,
        latexFp:st.latexFp||'',
        latexFp_raw:st.latexFp_raw||'',
        solHTML:st.solHTML
      });
      if(window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }
    return st;
  },
  correct(host,st){
    const r=checkAnswer(st);
    scoreTot+=r.count;
    scoreOK +=r.good;
    updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML=st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent='';
    setTick(null);
    const inp=$('#ansF',host);
    if(inp) inp.value='';
  }
};

const EXO2 = {
  id:'exo2',
  title:'Exercice 2 ‚Äî u non affine',
  gen(host){
    const st=genEx2();
    if(host){
      host.innerHTML=buildHostHTML(st);
      host.__state=st;
      host.dataset.state = JSON.stringify({
        title:st.title,
        enonce:st.enonce,
        latexF:st.latexF,
        latexFp:st.latexFp||'',
        latexFp_raw:st.latexFp_raw||'',
        solHTML:st.solHTML
      });
      if(window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }
    return st;
  },
  correct(host,st){
    const r=checkAnswer(st);
    scoreTot+=r.count;
    scoreOK +=r.good;
    updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML=st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent='';
    setTick(null);
    const inp=$('#ansF',host);
    if(inp) inp.value='';
  }
};

const REG=[EXO1,EXO2];
window.REG=REG;
window.REGISTRY=REG;

/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host,host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host,host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);

/* ===== Adaptateur PDF =====
   m√™me principe que les autres fiches
*/
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(def, _st, ctx){
        const host = document.createElement('div');
        if(def && typeof def.gen === 'function') def.gen(host);
        let st={};
        try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
        return st;
      },
      beforeRender(def, st, withSolutions){
        try{
          const host = document.createElement('div');
          host.id='pdf-host';
          host.style.position='fixed';
          host.style.left='-10000px';
          host.style.top='-10000px';
          document.body.appendChild(host);

          host.innerHTML = (typeof window.buildHostHTML==='function')? buildHostHTML(st):'';
          host.dataset.state = JSON.stringify(st);

          if(withSolutions && def && typeof def.solution==='function'){
            def.solution(host,st);
          }

          // remplace les inputs par du texte
          (host.querySelectorAll('input, textarea, select, [contenteditable="true"]')||[])
          .forEach(el=>{
            const t=document.createTextNode(el.value||' ');
            el.replaceWith(t);
          });

          const outHTML = withSolutions
            ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
            : host.innerHTML;

          document.body.removeChild(host);
          return outHTML;
        }catch(e){
          console.error('PDF beforeRender error:', e);
          return null;
        }
      }
    });
  });
})();

/* ===== tweaks mobile ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r=parseFloat(c.getAttribute('r')||'5');
      if(r<10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
},{passive:true});
</script>

</body>
</html>
