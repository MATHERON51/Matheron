<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1ère — Dérivation : Fonction composée</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc d'étapes / correction */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:center;
  gap:.4rem;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
}

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}

/* tableau 2 colonnes méthode 1 / méthode 2 */
.twocol-solution{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  width:auto;
}
.twocol-solution td{
  vertical-align:top;
  padding:0 16px;
  border:none;
  white-space:nowrap;
  line-height:1.75;
  font-size:0.95rem;
}
/* barre verticale SEULEMENT entre les 2 colonnes */
.twocol-solution td.col-gauche{
  border-right:2px solid #999;
  padding-right:24px;
}
.twocol-solution td.col-droite{
  padding-left:24px;
}
.twocol-solution .line{
  margin:.3rem 0;
}
.twocol-solution .line mjx-container{
  padding-bottom:.08em;
}

/* mini tableau u / u' / g / g' en colonne gauche */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{
    padding:4px 40px 4px 0;
  }
}

@media print{ .controls{display:none !important;} }

</style>

<!-- ⭐ MATHJAX CONFIG CHTML (PAS SVG) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<!-- FIN MathJax -->
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1ère – Dérivation : Fonction composée</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d’exercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
    <button id="btn-check" class="btn">✅ Vérifier</button>
    <button id="btn-solution" class="btn">💡 Solution</button>
    <button id="btn-reset" class="btn">🧹 Réinitialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; réponses acceptées :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x²</code>…</li>
      <li>Racines : <code>sqrt(…)</code>, <code>rac(…)</code>, <code>√(…)</code>.</li>
      <li>Fractions : <code>a/b</code>. Multiplications implicites acceptées.</li>
    </ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- Dépendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ====== util DOM + score ====== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){
  const el=$("#score");
  if(el) el.textContent = scoreOK+" / "+scoreTot;
}
function scanFractions(root){
  try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){}
}

/* ====== random helpers ====== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

/* ===== normalisation / éval saisie ===== */
function normalizeRac(s){
  s = String(s||'');

  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  s = s.replace(/(\d|\))\s*√\s*\(/g, '$1*sqrt(');
  s = s.replace(/(\d|\))\s*√\s*x\b/gi, '$1*sqrt(x)');
  s = s.replace(/√\s*\(/g,   'sqrt(')
       .replace(/√\s*x\b/gi, 'sqrt(x)');

  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
  return s;
}
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  s = s.replace(/−/g,'-').replace(/[×·]/g,'*');
  s = normalizeRac(s);

  // puissances unicode -> ^ -> **
  const SUP = {'⁰':'0','¹':'1','²':'2','³':'3','⁴':'4','⁵':'5','⁶':'6','⁷':'7','⁸':'8','⁹':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([⁰¹²³⁴⁵⁶⁷⁸⁹]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }
}
function almost(a,b,eps=1e-8){
  return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b)));
}

/* ===== helpers d'affichage pour affines / polynômes courts ===== */
function affineLatex(A,B){
  const absA=Math.abs(A), absB=Math.abs(B);
  // terme en x
  let sA = (absA===1?'x':`${absA}x`);
  if(A<0) sA='-'+sA;
  // constante
  let sB='';
  if(B!==0){
    if(B>0) sB = ' + '+absB;
    else    sB = ' - '+absB;
  }
  return sA + sB;
}
function affineToJS(A,B){
  const absA=Math.abs(A);
  let tA = (absA===1?'x':`${absA}*x`);
  if(A<0) tA='-('+tA+')';
  let expr=tA;
  if(B!==0){
    if(B>0) expr += `+${B}`;
    else    expr += `${B}`;
  }
  return expr;
}
function affineDerivLatex(A){
  // u'(x)=A (constante)
  return String(A);
}

/* polynôme degré>=2 pour exo2 */
function randPoly(minDeg,maxDeg){
  const deg = rnd(minDeg,maxDeg);
  const coeffs=[];
  for(let i=0;i<=deg;i++){
    let c=rnd(-5,5);
    if(i===deg){
      while(c===0) c=rnd(-5,5); // coef dominant ≠0
    }
    coeffs.push(c);
  }
  return coeffs;
}
function polyToLatex(p){
  const terms=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    const absA=Math.abs(a);
    let seg='';
    if(i===0){
      seg = String(absA);
    }else if(i===1){
      seg = (absA===1)?'x':`${absA}x`;
    }else{
      seg = (absA===1)?`x^{${i}}`:`${absA}x^{${i}}`;
    }
    seg = (a<0?'-':'+' )+' '+seg;
    terms.push(seg);
  }
  if(!terms.length) return '0';
  return terms.join(' ').replace(/^\+\s*/,'').trim();
}
function polyToJS(p){
  const parts=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    let seg='';
    if(i===0){
      seg=String(Math.abs(a));
    }else if(i===1){
      seg=(Math.abs(a)===1)?'x':`${Math.abs(a)}*x`;
    }else{
      seg=(Math.abs(a)===1)?`x**${i}`:`${Math.abs(a)}*x**${i}`;
    }
    if(a<0) parts.push(`-(${seg})`);
    else parts.push(seg);
  }
  if(!parts.length) return '0';
  let expr=parts.join('+');
  expr=expr.replace(/\+\-\(/g,'-(');
  return expr;
}
function polyDeriv(p){
  if(p.length<=1) return [0];
  const d=[];
  for(let i=1;i<p.length;i++){
    d.push(p[i]*i);
  }
  return d;
}

/* petites fonctions utilitaires pour affichage propre */
function cleanSignsDisplay(str){
  // supprime "+ 0", "- 0" en fin, répare "+ -" -> "-" etc.
  if(!str) return str;
  let out = String(str);

  out = out.replace(/\+\s*-\s*/g,' - ');
  out = out.replace(/-\s*-\s*/g,' + ');
  out = out.replace(/\+\s*\+\s*/g,' + ');
  out = out.replace(/-\s*\+\s*/g,' - ');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/^\+\s*/,''); // retire + en tête
  out = out.replace(/(\+|−|-)\s*0($|[^0-9])/g, ' $2'); // virer "+ 0" isolés
  out = out.replace(/\s+/g,' ').trim();
  return out;
}

// essaie de simplifier le numérateur k * dU par 2
// renvoie une string LaTeX sans le /2 si possible, sinon ""
function buildAfterDivide2(k, dULatex, uLatex){
  // k : entier (coeff devant la racine, genre -2, 3, etc.)
  // dULatex : dérivée u'(x) déjà substituée (ex "10x-1" ou "(10x-1)" selon parenthèses)
  // uLatex : le u(x) explicite (ex "5x^2 - x + 3")
  //
  // On part de   (k * dU) / ( 2 sqrt(u) )
  // Si k est multiple de 2 -> (k/2 * dU) / sqrt(u)
  // Sinon pas de simplification => retourne "" (càd pas de ligne supplémentaire)

  if(k % 2 !== 0) return "";

  const half = k/2; // peut être négatif
  // Cas spécial : half = 1 ou -1 → on ne veut pas "1×"
  let numLatex;
  if(half === 1){
    numLatex = dULatex.replace(/^\((.*)\)$/,'$1'); // enlève parenthèses inutiles autour (10x-1)
  }else if(half === -1){
    // "-1 × (10x-1)" => "-(10x-1)"
    // si dULatex est déjà parenthésé "(10x-1)" : devient "-(10x-1)"
    // si pas parenthésé "10x-1" : devient "-(10x-1)" quand même pour bien montrer le bloc
    const core = dULatex.match(/^\((.*)\)$/) ? dULatex : `(${dULatex})`;
    numLatex = `-${core}`;
  }else{
    // général : "c × (10x-1)" (si dULatex pas déjà parenthésé ET contient un "+"/"-", on le parenthèse)
    let core = dULatex;
    if(!/^\(.*\)$/.test(core) && /[+\-]/.test(core)){
      core = `(${core})`;
    }
    numLatex = `${half} ${core}`;
  }

  return `\\dfrac{${numLatex}}{\\sqrt{${uLatex}}}`;
}


/* =========================================================
   EXERCICE 1
   u(x) affine ; g = puissance OU racine (avec coeff k devant possible)
   Deux méthodes dans la correction.
   ========================================================= */
function genEx1(mode){
  // détermine le type concret : "pow" ou "sqrt"
  let kind;
  if(mode === 'powAffine'){
    kind = 'pow';
  }else if(mode === 'sqrtAffine'){
    kind = 'sqrt';
  }else{
    // mix1 ou inconnu -> aléatoire
    kind = choice(["pow","sqrt"]);
  }




  // génère u(x)=ax+b avec a≠0
  const a = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);
  const b = rnd(-6,6);

  const uLatex = affineLatex(a,b);
  const uPrime = a; // constante
  const uJS = '('+affineToJS(a,b)+')';

  let title = "Exercice 1 : Dérivation d’une composée (avec u affine)";
  let enonce = "";
  let solHTML = "";
  let latexF = "";
  let fpJS;  // fonction JS de f'
  let fJS;   // fonction JS de f

  if(kind==="pow"){
    // puissance n, entre 2 et 7
    const n = rnd(2,7);

    latexF = `(${uLatex})^{${n}}`;

    // f(x) = (u(x))^n
    // f'(x) = n * (u(x))^{n-1} * u'(x)
    // pour la méthode 1 on veut la forme g(u(x)) avec g(x)=x^n
    // g'(x)= n x^{n-1}
    const gLatex   = `x^{${n}}`;
    const gPrime   = `${n}x^{${n-1}}`;

    // Substitution g'(u(x)) = n(u(x))^{n-1}
    // attention au signe de u'(x) dans le produit final :
    // On affiche (u'(x)) entre parenthèses si u'(x)<0.
    const uPrimeLatex = String(uPrime);
    const uPrimePar = (uPrime<0?`(${uPrimeLatex})`:uPrimeLatex);

   // Méthode 1 (chaîne g∘u)
const method1Lines = [
  `\\(f(x)=g(u(x))\\( \\) \\text{ avec } u(x)=${uLatex},\\ u'(x)=${uPrimeLatex},\\ g(x)=${gLatex},\\ g'(x)=${gPrime}\\)`,
  `\\(f'(x)=g'(u(x))\\times u'(x)\\)`,
  `\\(f'(x)= ${n}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}\\)`
];

// Méthode 2 (formule directe (u^n)' = n u^{n-1} u')
const method2Lines = [
  `\\(f(x)=(${uLatex})^{${n}}\\)`,
  `\\(f'(x)= ${n}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}\\)`
];

// résultat simplifié Latex final :
const finalLatex = `${n}\\,(${uLatex})^{${n-1}}\\times ${uPrimePar}`;

enonce =
  `Dériver la fonction suivante, sans se préoccuper des ensembles de définition/dérivabilité :<br><br>`+
  `\\[ f(x)=(${uLatex})^{${n}} \\]`;
// préparation avant le template HTML
// ---------------------------------

// version "propre" de g'(x) sans exposant 1
const gPrimeNice =
  (n === 2)
    ? `${n}x`
    : `${n}x^{${n-1}}`;

// g'(u(x)) déjà nettoyé plus haut :
const gPrimeComposeLatex =
  (n === 2)
    ? `${n}\\,u(x)`
    : `${n}\\,(u(x))^{${n-1}}`;

// f'(x)= ... sans puissance 1
const derivGeneric_uLatex =
  (n === 2)
    ? `${n}\\,u(x)u'(x)`
    : `${n}\\,(u(x))^{${n-1}}u'(x)`;

// version développée avec u(x)=... et u'(x)=...
const derivExpandedLatex =
  (n === 2)
    ? `${n}\\,(${uLatex}) \\times ${uPrimePar}`
    : `${n}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}`;

// Conclusion finale propre
const finalLatexClean =
  (n === 2)
    ? `${n}\\,(${uLatex}) \\times ${uPrimePar}`
    : `${n}\\,(${uLatex})^{${n-1}}\\times ${uPrimePar}`;


const uPrimeNum = uPrime; // uPrime était déjà le nombre dérivé de u(x) (ex: -3)

const coeffNum = n * uPrimeNum; // nombre pur
function coeffLatex(c){
  // si c = -1 ou 1 on garde le ±1 explicite, pas besoin de ruser,
  // parce que tu montres bien le coefficient numérique final tel quel.
  return `${c}`;
}

const derivFinalSimplifiedLatex =
  (n === 2)
    ? `${coeffLatex(coeffNum)}\\,(${uLatex})`
    : `${coeffLatex(coeffNum)}\\,(${uLatex})^{${n-1}}`;

// 7. C'est cette version qu'on veut afficher en DERNIÈRE ligne
//    dans chaque colonne, et dans "Conclusion :"
const finalLatexClean2 = derivFinalSimplifiedLatex;


solHTML = `
<div class="steps">
  <table class="twocol-solution">
    <tr>
      <td class="col-gauche">
        <div class="line"><strong>1<sup>re</sup> méthode :</strong></div>

        <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
        <table class="uvtab">
          <tr>
            <td>\\(u(x)=${uLatex}\\)</td>
            <td>\\(g(x)=${gLatex}\\)</td>
          </tr>
          <tr>
            <td>\\(u'(x)=${uPrimeLatex}\\)</td>
            <td>\\(g'(x)=${gPrimeNice}\\)</td>
          </tr>
          <tr>
            <td></td>
            <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
          </tr>
        </table>

        <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
        <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>

        <div class="line">\\(f'(x)= ${derivExpandedLatex}\\)</div>
				  <div class="line">\\(f'(x)= ${finalLatexClean2}\\)</div>

      </td>

      <td class="col-droite">
        <div class="line"><strong>2<sup>e</sup> méthode :</strong></div>
        <div class="line">\\(f(x)=(u(x))^{${n}}\\) \\( \\) avec :</div>
        <table class="uvtab">
          <tr>
            <td>\\(u(x)=${uLatex}\\)</td>
          </tr>
          <tr>
            <td>\\(u'(x)=${uPrimeLatex}\\)</td>
          </tr>
        </table>

        <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>

        <div class="line">\\(f'(x)= ${derivExpandedLatex}\\)</div>
		  <div class="line">\\(f'(x)= ${finalLatexClean2}\\)</div>
      </td>
    </tr>
  </table>


</div>`;




    // fonctions JS num pour check
    fJS = x => {
      const u = Function("x","return "+uJS+";")(x);
      return Math.pow(u,n);
    };
    fpJS = x => {
      const u  = Function("x","return "+uJS+";")(x);
      const du = uPrime;
      return n*Math.pow(u,n-1)*du;
    };

  } else { // kind==="sqrt"
    // k * sqrt(ax+b)
    // k non nul, éviter k=1 affiché comme "1√", on gère texte
    let k = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);
    // éviter k=1 affiché "1√", on ne l'affiche pas si 1 ; si -1 on affiche juste "−"
    const kAbs = Math.abs(k);
    let kPrefix;
    if(k===1){ kPrefix = ""; }
    else if(k===-1){ kPrefix = "−"; }
    else{
      kPrefix = (k<0? "−"+kAbs : String(kAbs));
    }

    latexF = `${kPrefix}\\sqrt{${uLatex}}`;

    // Ici f(x)=k√(u(x)).
    // Posons u(x)=ax+b.
    // g(t)=k√t → g'(t)=k * 1/(2√t).
    // Méthode 1 : g∘u.
    const gLatex   = `${kPrefix}\\sqrt{x}`.replace(/−-/g,'−'); // affichage g(x)
    // g'(x)=k/(2√x). Attention kPrefix pour la dérivée :
    // si k=−1 on veut - 1/(2√x) → "- \\dfrac{1}{2\\sqrt{x}}"
    let gPrimeLatex;
    if(k===1){
      gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
    }else if(k===-1){
      gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
    }else{
      gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
    }

    // substitution : g'(u(x)) = k/(2√(u(x)))
    // puis * u'(x)=a
    const uPrimeLatex = String(uPrime);
    // parenthèses autour de u'(x) si négatif pour la ligne produit
    const uPrimePar = (uPrime<0?`(${uPrimeLatex})`:uPrimeLatex);

    const uPrimePar2 = (uPrime<0?`${uPrimeLatex}`:uPrimeLatex);

    // Méthode 1 lignes
    // On va aussi simplifier comme dans ton screen :
    // f'(x)= k * u'(x) / (2√(u(x)))
    // puis réduire k*a /2 etc.
    // Calcul du numérateur final k*a
    const numFinal = k*uPrime;
    // Denom 2√(u(x))
    // Forme mise au propre : numFinal / (2√(u(x)))
    // ex : k=-2, a=5 → numFinal=-10 → f'(x)= -10/(2√(...)) = -5/√(...)
    // On va faire la simplification finale nous-mêmes pour l'affichage "Conclusion".
    const rawNum   = k*uPrime;
    const rawDen   = 2;
    // simplif fraction k*a /2
    function fracSimplif(n,d){
      // on essaie juste de /2 si possible
      if(n%d===0){ return [n/d,1]; }
      return [n,d];
    }
    const [simpNum, simpDen] = fracSimplif(rawNum,rawDen);

    let finalFracLatex;
    if(simpDen===1){
      // ex -5 / √(u)
      // si simpNum = ±1 on veut juste "-" devant ?
      if(simpNum===1){
        finalFracLatex = `\\dfrac{1}{\\sqrt{${uLatex}}}`;
      }else if(simpNum===-1){
        finalFracLatex = `-\\dfrac{1}{\\sqrt{${uLatex}}}`;
      }else{
        finalFracLatex = `\\dfrac{${simpNum}}{\\sqrt{${uLatex}}}`;
      }
    }else{
      // ex num/2√(u)
      // si rawNum = 1 → 1/(2√(...)), si -1 → -1/(2√(...)), sinon n/(2√(...))
      if(rawNum===1){
        finalFracLatex = `\\dfrac{1}{2\\sqrt{${uLatex}}}`;
      }else if(rawNum===-1){
        finalFracLatex = `-\\dfrac{1}{2\\sqrt{${uLatex}}}`;
      }else{
        finalFracLatex = `\\dfrac{${rawNum}}{2\\sqrt{${uLatex}}}`;
      }
    }
// On veut gérer proprement l'affichage quand k = 1 ou k = -1
// kPrefix = "" si k=1, "-" si k=-1, sinon "k"
// (tu l'as déjà dans ton code, je le réutilise tel quel)

// 1. g'(x) = k / (2√x)
//    -> si k = 1 on veut 1/(2√x) (ça va, pas de "1×" implicite)
//    -> si k = -1, on veut -1/(2√x) OK
//    pas besoin de changer g'(x) ici

// 2. g'(u(x)) = k / (2√(u(x)))
//    pareille logique, pas de "1×" ici donc c'est déjà bien

// 3. f'(x) = [k u'(x)] / [2√(u(x))]
//    si k = 1 -> u'(x) / (2√(u(x)))
//    si k = -1 -> -u'(x) / (2√(u(x)))
//    si k = autre -> (k u'(x)) / (...)
//
let fracGeneric_no1;
if (k === 1) {
  fracGeneric_no1 = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
} else if (k === -1) {
  // k=-1 : -u'(x)/(2√u(x))
  fracGeneric_no1 = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
} else {
  fracGeneric_no1 = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
}

// 4. version avec substitution u'(x)=uPrimePar et u(x)=uLatex
//    ex avant:  (k × uPrimePar)/(2√(uLatex))
//    si k = 1 -> (uPrimePar)/(2√(...))
//    si k = -1 -> (-uPrimePar)/(2√(...))
//    pas de "1 ×" ni "1 × (...)".
//    Pas de "k ×" quand k=1.
//
let fracExpanded_no1;
if (k === 1) {
  // juste uPrimePar au numérateur
  fracExpanded_no1 = `\\dfrac{${uPrimePar2}}{2\\sqrt{${uLatex}}}`;
} else if (k === -1) {
  // -uPrimePar
  fracExpanded_no1 = `\\dfrac{-\\,${uPrimePar}}{2\\sqrt{${uLatex}}}`;
} else {
  fracExpanded_no1 = `\\dfrac{${k}\\times ${uPrimePar}}{2\\sqrt{${uLatex}}}`;
}

// 5. Méthode 2 : première ligne "f(x)= k√{u(x)}"
//    si k = 1 -> "f(x)=√{u(x)}"
//    si k = -1 -> "f(x)= -\\sqrt{u(x)}"
//    sinon "f(x)= k\\sqrt{u(x)}"
let fxMethod2;
if (k === 1) {
  fxMethod2 = `f(x)=\\sqrt{u(x)}`;
} else if (k === -1) {
  fxMethod2 = `f(x)=-\\sqrt{u(x)}`;
} else {
  fxMethod2 = `f(x)=${k}\\sqrt{u(x)}`;
}

// 6. Dans la fraction finale que tu appelles finalFracLatex,
//    tu dois t'assurer qu'elle n'a pas "1×" dedans non plus.
//    On suppose que finalFracLatex c'est déjà la forme réduite genre "-2 / √(-4x-4)".
//    Si jamais tu la construis encore avec `k * uPrimePar`, pense à appliquer
//    la même logique que ci-dessus. Mais je la garde telle que tu la fournis.

const method1HTML = `

  <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>

  <table class="uvtab">
    <tr>
      <td>\\(u(x)=${uLatex}\\)</td>
      <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
    </tr>
    <tr>
      <td>\\(u'(x)=${uPrimeLatex}\\)</td>
      <td>\\(g'(x)=${gPrimeLatex}\\)</td>
    </tr>
    <tr>
      <td></td>
      <td>\\(g'(u(x))=\\dfrac{${k}}{2\\sqrt{u(x)}}\\)</td>
    </tr>
  </table>

  <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

  <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

  <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>

  <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
`;

// Méthode 2 : formule spécifique (k√u)' = k * u' / (2√u)
const method2HTML = `
  <div class="line">\\(${fxMethod2}\\) \\( \\) avec :</div>
  <table class="uvtab">
    <tr>
      <td>\\(u(x)=${uLatex}\\)</td>
    </tr>
    <tr>
      <td>\\(u'(x)=${uPrimeLatex}\\)</td>
    </tr>
  </table>

  <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

  <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>

  <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
`;

enonce =
  `Dériver la fonction suivante, sans se préoccuper des ensembles de définition/dérivabilité :<br><br>`+
  `\\[ f(x)= ${kPrefix}\\sqrt{${uLatex}} \\]`;

solHTML = `
<div class="steps">
  <table class="twocol-solution">
    <tr>
      <td class="col-gauche">
        <div class="line"><strong>1<sup>re</sup> méthode :</strong></div>
        ${method1HTML}
      </td>
      <td class="col-droite">
        <div class="line"><strong>2<sup>e</sup> méthode :</strong></div>
        ${method2HTML}
      </td>
    </tr>
  </table>
</div>`;


    // fonctions JS num pour check :
    fJS = x => {
      const u = Function("x","return "+uJS+";")(x);
      return k*Math.sqrt(u);
    };
    fpJS = x => {
      const u  = Function("x","return "+uJS+";")(x);
      const du = uPrime;
      // dérivée num : k * du / (2 sqrt(u))
      return k*du/(2*Math.sqrt(u));
    };
  }

  return {
    title,
    enonce,
    solHTML,
    latexF,
    fJS,
    fpJS,
    // pour PDF :
    latexFp_raw: '', // pas besoin ici mais on laisse pour compat
    latexFp: ''      // idem
  };
}

/* =========================================================
   EXERCICE 2
   u(x) NON affine (polynôme deg>=2 OU 1/x), g = puissance ou racine (avec coeff k)
   Même présentation 2 colonnes.
   ========================================================= */
function genEx2(mode){

  // ----- helpers locaux réutilisés -----
  const coeffTex = c => `${c}`; // tu l'avais prévu mais on garde la forme simple

  // fabrique A : (P(x))^n avec deg(P)≥2
  function make_powPoly(){
    const P   = randPoly(2,3);
    const dP  = polyDeriv(P);

    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    const n = rnd(2,7);

    const title = "Exercice 2 : Dérivation d’une composée (u non affine)";
    const latexF = `(${Platex})^{${n}}`;

    const enonce =
      `Dériver la fonction suivante, sans se préoccuper des ensembles de définition/dérivabilité :<br><br>`+
      `\\[ f(x)=(${Platex})^{${n}} \\]`;

    // g(x)=x^n
    const gPrimeNice =
      (n===2)
        ? `${n}x`
        : `${n}x^{${n-1}}`;

    const gPrimeComposeLatex =
      (n===2)
        ? `${n}\\,u(x)`
        : `${n}\\,(u(x))^{${n-1}}`;

    const derivGeneric_uLatex =
      (n===2)
        ? `${n}\\,u(x)u'(x)`
        : `${n}\\,(u(x))^{${n-1}}u'(x)`;

    const derivFinalSimplifiedLatex =
      (n===2)
        ? `${n}\\,(${Platex})  (${dPlatex})`
        : `${n}\\,(${Platex})^{${n-1}} (${dPlatex})`;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> méthode :</strong></div>

            <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=${Platex}\\)</td>
                <td>\\(g(x)=x^{${n}}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=${dPlatex}\\)</td>
                <td>\\(g'(x)=${gPrimeNice}\\)</td>
              </tr>
              <tr>
                <td></td>
                <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
              </tr>
            </table>

            <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> méthode :</strong></div>

            <div class="line">\\(f(x)=(u(x))^{${n}}\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr><td>\\(u(x)=${Platex}\\)</td></tr>
              <tr><td>\\(u'(x)=${dPlatex}\\)</td></tr>
            </table>

            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
          </td>

        </tr>
      </table>
    </div>`;

    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);

    const fJS  = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      return Math.pow(u,n);
    };
    const fpJS = x => {
      const u  = Function("x","return ("+Pjs+");")(x);
      const du = Function("x","return ("+dPjs+");")(x);
      return n*Math.pow(u,n-1)*du;
    };

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // fabrique B : k√(P(x)) avec deg(P)≥2
  function make_sqrtPoly(){
    const P   = randPoly(2,3);
    const dP  = polyDeriv(P);

    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    let k = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);

    const kAbs = Math.abs(k);
    let kPrefix;
    if(k===1){ kPrefix=""; }
    else if(k===-1){ kPrefix="−"; }
    else{ kPrefix=(k<0? "−"+kAbs : String(kAbs)); }

    const title = "Exercice 2 : Dérivation d’une composée (u non affine)";
    const latexF = `${kPrefix}\\sqrt{${Platex}}`;

    const enonce =
      `Dériver la fonction suivante, sans se préoccuper des ensembles de définition/dérivabilité :<br><br>`+
      `\\[ f(x)= ${kPrefix}\\sqrt{${Platex}} \\]`;

    // g'(x)=k/(2√x) sans "1×"
    let gPrimeLatex;
    if(k===1){
      gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
    }else if(k===-1){
      gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
    }else{
      gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
    }

    let gPrimeOfU;
    if(k===1){
      gPrimeOfU = `\\dfrac{1}{2\\sqrt{u(x)}}`;
    }else if(k===-1){
      gPrimeOfU = `-\\dfrac{1}{2\\sqrt{u(x)}}`;
    }else{
      gPrimeOfU = `\\dfrac{${k}}{2\\sqrt{u(x)}}`;
    }

    let derivGeneric_uLatex;
    if(k===1){
      derivGeneric_uLatex = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
    }else if(k===-1){
      derivGeneric_uLatex = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
    }else{
      derivGeneric_uLatex = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
    }

    let derivExpandedLatex;
    if(k===1){
      derivExpandedLatex = `\\dfrac{${dPlatex}}{2\\sqrt{${Platex}}}`;
    }else if(k===-1){
      derivExpandedLatex = `\\dfrac{-\\,(${dPlatex})}{2\\sqrt{${Platex}}}`;
    }else{
      derivExpandedLatex = `\\dfrac{${k}(${dPlatex})}{2\\sqrt{${Platex}}}`;
    }

    // ligne supplémentaire après division par 2 éventuelle
    let fracAfterDivide2 = "";
    if (k % 2 === 0){
      fracAfterDivide2 = buildAfterDivide2(
        k,
        dPlatex,
        Platex
      );
    }

    const derivFinalSimplifiedLatex = derivExpandedLatex;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> méthode :</strong></div>

            <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=${Platex}\\)</td>
                <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=${dPlatex}\\)</td>
                <td>\\(g'(x)=${gPrimeLatex}\\)</td>
              </tr>
              <tr>
                <td></td>
                <td>\\(g'(u(x))=${gPrimeOfU}\\)</td>
              </tr>
            </table>

            <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
            ${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> méthode :</strong></div>

            <div class="line">\\(f(x)=${kPrefix}\\sqrt{u(x)}\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr><td>\\(u(x)=${Platex}\\)</td></tr>
              <tr><td>\\(u'(x)=${dPlatex}\\)</td></tr>
            </table>

            <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
            <div class="line">\\(f'(x)=${derivFinalSimplifiedLatex}\\)</div>
            ${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }
          </td>

        </tr>
      </table>
    </div>`;

    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);

    const fJS  = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      return k*Math.sqrt(u);
    };
    const fpJS = x => {
      const u  = Function("x","return ("+Pjs+");")(x);
      const du = Function("x","return ("+dPjs+");")(x);
      return k*du/(2*Math.sqrt(u));
    };

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // fabrique C : (1/x)^n
  function make_powInv(){
    const n = rnd(2,6);

    const title = "Exercice 2 : Dérivation d’une composée (u non affine)";
    const latexF = `(\\dfrac{1}{x})^{${n}}`;

    const enonce =
      `Dériver la fonction suivante, sans se préoccuper des ensembles `+
      `de définition/dérivabilité :<br><br>`+
      `\\[ f(x)=\\left(\\dfrac{1}{x}\\right)^{${n}} \\]`;

    const gPrimeNice =
      (n === 2)
        ? `${n}x`
        : `${n}x^{${n-1}}`;

    const gPrimeComposeLatex =
      (n === 2)
        ? `${n}\\,u(x)`
        : `${n}\\,\\big(u(x)\\big)^{${n-1}}`;

    const derivGeneric_uLatex =
      (n === 2)
        ? `${n}\\,u(x)\\,u'(x)`
        : `${n}\\,\\big(u(x)\\big)^{${n-1}}\\,u'(x)`;

    const derivExpandedLatex =
      (n === 2)
        ? `${n}\\,\\left(\\dfrac{1}{x}\\right) \\times \\left(-\\dfrac{1}{x^{2}}\\right)`
        : `${n}\\,\\left(\\dfrac{1}{x}\\right)^{${n-1}} \\times \\left(-\\dfrac{1}{x^{2}}\\right)`;

    const finalFracLatex = `-\\dfrac{${n}}{x^{${n+1}}}`;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> méthode :</strong></div>

            <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=\\dfrac{1}{x}\\)</td>
                <td>\\(g(x)=x^{${n}}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td>
                <td>\\(g'(x)=${gPrimeNice}\\)</td>
              </tr>
              <tr>
                <td></td>
                <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
              </tr>
            </table>

            <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

            <div class="line">
              \\(f'(x)= ${derivGeneric_uLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${derivExpandedLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${finalFracLatex}\\)
            </div>
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> méthode :</strong></div>

            <div class="line">
              \\(f(x)=\\big(u(x)\\big)^{${n}}\\) \\( \\) avec :
            </div>
            <table class="uvtab">
              <tr><td>\\(u(x)=\\dfrac{1}{x}\\)</td></tr>
              <tr><td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td></tr>
            </table>

            <div class="line">
              \\(f'(x)= ${derivGeneric_uLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${derivExpandedLatex}\\)
            </div>

            <div class="line">
              \\(f'(x)= ${finalFracLatex}\\)
            </div>
          </td>

        </tr>
      </table>
    </div>`;

    const fJS  = x => Math.pow(1/x,n);
    const fpJS = x => -n*Math.pow(x,-(n+1));

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // fabrique D : k√(1/x)
  function make_sqrtInv(){
    let k = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);

    const title = "Exercice 2 : Dérivation d’une composée (u non affine)";

    const kAbs = Math.abs(k);
    let kPrefix;
    if (k === 1){
      kPrefix = "";
    } else if (k === -1){
      kPrefix = "−";
    } else {
      kPrefix = (k<0? "−"+kAbs : String(kAbs));
    }

    const latexF = `${kPrefix}\\sqrt{\\dfrac{1}{x}}`;

    const enonce =
      `Dériver la fonction suivante, sans se préoccuper des ensembles `+
      `de définition/dérivabilité :<br><br>`+
      `\\[ f(x)= ${kPrefix}\\sqrt{\\dfrac{1}{x}} \\]`;

    const uPrimeLatex = `-\\dfrac{1}{x^{2}}`;

    let gPrimeLatex;
    if (k === 1){
      gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
    } else if (k === -1){
      gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
    } else {
      gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
    }

    let gPrimeOfU;
    if (k === 1){
      gPrimeOfU = `\\dfrac{1}{2\\sqrt{u(x)}}`;
    } else if (k === -1){
      gPrimeOfU = `-\\dfrac{1}{2\\sqrt{u(x)}}`;
    } else {
      gPrimeOfU = `\\dfrac{${k}}{2\\sqrt{u(x)}}`;
    }

    let fracGeneric_no1;
    if (k === 1){
      fracGeneric_no1 = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
    } else if (k === -1){
      fracGeneric_no1 = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
    } else {
      fracGeneric_no1 = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
    }

    const uPrimeWithParIfK =
      (k === 1)
      ? `-\\dfrac{1}{x^{2}}`
      : `\\left(-\\dfrac{1}{x^{2}}\\right)`;

    let fracExpanded_no1;
    if (k === 1){
      fracExpanded_no1 = `\\dfrac{-\\dfrac{1}{x^{2}}}{2\\sqrt{\\dfrac{1}{x}}}`;
    } else if (k === -1){
      fracExpanded_no1 = `\\dfrac{\\dfrac{1}{x^{2}}}{2\\sqrt{\\dfrac{1}{x}}}`;
    } else {
      fracExpanded_no1 = `\\dfrac{${k}\\times ${uPrimeWithParIfK}}{2\\sqrt{\\dfrac{1}{x}}}`;
    }

    // coef final = -(k√x)/(2x²)
    const coef_brut = -k;
    let finalLatex = "";
    if (coef_brut % 2 === 0) {
      const half = coef_brut / 2;
      if (half === 1) {
        finalLatex = `\\dfrac{\\sqrt{x}}{x^{2}}`;
      } else if (half === -1) {
        finalLatex = `-\\dfrac{\\sqrt{x}}{x^{2}}`;
      } else if (half === 0) {
        finalLatex = `0`;
      } else if (half > 0) {
        finalLatex = `\\dfrac{${half}\\,\\sqrt{x}}{x^{2}}`;
      } else {
        const absHalf = Math.abs(half);
        finalLatex = `-\\dfrac{${absHalf}\\,\\sqrt{x}}{x^{2}}`;
      }
    } else {
      if (coef_brut === 1) {
        finalLatex = `\\dfrac{\\sqrt{x}}{2x^{2}}`;
      } else if (coef_brut === -1) {
        finalLatex = `-\\dfrac{\\sqrt{x}}{2x^{2}}`;
      } else if (coef_brut > 0) {
        finalLatex = `\\dfrac{${coef_brut}\\,\\sqrt{x}}{2x^{2}}`;
      } else {
        const absCoef = Math.abs(coef_brut);
        finalLatex = `-\\dfrac{${absCoef}\\,\\sqrt{x}}{2x^{2}}`;
      }
    }

    let fracAfterDivide2 = "";
    if (k % 2 === 0){
      fracAfterDivide2 = buildAfterDivide2(
        k,
        "-\\dfrac{1}{x^{2}}",
        "\\dfrac{1}{x}"
      );
    }

    const method1HTML = `
      <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr>
          <td>\\(u(x)=\\dfrac{1}{x}\\)</td>
          <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=${uPrimeLatex}\\)</td>
          <td>\\(g'(x)=${gPrimeLatex}\\)</td>
        </tr>
        <tr>
          <td></td>
          <td>\\(g'(u(x))=${gPrimeOfU}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

      <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

      <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>
      ${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }

      <div class="line">\\(f'(x)= ${finalLatex}\\)</div>
    `;

    let fxMethod2;
    if (k === 1){
      fxMethod2 = `f(x)=\\sqrt{u(x)}`;
    } else if (k === -1){
      fxMethod2 = `f(x)=-\\sqrt{u(x)}`;
    } else {
      fxMethod2 = `f(x)=${k}\\sqrt{u(x)}`;
    }

    const method2HTML = `
      <div class="line">\\(${fxMethod2}\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr><td>\\(u(x)=\\dfrac{1}{x}\\)</td></tr>
        <tr><td>\\(u'(x)=${uPrimeLatex}\\)</td></tr>
      </table>

      <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

      <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>
      ${ fracAfterDivide2 ? `<div class="line">\\(f'(x)= ${fracAfterDivide2}\\)</div>` : "" }

      <div class="line">\\(f'(x)= ${finalLatex}\\)</div>
    `;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>
          <td class="col-gauche">
            <div class="line"><strong>1<sup>re</sup> méthode :</strong></div>
            ${method1HTML}
          </td>

          <td class="col-droite">
            <div class="line"><strong>2<sup>e</sup> méthode :</strong></div>
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

    const fJS  = x => k * Math.sqrt(1/x);
    const fpJS = x => (-(k*Math.sqrt(x)) / (2*x*x));

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // ----- choix du scénario -----
  function pickScenario(){
    if(mode === 'powPoly')   return make_powPoly;
    if(mode === 'sqrtPoly')  return make_sqrtPoly;
    if(mode === 'powInv')    return make_powInv;
    if(mode === 'sqrtInv')   return make_sqrtInv;
    // mode === 'mix2' ou inconnu
    return choice([make_powPoly, make_sqrtPoly, make_powInv, make_sqrtInv]);
  }

  const scenario = pickScenario();
  return scenario();
}






/* =========================================================
   RENDU BLOC EXO + vérification
   ========================================================= */
function buildHostHTML(st, exoId){
  // exoId sera "exo1" ou "exo2"

  let selectorHTML = '';
  if(exoId === 'exo1'){
    selectorHTML = `
      <label style="font-weight:600;margin-right:.4rem;">Forme :</label>
      <select class="kind-select" style="padding:4px 6px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
        <option value="mix1">Mélange</option>
        <option value="powAffine">(ax+b)^n</option>
        <option value="sqrtAffine">k√(ax+b)</option>
      </select>
    `;
  } else if(exoId === 'exo2'){
    selectorHTML = `
      <label style="font-weight:600;margin-right:.4rem;">Forme :</label>
      <select class="kind-select" style="padding:4px 6px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
        <option value="mix2">Mélange</option>
        <option value="powPoly">(P(x))^n</option>
        <option value="sqrtPoly">k√(P(x))</option>
        <option value="powInv">(1/x)^n</option>
        <option value="sqrtInv">k√(1/x)</option>
      </select>
    `;
  }

  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>

      <div style="display:flex;flex-wrap:wrap;align-items:center;gap:.5rem .75rem;margin-bottom:.6rem;">
        ${selectorHTML}
      </div>

      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansF" class="inp" style="min-width:360px">
          <span id="tickF" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}


function setTick(ok){
  const el = $('#tickF');
  if(!el) return;
  el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
  el.textContent = ok===true?'✓': ok===false?'✗':'—';
}

function pickSafeXs(st){
  // On essaie de deviner le type d'exercice à partir de st.latexF
  // (on l'a déjà dans le state qu'on stocke pour le PDF)
  const F = st.latexF || "";

  // Cas racine simple k√(ax+b) ou k√( … )
  // → on veut des x pour lesquels l'intérieur de la racine est strictement > 0
  //   ET pas nul (car f' a √(u(x)) au dénominateur).
  //
  // On va essayer de détecter deux patterns faciles :
  //  - k√(ax+b)
  //  - k√(1/x)
  //
  // Sinon, fallback : on renvoie les x par défaut.

  // helper sécurisée : essaie d'évaluer ref fpJS(x), si c'est un nombre fini c'est bon
  function isSafeX(x){
    try{
      const v = st.fpJS(x);
      return Number.isFinite(v);
    }catch(e){
      return false;
    }
  }

  // on part d'une "pool" de candidats assez large
  // pour couvrir négatif/positif et éviter 0 trop souvent
  const pool = [
    -5,-3,-2,-1,-0.5,-0.2,
     0.1,0.2,0.5,1,1.2,1.8,2.5,3.7,4,4.5,5.1
  ];

  const xs=[];
  for(const x of pool){
    if(isSafeX(x)) xs.push(x);
    if(xs.length>=5) break; // on en garde ~5 max
  }

  // Si jamais on n'en a trouvé aucun (cas ultra tordu),
  // on renvoie quand même quelques valeurs "classiques"
  // pour éviter plantage.
  if(xs.length===0){
    return [1,2,3];
  }
  return xs;
}



function checkAnswer(st){
  const inp = $('#ansF');
  if(!inp){
    setTick(null);
    return {count:0,good:0};
  }

  const val = inp.value||'';
  if(!val.trim()){
    setTick(null);
    return {count:0,good:0};
  }

  // points de test sûrs pour CETTE fonction
  const xs = pickSafeXs(st);

  let ok = true;
  let compared = 0;

  for(const x of xs){
    const got = numEval(val,x);
    const ref = st.fpJS(x);

    // si l'un des deux est pas un nombre fini, on ignore ce x
    if(!Number.isFinite(got) || !Number.isFinite(ref)){
      continue;
    }

    compared++;

    if(!almost(got,ref,1e-6)){
      ok = false;
      break;
    }
  }

  // Si on n'a pas réussi à comparer au moins un x valable,
  // on NE met PAS faux automatiquement.
  if(compared===0){
    ok = true;
  }

  setTick(ok);
  return {count:1,good:(ok?1:0)};
}


/* =========================================================
   REGISTRY
   ========================================================= */
const EXO1 = {
  id:'exo1',
  title:'Exercice 1 — u affine',
 gen(host){
  // lire le mode actuel SI l'hôte appartient déjà à EXO1,
  // sinon retomber sur 'mix1'
  let mode = 'mix1';
  if(host && host.dataset && host.dataset.exoId === 'exo1'){
    const sel = host.querySelector('.kind-select');
    if(sel && sel.value){
      mode = sel.value;
    }
  }

  // si mode n'est pas une option valide pour EXO1, on remet 'mix1'
  if(mode!=='mix1' && mode!=='powAffine' && mode!=='sqrtAffine'){
    mode='mix1';
  }

  const st = genEx1(mode);

  if(host){
    host.innerHTML = buildHostHTML(st, 'exo1');
    host.__state   = st;
    host.dataset.state = JSON.stringify({
      title:st.title,
      enonce:st.enonce,
      latexF:st.latexF,
      latexFp:st.latexFp||'',
      latexFp_raw:st.latexFp_raw||'',
      solHTML:st.solHTML
    });
    host.dataset.exoId = 'exo1'; // <--- IMPORTANT, pour savoir qui était là avant

    const sel2 = host.querySelector('.kind-select');
    if(sel2){
      sel2.value = mode;
      sel2.addEventListener('change', ()=>{
        this.gen(host);
        if(window.MathJax?.typeset) MathJax.typeset();
        scanFractions(host);
      });
    }

    if(window.MathJax?.typeset) MathJax.typeset();
    scanFractions(host);
  }
  return st;
},

  correct(host,st){
    const r=checkAnswer(st);
    scoreTot+=r.count;
    scoreOK +=r.good;
    updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML=st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent='';
    setTick(null);
    const inp=$('#ansF',host);
    if(inp) inp.value='';
  }
};

const EXO2 = {
  id:'exo2',
  title:'Exercice 2 — u non affine',
  gen(host){
  let mode = 'mix2';
  if(host && host.dataset && host.dataset.exoId === 'exo2'){
    const sel = host.querySelector('.kind-select');
    if(sel && sel.value){
      mode = sel.value;
    }
  }

  // sécurité : clamp sur les valeurs autorisées pour exo2
  if(mode!=='mix2' && mode!=='powPoly' && mode!=='sqrtPoly' && mode!=='powInv' && mode!=='sqrtInv'){
    mode='mix2';
  }

  const st = genEx2(mode);

  if(host){
    host.innerHTML = buildHostHTML(st, 'exo2');
    host.__state   = st;
    host.dataset.state = JSON.stringify({
      title:st.title,
      enonce:st.enonce,
      latexF:st.latexF,
      latexFp:st.latexFp||'',
      latexFp_raw:st.latexFp_raw||'',
      solHTML:st.solHTML
    });
    host.dataset.exoId = 'exo2'; // marquer l'origine

    const sel2 = host.querySelector('.kind-select');
    if(sel2){
      sel2.value = mode;
      sel2.addEventListener('change', ()=>{
        this.gen(host);
        if(window.MathJax?.typeset) MathJax.typeset();
        scanFractions(host);
      });
    }

    if(window.MathJax?.typeset) MathJax.typeset();
    scanFractions(host);
  }
  return st;
},

  correct(host,st){
    const r=checkAnswer(st);
    scoreTot+=r.count;
    scoreOK +=r.good;
    updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML=st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent='';
    setTick(null);
    const inp=$('#ansF',host);
    if(inp) inp.value='';
  }
};


const REG=[EXO1,EXO2];
window.REG=REG;
window.REGISTRY=REG;

/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); 
  if(!sel) return;

  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host,host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host,host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}

document.addEventListener('DOMContentLoaded', mount);

/* =========================================================
   Adaptateur PDF : version iframe SVG
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try {
          st = JSON.parse(hostTmp.dataset.state || '{}');
        } catch(_){}
        return st;
      },




      // >>>>>>>>>>>>> async PROMISE RETURN
  beforeRender(def, st, withSolutions){
  return (async () => {
    let host = null;
    try {

      // 1. Construire un host OFFSCREEN juste pour récupérer l'état (mais SANS typeset écran)
      host = document.createElement('div');
      host.id = 'pdf-host';
      host.style.position='fixed';
      host.style.left='-10000px';
      host.style.top='-10000px';
      document.body.appendChild(host);

      // on DOIT recréer l'enoncé de base
      host.innerHTML = buildHostHTML(st);
      host.dataset.state = JSON.stringify(st);

      // 👉⚠ NE PAS appeler def.solution(host, st) ici,
      //    car ça MathJax-typeset en CHTML et flingue le LaTeX brut.

      // 2. Construire le HTML qu'on veut envoyer dans le PDF
      //    - si withSolutions === false : on prend juste l'énoncé tel quel
      //    - si withSolutions === true  : on fabrique nous-même un bloc
      //      qui contient st.solHTML (non encore typeset).
      let innerHTML_for_pdf;
if (withSolutions){
  innerHTML_for_pdf = `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>
      <div class="enonce">
        ${st.enonce}
        <div style="margin-top:1rem;font-weight:600">Corrigé :</div>
      </div>
      ${st.solHTML}
    </div>
  `;
} else {
  innerHTML_for_pdf = host.innerHTML;
}


      // 3. IFRAME sandbox pour MathJax SVG ...
      // (le reste de ton code continue comme avant)


      // 2. Créer l'iframe sandbox
      const iframe = document.createElement('iframe');
      iframe.style.position   = 'fixed';
      iframe.style.left       = '-10000px';
      iframe.style.top        = '-10000px';
      iframe.style.width      = '0';
      iframe.style.height     = '0';
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);

      const iwin = iframe.contentWindow;
      const idoc = iframe.contentDocument;

      // 3. Écrire un DOM minimal dans l'iframe
      // pas de <script> ici pour éviter de casser notre propre <script> parent
      idoc.open();
      idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
      idoc.close();
// 4. Injecter le contenu (énoncé/solution) dans l'iframe
const contentDiv = idoc.getElementById('content');
contentDiv.innerHTML = innerHTML_for_pdf;

// 🔧 IMPORTANT : on vire toute trace d'anciens rendus MathJax CHTML
// (dans le host original il y a déjà des <mjx-container jax="CHTML">...</mjx-container> )
// On veut repartir du LaTeX brut pour que MathJax SVG refasse tout proprement.

contentDiv.querySelectorAll('mjx-container').forEach(mjx => {
  // On essaie de récupérer le tex d'origine si MathJax l'a gardé en commentaire,
  // sinon on remplace par juste le texte rendu (fallback).
  // Mais dans notre cas, comme l'innerHTML_for_pdf vient AVANT typeset dans l'iframe,
  // il devrait déjà contenir le LaTeX source (\( ... \)). Donc en pratique,
  // ce bloc servira surtout si jamais un ancien mjx traine.
  mjx.replaceWith(mjx.textContent || '');
});

// Enlever aussi l'accessibilité MathML pré-existante (au cas où)
contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml')
  .forEach(n => n.remove());


      // 5. Préparer MathJax SVG dans l'iframe
      //    a) script config MathJax
      const cfg = idoc.createElement('script');
      cfg.type = 'text/javascript';
      cfg.text = `
        window.MathJax = {
          tex: {
            inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
            displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
            processEscapes: true,
            packages: { '[+]': ['bbox','ams'] }
          },
          svg: {
            fontCache: 'none'
          },
          options: {
            skipHtmlTags: ['script','noscript','style','textarea']
          },
          startup: { typeset: false }
        };
      `;
      idoc.head.appendChild(cfg);

      //    b) script tex-svg.js (URL absolue pour être sûr)
      const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
      const mj = idoc.createElement('script');
      mj.type = 'text/javascript';
      mj.src  = svgScriptURL;
      idoc.head.appendChild(mj);

// 6. Attendre que tex-svg.js soit chargé puis typer
await new Promise(resolve=>{
  mj.onload = resolve;
  mj.onerror = resolve; // on résout quand même même si ça plante
});

// sécurité: attendre que MathJax initialise typesetPromise
async function waitMathJaxReady(win){
  const limit = 200;
  let n = 0;
  while (
    (!win.MathJax) ||
    (!win.MathJax.typesetPromise && !win.MathJax.typeset)
  ){
    await new Promise(res=>setTimeout(res,5));
    n++;
    if(n>limit) break;
  }
}
await waitMathJaxReady(iwin);

// 7. Faire le typeset SVG dans l'iframe
if (iwin.MathJax && iwin.MathJax.typesetPromise){
  await iwin.MathJax.typesetPromise([ contentDiv ]);
} else if (iwin.MathJax && iwin.MathJax.typeset){
  iwin.MathJax.typeset([ contentDiv ]);
}

// 8. *** NETTOYAGE ANTI-DOUBLON ***
//    On enlève la version CHTML héritée de l'écran et on garde la version SVG.
(function purgeCHTML(){
  // 1. Supprimer les conteneurs CHTML de l'écran s'ils existent
  //    (dans ta page écran, MathJax CHTML génère <mjx-container jax="CHTML"> ...)
  contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n => n.remove());

  // 2. Certains contenus d'origine peuvent encore contenir du texte LaTeX brut
  //    suivi d'un conteneur SVG généré. Ex :
  //      "f'(x)=" <mjx-container jax="SVG">...</mjx-container>
  //    → ça va, on garde.

  // 3. Option belt & suspenders :
  //    Si jamais MathJax SVG a cloné au lieu de remplacer, on vire les doublons restants
  //    du type <mjx-container jax="CHTML"> même imbriqués.
  contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n => n.remove());

  // 4. On enlève les aides d’accessibilité inutiles pour le PDF
  contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n => n.remove());
})();

// 9. Récupérer le HTML final (ne contenant plus que le SVG)
const finalHTML = contentDiv.innerHTML;

// 10. Nettoyage DOM temporaire
iframe.remove();
if (host) host.remove();

// 11. Retourner le HTML prêt pour le PDF
return finalHTML;


    } catch(e){
      console.error('beforeRender SVG error:', e);

      let fallbackHTML = '';
      if (host) {
        fallbackHTML = withSolutions
          ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
          : host.innerHTML;
        host.remove();
        host = null;
      }
      return fallbackHTML;
    }
  })(); // IIFE async
}

    }); // <-- FERMETURE ExoPDF.init
  }); // <-- FERMETURE addEventListener DOMContentLoaded
})(); // <-- FERMETURE IIFE global

/* ===== tweaks mobile ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r=parseFloat(c.getAttribute('r')||'5');
      if(r<10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
},{passive:true});
</script>

</body>
</html>
