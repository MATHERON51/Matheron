<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1ère — Dérivation : Produit / Identités remarquables / Racine / Carré</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* tableau avec espace horizontal pour les étapes */
.table.xgap{
  border-collapse:separate;
  border-spacing:22px 0;
}
.table.xgap th,.table.xgap td{
  border:1px solid #e5e5e5;
  padding:10px 14px;
  white-space:nowrap;
}
@media print{ .table.xgap{ border-spacing:24px 0; } }

.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:center;
  gap:.4rem;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
}

@media print{ .controls{display:none !important;} }

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0; /* 👈 plus d'espace entre les deux colonnes */
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{
    padding:4px 40px 4px 0;
  }
}

.twocol-solution{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  width:auto;
}
.twocol-solution td{
  vertical-align:top;
  padding:0 16px;
  /* pas de bordure autour par défaut */
  border:none;
  white-space:nowrap;
  line-height:1.75;
  font-size:0.95rem;
}

/* on force UNIQUEMENT une barre verticale entre les 2 colonnes */
.twocol-solution td.col-gauche{
  border-right:2px solid #999; /* la barre visible */
  padding-right:24px;
}
.twocol-solution td.col-droite{
  padding-left:24px;
}

.twocol-solution .line{
  margin:.3rem 0;
}
.twocol-solution .line mjx-container{
  padding-bottom:.08em;
}

</style>

<!-- MathJax SVG -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true,
    packages: { '[+]': ['bbox','ams'] },
    macros: { frac: ['\\dfrac{#1}{#2}', 2] }
  },
  options: {
    skipHtmlTags: ['script','noscript','style','textarea'],
    renderActions: { assistiveMml: [] }
  },
  startup: { typeset:true }
};

</script>
<script defer src="../../../../es5/tex-svg.js"></script>

<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1ère – Dérivation : Produit / Identités remarquables / Racine carrée / Carré</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d’exercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
    <button id="btn-check" class="btn">✅ Vérifier</button>
    <button id="btn-solution" class="btn">💡 Solution</button>
    <button id="btn-reset" class="btn">🧹 Réinitialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; réponses acceptées :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x²</code>…</li>
      <li>Racines : <code>sqrt(…)</code>, <code>rac(…)</code>, <code>√(…)</code>.</li>
      <li>Fractions : <code>a/b</code>. Multiplications implicites acceptées.</li>
    </ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- Dépendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ===== Utils DOM / score ===== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

/* ====== random helpers ====== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

/* ===== normalisation / éval saisie ===== */
function normalizeRac(s){
  s = String(s||'');

  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  s = s.replace(/(\d|\))\s*√\s*\(/g, '$1*sqrt(');
  s = s.replace(/(\d|\))\s*√\s*x\b/gi, '$1*sqrt(x)');
  s = s.replace(/√\s*\(/g,   'sqrt(')
       .replace(/√\s*x\b/gi, 'sqrt(x)');

  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
  return s;
}
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  s = s.replace(/−/g,'-').replace(/[×·]/g,'*');
  s = normalizeRac(s);

  // puissances "²" -> "^2" -> "**2"
  const SUP = {'⁰':'0','¹':'1','²':'2','³':'3','⁴':'4','⁵':'5','⁶':'6','⁷':'7','⁸':'8','⁹':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([⁰¹²³⁴⁵⁶⁷⁸⁹]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }
}
function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }

/* ===== polynômes utilitaires ===== */
function randPoly(minDeg, maxDeg){
  const deg = rnd(minDeg,maxDeg);
  const coeffs = [];
  for(let i=0;i<=deg;i++){
    let c = rnd(-5,5);
    if(i===deg){ while(c===0) c=rnd(-5,5); }
    coeffs.push(c);
  }
  return coeffs;
}
function polyDeriv(p){
  if(p.length<=1) return [0];
  const d=[];
  for(let i=1;i<p.length;i++){
    d.push(p[i]*i);
  }
  return d;
}
function polyTimes(p,q){
  const r = Array(p.length+q.length-1).fill(0);
  for(let i=0;i<p.length;i++){
    for(let j=0;j<q.length;j++){
      r[i+j]+=p[i]*q[j];
    }
  }
  return r;
}
function polyToLatex(p){
  const terms=[];
  for(let i=p.length-1;i>=0;i--){
    const a = p[i];
    if(a===0) continue;
    const absA = Math.abs(a);
    let seg='';
    if(i===0){
      seg = String(absA);
    }else if(i===1){
      seg = (absA===1)?'x':`${absA}x`;
    }else{
      seg = (absA===1)?`x^{${i}}`:`${absA}x^{${i}}`;
    }
    seg = (a<0?'-':'+')+' '+seg;
    terms.push(seg);
  }
  if(!terms.length) return '0';
  return terms.join(' ').replace(/^\+\s*/,'').trim();
}
function polyToJS(p){
  const parts=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    let seg='';
    if(i===0){
      seg = String(Math.abs(a));
    }else if(i===1){
      seg = (Math.abs(a)===1)?'x':`${Math.abs(a)}*x`;
    }else{
      seg = (Math.abs(a)===1)?`x**${i}`:`${Math.abs(a)}*x**${i}`;
    }
    if(a<0) parts.push(`-(${seg})`);
    else parts.push(seg);
  }
  if(!parts.length) return '0';
  let expr = parts.join('+');
  expr = expr.replace(/\+\-\(/g,'-(');
  return expr;
}
function makePolyFuncJS(p){
  const fExpr = polyToJS(p);
  return x => Function("x","return ("+fExpr+");")(x);
}
function makePolyDerivFuncJS(p){
  const dp = polyDeriv(p);
  const dfExpr = polyToJS(dp);
  return x => Function("x","return ("+dfExpr+");")(x);
}

/* ===== helpers affines ===== */
function affineLatex(A,B){
  const absA=Math.abs(A), absB=Math.abs(B);
  let sA = (absA===1? 'x' : `${absA}x`);
  if(A<0) sA='-'+sA;
  let sB='';
  if(B!==0){
    if(B>0) sB = ' + '+absB;
    else    sB = ' - '+absB;
  }
  return sA + sB;
}
function affineDerivLatex(A){ return String(A); }
function affineToJS(A,B){
  const absA=Math.abs(A);
  let termA = (absA===1? 'x' : `${absA}*x`);
  if(A<0) termA='-('+termA+')';
  let expr = termA;
  if(B!==0){
    if(B>0) expr += `+${B}`;
    else    expr += `${B}`;
  }
  return expr;
}

/* ===== Helpers affichage signes (u', v' constants) ===== */
function isPureNumberLatex(x){
  if (typeof x === 'number') return Number.isFinite(x);
  // enlève \( \), () englobants et tous les espaces
  const s = String(x||'')
              .trim()
              .replace(/^\\\((.*)\\\)$/,'$1')
              .replace(/^\((.*)\)$/,'$1')
              .replace(/\s+/g,'');
  return /^[-+]?\d+$/.test(s);
}
function toNumber(x){
  return (typeof x === 'number')
    ? x
    : Number(String(x||'').replace(/\s+/g,'').trim());
}

/* f'(x) = A·(B) + C·(D)  ->  signe propre si A/C sont des nombres */
function sumOfTwoProducts(A, B_ltx, C, D_ltx){
  // terme 1 (en tête, sans "+ ")
  let t1;
  if (isPureNumberLatex(A)){
    const n = toNumber(A), abs = Math.abs(n);
    const coef = (abs===1 ? '' : String(abs));
    t1 = (n<0 ? '− ' : '') + (coef ? coef+'\\,' : '') + `(${B_ltx})`;
  }else{
    t1 = `(${A})(${B_ltx})`;
  }
  // terme 2 (préfixé d’un " + " ou " − ")
  let t2;
  if (isPureNumberLatex(C)){
    const n = toNumber(C), abs = Math.abs(n);
    const coef = (abs===1 ? '' : String(abs));
    const sign = (n<0 ? ' − ' : ' + ');
    t2 = sign + (coef ? coef+'\\,' : '') + `(${D_ltx})`;
  }else{
    t2 = ' + ' + `(${C})(${D_ltx})`;
  }
  return t1 + t2;
}
/* Produit simple où le facteur de gauche est un nombre : "(a)(u)" -> "a(u)" */
function productNumTimes(B_ltx, A){
  if (isPureNumberLatex(A)){
    const n = toNumber(A), abs = Math.abs(n);
    const coef = (abs===1 ? '' : String(abs));
    const sign = (n<0 ? '− ' : '');
    return `${sign}${coef}${coef?'\\,':''}(${B_ltx})`;
  }
  return `(${A})(${B_ltx})`;
}

function cleanSigns(s){
  if(!s) return s;

  // on bosse sur une copie
  let out = String(s);

  // normaliser les espaces multiples autour des signes pour éviter des trucs bizarres après remplacements
  out = out.replace(/\s+/g,' ').trim();

  // séquences "+ -"  -> " - "
  out = out.replace(/\+\s*-\s*/g,' - ');

  // séquences "- -" -> " + "
  out = out.replace(/-\s*-\s*/g,' + ');

  // séquences "+ +" -> " + "
  out = out.replace(/\+\s*\+\s*/g,' + ');

  // séquences "- +" -> " - "
  out = out.replace(/-\s*\+\s*/g,' - ');

  // encore un petit coup pour réduire les espaces multiples
  out = out.replace(/\s+/g,' ').trim();

  // si ça commence par "+ " on vire le "+"
  out = out.replace(/^\+\s*/,'');

  return out;
}
function polyToMonomeList(p){
  const monos=[];
  for(let deg=p.length-1;deg>=0;deg--){
    const c = p[deg];
    if(c===0) continue;
    const absC = Math.abs(c);
    let mCore;
    if(deg===0){
      mCore = String(absC);
    }else if(deg===1){
      mCore = (absC===1) ? 'x' : `${absC}x`;
    }else{
      mCore = (absC===1) ? `x^{${deg}}` : `${absC}x^{${deg}}`;
    }
    const signed = (c<0?'- ':'+ ') + mCore;
    monos.push(signed.trim()); // ex "- 3x^2", "+ 2"
  }
  if(!monos.length){
    monos.push('0');
  }
  // petit nettoyage pour que le premier ne commence pas par "+"
  if(monos.length>0 && monos[0].startsWith('+ ')){
    monos[0] = monos[0].replace(/^\+\s*/,'');
  }
  return monos;
}

function distributiveSymbolicTerms(Pu, Pv){
  // Pu, Pv sont tableaux coeffs (u' ou v, etc.)
  // On génère la liste des " (monomePu)(monomePv) "
  const monsU = polyToMonomeList(Pu); // ex ["-5", "+2x"]
  const monsV = polyToMonomeList(Pv); // ex ["3x^2", "-4x", "+7"]
  const pieces=[];
  for(const mu of monsU){
    for(const mv of monsV){
      pieces.push(`(${mu})(${mv})`);
    }
  }
  // on joint avec " + " puis on nettoie avec cleanSigns pour éviter "+ (-...)" etc.
  let raw = pieces.join(' + ');
  raw = cleanSigns(raw);
  return raw;
}


// extrait les monômes d'un polynôme comme objets {coeff, deg}
// ET conserve l'ordre "deg décroissant" (comme polyToMonomeList)
function polyToMonomeData(p){
  const list=[];
  for(let deg=p.length-1; deg>=0; deg--){
    const c = p[deg];
    if(c === 0) continue;
    list.push({ coeff: c, deg });
  }
  if (!list.length){
    list.push({ coeff: 0, deg: 0 });
  }
  return list;
}

// même ordre que distributiveSymbolicTerms :
// pour chaque monôme de Pu (u'(x)), puis chaque monôme de Pv (v(x))
// on écrit directement le produit numérique (plus de parenthèses).
function distributiveNumericTerms(Pu, Pv){
  const U = polyToMonomeData(Pu); // [{coeff,deg}, ...] ordre deg max -> deg min
  const V = polyToMonomeData(Pv);

  const chunks = [];

  for (const mu of U){
    for (const mv of V){
      // produit des coeffs
      const c = mu.coeff * mv.coeff;
      const degTot = mu.deg + mv.deg;

      // construire le monôme numérique c * x^{degTot}
      const absC = Math.abs(c);
      let core;
      if(degTot === 0){
        core = String(absC);
      } else if (degTot === 1){
        core = (absC === 1) ? 'x' : `${absC}x`;
      } else {
        core = (absC === 1) ? `x^{${degTot}}` : `${absC}x^{${degTot}}`;
      }

      let txt;
      if (c < 0){
        txt = `- ${core}`;
      }else{
        txt = `+ ${core}`;
      }

      chunks.push(txt.trim());
    }
  }

  // Joindre tous les blocs dans l'ordre de distribution
  let out = chunks.join(' ');
  // nettoyer les "+ -" etc et virer un éventuel "+" de début
  out = cleanSigns(out);
  return out;
}


function fullDistributiveSymbolic(uPrime,u,vPrime,v){
  // uPrime, u, vPrime, v sont tableaux coeffs
  // 1) u'(x)v(x) en premier
  // 2) puis v'(x)u(x)
  const part1 = distributiveSymbolicTerms(uPrime, v);
  const part2 = distributiveSymbolicTerms(vPrime, u);
  let all = part1 + ' + ' + part2;
  all = cleanSigns(all);
  return all;
}
function fullDistributiveNumeric(uPrime, v, vPrime, u){
  const part1 = distributiveNumericTerms(uPrime, v); // u' * v
  const part2 = distributiveNumericTerms(vPrime, u); // v' * u
  let all = part1 + ' + ' + part2;
  all = cleanSigns(all);
  return all;
}



// renvoie le développement (LaTeX) du produit A(x)*B(x)
// A et B sont tableaux de coeffs croissants [c0,c1,c2,...]
// et aussi la dérivée regroupée à la fin tu l'as déjà (polyDeriv(polyTimes(A,B)))
function expandPolyProductLatex(P, Q){
  // on veut une chaîne du style "(a x^2 + ...)(b x^3+ ...)"
  // puis " = " + somme des termes issus de la distributivité non encore réduits,
  // puis "= ... ordonné".
  //
  // Ex: u'(x)v(x) = (-5)(2x^3 - 4x^2 - 4x + 3)
  //   -> = (-5)*2x^3 + (-5)*(-4x^2) + ...
  //
  // Ici on va retourner une fonction qui,
  // quand on lui donne les deux polynômes en LaTeX sous forme déjà jolie,
  // produit juste la "somme terme à terme" (sans regroupement).
  //
  // Pour faire simple : on va générer tous les produits coeff_u * monome_v
  // en LaTeX déjà signé.

  function monomeLatex(coeff, degree){
    if(coeff === 0) return null;
    const absC = Math.abs(coeff);

    // construit le bloc "3x^2" / "x" / "5"
    let core;
    if(degree===0){
      core = String(absC);
    } else if(degree===1){
      core = (absC===1) ? 'x' : `${absC}x`;
    } else {
      core = (absC===1) ? `x^{${degree}}` : `${absC}x^{${degree}}`;
    }

    // signe
    if(coeff<0) return `- ${core}`;
    return `+ ${core}`;
  }

  // Décompose P et Q en monomes LaTeX individuels pour pouvoir former u'v et v'u
  function polyMonomes(p){
    const out=[];
    for(let i=p.length-1;i>=0;i--){
      const c=p[i];
      if(c===0) continue;
      const absC = Math.abs(c);
      let mono;
      if(i===0){
        mono = String(absC);
      }else if(i===1){
        mono = (absC===1)?'x':`${absC}x`;
      }else{
        mono = (absC===1)?`x^{${i}}`:`${absC}x^{${i}}`;
      }
      mono = (c<0?'- ':'+ ')+mono;
      out.push(mono);
    }
    if(!out.length) out.push('+ 0');
    // reorder so that biggest degree first is already what we did
    // join without leading "+"
    return out.join(' ').replace(/^\+\s*/,'').trim();
  }

  // On va donner aussi les "termes bruts" sans combinaison :
  // si P = [p0,p1,...] et Q=[q0,q1,...], alors pour chaque i,j :
  //   terme = p_i * q_j * x^{i+j}
  // On les retourne sous forme "+ 6x^4" etc., les uns à la suite.
function rawDistributedTerms(p,q){
  const terms=[];
  for(let i=0;i<p.length;i++){
    for(let j=0;j<q.length;j++){
      const c = p[i]*q[j];
      if(c===0) continue;
      const deg = i+j;

      const absC = Math.abs(c);
      let core;
      if(deg===0){
        core = String(absC);
      }else if(deg===1){
        core = (absC===1)?'x':`${absC}x`;
      }else{
        core = (absC===1)?`x^{${deg}}`:`${absC}x^{${deg}}`;
      }
      const tex = (c<0?'- ':'+ ')+core;
      terms.push({deg, tex});
    }
  }
  if(!terms.length){
    terms.push({deg:0, tex:'+ 0'});
  }
  let joined = terms.map(t=>t.tex).join(' ').replace(/^\+\s*/,'').trim();
  joined = cleanSigns(joined);
  return joined;
}

function orderedSumLatex(p,q){
  // Regroupe par degré pour donner le polynôme final ordonné
  const maxDeg = (p.length-1)+(q.length-1);
  const coeffs = Array(maxDeg+1).fill(0);
  for(let i=0;i<p.length;i++){
    for(let j=0;j<q.length;j++){
      coeffs[i+j]+=p[i]*q[j];
    }
  }
  let poly = polyToLatex(coeffs);
  poly = cleanSigns(poly);
  return poly;
}


  return {
    polyMonomes,          // renvoie "2x^3 - 4x^2 - 4x + 3"
    rawDistributedTerms,  // renvoie " -10x^3 +20x^2 +20x -15 ..."
    orderedSumLatex       // renvoie le polynôme simplifié " -10x^3 +20x^2 +20x -15"
  };
}
function randPolyExact(deg){
  // coeffs[0] = c0, coeffs[1] = c1, ..., coeffs[deg] = c_deg
  const coeffs = [];
  for (let i = 0; i <= deg; i++){
    let c = rnd(-5,5);
    // le coefficient dominant doit être ≠ 0
    if (i === deg){
      while(c === 0){
        c = rnd(-5,5);
      }
    }
    coeffs.push(c);
  }
  return coeffs;
}

/* =========================================================
   EXERCICE 1 : Produit de deux polynômes
   Deux méthodes dans la solution
   ========================================================= */
function genEx1(){

  // 1. On choisit une paire de degrés autorisée
  //    1 = affine (ax + b)
  //    2 = quadratique
  //    3 = cubique
  const allowedPairs = [
    [1,2],
    [1,3],
    [2,2],
    [2,3],
  ];
  const chosenPair = choice(allowedPairs); // ex: [1,3] ou [2,2] ...
  const degU = chosenPair[0];
  const degV = chosenPair[1];

  // 2. On génère u et v avec ces degrés exacts
  const P = randPolyExact(degU);
  const Q = randPolyExact(degV);

  // le reste de ta fonction continue comme avant ↓
  const dP = polyDeriv(P);
  const dQ = polyDeriv(Q);
  const PQ = polyTimes(P,Q);
  const dPQ = polyDeriv(PQ);

  const latexP   = polyToLatex(P);
  const latexQ   = polyToLatex(Q);
  const latexdP  = polyToLatex(dP);
  const latexdQ  = polyToLatex(dQ);
  const latexPQ  = polyToLatex(PQ);
  const latexdPQ = polyToLatex(dPQ);

  // pour l'élève à afficher
  const title = "Exercice 1 : Produit de deux polynômes";
  const enonce = `Dériver, en utilisant la formule du produit, la fonction définie sur \\(\\mathbb{R}\\) par : <br><br>\\[ f(x)=(${latexP})(${latexQ}) \\]<br><br>`;

  // tableaus coeffs déjà là : P, Q, dP, dQ
  // On veut :
  // - substitution propre (subLine) -> déjà tu faisais sumOfTwoProducts(...)
  // - une ligne "développement symbolique"
  // - une ligne "développement numérique"
  // - une ligne finale ordonnée

  const subLine = cleanSigns(
    sumOfTwoProducts(latexdP, latexQ, latexdQ, latexP)
  );

  // distributivité brute dans l'ordre :
  // u'(x)v(x) puis v'(x)u(x)
  const symbolicDevLine = fullDistributiveSymbolic(dP, P, dQ, Q);
  const numericDevLine  = fullDistributiveNumeric(dP, Q, dQ, P);

  const finalClean = cleanSigns(latexdPQ); // dérivée finale ordonnée


   const solHTML = `
  <div class="steps">
    <div class="stepTitle">Formule du produit</div>

    <div class="line">On a \\( \\) \\(f(x)=u(x)v(x)\\) \\( \\) avec :</div>
    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${latexP}\\)</td>
        <td>\\(v(x)=${latexQ}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${latexdP}\\)</td>
        <td>\\(v'(x)=${latexdQ}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x)=u'(x)v(x)+v'(x)u(x)\\).</div>
    <div class="line">\\(f'(x)= ${subLine}\\).</div>
    <div class="line">\\(f'(x)= ${numericDevLine}\\).</div>
    <div class="line">\\(f'(x)= ${finalClean}\\).</div>
    <div class="line"></div>
	
    <div class="line"><br>Remarque : On aurait pu développer \\( \\) \\(f(x)\\) \\( \\) puis dériver le polynôme obtenu.</div>
	

  </div>`;






  const fJS  = x => makePolyFuncJS(P)(x)*makePolyFuncJS(Q)(x);
  const fpJS = x=>{
    const u = makePolyFuncJS(P)(x);
    const v = makePolyFuncJS(Q)(x);
    const du= makePolyDerivFuncJS(P)(x);
    const dv= makePolyDerivFuncJS(Q)(x);
    return du*v + u*dv;
  };

  return {
    latexF: `(${latexP})(${latexQ})`,
    latexFp: latexdPQ,
    latexFp_raw: `(${latexdP})(${latexQ}) + (${latexP})(${latexdQ})`,
    title,
    enonce,
    solHTML,
    fJS,
    fpJS
  };
}

/* =========================================================
   EXERCICE 2 : Identité remarquable avec affine
   Deux méthodes : produit / identité remarquable
   (peut être (ax+b)^2, (ax+b)(ax-b), ou (ax+b)(cx+d))
   ========================================================= */
function genEx2(){
  const pattern = choice(["square","diffsquare","prod"]);
  const a = nzChoose([-4,-3,-2,-1,1,2,3,4]);
  const b = rnd(-5,5);
  const c = nzChoose([-4,-3,-2,-1,1,2,3,4]);
  const d = rnd(-5,5);

  // --- petits helpers locaux de genEx2 ---

  function affineLatex(A,B){
    const absA=Math.abs(A), absB=Math.abs(B);
    let sA = (absA===1? 'x' : `${absA}x`);
    if(A<0) sA='-'+sA;
    let sB='';
    if(B!==0){
      if(B>0) sB = ' + '+absB;
      else    sB = ' - '+absB;
    }
    return sA + sB;
  }
  function affineToJS(A,B){
    const absA=Math.abs(A);
    let termA = (absA===1? 'x' : `${absA}*x`);
    if(A<0) termA='-('+termA+')';
    let expr = termA;
    if(B!==0){
      if(B>0) expr += `+${B}`;
      else    expr += `${B}`;
    }
    return expr;
  }
  function polyAff2Latex(A2,Xc,C0){
    const terms=[];
    if(A2!==0){
      const absA2=Math.abs(A2);
      terms.push((A2<0?'-':'+' )+' '+ (absA2===1?'x^{2}':`${absA2}x^{2}`));
    }
    if(Xc!==0){
      const absX=Math.abs(Xc);
      terms.push((Xc<0?'-':'+' )+' '+ (absX===1?'x':`${absX}x`));
    }
    if(C0!==0){
      terms.push((C0<0?'-':'+' )+' '+Math.abs(C0));
    }
    if(!terms.length) return '0';
    return terms.join(' ').replace(/^\+\s*/,'').trim();
  }

  // renvoie la liste des monômes d’un polynôme p (tableau coeffs croissants),
  // ordre du plus grand degré vers le plus petit, sous forme {coeff,deg}
  function polyToMonomeDataLocal(p){
    const list=[];
    for(let deg=p.length-1; deg>=0; deg--){
      const c = p[deg];
      if(c === 0) continue;
      list.push({ coeff: c, deg });
    }
    if (!list.length){
      list.push({ coeff: 0, deg: 0 });
    }
    return list;
  }

  // construit la ligne "développement dans l'ordre" pour (u^2)' = 2u'u :
  // On veut : 2a(ax+b)  →  "2a·ax + 2a·b"
  // puis la version simplifiée numérique finale : "2a²x + 2ab"
  function squareDevLines(a,b){
    // facteur global = 2a
    const K = 2*a;

    // u(x)=ax+b  ==> coeffs [b,a]
    const uCoeffs=[b,a];
    const monos = polyToMonomeDataLocal(uCoeffs); // [{coeff,deg}, ...] (d'abord ax puis b)

    // ligne développement "K·(chaque monôme)"
    // ex: "2a·ax + 2a·b"
    const devPieces=[];
    for(const {coeff,deg} of monos){
      // monôme "coeff x^deg"
      const absCoeff=Math.abs(coeff);
      let monoCore;
      if(deg===0){
        monoCore = String(absCoeff);
      }else if(deg===1){
        monoCore = (absCoeff===1?'x':`${absCoeff}x`);
      }else{
        monoCore = (absCoeff===1?`x^{${deg}}`:`${absCoeff}x^{${deg}}`);
      }
      // remettre le signe du coeff
      const monoSigned = (coeff<0?'- ':'') + monoCore;

      // bloc "K·(monôme)"
      // on écrit K de façon lisible : "2a" pas "2*a"
      // K = 2a peut être négatif aussi
      const absK = Math.abs(K);
      let Ktex = (absK===1?''+'' : String(absK)); // "2" ou "6"...
      // si a est négatif ça se voit déjà dans K donc signe du bloc vient du signe global du produit
      // produit K * coeff  pour voir le signe global du terme ? -> non ! ici on n'est PAS encore en mode simplification,
      // tu veux juste montrer "2a·ax", pas directement  "6x" etc.
      // donc on garde "2a·(monôme)" mais attention au signe du monôme.
      // pour être simple côté rendu élève, on ne factorise pas le signe à l'intérieur du "·":
      // on va écrire: "2${a}·(${monoSignedSansSigne})" → c'est un peu moche si coeff<0.
      // Pour garder un rendu propre proche de ce que tu montres déjà dans ex1 (ligne numericDevLine),
      // on va plutôt directement multiplier les coefficients ici.
      //
      // => Conclusion : pas besoin de cette fonction compliquée
      // On va faire comme ex1 : on renvoie DIRECTEMENT la version numérique (=coeff multipliés),
      // et la "devPieces" sera en fait le même format que ta ligne numericDevLine.
      //
      // donc je stop ici et je passe à la vraie stratégie ci-dessous.
    }
  }
  // remarque importante:
  // dans ton ex1, tu n’affiches PAS une ligne "2a·ax + 2a·b" symbolique.
  // Tu vas direct à la ligne avec les produits numériques (numericDevLine).
  // Donc pour le carré on va faire pareil : pas de ligne symbolique séparée, on ira direct au numérique.

  // fabrique la ligne "numérique dans l'ordre" pour le carré :
  // K = 2a ; u(x)=ax+b.
  // On écrit les termes K*a x^1 puis K*b, dans cet ordre.
  function numericLineSquare(a,b){
    const K = 2*a; // 2a
    const terms=[];

    // premier monôme : a x
    // coeff = K * a
    const c1 = K * a;
    const abs1=Math.abs(c1);
    let mono1 = (abs1===1?'x':`${abs1}x`);
    terms.push( (c1<0?'- ':'+ ') + mono1 );

    // deuxième monôme : b
    const c2 = K * b;
    if(c2!==0){
      terms.push( (c2<0?'- ':'+ ') + Math.abs(c2) );
    }

    let out = terms.join(' ').replace(/^\+\s*/,'').trim();
    out = cleanSigns(out);
    return out;
  }

  // fabrique la dernière ligne rangée pour le carré :
  // résultat final = 2a^2 x + 2ab
  function finalLineSquare(a,b){
    const A2 = a*a;
    const termX = 2*A2;     // 2a^2
    const termC = 2*a*b;    // 2ab
    let finalLatex='';

    if(termX!==0){
      const absTX=Math.abs(termX);
      finalLatex += (termX<0?'− ':'') + (absTX===1?'x':`${absTX}x`);
    }
    if(termC!==0){
      finalLatex += (termC<0?' − ':' + ') + Math.abs(termC);
    }
    if(finalLatex==='') finalLatex='0';

    return cleanSigns(finalLatex);
  }
  
   // ======================================================
  // CAS 1 : f(x) = (ax+b)²
  // Formule spéciale : (u²)' = 2u'u
  // ======================================================
  if(pattern==="square"){
    const uLatex = affineLatex(a,b);
    const uPrimeLatex = String(a);
	
	
	  // affichage de a entre parenthèses s'il est négatif
  const aTex = (a < 0 ? `(${a})` : `${a}`);
  // coef K = 2a
  const K = 2*a;
    // lignes solution :
    // 1) formule
    // 2) substitution directe 2 u'(x) u(x)
    // 3) développement numérique dans l'ordre
    // 4) forme rangée finale
  const lineSub = `2 \\times ${aTex} \\times (${uLatex})`;


     // ligne "on regroupe 2×a" : K(ax+b)
  // ex : 8(4x-1)
  // Attention au signe de K.
  // Si K = -6 et u(x)= -3x+5, on veut "-6(-3x+5)" et pas "+ -6(...)".
  const Kabs = Math.abs(K);
  const Ktex = (K<0 ? `- ${Kabs}` : `${Kabs}`);
  const lineFactor = `${Ktex}(${uLatex})`;

  // ligne développée numérique dans l'ordre des termes de u(x)
  // u(x)=ax+b -> d'abord terme en x, puis constante
  // K*a est le coeff devant x
  // K*b est la constante
  const Ka = K * a; // coeff du x
  const Kb = K * b; // constante
  const absKa = Math.abs(Ka);
  let monoX = (absKa===1 ? 'x' : `${absKa}x`);
  let pieces = [];
  pieces.push( (Ka<0?'- ':'+ ') + monoX );
  if(Kb !== 0){
    pieces.push( (Kb<0?'- ':'+ ') + Math.abs(Kb) );
  }
  let lineExpand = pieces.join(' ').replace(/^\+\s*/,'').trim();
  lineExpand = cleanSigns(lineExpand); // ex "32x-8" propre

  // JS pour vérifier numériquement la dérivée
  const uJS = '('+affineToJS(a,b)+')';
  const fJS  = x => {
    const u = Function("x","return "+uJS+";")(x);
    return u*u;
  };
  const fpJS = x => {
    const u = Function("x","return "+uJS+";")(x);
    const du = a;
    return 2*u*du;
  };

    const title = "Exercice 2 : Identité remarquable";
    const enonce =
      `Dériver de deux façons différentes la fonction définie sur \\(\\mathbb{R}\\) par :<br><br>`+
      `\\[ f(x)=(${uLatex})^{2} \\]<br><br>`+
      `1) En utilisant la formule du produit.<br>`+
      `2) En utilisant l'identité remarquable puis en dérivant le polynôme développé.`;

     // développement (ax+b)^2 = a^2 x^2 + 2ab x + b^2
    const A=a, B=b;
    const A2 = A*A;
    const twoAB = 2*A*B;
    const B2 = B*B;

    let fxLatexParts=[];
    if(A2!==0){
      fxLatexParts.push( (A2===1?'x^{2}': (A2===-1?'-x^{2}':`${A2}x^{2}`)) );
    }
    if(twoAB!==0){
      const abs2AB=Math.abs(twoAB);
      fxLatexParts.push( (twoAB<0?'- ':'+ ') + (abs2AB===1?'x':`${abs2AB}x`) );
    }
    if(B2!==0){
      fxLatexParts.push( (B2<0?'- ':'+ ') + Math.abs(B2) );
    }
    if(!fxLatexParts.length) fxLatexParts=['0'];
    const fxLatex = fxLatexParts.join(' ').replace(/^\+\s*/,'').trim();

    // dérivée du développé :
    const part1 = 2*A2; // coef devant x
    const part2 = twoAB; // constante
    let dfxLatex = '';
    if(part1!==0){
      const absp1=Math.abs(part1);
      dfxLatex += (part1<0?'-':'')+(absp1===1?'x':`${absp1}x`);
    }
    if(part2!==0){
      dfxLatex += (part2<0?' - ':' + ') + Math.abs(part2);
    }
    if(dfxLatex==='') dfxLatex='0';

     // ⬇⬇⬇ NOUVELLE PRÉSENTATION : TABLEAU 2 COLONNES ⬇⬇⬇
  const solHTML = `
    <div class="steps">

    <table class="twocol-solution">
      <tr>
        <td class="col-gauche">
          <div class="line"><strong>Méthode 1 — Formule du produit</strong></div>

    <div class="line">On a \\( \\) \\(f(x)=u^2(x)\\).</div>
          <div class="line">\\(u(x)=${uLatex}\\)</div>
          <div class="line">\\(u'(x)=${uPrimeLatex}\\)</div>

          <div class="line">\\(f'(x)=2u'(x)u(x).\\)</div>
          <div class="line">\\(f'(x)= ${lineSub}\\).</div>
          <div class="line">\\(f'(x)= ${lineFactor}\\).</div>
          <div class="line">\\(f'(x)= ${lineExpand}\\).</div>
        </td>

        <td class="col-droite">
          <div class="line"><strong>Méthode 2 — Identité remarquable</strong></div>
	    <div class="line">On développe \\( \\) \\(f(x)\\) \\( \\) en utilisant les identités remarquables :</div>

          <div class="line">\\(f(x)=(${uLatex})^{2}\\).</div>
          <div class="line">\\(f(x)=${fxLatex}\\).</div>

          <div class="line"><br>En dérivant ce polynôme :</div>
          <div class="line">\\(f'(x)=${dfxLatex}\\).</div>
        </td>
      </tr>
    </table>

    <div class="line" style="margin-top:.6rem"><strong>Conclusion :</strong> \\(f'(x)=${dfxLatex}\\).</div></div>
  `;

  const latexF      = `(${uLatex})^{2}`;
  const latexFp_raw = lineSub;     // forme "2 × a × (ax+b)"
  const latexFp     = lineExpand;  // forme finale "32x-8"

  return {
    title,
    enonce,
    latexF,
    latexFp,
    latexFp_raw,
    solHTML,
    fJS,
    fpJS
  };
}


  // ======================
  // CAS 2 : (ax+b)(ax-b) = (ax)^2 - b^2
  // ======================
  if(pattern==="diffsquare"){
    const uLatex = affineLatex(a,b);      // ax+b
    const vLatex = affineLatex(a,-b);     // ax-b

 const uCoeffs = [b,a];
    const vCoeffs = [-b,a];
    const uPrimeCoeffs = [a];
    const vPrimeCoeffs = [a];

    const subLine = cleanSigns(
      sumOfTwoProducts(a, vLatex, a, uLatex)
    );

    // dév numérique dans l’ordre : u'(x)v(x) puis v'(x)u(x)
// u(x) = ax+b -> uCoeffs
// v(x) = ax-b -> vCoeffs
// u'(x) = a   -> uPrimeCoeffs
// v'(x) = a   -> vPrimeCoeffs

const partUV  = distributiveNumericTerms(uPrimeCoeffs, vCoeffs); // u' * v
const partVU  = distributiveNumericTerms(vPrimeCoeffs, uCoeffs); // v' * u

const numericDevLine = cleanSigns(partUV + ' + ' + partVU);


    // forme finale rangée :
    // (ax+b)(ax-b) = a²x² - b²
    // dérivée = 2a²x
    const A=a, B=b;
    const finalCoef = 2*(A*A); // 2a²
    let finalLatex='';
    if(finalCoef===0){
      finalLatex='0';
    }else{
      const absF=Math.abs(finalCoef);
      finalLatex = (finalCoef<0?'− ':'') + (absF===1?'x':`${absF}x`);
    }
    finalLatex = cleanSigns(finalLatex);

    // JS pour vérif
    const uJS = '('+affineToJS(a,b)+')';
    const vJS = '('+affineToJS(a,-b)+')';
    const fJS = x=>{
      const u = Function("x","return "+uJS+";")(x);
      const v = Function("x","return "+vJS+";")(x);
      return u*v;
    };
    const fpJS= x=>{
      const u = Function("x","return "+uJS+";")(x);
      const v = Function("x","return "+vJS+";")(x);
      const du=a, dv=a;
      return du*v + u*dv;
    };

    // développement via (A+B)(A-B)=A^2-B^2
    const A2=A*A;
    const B2=B*B;
    // f(x) = a^2 x^2 - b^2
    let fxLatex = (A2===1?'x^{2}': (A2===-1?'-x^{2}':`${A2}x^{2}`));
    if(B2!==0){
      fxLatex += (B2>0?' - ':' + ') + Math.abs(B2);
    }

    // dérivée : d/dx (a^2 x^2 - b^2) = 2 a^2 x
    const dfxCoef = 2*A2;
    let dfxLatex='';
    if(dfxCoef===0){ dfxLatex='0'; }
    else{
      const absd=Math.abs(dfxCoef);
      dfxLatex = (dfxCoef<0?'-':'') + (absd===1?'x':`${absd}x`);
    }

    const title = "Exercice 2 : Double distributivité et identités remarquables";
    const enonce =
      `Dériver de deux façons différentes la fonction définie sur \\(\\mathbb{R}\\) par :<br><br>`+
      `\\[ f(x)=(${uLatex})(${vLatex}) \\]<br><br>`+
      `1) En utilisant la formule du produit.<br>`+
      `2) En utilisant l'identité remarquable pour développer puis dériver.`;

const solHTML = `
  <div class="steps">
      <table class="twocol-solution">
      <tr>
        <td class="col-gauche">
    <div class="stepTitle">Méthode 1 — Formule du produit</div>
    <div class="line">On a \\( \\) \\(f(x)=u(x)v(x)\\) \\( \\) avec :</div>

    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
        <td>\\(v(x)=${vLatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${a}\\)</td>
        <td>\\(v'(x)=${a}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x) = u'(x)v(x) + v'(x)u(x)\\).</div>
      <div class="line">\\(f'(x)= ${subLine}\\).</div>

      <div class="line">\\(f'(x)= ${numericDevLine}\\).</div>

      <div class="line">\\(f'(x)= ${finalLatex}\\).</div>
 </td>

        <td class="col-droite">
    <div class="stepTitle">Méthode 2 — Identité remarquable</div>
	
		    <div class="line">On développe \\( \\) \\(f(x)\\) \\( \\) en utilisant les identités remarquables :</div>
    <div class="line">\\(f(x)=(${uLatex})(${vLatex})\\).</div>
          <div class="line">\\(f(x)=${fxLatex}\\).</div>
          <div class="line"><br>En dérivant ce polynôme :</div>
          <div class="line">\\(f'(x)=${dfxLatex}\\).</div>
	
        </td>
      </tr>
    </table>
    <div class="stepTitle">Conclusion</div>
    <div class="line"><strong>\\(f'(x)=${dfxLatex}\\)</strong></div>
  </div>`;


     const latexF      = `(${uLatex})(${vLatex})`;
    const latexFp_raw = subLine;
    const latexFp     = finalLatex;

    return {
      title,
      enonce,
      latexF,
      latexFp,
      latexFp_raw,
      solHTML,
      fJS,
      fpJS
    };
  }

  // ======================
  // CAS 3 : (ax+b)(cx+d) classique
  // ======================
  
{
  const uLatex = affineLatex(a,b);
  const vLatex = affineLatex(c,d);

  const uCoeffs = [b,a]; // b + a x
  const vCoeffs = [d,c]; // d + c x
  const uPrimeCoeffs = [a];
  const vPrimeCoeffs = [c];

  const subLine = cleanSigns(
    sumOfTwoProducts(a, vLatex, c, uLatex)
  );

  // ✅ version corrigée de fullDistributiveNumeric (u'v puis v'u)
  const numericDevLine  = fullDistributiveNumeric(
    uPrimeCoeffs, vCoeffs,
    vPrimeCoeffs, uCoeffs
  );

  // Coeffs utiles
  const A=a, B=b, C=c, D=d;

  // Pour la méthode 1 (finalLatex = dérivée simplifiée) :
  const A2 = A*C;               // ac
  const Xcoef = A*D + B*C;      // ad+bc
  const Cst = B*D;              // bd

  const finalCoefX = 2*A2;      // 2ac
  const finalConst = Xcoef;     // ad+bc

  let finalLatex='';
  if(finalCoefX!==0){
    const absFX=Math.abs(finalCoefX);
    finalLatex += (finalCoefX<0?'− ':'') + (absFX===1?'x':`${absFX}x`);
  }
  if(finalConst!==0){
    finalLatex += (finalConst<0?' − ':' + ') + Math.abs(finalConst);
  }
  if(finalLatex==='') finalLatex='0';
  finalLatex = cleanSigns(finalLatex);

  // JS vérif
  const uJS = '('+affineToJS(a,b)+')';
  const vJS = '('+affineToJS(c,d)+')';
  const fJS = x=>{
    const u = Function("x","return "+uJS+";")(x);
    const v = Function("x","return "+vJS+";")(x);
    return u*v;
  };
  const fpJS= x=>{
    const u = Function("x","return "+uJS+";")(x);
    const v = Function("x","return "+vJS+";")(x);
    const du=a, dv=c;
    return du*v + u*dv;
  };

  // -------- Méthode 2 : toutes les étapes --------

  // Étape brute de la double distributivité :
  // (ax+b)(cx+d) = (ax)(cx) + (ax)(d) + (b)(cx) + (b)(d)
  // ce qui donne : ac x^2 + ad x + bc x + bd
  //
  // On veut garder CHAQUE terme séparé, même si certains coeff = ±1 ou 0.
  // Règles :
  // - ne jamais écrire "1x", on écrit juste "x".
  // - ne pas afficher les termes nuls.
  // - nettoyer les "+ -" / "- -" à la fin avec cleanSigns.
  //
  // Construisons chaque bloc :

  function termToLatex(coef, power, prefixPlus){
    // coef numérique, power entier >=0
    // prefixPlus = true -> on met le signe (+ / -) devant
    if(coef === 0) return '';

    const absC = Math.abs(coef);

    // construire la partie x^power sans le signe
    let core;
    if(power === 0){
      core = String(absC);
    }else if(power === 1){
      core = (absC===1 ? 'x' : `${absC}x`);
    }else{
      core = (absC===1 ? `x^{${power}}` : `${absC}x^{${power}}`);
    }

    // appliquer signe / plus
    if(prefixPlus){
      return (coef < 0 ? ' - ' : ' + ') + core;
    }else{
      return (coef < 0 ? '- ' : '') + core;
    }
  }

  // ac x^2
  const t1 = termToLatex(A*C, 2, false); // premier terme : pas de " + " devant

  // ad x
  const t2 = termToLatex(A*D, 1, true);  // suivants : signe explicite

  // bc x
  const t3 = termToLatex(B*C, 1, true);

  // bd
  const t4 = termToLatex(B*D, 0, true);

  let fxDevRawLine = (t1 + t2 + t3 + t4).trim();
  fxDevRawLine = fxDevRawLine.replace(/^\+\s*/,'');
  fxDevRawLine = cleanSigns(fxDevRawLine);
  // exemple attendu : "4x^{2} + 8x − 6x − 12"
  // (puis l'élève pourra regrouper adx+bcx → (ad+bc)x)

  // Étape suivante : on regroupe les deux termes en x :
  // ac x^2 + (ad+bc)x + bd
  // (c'est ce que tu appelais fxDevLine précédemment)
  //
  // On la re-génère proprement :
  let fxDevParts = [];

  // terme x^2 : A2 x^2
  if (A2 !== 0){
    const absA2 = Math.abs(A2);
    const monoX2 = (absA2===1 ? 'x^{2}' : `${absA2}x^{2}`);
    fxDevParts.push( (A2<0?'- ':'+ ') + monoX2 );
  }

  // terme x : (ad+bc) x  => Xcoef
  if (Xcoef !== 0){
    const absXc = Math.abs(Xcoef);
    const monoX1 = (absXc===1 ? 'x' : `${absXc}x`);
    fxDevParts.push( (Xcoef<0?'- ':'+ ') + monoX1 );
  }

  // constante bd : Cst
  if (Cst !== 0){
    fxDevParts.push( (Cst<0?'- ':'+ ') + Math.abs(Cst) );
  }

  if (!fxDevParts.length){
    fxDevParts = ['0'];
  }

  let fxDevLine = fxDevParts.join(' ');
  fxDevLine = fxDevLine.replace(/^\+\s*/,'');
  fxDevLine = cleanSigns(fxDevLine);

  // fxLatex = polynôme rangé tel que tu l'affiches (polyAff2Latex)
  const fxLatex = polyAff2Latex(A2, Xcoef, Cst);

  // dérivée du polynôme rangé :
  const dfx_xcoef = 2*A2; // 2ac
  const dfx_const = Xcoef; // ad+bc
  let dfxLatex="";
  if(dfx_xcoef!==0){
    const absdx=Math.abs(dfx_xcoef);
    dfxLatex += (dfx_xcoef<0?'-':'') + (absdx===1?'x':`${absdx}x`);
  }
  if(dfx_const!==0){
    dfxLatex += (dfx_const<0?' - ':' + ') + Math.abs(dfx_const);
  }
  if(dfxLatex==="") dfxLatex="0";

    const title = "Exercice 2 : Identité remarquable";
    const enonce =
      `Dériver de deux façons différentes la fonction définie sur \\(\\mathbb{R}\\) par :<br><br>`+
      `\\[ f(x)=(${uLatex})(${vLatex}) \\]<br><br>`+
      `1) En utilisant la formule du produit.<br>`+
      `2) En développant puis en dérivant le polynôme obtenu.`;

const solHTML = `
  <div class="steps">
        <table class="twocol-solution">
      <tr>
        <td class="col-gauche">
    <div class="stepTitle">Méthode 1 — Formule du produit</div>
    <div class="line">On a \\( \\) \\(f(x)=u(x)v(x)\\) \\( \\) avec :</div>

    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
        <td>\\(v(x)=${vLatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${a}\\)</td>
        <td>\\(v'(x)=${c}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x) = u'(x)v(x) + v'(x)u(x)\\).</div>
      <div class="line">\\(f'(x)= ${subLine}\\).</div>

      <div class="line">\\(f'(x)= ${numericDevLine}\\).</div>

      <div class="line">\\(f'(x)= ${finalLatex}\\).</div>
 </td>

        <td class="col-droite">
    <div class="stepTitle">Méthode 2 — Développer puis dériver</div>
			    <div class="line">On développe \\( \\) \\(f(x)\\) \\( \\) :</div>

	            <div class="line">\\(f(x)=(${uLatex})(${vLatex})\\).</div>
            <div class="line">\\(f(x)= ${fxDevRawLine}\\).</div>

    <div class="line">\\(f(x)=${fxLatex}\\).</div>
	          <div class="line"><br>En dérivant ce polynôme :</div>

    <div class="line">\\(f'(x)=${dfxLatex}\\).</div>
        </td>
      </tr>
    </table>
    <div class="stepTitle">Conclusion</div>
    <div class="line"><strong>\\(f'(x)=${dfxLatex}\\)</strong></div>
  </div>`;


 const latexF      = `(${uLatex})(${vLatex})`;
    const latexFp_raw = subLine;
    const latexFp     = finalLatex;

    return {
      title,
      enonce,
      latexF,
      latexFp,
      latexFp_raw,
      solHTML,
      fJS,
      fpJS
    };
  }
}


/* =========================================================
   EXERCICE 3 : Produit poly × fonction racine
   Une seule méthode : formule du produit
   ========================================================= */
function genEx3(){
  const P = randPoly(1,3);
  const dP = polyDeriv(P);

  const alpha = nzChoose([-3,-2,-1,1,2,3]);
  const pattern = choice(["sqrt","sqrt-x","sqrt+x"]);

  const Platex  = polyToLatex(P);
  const dPlatex = polyToLatex(dP);

  let Vlatex, VprimeLatex, Vjs, dVjs;
  if(pattern==="sqrt"){
    Vlatex="\\sqrt{x}";
    VprimeLatex="\\dfrac{1}{2\\sqrt{x}}";
    Vjs="Math.sqrt(x)";
    dVjs="(1/(2*Math.sqrt(x)))";
  }else if(pattern==="sqrt-x"){
    Vlatex = `\\sqrt{x} ${alpha>0?'-':'+'} ${Math.abs(alpha)}x`;
    VprimeLatex = `\\dfrac{1}{2\\sqrt{x}} ${alpha>0?'-':'+'} ${Math.abs(alpha)}`;
    Vjs = `(Math.sqrt(x) - (${alpha})*x)`;
    dVjs= `((1/(2*Math.sqrt(x))) - (${alpha}))`;
  }else{
    Vlatex = `\\sqrt{x} ${alpha>0?'+':'-'} ${Math.abs(alpha)}x`;
    VprimeLatex = `\\dfrac{1}{2\\sqrt{x}} ${alpha>0?'+':'-'} ${Math.abs(alpha)}`;
    Vjs = `(Math.sqrt(x) + (${alpha})*x)`;
    dVjs= `((1/(2*Math.sqrt(x))) + (${alpha}))`;
  }

  const title="Exercice 3 : Produit d'un polynôme et d'une racine carrée";
  const enonce=`On considère la fonction définie (sur son ensemble de définition) par :<br><br>\\[ f(x)=(${Platex})\\,(${Vlatex}) \\]<br><br>On utilisera uniquement la formule du produit \\((uv)'=u'v+uv'\\).`;

const solHTML=`
  <div class="steps">
    <div class="stepTitle">Formule du produit</div>
    <div class="line">On a \\( \\) \\(f(x)=u(x)v(x)\\) \\( \\) avec :</div>

    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${Platex}\\)</td>
        <td>\\(v(x)=${Vlatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${dPlatex}\\)</td>
        <td>\\(v'(x)=${VprimeLatex}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x) = u'(x)v(x) + v'(x)u(x)\\).</div>

    <div class="line">\\(f'(x)=(${dPlatex})(${Vlatex})+\\left(${VprimeLatex}\\right)(${Platex})\\)</div>
  </div>`;


  const latexF = `(${Platex})(${Vlatex})`;
  const latexFp_raw = `(${dPlatex})(${Vlatex}) + (${Platex})\\left(${VprimeLatex}\\right)`;
  const latexFp = latexFp_raw; // pas vraiment de simplif symbolique ici

  const fJS = x => Function("x","return (("+polyToJS(P)+")*("+Vjs+"));")(x);
  const fpJS= x => {
    const u  = Function("x","return ("+polyToJS(P)+");")(x);
    const du = Function("x","return ("+polyToJS(dP)+");")(x);
    const v  = Function("x","return ("+Vjs+");")(x);
    const dv = Function("x","return ("+dVjs+");")(x);
    return du*v + u*dv;
  };

  return {
    title,
    enonce,
    latexF,
    latexFp,
    latexFp_raw,
    solHTML,
    fJS,
    fpJS
  };
}

/* =========================================================
   EXERCICE 4 : Carré d'une fonction
   u(x)^2 avec u polynôme degré>=3 OU mix sqrt(x)+...+...
   Méthode : (u^2)' = 2u u'
   ========================================================= */
function genEx4(){
  const type = choice(["poly2","sqrtmix2"]);

  let title="Exercice 4 : Carré d'une fonction";
  let enonce, solHTML;
  let latexF, latexFp, latexFp_raw;
  let fJS, fpJS;

  if(type==="poly2"){
    const P = randPoly(3,4);
    const dP= polyDeriv(P);

    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    latexF = `(${Platex})^{2}`;
    latexFp_raw = `2\\,(${Platex})\\cdot (${dPlatex})`;
    latexFp     = latexFp_raw;

    enonce=`On considère la fonction \\(f\\) définie sur \\(\\mathbb{R}\\) par :<br><br>\\[ f(x)=(${Platex})^{2} \\]<br><br>Déterminer \\(f'(x)\\).`;

solHTML=`
  <div class="steps">
    <div class="stepTitle">Formule du produit</div>
    <div class="line">On a \\( \\) \\(f(x)=u^2(x)\\) \\( \\) avec :</div>

    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${Platex}\\)</td>
      </tr>
	     <tr>
        <td>\\(u'(x)=${dPlatex}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x)=2\\,u'(x)\\,u(x)\\).</div>
<div class="line">\\(f'(x)=2\\,${productNumTimes(Platex, dPlatex)}\\).</div>


  </div>`;

    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);
    fJS  = x => { const u=Function("x","return ("+Pjs+");")(x); return u*u; };
    fpJS = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      const du= Function("x","return ("+dPjs+");")(x);
      return 2*u*du;
    };

  } else {
    const A = nzChoose([-4,-3,-2,-1,1,2,3,4]);
    const B = nzChoose([-4,-3,-2,-1,1,2,3,4]);
    const C = rnd(-5,5);

    // u(x) = A√x + Bx + C
    let uPieces=[];
    if(A!==0){
      const absA=Math.abs(A);
      if(absA===1) uPieces.push( (A<0?'-':'')+"\\sqrt{x}" );
      else uPieces.push( (A<0?'-':'')+absA+"\\sqrt{x}" );
    }
    if(B!==0){
      const absB=Math.abs(B);
      uPieces.push( (B<0?'- ':'+ ')+ (absB===1?'x':`${absB}x`) );
    }
    if(C!==0){
      uPieces.push( (C<0?'- ':'+ ')+Math.abs(C) );
    }
    if(!uPieces.length) uPieces=['0'];
    let uLatex = uPieces.join(' ').replace(/^\+\s*/,'').trim();

    // u'(x) = A/(2√x) + B
    let uprimeParts=[];
    if(A!==0){
      uprimeParts.push(`\\dfrac{${A}}{2\\sqrt{x}}`);
    }
    if(B!==0){
      uprimeParts.push((B<0?'- ':'+ ')+Math.abs(B));
    }
    let uPrimeLatex = uprimeParts.join(' ').replace(/^\+\s*/,'').trim();
    if(!uPrimeLatex) uPrimeLatex='0';

    latexF     = `(${uLatex})^{2}`;
    latexFp_raw= `2\\,(${uLatex})\\cdot \\left(${uPrimeLatex}\\right)`;
    latexFp    = latexFp_raw;

    enonce=`On considère la fonction \\(f\\) définie (sur son ensemble de définition) par :<br><br>\\[ f(x)=(${uLatex})^{2} \\]<br><br>Déterminer \\(f'(x)\\).`;

solHTML=`
  <div class="steps">
    <div class="stepTitle">Formule du produit</div>
    <div class="line">On a \\( \\) \\(f(x)=u^2(x)\\) \\( \\) avec :</div>

    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
      </tr>
	     <tr>
        <td>\\(u'(x)=${uPrimeLatex}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x)=2\\,u'(x)\\,u(x)\\).</div>
	    <div class="line">\\(f'(x)=2\\,\\left(${uPrimeLatex}\\right)(${uLatex}) \\).</div>

  </div>`;


    const uJS = (()=>{
      const parts=[];
      if(A!==0) parts.push(`(${A})*Math.sqrt(x)`);
      if(B!==0) parts.push(`(${B})*x`);
      if(C!==0) parts.push(`(${C})`);
      if(!parts.length) parts.push('0');
      return '('+parts.join('+')+')';
    })();
    const duJS = (()=>{
      const parts=[];
      if(A!==0) parts.push(`(${A})/(2*Math.sqrt(x))`);
      if(B!==0) parts.push(`(${B})`);
      if(!parts.length) parts.push('0');
      return '('+parts.join('+')+')';
    })();

    fJS  = x => Function("x","return ("+uJS+"*"+uJS+");")(x);
    fpJS = x => {
      const u  = Function("x","return "+uJS+";")(x);
      const du = Function("x","return "+duJS+";")(x);
      return 2*u*du;
    };
  }

  return {
    title,
    enonce,
    latexF,
    latexFp,
    latexFp_raw,
    solHTML,
    fJS,
    fpJS
  };
}

/* =========================================================
   RENDU DANS LE HOST
   ========================================================= */

function buildHostHTML(st){
  // bloc unique
  // une seule réponse attendue
  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>
      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansF" class="inp" style="min-width:360px">
          <span id="tickF" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}

function setTick(ok){
  const el = $('#tickF');
  if(!el) return;
  el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
  el.textContent = ok===true?'✓': ok===false?'✗':'—';
}

function checkAnswer(st){
  const inp = $('#ansF');
  if(!inp) { setTick(null); return {count:0,good:0}; }
  const val = inp.value||'';
  if(!val.trim()){
    setTick(null);
    return {count:0,good:0};
  }

  // test numérique
  const xs=[1.2,1.8,2.5,3.7,5.1];
  let ok=true;
  for(const x of xs){
    const got=numEval(val,x);
    const ref=st.fpJS(x);
    if(!Number.isFinite(got)||!Number.isFinite(ref)||!almost(got,ref,1e-6)){
      ok=false;break;
    }
  }
  setTick(ok);
  return {count:1, good:(ok?1:0)};
}

/* =========================================================
   REGISTRY des 4 exercices comme d’habitude
   ========================================================= */

const EXO1 = {
  id:'exo1',
  title:'Exercice 1 — Produit de deux polynômes',
  gen(host){
    const st = genEx1();

    // si on a un host réel (mode normal écran)
    if (host) {
      host.innerHTML = buildHostHTML(st);
      host.__state = st;

      // on stocke dans le DOM l'état "figé" pour le PDF
      host.dataset.state = JSON.stringify({
        title:        st.title,
        enonce:       st.enonce,
        latexF:       st.latexF,
        latexFp:      st.latexFp,
        latexFp_raw:  st.latexFp_raw,
        solHTML:      st.solHTML
      });

      if (window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }

    // IMPORTANT : toujours retourner st
    return st;
  },
  correct(host, st){
    const r = checkAnswer(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick(null);
    const inp = $('#ansF',host);
    if (inp) inp.value = '';
  }
};

const EXO2 = {
  id:'exo2',
  title:'Exercice 2 : Double distributivité et identités remarquables',
  gen(host){
    const st = genEx2();

    if (host) {
      host.innerHTML = buildHostHTML(st);
      host.__state = st;

      host.dataset.state = JSON.stringify({
        title:        st.title,
        enonce:       st.enonce,
        latexF:       st.latexF,
        latexFp:      st.latexFp,
        latexFp_raw:  st.latexFp_raw,
        solHTML:      st.solHTML
      });

      if (window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }

    return st;
  },
  correct(host, st){
    const r = checkAnswer(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick(null);
    const inp = $('#ansF',host);
    if (inp) inp.value = '';
  }
};

const EXO3 = {
  id:'exo3',
  title:'Exercice 3 — Produit polynôme × racine carrée',
  gen(host){
    const st = genEx3();

    if (host) {
      host.innerHTML = buildHostHTML(st);
      host.__state = st;

      host.dataset.state = JSON.stringify({
        title:        st.title,
        enonce:       st.enonce,
        latexF:       st.latexF,
        latexFp:      st.latexFp,
        latexFp_raw:  st.latexFp_raw,
        solHTML:      st.solHTML
      });

      if (window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }

    return st;
  },
  correct(host, st){
    const r = checkAnswer(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick(null);
    const inp = $('#ansF',host);
    if (inp) inp.value = '';
  }
};

const EXO4 = {
  id:'exo4',
  title:'Exercice 4 — Carré d’une fonction',
  gen(host){
    const st = genEx4();

    if (host) {
      host.innerHTML = buildHostHTML(st);
      host.__state = st;

      host.dataset.state = JSON.stringify({
        title:        st.title,
        enonce:       st.enonce,
        latexF:       st.latexF,
        latexFp:      st.latexFp,
        latexFp_raw:  st.latexFp_raw,
        solHTML:      st.solHTML
      });

      if (window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }

    return st;
  },
  correct(host, st){
    const r = checkAnswer(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick(null);
    const inp = $('#ansF',host);
    if (inp) inp.value = '';
  }
};


const REG = [EXO1,EXO2,EXO3,EXO4];
window.REG = REG;
window.REGISTRY = REG;

/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);

/* ===== Adaptateur PDF =====
   Le PDF doit imprimer l'exercice courant uniquement,
   avec ou sans solution.
*/
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(def, _st, ctx){
        const host = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(host);
        let st = {};
        try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
        return st;
      },
      beforeRender(def, st, withSolutions){
        try{
          const host = document.createElement('div');
          host.id = 'pdf-host';
          host.style.position='fixed'; host.style.left='-10000px'; host.style.top='-10000px';
          document.body.appendChild(host);

          host.innerHTML = (typeof window.buildHostHTML === 'function') ? buildHostHTML(st) : '';
          host.dataset.state = JSON.stringify(st);

          if (withSolutions && def && typeof def.solution === 'function'){
            def.solution(host, st); // va utiliser latexFp_raw -> donc "Simplification" réapparaît si besoin
          }

          // remplace les inputs par du texte dans la sortie PDF
          (host.querySelectorAll('input, textarea, select, [contenteditable="true"]')||[])
            .forEach(el=>{
              const t = document.createTextNode(el.value||' ');
              el.replaceWith(t);
            });

          const outHTML = withSolutions
            ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
            : host.innerHTML;

          document.body.removeChild(host);
          return outHTML;
        }catch(e){
          console.error('PDF beforeRender error:', e);
          return null;
        }
      }
    });
  });
})();

/* ===== mobile tweaks ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
