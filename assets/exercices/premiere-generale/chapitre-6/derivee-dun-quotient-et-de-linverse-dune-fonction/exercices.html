<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äî D√©rivation : Quotient / Inverse</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc d'√©tapes solution */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:center;
  gap:.4rem;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
}

@media print{ .controls{display:none !important;} }

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}

/* mini-table √† 2 colonnes pour u,v et u',v' */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{padding:4px 40px 4px 0;}
}

/* tableau correction en 2 colonnes s√©par√©es par une barre verticale */
.twocol-solution{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  width:auto;
}
.twocol-solution td{
  vertical-align:top;
  padding:0 16px;
  border:none;
  white-space:nowrap;
  line-height:1.75;
  font-size:0.95rem;
}
.twocol-solution td.col-gauche{
  border-right:2px solid #999;
  padding-right:24px;
}
.twocol-solution td.col-droite{
  padding-left:24px;
}
.twocol-solution .line{
  margin:.3rem 0;
}
.twocol-solution .line mjx-container{
  padding-bottom:.08em;
}

/* --- anti-"formule g√©ante" en inline sur mobile --- */
@media (max-width:760px){
  /* cible les math inline MathJax SVG */
  mjx-container[jax="SVG"][display="inline"]{
    font-size:1em !important;        /* pas plus gros que le texte */
    line-height:1.2 !important;      /* √©vite d'√©tirer la ligne */
    vertical-align:-0.2em !important;/* recale un peu vers le bas */
  }

  /* dans les phrases normales (enonce, steps, etc.) */
  .enonce mjx-container[jax="SVG"][display="inline"],
  .steps mjx-container[jax="SVG"][display="inline"],
  .uvtab mjx-container[jax="SVG"][display="inline"],
  .twocol-solution mjx-container[jax="SVG"][display="inline"]{
    max-height:1.2em;                /* emp√™che le SVG de d√©passer */
  }

  /* s√©curit√© : emp√™che MathJax d'ajouter trop d'espace sous la ligne */
  mjx-container[jax="SVG"][display="inline"] svg{
    height:1em;                      /* on cale la hauteur du svg */
    width:auto;
  }
}

@media (max-width:760px){
  .steps mjx-container{
    padding-bottom:0;
  }
}
</style>

<!-- MathJax SVG -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true,
    packages: { '[+]': ['bbox','ams'] },
    macros: { frac: ['\\dfrac{#1}{#2}', 2] }
  },
  options: {
    skipHtmlTags: ['script','noscript','style','textarea'],
    renderActions: { assistiveMml: [] }
  },
  startup: { typeset:true }
};
</script>
<script defer src="../../../../es5/tex-svg.js"></script>

<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1√®re ‚Äì D√©rivation : Quotient / Inverse</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
    <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
    <button id="btn-solution" class="btn">üí° Solution</button>
    <button id="btn-reset" class="btn">üßπ R√©initialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; r√©ponses accept√©es :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x¬≤</code>‚Ä¶</li>
      <li>Fractions : <code>(num)/(den)</code> ou <code>num/den</code>. Parenth√®ses conseill√©es.</li>
      <li>Tu peux simplifier si tu veux, mais ce n‚Äôest pas obligatoire tant que la r√©ponse est alg√©briquement √©gale √† la d√©riv√©e attendue.</li>
      <li>Interdits : <code>1x</code> (√©crire juste <code>x</code>), <code>+0</code>, <code>0x</code>.</li>
    </ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- D√©pendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* =========================================================
   Utils / random / √©valuation √©l√®ve
   (reprend ta base)
   ========================================================= */

const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

function normalizeRac(s){
  s = String(s||'');
  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');
  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');
  s = s.replace(/(\d|\))\s*‚àö\s*\(/g, '$1*sqrt(');
  s = s.replace(/(\d|\))\s*‚àö\s*x\b/gi, '$1*sqrt(x)');
  s = s.replace(/‚àö\s*\(/g,   'sqrt(')
       .replace(/‚àö\s*x\b/gi, 'sqrt(x)');
  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
  return s;
}
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');
  s = normalizeRac(s);

  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }
}
function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }

/* =========================================================
   Polyn√¥mes : repr√©sentation coeffs croissants [c0,c1,c2,...]
   et helpers d'affichage
   ========================================================= */

function randAffine(){
  // ax + b
  const A = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);
  const B = rnd(-5,5);
  // renvoyer aussi version tableau coeffs
  return {A,B, coeffs:[B,A]}; // [c0,c1]
}
function randQuad(){
  // ax¬≤+bx+c avec a!=0
  const a = nzChoose([-3,-2,-1,1,2,3]);
  const b = rnd(-5,5);
  const c = rnd(-5,5);
  return {a,b,c, coeffs:[c,b,a]}; // [c0,c1,c2]
}

function polyDeriv(p){
  // p = [c0,c1,c2,...]
  if(p.length<=1) return [0];
  const d=[];
  for(let i=1;i<p.length;i++){
    d.push(p[i]*i);
  }
  return d;
}
function polyTimes(p,q){
  const r = Array(p.length+q.length-1).fill(0);
  for(let i=0;i<p.length;i++){
    for(let j=0;j<q.length;j++){
      r[i+j]+=p[i]*q[j];
    }
  }
  return r;
}

/* √©criture polyn√¥me propre style "2x^2+5x+1" en LaTeX (sans 1x, sans +0) */
function polyToLatex(p){
  const terms=[];
  for(let deg=p.length-1;deg>=0;deg--){
    const a = p[deg];
    if(a===0) continue;
    const absA = Math.abs(a);

    // c≈ìur du mon√¥me
    let mono;
    if(deg===0){
      mono = ''+absA;
    }else if(deg===1){
      mono = (absA===1)?'x':`${absA}x`;
    }else{
      mono = (absA===1)?`x^{${deg}}`:`${absA}x^{${deg}}`;
    }

    // signe + espace
    const piece = (a<0?'- ':'+ ')+mono;
    terms.push(piece);
  }
  if(!terms.length) return '0';

  // enlever le "+" du tout premier si besoin
  return terms.join(' ').replace(/^\+\s*/,'').trim();
}

/* version JS exploitable num√©riquement pour p(x) */
function polyToJS(p){
  const parts=[];
  for(let deg=p.length-1;deg>=0;deg--){
    const a=p[deg];
    if(a===0) continue;
    const absA=Math.abs(a);

    let seg;
    if(deg===0){
      seg = ''+absA;
    }else if(deg===1){
      seg = (absA===1)?'x':`${absA}*x`;
    }else{
      seg = (absA===1)?`x**${deg}`:`${absA}*x**${deg}`;
    }

    if(a<0) parts.push(`-(${seg})`);
    else    parts.push(seg);
  }
  if(!parts.length) return '0';

  let expr = parts.join('+');
  expr = expr.replace(/\+\-\(/g,'-(');
  return expr;
}
function makePolyFuncJS(p){
  const fExpr = polyToJS(p);
  return x => Function("x","return ("+fExpr+");")(x);
}
function makePolyDerivFuncJS(p){
  const dp = polyDeriv(p);
  const dfExpr = polyToJS(dp);
  return x => Function("x","return ("+dfExpr+");")(x);
}

/* petite fonction pour afficher un polyn√¥me d√©riv√© (affine/const) en LaTeX propre */
function polyDerivToLatex(p){
  return polyToLatex(polyDeriv(p));
}

/* idem JS */
function polyDerivToJS(p){
  return polyToJS(polyDeriv(p));
}

/* =========================================================
   Outils signe / nettoyage cha√Ænes de signes
   ========================================================= */

function cleanSigns(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/\+\s*-\s*/g,' - ');
  out = out.replace(/-\s*-\s*/g,' + ');
  out = out.replace(/\+\s*\+\s*/g,' + ');
  out = out.replace(/-\s*\+\s*/g,' - ');
  out = out.replace(/^\+\s*/,'');
  return out.replace(/\s+/g,' ').trim();
}

/* Liste des mon√¥mes non nuls d'un poly p, ordre degr√© d√©croissant.
   Renvoie [{coeff,deg}, ...] */
function polyToMonomeData(p){
  const list=[];
  for(let deg=p.length-1;deg>=0;deg--){
    const c=p[deg];
    if(c!==0){
      list.push({coeff:c,deg});
    }
  }
  if(!list.length){
    list.push({coeff:0,deg:0});
  }
  return list;
}

/* transforme un mon√¥me num√©rique coeff*x^deg en latex genre "4x^3", "5x", "2"
   coeff est suppos√© NON nul ici */
function monomeNumericLatex(coeff,deg){
  const absC = Math.abs(coeff);
  let core;
  if(deg===0){
    core = ''+absC;
  }else if(deg===1){
    core = (absC===1)?'x':`${absC}x`;
  }else{
    core = (absC===1)?`x^{${deg}}`:`${absC}x^{${deg}}`;
  }
  // on NE met PAS le signe ici, on renvoie juste "4x^3"
  return core;
}

/* D√©veloppe produit A(x)*B(x) EN SUIVANT L'ORDRE PROF :
   - on prend chaque mon√¥me de A par degr√© d√©croissant,
   - pour chacun on le multiplie par chaque mon√¥me de B par degr√© d√©croissant,
   - on garde les r√©sultats dans l'ordre d'apparition
   => retourne un tableau de termes sign√©s, par ex ["+ 4x^3", "+ 4x", "+ 5x^2", "+ 5"]
*/
function expandProductAsOrderedSignedTerms(P, Q){
  const monsP = polyToMonomeData(P); // [{coeff,deg}, ...] high->low
  const monsQ = polyToMonomeData(Q);

  const terms=[];

  for(const mp of monsP){
    for(const mq of monsQ){
      const coeff = mp.coeff * mq.coeff;
      const deg   = mp.deg   + mq.deg;
      // si coeff = 0 on saute
      if(coeff===0) continue;
      const base = monomeNumericLatex(coeff,deg);
      if(coeff<0){
        terms.push(`- ${base}`);
      }else{
        terms.push(`+ ${base}`);
      }
    }
  }

  if(!terms.length){
    terms.push('+ 0');
  }

  // On renvoie le tableau brut. On g√©rera le collage/simplification plus tard.
  return terms;
}

/* Colle une liste ["+ 4x^3","- 2x"," +5"] en une seule cha√Æne propre :
   "4x^3 - 2x + 5"
*/
function joinSignedTermList(terms){
  if(!terms.length) return '0';
  let txt = terms.join(' ');
  txt = cleanSigns(txt);
  return txt;
}

/* Combine les deux d√©veloppements pour faire
   (u'v)  ‚àí  (v'u)
   mais sans "--".
   On veut exactement :
   "4x^3+4x+5x^2+5 - 4x^3-10x^2-2x"
   c-√†-d :
   - la premi√®re liste sans signe initial "+"
   - puis " - "
   - puis la seconde liste mais en for√ßant le signe NEGATIF DEVANT CHAQUE TERME,
     donc si un terme est d√©j√† "- 10x^2", le " - (-10x^2)" devient " +10x^2"
*/
function buildNumeratorDeveloped(uPrimeCoeffs,vCoeffs,vPrimeCoeffs,uCoeffs){
  const uvTerms = expandProductAsOrderedSignedTerms(uPrimeCoeffs,vCoeffs);
  const vuTerms = expandProductAsOrderedSignedTerms(vPrimeCoeffs,uCoeffs);

  // premi√®re partie : uvTerms normalis√©s
  let left = joinSignedTermList(uvTerms); // ex "4x^3 + 4x + 5x^2 + 5"

  // deuxi√®me partie : on veut soustraire terme √† terme vuTerms
  // vuTerms est du style ["+ 4x^3","+ 10x^2","+ 2x"] ou avec des "-" d√©j√† dedans.
  // Soustraction terme √† terme :
  //  - si le terme commence par "+ A", √ßa devient "- A"
  //  - si le terme commence par "- A", √ßa devient "+ A"
  const flipped = vuTerms.map(t=>{
    // normaliser espaces
    t = t.trim();
    // t est style "+ 4x^3" ou "- 10x^2"
    if(t.startsWith('+')){
      return t.replace(/^\+\s*/,'- ');
    }else if(t.startsWith('-')){
      return t.replace(/^\-\s*/,'+ ');
    }
    return t; // fallback, devrait pas arriver
  });

  // maintenant on concat√®ne left + " " + flipped...
  let right = joinSignedTermList(flipped); // ex " - 4x^3 - 10x^2 - 2x" (apr√®s cleanSigns => "- 4x^3 - 10x^2 - 2x")
  // joinSignedTermList remet au propre, mais peut d√©marrer sans signe +.
  // on veut qu'entre les deux blocs il y ait juste un espace, pas un " + " automatique.
  // Exemple final attendu :
  // "4x^3 + 4x + 5x^2 + 5 - 4x^3 - 10x^2 - 2x"
  // On peut juste fusionner et re-nettoyer.
  let full = (left + ' ' + right).trim();
  full = cleanSigns(full);
  return full;
}

/* R√©duction finale du num√©rateur :
   numAll = (u'v) - (v'u) regroup√© par puissance
*/
function buildNumeratorReduced(uPrimeCoeffs,vCoeffs,vPrimeCoeffs,uCoeffs){
  const uv = polyTimes(uPrimeCoeffs,vCoeffs);
  const vu = polyTimes(vPrimeCoeffs,uCoeffs);
  // uv - vu
  const maxDeg = Math.max(uv.length-1, vu.length-1);
  const res = Array(maxDeg+1).fill(0);
  for(let k=0;k<=maxDeg;k++){
    const a = uv[k]||0;
    const b = vu[k]||0;
    res[k]=a-b;
  }
  return polyToLatex(res); // propre, ex "-5x^2 + 2x + 5"
}

function isConstantPoly(p){
  // p = [c0, c1, c2, ...]
  // c1,c2,... tous nuls => constante
  for(let i=1;i<p.length;i++){
    if(p[i] !== 0) return false;
  }
  return true;
}

function beautifyConstant(k){
  return String(k);
}

function buildLineSubstitution(uPrimeLatex, vLatex, vPrimeLatex, uLatex, vPrimeCoeffs){
  // ===== 1. Pr√©parer u'(x)*v(x) proprement (TERME "u'v")
  // On veut g√©rer :
  //  - u'(x)=1      -> v(x)
  //  - u'(x)=-1     -> -v(x)
  //  - u'(x)=k‚â†¬±1   -> k v(x)
  //  - sinon        -> (u')(v)

  // ex: "1", "- 1", "2", "- 4", "3.5", etc -> on nettoie les espaces
  const uPrimeClean = uPrimeLatex.replace(/\s+/g,'').trim(); // ex "-4", "1", "-1"
  const isConstUPrime = /^-?\d+(\.\d+)?$/.test(uPrimeClean);

  let termUV;
  if(isConstUPrime){
    // c'est une constante
    if(uPrimeClean === '1'){
      // 1 * v(x) -> juste v(x)
      termUV = `(${vLatex})`;
    } else if(uPrimeClean === '-1'){
      // -1 * v(x) -> - v(x)
      termUV = `-${vLatex.startsWith('-') ? `(${vLatex})` : `(${vLatex})`}`;
      // on garde "-(...)" c'est propre et clair
      termUV = `-${vLatex.startsWith('-') ? `(${vLatex})` : `(${vLatex})`}`;
    } else {
      // k * v(x) avec k‚â†¬±1 -> k(v(x))
      termUV = `${uPrimeClean}(${vLatex})`;
    }
  } else {
    // pas juste une constante -> parenth√®ses autour de u'(x)
    termUV = `(${uPrimeLatex})(${vLatex})`;
  }

  // D√©nominateur commun
  const denom = `\\left(${vLatex}\\right)^{2}`;

  // ===== 2. CAS o√π v'(x) est constante k
  // (r√®gle d√©j√† en place chez toi)
  if (isConstantPoly(vPrimeCoeffs)){
    const k = vPrimeCoeffs[0]; // v'(x)=k

    if (k < 0){
      // -(k)u(x) = -(-2)u(x) -> +2u(x)
      const kk = Math.abs(k);
      const secondPretty = (kk===1?`(${uLatex})`:`${kk}\\,(${uLatex})`);
      return `f'(x)=\\dfrac{${termUV} + ${secondPretty}}{${denom}}`;
    } else {
      if (k === 0){
        // v'(x)=0
        return `f'(x)=\\dfrac{${termUV}}{${denom}}`;
      } else {
        // k>0 : u'v - k u
        const secondPretty = (k===1?`(${uLatex})`:`${k}\\,(${uLatex})`);
        return `f'(x)=\\dfrac{${termUV} - ${secondPretty}}{${denom}}`;
      }
    }
  }

  // ===== 3. SINON : v'(x) n'est PAS constante
  // Il faut g√©rer "v'(x)=kx"
  // On veut rep√©rer exactement une forme "k x" ou "-k x" avec k r√©el et PAS de + ... derri√®re.
  // Notre latex actuel pour une d√©riv√©e affine style "2x" ou "-4x" vient de polyToLatex(),
  // qui donne par exemple "2x" ou "- 4x" (avec espace).
  const vPrimeNoSpace = vPrimeLatex.replace(/\s+/g,'').trim(); // ex "2x", "-4x", "x", "-x", "2x+3", etc.

  // regex : nombre (optionnel) puis "x", rien d'autre
  // accepte "x", "-x", "2x", "-3x", "4.5x"
  const m = vPrimeNoSpace.match(/^(-?\d*\.?\d*)x$/);

  if (m){
    // C'est du type kx pur
    let kStr = m[1]; // peut √™tre "", "-", "2", "-4", "3.5"...
    // normaliser k num√©rique
    // ""  -> 1
    // "-" -> -1
    let kVal;
    if(kStr === '' || kStr === '+'){ kVal = 1; }
    else if(kStr === '-'){ kVal = -1; }
    else { kVal = parseFloat(kStr); }

    // Maintenant on forme "- v'(x) u(x)" sans parenth√®ses autour de v'(x)
    // R√®gle demand√©e :
    // si k>0 -> "- kx(u(x))"
    // si k<0 -> "+ |k|x(u(x))"
    // Et si |k|=1 on √©crit juste "x" pas "1x"

    // construit la cha√Æne kx propre sans le 1:
    function kxLatex(k){
      const absK = Math.abs(k);
      if (absK === 1){
        return `x`;
      } else {
        return `${absK}x`;
      }
    }

    let secondTerm; // ce qui remplace "-(v'(x))u(x)"

    if(kVal > 0){
      // - kx(u)
      secondTerm = ` - ${kxLatex(kVal)}(${uLatex})`;
    } else if(kVal < 0){
      // - ( -|k|x ) u  = + |k|x(u)
      secondTerm = ` + ${kxLatex(kVal)}(${uLatex})`;
    } else {
      // k=0 -> v'(x)=0, √ßa retombe au cas constant 0 normalement, mais bon:
      secondTerm = ``;
    }

    return `f'(x)=\\dfrac{${termUV}${secondTerm}}{${denom}}`;
  }

  // ===== 4. Cas g√©n√©ral inchang√© (affine avec constante, polyn√¥me, etc.)
  // on garde la version classique : (u'v) - (v'u) avec parenth√®ses
  const termVU = `(${vPrimeLatex})(${uLatex})`;
  return `f'(x)=\\dfrac{${termUV} - ${termVU}}{${denom}}`;
}


function monomesFromProduct(P, Q){
  // P et Q sont les coeffs [c0,c1,c2]...
  // retourne ["-4x^2", "-6x", ...] avec signe int√©gr√©
  const monos=[];
  for(let i=0;i<P.length;i++){
    for(let j=0;j<Q.length;j++){
      const coef = P[i]*Q[j];
      if(coef===0) continue;
      const deg = i+j;

      // construit le mon√¥me abs(coef)*x^{deg}
      const absC = Math.abs(coef);
      let core;
      if(deg===0){
        core = ''+absC;
      }else if(deg===1){
        core = (absC===1)?'x':`${absC}x`;
      }else{
        core = (absC===1)?`x^{${deg}}`:`${absC}x^{${deg}}`;
      }

      const signedMono = (coef<0?'- ':'+ ') + core;
      monos.push(signedMono.trim());
    }
  }
  // join avec " " + " " ne suffit pas ; on veut des + / -
  let txt = monos.join(' ');
  txt = cleanSigns(txt);
  return txt;
}

function factorTimesExprLatex(factorLatex, exprLatex){
  // Si le facteur est juste un nombre (ex: "3", "-2", "0.5", "-7"),
  // alors PAS de parenth√®ses autour du facteur.
  // Sinon (ex: "2x+1"), on met des parenth√®ses.
  const isNumber = /^-?\d+(\.\d+)?$/.test(factorLatex.trim());

  if(isNumber){
    return factorLatex.trim() + `(${exprLatex})`;
  }else{
    return `(${factorLatex})(${exprLatex})`;
  }
}


/* =========================================================
   Construction d'un exo QUOTIENT
   ========================================================= */

function randUVpair(){
  // Choix du type :
  const pattern = choice(["aff/aff","aff/quad","quad/aff","quad/quad"]);

  let u, v;
  if(pattern==="aff/aff"){
    u = randAffine();
    v = randAffine();
  }else if(pattern==="aff/quad"){
    u = randAffine();
    v = randQuad();
  }else if(pattern==="quad/aff"){
    u = randQuad();
    v = randAffine();
  }else{
    u = randQuad();
    v = randQuad();
  }

  // On construit les polyn√¥mes sous forme coeffs[]
  const uCoeffs = u.coeffs;
  const vCoeffs = v.coeffs;

  // D√©riv√©es u', v'
  const uPrimeCoeffs = polyDeriv(uCoeffs);
  const vPrimeCoeffs = polyDeriv(vCoeffs);

  // LaTeX de u, v, u', v'
  const uLatex = polyToLatex(uCoeffs);
  const vLatex = polyToLatex(vCoeffs);
  const uPrimeLatex = polyToLatex(uPrimeCoeffs);
  const vPrimeLatex = polyToLatex(vPrimeCoeffs);

  // JS des m√™mes (pour v√©rification √©l√®ve)
  const uJS      = '('+polyToJS(uCoeffs)+')';
  const vJS      = '('+polyToJS(vCoeffs)+')';
  const uPrimeJS = '('+polyToJS(uPrimeCoeffs)+')';
  const vPrimeJS = '('+polyToJS(vPrimeCoeffs)+')';

  return {
    uCoeffs,vCoeffs,uPrimeCoeffs,vPrimeCoeffs,
    uLatex,vLatex,uPrimeLatex,vPrimeLatex,
    uJS,vJS,uPrimeJS,vPrimeJS
  };
}

/* calcule f(x)=u/v et f'(x) num√©riquement */
function makeQuotientEval(uJS,vJS,uPrimeJS,vPrimeJS){
  const fJS = x => {
    const u = Function("x","return "+uJS+";")(x);
    const v = Function("x","return "+vJS+";")(x);
    return u/v;
  };
  const fpJS = x => {
    const u  = Function("x","return "+uJS+";")(x);
    const v  = Function("x","return "+vJS+";")(x);
    const du = Function("x","return "+uPrimeJS+";")(x);
    const dv = Function("x","return "+vPrimeJS+";")(x);
    return (du*v - u*dv)/(v*v);
  };
  return {fJS, fpJS};
}

function genExQuotient(){

  // tirage u,v
  const {
    uCoeffs,vCoeffs,uPrimeCoeffs,vPrimeCoeffs,
    uLatex,vLatex,uPrimeLatex,vPrimeLatex,
    uJS,vJS,uPrimeJS,vPrimeJS
  } = randUVpair();

  const {fJS, fpJS} = makeQuotientEval(uJS,vJS,uPrimeJS,vPrimeJS);

  const fLatex = `\\dfrac{${uLatex}}{${vLatex}}`;

  // ----- LIGNE FORMULE G√âN√âRALE
  const lineFormule =
    `f'(x)=\\dfrac{u'(x)v(x)-v'(x)u(x)}{(v(x))^{2}}`;

  // ----- LIGNE SUBSTITUTION (avec gestion du signe sp√©cial si v' est constante)
  const lineSubstitution = buildLineSubstitution(
    uPrimeLatex,
    vLatex,
    vPrimeLatex,
    uLatex,
    vPrimeCoeffs
  );

   const vPrimeIsConst = isConstantPoly(vPrimeCoeffs);

  // On d√©tecte aussi si v'(x) est du type kx (sans terme constant)
  const vPrimeNoSpace = vPrimeLatex.replace(/\s+/g,'').trim();
  const vPrimeIsKx = /^-?\d*\.?\d*x$/.test(vPrimeNoSpace); // ex "2x", "-x", "x", "0.5x"

  // num√©rateur r√©duit final :
  const numerateurReduit = buildNumeratorReduced(
    uPrimeCoeffs,
    vCoeffs,
    vPrimeCoeffs,
    uCoeffs
  );
  const denomSquared = `\\left(${vLatex}\\right)^{2}`;

  let lineDevSectionHTML = '';
  let lineConclusion = '';

  if(vPrimeIsConst){
    // ===== CAS A : v'(x) = k constante =====
    const k = vPrimeCoeffs[0];

    // contribution mult*u(x) avec le bon signe
    let mult;
    if(k < 0){
      mult = Math.abs(k);   // devient "+ |k| u(x)"
    }else if(k > 0){
      mult = -k;            // devient "- k u(x)"
    }else{
      mult = 0;             // v'(x)=0
    }

    // uvPoly = u' * v
    const uvPoly = polyTimes(uPrimeCoeffs,vCoeffs);
    // mult*u
    const kuPoly = uCoeffs.map(c => mult*c);

    // num√©rateur d√©velopp√© "brut" : u'v + (mult*u)" (concaten√© sans simplif)
    const uvTerms = expandProductAsOrderedSignedTerms(uPrimeCoeffs, vCoeffs);
    const uvJoined = joinSignedTermList(uvTerms);

    let kuJoined = '';
    if(mult!==0){
      const kuTerms = expandProductAsOrderedSignedTerms([mult], uCoeffs);
      kuJoined = joinSignedTermList(kuTerms);
    }

    let numDeveloppe = uvJoined;
    if(mult!==0){
      numDeveloppe = cleanSigns((uvJoined + '+ ' + kuJoined).trim());
    }

    // puis on regroupe (r√©duction)
    const maxDeg = Math.max(uvPoly.length-1, kuPoly.length-1);
    const res = Array(maxDeg+1).fill(0);
    for(let d=0; d<=maxDeg; d++){
      res[d] = (uvPoly[d]||0) + (kuPoly[d]||0);
    }
    const numerateurReduitConst = polyToLatex(res);

    lineDevSectionHTML = `
      <div class="line">\\(f'(x)=\\dfrac{${numDeveloppe}}{${denomSquared}}\\)</div>

      <div class="line">\\(f'(x)=\\dfrac{${numerateurReduitConst}}{${denomSquared}}\\)</div>
    `;

    lineConclusion = `f'(x)=\\dfrac{${numerateurReduitConst}}{${denomSquared}}`;

  } else {
    // ===== CAS B : v'(x) pas constante =====

    // On a 2 sous-cas :
    //   B1. v'(x) = kx   ‚Üí on a d√©j√† absorb√© le signe dans la substitution,
    //                     donc on ne veut PAS l'√©tape " - (v'(x))u(x)" d√©velopp√©e
    //                     puis l'√©tape o√π on distribue le '-'.
    //
    //   B2. v'(x) plus compliqu√©e ‚Üí on garde le d√©roul√© complet (tes 3 lignes actuelles)

    // Pr√©paration commune :
    const uvTerms = expandProductAsOrderedSignedTerms(uPrimeCoeffs, vCoeffs);
    const uvJoined = joinSignedTermList(uvTerms);

    const vuTerms = expandProductAsOrderedSignedTerms(vPrimeCoeffs, uCoeffs);
    const vuJoined = joinSignedTermList(vuTerms);

    // num√©rateur r√©duit d√©j√† calcul√© :
    const numReduit = numerateurReduit;

if (vPrimeIsKx){
  // ----- CAS B1 : v'(x)=kx -----

  // 1. R√©cup√©rer k (dans v'(x)=k x)
  let kStr = vPrimeNoSpace.replace('x',''); // "2", "-3", "", "-"
  let kVal = (kStr === '' || kStr === '+') ? 1
             : (kStr === '-' ? -1 : parseFloat(kStr));

  // 2. Construire polyn√¥me u'v :
  // uvPoly = u' * v
  const uvPoly = polyTimes(uPrimeCoeffs, vCoeffs);

  // 3. Construire polyn√¥me correspondant au deuxi√®me terme APR√àS le signe de la SUBSTITUTION :
  // Substitution a fait :
  //   si kVal>0 :  ... - kVal*x * u(x)
  //   si kVal<0 :  ... + |kVal|*x * u(x)
  //
  // On va donc cr√©er polySecond = (coefGlobal)*x*u(x)
  // o√π coefGlobal = (kVal>0 ? -kVal : +|kVal|).
  const coefGlobal = (kVal>0 ? -kVal : Math.abs(kVal));

  // u(x) coeffs = uCoeffs = [c0,c1,c2,...] pour c0 + c1 x + c2 x^2 + ...
  // x*u(x) => on d√©cale d'un cran : [0, c0, c1, c2, ...]
  const xTimesU = [0, ...uCoeffs];

  // coefGlobal * (x*u(x))
  const secondPoly = xTimesU.map(c => coefGlobal * c);

  // 4. numDevPoly = uvPoly + secondPoly
  //    (somme terme √† terme)
  const maxLen = Math.max(uvPoly.length, secondPoly.length);
  const numDevPoly = Array(maxLen).fill(0);
  for (let i=0;i<maxLen;i++){
    numDevPoly[i] = (uvPoly[i]||0) + (secondPoly[i]||0);
  }

  // 5. Cr√©er la ligne "d√©veloppement du num√©rateur" en LISTE DE TERMES,
  //    dans l'ordre prof : d'abord u'v, puis le 2√®me terme sign√©,
  //    EXACTEMENT comme on vient de l'√©crire en substitution.
  //
  // Pour √ßa on va g√©n√©rer s√©par√©ment :
  //   - les termes de u'v (uPrimeCoeffs * vCoeffs) -> uvTerms
  //   - les termes du deuxi√®me bloc sign√© -> secondTerms
  //
  const uvTerms = expandProductAsOrderedSignedTerms(uPrimeCoeffs, vCoeffs);

  // construire coeffs du deuxi√®me bloc sign√© seul :
  // coefGlobal * x * u(x) -> secondCoeffs = secondPoly
  // mais on veut les mon√¥mes de ce poly seul, donc :
  // on va reconstruire secondTerms via polyToMonomeData + signe
  function polyToSignedTerms(p){
    // p : [c0,c1,c2,...]
    // on veut la liste "+ 4x^2", "- 3x", etc. en ordre d√©croissant
    const mons = polyToMonomeData(p); // [{coeff,deg}, ...] ordre d√©croissant d√©j√†
    return mons
      .filter(m=>m.coeff!==0)
      .map(m=>{
        const absC = Math.abs(m.coeff);
        let core;
        if(m.deg===0){
          core = ''+absC;
        }else if(m.deg===1){
          core = (absC===1)?'x':`${absC}x`;
        }else{
          core = (absC===1)?`x^{${m.deg}}`:`${absC}x^{${m.deg}}`;
        }
        return (m.coeff<0?'- ':'+ ') + core;
      });
  }

  const secondTerms = polyToSignedTerms(secondPoly);

  // concat ordre prof : u'v puis le bloc sign√©
  const allTermsRaw = uvTerms.concat(secondTerms);
  let numDevDistrib = joinSignedTermList(allTermsRaw); // cleanSigns dedans

  // 6. numReduit = forme r√©duite finale qu'on avait d√©j√† calcul√©e
  const numReduit = numerateurReduit;

  // 7. On construit les lignes affich√©es :
  lineDevSectionHTML = `
    <div class="line">\\(f'(x)=\\dfrac{${numDevDistrib}}{${denomSquared}}\\)</div>

    <div class="line">\\(f'(x)=\\dfrac{${numReduit}}{${denomSquared}}\\)</div>
  `;

  lineConclusion = `f'(x)=\\dfrac{${numReduit}}{${denomSquared}}`;



    } else {
      // --------- CAS B2 : v'(x) g√©n√©ral ---------
      // = ton ancien comportement complet (3 lignes)
      // 1) numDevBrut = u'v - (v'u)
      const numDevBrut = `${uvJoined} - (${vuJoined})`;
      const numDevBrutClean = cleanSigns(numDevBrut);

      // 2) on distribue le " - (...) " terme √† terme
      const flippedVuTerms = vuTerms.map(t=>{
        t = t.trim();
        if(t.startsWith('+')){
          return t.replace(/^\+\s*/,'- ');
        }else if(t.startsWith('-')){
          return t.replace(/^\-\s*/,'+ ');
        }
        return t;
      });
      const flippedVuJoined = joinSignedTermList(flippedVuTerms);
      let numDevDistribRaw = (uvJoined + '+ ' + flippedVuJoined).trim();
      numDevDistribRaw = cleanSigns(numDevDistribRaw);
      // espace apr√®s + / -
      const numDevDistrib = numDevDistribRaw.replace(/([+\-])\s*(?=[0-9x])/g, '$1 ');

      lineDevSectionHTML = `
        <div class="line">\\(f'(x)=\\dfrac{${numDevBrutClean}}{${denomSquared}}\\)</div>

        <div class="line">\\(f'(x)=\\dfrac{${numDevDistrib}}{${denomSquared}}\\)</div>

        <div class="line">\\(f'(x)=\\dfrac{${numReduit}}{${denomSquared}}\\)</div>
      `;

      lineConclusion = `f'(x)=\\dfrac{${numReduit}}{${denomSquared}}`;
    }
	
  }

  
const defDomLine = `Ensemble de d√©finition :\\( \\) \\( \\mathcal{D}_f = \\{ x \\in \\mathbb{R} \\mid ${vLatex} \\neq 0 \\} \\).`;

  // bloc HTML final pour la solution :
  const solHTML = `
  <div class="steps">
    <div class="line" style="margin-top:.6rem"><strong>${defDomLine}</strong></div>
Remarque : Si l'√©nonc√© demande clairement l'ensemble de d√©finition de \\(f\\) \\( \\) il faut alors r√©soudre : \\( \\) \\(${vLatex}=0\\) \\( \\) et exclure les racines √©ventuelles.<br>
                   <div class="line"><br></div>
   
   <div class="line"><strong>M√©thode ‚Äî R√®gle du quotient</strong></div>

    <div class="line">On pose \\(f(x)=\\dfrac{u(x)}{v(x)}\\) avec :</div>

    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
        <td>\\(v(x)=${vLatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${uPrimeLatex}\\)</td>
        <td>\\(v'(x)=${vPrimeLatex}\\)</td>
      </tr>
    </table>

    <div class="line">\\(${lineFormule}\\)</div>

    <div class="line">\\(${lineSubstitution}\\)</div>

    ${lineDevSectionHTML}

  </div>`;

  const title  = "Exercice 1 : Quotient";
  const enonce = `D√©terminer la d√©riv√©e de la fonction d√©finie (sur son ensemble de d√©finition) par :<br><br>\\[ f(x)=${fLatex} \\]`;

  return {
    title,
    enonce,
    latexF: fLatex,
    latexFp_raw: lineConclusion.replace(/^f'\(x\)=/,'').trim(),
    latexFp: lineConclusion.replace(/^f'\(x\)=/,'').trim(),
    solHTML,
    fJS,
    fpJS
  };
}


/* =========================================================
   EXERCICE 2 : Inverse
   m√™me id√©e que ta version pr√©c√©dente
   ========================================================= */

function randInverseData(){
  // on choisit v affine ou quad
  const isQuad = Math.random()<0.5;

  let vObj;
  if(isQuad){ vObj = randQuad(); }
  else      { vObj = randAffine(); }

  const vCoeffs = vObj.coeffs;
  const vLatex  = polyToLatex(vCoeffs);
  const vPrimeCoeffs = polyDeriv(vCoeffs);
  const vPrimeLatex  = polyToLatex(vPrimeCoeffs);

  const vJS      = '('+polyToJS(vCoeffs)+')';
  const vPrimeJS = '('+polyToJS(vPrimeCoeffs)+')';

  // k al√©atoire ou pas
  const k = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
  const useK = Math.random()<0.5; // soit 1/v, soit k/v

  let fLatex, fJSexpr;
  if(useK){
    fLatex = `\\dfrac{${k}}{${vLatex}}`;
    fJSexpr = `(${k})/(${vJS.slice(1,-1)})`;
  }else{
    fLatex = `\\dfrac{1}{${vLatex}}`;
    fJSexpr = `1/(${vJS.slice(1,-1)})`;
  }

  // d√©riv√©e :
  // f(x)=k/v(x) => f'(x)= -k * v'(x)/(v(x))^2
  // si pas de k explicite => k=1
  const K = useK ? k : 1;
  // coeff devant la fraction : -K
  function coefTimesDerivLatex(coeff){
    const absC = Math.abs(coeff);
    if(absC===1){
      return coeff<0?'- ':'';
    }else{
      return (coeff<0?'- ':'')+absC+"\\,";
    }
  }
  const frontCoef = coefTimesDerivLatex(-K);
  const derivLatexFinal =
    `${frontCoef}\\dfrac{${vPrimeLatex}}{\\left(${vLatex}\\right)^{2}}`
      .replace(/\s+/g,' ')
      .trim();

  const derivLatexAFinal =
    `${frontCoef}\\dfrac{v'(x)}{\\left(v(x)\\right)^{2}}`
      .replace(/\s+/g,' ')
      .trim();
	  
  // fonctions num pour check
  const fJS = x => Function("x","return ("+fJSexpr+");")(x);
  const fpJS = x => {
    const v  = Function("x","return "+vJS+";")(x);
    const dv = Function("x","return "+vPrimeJS+";")(x);
    return -(K*dv)/(v*v);
  };
const defDomLine = `Ensemble de d√©finition :\\( \\) \\( \\mathcal{D}_f = \\{ x \\in \\mathbb{R} \\mid ${vLatex} \\neq 0 \\} \\).`;

  const title = "Exercice 2 : Inverse";
  const enonce = `D√©terminer la d√©riv√©e de la fonction d√©finie (sur son ensemble de d√©finition) par :<br><br>\\[ f(x)=${fLatex} \\]`;


  // --- Avantage : on fabrique deux styles HTML diff√©rents ---

  let solHTML = '';

  if (!useK || K === 1) {
    // =========================
    // CAS A : f(x) = 1 / u(x)
    // (donc on ne parle PAS de k)
    // =========================

    // d√©riv√©e attendue dans ce cas pr√©cis :
    // f'(x) = -(u'(x)) / (u(x))^2
    const derivLatexCase1 =
      `-\\dfrac{${vPrimeLatex}}{\\left(${vLatex}\\right)^{2}}`
      .replace(/\s+/g,' ')
      .trim();

 function minusOneTimes_vPrime_raw(vPrimeLatex){
    // si v'(x) commence par "-" ou contient plusieurs termes, on l'encadre
    const vpTrim = vPrimeLatex.trim();
    const needsPar = /[-+].*x|^\-/.test(vpTrim);
    const vpShown = needsPar ? `(${vpTrim})` : vpTrim;
    // on √©crit -1 √ó v'(x) mais on ne veut pas montrer "1" devant,
    // tu ne veux jamais voir "1x". Par coh√©rence visuelle,
    // on va √©crire juste "- " devant si c'est une constante simple,
    // mais on veut conserver le format "(-1) √ó ..." pour rester parall√®le au cas k‚â†1.
    //
    // Pour √™tre propre et explicite p√©dagogiquement, on garde "(-1) √ó ...".
    return `(-1)\\,${vpShown}`;
  }

  // 2) produit d√©velopp√© : (-1)*v'(x)
  // vPrimeCoeffs est un polyn√¥me [c0,c1,c2,...]
  // On multiplie CHAQUE coeff par -1, puis on le r√©√©crit joliment.
  function minusOneTimes_vPrime_develop(vPrimeCoeffs){
    const scaled = vPrimeCoeffs.map(c => -1 * c);
    return polyToLatex(scaled); // ex "4x-6" ou "1" ou "-2x" etc.
  }

  const numRaw   = minusOneTimes_vPrime_raw(vPrimeLatex);
  const numDev   = minusOneTimes_vPrime_develop(vPrimeCoeffs);

  // d√©nominateur commun
  const denomSq = `\\left(${vLatex}\\right)^{2}`;

  // lignes interm√©diaires :
  //
  // 1. Formule g√©n√©rale appliqu√©e au cas k=1 :
  //    f'(x)= - v'(x)/(v(x))^2
  const lineGeneral =
    `f'(x)= -\\dfrac{v'(x)}{\\big(v(x)\\big)^2}`;

  // 2. Substitution explicite de v'(x)
  //    f'(x)= [ (-1) √ó v'(x) ] / (v(x))^2
  const lineSubNoDev =
    `f'(x)=\\dfrac{${numRaw}}{${denomSq}}`;

  // 3. D√©veloppement de (-1)*v'(x)
  //    f'(x)= numDev / (v(x))^2
  const lineAfterDev =
    `f'(x)=\\dfrac{${numDev}}{${denomSq}}`;


    solHTML = `
    <div class="steps">
    <div class="line" style="margin-top:.6rem"><strong>${defDomLine}</strong></div>
Remarque : Si l'√©nonc√© demande clairement l'ensemble de d√©finition de \\(f\\) \\( \\) il faut alors r√©soudre : \\( \\) \\(${vLatex}=0\\) \\( \\) et exclure les racines √©ventuelles.<br>
                          <div class="line"><br></div>

	   <div class="line"><strong>M√©thode ‚Äî R√®gle de l'inverse d'une fonction</strong></div>

        <div class="line">On a \\( \\) \\(f(x)=\\dfrac{1}{v(x)}\\) \\( \\) avec :</div>

        <div class="line">\\(v(x)=${vLatex}\\).</div>
        <div class="line">\\(v'(x)=${vPrimeLatex}\\).</div>

      

        <div class="line">\\(f'(x)= -\\dfrac{v'(x)}{\\big(v(x)\\big)^2}\\)
        </div>

        <div class="line">
          \\(f'(x)= ${derivLatexCase1}\\)
        </div>
		
		  <div class="line">
          \\(${lineAfterDev}\\)
        </div>
   
    </div>`;

    // et on d√©finit la version finale √† comparer pour la v√©rif √©l√®ve :
    // (c'est la m√™me forme que derivLatexCase1)
    // -> On remplace latexFp_raw / latexFp par ce cas-l√†
    const derivLatexFinal = derivLatexCase1;
    return {
      title,
      enonce,
      latexF: fLatex,
      latexFp_raw: derivLatexFinal,
      latexFp: derivLatexFinal,
      solHTML,
      fJS,
      fpJS
    };

  } else {
    	
	 // (-k)
    function minusKVal(k){ return -k; } // valeur num√©rique
    function minusKLatex(k){
      // affichage symbolique de "-k"
      // si k<0 -> "-(-4)"
      // si k>0 -> "-2"
      if(k < 0){
        return `-(${k})`;
      } else {
        return `-${k}`;
      }
    }

    // 1) produit (-k)*v'(x) NON d√©velopp√©, propre :
    //    ex k=-4, v'(x)=-1  -> "-(-4) \\times (-1)"
    //    ex k=2,  v'(x)=3x-5 -> "-2 \\times (3x-5)"
    function productMinusK_vPrime_raw(k, vPrimeLatex){
      const minusKtxt = minusKLatex(k); // "-2" ou "-(-4)"
      // v'(x) peut commencer par "-", ou avoir plusieurs termes
      const vpTrim = vPrimeLatex.trim();
      const needsPar = /[-+].*x|^\-/.test(vpTrim); 
      // heuristique : si affine ou commence par "-", mets ( ... )
      const vpShown = needsPar ? `(${vpTrim})` : vpTrim;
      return `${minusKtxt}\\,${vpShown}`;
    }

    // 2) produit (-k)*v'(x) D√âVELOPP√â :
    //    on prend vPrimeCoeffs (tableau coeffs croissants)
    //    on multiplie chaque coeff par (-k) et on r√©-√©crit en LaTeX propre
    function productMinusK_vPrime_develop(k, vPrimeCoeffs){
      const mk = -k; // num√©riquement
      const scaled = vPrimeCoeffs.map(c => mk*c); // (-k)*v'(x)
      // convertir ce polyn√¥me en latex propre (sans 1x, sans + -)
      return polyToLatex(scaled); // ex "6x - 10" ou "-4"
    }

    // valeurs utiles
    const minusK_num = minusKVal(K); // nombre -k
    const rawNum = productMinusK_vPrime_raw(K, vPrimeLatex); // ex "-(-4) (-1)" ou "-2 (3x-5)"
    const devNum = productMinusK_vPrime_develop(K, vPrimeCoeffs); // ex "-4" ou "6x - 10"

    // Ligne 1 : rappel r√®gle appliqu√©e
    // f'(x)= -k * v'(x) / (v(x))^2
    const lineGeneralApplied = 
      `f'(x)=\\dfrac{-k\\,v'(x)}{\\left(v(x)\\right)^{2}}`;

    // Ligne 2 : substitution k et v'(x) dedans, AVANT d√©veloppement
    //          -> num√©rateur = minusKLatex(K) * v'(x)
    const lineSubNoDev =
      `f'(x)=\\dfrac{${rawNum}}{\\left(${vLatex}\\right)^{2}}`;

    // Ligne 3 : d√©veloppement de (-k)*v'(x)
    //          -> num√©rateur = devNum
    //          Attention au cas o√π devNum est juste un nombre n√©gatif :
    //          c'est ok, polyToLatex g√®re les signes.
    const lineAfterDev =
      `f'(x)=\\dfrac{${devNum}}{\\left(${vLatex}\\right)^{2}}`;



    solHTML = `
    <div class="steps">
    <div class="line" style="margin-top:.6rem"><strong>${defDomLine}</strong></div>
Remarque : Si l'√©nonc√© demande clairement l'ensemble de d√©finition de \\(f\\) \\( \\) il faut alors r√©soudre : \\( \\) \\(${vLatex}=0\\) \\( \\) et exclure les racines √©ventuelles.<br>
                   <div class="line"><br></div>

		 <div class="line"><strong>M√©thode ‚Äî R√®gle de l'inverse d'une fonction</strong></div>


        <div class="line">On a \\( \\) \\(f(x)=\\dfrac{${K}}{v(x)}\\) \\( \\) avec :</div>
        <div class="line">\\(v(x)=${vLatex}\\)</div>
        <div class="line">\\(v'(x)=${vPrimeLatex}\\)</div>

   
        <div class="line">\\(f'(x)= ${K}\\,\\dfrac{-v'(x)}{\\big(v(x)\\big)^2}\\)</div>
  <div class="line">
          \\(f'(x)= ${derivLatexAFinal}\\)
        </div>
        <div class="line">
          \\(f'(x)= ${derivLatexFinal}\\)
        </div>
 <div class="line">
          \\(${lineAfterDev}\\)
        </div>

    </div>`;

    return {
      title,
      enonce,
      latexF: fLatex,
      latexFp_raw: derivLatexFinal,
      latexFp: derivLatexFinal,
      solHTML,
      fJS,
      fpJS
    };
  }

}

/* =========================================================
   RENDU / UI / V√©rification
   ========================================================= */

function buildHostHTML(st){
  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>
      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansF" class="inp" style="min-width:360px">
          <span id="tickF" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}

function setTick(ok){
  const el = $('#tickF');
  if(!el) return;
  el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
  el.textContent = ok===true?'‚úì': ok===false?'‚úó':'‚Äî';
}

function checkAnswer(st){
  const inp = $('#ansF');
  if(!inp){ setTick(null); return {count:0,good:0}; }
  const val = inp.value||'';
  if(!val.trim()){
    setTick(null);
    return {count:0,good:0};
  }

  const xs=[-2.4,-1.1,0.7,1.3,2.8,4.2];
  let ok=true;
  for(const x of xs){
    const got=numEval(val,x);
    const ref=st.fpJS(x);
    if(!Number.isFinite(got)||!Number.isFinite(ref)||!almost(got,ref,1e-6)){
      ok=false;break;
    }
  }
  setTick(ok);
  return {count:1, good:(ok?1:0)};
}

/* =========================================================
   REGISTRY des exos
   ========================================================= */

const EXO_Q = {
  id:'exoQ',
  title:'Exercice 1 ‚Äî Quotient',
  gen(host){
    const st = genExQuotient();
    if(host){
      host.innerHTML = buildHostHTML(st);
      host.__state = st;
      host.dataset.state = JSON.stringify({
        title:        st.title,
        enonce:       st.enonce,
        latexF:       st.latexF,
        latexFp:      st.latexFp,
        latexFp_raw:  st.latexFp_raw,
        solHTML:      st.solHTML
      });
      if(window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }
    return st;
  },
  correct(host, st){
    const r = checkAnswer(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick(null);
    const inp = $('#ansF',host);
    if(inp) inp.value = '';
  }
};

const EXO_I = {
  id:'exoI',
  title:'Exercice 2 ‚Äî Inverse',
  gen(host){
    const st = randInverseData();
    if(host){
      host.innerHTML = buildHostHTML(st);
      host.__state = st;
      host.dataset.state = JSON.stringify({
        title:        st.title,
        enonce:       st.enonce,
        latexF:       st.latexF,
        latexFp:      st.latexFp,
        latexFp_raw:  st.latexFp_raw,
        solHTML:      st.solHTML
      });
      if(window.MathJax?.typeset) MathJax.typeset();
      scanFractions(host);
    }
    return st;
  },
  correct(host, st){
    const r = checkAnswer(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick(null);
    const inp = $('#ansF',host);
    if(inp) inp.value = '';
  }
};

const REG = [EXO_Q,EXO_I];
window.REG = REG;
window.REGISTRY = REG;

/* =========================================================
   Montage UI / PDF / mobile tweaks
   ========================================================= */

function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);

/* ===== Adaptateur PDF ===== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(def, _st, ctx){
        const host = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(host);
        let st = {};
        try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
        return st;
      },
      beforeRender(def, st, withSolutions){
        try{
          const host = document.createElement('div');
          host.id = 'pdf-host';
          host.style.position='fixed'; host.style.left='-10000px'; host.style.top='-10000px';
          document.body.appendChild(host);

          host.innerHTML = (typeof window.buildHostHTML === 'function') ? buildHostHTML(st) : '';
          host.dataset.state = JSON.stringify(st);

          if (withSolutions && def && typeof def.solution === 'function'){
            def.solution(host, st);
          }

          (host.querySelectorAll('input, textarea, select, [contenteditable="true"]')||[])
            .forEach(el=>{
              const t = document.createTextNode(el.value||' ');
              el.replaceWith(t);
            });

          const outHTML = withSolutions
            ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
            : host.innerHTML;

          document.body.removeChild(host);
          return outHTML;
        }catch(e){
          console.error('PDF beforeRender error:', e);
          return null;
        }
      }
    });
  });
})();

/* ===== mobile tweaks ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type='button';
          clone.removeAttribute('id');
          clone.addEventListener('click',(e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className='btn';
          fallback.type='button';
          fallback.textContent=label;
          fallback.addEventListener('click',(e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r<10) c.setAttribute('r','12');
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
