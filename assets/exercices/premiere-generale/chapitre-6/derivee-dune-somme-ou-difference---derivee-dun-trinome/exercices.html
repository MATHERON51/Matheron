<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äî Fonctions d√©riv√©es ‚Äî Somme & produit par un r√©el</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}

  /* tableau avec espace horizontal (r√©utilis√© pour les √©tapes) */
  .table.xgap{ border-collapse:separate; border-spacing:22px 0; }
  .table.xgap th,.table.xgap td{ border:1px solid #e5e5e5; padding:10px 14px; white-space:nowrap; }
  @media print{ .table.xgap{ border-spacing:24px 0; } }

  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .step{margin:.2rem 0}
  .line{white-space:nowrap}
  .tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
  .tick.ok{color:#11823b}.tick.ko{color:#b00020}

  .answers{ display:flex; flex-wrap:wrap; gap:.4rem .5rem; }
  .answers .qa-row{ flex-basis:100%; display:flex; align-items:center; gap:.4rem; margin-top:.35rem; }
  .answers .qa-row label{ margin-right:.3rem; }

  @media print{ .controls{display:none !important;} }

  /* espacement lisible des lignes LaTeX */
  .steps .line{ margin:.32rem 0; line-height:1.9 }
  .steps mjx-container{ padding-bottom:.08em }

  @media print{
    .steps .line{ margin:.36rem 0; line-height:2 }
  }
  
  
</style>

<!-- MathJax (SVG, sans Assistive MathML) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)'], ['$', '$']],
      displayMath: [['\\[', '\\]'], ['$$', '$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: {
      skipHtmlTags: ['script','noscript','style','textarea'],
      renderActions: {
        assistiveMml: []   // ‚¨ÖÔ∏è coupe l‚ÄôAssistive MathML (√©vite les r√©p√©titions)
      }
    },
    svg: {
      matchFontHeight: false
    },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-svg.js"></script>

<!-- Ceinture + bretelles : au cas o√π, on masque aussi l‚ÄôAssistive MathML en CSS -->
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem"><strong>1√®re ‚Äì Fonctions d√©riv√©es ‚Äî Somme & produit par un r√©el</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
<li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x¬≤</code>‚Ä¶</li>
<li>Racines : <code>sqrt(‚Ä¶)</code>, <code>rac(‚Ä¶)</code>, <code>‚àö(‚Ä¶)</code>.</li>
<li>Fractions : <code>a/b</code>. Multiplications implicites accept√©es.</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- D√©pendances (projet) -->
  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
  <script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

  <script>
'use strict';

  /* ==== Utils ==== */
  const $  = (s,r)=> (r||document).querySelector(s);
  const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
  let scoreOK=0, scoreTot=0;
  function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
  const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const choice=a=>a[Math.floor(Math.random()*a.length)];
  const UMINUS = (window.DevRules && DevRules.consts && DevRules.consts.UMINUS) || '‚àí';
  function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

  /* ==== Eval clavier ‚Üí JS number ==== */
// ---- remplacER TOUTE la fonction numEval par celle-ci ----
// === (1) GARDER tel quel : ta normalisation racine ===
function normalizeRac(s){
  s = String(s||'');

  // LaTeX -> sqrt(...)
  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  // ----- cas "rac(" sous TOUTES ses formes -----
  // 2rac(...), )rac(...) -> 2*sqrt(...), )*sqrt(...)
  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  // d√©but de cha√Æne ou s√©parateur non-mot avant rac( -> sqrt(
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  // ----- variantes avec le symbole ‚àö -----
  // 2‚àö(...), )‚àö(...) -> 2*sqrt(...), )*sqrt(...)
  s = s.replace(/(\d|\))\s*‚àö\s*\(/g, '$1*sqrt(');
  // 2‚àöx, )‚àöx -> 2*sqrt(x), )*sqrt(x)
  s = s.replace(/(\d|\))\s*‚àö\s*x\b/gi, '$1*sqrt(x)');
  // ‚àö(‚Ä¶) / ‚àöx "nus" -> sqrt(...)
  s = s.replace(/‚àö\s*\(/g,   'sqrt(')
       .replace(/‚àö\s*x\b/gi, 'sqrt(x)');

  // S√©curit√© : ")sqrt(" -> ")*sqrt("
  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');

  // Cas classique du d√©nominateur : 1/(2sqrt(...)) si l‚Äô√©toile manquait encore
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');

  return s;
}
// === (2) REMPLACER TOUTE ta numEval par celle-ci ===
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  // -- normalisations de base
  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');

  // -- normaliser toutes les √©critures de racine (ta fonction)
  s = normalizeRac(s);                 // -> ... sqrt(...)

  // -- puissances : ¬≤ ¬≥ ... -> ^n  puis ^ -> **
  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  // -- convertir sqrt( -> Math.sqrt(
  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  // -- multiplications implicites usuelles
  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  // -- √©toile implicite AVANT une racine d√©j√† convertie
  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')  // 2Math.sqrt( ‚Üí 2*Math.sqrt(
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');        // xMath.sqrt( ‚Üí x*Math.sqrt(

  // -- substitution num√©rique de x
  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }
}

// ---- helpers pour composer du LaTeX propre (sans +0)
function isZeroTex(t){ return /^\s*[+-]?\s*0\s*$/.test(String(t||'')); }
function stripSign(s){ return String(s||'').replace(/^\s*[+]\s*/,'').trim(); }

/** Concat√®ne des termes LaTeX en ignorant ceux √©gaux √† 0. 
 *  terms: array de cha√Ænes (p.ex. ["x^2","-3x","0","1/2"])
 *  Retourne "0" si tout √©tait nul.
 */
function joinTermsNoZero(terms){
  const kept = [];
  for(const raw of (terms||[])){
    const t = String(raw||'').trim();
    if(!t) continue;
    if(isZeroTex(t)) continue;                     // ‚Üê on zappe les 0
    kept.push(t);
  }
  if(kept.length===0) return '0';
  // 1er terme : garder son signe si c'est un vrai "‚àí‚Ä¶", sinon enlever le '+'
  let out = kept[0].startsWith('-') ? kept[0] : stripSign(kept[0]);
  for(let i=1;i<kept.length;i++){
    const t = kept[i].trim();
    out += (t.startsWith('-') ? ' - ' + t.slice(1).trim()
                              : ' + ' + stripSign(t));
  }
  // nettoyage final au cas o√π
  return out.replace(/\s+[+]\s+0\b/g,'').replace(/\s+[-]\s+0\b/g,'').trim();
}


  function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }


// 1) D√©place le signe hors du num√©rateur : \dfrac{-7}{x^2} -> -\dfrac{7}{x^2}
function moveSignOutOfFracNum(lx){
  const re = /\\dfrac\{\s*([+-])\s*(\d+)\s*\}\{\s*(x(?:\^\{\d+\})?)\s*\}/g;
  return String(lx||'').replace(re, (_m, sign, p, den) =>
    (sign === '-' ? '-' : '') + `\\dfrac{${p}}{${den}}`
  );
}

// 2) 2/(2‚àöx) -> 1/‚àöx (d√©j√† propos√© plus haut ; garde-le si tu l'as)
function simplifySqrtHalf(lx){
  return String(lx||'').replace(/\\dfrac\{([+-]?\d+)\}\{2\\sqrt\{x\}\}/g, (_m, nStr) => {
    const n = parseInt(nStr,10);
    if (!Number.isFinite(n) || (n % 2)) return _m;
    const m = n/2;
    if (m === 1)  return '\\dfrac{1}{\\sqrt{x}}';
    if (m === -1) return '-\\dfrac{1}{\\sqrt{x}}';
    return `\\dfrac{${m}}{\\sqrt{x}}`;
  });
}

// 3) pgcd + simplif \dfrac{p}{q} (signe DEVANT, r√©duction, et gestion de x / x^{n})
function _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function simplifyDfracIntInt(lx){
  const re = /\\dfrac\{\s*([+-]?\d+)\s*\}\{\s*([+-]?\d+)\s*\}(\s*x(?:\^\{\d+\})?)?/g;
  return String(lx||'').replace(re, (_m, pStr, qStr, xpart='')=>{
    let p = parseInt(pStr,10), q = parseInt(qStr,10);
    if(!Number.isFinite(p) || !Number.isFinite(q) || q===0) return _m;
    const neg = (p<0) ^ (q<0); p=Math.abs(p); q=Math.abs(q);
    const g = _gcd(p,q); p/=g; q/=g;
    const xp = (xpart||'').trim(); // 'x' ou 'x^{n}' ou ''

    if(q===1){
      const c = neg ? -p : p;      // entier
      if(!xp) return String(c);
      if(c=== 1) return xp;        // 1x -> x ; 1x^{n} -> x^{n}
      if(c===-1) return '-'+xp;    // -1x -> -x ; -1x^{n} -> -x^{n}
      return String(c)+xp;         // 2x, -3x^{4}, ...
    }
    const core = `\\dfrac{${p}}{${q}}`;
    return (neg?'-':'') + core + (xp? xp : '');
  });
}

// 4) Nettoyage des signes juxtapos√©s
function tidySigns(lx){
  let s = String(lx||'');
  const M = '[\\-‚àí]';
  s = s.replace(new RegExp('\\+\\s*'+M, 'g'), ' - ');
  s = s.replace(new RegExp(M+'\\s*'+M, 'g'), ' + ');
  s = s.replace(/\+\s*\+/g, ' + ');
  return s.trim();
}

// 5) Supprimer toute apparition de 1x / -1x (s√©curit√© finale)
function stripUnitCoeff(lx){
  let s = String(lx||'');
  s = s.replace(/(^|[+\-]\s*)1(?=x(\^\{\d+\})?)/g, '$1');   // 1x -> x
  s = s.replace(/(^|[+\-]\s*)-1(?=x(\^\{\d+\})?)/g, '$1-'); // -1x -> -x
  return s;
}
function simplifyFracIntXOverInt(lx){
  const re = /\\dfrac\{\s*([+-]?\d+)\s*x(?:\^\{(\d+)\})?\s*\}\{\s*([+-]?\d+)\s*\}/g;
  return String(lx||'').replace(re, (_m, pStr, exp, qStr)=>{
    let p = parseInt(pStr,10), q = parseInt(qStr,10);
    if(!Number.isFinite(p) || !Number.isFinite(q) || q===0) return _m;
    const neg = (p<0) ^ (q<0);
    p = Math.abs(p); q = Math.abs(q);
    const g = _gcd(p,q); p/=g; q/=g;
    const xpow = exp ? `x^{${exp}}` : 'x';
    if(q===1){
      const c = neg ? -p : p;
      if(c=== 1)  return xpow;        // 1x -> x ; 1x^{n} -> x^{n}
      if(c===-1) return '-'+xpow;     // -1x -> -x ; -1x^{n} -> -x^{n}
      return `${c}${xpow}`;           // 2x, -3x^{4}, ‚Ä¶
    }
    const frac = `\\dfrac{${p}}{${q}}`;
    return (neg?'-':'') + frac + xpow; // signe DEVANT la fraction
  });
}

// 6) Pipeline complet de simplification (pour afficher la version "simple")
function simplifyAll(lx){
  return tidySigns(
           stripUnitCoeff(
             simplifyDfracIntInt(        // \dfrac{p}{q} (avec √©ventuel ‚Äúx‚Äù APRES la fraction)
               simplifyFracIntXOverInt(  // \dfrac{p x^{n}}{q}  ‚Üê NOUVEAU
                 simplifySqrtHalf(
                   moveSignOutOfFracNum(String(lx||''))
                 )
               )
             )
           )
         );
}




  /* ==== G√©n√©ration LaTeX simple ==== */
  const tPow = (k)=> k===1?'x' : (k===-1?'\\frac{1}{x}': (k===2?'x^{2}': (k===3?'x^{3}': (k===4?'x^{4}': (k===5?'x^{5}':`x^{${k}}`)))));
  const tAx  = (a)=> a===1?'x':(a===-1?'-x':`${a}x`);
  const tConst = (c)=> String(c);
  const tSqrt = ()=> '\\sqrt{x}';

  /* ==== Banque de briques usuelles ==== */
  const BRICKS = {
    polyTerm(){ // ax^n avec n>=0
      const n = choice([1,1,1,2,2,3,4,5]);
      const a = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      return {
        latex: a===1 ? tPow(n) : (a===-1 ? ('-'+tPow(n)) : `${a}${n>=2?'x^{'+n+'}':'x'}`),
        f: x => a*(n===0?1:Math.pow(x,n)),
        fp: x => a*n*Math.pow(x,Math.max(0,n-1)),
        latex_fp: ()=>{
          if(n===0) return '0';
          if(n===1) return String(a);
          const coef = a*n;
          if(n===2) return coef===1?'2x':(coef===-1?'-2x':`${coef}x`);
          return (coef===1?'' : (coef===-1?'-':String(coef))) + `x^{${n-1}}`;
        },
rule: "\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}"

      };
    },
    sqrtX(k=1){ // k*sqrt(x)
      const a = (typeof k==='number')?k:choice([-5,-3,-2,-1,1,2,3,5]);
      return {
        latex: a===1?'\\sqrt{x}': (a===-1?`-${tSqrt()}`:`${a}\\,${tSqrt()}`),
        f: x => a*Math.sqrt(x),
        fp: x => a*(1/(2*Math.sqrt(x))),
latex_fp: ()=> {
  const a = (typeof k==='number') ? k : 1;
  // forme volontairement NON simplifi√©e (application) : a/(2‚àöx)
  return `\\dfrac{${a}}{2\\sqrt{x}}`;
},

rule: "\\text{Si } f(x)=\\sqrt{x} \\text{ alors } f'(x)=\\dfrac{1}{2\\sqrt{x}}"
      };
    },
    invX(k=1){ // k*(1/x)
      const a = (typeof k==='number')?k:choice([-5,-3,-2,-1,1,2,3,5]);
      return {
        latex: a===1?'\\dfrac{1}{x}': (a===-1?`-${'\\dfrac{1}{x}'}`:`\\dfrac{${a}}{x}`),
        f: x => a*(1/x),
        fp: x => a*(-1/(x*x)),
// k * (1/x)  ->  (f)' = k * (-1/x^2) = -(k)/x^2
latex_fp: ()=> {
  const num = -(typeof k === 'number' ? k : 1);      // = -k
  if (num === 0) return '0';
  const abs = Math.abs(num);
  if (abs === 1) return (num < 0) ? '-\\dfrac{1}{x^{2}}' : '\\dfrac{1}{x^{2}}';
  return (num < 0) ? `-\\dfrac{${abs}}{x^{2}}` : `\\dfrac{${abs}}{x^{2}}`;
},
rule: "\\text{Si } f(x)=\\dfrac{1}{x} \\text{ alors } f'(x)=-\\dfrac{1}{x^{2}}"
      };
    },
    constant(){ // c
      const c = choice([-7,-5,-3,-2,-1,0,1,2,3,5,7, ' \\sqrt{2} ']);
      const isRoot = (''+c).includes('\\sqrt');
      return {
        latex: isRoot?'\\sqrt{2}':String(c),
        f: x => isRoot?Math.sqrt(2):Number(c),
        fp: _ => 0,
        latex_fp: ()=> '0',
rule: "\\text{Si } f(x)=k \\text{ alors } f'(x)=0"
      };
    }
  };

  /* ==== Constructeurs d‚Äôexercices ==== */

  // 1) Polyn√¥me
  function genPoly(){
    const r = Math.random();
    let deg;
    if (r < 0.50) deg = 2;       // 50% degr√© 2
    else if (r < 0.80) deg = 3;  // 30% degr√© 3
    else deg = rnd(4,6);         // 20% degr√© >=4
    // coef a_deg ‚â† 0 ; autres coefs quelconques (quelques z√©ros possibles)
    const coefs = Array.from({length:deg+1},(_,i)=> (i===deg? choice([-3,-2,-1,1,2,3]) : rnd(-6,6)));
    // f, f'
       


	const f = x => coefs.reduce((s,a,i)=> s + a*Math.pow(x,i), 0);
    const fp = x => coefs.slice(1).reduce((s,a,i)=> s + a*(i+1)*Math.pow(x,i), 0);
    // LaTeX f
    const t = [];
    for(let i=deg;i>=0;i--){
      const a = coefs[i];
      if(a===0) continue;
      let seg='';
      if(i===0){ seg = String(Math.abs(a)); }
      else if(i===1){ seg = (Math.abs(a)===1)?'x':`${Math.abs(a)}x`; }
      else{ seg = (Math.abs(a)===1)?`x^{${i}}`:`${Math.abs(a)}x^{${i}}`; }
      t.push((a<0?'-':'+') + ' ' + seg);
    }
    const latexF = (t.length? t.join(' ') : '0').replace(/^\+\s*/,'');
    // LaTeX f'
    const tt=[];
    for(let i=deg;i>=1;i--){
      const a = coefs[i]*i;
      if(a===0) continue;
      let seg='';
      if(i-1===0){ seg = String(Math.abs(a)); }
      else if(i-1===1){ seg = (Math.abs(a)===1)?'x':`${Math.abs(a)}x`; }
      else{ seg = (Math.abs(a)===1)?`x^{${i-1}}`:`${Math.abs(a)}x^{${i-1}}`; }
      tt.push((a<0?'-':'+') + ' ' + seg);
    }
const latexFp = joinTermsNoZero(tt.map(seg => seg)); // o√π tt √©tait d√©j√† ta liste de segments sign√©s
const latexFp_raw = latexFp;                 // ta construction actuelle
const latexFp_s   = simplifyAll(latexFp_raw);


const rules = [[
  "\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}",
  "\\text{Somme : } (u+v)'=u'+v'",
  "\\text{Si } f(x)=k \\text{ alors } f'(x)=0"
]];
return { title:`Exercice 1 ‚Äî Polyn√¥me (degr√© ${deg})`,
         latexF, latexFp: latexFp_s, latexFp_raw, f, fp, rules };
  }

  // 2) Somme de fonctions usuelles
  function genSumUsuelle(){
    // mod√®le : somme de 2 √† 3 briques usuelles
    const bank = [
      // proches de tes captures
      [BRICKS.polyTerm(), BRICKS.constant()],
      [BRICKS.polyTerm(), BRICKS.polyTerm(), BRICKS.constant()],
      [BRICKS.polyTerm(), BRICKS.sqrtX(), BRICKS.constant()],
      [BRICKS.polyTerm(), BRICKS.invX(), BRICKS.constant()],
      [BRICKS.polyTerm(), BRICKS.invX(), BRICKS.sqrtX()],
    ];
    const parts = choice(bank);
    const f = x => parts.reduce((s,b)=> s + b.f(x), 0);
    const fp = x => parts.reduce((s,b)=> s + b.fp(x), 0);
const latexF = tidySigns( stripUnitCoeff( simplifyDfracIntInt( joinTermsNoZero(parts.map(p=>p.latex)) ) ) );


const latexFp_raw = joinTermsNoZero(parts.map(p => p.latex_fp())); // forme non simplifi√©e
const latexFp     = simplifyAll(latexFp_raw);                      // forme simplifi√©e (pour compat)


    const rules = parts.map(p=>[p.rule, 'Somme : (u+v)\' = u\' + v\'']);

return { title:'Exercice 2 ‚Äî Somme de fonctions usuelles',
         latexF, latexFp, latexFp_raw, f, fp, rules };

  }

 // ---------- helpers sp√©cifiques √† l'exo 3 ----------
const INT = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
const CH  = A => A[Math.floor(Math.random()*A.length)];
const NZ  = (A)=> CH(A.filter(x=>x!==0));
const DENOMS = [2,3,4,5,6];

function makeAxn(a,n){ // a*x^n
  const abs = Math.abs(a);
  return {
    latex: (abs===1? (a<0?'-':'') : String(a)) + (n===1?'x':`x^{${n}}`),
    f:  x => a*Math.pow(x,n),
    fp: x => a*n*Math.pow(x,n-1),
    latex_fp: ()=>{
      const c = a*n;
      const ab = Math.abs(c);
      if(n-1===0) return String(c);
      if(n-1===1) return (ab===1 ? (c<0?'-':'')+'x' : `${c}x`);
      return (ab===1? (c<0?'-':'') : String(c)) + `x^{${n-1}}`;
    },
    rule:"\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}"
  };
}

function makeConst(b){
  return {
    latex:String(b),
    f:_=>b, fp:_=>0,
    latex_fp:()=> '0',
    rule:"\\text{Si } f(x)=k \\text{ alors } f'(x)=0"
  };
}

function makeLin(a){ // a*x
  return {
    latex: (a===1?'x':(a===-1?'-x':`${a}x`)),
    f:x=>a*x, fp:_=>a,
    latex_fp:()=> String(a),
    rule:"\\text{Si } f(x)=mx \\text{ alors } f'(x)=m"
  };
}

function fracOfSum(parts,q){ // (sum)/q
  const Fsum  = joinTermsNoZero(parts.map(p=>p.latex));
  const FPsum = joinTermsNoZero(parts.map(p=>p.latex_fp()));
  return {
    latex: `\\dfrac{${Fsum}}{${q}}`,
    f: x => parts.reduce((s,p)=>s+p.f(x),0)/q,
    fp:x => parts.reduce((s,p)=>s+p.fp(x),0)/q,
    latex_fp: ()=> `\\dfrac{${FPsum}}{${q}}`,
    rule:"\\text{Produit par un r√©el : } (k\\,u)'=k\\,u'"
  };
}
// -----------------------------------------------------

function genLinComb(){
  // coefficients al√©atoires
  const a = NZ([-5,-4,-3,-2,-1,1,2,3,4,5]);
  const b = CH([-7,-5,-3,-2,-1,0,1,2,3,5,7]);
  const c = NZ([-5,-3,-2,-1,1,2,3,5]);
  const d = CH([2,3,4,5,6,7,8,9]);
  const k = NZ([-3,-2,-1,1,2,3]);
  const m = NZ([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);

  // banque de patrons 100% random (12 variantes)
  const patterns = [

    // 1) k¬∑sqrt(x) + a¬∑x + b
    ()=> [ BRICKS.sqrtX(k), makeLin(a), makeConst(b) ],

    // 2) x‚àöc + a¬∑x + b   (c ‚àà {2,3,5,6,7})
    ()=> {
      const cpos = CH([2,3,5,6,7]);
      const p1 = { latex:`x\\sqrt{${cpos}}`, f:x=>x*Math.sqrt(cpos), fp:_=>Math.sqrt(cpos), latex_fp:()=>`\\sqrt{${cpos}}`, rule:"\\text{Si } f(x)=x \\text{ alors } f'(x)=1" };
      return [ p1, makeLin(a), makeConst(b) ];
    },

    // 3) x‚àöc  ‚àí d/x + b
    ()=> {
      const cpos = CH([2,3,5,6,7]);
      const p1 = { latex:`x\\sqrt{${cpos}}`, f:x=>x*Math.sqrt(cpos), fp:_=>Math.sqrt(cpos), latex_fp:()=>`\\sqrt{${cpos}}`, rule:"\\text{Si } f(x)=x \\text{ alors } f'(x)=1" };
      const p2 = BRICKS.invX(-d);
      return [ p1, p2, makeConst(b) ];
    },

    // 4) (x^4 + b x^3 + a)/q
    ()=> {
      const q = CH(DENOMS);
      return [ fracOfSum([ makeAxn(1,4), makeAxn(NZ([-5,-4,-3,-2,-1,1,2,3,4,5]),3), makeConst(a) ], q) ];
    },

    // 5) (a x + b)/q
    ()=> { const q=CH(DENOMS); return [ fracOfSum([ makeLin(a), makeConst(b) ], q) ]; },

    // 6) (p/q)x^4 + (r/s)x
    ()=> {
      const q1=CH(DENOMS), q2=CH(DENOMS);
      const p = NZ([-3,-2,-1,1,2,3]); const r = NZ([-3,-2,-1,1,2,3]);
      const t1 = { latex:`\\dfrac{${p}}{${q1}}x^{4}`, f:x=> (p/q1)*x**4, fp:x=> (4*p/q1)*x**3, latex_fp:()=> `\\dfrac{${4*p}}{${q1}}x^{3}`, rule:"\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}" };
      const t2 = { latex:`\\dfrac{${r}}{${q2}}x`,   f:x=> (r/q2)*x,   fp:_=> r/q2,        latex_fp:()=> `\\dfrac{${r}}{${q2}}`, rule:"\\text{Si } f(x)=x \\text{ alors } f'(x)=1" };
      return [ t1, t2 ];
    },

    // 7) (x^3)/q1 + m x^2 + b
    ()=> {
      const q1=CH(DENOMS);
      const t1 = { latex:`\\dfrac{x^{3}}{${q1}}`, f:x=>x**3/q1, fp:x=> (3/q1)*x**2, latex_fp:()=> `\\dfrac{3}{${q1}}x^{2}`, rule:"\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}" };
      return [ t1, makeAxn(m,2), makeConst(b) ];
    },

    // 8) (a x^n + b)/q  avec n ‚àà {2,3,4}
    ()=> {
      const n = CH([2,3,4]), q=CH(DENOMS);
      return [ fracOfSum([ makeAxn(a,n), makeConst(b) ], q) ];
    },

    // 9) k¬∑sqrt(x) + d/x + b
    ()=> [ BRICKS.sqrtX(k), BRICKS.invX(d), makeConst(b) ],

    // 10) d/x + m x^2 + b
    ()=> [ BRICKS.invX(d), makeAxn(m,2), makeConst(b) ],

    // 11) t¬∑(sqrt(x) + a x) + b   (t ‚àà {-3..3}\{0})
    ()=> {
      const t = NZ([-3,-2,-1,1,2,3]);
      const s1 = BRICKS.sqrtX(t);
      const s2 = makeLin(t*a);
      return [ s1, s2, makeConst(b) ];
    },

    // 12) a x^2 + k sqrt(x) + d/x   (sans constante)
    ()=> [ makeAxn(a,2), BRICKS.sqrtX(k), BRICKS.invX(d) ],
  ];

  const parts = CH(patterns)();

  const f  = x => parts.reduce((s,p)=> s + p.f(x), 0);
  const fp = x => parts.reduce((s,p)=> s + p.fp(x), 0);

const latexF = tidySigns( stripUnitCoeff( simplifyDfracIntInt( joinTermsNoZero(parts.map(p=>p.latex)) ) ) );

const latexFp_raw = joinTermsNoZero(parts.map(p => p.latex_fp()));
const latexFp     = simplifyAll(latexFp_raw);



  const rules   = parts.map(p => [p.rule||'', "\\text{Somme : } (u+v)'=u'+v'"]);

return { title:'Exercice 3 ‚Äî Somme et produit par un r√©el',
         latexF, latexFp, latexFp_raw, f, fp, rules };
}


  /* ==== Affichage / V√©rification / Solution ==== */
function buildHostHTML(st){
  const fClean = joinTermsNoZero([st.latexF]);     // ‚Üê prot√®ge l‚Äô√©nonc√©
  const fpClean = joinTermsNoZero([st.latexFp]);   // ‚Üê prot√®ge si besoin
  return `
    <div class="card">
      <div><strong>Exercice :</strong> Soit la fonction \\(f\\) d√©finie par : \\(f(x)=${fClean}\\). <br>Donner sa fonction d√©riv√©e d√©finie par : </div>
      <div class="answers">
        <div class="qa-row">
          <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansF" class="inp" placeholder="" style="min-width:360px">
          <span id="tickF" class="tick" style="margin-left:6px"></span>
        </div>
      </div>
    </div>
    <div id="res"></div>
  `;
}


  function setTick(host, ok){
    const el = $('#tickF', host);
    if(!el) return;
    el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
    el.textContent = ok===true?'‚úì': ok===false?'‚úó':'‚Äî';
  }

function checkAnswer(st, val){
  if(!val || !String(val).trim()) return null;
  if(typeof st?.fp !== 'function') return false;   // ‚Üê garde-fou
  const xs = [1.2, 1.8, 2.5, 3.7, 5.1];
  try{
    for(const x of xs){
      const got = numEval(val, x);
      const ref = st.fp(x);
      if(!Number.isFinite(got) || !Number.isFinite(ref) || !almost(got, ref, 1e-6)) return false;
    }
    return true;
  }catch(_){ return false; }
}


function solutionHTML(st){
  const rows = [];
  const seen = new Set();
  (st.rules||[]).forEach(pair=>{
    const rule = pair[0]||'';
    if(rule && !seen.has(rule)) { rows.push(`<tr><td><em>R√®gle</em></td><td>\\(${rule}\\)</td></tr>`); seen.add(rule); }
  });

  const fpRaw  = st.latexFp_raw || st.latexFp || '';
  const fpSimp = simplifyAll(fpRaw);

  // 1) Application = forme brute (non simplifi√©e)
  rows.push(`<tr><td><em>Application</em></td><td>\\(f'(x) = ${fpRaw}\\)</td></tr>`);

  // 2) Ajouter "Simplification" UNIQUEMENT si √ßa change vraiment
  const showSimp = tidySigns(fpRaw) !== tidySigns(fpSimp);
  if (showSimp){
    rows.push(`<tr><td><em>Simplification</em></td><td>\\(f'(x) = ${fpSimp}\\)</td></tr>`);
  }

  return `
    <div class="steps">
      <table class="table xgap">
        <thead><tr><th style="text-align:center">Justification</th><th style="text-align:center">√âcriture</th></tr></thead>
        <tbody>${rows.join('')}</tbody>
      </table><br>
      <div class="line"><strong>Conclusion :</strong> \\(\\;f'(x) = ${fpSimp}\\).</div>
    </div>
  `;
}



  /* ==== D√©finition des exercices ==== */
  const EXO1 = { id:'poly', title:'Exercice 1 ‚Äî Polyn√¥me',
gen(host){
  const st = genPoly(); // ou genSumUsuelle / genLinComb
  host.innerHTML = buildHostHTML(st);

  // ‚úÖ garder l'√©tat VIVANT (avec fonctions) pour la v√©rif
  host.__state = st;

  // ‚úÖ dataset : version "light" sans fonctions (utile au PDF)
  host.dataset.state = JSON.stringify({ latexF: st.latexF, latexFp: st.latexFp, rules: st.rules || [] });

  if (window.MathJax?.typeset) MathJax.typeset();
},
    correct(host, st){ const val=$('#ansF',host)?.value||''; const ok=checkAnswer(st,val); scoreTot+= (val.trim()?1:0); scoreOK+= (ok?1:0); updateScore(); setTick(host, val.trim()?ok:null); },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTick(host,null); }
  };
  const EXO2 = { id:'sum', title:'Exercice 2 ‚Äî Somme de fonctions usuelles',
gen(host){
  const st = genSumUsuelle(); 
  host.innerHTML = buildHostHTML(st);

  // ‚úÖ garder l'√©tat VIVANT (avec fonctions) pour la v√©rif
  host.__state = st;

  // ‚úÖ dataset : version "light" sans fonctions (utile au PDF)
  host.dataset.state = JSON.stringify({ latexF: st.latexF, latexFp: st.latexFp, rules: st.rules || [] });

  if (window.MathJax?.typeset) MathJax.typeset();
},
    correct(host, st){ const val=$('#ansF',host)?.value||''; const ok=checkAnswer(st,val); scoreTot+= (val.trim()?1:0); scoreOK+= (ok?1:0); updateScore(); setTick(host, val.trim()?ok:null); },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTick(host,null); }
  };
  const EXO3 = { id:'lin', title:'Exercice 3 ‚Äî Somme et produit par un r√©el',
gen(host){
  const st = genLinComb();
  host.innerHTML = buildHostHTML(st);

  // ‚úÖ garder l'√©tat VIVANT (avec fonctions) pour la v√©rif
  host.__state = st;

  // ‚úÖ dataset : version "light" sans fonctions (utile au PDF)
  host.dataset.state = JSON.stringify({ latexF: st.latexF, latexFp: st.latexFp, rules: st.rules || [] });

  if (window.MathJax?.typeset) MathJax.typeset();
},
    correct(host, st){ const val=$('#ansF',host)?.value||''; const ok=checkAnswer(st,val); scoreTot+= (val.trim()?1:0); scoreOK+= (ok?1:0); updateScore(); setTick(host, val.trim()?ok:null); },
    solution(host, st){ $('#res',host).innerHTML = solutionHTML(st); if (window.MathJax?.typeset) MathJax.typeset(); },
    reset(host){ $('#res',host).textContent=''; setTick(host,null); }
  };

  const REG = [EXO1, EXO2, EXO3];
  window.REG=REG; window.REGISTRY=REG;

  /* ==== Montage UI ==== */
  function mount(){
    const sel=$("#exo-select"); if(!sel) return;
    sel.innerHTML=REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');
    function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
    function newOne(){ const ex=get(); const host=$("#host"); ex.gen(host); scanFractions(host); }
function check(){ const ex=get(); const host=$("#host"); ex.correct(host, host.__state); }
function sol(){ const ex=get(); const host=$("#host"); ex.solution(host, host.__state); }
function reset(){ const ex=get(); const host=$("#host"); ex.reset(host); }



    sel.onchange=newOne;
    $("#btn-new").onclick=newOne;
    $("#btn-check").onclick=check;
    $("#btn-solution").onclick=sol;
    $("#btn-reset").onclick=reset;

    document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});
    sel.value=REG[0].id; newOne();
  }
  document.addEventListener('DOMContentLoaded', mount);
  </script>

  <!-- === Adaptateur PDF (copie exacte de la zone .steps) === -->
  <script>
  (function(){
    document.addEventListener('DOMContentLoaded', function () {
      if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
      ExoPDF.init({
        title: document.title,
        mountAfterSelector: '#host',
        beforeGen(def, _st, ctx){
          const host = document.createElement('div');
          if (def && typeof def.gen === 'function') def.gen(host);
          let st = {};
          try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
          return st;
        },
        beforeRender(def, st, withSolutions){
          try{
            const host = document.createElement('div');
            host.id = 'pdf-host';
            host.style.position='fixed'; host.style.left='-10000px'; host.style.top='-10000px';
            document.body.appendChild(host);

            host.innerHTML = (typeof window.buildHostHTML === 'function') ? buildHostHTML(st) : '';
            host.dataset.state = JSON.stringify(st);

            if (withSolutions && def && typeof def.solution === 'function'){
              def.solution(host, st);
            }

            (host.querySelectorAll('input, textarea, select, [contenteditable="true"]')||[])
              .forEach(el=>{ const t = document.createTextNode(el.value||' '); el.replaceWith(t); });

            const outHTML = withSolutions
              ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
              : host.innerHTML;

            document.body.removeChild(host);
            return outHTML;
          }catch(e){ console.error('PDF beforeRender error:', e); return null; }
        }
      });
    });
  })();
  </script>

<!-- === SHIM universel (inchang√©) === -->
<script>
(function(){
  function isHost(x){ return x && x.nodeType===1; }
  function scaffold(host){
    if(!host) return;
    ['enonce','res','solution','statement'].forEach(function(id){
      if(!host.querySelector('#'+id)){ var d=document.createElement('div'); d.id=id; host.appendChild(d); }
    });
  }
  function wrapDef(def){
    if(!def || typeof def!=='object') return;

    // Wrap gen
    var oldGen = def.gen;
    if(typeof oldGen==='function'){
      def.gen = function(a,b){
        if(isHost(a)) return oldGen.call(this, a, b);
        var st = (a && typeof a==='object') ? a : (b && typeof b==='object' ? b : {});
        var host = document.createElement('div');
        scaffold(host);
        var r = oldGen.call(this, host, st);
        if(!host.dataset.state) try{ host.dataset.state = JSON.stringify(st||{}); }catch(_){}
        return host;
      };
      if(typeof def.render!=='function'){
        def.render = function(host, st){ scaffold(host); return oldGen.call(this, host, st); };
      }
    }

    var oldSol = def.solution;
    if(typeof oldSol==='function'){
      def.solution = function(a,b){
        if(isHost(a)) return oldSol.call(this, a, b);
        var st = (a && typeof a==='object') ? a : (b && typeof b==='object' ? b : {});
        var host = document.createElement('div'); scaffold(host);
        return oldSol.call(this, host, st);
      };
    }
  }

  function apply(){
    var list = (window.REGISTRY || window.REG || []);
    if(Array.isArray(list)) list.forEach(wrapDef);
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', apply); else apply();
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>