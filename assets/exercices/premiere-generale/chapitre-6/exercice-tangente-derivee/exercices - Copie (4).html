<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äî Fonctions d√©riv√©es : D√©riv√©es et tangentes</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc d'√©tapes solution */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{
  white-space:nowrap;
  line-height:1.8;
  margin:.32rem 0;
}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:flex-start;
  column-gap:.4rem;
  row-gap:.2rem;
  flex-wrap:wrap;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
  white-space:nowrap;
}

@media print{ .controls{display:none !important;} }

/* on calme MathJax CHTML en inline */
mjx-container{
  line-height:1.2;
  font-size:1em;
  vertical-align:middle;
}
.steps mjx-container{
  padding-bottom:.08em;
}
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
  mjx-container{font-size:1em; line-height:1.2}
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}

/* table mini rappel */
.sysTab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.sysTab td{
  border:none;
  padding:4px 18px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
.sysTab td.eq{
  padding-right:4px;
}


/* mini-table u,v / u',v' */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}

.MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

<!-- MathJax pour l'√©cran (CHTML) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<!-- FIN MathJax √©cran -->

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1√®re ‚Äì Fonctions d√©riv√©es : D√©riv√©es et tangentes</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
    <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
    <button id="btn-solution" class="btn">üí° Solution</button>
    <button id="btn-reset" class="btn">üßπ R√©initialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; r√©ponses accept√©es :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^2</code>, <code>x^3</code>, <code>x¬≤</code>, etc.</li>
      <li>Parenth√®ses recommand√©es autour des fractions ou des quotients.</li>
      <li>Pour plusieurs abscisses, s√©pare-les par <code>;</code> (ex : <code>1 ; -2</code>).</li>
      <li>Tu peux √©crire <code>non</code> (ou laisser vide) si aucune tangente ne v√©rifie la condition demand√©e.</li>
      <li>Interdits : <code>1x</code> (√©crire <code>x</code>) ; <code>0x</code> ; <code>+0</code>.</li>
    </ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- D√©pendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';
// --- mode de g√©n√©ration pour l'exercice Tangentes ---
// "mix" = al√©atoire comme avant
// "deg2" = impose polyn√¥me degr√© 2
// "deg3" = impose polyn√¥me degr√© 3 (avec Œî)
let modeTangentes = 'mix';
let modeCoeffs = 'mix2'; 

/* =========================================================
   Utils
   ========================================================= */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));

let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }

function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

/* mini parse pour listes d'abscisses fournies par l'√©l√®ve */
function parseAbscissaList(str){
  if(!str) return [];
  str = String(str).trim();

  // mots-cl√©s pour "aucune solution"
  if(/^(non|aucun|aucune|rien)$/i.test(str)) return [];

  // on s√©pare ; ou ,
  return str
    .split(/[,;]+/)
    .map(s => s.trim())
    .filter(s => s!=='')
    .map(s => {
      // g√©rer les fractions type "3/2"
      const m = s.match(/^(-?\d+)\s*\/\s*(-?\d+)$/);
      if(m){
        const num = Number(m[1].replace(',','.'));
        const den = Number(m[2].replace(',','.'));
        if(den!==0){
          return num/den;
        } else {
          return NaN;
        }
      }
      // sinon nombre d√©cimal style "1.5" ou "1,5"
      return Number(s.replace(',','.'));
    })
    .filter(v => Number.isFinite(v));
}

function fracToNumberObj(fr){
  // fr du type {num:..., den:...}
  if(!fr || typeof fr.num!=='number' || typeof fr.den!=='number') return NaN;
  return fr.num / fr.den;
}


function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }

/* √©val simple de polyn√¥me affine */
function evalAffine(A,B,x){ return A*x+B; }

/* solve 2ax+b = k  => x = (k-b)/(2a)  si a!=0 */
function solveSlopeEq(a,b,k){
  const den = 2*a;
  if(den===0) return []; // d√©riv√©e est constante -> ou pas de solution ou infiniment
  const x0 = (k-b)/den;
  return [x0];
}

/* format latex d'un polyn√¥me ax^2+bx+c (en enlevant 0x, +0, 1x -> x, -1x -> -x) */
function quadToLatex(a,b,c){
  const parts=[];
  // ax^2
  if(a!==0){
    const aa = Math.abs(a);
    const m2 = (aa===1? 'x^{2}' : aa+'x^{2}');
    parts.push((a<0?'- ':'+ ')+m2);
  }
  // bx
  if(b!==0){
    const bb = Math.abs(b);
    const m1 = (bb===1? 'x' : bb+'x');
    parts.push((b<0?'- ':'+ ')+m1);
  }
  // c
  if(c!==0 || parts.length===0){
    const cc = Math.abs(c);
    parts.push((c<0?'- ':'+ ')+cc);
  }
  return parts.join(' ').replace(/^\+\s*/,'').trim();
}

/* f'(x)=2ax+b en latex */
function quadDerivLatex(a,b){
  // 2ax+b
  const A = 2*a;
  const B = b;
  const out=[];
  if(A!==0){
    const AA=Math.abs(A);
    const mono = (AA===1? 'x' : AA+'x');
    out.push((A<0?'- ':'+ ')+mono);
  }
  if(B!==0 || !out.length){
    const BB=Math.abs(B);
    out.push((B<0?'- ':'+ ')+BB);
  }
  return out.join(' ').replace(/^\+\s*/,'').trim();
}

/* affichage latex d'une droite y = m x + p */
function lineLatex(m,p){
  // y = mx + p  (sans 1x ni +0)
  const terms=[];
  if(m!==0){
    const mm=Math.abs(m);
    const mono=(mm===1? 'x' : mm+'x');
    terms.push( (m<0?'- ':'')+mono );
  }
  if(p!==0 || !terms.length){
    const pp=Math.abs(p);
    terms.push( (p<0?'- ':'+ ')+pp );
  }
  let rhs=terms.join(' ').replace(/^\+\s*/,'').trim();
  return 'y = '+rhs;
}

/* ===== normalisation / √©val saisie ===== */
function normalizeRac(s){
  s = String(s||'');

  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  s = s.replace(/(\d|\))\s*‚àö\s*\(/g, '$1*sqrt(');
  s = s.replace(/(\d|\))\s*‚àö\s*x\b/gi, '$1*sqrt(x)');
  s = s.replace(/‚àö\s*\(/g,   'sqrt(')
       .replace(/‚àö\s*x\b/gi, 'sqrt(x)');

  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
  return s;
}
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');
  s = normalizeRac(s);

  // puissances "¬≤" -> "^2" -> "**2"
  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }

}




function numEvalExpr(expr, x){
  if(!expr) return NaN;
  let s = String(expr);

  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');
  s = normalizeRac(s);

  // 1. enlever espaces
  s = s.replace(/\s+/g,'');

  // 2. enlever √©ventuel "g'(x)=" "g(x)=" etc au d√©but
  s = s.replace(/^[a-zA-Z]['‚Äô]?\(x\)=+/,''); // g'(x)=..., g(x)=..., f'(x)==..., etc.

  // 3. normaliser puissances unicodes -> "^"
  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      );

  // 4. remplacer ^ par **
  s = s.replace(/\^/g,'**');

  // 5. remplacements typographiques
  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');

  // 6. sqrt(...)  /  \sqrt{...}
  s = s
    .replace(/\\sqrt\{([^{}]+)\}/g,'Math.sqrt($1)')
    .replace(/sqrt\(/g,'Math.sqrt(');

  // 7. multiplications implicites classiques : 2x -> 2*x, x( -> x*(, )(
  s = s
    .replace(/(\d)(x|\()/g,'$1*$2')
    .replace(/x\(/g,'x*(')
    .replace(/\)\(/g,')*(');

  // 8. fractions a/b -> (a)/(b) pour que Function comprenne bien
  s = s.replace(/([0-9A-Za-z_\)\]])\/([0-9A-Za-z_\(])/g,'($1)/($2)');

  // 9. nettoyer les combinaisons de signes foireuses avant √©val
  //    "+-" -> "-", "-+" -> "-", "--" -> "+", "++" -> "+"
  //    on boucle jusqu'√† stabilisation
  let old;
  do{
    old = s;
    s = s
      .replace(/\+\-/g,'-')
      .replace(/\-\+/g,'-')
      .replace(/\-\-/g,'+')
      .replace(/\+\+/g,'+');
  }while(s!==old);

  // 9bis. coefficient implicite ¬±x, ¬±x^2, etc.
  // transforme "-x" -> "-1*x", "+x" -> "+1*x", "( -x" -> "(-1*x", d√©but de cha√Æne "x" -> "1*x", etc.

  // cas d√©but de cha√Æne : "x" -> "1*x", "-x" -> "-1*x", "+x" -> "+1*x"
  s = s.replace(/^([+\-]?)x\b/g, (m,sign)=>{
    if(sign==='+') return '+1*x';
    if(sign==='-') return '-1*x';
    return '1*x';
  });

  // cas apr√®s un op√©rateur ou parenth√®se : "(x", "+x", "-x", "*x", "/x"
  s = s.replace(/([\+\-\*\/\(])x\b/g, (m,op)=>{
    // si op = '-', on veut "-1*x"
    if(op==='-') return '-1*x';
    if(op==='+') return '+1*x';
    // sinon "(x" -> "(1*x", "*x" -> "*1*x", "/x" -> "/1*x"
    return op + '1*x';
  });


  // 10. remplace x par la valeur num√©rique
  s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g,'(XVAL)');

  // 11. derni√®re s√©curit√© : si √ßa finit par un + ou -, vire
  s = s.replace(/([+\-])$/,''); 

  try{
    return Number(Function("XVAL","return ("+s+");")(x));
  }catch(e){
    return NaN;
  }
}


function insertImplicitOne(s){
  // Objectif :
  //   "-x"   -> "-1*x"
  //   "+x"   -> "+1*x"
  //   "(x"   -> "(1*x"
  //   "*x"   -> "*1*x"
  //   "/x"   -> "/1*x"
  //   "x" tout seul au d√©but -> "1*x"
  //
  // On fait √ßa avant qu'on remplace x par (valeur)
  // et avant qu'on balance √† numEval().

  // d√©but de cha√Æne
  s = s.replace(/^([+\-]?)x\b/g, (m,sign)=>{
    if(sign==='+') return '+1*x';
    if(sign==='-') return '-1*x';
    return '1*x';
  });

  // apr√®s op√©rateur ou parenth√®se
  s = s.replace(/([\+\-\*\/\(])x\b/g, (m,op)=>{
    if(op==='-') return '-1*x';
    if(op==='+') return '+1*x';
    return op + '1*x';
  });

  return s;
}





/* v√©rification √©l√®ve ExoA :
   - champ1 : abscisses // horizontales
   - champ2 : abscisses // parall√®le √† y = m x + p
*/
function checkExoA(st){
  const raw0  = $('#ans0')  ?.value ?? '';
  const raw1a = $('#ans1a') ?.value ?? '';
  const raw1  = $('#ans1')  ?.value ?? '';
  const raw2a = $('#ans2a') ?.value ?? '';
  const raw2  = $('#ans2')  ?.value ?? '';

  const ans1 = parseAbscissaList(raw1);
  const ans2 = parseAbscissaList(raw2);

  const sol1 = st.roots0; // abscisses pente=0
  const sol2 = st.rootsM; // abscisses pente = slopeM

  // garde-fou : s'il manque la d√©riv√©e de r√©f√©rence, on ne traverse pas tout
  if(typeof st.gPrimeEvalFn !== 'function'){
    console.warn('gPrimeEvalFn manquant dans state, impossible de corriger proprement');
  }

  // ===== helpers =====

  // m√™me solutions (ordre libre, tol√©rance flottante)
  function sameSolutions(user, sol){
    if(sol.length===0) return user.length===0;
    if(user.length!==sol.length) return false;
    const U=[...user].sort((a,b)=>a-b);
    const S=[...sol].sort((a,b)=>a-b);
    for(let i=0;i<S.length;i++){
      if(!almost(U[i], S[i], 1e-6)) return false;
    }
    return true;
  }

  // √©value une expression de l'√©l√®ve num√©riquement
  function evalUserExpr(expr, x){
    return numEvalExpr(expr, x); // tu as d√©j√† numEvalExpr dans ce fichier
  }

  // dit si exprUser repr√©sente la m√™me fonction que gPrimeEvalFn
function sameAsDerivative(exprUser){
  if(typeof st.gPrimeEvalFn !== 'function') return false;
  if(!exprUser || !exprUser.trim()) return false;

  // cas trivial : "g'(x)" tout seul -> on consid√®re que √ßa repr√©sente LA d√©riv√©e
  const bare = exprUser.replace(/\s+/g,'');
  if(/^g['‚Äô]?\(x\)$/i.test(bare)) return true;

  // sinon on enl√®ve un √©ventuel "g'(x)=" ou "g(x)=" au d√©but
  const core = exprUser
    .replace(/^\s*[a-zA-Z]['‚Äô]?\s*\(\s*x\s*\)\s*={1,2}\s*/,'')
    .trim();

  const testX = [-2,-1,0,1,2,3];
  for(const x of testX){
    const vUser = numEvalExpr(core, x);
    const vRef  = st.gPrimeEvalFn(x);
    if(!Number.isFinite(vUser) || !Number.isFinite(vRef) || !almost(vUser,vRef,1e-6)){
      return false;
    }
  }
  return true;
}


  // v√©rifie si expr est une constante num√©rique donn√©e = slope
  function isConstSlope(expr, slope){
    if(!expr.trim()) return false;
    const testX = [-2,-1,0,1,2,3];
    for(const x of testX){
      const v = evalUserExpr(expr, x);
      if(!Number.isFinite(v) || !almost(v, slope, 1e-6)){
        return false;
      }
    }
    return true;
  }

  // v√©rifie si "√©quation √† r√©soudre" est du type d√©riv√©e = pente
  // accepte : "g'(x)=0", "-3x^2-2x-3=0", "0=g'(x)", "g'(x)=-2", etc.
  function isGoodEquation(userEq, slope){
    if(!userEq.trim()) return false;
    const clean = userEq.replace(/\s+/g,'').replace(/==/g,'=');
    const parts = clean.split('=');
    if(parts.length!==2) return false;
    const [L,R] = parts;

    const Lderiv = sameAsDerivative(L);
    const Rderiv = sameAsDerivative(R);
    const Lslope = isConstSlope(L, slope);
    const Rslope = isConstSlope(R, slope);

    if(Lderiv && Rslope) return true;
    if(Rderiv && Lslope) return true;
    return false;
  }

  // ===== correction champs =====

  // g'(x)= ?
  let ok0 = null;
  if(raw0.trim()!==''){
    ok0 = sameAsDerivative(raw0);
  }

  // √©quation pente=0
  let ok1a = null;
  if(raw1a.trim()!==''){
    ok1a = isGoodEquation(raw1a, st.slope0);
  }

  // abscisse(s) tangente horizontale
  let ok1 = null;
  if(raw1.trim()!==''){
    ok1 = sameSolutions(ans1, sol1);
  }

  // √©quation pente = slopeM
  let ok2a = null;
  if(raw2a.trim()!==''){
    ok2a = isGoodEquation(raw2a, st.slopeM);
  }

  // abscisse(s) tangente // droite
  let ok2 = null;
  if(raw2.trim()!==''){
    ok2 = sameSolutions(ans2, sol2);
  }

  // ===== affichage ticks =====
  setTick('#tick0',  ok0);
  setTick('#tick1a', ok1a);
  setTick('#tick1',  ok1);
  setTick('#tick2a', ok2a);
  setTick('#tick2',  ok2);

  // score
  let count=0, good=0;
  function tally(ok){
    if(ok===null) return;
    count++;
    if(ok===true) good++;
  }
  tally(ok0);
  tally(ok1a);
  tally(ok1);
  tally(ok2a);
  tally(ok2);

  return {count, good};
}



/* =========================================================
   Helpers repris du style "√©quations du second degr√©"
   (tu en as d√©j√† une partie ; ne duplique pas si d√©j√† d√©fini)
   ========================================================= */

// pgcd + fraction irr√©ductible
function gcdLoc(u,v){
  u=Math.trunc(u); v=Math.trunc(v);
  u=Math.abs(u); v=Math.abs(v);
  while(v){ const t=u%v; u=v; v=t; }
  return u||1;
}
function simpLoc(p,q){
  if(q<0){ p=-p; q=-q; }
  const g=gcdLoc(p,q);
  return [p/g,q/g];
}
function texFracIrred(p,q){
  const [P,Q]=simpLoc(p,q);
  if(Q===1) return `${P}`;
  return `\\dfrac{${P}}{${Q}}`;
}

function isSquareInt(n){
  if(n<0) return false;
  const r = Math.floor(Math.sqrt(n));
  return r*r===n;
}

// √©criture latex d'un polyn√¥me du 2nd degr√© A x¬≤ + B x + C
function polyQuadLatexNum(A,B,C){
  let s='';
  // terme x¬≤
  if(A===1) s='x^{2}';
  else if(A===-1) s='-x^{2}';
  else s=`${A}x^{2}`;

  // terme x
  if(B!==0){
    const seg = (Math.abs(B)===1) ? 'x' : `${Math.abs(B)}x`;
    s += (B>0? ' + ' : ' - ') + seg.replace(/^-/, '');
  }

  // constante
  if(C!==0){
    s += (C>0? ' + ' : ' - ') + String(Math.abs(C));
  }

  return s;
}

// version sans constante C
function polyQuadNoConstLatexNum(A,B){
  let s='';
  if(A===1) s='x^{2}';
  else if(A===-1) s='-x^{2}';
  else s=`${A}x^{2}`;

  if(B!==0){
    const seg = (Math.abs(B)===1) ? 'x' : `${Math.abs(B)}x`;
    s += (B>0? ' + ' : ' - ') + seg.replace(/^-/, '');
  }
  return s;
}

// factorisation x(Ax+B)
function factoredLatexNum(A,B){
  let inside = (A===1) ? 'x'
              : (A===-1) ? '-x'
              : `${A}x`;
  if(B!==0){
    inside += (B>0?' + ':' - ') + String(Math.abs(B));
  }
  return `x\\big(${inside}\\big)`;
}

// √©value g(x)=a x^3+ b x^2+ c x + d √† x = p/q, retourne fraction irr√©ductible
function evalCubicFrac(a,b,c,d,p,q){
  const num = (
    a*p*p*p +
    b*p*p*q +
    c*p*q*q +
    d*q*q*q
  );
  const den = q*q*q;
  return simpLoc(num,den); // [num,den] irr√©ductible
}

// point de contact en LaTeX : (x ; g(x))
function pointTexFrac(p,q,a,b,c,d){
  const [Yn,Yd] = evalCubicFrac(a,b,c,d,p,q);
  return `\\(\\left(${texFracIrred(p,q)}\\,;\\,${texFracIrred(Yn,Yd)}\\right)\\)`;
}

// teste si k = num/den est un carr√© rationnel parfait >=0
// renvoie {ok, roots:[[p,q],[‚àíp,q]]}
function rationalSquareRoots(num,den){
  // signe
  if(den===0) return {ok:false};
  const [P,Q] = simpLoc(num,den); // P/Q
  if(P<0) return {ok:false};      // pas r√©el
  // P et Q doivent √™tre carr√©s parfaits
  if(!isSquareInt(P) || !isSquareInt(Q)) return {ok:false};
  const rP = Math.round(Math.sqrt(P));
  const rQ = Math.round(Math.sqrt(Q));
  const [N,D] = simpLoc(rP,rQ); // racine = ¬± N/D
  return { ok:true, roots:[[ N, D],[ -N, D]] };
}

/* √©criture latex d'une droite y = m x + p */
function lineLatex(m,p){
  // pente m, ordonn√©e √† l'origine p
  // m toujours !=0 dans nos tirages
  let txt = 'y = ';
  // pente
  if(m===1) txt+='x';
  else if(m===-1) txt+='-x';
  else txt+= `${m}x`;
  // + p
  if(p!==0){
    txt += (p>0?' + ':' - ') + Math.abs(p);
  }
  return txt;
}

/* √©criture latex du cubique g(x)=... */
function cubicToLatex(a,b,c,d){
  // a x^3 + b x^2 + c x + d
  let s='';
  // x^3
  if(a===1) s='x^{3}';
  else if(a===-1) s='-x^{3}';
  else s=`${a}x^{3}`;

  // x^2
  if(b!==0){
    const seg = (Math.abs(b)===1) ? 'x^{2}' : `${Math.abs(b)}x^{2}`;
    s += (b>0?' + ':' - ') + seg.replace(/^-/, '');
  }

  // x
  if(c!==0){
    const seg = (Math.abs(c)===1) ? 'x' : `${Math.abs(c)}x`;
    s += (c>0?' + ':' - ') + seg.replace(/^-/, '');
  }

  // constant
  if(d!==0){
    s += (d>0?' + ':' - ') + String(Math.abs(d));
  }

  return s;
}

/* d√©riv√©e g'(x)=3ax^2+2bx+c en latex */
function cubicDerivLatex(a,b,c){
  const A = 3*a;
  const B = 2*b;
  const C = c;
  return polyQuadLatexNum(A,B,C);
}

// ======================================================
// R√©solution "propre lyc√©e" de A x¬≤ + B x + C = 0
// avec mise en forme EXACTEMENT style tes captures d'√©cran
// Retourne { html, rootsFrac }
// - html : bloc <div>...</div> pr√™t √† injecter dans la solution
// - rootsFrac : tableau de racines rationnelles sous forme [p,q] SI Œî>=0
//               (utile pour construire les points de tangence)
// ======================================================

// R√©solution "propre lyc√©e" de A x¬≤ + B x + C = 0
// avec l'affichage EXACT du calcul du discriminant (Œî)
function solveQuadraticPretty(A,B,C) {

  // outils fraction
  function pgcd(u,v){
    u=Math.trunc(u); v=Math.trunc(v);
    u=Math.abs(u); v=Math.abs(v);
    while(v!==0){ const t=u%v; u=v; v=t; }
    return u===0?1:u;
  }
  function simp(p,q){
    if(q<0){ p=-p; q=-q; }
    const g=pgcd(p,q);
    return [p/g,q/g];
  }
  function texFrac(p,q){
    const [P,Q]=simp(p,q);
    if(Q===1) return `${P}`;
    return `\\dfrac{${P}}{${Q}}`;
  }

  // calcul Œî
  const prod4ac = 4 * A * C;
  const b2      = B * B;

  // √©criture du terme b¬≤ avec parenth√®ses si b<0
  // ex : b=-3 -> "(-3)^{2}"
  //      b=4  -> "4^{2}"
  const bSquaredTex = (B < 0)
    ? `(${B})^{2}`
    : `${B}^{2}`;

  // 4 √ó a √ó c avec parenth√®ses autour de a ou c si n√©gatifs
  const prettyProd = `4 \\times ${A<0?`(${A})`:A} \\times ${C<0?`(${C})`:C}`;

  // milieu apr√®s distribution du signe :
  // si 4ac est n√©gatif => b¬≤ + |4ac|
  // si 4ac est positif => b¬≤ - 4ac
  const middle = prod4ac < 0
    ? `${b2} + ${Math.abs(prod4ac)}`
    : `${b2} - ${prod4ac}`;

  const Delta   = b2 - prod4ac;
  const tail    = Delta>0 ? ' > 0' : (Delta<0 ? ' < 0' : ' ');

  // ligne Œî en rouge, style demand√©
  let html = '';
  html += `<div class="line" style="color:#b00020;font-weight:500">` +
          `\\(\\Delta = b^{2} - 4ac = ${bSquaredTex} - ${prettyProd} = ${middle} = ${Delta}${tail}\\)` +
          `</div>`;


  const rootsFrac = [];

  // cas Œî < 0 : pas de solution r√©elle
  if(Delta < 0){
    html += `<div class="line">L‚Äô√©quation n‚Äôadmet pas de solution r√©elle.</div>`;
    return { html, rootsFrac: [] };
  }

  // cas Œî = 0 : une seule racine alpha = -b / (2a)
  if(Delta === 0){
    // alpha = -B / (2A)
    const [p0,q0] = simp(-B, 2*A);

    html += `<div class="line">Donc \\(\\Delta = 0\\) et l‚Äô√©quation admet une seule solution :</div>`;
    html += `<div class="line">\\(\\alpha = \\dfrac{-b}{2a} = \\dfrac{${-B}}{2\\times ${A}} = ${texFrac(p0,q0)}\\)</div>`;

    rootsFrac.push([p0,q0]);
    return { html, rootsFrac };
  }

  // ici Œî > 0
  const sqrtD  = Math.round(Math.sqrt(Math.abs(Delta)));
  const perfect = (sqrtD*sqrtD === Delta);

  // petite phrase d‚Äôencha√Ænement
  // (tu ne veux pas "Et ‚àöŒî = ...", tu veux juste encha√Æner proprement)
  html += `<div class="line">Comme \\( \\)\\(\\Delta > 0\\), l‚Äô√©quation admet deux solutions r√©elles :</div>`;

  // fabrique la colonne de calcul pour x1 / x2
  function buildCol(sign){
    // sign = -1 pour x1 ( -‚àöŒî ), +1 pour x2 ( +‚àöŒî )
    const numSymb   = `-b ${sign<0?'-':'+'} \\sqrt{\\Delta}`;
    const numSubRaw = `${-B} ${sign<0?'-':'+'} ${perfect ? sqrtD : `\\sqrt{${Delta}}`}`;
    const denSymb   = `2a`;
    const denSub1   = `2 \\times ${A}`;
    const denSub2   = `${2*A}`;

    // troisi√®me ligne : on remplace ¬±‚àöŒî num√©riquement si possible
    const numAfterSqrt = perfect
      ? `${-B + sign*sqrtD}`
      : `${-B} ${sign<0?'-':'+'} \\sqrt{${Delta}}`;

    // derni√®re ligne : fraction simplifi√©e si parfaite
    let finalLine;
    if(perfect){
      const [pS,qS] = simp(-B + sign*sqrtD, 2*A);
      rootsFrac.push([pS,qS]);
      finalLine = texFrac(pS,qS);
    }else{
      // Œî pas carr√© parfait ‚áí on garde la forme fractionnelle non simplifi√©e
      finalLine = `\\dfrac{${-B + sign*sqrtD}}{${2*A}}`;
      // (si tu veux ignorer ces racines irrationnelles pour la suite tangente,
      // on ne push pas dans rootsFrac dans ce cas)
    }

    return `
      <div class="line">\\(x = \\dfrac{${numSymb}}{${denSymb}}\\)</div>
      <div class="line">\\(x = \\dfrac{${numSubRaw}}{${denSub1}}\\)</div>
      <div class="line">\\(x = \\dfrac{${numAfterSqrt}}{${denSub2}}\\)</div>
      <div class="line">\\(x = ${finalLine}\\)</div>
    `;
  }

  html += `
    <div style="display:flex;flex-wrap:wrap;gap:1rem;align-items:flex-start;margin-top:.4rem">
      <div style="min-width:240px;border:1px solid #ddd;border-radius:8px;padding:.5rem .8rem;">
        <div style="text-align:center;font-weight:600;margin-bottom:.4rem">\\(x_{1}\\)</div>
        ${buildCol(-1)}
      </div>
      <div style="min-width:240px;border:1px solid #ddd;border-radius:8px;padding:.5rem .8rem;">
        <div style="text-align:center;font-weight:600;margin-bottom:.4rem">\\(x_{2}\\)</div>
        ${buildCol(+1)}
      </div>
    </div>
  `;

  // rootsFrac ne contient que les racines rationnelles jolies (si Œî carr√©)
  const cleaned = rootsFrac.filter(r => Array.isArray(r));
  return { html, rootsFrac: cleaned };
}

// (-3)^{2} ou 2^{2}
function latexPow2(n){
  return (n < 0 ? `(${n})^{2}` : `${n}^{2}`);
}

// "(-3)" ou "3"
function latexMaybeParen(n){
  return (n < 0 ? `(${n})` : `${n}`);
}

// "(-3)" ou "3", mais pens√© pour un facteur isol√© de produit
function latexSignedNum(n){
  // on utilisait √ßa pour b √ó (-3). √áa reste bon.
  return (n < 0 ? `(${n})` : `${n}`);
}

// mon√¥me k*var sans afficher 1a ou -1a
function mono(k, variable){
  if (k === 1)  return variable;
  if (k === -1) return '-' + variable;
  return k + variable;
}

function latexBareNum(n){
  return String(n);
}
function latexPow(n, power){
  return (n < 0 ? `(${n})^{${power}}` : `${n}^{${power}}`);
}

function texTimes(val){
  // renvoie "\times X" o√π X est parenth√©s√© si n√©gatif
  return `\\times ${val < 0 ? `(${val})` : val}`;
}



// fabrique "9a - 3b + c"
function linearComboLatex(Acoef,Bcoef,Ccoef){
  const parts = [];

  if (Acoef !== 0){
    parts.push(mono(Acoef,'a'));
  }

  if (Bcoef !== 0){
    const pieceB = mono(Math.abs(Bcoef),'b'); // "3b" ou "b"
    if (Acoef === 0){
      parts.push(Bcoef < 0 ? '-' + pieceB : pieceB);
    } else {
      parts.push((Bcoef < 0 ? ' - ' : ' + ') + pieceB);
    }
  }

  if (Ccoef !== 0){
    const pieceC = mono(Math.abs(Ccoef),'c'); // "c"
    if (Acoef === 0 && Bcoef === 0){
      parts.push(Ccoef < 0 ? '-' + pieceC : pieceC);
    } else {
      parts.push((Ccoef < 0 ? ' - ' : ' + ') + pieceC);
    }
  }

  return parts.join('').replace(/^\+\s*/,'').trim();
}

function linearComboLatexGeneric(coefs, vars){
  // coefs et vars doivent √™tre align√©s : [Acoef,Bcoef,...], ['a','b',...]
  // retourne une cha√Æne genre "9a - 3b + c - 2d"
  const parts = [];
  for (let i=0;i<coefs.length;i++){
    const k = coefs[i];
    const v = vars[i];
    if (k === 0) continue;

    const piece = mono(Math.abs(k), v); // "9a" ou "a"

    if (parts.length === 0){
      // premier terme
      parts.push(k < 0 ? '-' + piece : piece);
    } else {
      parts.push((k < 0 ? ' - ' : ' + ') + piece);
    }
  }
  return parts.join('').replace(/^\+\s*/,'').trim();
}

/* =========================================================
   G√©n√©rateur cubique propre avec r√©daction style "Œî"
   ========================================================= */

function genExTangentesDegre3(){

  // tirage coefficients "propres"
  let a,b,c,d, prof=null;
  for(let tries=0; tries<400 && !prof; tries++){
    a = choice([-2,-1,1,2]);
    b = rnd(-3,3);
    c = choice([-4,-3,-2,-1,1,2,3,4]); // c‚â†0
    d = rnd(-5,5);

    const A = 3*a;
    const B = 2*b;
    const C = c;

    // m√™mes conditions que tu avais
    if(C===0){
      prof = {kind:"C0",A,B,C,a,b,c,d};
      break;
    }
    if(B===0){
      const num = -C;
      const den = A;
      if(num*den >= 0){
        const test = rationalSquareRoots(Math.abs(num),Math.abs(den));
        if(test.ok){
          prof = {kind:"B0",A,B,C,a,b,c,d,rootsB0:test.roots};
          break;
        }
      }
      continue;
    }

    const Delta = B*B - 4*A*C;
    if(Delta < 0){
      prof = {kind:"DISC",A,B,C,Delta,a,b,c,d};
      break;
    }else if(Delta === 0){
      prof = {kind:"DISC",A,B,C,Delta,a,b,c,d};
      break;
    }else{
      if(isSquareInt(Delta)){
        prof = {kind:"DISC",A,B,C,Delta,a,b,c,d};
        break;
      }
    }
  }

  // fallback
  if(!prof){
    a=1;b=1;c=2;d=0;
    const A=3*a,B=2*b,C=c;
    prof={kind:"DISC",A,B,C,Delta:(B*B-4*A*C),a,b,c,d};
  }

  const {A,B,C} = prof;

  const gLatex = cubicToLatex(a,b,c,d);
  const gPrime = cubicDerivLatex(a,b,c);

  // droite cible pente = c
  const m = c;
  const p0 = rnd(-6,6);
  const droiteLt = lineLatex(m,p0);



function derivTextCubic(a,b,c){
  // g'(x)=3ax^2+2bx+c
  const A = 3*a;
  const B = 2*b;
  const C = c;
  let s='';

  // terme x^2
  if (A !== 0){
    if (A === 1)       { s += 'x^2'; }
    else if (A === -1) { s += '-x^2'; }
    else               { s += A + 'x^2'; }
  }

  // terme x
  if (B !== 0){
    if (B > 0){
      s += (s==='' ? '' : '+') + (B === 1 ? 'x' : (B === -1 ? '-x' : (B+'x')));
    } else {
      // B < 0
      if (B === -1){
        s += (s==='' ? '' : '') + '-x';
      } else {
        s += B + 'x';
      }
    }
  }

  // constante
  if (C !== 0){
    if (C > 0){
      s += (s==='' ? '' : '+') + C;
    } else {
      s += C; // d√©j√† n√©gatif
    }
  }

  if (s==='') s='0';
  return s;
}
const gPrimeText = derivTextCubic(a,b,c);



  // =========================
  // Q1 : tangente horizontale
  // pente = 0 <=> g'(x)=0 <=> A x¬≤ + B x + C = 0
  // On g√©n√®re TON pav√© Œî avec solveQuadraticPretty
  // =========================
  const pretty = solveQuadraticPretty(A,B,C); // {html, rootsFrac}

  // points pour Q1
  let ptsQ1Tex = '\\( \\) \\(\\text{aucun point r√©el.}\\)';
  if(pretty.rootsFrac.length){
    ptsQ1Tex = pretty.rootsFrac.map(([p,q])=>{
      const [Yn,Yd] = evalCubicFrac(a,b,c,d,p,q);
      return `\\(\\left(${texFracIrred(p,q)}\\,;\\,${texFracIrred(Yn,Yd)}\\right)\\)`;
    }).join(' , ');
  }

  // =========================
  // Q2 : tangente // droite y = m x + p0
  // pente m = c
  // On r√©sout g'(x)=c:
  // A x¬≤ + B x + C = c  ‚áî A x¬≤ + B x + (C-c)=0  ‚áî mais comme C=c, √ßa devient A x¬≤ + B x = 0
  // donc x(Ax+B)=0 -> x=0 ou x=-B/A
  // =========================

  const [pRoot,qRoot]=simpLoc(-B,A);
  const texX2 = texFracIrred(pRoot,qRoot);

  const solsQ2Frac = [ [0,1],[pRoot,qRoot] ];
  const ptsQ2Tex = solsQ2Frac.map(([p,q])=>{
    const [Yn,Yd] = evalCubicFrac(a,b,c,d,p,q);
    return `\\(\\left(${texFracIrred(p,q)}\\,;\\,${texFracIrred(Yn,Yd)}\\right)\\)`;
  }).join(' , ');

  const q2BlockHTML = `
    <div class="line stepTitle">2) Tangente parall√®le √† ${droiteLt}</div>
    <div class="line">Une tangente parall√®le √† \\( \\) \\(${droiteLt}\\) \\( \\) a pour pente \\( \\) \\(${m}\\).</div>
    <div class="line">On cherche les points o√π \\( \\) \\(g'(x) = ${m}\\).</div>
    <div class="line">\\(${polyQuadLatexNum(A,B,C)}=${m}\\) <br> \\(${A===1?'x^{2}':A+'x^{2}'} ${B>=0?'+':'-'} ${Math.abs(B)}x = 0\\)</div>
    <div class="line">\\(x(${A===1?'x':A+'x'} ${B>=0?'+':'-'} ${Math.abs(B)})=0\\)</div>
    <div class="line">\\(x=0\\) ou \\(x=${texX2}\\)</div>
    <div class="line">Point(s) de contact : \\( \\) ${ptsQ2Tex}.</div>
  `;

  // =========================
  // Assemblage final stepsHTML
  // =========================
  const stepsHTML = `
    <div class="steps">
      <div class="line"><strong>On a :</strong> \\(g(x)=${gLatex}\\) <br> Donc : \\( \\) \\(g'(x)=${gPrime}\\).</div>
	 	   <div class="line"> <br></div>

      <div class="line stepTitle">1) Tangente parall√®le √† l‚Äôaxe des abscisses</div>
      <div class="line">Tangente parall√®le √† l‚Äôaxe des abscisses \\(\\iff\\) pente = 0 \\(\\iff g'(x)=0.\\)</div>
      <div class="line">On r√©sout \\( \\) \\(g'(x)=0\\), c‚Äôest-√†-dire : \\( \\) \\(${polyQuadLatexNum(A,B,C)} = 0\\).</div>

      ${pretty.html}

      <div class="line">Abscisse(s) obtenue(s) : \\( \\) \\(${
        pretty.rootsFrac.length
          ? pretty.rootsFrac.map(([p,q])=>texFracIrred(p,q)).join('\\text{ et }')
          : '\\text{aucune}'
      }\\).</div>
      <div class="line">Point(s) de contact :  ${ptsQ1Tex}</div>
	 	   <div class="line"> <br></div>

      ${q2BlockHTML}
    </div>
  `;

  // =========================
  // Pour l‚Äôauto-check dans checkExoA :
  // -> roots0 : les abscisses o√π pente = 0
  // -> rootsM : les abscisses o√π pente = m
  // checkExoA attend des NOMBRES (pas [p,q])
  // On convertit les fractions en d√©cimaux
  // =========================
  function fracToNumber(p,q){ return p/q; }

  const roots0Nums = pretty.rootsFrac.map(([p,q])=>p/q);
  const rootsMNums = solsQ2Frac.map(([p,q])=>p/q);
const slope0 = 0;
const slopeM = m; // m=c dans ce tirage

  // =========================
  // Enonc√©
  // =========================
  const enonceHTML = `
    Soit \\(g\\) la fonction d√©finie sur \\(\\mathbb{R}\\) par :
    \\[ g(x)=${gLatex} \\]
    et \\(\\mathcal{C}_g\\) sa courbe repr√©sentative.
    <ol style="margin-top:.5rem">
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† l‚Äôaxe des abscisses ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† la droite d‚Äô√©quation
        \\(${droiteLt}\\) ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
    </ol>
  `;

return {
  title : "Exercice 1 : D√©riv√©es et tangentes",
  enonce: enonceHTML,
  solHTML: stepsHTML,
  roots0: roots0Nums,
  rootsM: rootsMNums,
gPrimeEvalFn: function(x){ return 3*a*x*x + 2*b*x + c; },

  gPrimeText, // ex "6x^2-2x+4"
  slope0,     // 0
  slopeM      // m (=c)
};

}



function genExTangentesDegre2() {
  // ======================
  // Tirage des coefficients
  // ======================
  // g(x) = a x¬≤ + b x + c avec a ‚â† 0
  function nzChoose(list){ return list.filter(x=>x!==0)[Math.floor(Math.random()*list.filter(x=>x!==0).length)]; }
  function rnd(A,B){ return Math.floor(Math.random()*(B-A+1))+A; }

  const a = nzChoose([-3,-2,-1,1,2,3]);
  const b = rnd(-5,5);
  const c = rnd(-5,5);

  // droite cible : y = m x + p, pente m ‚â† 0
  const m = nzChoose([-4,-3,-2,-1,1,2,3,4]);
  const p = rnd(-6,6);

  // ======================
  // Helpers d'affichage LaTeX
  // ======================
  function quadToLatex(a,b,c){
    // retourne "ax^{2}+bx+c" propre (pas de 1x, pas de + -)
    const parts=[];
    if(a!==0){
        const aa=Math.abs(a);
        parts.push((a<0?'- ':'+ ')+(aa===1?'x^{2}':aa+'x^{2}'));
    }
    if(b!==0){
        const bb=Math.abs(b);
        parts.push((b<0?'- ':'+ ')+(bb===1?'x':bb+'x'));
    }
    if(c!==0 || !parts.length){
        const cc=Math.abs(c);
        parts.push((c<0?'- ':'+ ')+cc);
    }
    return parts.join(' ').replace(/^\+\s*/,'').trim();
  }

  function quadDerivLatex(a,b){
    // g'(x)=2ax+b
    const A=2*a, B=b;
    const parts=[];
    if(A!==0){
      const AA=Math.abs(A);
      parts.push((A<0?'- ':'+ ')+(AA===1?'x':AA+'x'));
    }
    if(B!==0 || !parts.length){
      const BB=Math.abs(B);
      parts.push((B<0?'- ':'+ ')+BB);
    }
    return parts.join(' ').replace(/^\+\s*/,'').trim();
  }

  function lineLatex(m,p){
    // y = m x + p (sans 1x, sans +0)
    const terms=[];
    if(m!==0){
      const mm=Math.abs(m);
      const mono=(mm===1?'x':mm+'x');
      terms.push( (m<0?'- ':'')+mono );
    }
    if(p!==0 || !terms.length){
      const pp=Math.abs(p);
      terms.push( (p<0?'- ':'+ ')+pp );
    }
    let rhs=terms.join(' ').replace(/^\+\s*/,'').trim();
    return 'y = '+rhs;
  }

  // fractions irr√©ductibles pour les abscisses
  function pgcd(u,v){
    u=Math.trunc(u); v=Math.trunc(v);
    u=Math.abs(u); v=Math.abs(v);
    while(v!==0){ const t=u%v; u=v; v=t; }
    return u===0?1:u;
  }
  function frac(num,den){
    if(den<0){ num=-num; den=-den; }
    const g=pgcd(num,den);
    return {num:num/g, den:den/g};
  }
  function fracToLatex(F){
    if(F.den===1) return ''+F.num;
    return `\\dfrac{${F.num}}{${F.den}}`;
  }

  // √©valuer g(x) = a x¬≤ + b x + c sur une fraction num/den
  function evalPoly2(a,b,c,F){
    const p=F.num, q=F.den;
    // num = a p¬≤ + b p q + c q¬≤
    // den = q¬≤
    const num = a*p*p + b*p*q + c*q*q;
    const den = q*q;
    const g=pgcd(num,den);
    const N=num/g, D=den/g;
    return {num:N, den:D};
  }
  function pointTexFrac(F){
    const Y = evalPoly2(a,b,c,F);
    return `\\(\\left(${fracToLatex(F)}\\,;\\,${fracToLatex(Y)}\\right)\\)`;
  }

  const gLatex   = quadToLatex(a,b,c);
  const gPrime   = quadDerivLatex(a,b);
  const droiteLt = lineLatex(m,p);

function derivText(a,b){
  // retourne style "4x-4" ou "-2x+5" ou "6x" ou "3"
  const A = 2*a;
  const B = b;
  let s = '';

  // terme en x
  if (A !== 0){
    if (A === 1)       { s += 'x'; }
    else if (A === -1) { s += '-x'; }
    else               { s += A + 'x'; }
  }

  // constante
  if (B !== 0){
    if (B > 0){
      s += (s==='' ? '' : '+') + B;
    } else {
      s += B; // B d√©j√† n√©gatif avec le signe -
    }
  }

  if (s==='') s='0';
  return s;
}
const gPrimeText = derivText(a,b); // ex "4x-4"

  // ======================
  // Q1 : tangente // axe des abscisses
  // pente = 0  <=>  g'(x)=0  <=> 2ax + b = 0
  // => x = -b/(2a)
  // ======================
  const sol0 = frac(-b, 2*a); // abscisse o√π pente=0
  const s0_line1 = `${(2*a===1?'':2*a+'') }x ${b>=0?'+ '+b:'- '+Math.abs(b)} = 0`;
  const s0_line2 = `${(2*a===1?'':2*a+'') }x = ${-b}`;
  const s0_line3 = `x = ${fracToLatex(sol0)}`;

  // point(s) de contact pour Q1
  const pts0TexList = [ pointTexFrac(sol0) ];

  // ======================
  // Q2 : tangente // droite y = m x + p
  // pente = m  <=>  g'(x)=m  <=> 2ax+b = m
  // => x = (m - b)/(2a)
  // ======================
  const solM = frac(m - b, 2*a);
  const sM_line1 = `${(2*a===1?'':2*a+'') }x ${b>=0?'+ '+b:'- '+Math.abs(b)} = ${m}`;
  const sM_line2 = `${(2*a===1?'':2*a+'') }x = ${m-b}`;
  const sM_line3 = `x = ${fracToLatex(solM)}`;

  const ptsMTexList = [ pointTexFrac(solM) ];

  // ======================
  // blocs de solution r√©dig√©e (comme dans ta fiche)
  // ======================

  const stepsQ1_block = `
    <div class="line stepTitle">1) Tangente parall√®le √† l‚Äôaxe des abscisses</div>
    <div class="line">Tangente parall√®le √† l‚Äôaxe des abscisses \\(\\iff\\) pente = 0 \\(\\iff\\ g'(x)=0.\\)</div>
    <div class="line">On r√©sout \\( \\) \\(g'(x)=0\\), soit :</div>
    <div class="line">\\(${s0_line1}\\)</div>
    <div class="line">\\(${s0_line2}\\)</div>
    <div class="line">\\(${s0_line3}\\)</div>
    <div class="line">Donc \\( \\) \\(\\mathcal{C}_g\\) \\( \\)admet une tangente horizontale pour \\( \\) \\(x=${fracToLatex(sol0)}\\).</div>
    <div class="line">Point(s) de contact : ${pts0TexList.join(', ')}.</div>
  `;

  const stepsQ2_block = `
  
    <div class="line stepTitle">2) Tangente parall√®le √† ${droiteLt}</div>
    <div class="line">Une tangente parall√®le √† \\( \\) \\(${droiteLt}\\) \\( \\) a pour pente \\( \\) \\(${m}\\).</div>
    <div class="line">On cherche les points o√π  \\( \\)  \\(g'(x)=${m}\\).</div>
    <div class="line">\\(g'(x)=${m}\\)</div>
    <div class="line">\\(${sM_line1}\\)</div>
    <div class="line">\\(${sM_line2}\\)</div>
    <div class="line">\\( ${sM_line3}\\)</div>
    <div class="line">Donc  \\( \\)  \\(\\mathcal{C}_g\\) \\( \\)  admet une tangente parall√®le √†  \\( \\) \\(${droiteLt}\\) \\( \\)  pour \\( \\)  \\(x=${fracToLatex(solM)}\\).</div>
    <div class="line">Point(s) de contact : ${ptsMTexList.join(', ')}.</div>
	
  `;

  const solHTML = `
    <div class="steps">
      <div class="line"><strong>On a :</strong> \\(g(x)=${gLatex}\\) <br> Donc \\(g'(x)=${gPrime}\\).</div>
		   <div class="line"> <br></div>
	${stepsQ1_block}
	 	   <div class="line"> <br></div>

	     ${stepsQ2_block}
    </div>
  `;

  // ======================
  // Enonc√© affich√© √† l'√©l√®ve
  // ======================
  const enonceHTML = `
    Soit \\(g\\) la fonction d√©finie sur \\(\\mathbb{R}\\) par :
    \\[ g(x)=${gLatex} \\]
    et \\(\\mathcal{C}_g\\) sa courbe repr√©sentative.
    <ol style="margin-top:.5rem">
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† l‚Äôaxe des abscisses ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† la droite d‚Äô√©quation
        \\(${droiteLt}\\) ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
    </ol>
  `;

    // ======================
  // Pour la v√©rification auto :
  // roots0 = abscisses o√π pente = 0
  // rootsM = abscisses o√π pente = m
  // On les renvoie COMME DES NOMBRES r√©els (pas objets fraction),
  // pour matcher checkExoA().
  // ======================

  const roots0Nums = [ fracToNumberObj(sol0) ];
  const rootsMNums = [ fracToNumberObj(solM) ];
  const slope0 = 0;
const slopeM = m;


return {
  title : "Exercice 1 : D√©riv√©es et tangentes",
  enonce: enonceHTML,
  solHTML,

  roots0: roots0Nums,
  rootsM: rootsMNums,
gPrimeEvalFn: function(x){ return 2*a*x + b; },

  gPrimeText, // ex "4x-4"
  slope0,     // 0
  slopeM      // m (pente de la droite y=mx+p)
};

}






/* =========================================================
   Exercice A : Tangentes parall√®les
   On prend g(x)=ax^2+bx+c avec a!=0
   Q1 : parall√®les √† l'axe des abscisses ?  <=> pente 0 <=> g'(x)=0
   Q2 : parall√®les √† y = m x + p ?        <=> pente m <=> g'(x)=m
   ========================================================= */
function genExTangentes(){
  if (modeTangentes === 'deg2'){
    return genExTangentesDegre2();
  }
  if (modeTangentes === 'deg3'){
    return genExTangentesDegre3();
  }
  // mode "mix" = comportement ancien : 50/50
  if (Math.random() < 0.5){
    return genExTangentesDegre2();
  } else {
    return genExTangentesDegre3();
  }
}




/* =========================================================
   Exercice B : Retrouver la fonction √† partir des conditions,
   puis donner f'(x).
   Deux sous-types :
   - P2 : f(x)=ax^2+bx+c
     Conditions :
       * f(0)=0
       * f'(0)=m0
       * f(x1)=y1
   - QUOT : f(x)=(a x^2 + b)/(3x-2)
     Conditions :
       * C_f coupe l'axe des ordonn√©es en A(0;y0)
       * Tangente horizontale en x=1
   ========================================================= */



/* ----- Sous-type P2 ----- */
function genP2(){
  // param√®tres al√©atoires simples
  const m0 = nzChoose([-4,-3,-2,-1,1,2,3,4]); // pente de la tangente en 0
  const x1 = nzChoose([-3,-2,-1,1,2,3]);      // un point donn√©
  const a  = nzChoose([-3,-2,-1,1,2,3]);      // on choisit a,
  // on imposera f(0)=0  => c=0
  // f'(x)=2ax+b, donc f'(0)=b = m0
  const b  = m0;
  // f(x)=ax^2+bx+c, et c=0
  // On choisit y1 coh√©rent : y1 = a x1^2 + b x1
  const y1 = a*x1*x1 + b*x1;
  const c  = 0;

  const fLatex    = quadToLatex(a,b,c);
  const fpLatex   = quadDerivLatex(a,b);



function buildSystemP2(a,b,c,x1,y1,m0){
  const Acoef = x1 * x1; // coeff sur a
  const Bcoef = x1;      // coeff sur b
  const Ccoef = 1;       // coeff sur c

  // √âtape "9a - 3b + c = 12"
  const comboLatex = linearComboLatex(Acoef,Bcoef,Ccoef);

  // √âtape SUBSTITUTION EXPLICITE :
  // ex: "9a - 3 √ó (-1) + 0"
  let substitutionEq = mono(Acoef,'a'); // "9a" ou "a" etc.

  // terme b :
  if (Bcoef !== 0){
    const sign = (Bcoef < 0 ? ' - ' : ' + ');
    const absB = Math.abs(Bcoef);
    const multB = (absB === 1 ? '' : absB + ' \\times ');
    substitutionEq += sign + multB + latexMaybeParen(b);
  }

  // terme c :
  if (Ccoef !== 0){
    const sign = (Ccoef < 0 ? ' - ' : ' + ');
    const absC = Math.abs(Ccoef);
    if (c !== 0){
      const multC = (absC === 1 ? '' : absC + ' \\times ');
      substitutionEq += sign + multC + latexMaybeParen(c);
    } else {
      // si c=0 on veut juste " + 0", pas "(0)"
      substitutionEq += ' + 0';
    }
  }

  // Maintenant √âtape SIMPLIFI√âE :
  // On regroupe Bcoef*b + Ccoef*c num√©riquement
  const constAfterBC = Bcoef*b + Ccoef*c; // un nombre
  let simplifiedEq = mono(Acoef,'a'); // "9a" ou "a" ou "-a"
  if (constAfterBC !== 0){
    simplifiedEq += (constAfterBC > 0 ? ' + ' : ' - ') + Math.abs(constAfterBC);
  }

  return `
    <div class="line"><em>Traduction des hypoth√®ses :</em></div>
    <div class="line">
      \\(H_1\\) : \\(f(0)=0\\)<br/>
      \\(H_2\\) : \\(f'(0)=${m0}\\)<br/>
      \\(H_3\\) : \\(f(${x1})=${y1}\\)
    </div>

    <div class="line" style="margin-top:.4rem">
    \\[
    \\left\\{
      \\begin{array}{l}
      f(0)=0 \\\\
      f'(0)=${m0} \\\\
      f(${x1})=${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      a \\times ${latexPow2(x1)} + b \\times ${latexSignedNum(x1)} + c = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      ${comboLatex} = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      ${substitutionEq} = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      ${simplifiedEq} = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      a = ${a} \\\\
      b = ${b} \\\\
      c = ${c}
      \\end{array}
    \\right.
    \\]
    </div>
  `;
}


function buildSystemP2(a,b,c,x1,y1,m0){
  // coefficients pour la forme d√©velopp√©e
  const Acoef = x1*x1;   // coeff de a
  const Bcoef = x1;      // coeff de b
  const Ccoef = 1;       // coeff de c
  const comboLatex = linearComboLatex(Acoef,Bcoef,Ccoef); // ex "9a - 3b + c"

  // √©quation combo apr√®s substitution b=m0, c=0
  // on veut afficher l'√©tape AVEC la substitution explicite :
  // 9a - 3b + c = 12  devient  9a - 3√ó(-1) + 0 = 12  avant de simplifier
  // puis on simplifie en 9a +3 =12 ou 9a-3=12 etc.

  // terme "Bcoef b" devient Bcoef * (m0)
  const subTermB = Bcoef * b; // num√©riquement
  // signe apr√®s substitution Bcoef*b + Ccoef*c
  // on fabrique la ligne genre "9a - 3 √ó (-1) + 0 = 12"
  let substitutionEq = `${Acoef}a`;
  // b-term
  if (Bcoef !== 0){
    const signB = (Bcoef < 0 ? ' - ' : ' + ');
    const absB  = Math.abs(Bcoef);
    substitutionEq += signB + (absB===1 ? `(${b})` : `${absB}\\times (${b})`);
  }
  // c-term
  if (Ccoef !== 0){
    const signC = (Ccoef < 0 ? ' - ' : ' + ');
    const absC  = Math.abs(Ccoef);
    substitutionEq += signC + (absC===1 ? `${c}` : `${absC}\\times ${c}`);
  }
  // nettoyage signe initial si √ßa commence par " + "
  substitutionEq = substitutionEq.replace(/^\s*\+\s*/,'');

  // maintenant on veut la version simplifi√©e finale, du style "9a - 3 = 12"
  // num√©riquement, combo devient Acoef*a + Bcoef*b + Ccoef*c = y1
  // mais pour l'affichage, on ne remplace pas a; on garde "9a ¬± 3"
  // donc :
  //   Acoef a + (Bcoef*b + Ccoef*c) = y1
  const constAfterBC = Bcoef*b + Ccoef*c; // ex -3*(-1)+0 = 3
  let simplifiedEq = `${Acoef}a`;
  if (constAfterBC !== 0){
    simplifiedEq += (constAfterBC > 0 ? ' + ' : ' - ') + Math.abs(constAfterBC);
  }

  return `
    <div class="line"><em>Traduction des hypoth√®ses :</em></div>
    <div class="line">
      \\(H_1\\) : \\(f(0)=0\\)<br/>
      \\(H_2\\) : \\(f'(0)=${m0}\\)<br/>
      \\(H_3\\) : \\(f(${x1})=${y1}\\)
    </div>

    <div class="line" style="margin-top:.4rem">
    \\[
    \\left\\{
      \\begin{array}{l}
      f(0)=0 \\\\
      f'(0)=${m0} \\\\
      f(${x1})=${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      a \\times ${latexPow2(x1)} + b \\times ${latexSignedNum(x1)} + c = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      ${comboLatex} = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      ${substitutionEq} = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      c = 0 \\\\
      b = ${m0} \\\\
      ${simplifiedEq} = ${y1}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      a = ${a} \\\\
      b = ${b} \\\\
      c = ${c}
      \\end{array}
    \\right.
    \\]
    </div>
  `;
}





  const enonceHTML = `
  On consid√®re la fonction \\(f\\) d√©finie sur \\(\\mathbb{R}\\) par
  \\(f(x)=ax^{2}+bx+c\\), et l‚Äôon note \\( \\) \\(\\mathcal{C}_f\\) \\( \\) sa courbe repr√©sentative dans un rep√®re \\((O;\\vec{i},\\vec{j})\\).
  <ol style="margin-top:.5rem">
    <li>Calculer \\(f'(x)\\) selon \\(a,b\\) \\( \\) et \\( \\) \\(c\\). </li>
    <li>D√©terminer \\( \\)  \\(a,b\\) \\( \\) et \\( \\) \\(c\\) \\( \\) sachant que \\( \\) \\(\\mathcal{C}_f\\) \\( \\) v√©rifie les hypoth√®ses suivantes :
      <ul>
        <li>\\(H_1 :\\) \\( \\) \\(\\mathcal{C}_f\\) \\( \\)  passe par l‚Äôorigine du rep√®re \\( \\)  \\(O(0;0)\\).</li>
        <li>\\(H_2 :\\) \\( \\) La tangente √† \\( \\)  \\(\\mathcal{C}_f\\)  \\( \\) en \\( \\)  \\(O\\) \\( \\)  a pour coefficient directeur \\( \\)  \\(${m0}\\).</li>
        <li>\\(H_3 :\\) \\( \\) \\(\\mathcal{C}_f\\) \\( \\)  passe par le point \\( \\)  \\(A(${x1}\\,;\\,${y1})\\).</li>
      </ul>
      Donner l‚Äôexpression finale de \\(f(x)\\).
    </li>
  </ol>
  `;

  const solHTML = `
  <div class="steps">
    <div class="line stepTitle">1) D√©riv√©e g√©n√©rale</div>
    <div class="line">\\(f(x)=ax^{2}+bx+c\\) \\( \\) donc \\( \\) \\(f'(x)=2ax+b\\).</div>

    <div class="line stepTitle">2) Utilisation des hypoth√®ses</div>
${buildSystemP2(a,b,c,x1,y1,m0)}


    <div class="line stepTitle">Conclusion</div>
    <div class="line">On a \\( \\) \\(a=${a},\\;b=${b} \\) \\( \\) et \\( \\) \\(c=${c}\\).</div>
    <div class="line">Donc \\( \\)  \\(f(x)=${fLatex}\\).</div>
    <div class="line">Et \\( \\)  \\(f'(x)=${fpLatex}\\).</div>
  </div>
  `;

  // auto-check :
  // √©l√®ve doit donner f'(x) dans ansMain
  // puis "a=..., b=..., c=..." dans ansCoeff (on va tol√©rer juste "a=2,b=3,c=0" ou "2;3;0")
  function refFp(x){ return 2*a*x + b; }
  const coeffsRef = {a,b,c};
function refF(x){ return a*x*x + b*x + c; }

  // d√©riv√©e symbolique et f(x)
  const fSymbolicLatex   = `ax^{2}+bx+c`;
  const fpSymbolicLatex  = `2ax+b`;
  const fFinalLatex      = fLatex; // d√©j√† mis en forme num√©rique plus haut

  const hypInputs = [
    { id:"H1", label:"H‚ÇÅ se traduit par :", expect:`f(0)=0` },
    { id:"H2", label:"H‚ÇÇ se traduit par :", expect:`f'(0)=${m0}` },
    { id:"H3", label:"H‚ÇÉ se traduit par :", expect:`f(${x1})=${y1}` },
  ];

  return {
    title:"Exercice 2 : Retrouver la fonction",
    enonce:enonceHTML,
    solHTML,
    fpEval:refFp,
	  fEval: refF,

    fpLatex,
    coeffsRef,
    hypInputs,
    fpSymbolicLatex,  // attendu pour f'(x)=...
    fSymbolicLatex,   // forme g√©n√©rale
    fFinalLatex       // forme finale num√©rique
  };
}



function genQuot(){
  // On veut f(x) = (a x^2 + b)/(p x + q)
  //
  // Hypoth√®ses de l'√©nonc√© :
  //  - Cf coupe l‚Äôaxe des ordonn√©es en y0  -> f(0)=y0  -> b/q = y0 -> b = q*y0
  //  - Cf admet une tangente horizontale en x=1 -> f'(1)=0 -> a = (p*b)/(p+2q)
  //
  // Contraintes qu'on impose pour avoir un √©nonc√© propre :
  //  - a,b,p,q entiers petits
  //  - p ‚â† 0
  //  - p+2q ‚â† 0 (sinon a pas d√©fini)
  //  - a entier
  //  - PAS de num√©rateur nul : interdit d'avoir a = 0 ET b = 0
  //    (c'est le cas que tu refuses : f(x)=0/(...) )
  //
  // On boucle jusqu'√† trouver un jeu propre.
  // Si rien de propre apr√®s N essais : fallback manuel propre qui respecte les contraintes.

  let a,b,p,q,y0;
  let tries = 0;
  while (tries < 200) {
    tries++;

    // tirages
    p  = nzChoose([-3,-2,-1,1,2,3]); // pente du d√©nominateur
    q  = rnd(-4,4);                  // ordonn√©e du d√©nominateur
    if (q === 0) continue;           // pas de v(x)=p x (trop simple, et √©vite b=0 si y0=0 de fa√ßon trop fr√©quente)
    y0 = rnd(-3,3);

    // f(0)=y0 => b/q = y0 => b = q*y0, entier
    b = q * y0;

    const denTest = p + 2*q;
    if (denTest === 0) continue;     // √©vite division par 0 dans a

    // a = (p*b)/(p+2q), on veut a entier
    const numA = p * b;
    if (numA % denTest !== 0) continue;
    a = numA / denTest;

    // bornes de lisibilit√©
    if (Math.abs(a) > 10) continue;
    if (Math.abs(b) > 30) continue;
    if (Math.abs(p) > 10) continue;
    if (Math.abs(q) > 10) continue;

    // üî¥ garde-fou majeur : pas de num√©rateur nul "0 / (px+q)"
    // c'est-√†-dire pas (a=0 ET b=0)
    if (a === 0 && b === 0) continue;

    // si on arrive ici, tirage valid√©
    break;
  }

  // Fallback si rien trouv√© (tr√®s rare mais on s√©curise)
  if (tries >= 200) {
    // On construit explicitement un exemple propre √† la main :
    // p=3, q=-2, y0=1
    // -> b = q*y0 = -2
    // denTest = p+2q = 3-4 = -1
    // -> a = (p*b)/(p+2q) = (3 * -2)/(-1)=6
    // Ici a=6, b=-2 donc NUM ‚â† 0, nickel.
    p=3;
    q=-2;
    y0=1;
    b = -2;
    a = 6;
  }

  // Helpers latex
  function linLatex(px,qx){
    // rend "3x-2", "-x+5", "x-4", etc.
    let head;
    if (px === 1) head = 'x';
    else if (px === -1) head = '-x';
    else head = px + 'x';

    if (qx === 0) return head;
    return head + (qx>0 ? ' + ' : ' - ') + Math.abs(qx);
  }

  function numQuadLatex(ax2, bcte){
    // ax^2 + b en jolis termes
    const parts=[];
    if (ax2 !== 0){
      const aa = Math.abs(ax2);
      parts.push((ax2<0?'- ':'+ ') + (aa===1?'x^{2}':aa+'x^{2}'));
    }
    if (bcte !== 0 || !parts.length){
      const bb = Math.abs(bcte);
      parts.push((bcte<0?'- ':'+ ') + bb);
    }
    return parts.join(' ').replace(/^\+\s*/,'').trim();
  }

  // f(x) latex
  const fLatex = `\\dfrac{${numQuadLatex(a,b)}}{${linLatex(p,q)}}`;
  const efLatex = `\\dfrac{ax¬≤+b}{${linLatex(p,q)}}`;

  // d√©riv√©e
  // u = a x^2 + b   -> u' = 2 a x
  // v = p x + q     -> v' = p
  //
  // f'(x)= [2ax(px+q) - p(ax^2+b)]/(px+q)^2
  //      = [(ap)x^2 + (2aq)x - p b]/(px+q)^2
  const A3 = a*p;
  const B4 = 2*a*q;
  const Cc = -p*b;

  function polyNumLatex(Acoef,Bcoef,Ccoef){
    const arr=[];
    if (Acoef!==0){
      const AA=Math.abs(Acoef);
      arr.push((Acoef<0?'- ':'+ ') + (AA===1?'x^{2}':AA+'x^{2}'));
    }
    if (Bcoef!==0){
      const BB=Math.abs(Bcoef);
      arr.push((Bcoef<0?'- ':'+ ') + (BB===1?'x':BB+'x'));
    }
    if (Ccoef!==0 || !arr.length){
      const CC=Math.abs(Ccoef);
      arr.push((Ccoef<0?'- ':'+ ') + CC);
    }
    return arr.join(' ').replace(/^\+\s*/,'').trim();
  }

  const numLatex   = polyNumLatex(A3,B4,Cc);
  const denomLatex = `\\left(${linLatex(p,q)}\\right)^{2}`;
  const fpLatex    = `\\dfrac{${numLatex}}{${denomLatex}}`;

function buildSystemQuot_full(a,b,p,q,y0){



  // b = q * y0
  // deuxi√®me √©quation : a(p+2q) - p b = 0
  // apr√®s substitution explicite :
  //   a(p+2q) - p * (q*y0) = 0
  //
  // puis forme isol√©e de a = ...
  //   a = [p * (q*y0)] / (p+2q)
  //
  // ATTENTION aux signes, aux parenth√®ses seulement si n√©gatif

  // on formate p+2q :
  const denom = p + 2*q;

  // √©quation substitu√©e explicitement (AVANT simplification)
  // a(p+2q) - p*(q*y0) = 0
  const subEq = `a(${p}+2\\times ${q}) - ${p}\\times (${q}\\times ${y0}) = 0`;

  // √©quation finale isol√©e :
  // a = p*(q*y0)/(p+2q)
  const finalAeq = `a = \\dfrac{${p}\\times (${q}\\times ${y0})}{${p}+2\\times ${q}} = ${a}`;

  return `
    <div class="line"><em>Traduction des hypoth√®ses :</em></div>
    <div class="line">
      \\(H_1\\) : \\(f(0)=${y0}\\)<br/>
      \\(H_2\\) : \\(f'(1)=0\\)
    </div>

    <div class="line" style="margin-top:.4rem">
    \\[
    \\left\\{
      \\begin{array}{l}
      f(0)=${y0} \\\\
      f'(1)=0
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      \\dfrac{b}{${q}} = ${y0} \\\\
      a(${p}+2\\times ${q}) - ${p}b = 0
      \\end{array}
    \\right.
    \\]
    </div>

    <div class="line" style="margin-top:.4rem">
    Comme \\(\\frac{b}{${q}}=${y0}\\), on a \\(b=${q}\\times ${y0}=${b}\\). On remplace dans la deuxi√®me √©quation :
    \\[
      ${subEq}
    \\]
    </div>

    <div class="line" style="margin-top:.4rem">
    On obtient finalement :
    \\[
      ${finalAeq}
    \\]
    </div>

    <div class="line" style="margin-top:.4rem">
    Donc :
    \\[
    \\left\\{
      \\begin{array}{l}
      a = ${a} \\\\
      b = ${b}
      \\end{array}
    \\right.
    \\]
    </div>
  `;
}

  // petites aides d'affichage pour la partie d√©riv√©e style "image"
  function numStep1_Latex(p,q){
    // 2ax(px+q) - p(ax¬≤+b)
    return `\\dfrac{2ax\\,(${linLatex(p,q)})-${p}(ax^{2}+b)}{(${linLatex(p,q)})^{2}}`;
  }
  function numStep2_Latex(p,q){
    // d√©velopper mais encore avec a,b,p,q litt√©raux :
    // 2ax(px+q) = 2ap x¬≤ + 2aq x
    // -p(ax¬≤+b) = -ap x¬≤ -pb
    // => (2ap x¬≤ + 2aq x) + (-ap x¬≤ -pb)
    // On n'essaie pas encore de regrouper, juste on montre la somme brute
    const term_x2_1 = `2apx^{2}`;   // visuel "2apx¬≤"
    const term_x_1  = `2aqx`;
    const term_x2_2 = `-apx^{2}`;
    const term_cst  = `-pb`;
    return `\\dfrac{${term_x2_1} + ${term_x_1} ${term_x2_2[0]==='-'? '' : '+ '}${term_x2_2} ${term_cst[0]==='-'? '':'+ '}${term_cst}}{(${linLatex(p,q)})^{2}}`;
  }
  function numStep3_Latex(p,q){
    // Regroupement (2ap - ap)x¬≤ + 2aq x - pb = ap x¬≤ + 2aq x - pb
    // On veut la ligne "6ax¬≤-4ax-3a x¬≤-3b" -> "3ax¬≤-4ax-3b" dans ton exemple.
    // Ici on va calculer avec les VRAIS nombres a,b,p,q tir√©s.
    //
    // num√©rateur simplifi√© = (a*p)x¬≤ + (2*a*q)x - p*b
    const Acoef = a*p;
    const Bcoef = 2*a*q;
    const Ccoef = -p*b;

    // helper pour afficher Ax¬≤+Bx+Cc avec les bons signes, sans 1x etc.
    function polyNumPretty(A,B,C){
      const chunks=[];
      if(A!==0){
        const AA=Math.abs(A);
        chunks.push((A<0?'- ':'')+(AA===1?'a x^{2}':AA+'a x^{2}')); // ‚ö† NON : on veut d√©j√† num√©rique ici !
      }
    }
    // MAIS : √† cette √©tape tu veux du NUM√âRIQUE pur (ex. "6ax¬≤-4ax-3a x¬≤-3b" puis "3ax¬≤-4ax-3b").
    // Dans ton screenshot :
    // Ligne 2 : 2ax(3x-2) - 3(ax¬≤+b)
    // Ligne 3 : 6ax¬≤-4ax-3ax¬≤-3b
    // Ligne 4 : 3ax¬≤-4ax-3b
    //
    // Donc en fait on va faire EXACTEMENT ces 4 lignes pour NOS p,q :
    // LIGNE 1 : f'(x)= (u'v - v'u)/v¬≤
    // LIGNE 2 : f'(x)= (2ax(px+q) - p(ax¬≤+b))/(px+q)¬≤    ‚Üê numStep1_Latex
    // LIGNE 3 : f'(x)= ( (2ap)x¬≤ + (2aq)x -(ap)x¬≤ -pb )/(px+q)¬≤
    //          = f'(x)= ( (2*a*p)x¬≤ + (2*a*q)x - (a*p)x¬≤ - (p*b) )/(...)¬≤
    // LIGNE 4 : f'(x)= ( (a*p)x¬≤ + (2*a*q)x - (p*b) )/(px+q)¬≤
    //
    // Donc plut√¥t que numStep3_Latex on va construire ligne3/ligne4 directement dans solHTML avec les vrais coeffs.
  }



  // ENONC√â
  const enonceHTML = `
  On consid√®re la fonction \\(f\\) d√©finie par
  \\[ f(x)=${efLatex} \\]
  et l‚Äôon note \\(\\mathcal{C}_f\\) sa courbe repr√©sentative dans le plan muni d‚Äôun rep√®re \\((O;\\vec{i},\\vec{j})\\).
  <ol style="margin-top:.5rem">
    <li>Calculer \\(f'(x)\\) selon \\(a\\) \\( \\) et \\( \\) \\(b\\).</li>
    <li>D√©terminer \\( \\) \\(a\\) et \\(b\\) \\( \\) sachant que \\( \\) \\(\\mathcal{C}_f\\) \\( \\) v√©rifie les hypoth√®ses suivantes :
      <ul>
        <li>\\(H_1 :\\) \\( \\) \\(\\mathcal{C}_f\\)  \\( \\) coupe l‚Äôaxe des ordonn√©es au point d‚Äôordonn√©e \\( \\)  \\(${y0}\\).</li>
        <li>\\(H_2 :\\) \\( \\) \\(\\mathcal{C}_f\\)  \\( \\) admet une tangente horizontale au point d‚Äôabscisse \\( \\)  \\(1\\).</li>
      </ul>
      Donner l‚Äôexpression finale de \\(f(x)\\).
    </li>
  </ol>
  `;

function fmtFactorKofExpr(k, exprLatex){
  // renvoie k*(expr) en LaTeX propre:
  //  k =  5  -> "5"+expr
  //  k = -5  -> "-5"+expr
  //  k =  1  -> expr
  //  k = -1  -> "-" + expr
  //  k =  0  -> "0"? (ici √ßa ne se produit pas pour v'(x))
  if(k === 1){
    return exprLatex;
  } else if(k === -1){
    return "-" + exprLatex;
  } else {
    return k + exprLatex;
  }
}

// construit un terme style "coef * ax¬≤"
function term_ax2(coef){
  if (coef === 0) return "";
  if (coef === 1) return "ax^{2}";
  if (coef === -1) return "-ax^{2}";
  if (coef > 0) return coef + "ax^{2}";
  return "-" + Math.abs(coef) + "ax^{2}";
}

function term_ax(coef){
  if (coef === 0) return "";
  if (coef === 1) return "ax";
  if (coef === -1) return "-ax";
  if (coef > 0) return coef + "ax";
  return "-" + Math.abs(coef) + "ax";
}

function term_b(coef){
  if (coef === 0) return "";
  if (coef === 1) return "b";
  if (coef === -1) return "-b";
  if (coef > 0) return coef + "b";
  return "-" + Math.abs(coef) + "b";
}

// petit nettoyeur d'espaces et de signes
function tidySum(str){
  return str
    .replace(/\s+/g," ")
    .replace(/\+\s*-/g,"- ")
    .replace(/-\s*-/g,"- -") // on laisse -- ? on va corriger juste apr√®s
    .replace(/\+\s*\+/g,"+ ")
    .replace(/^\+\s*/,"")
    .replace(/ - -/g," + ") // "--" -> "+", r√®gle p√©dagogique que tu veux d√©j√† partout
    .trim();
}




function buildDerivBlockQuot(a,b,p,q){
  const vLatex = linLatex(p,q); // ex "x-1" ou "-3x+3"
  const vp     = p;             // v'(x)=p
  const upLatex = "2ax";
  const uLatex  = "ax^{2}+b";

  // (1) tableau u / v / u' / v'
  const tableHTML = `
    <div class="line">On a \\( f(x)=\\dfrac{u(x)}{v(x)} \\) avec :</div>
    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
        <td>\\(v(x)=${vLatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${upLatex}\\)</td>
        <td>\\(v'(x)=${vp}\\)</td>
      </tr>
    </table>
  `;

  // (2) formule g√©n√©rale
  const lineFormule = `
    <div class="line">\\(f'(x)=\\dfrac{u'(x)v(x)-v'(x)u(x)}{v(x)^{2}}\\)</div>
  `;

  // (3) substitution directe
  // num√©rateur : 2ax * v(x)  -  v'(x)*(ax¬≤+b)
  // on doit afficher " - (ax¬≤+b)" si v'(x)=1, et " - (-3)(ax¬≤+b)" si v'(x)=-3, etc.
  let secondFactor; // la partie "-v'(x)u(x)" propre

if (vp === 1) {
  // cas v'(x)=+1 : on garde le signe "‚Äì" de la formule
  secondFactor = "-(ax^{2}+b)";
} else if (vp === -1) {
  // cas v'(x)=-1 :  -(-1)(ax¬≤+b) ‚Üí + (ax¬≤+b)
  secondFactor = "+(ax^{2}+b)";
} else if (vp > 1) {
  // cas v'(x)>1 :  -(vp)(ax¬≤+b)
  secondFactor = `-${vp}(ax^{2}+b)`;
} else {
  // cas v'(x)<-1 :  -(-|vp|)(ax¬≤+b) ‚Üí +|vp|(ax¬≤+b)
  secondFactor = `+${Math.abs(vp)}(ax^{2}+b)`;
}


  // Et la premi√®re partie "2ax * v(x)" on l'√©crit simplement "2ax(${vLatex})"
 const lineSubstitution = `
  <div class="line">\\(f'(x)=\\dfrac{2ax\\,(${vLatex})${secondFactor}}{(${vLatex})^{2}}\\)</div>
`;


  // (4) d√©veloppement du num√©rateur AVANT regroupement
  //
  // 2ax(px+q) -> (2p)ax¬≤ + (2q)ax
  // k(ax¬≤+b)  -> k¬∑ax¬≤ + k¬∑b, avec k = -vp (cf plus haut)
  //
  const coef_x2_first = 2*p;   // pour ax¬≤
  const coef_x_first  = 2*q;   // pour ax
  const kSecond       = -vp;   // facteur appliqu√© √† (ax¬≤+b)

  const coef_x2_second = kSecond; // k * ax¬≤
  const coef_b_second  = kSecond; // k * b

  // construit l'encha√Ænement des 3/4 termes :
  let rawTerms = [
    term_ax2(coef_x2_first),
    term_ax(coef_x_first),
    term_ax2(coef_x2_second),
    term_b(coef_b_second)
  ].filter(t=>t!=="").join(" + ");

  rawTerms = tidySum(rawTerms);

  const lineDeveloppe = `
    <div class="line">\\(f'(x)=\\dfrac{${rawTerms}}{(${vLatex})^{2}}\\)</div>
  `;

  // (5) regroupement final :
  // ax¬≤ : coef_x2_first + coef_x2_second = (2p) + (-vp) = 2p - vp = p
  // ax  : coef_x_first                  = 2q
  // b   : coef_b_second                 = -vp
  const coef_ax2_final = 2*p - vp; // qui est p en vrai
  const coef_ax_final  = 2*q;
  const coef_b_final   = -vp;

  let finalTerms = [
    term_ax2(coef_ax2_final),
    term_ax(coef_ax_final),
    term_b(coef_b_final)
  ].filter(t=>t!=="").join(" + ");

  finalTerms = tidySum(finalTerms);

  const lineReduite = `
    <div class="line">\\(f'(x)=\\dfrac{${finalTerms}}{(${vLatex})^{2}}\\)</div>
  `;

  // assemblage final du bloc d√©riv√©e :
  return `
    ${tableHTML}
    ${lineFormule}
    ${lineSubstitution}
    ${lineDeveloppe}
    ${lineReduite}
  `;
}




  // SOLUTION
  const solHTML = `
  <div class="steps">
    <div class="line stepTitle">1) D√©riv√©e g√©n√©rale du quotient</div>
    <div class="line">${buildDerivBlockQuot(a,b,p,q)}</div>


    <div class="line stepTitle">2) Utilisation des hypoth√®ses</div>
${buildSystemQuot_full(a,b,p,q,y0)}

    <div class="line stepTitle">Conclusion</div>
    <div class="line">\\(a=${a},\\;b=${b}.\\)</div>
    <div class="line">Donc \\(f(x)=${fLatex}\\).</div>
    <div class="line">Et \\(f'(x)=${fpLatex}\\).</div>
  </div>
  `;

  // Pour checkExoB : on renvoie f'(x) num√©rique
  function fpEval(x){
    // num√©rateur d√©riv√©e = (a p)x^2 + (2 a q)x - p b
    const num = (a*p)*x*x + (2*a*q)*x + (-p*b);
    const den = (p*x+q)*(p*x+q);
    return num/den;
  }
function fEval(x){
  return (a*x*x + b) / (p*x + q);
}
  const coeffsRef = {a,b};

  // formes symboliques attendues
  const fSymbolicLatex  = `\\dfrac{ax^{2}+b}{${linLatex(p,q)}}`;
  // d√©riv√©e symbolique g√©n√©rale (sans remplacer a,b,p,q)
  const fpSymbolicLatex = `\\dfrac{2ax(${linLatex(p,q)})-${p}(ax^{2}+b)}{(${linLatex(p,q)})^{2}}`;
  const fFinalLatex     = fLatex; // d√©j√† num√©rique

  const hypInputs = [
    { id:"H1", label:"H‚ÇÅ se traduit par :", expect:`f(0)=${y0}` },
    { id:"H2", label:"H‚ÇÇ se traduit par :", expect:`f'(1)=0` },
  ];

  return {
    title:"Exercice 2 : Retrouver la fonction (quotient)",
    enonce:enonceHTML,
    solHTML,
    fpEval,
	  fEval,
    fpLatex,
    coeffsRef,
    hypInputs,
    fpSymbolicLatex,
	p,
q,

    fSymbolicLatex,
    fFinalLatex
	
  };
}




function genCubic(){
  // On va imposer :
  // H1 : f(0) = d0        -> d = d0
  // H2 : f(XA) = YA       -> a*XA^3 + b*XA^2 + c*XA + d = YA
  // H3 : f'(0) = m0       -> c = m0
  // H4 : f'(XH) = 0       -> 3a*XH^2 + 2b*XH + c = 0

  // Choix contr√¥l√© :
  const candidatesA  = [-3,-2,-1,1,2,3];    // valeurs possibles pour a
  const candidatesB  = [-3,-2,-1,0,1,2,3];  // b
  const candidatesD0 = [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6]; // d0
  const candidatesXH = [-2,-1,1,2];         // abscisse tangente horizontale (‚â†0 pour que ce soit int√©ressant)
  const candidatesXA = [-3,-2,-1,1,2,3];    // point A (√©vite 0 pour que ce soit utile)

  // pente en 0 (m0 = c) -> on veut c pas trop moche
  const candidatesM0 = [-4,-3,-2,-1,1,2,3,4];

  for(let guard=0; guard<400; guard++){
    const Atry = choice(candidatesA);
    const Btry = choice(candidatesB);
    const d0   = choice(candidatesD0);
    const XH   = choice(candidatesXH);
    const XA   = choice(candidatesXA);
    const cTry = choice(candidatesM0); // c = m0

    // H4 : f'(XH)=0 impose une relation entre a,b,c :
    // 3a*XH^2 + 2b*XH + c = 0
    // On v√©rifie qu'avec (Atry,Btry,cTry) c'est bien vrai.
    const checkH4 = 3*Atry*XH*XH + 2*Btry*XH + cTry;
    if(checkH4 !== 0) continue; // sinon on rejette, on veut que la tangente horizontale soit vraie

    // H2 : f(XA)=YA -> √ßa d√©finit YA
    const YA = Atry*XA*XA*XA + Btry*XA*XA + cTry*XA + d0;

    // On v√©rifie que YA et m0 (=cTry) restent raisonnables pour l'√©nonc√©
    if(Math.abs(YA)>30) continue;

    // OK, on tient un exo coh√©rent :
    const a = Atry;
    const b = Btry;
    const c = cTry;
    const d = d0;
    const x0 = 0;
    const m0 = cTry; // puisque f'(0)=c

    return genCubic_fromSolved({
      a,b,c,d,
      XA,YA,
      x0,m0,
      XH,
      d0
    });
  }

  // En th√©orie on ne tombe pas ici avec les bornes choisies.
  // En cas d'√©chec extr√™me, on force un cas simple coh√©rent :
  const a=1,b=-2,XH=1;
  const c= -(3*a*XH*XH + 2*b*XH); // pour f'(XH)=0
  const d0= -3;
  const x0=0;
  const m0=c;
  const XA=2;
  const YA=a*XA*XA*XA + b*XA*XA + c*XA + d0;
  return genCubic_fromSolved({
    a,b,c,d:d0,
    XA,YA,
    x0,m0,
    XH,
    d0
  });
}



function genCubic_fromSolved(data){
  const {a,b,c,d, XA,YA, x0,m0, XH, d0} = data;

  const efLatex= `ax^3+bx^2+cx+d`;
    const fLatex  = cubicToLatex(a,b,c,d);

  const fpLatex = cubicDerivLatex(a,b,c); // 3ax¬≤+2bx+c propre

function buildSystemCubic_full(a,b,c,d, XA,YA, x0,m0, XH, d0){
  // helpers suppos√©s disponibles:
  // latexPow(n,p), latexPow2(n),
  // latexSignedNum(n), latexBareNum(n),
  // linearComboLatexGeneric(coeffs, syms)

  // Rappels :
  // f(x)=ax^3+bx^2+cx+d
  // f'(x)=3ax^2+2bx+c
  //
  // H1: f(0)=d0  -> d = d0
  // H2: f(XA)=YA -> a*XA^3 + b*XA^2 + c*XA + d = YA
  // H3: f'(0)=m0 -> c = m0
  // H4: f'(XH)=0 -> 3a*XH^2 + 2b*XH + c = 0

  // √âquations "brutes" avec x remplac√©s (avec √ó et puissances)
  function rawEq_fXA(){
    return `a \\times ${latexPow(XA,3)} + b \\times ${latexPow2(XA)} + c \\times ${latexSignedNum(XA)} + d = ${YA}`;
  }
  function rawEq_fp0(){
    // f'(0)=m0 -> 3a√ó0^2 + 2b√ó0 + c = m0
    return `3a \\times ${latexPow2(0)} + 2b \\times ${latexSignedNum(0)} + c = ${m0}`;
  }
  function rawEq_fpXH(){
    return `3a \\times ${latexPow2(XH)} + 2b \\times ${latexSignedNum(XH)} + c = 0`;
  }

  // Version simplifi√©e sans "√ó0"
  const eq_XA_combo = linearComboLatexGeneric(
    [XA*XA*XA, XA*XA, XA, 1],
    ['a','b','c','d']
  );
  const eq_fp0_combo = `c = ${m0}`; // car f'(0)=c => c=m0
  const eq_fpXH_combo = linearComboLatexGeneric(
    [3*XH*XH, 2*XH, 1],
    ['a','b','c']
  ) + ` = 0`;

  // Apr√®s substitution de d=d0 ET c=m0 dans f(XA)=YA :
  // a*XA^3 + b*XA^2 + (m0)*XA + d0 = YA
  function eqPointA_afterSub(){
    const Acoef = XA*XA*XA;
    const Bcoef = XA*XA;
    const constC = m0*XA;
    const constD = d0;

    const parts = [];
    // a
    if(Acoef === 1) parts.push('a');
    else if(Acoef === -1) parts.push('-a');
    else parts.push(`${Acoef}a`);
    // b
    if(Bcoef === 1) parts.push('+ b');
    else if(Bcoef === -1) parts.push('- b');
    else if(Bcoef !== 0){
      parts.push((Bcoef>0?'+ ':'')+`${Bcoef}b`);
    }
    // constC
    if(constC !== 0){
      parts.push((constC>0?'+ ':'')+`${constC}`);
    }
    // constD
    if(constD !== 0){
      parts.push((constD>0?'+ ':'')+`${constD}`);
    }

    let lhs = parts.join(' ');
    lhs = lhs.replace(/\+\s-\s/g,'- ').replace(/\s+/g,' ').trim();
    return `${lhs} = ${YA}`;
  }

  // Apr√®s substitution de c=m0 dans f'(XH)=0 :
  // 3a*XH^2 + 2b*XH + m0 = 0
  function eqDerivXH_afterSub(){
    const Acoef = 3*XH*XH;
    const Bcoef = 2*XH;
    const Cst   = m0;

    const parts = [];
    // a
    if(Acoef === 1) parts.push('a');
    else if(Acoef === -1) parts.push('-a');
    else parts.push(`${Acoef}a`);
    // b
    if(Bcoef === 1) parts.push('+ b');
    else if(Bcoef === -1) parts.push('- b');
    else if(Bcoef !== 0){
      parts.push(Bcoef>0?`+ ${Bcoef}b`:`${Bcoef}b`);
    }
    // constante m0
    if(Cst!==0){
      parts.push(Cst>0?`+ ${Cst}`:`${Cst}`);
    }

    let lhs = parts.join(' ');
    lhs = lhs.replace(/\+\s-\s/g,'- ').replace(/\s+/g,' ').trim();
    return `${lhs} = 0`;
  }

  // Syst√®me lin√©aire en a,b apr√®s substitution :
  // De H2 (f(XA)=YA apr√®s sub) :
  //   (XA^3) a + (XA^2) b = YA - m0*XA - d0
  const A1 = XA*XA*XA;
  const B1 = XA*XA;
  const C1 = YA - m0*XA - d0;

  // De H4 (f'(XH)=0 apr√®s sub) :
  //   (3XH^2) a + (2XH) b = -m0
  const A2 = 3*XH*XH;
  const B2 = 2*XH;
  const C2 = -m0;

  function linEqAB(Ac,Bc,Cc){
    const parts=[];
    // a
    if(Ac===1) parts.push('a');
    else if(Ac===-1) parts.push('-a');
    else parts.push(`${Ac}a`);
    // b
    if(Bc===1) parts.push('+ b');
    else if(Bc===-1) parts.push('- b');
    else if(Bc!==0){
      parts.push(Bc>0?`+ ${Bc}b`:`${Bc}b`);
    }
    let lhs = parts.join(' ');
    lhs = lhs.replace(/\+\s-\s/g,'- ').replace(/\s+/g,' ').trim();
    return `${lhs} = ${Cc}`;
  }

  const eqAB1 = linEqAB(A1,B1,C1);
  const eqAB2 = linEqAB(A2,B2,C2);

  // === √©tages d'√©limination lin√©aire sur a,b =======================
  function niceCoeffTimesVar(coeff, variable){
    // √©crit "3a", "-a", "a", etc. sans "1a" ni "+ ..."
    if(coeff === 0) return '';
    if(variable === 'a'){
      if(coeff === 1) return 'a';
      if(coeff === -1) return '-a';
      return coeff+'a';
    }else{ // 'b'
      if(coeff === 1) return '+ b';
      if(coeff === -1) return '- b';
      if(coeff > 0) return '+ '+coeff+'b';
      return coeff+'b';
    }
  }
  function lhsFrom(Ac,Bc){
    // construit "8a - 6b" propre, sans espaces d√©gueu
    const pa = niceCoeffTimesVar(Ac,'a');
    const pb = niceCoeffTimesVar(Bc,'b');

    let txt = (pa + ' ' + pb).trim();
    txt = txt
      .replace(/\+\s-\s/g,'- ')
      .replace(/\s+/g,' ')
      .replace(/^\+ /,''); // si commence par "+ "
    return txt;
  }

  // construit la paire d'√©tapes d'√©limination :
 function elimStepsOnAB(A1,B1,C1,A2,B2,C2){
  function ppcm(x,y){
    const a = Math.abs(x), b = Math.abs(y);
    if(a===0 || b===0) return 0;
    function pgcd(u,v){ return v ? pgcd(v, u%v) : u; }
    return a*b/pgcd(a,b);
  }

  const L = ppcm(A1, A2);
  const k1 = L / A1;
  const k2 = L / A2;

  const LA = k1*A1;
  const LB = k1*B1;
  const LC = k1*C1;

  const MA = k2*A2;
  const MB = k2*B2;
  const MC = k2*C2;

  const FB = LB - MB;
  const FC = LC - MC;

  function lhsFrom(Ac,Bc){
    function niceCoeffTimesVar(coeff, variable){
      if(coeff === 0) return '';
      if(variable === 'a'){
        if(coeff === 1) return 'a';
        if(coeff === -1) return '-a';
        return coeff+'a';
      }else{
        if(coeff === 1) return '+ b';
        if(coeff === -1) return '- b';
        if(coeff > 0) return '+ '+coeff+'b';
        return coeff+'b';
      }
    }
    const pa = niceCoeffTimesVar(Ac,'a');
    const pb = niceCoeffTimesVar(Bc,'b');
    let txt = (pa + ' ' + pb).trim();
    txt = txt
      .replace(/\+\s-\s/g,'- ')
      .replace(/\s+/g,' ')
      .replace(/^\+ /,'');
    return txt;
  }

  function eqScaled(k,Ac,Bc,Cc){
    const lhs = lhsFrom(k*Ac, k*Bc);
    const rhs = k*Cc;
    return lhs + ' = ' + rhs;
  }

  // Pour b
  let isoB_lhs;
  if(FB === 1){
    isoB_lhs = 'b';
  }else if(FB === -1){
    isoB_lhs = '-b';
  }else{
    isoB_lhs = FB+'b';
  }
  const firstIsoB  = `${isoB_lhs} = ${FC}`;
  const secondIsoB = `b = ${b}`;

  // Pour a
  const A1a = (A1===1)?'a':(A1===-1?'-a':(A1+'a'));
  const A2a = (A2===1)?'a':(A2===-1?'-a':(A2+'a'));

  // ligne avec a utilisant la DEUXI√àME √©quation (celle qu'on appelle L4 chez toi)
  // A2 a + B2 b = C2  ->  A2 a = C2 - B2 b   (ou + si B2<0)
  let rhsA2a;
  if(B2===0){
    rhsA2a = C2;
  }else if(B2>0){
    rhsA2a = `${C2} - ${B2}\\times ${latexSignedNum(b)}`;
  }else{
    rhsA2a = `${C2} + ${Math.abs(B2)}\\times ${latexSignedNum(b)}`;
  }
  const lineIsoA2 = `${A2a} = ${rhsA2a}`;

  // nouvelle ligne interm√©diaire num√©rique : ex "3a = 3"
  const Ares = A2 * a; // ex: si A2=3 et a=1 -> 3
  const lineIsoA2num = `${A2a} = ${Ares}`;

  const lineFinalA = `a = ${a}`;

  // maintenant on g√®re l'affichage des op√©rations de lignes
  // on doit faire sauter les annotations si k2 = 1
  const multLineForL4 = (k2 === 1)
    ? `${eqScaled(k2,A2,B2,C2)}`
    : `${eqScaled(k2,A2,B2,C2)} \\; (L_4 \\leftarrow ${k2}\\times L_2)`;

  const divLineForL4 = (k2 === 1)
    ? `${eqAB2}`
    : `${eqAB2} \\;(L_4\\leftarrow L_4/${k2})`;

  const step1block = `
\\left\\{
  \\begin{array}{l}
    d = ${d0} \\\\
  ${eqScaled(k1,A1,B1,C1)} \\; (L_2 \\leftarrow ${k1}\\times L_2) \\\\
        c = ${m0} \\\\
  ${multLineForL4} \\\\
  \\end{array}
\\right.
`;

  const step2block = `
\\left\\{
  \\begin{array}{l}
    d = ${d0} \\\\
  ${firstIsoB} \\; (L_2\\leftarrow L_2-L_4) \\\\
        c = ${m0} \\\\
      ${divLineForL4} \\\\
  \\end{array}
\\right.
    \\Longleftrightarrow

\\left\\{
  \\begin{array}{l}
    d = ${d0} \\\\
  ${secondIsoB} \\\\
        c = ${m0} \\\\
  ${lineIsoA2} \\\\
  \\end{array}
\\right.
 \\Longleftrightarrow

\\left\\{
  \\begin{array}{l}
    d = ${d0} \\\\
  ${secondIsoB} \\\\
        c = ${m0} \\\\

  ${lineIsoA2num} \\\\

  \\end{array}
\\right.
`;

  return { step1block, step2block };
}


 

  
  const {step1block, step2block} = elimStepsOnAB(A1,B1,C1,A2,B2,C2);

  // Bloc final valeurs trouv√©es :
  const finalBlock = `
\\left\\{
  \\begin{array}{l}
  a = ${a} \\\\
  b = ${b} \\\\
  c = ${c} \\\\
  d = ${d0}
  \\end{array}
\\right.
`;

  // ================= HTML complet =====================
  return `
    <div class="line"><em>Traduction des hypoth√®ses :</em></div>

    <div class="line">
      \\(H_1\\) : \\(f(0)=${d0}\\)<br/>
      \\(H_2\\) : \\(f(${latexBareNum(XA)})=${YA}\\)<br/>
      \\(H_3\\) : \\(f'(0)=${m0}\\)<br/>
      \\(H_4\\) : \\(f'(${latexBareNum(XH)})=0\\)
    </div>

    <div class="line" style="margin-top:.6rem">
    \\[
    \\left\\{
      \\begin{array}{l}
      f(0)=${d0} \\\\
      f(${latexBareNum(XA)})=${YA} \\\\
      f'(0)=${m0} \\\\
      f'(${latexBareNum(XH)})=0
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      d = ${d0} \\\\
      ${rawEq_fXA()} \\\\
      ${rawEq_fp0()} \\\\
      ${rawEq_fpXH()}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      d = ${d0} \\\\
      ${eq_XA_combo} = ${YA} \\\\
      c = ${m0} \\\\
      ${eq_fpXH_combo}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      d = ${d0} \\\\
      ${eqPointA_afterSub()} \\\\
      c = ${m0} \\\\
      ${eqDerivXH_afterSub()}
      \\end{array}
    \\right.
	\\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      d = ${d0} \\\\
      ${eqAB1} \\\\
      c = ${m0} \\\\
      ${eqAB2}
      \\end{array}
    \\right.
    \\]
    </div>

    <div class="line" style="margin-top:.6rem">
    \\[
    
    \\Longleftrightarrow
    ${step1block}
    \\Longleftrightarrow
    ${step2block}

    \\Longleftrightarrow
    ${finalBlock}
    \\]
    </div>
  `;
}







  const enonceHTML = `
  On consid√®re la fonction \\(f\\) d√©finie sur \\(\\mathbb{R}\\) par
  \\[ f(x)=${efLatex} \\]
  et l‚Äôon note \\(\\mathcal{C}_f\\) sa courbe repr√©sentative dans le plan muni d‚Äôun rep√®re \\((O;\\vec{i},\\vec{j})\\).
  <ol style="margin-top:.5rem">
    <li>Calculer \\(f'(x)\\)  selon \\(a, b, c\\) \\( \\) et \\( \\) \\(d\\).</li>
    <li>D√©terminer \\( \\) \\(a, b, c\\) \\( \\) et \\( \\) \\(d\\) \\( \\) sachant que \\( \\) \\(\\mathcal{C}_f\\) \\( \\) v√©rifie les hypoth√®ses suivantes :
      <ul>
        <li>\\(H_1 :\\) \\( \\) \\(\\mathcal{C}_f\\) \\( \\)  coupe l‚Äôaxe des ordonn√©es au point d‚Äôordonn√©e \\( \\)  \\(${d0}\\).</li>
        <li>\\(H_2 :\\) \\( \\) \\(\\mathcal{C}_f\\) \\( \\)  passe par le point \\( \\)  \\(A(${XA}\\,;\\,${YA})\\).</li>
        <li>\\(H_3 :\\) \\( \\) La tangente √† \\( \\)  \\(\\mathcal{C}_f\\)  \\( \\) au point d‚Äôabscisse \\( \\)  \\(${x0}\\) a pour coefficient directeur \\( \\)  \\(${m0}\\).</li>
        <li>\\(H_4 :\\) \\( \\) \\(\\mathcal{C}_f\\) \\( \\)  admet une tangente horizontale au point d‚Äôabscisse \\( \\)  \\(${XH}\\).</li>
      </ul>
      Donner l‚Äôexpression finale de \\(f(x)\\).
    </li>
  </ol>
  `;

  const solHTML = `
  <div class="steps">
    <div class="line stepTitle">1) D√©riv√©e g√©n√©rale</div>
    <div class="line">\\(f(x)=ax^{3}+bx^{2}+cx+d\\) \\( \\) donc \\( \\) \\(f'(x)=3ax^{2}+2bx+c\\).</div>

    <div class="line stepTitle">2) Utilisation des hypoth√®ses</div>
${buildSystemCubic_full(a,b,c,d, XA,YA, x0,m0, XH, d0)}


    <div class="line stepTitle">Conclusion</div>
    <div class="line">On a \\( \\) \\(a=${a},\\;b=${b},\\;c=${c}\\) \\( \\) et \\( \\)  \\(d=${d}.\\)</div>
    <div class="line">Donc \\( \\)  \\(f(x)=${fLatex}\\).</div>
    <div class="line">Et \\( \\)  \\(f'(x)=${fpLatex}\\).</div>
  </div>
  `;

  function fpEval(x){
    return 3*a*x*x + 2*b*x + c;
  }
  
  
  function fEval(x){ return a*x*x*x + b*x*x + c*x + d; }

  const coeffsRef={a,b,c,d};

  const fSymbolicLatex   = `ax^{3}+bx^{2}+cx+d`;
  const fpSymbolicLatex  = `3ax^{2}+2bx+c`;
  const fFinalLatex      = fLatex;

  const hypInputs = [
    { id:"H1", label:"H‚ÇÅ se traduit par :", expect:`f(0)=${d0}` },
    { id:"H2", label:"H‚ÇÇ se traduit par :", expect:`f(${XA})=${YA}` },
    { id:"H3", label:"H‚ÇÉ se traduit par :", expect:`f'(0)=${m0}` },
    { id:"H4", label:"H‚ÇÑ se traduit par :", expect:`f'(${XH})=0` },
  ];

  return {
    title:"Exercice 2 : Retrouver la fonction (3√®me degr√©)",
    enonce:enonceHTML,
    solHTML,
    fpEval,
	fEval,
    fpLatex:fpLatex,
    coeffsRef,
    hypInputs,
    fpSymbolicLatex,
    fSymbolicLatex,
    fFinalLatex
  };
}



function genRacine(){
  // On veut f(x) = a‚àöx + b x + c
  // Domaine [0;+‚àû[
  //
  // Hypoth√®ses dans l'√©nonc√© :
  //  - Cf passe par A(xA ; yA)
  //  - La tangente en A a pour √©quation y = m x + p
  //
  // Donc :
  //    yA = m*xA + p                (point sur la tangente)
  //    pente en A = m = f'(xA)
  //    f'(x) = a/(2‚àöx) + b
  // =>  b = m - a/(2‚àöxA)
  // Puis :
  //    yA = a‚àöxA + b xA + c
  // =>  c = yA - a‚àöxA - b xA
  //
  // But : a,b,c entiers petits.
  //
  // Strat√©gie :
  //   - tirer xA dans {1,4,9} pour que ‚àöxA soit entier
  //   - tirer m,p,a entiers petits
  //   - calculer b ; imposer b entier
  //   - calculer c ; imposer c entier
  //   - rejeter si coefficients trop gros ou moches
  //
  // On boucle jusqu'√† trouver propre.

  let a,b,c;
  let xA,m,p,yA;
  let tries = 0;
  while (tries < 200) {
    tries++;

    // xA carr√© parfait pour ‚àöxA entier
    xA = choice([1,4,9]);
    const rootXA = Math.sqrt(xA); // 1,2,3

    // pente de la tangente (coefficient directeur)
    m = nzChoose([-3,-2,-1,1,2,3]);

    // ordonn√©e √† l'origine de la tangente
    p = rnd(-5,5);

    // point A est sur la tangente => yA = m*xA + p
    yA = m * xA + p;

    // Choix de a (coefficient devant ‚àöx) : petit entier
    a = nzChoose([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);

    // Calcul b = m - a/(2‚àöxA)
    // On impose que a/(2‚àöxA) soit entier pour que b soit entier.
    const denom = 2 * rootXA; // 2,4,6
    if (a % denom !== 0) continue; // sinon b pas entier
    const fracPart = a / denom;    // entier
    b = m - fracPart;              // entier

    // Maintenant calcul de c
    // c = yA - a‚àöxA - b xA
    // -> tous entiers ? rootXA entier, OK
    c = yA - a*rootXA - b*xA;

    // V√©rif entiers ?
    if (!Number.isInteger(b)) continue;
    if (!Number.isInteger(c)) continue;

    // bornes de "propret√©"
    if (Math.abs(a) > 12) continue;
    if (Math.abs(b) > 12) continue;
    if (Math.abs(c) > 30) continue;

    // on accepte ce tirage
    break;
  }

  // Fallback manuel si rien trouv√© (c'est tr√®s improbable maintenant)
  if (tries >= 200) {
    // Exemple propre :
    // prenons xA=4 => ‚àöxA=2
    // choisissons m=1, p=3 => yA=1*4+3=7
    // prenons a=4
    // 2‚àöxA=2*2=4 ‚Üí a/(2‚àöxA)=4/4=1 ‚Üí b = m - 1 = 0
    // c = yA - a‚àöxA - b xA = 7 - 4*2 - 0 = -1
    xA = 4; const rootXA = 2;
    m  = 1;
    p  = 3;
    yA = 7;
    a  = 4;
    b  = 0;
    c  = -1;
  }
  const efLatex= `a\\sqrt{x}+bx+c`;

  // Helpers LaTeX pour affichage propre
  function fLatexR(a,b,c){
    // construit a‚àöx + b x + c
    // r√®gles :
    //  - pas "1x"
    //  - pas "1‚àöx"
    //  - pas "+0"
    const parts=[];

    // terme a‚àöx
    if (a !== 0){
      if (a === 1){
        parts.push(`\\sqrt{x}`);
      } else if (a === -1){
        parts.push(`-\\sqrt{x}`);
      } else {
        parts.push(`${a}\\sqrt{x}`);
      }
    }

    // terme b x
    if (b !== 0){
      const bb = Math.abs(b);
      const mono = (bb===1?'x':bb+'x');
      parts.push((b<0?'- ':'+ ')+mono);
    }

    // constante c
    if (c !== 0 || !parts.length){
      const cc = Math.abs(c);
      parts.push((c<0?'- ':'+ ')+cc);
    }

    return parts.join(' ').replace(/^\+\s*/,'').trim();
  }

  function fpLatexR(a,b){
    // f'(x)= a/(2‚àöx) + b
    // m√™me style : pas "+0"
    // pas "1" inutile devant x
    // On fabrique les deux morceaux puis on nettoie.
    let term1 = '';
    if (a !== 0){
      // a/(2‚àöx)
      // si a=1 ‚Üí "1/(2‚àöx)" ; si a=-1 ‚Üí "-1/(2‚àöx)" ; sinon "a/(2‚àöx)"
      const num = (a===1) ? '1' : (a===-1 ? '-1' : String(a));
      term1 = `\\dfrac{${num}}{2\\sqrt{x}}`;
    }

    let term2 = '';
    if (b !== 0){
      const sign = (b<0?'- ':'+ ');
      const absb = Math.abs(b);
      term2 = sign + absb;
    }

    let full = (term1 + (term2 ? (' ' + term2) : '')).trim();
    full = full.replace(/^\+\s*/,''); // vire un + initial inutile
    if (full === '') full = '0';
    return full;
  }

  const fLatex   = fLatexR(a,b,c);       // f(x)
  const fpLatex  = fpLatexR(a,b);        // f'(x)

function buildSystemRacine_full(a,b,c,xA,yA,m,p){



  const r = Math.sqrt(xA); // entier (1,2,3,...) garanti par g√©n√©ration
  // pente : f'(xA) = a/(2r) + b = m
  // point : f(xA) = a*r + b*xA + c = yA

  // On va produire les √©tapes fa√ßon syst√®me encha√Æn√©.

  // Substitution explicite sans simplifier "a/(2r) + b = m"
  const eqPenteSub  = `\\dfrac{a}{2\\times ${r}} + b = ${m}`;
  // Substitution explicite pour le point :
  const eqPointSub  = `a\\times ${r} + b\\times ${xA} + c = ${yA}`;

  return `
    <div class="line"><em>Traduction des hypoth√®ses :</em></div>
    <div class="line">
      \\(H_1\\) : \\(A(${xA};${yA})\\in \\mathcal{C}_f\\), donc \\(f(${xA})=${yA}\\)<br/>
      \\(H_2\\) : la tangente en \\(A\\) a pour √©quation \\(y=${m}x ${p>=0?'+':'-'} ${Math.abs(p)}\\).
      Sa pente vaut \\(${m}\\), donc \\(f'(${xA})=${m}\\).
    </div>

    <div class="line" style="margin-top:.4rem">
    \\[
    \\left\\{
      \\begin{array}{l}
      f(${xA})=${yA} \\\\
      f'(${xA})=${m}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      a\\sqrt{${xA}} + b\\times ${xA} + c = ${yA} \\\\
      \\dfrac{a}{2\\sqrt{${xA}}} + b = ${m}
      \\end{array}
    \\right.
    \\Longleftrightarrow
    \\left\\{
      \\begin{array}{l}
      ${eqPointSub} \\\\
      ${eqPenteSub}
      \\end{array}
    \\right.
    \\]
    </div>

    <div class="line" style="margin-top:.4rem">
    En r√©solvant ce syst√®me en \\(a,b,c\\) (avec \\(\\sqrt{${xA}}=${r}\\)), on obtient :
    \\[
    \\left\\{
      \\begin{array}{l}
      a = ${a} \\\\
      b = ${b} \\\\
      c = ${c}
      \\end{array}
    \\right.
    \\]
    </div>
  `;
}




  // === ENONCE ===
  const enonceHTML = `
  Soit \\(f\\) la fonction d√©finie sur \\([0;+\\infty[\\) par
  \\[ f(x)=${efLatex} \\]
  et l‚Äôon note \\(\\mathcal{C}_f\\) sa courbe repr√©sentative dans le plan muni d‚Äôun rep√®re \\((O;\\vec{i},\\vec{j})\\).
  <ol style="margin-top:.5rem">
    <li>Calculer \\(f'(x)\\) selon \\( \\) \\(a, b\\) \\( \\) et \\( \\) \\(c\\).</li>
    <li>D√©terminer \\( \\) \\(a, b\\) \\( \\) et \\( \\) \\(c\\) \\( \\) sachant que \\( \\) \\(\\mathcal{C}_f\\) \\( \\) v√©rifie les hypoth√®ses suivantes :
      <ul>
        <li>\\(H_1 :\\) \\( \\) \\(\\mathcal{C}_f\\)  \\( \\) passe par le point \\( \\)  \\(A(${xA}\\,;\\,${yA})\\).</li>
        <li>\\(H_2 :\\) \\( \\) La tangente en \\(A\\) √† \\(\\mathcal{C}_f\\) \\( \\)  a pour √©quation r√©duite \\( \\)  \\(y=${m}x ${p>=0?'+':'-'} ${Math.abs(p)}\\).</li>
      </ul>
      Donner l‚Äôexpression finale de \\(f(x)\\).
    </li>
  </ol>
  `;

  // === SOLUTION ===
  const solHTML = `
  <div class="steps">
    <div class="line stepTitle">1) D√©riv√©e g√©n√©rale</div>
    <div class="line">Si \\(f(x)=a\\sqrt{x}+bx+c\\) alors \\(f'(x)=\\dfrac{a}{2\\sqrt{x}}+b\\).</div>
    <div class="line">Donc \\(f'(x)=${fpLatex}\\).</div>

    <div class="line stepTitle">2) Utilisation des hypoth√®ses</div>
${buildSystemRacine_full(a,b,c,xA,yA,m,p)}

    <div class="line stepTitle">Conclusion</div>
    <div class="line">On a \\(a=${a},\\;b=${b},\\;c=${c}.\\)</div>
    <div class="line">Donc \\(f(x)=${fLatex}\\).</div>
    <div class="line">Et \\(f'(x)=${fpLatex}\\).</div>
  </div>
  `;

  // Pour checkExoB :
  // fpEval(x) doit renvoyer num√©riquement f'(x)
  function fpEval(x){
    if (x <= 0) return NaN;
    return a/(2*Math.sqrt(x)) + b;
  }

function fEval(x){
  if (x < 0) return NaN;
  return a*Math.sqrt(x) + b*x + c;
}

  const coeffsRef = {a,b,c};

  // formes
  const fSymbolicLatex   = `a\\sqrt{x}+bx+c`;
  const fpSymbolicLatex  = `\\dfrac{a}{2\\sqrt{x}}+b`;
  const fFinalLatex      = fLatex;

  const hypInputs = [
    { id:"H1", label:"H‚ÇÅ se traduit par :", expect:`f(${xA})=${yA}` },
    { id:"H2", label:"H‚ÇÇ se traduit par :", expect:`f'(${xA})=${m}` },
  ];

  return {
    title:"Exercice 2 : Retrouver la fonction (racine)",
    enonce:enonceHTML,
    solHTML,
    fpEval,
	  fEval,

    fpLatex: fpLatex,
    coeffsRef,
    hypInputs,
    fpSymbolicLatex,
    fSymbolicLatex,
    fFinalLatex
  };
}



/* v√©rif ExoB :
   ansMain doit √™tre √©quivalent √† f'(x)
   ansCoeff doit contenir les bons coeffs
*/

function genExCoeffs(){
  // modeCoeffs : 'mix2' | 'deg2' | 'deg3' | 'quot' | 'racine'
  function pick(mode){
    if(mode==='deg2')   return genP2();
    if(mode==='deg3')   return genCubic();
    if(mode==='quot')   return genQuot();
    if(mode==='racine') return genRacine();
    // mix2 => tirage parmi les 4 cas
    const bag = [genP2, genCubic, genQuot, genRacine];
    return choice(bag)();
  }
  return pick(modeCoeffs);
}






function normalizeHypoStr(s){
  return s
    .replace(/\s+/g,'')       // vire tous les espaces
    .replace(/f'\s*\(/g,"f'(") // f'(  -> f'(
    .replace(/f\s*\(/g,"f(");  // f (  -> f(
}

function stripPowUnicode(s){
  return s
    .replace(/¬≤/g,"^2")
    .replace(/¬≥/g,"^3")
    .replace(/‚Å¥/g,"^4");
}

function normalizeSymbolic(s){
  return stripPowUnicode(s)
    .replace(/^f'?\(x\)\s*=\s*/i,'') // enl√®ve "f'(x)=" ou "f(x)="
    .replace(/\s+/g,'')
    .replace(/\*/g,'')
    .replace(/\((x)\)/g,'$1')
    .toLowerCase();
}

function checkDeriveeSymbolique(st){
  const field = $('#ansMain');
  const raw   = field ? field.value : '';
  const trimmed = raw.trim();

  // si vide => pas de tick, pas de sanction
  if(trimmed === ''){
    setTick('#tickMain', null);
    return {answered:false, ok:false};
  }

  // mod√®le attendu en lettres : st.fpSymbolicLatex
  let model = st.fpSymbolicLatex || '';
  model = model
    .replace(/\{([^}]+)\}/g,'$1') // x^{2} -> x^2
    .replace(/\\times/g,'')
    .replace(/\\/g,'');

  const uNorm = normalizeSymbolic(raw);
  const mNorm = normalizeSymbolic(model);

  const good = (uNorm === mNorm);
  setTick('#tickMain', good);
  return {answered:true, ok:good};
}

function normalizeHypoStr(s){
  return s
    .replace(/\s+/g,'')
    .replace(/f'\s*\(/g,"f'(")
    .replace(/f\s*\(/g,"f(")
    .toLowerCase();
}

function checkHypotheses(st){
  // On va calculer :
  // - est-ce qu'au moins un champ est rempli ?
  // - est-ce que tous les champs remplis sont bons ?
  let anyAnswered = false;
  let allGoodSoFar = true;

  if(st.hypInputs){
    st.hypInputs.forEach(h=>{
      const field   = $('#hyp_'+h.id);
      const tickSel = '#tick_'+h.id;

      if(!field){
        setTick(tickSel, null);
        return;
      }

      const raw = field.value || '';
      const trimmed = raw.trim();

      if(trimmed === ''){
        // vide -> pas de tick
        setTick(tickSel, null);
        return;
      }

      anyAnswered = true;

      const uNorm   = normalizeHypoStr(raw);
      const eNorm   = normalizeHypoStr(h.expect);
      const good    = (uNorm === eNorm);

      setTick(tickSel, good);
      if(!good) allGoodSoFar=false;
    });
  }

  return {
    answered:anyAnswered,
    ok: anyAnswered ? allGoodSoFar : false
  };
}

function parseCoeff(str){
  const obj={};
  const parts=str.split(/[,;]+/).map(s=>s.trim()).filter(Boolean);
  parts.forEach(p=>{
    const m = p.match(/^([abcd])\s*=\s*(-?\d+)$/i);
    if(m){
      obj[m[1].toLowerCase()]=Number(m[2]);
    }else{
      if(!obj._arr) obj._arr=[];
      const n = Number(p.replace(',','.'));
      if(!Number.isNaN(n)) obj._arr.push(n);
    }
  });
  return obj;
}

function checkCoeffs(st){
  const field = $('#ansCoeff');
  const raw   = field ? field.value : '';
  const trimmed = raw.trim();

  if(trimmed === ''){
    setTick('#tickCoeff', null);
    return {answered:false, ok:false};
  }

  const got = parseCoeff(raw);
  const ref = st.coeffsRef;
  let ok=true;

  if(ref.d!==undefined){
    // a,b,c,d
    if( got.a!==ref.a || got.b!==ref.b || got.c!==ref.c || got.d!==ref.d ){
      if(!(got._arr && got._arr.length===4 &&
           got._arr[0]===ref.a && got._arr[1]===ref.b &&
           got._arr[2]===ref.c && got._arr[3]===ref.d)){
        ok=false;
      }
    }
  }else if(ref.c!==undefined){
    // a,b,c
    if( got.a!==ref.a || got.b!==ref.b || got.c!==ref.c ){
      if(!(got._arr && got._arr.length===3 &&
           got._arr[0]===ref.a && got._arr[1]===ref.b && got._arr[2]===ref.c)){
        ok=false;
      }
    }
  }else{
    // a,b
    if( got.a!==ref.a || got.b!==ref.b ){
      if(!(got._arr && got._arr.length===2 &&
           got._arr[0]===ref.a && got._arr[1]===ref.b)){
        ok=false;
      }
    }
  }

  setTick('#tickCoeff', ok);
  return {answered:true, ok};
}

function cleanFxUserInput(){
  let raw = $('#ansFxFinal')?.value || '';
  // pas besoin de tout traiter ici, evalWithCoeffs va nettoyer beaucoup
  return raw;
}

function checkFxFinal(st){
  const ansFx = cleanFxUserInput();
  if(ansFx.trim()===''){
    setTick('#tickFxFinal', null);
    return {answered:false, ok:false};
  }

  const xs=[-2,-1,0,1,2,3];
  let forbid = null;
  if (typeof st.p === 'number' && typeof st.q === 'number') {
    forbid = -st.q / st.p;
  }

  for(const xx of xs){
    if (forbid !== null && Math.abs(xx - forbid) < 1e-9) {
      continue;
    }

    const vUser = evalWithCoeffs(ansFx, st.coeffsRef, xx);
    const vRef  = st.fEval(xx);
    if(!Number.isFinite(vUser)||!Number.isFinite(vRef)||!almost(vUser,vRef,1e-6)){
      setTick('#tickFxFinal', false);
      return {answered:true, ok:false};
    }
  }

  setTick('#tickFxFinal', true);
  return {answered:true, ok:true};
}




function evalWithCoeffs(expr, coeffs, x){
  if(!expr) return NaN;
  let s = String(expr);

  // 0) remplacer "f(x)=" ou "f'(x)=" s'il y en a un
  s = s.replace(/^f'?\(x\)\s*=\s*/i,'');

  // 1) s√©curiser les multiplications implicites AVANT substitution a,b,c,...
  //    ex: "2ax" -> "2*a*x", "3bx^2" -> "3*b*x^2", ")x" -> ")*x", "ax" -> "a*x"
  //    chiffre ou ")" suivi d'une lettre a,b,c,d,p,q,x  => "*"
  s = s.replace(/(\d|\))(?=[a-dpqx])/gi, '$1*');
  //    lettre a,b,c,d,p,q suivie de "(" ou "x" => "a*("
  s = s.replace(/([a-dpq])(?=\()/gi, '$1*');
  s = s.replace(/([a-dpq])(?=x)/gi, '$1*');
  //    ")" suivi de "x" => ")*x"
  s = s.replace(/\)(?=x)/gi, ')*x');

  // 2) remplacer a,b,c,d,p,q par leurs valeurs
  for (const k of ['a','b','c','d','p','q']){
    if (coeffs[k]!==undefined){
      const re = new RegExp(`\\b${k}\\b`,'gi');
      s = s.replace(re, '('+coeffs[k]+')');
    }
  }

  // 3) apr√®s substitution, on peut avoir par ex "(2)x" -> "(2)*x"
  //    nombre ou ")" suivi de "x" => "*x"
  s = s.replace(/(\d|\))(?=x)/g, '$1*');
  //    "x(" => "x*("
  s = s.replace(/x(?=\()/g, 'x*(');
  //    ")(" => ")*("
  s = s.replace(/\)\s*\(/g, ')*(');

  // 4) TR√àS IMPORTANT : g√©rer les coefficients implicites ¬±x, ¬±x^2, etc.
  //    surtout les "-x" -> "-1*x", "+x" -> "+1*x", "(x" -> "(1*x"
  s = insertImplicitOne(s);

  // 5) maintenant qu'on a rendu √ßa propre, on d√©l√®gue √† numEval,
  //    qui va g√©rer :
  //      - les racines ("‚àöx", "rac(x)", "\sqrt{}"...)
  //      - les puissances "x^3", "x¬≥"
  //      - les multiplications implicites r√©siduelles
  //      - et finalement remplacer x par la valeur num√©rique
  return numEval(s, x);
}



function checkExprWithCoeffs(exprUser, fnRef, coeffs){
  if(!exprUser || exprUser.trim()==='') return {answered:false, ok:false};

  const xs = [-2,-1,0,1,2,3];
  for (const x of xs){
    const vUser = evalWithCoeffs(exprUser, coeffs, x);
    const vRef  = fnRef(x);
    if(!Number.isFinite(vUser)||!Number.isFinite(vRef)||!almost(vUser,vRef,1e-6)){
      return {answered:true, ok:false};
    }
  }
  return {answered:true, ok:true};
}

function checkDeriveeNum(st){
  const ansDeriv = $('#ansMain')?.value || '';
  if(ansDeriv.trim()===''){
    setTick('#tickMain', null);
    return {answered:false, ok:false};
  }

  const xs=[-2,-1,0,1,2,3];

  // si c'est un quotient, on a st.p et st.q (on va les renvoyer depuis genQuot)
  // on √©vite x = -q/p
  let forbid = null;
  if (typeof st.p === 'number' && typeof st.q === 'number') {
    forbid = -st.q / st.p;
  }

  for(const xx of xs){
    if (forbid !== null && Math.abs(xx - forbid) < 1e-9) {
      continue; // on saute le x qui annule le d√©nominateur
    }

    const vUser = evalWithCoeffs(ansDeriv, st.coeffsRef, xx);
    const vRef  = st.fpEval(xx); // d√©riv√©e num√©rique officielle

    if(!Number.isFinite(vUser)||!Number.isFinite(vRef)||!almost(vUser,vRef,1e-6)){
      setTick('#tickMain', false);
      return {answered:true, ok:false};
    }
  }

  setTick('#tickMain', true);
  return {answered:true, ok:true};
}





function checkExoB(st){
  const rDeriv = checkDeriveeNum(st);   // f'(x)= ...
  const rHyps  = checkHypotheses(st);   // H1..H4
  const rCoef  = checkCoeffs(st);       // coeffs
  const rFx    = checkFxFinal(st);      // f(x)= ...

  const blocks = [rDeriv, rHyps, rCoef, rFx];
  let thisCount = 0;
  let thisGood  = 0;
  for(const b of blocks){
    if(b.answered){
      thisCount++;
      if(b.ok) thisGood++;
    }
  }
  scoreTot += thisCount;
  scoreOK  += thisGood;
  updateScore();

  return {count:thisCount, good:thisGood};
}





/* =========================================================
   RENDU / UI
   ========================================================= */

function buildHostHTML_A(st){
  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>

      <div style="margin-bottom:.6rem; display:flex; flex-wrap:wrap; align-items:center; gap:.5rem;">
        <label for="mode-tangentes" style="font-weight:600; white-space:nowrap;">
          Type de fonction tir√©e :
        </label>
        <select id="mode-tangentes" style="padding:4px 8px; border:1px solid #ccc; border-radius:6px; font-size:.9rem; line-height:1.3;">
          <option value="mix"${modeTangentes==='mix'?' selected':''}>M√©lange</option>
          <option value="deg2"${modeTangentes==='deg2'?' selected':''}>2nd degr√©</option>
          <option value="deg3"${modeTangentes==='deg3'?' selected':''}>3√®me degr√©</option>
        </select>
        <button type="button" id="regen-tangentes" class="btn" style="font-size:.8rem;padding:6px 10px;">
          üîÑ Re-tirer
        </button>
      </div>

      <div class="enonce">${st.enonce}</div>

      <div class="answers">
	          <div class="qa-row">
          <label for="ans0">\\(g'(x)=\\)</label>
          <input id="ans0" class="inp" style="min-width:260px">
          <span id="tick0" class="tick" style="margin-left:6px"></span>
        </div>
		        <div class="qa-row"><strong>1) Tangente horizontale :</strong></div>
  <div class="qa-row">
          <label for="ans1a">Il faut r√©soudre l'√©quation :</label>
          <input id="ans1a" class="inp" style="min-width:260px">
          <span id="tick1a" class="tick" style="margin-left:6px"></span>
        </div>
        <div class="qa-row">
          <label for="ans1">Abscisse du ou des point(s) de tangence</label>
          <input id="ans1" class="inp" style="min-width:260px">
          <span id="tick1" class="tick" style="margin-left:6px"></span>
        </div>
				        <div class="qa-row"><strong>2) Tangente // droite :</strong></div>
<div class="qa-row">
          <label for="ans2a">Il faut r√©soudre l'√©quation :</label>
          <input id="ans2a" class="inp" style="min-width:260px">
          <span id="tick2a" class="tick" style="margin-left:6px"></span>
        </div>
        <div class="qa-row">
        <div class="qa-row">
          <label for="ans2">Abscisse du ou des point(s) de tangence</label>
          <input id="ans2" class="inp" style="min-width:260px">
          <span id="tick2" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}


function buildHostHTML_B(st){
  // fabrique le bloc d'inputs des hypoth√®ses dynamiquement
  let hypRows = '';
  if (st.hypInputs && st.hypInputs.length){
    hypRows += `<div class="qa-row"><strong>Traduction des hypoth√®ses :</strong></div>`;
    st.hypInputs.forEach(h=>{
      hypRows += `
        <div class="qa-row">
          <label for="hyp_${h.id}">${h.label}</label>
          <input id="hyp_${h.id}" class="inp" style="min-width:260px"
                 placeholder="">
          <span id="tick_${h.id}" class="tick" style="margin-left:6px"></span>
        </div>`;
    });
  }

  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>

      <div style="margin-bottom:.6rem; display:flex; flex-wrap:wrap; align-items:center; gap:.5rem;">
        <label for="mode-coeffs" style="font-weight:600; white-space:nowrap;">
          Type de fonction tir√©e :
        </label>
        <select id="mode-coeffs" style="padding:4px 8px; border:1px solid #ccc; border-radius:6px; font-size:.9rem; line-height:1.3;">
          <option value="mix2"${modeCoeffs==='mix2'?' selected':''}>M√©lange</option>
          <option value="deg2"${modeCoeffs==='deg2'?' selected':''}>2nd degr√©</option>
          <option value="deg3"${modeCoeffs==='deg3'?' selected':''}>3√®me degr√©</option>
          <option value="quot"${modeCoeffs==='quot'?' selected':''}>Quotient</option>
          <option value="racine"${modeCoeffs==='racine'?' selected':''}>Racine</option>
        </select>
        <button type="button" id="regen-coeffs" class="btn" style="font-size:.8rem;padding:6px 10px;">
          üîÑ Re-tirer
        </button>
      </div>

      <div class="enonce">${st.enonce}</div>

      <div class="answers">

        <div class="qa-row">
          <label for="ansMain"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansMain" class="inp" style="min-width:360px">
          <span id="tickMain" class="tick" style="margin-left:6px"></span>
        </div>
        ${hypRows}

        <div class="qa-row">
          <label for="ansCoeff"><strong>Coefficients :</strong></label>
          <input id="ansCoeff" class="inp" style="min-width:260px"
            placeholder="">
          <span id="tickCoeff" class="tick" style="margin-left:6px"></span>
        </div>
			            <div class="qa-row"><strong>Expression finale de f(x)</strong></div>

       <div class="qa-row">

          <label for="ansFxFinal">\\(f(x)=\\)</label>
        <input id="ansFxFinal" class="inp" style="min-width:360px">
          <span id="tickFxFinal" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}



function setTick(sel, ok){
  const el = (typeof sel==="string"? $(sel): sel);
  if(!el) return;

  if(ok === null){
    // √©tat neutre : rien du tout visuellement
    el.className = 'tick';
    el.textContent = '';
    return;
  }

  el.className = 'tick ' + (ok===true ? 'ok' : 'ko');
  el.textContent = ok===true ? '‚úì' : '‚úó';
}


/* =========================================================
   REGISTRY des exos
   ========================================================= */

const EXO_A = {
  id:'exoA',
  title:'Exercice 1 ‚Äî Tangentes parall√®les',
gen(host){
  const st = genExTangentes();
  if(host){
    host.innerHTML = buildHostHTML_A(st);
    host.__state = st;
    host.dataset.state = JSON.stringify({
      title   : st.title,
      enonce  : st.enonce,
      solHTML : st.solHTML
    });

    // brancher le s√©lecteur interne "mode-tangentes"
    const modeSel = $('#mode-tangentes', host);
    if(modeSel){
      modeSel.addEventListener('change', e=>{
        modeTangentes = e.target.value; // maj globale
      });
    }

    // bouton "Re-tirer" pour r√©g√©n√©rer cet exo 1 avec le mode courant
    const regenBtn = $('#regen-tangentes', host);
    if(regenBtn){
      regenBtn.addEventListener('click', ()=>{
        const fresh = genExTangentes(); // r√©g√©n√®re selon modeTangentes
        host.innerHTML = buildHostHTML_A(fresh);
        host.__state = fresh;
        host.dataset.state = JSON.stringify({
          title   : fresh.title,
          enonce  : fresh.enonce,
          solHTML : fresh.solHTML
        });

        // rebrancher les listeners sur la nouvelle version recr√©√©e :
        const newSel = $('#mode-tangentes', host);
        if(newSel){
          newSel.value = modeTangentes;
          newSel.addEventListener('change', e=>{
            modeTangentes = e.target.value;
          });
        }
        const newBtn = $('#regen-tangentes', host);
        if(newBtn){
          newBtn.addEventListener('click', ()=>{ regenBtn.click(); });
          // astuce simple : reboucle sur lui-m√™me
        }

        if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
        else if(window.MathJax?.typeset)   MathJax.typeset([host]);
        scanFractions(host);
      });
    }

    // affichage MathJax pour la premi√®re g√©n√©ration
    if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
    else if(window.MathJax?.typeset)   MathJax.typeset([host]);
    scanFractions(host);
  }
  return st;
},

  correct(host, st){
    const r = checkExoA(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typesetPromise) MathJax.typesetPromise([$('#res',host)]);
    else if(window.MathJax?.typeset)   MathJax.typeset([$('#res',host)]);
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick('#tick1', null);
    setTick('#tick2', null);
    const i1 = $('#ans1',host); if(i1) i1.value='';
    const i2 = $('#ans2',host); if(i2) i2.value='';
  }
};

const EXO_B = {
  id:'exoB',
  title:'Exercice 2 ‚Äî Retrouver la fonction',
  gen(host){
    const st = genExCoeffs();
    if(host){
      host.innerHTML = buildHostHTML_B(st);
      host.__state = st;
      host.dataset.state = JSON.stringify({
        title   : st.title,
        enonce  : st.enonce,
        solHTML : st.solHTML
      });

      // brancher le s√©lecteur interne "mode-coeffs"
      const modeSel = $('#mode-coeffs', host);
      if(modeSel){
        modeSel.addEventListener('change', e=>{
          modeCoeffs = e.target.value; // maj globale
        });
      }

      // bouton "Re-tirer"
      const regenBtn = $('#regen-coeffs', host);
      if(regenBtn){
        regenBtn.addEventListener('click', ()=>{
          const fresh = genExCoeffs();
          host.innerHTML = buildHostHTML_B(fresh);
          host.__state = fresh;
          host.dataset.state = JSON.stringify({
            title   : fresh.title,
            enonce  : fresh.enonce,
            solHTML : fresh.solHTML
          });

          // rebrancher les listeners sur la nouvelle version :
          const newSel = $('#mode-coeffs', host);
          if(newSel){
            newSel.value = modeCoeffs;
            newSel.addEventListener('change', e=>{
              modeCoeffs = e.target.value;
            });
          }
          const newBtn = $('#regen-coeffs', host);
          if(newBtn){
            newBtn.addEventListener('click', ()=>{ regenBtn.click(); });
          }

          if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
          else if(window.MathJax?.typeset)   MathJax.typeset([host]);
          scanFractions(host);
        });
      }

      if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
      else if(window.MathJax?.typeset)   MathJax.typeset([host]);
      scanFractions(host);
    }
    return st;
  },
  correct(host, st){
    const r = checkExoB(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typesetPromise) MathJax.typesetPromise([$('#res',host)]);
    else if(window.MathJax?.typeset)   MathJax.typeset([$('#res',host)]);
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick('#tickMain', null);
    setTick('#tickCoeff', null);
    const i1 = $('#ansMain',host); if(i1) i1.value='';
    const i2 = $('#ansCoeff',host); if(i2) i2.value='';
  }
};






const REG = [EXO_A,EXO_B];
window.REG = REG;
window.REGISTRY = REG;

/* =========================================================
   Montage UI / Score / Raccourcis
   ========================================================= */

function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);


/* =========================================================
   Adaptateur PDF (reprend ta logique SVG)
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try { st = JSON.parse(hostTmp.dataset.state || '{}'); } catch(_){}
        return st;
      },

      beforeRender(def, st, withSolutions){
        return (async () => {
          let host = null;
          try {
            host = document.createElement('div');
            host.id = 'pdf-host';
            host.style.position='fixed';
            host.style.left='-10000px';
            host.style.top='-10000px';
            document.body.appendChild(host);

            // reconstruit bloc exo basique
            host.innerHTML = `
              <div class="exo-block">
                <span class="exo-title">${st.title||''}</span>
                <div class="enonce">${st.enonce||''}</div>
                ${withSolutions?('<div style="margin-top:1rem;font-weight:600">Corrig√© :</div>'+(st.solHTML||'')):""}
              </div>
            `;
            host.dataset.state = JSON.stringify(st);

            // IFRAME sandbox pour MathJax SVG
            const iframe = document.createElement('iframe');
            iframe.style.position   = 'fixed';
            iframe.style.left       = '-10000px';
            iframe.style.top        = '-10000px';
            iframe.style.width      = '0';
            iframe.style.height     = '0';
            iframe.style.visibility = 'hidden';
            document.body.appendChild(iframe);

            const iwin = iframe.contentWindow;
            const idoc = iframe.contentDocument;

            idoc.open();
            idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
            idoc.close();

            const contentDiv = idoc.getElementById('content');
            contentDiv.innerHTML = host.innerHTML;

            contentDiv.querySelectorAll('mjx-container').forEach(mjx => {
              mjx.replaceWith(mjx.textContent || '');
            });
            contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml')
              .forEach(n => n.remove());

            // config MathJax SVG dans l'iframe
            const cfg = idoc.createElement('script');
            cfg.type = 'text/javascript';
            cfg.text = `
              window.MathJax = {
                tex: {
                  inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
                  displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
                  processEscapes: true,
                  packages: { '[+]': ['bbox','ams'] }
                },
                svg: { fontCache:'none' },
                options: { skipHtmlTags:['script','noscript','style','textarea'] },
                startup: { typeset:false }
              };
            `;
            idoc.head.appendChild(cfg);

            const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
            const mj = idoc.createElement('script');
            mj.type = 'text/javascript';
            mj.src  = svgScriptURL;
            idoc.head.appendChild(mj);

            // attendre le chargement + pr√™t
            await new Promise(resolve=>{ mj.onload=resolve; mj.onerror=resolve; });
            async function waitMathJaxReady(win){
              const limit = 200;
              let n = 0;
              while ((!win.MathJax) || (!win.MathJax.typesetPromise && !win.MathJax.typeset)){
                await new Promise(res=>setTimeout(res,5));
                n++; if(n>limit) break;
              }
            }
            await waitMathJaxReady(iwin);

            if (iwin.MathJax && iwin.MathJax.typesetPromise){
              await iwin.MathJax.typesetPromise([ contentDiv ]);
            } else if (iwin.MathJax && iwin.MathJax.typeset){
              iwin.MathJax.typeset([ contentDiv ]);
            }

            // Purge CHTML (on ne garde que SVG)
            (function purgeCHTML(){
              contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n => n.remove());
              contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n => n.remove());
              contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n => n.remove());
            })();

            const finalHTML = contentDiv.innerHTML;

            iframe.remove();
            host.remove();

            return finalHTML;
          } catch(e){
            console.error('beforeRender SVG error:', e);
            let fallbackHTML = '';
            if (host) {
              fallbackHTML = host.innerHTML;
              host.remove();
              host = null;
            }
            return fallbackHTML;
          }
        })();
      }

    });
  });
})();

/* =========================================================
   mobile tweaks (inchang√©)
   ========================================================= */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type='button';
          clone.removeAttribute('id');
          clone.addEventListener('click',(e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className='btn';
          fallback.type='button';
          fallback.textContent=label;
          fallback.addEventListener('click',(e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r<10) c.setAttribute('r','12');
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
