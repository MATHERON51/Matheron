<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äî Fonctions d√©riv√©es : D√©riv√©es et tangentes</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc d'√©tapes solution */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{
  white-space:nowrap;
  line-height:1.8;
  margin:.32rem 0;
}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:flex-start;
  column-gap:.4rem;
  row-gap:.2rem;
  flex-wrap:wrap;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
  white-space:nowrap;
}

@media print{ .controls{display:none !important;} }

/* on calme MathJax CHTML en inline */
mjx-container{
  line-height:1.2;
  font-size:1em;
  vertical-align:middle;
}
.steps mjx-container{
  padding-bottom:.08em;
}
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
  mjx-container{font-size:1em; line-height:1.2}
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}

/* table mini rappel */
.sysTab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.sysTab td{
  border:none;
  padding:4px 18px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
.sysTab td.eq{
  padding-right:4px;
}

.MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

<!-- MathJax pour l'√©cran (CHTML) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<!-- FIN MathJax √©cran -->

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1√®re ‚Äì Fonctions d√©riv√©es : D√©riv√©es et tangentes</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
    <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
    <button id="btn-solution" class="btn">üí° Solution</button>
    <button id="btn-reset" class="btn">üßπ R√©initialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; r√©ponses accept√©es :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^2</code>, <code>x^3</code>, <code>x¬≤</code>, etc.</li>
      <li>Parenth√®ses recommand√©es autour des fractions ou des quotients.</li>
      <li>Pour plusieurs abscisses, s√©pare-les par <code>;</code> (ex : <code>1 ; -2</code>).</li>
      <li>Tu peux √©crire <code>non</code> (ou laisser vide) si aucune tangente ne v√©rifie la condition demand√©e.</li>
      <li>Interdits : <code>1x</code> (√©crire <code>x</code>) ; <code>0x</code> ; <code>+0</code>.</li>
    </ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- D√©pendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';
// --- mode de g√©n√©ration pour l'exercice Tangentes ---
// "mix" = al√©atoire comme avant
// "deg2" = impose polyn√¥me degr√© 2
// "deg3" = impose polyn√¥me degr√© 3 (avec Œî)
let modeTangentes = 'mix';

/* =========================================================
   Utils
   ========================================================= */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));

let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }

function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

/* mini parse pour listes d'abscisses fournies par l'√©l√®ve */
function parseAbscissaList(str){
  if(!str) return [];
  str = String(str).trim();
  if(/^non$/i.test(str)) return [];
  return str.split(/[,;]/).map(s=>s.trim()).filter(s=>s!=='').map(s=>Number(s.replace(',','.')));
}

function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }

/* √©val simple de polyn√¥me affine */
function evalAffine(A,B,x){ return A*x+B; }

/* solve 2ax+b = k  => x = (k-b)/(2a)  si a!=0 */
function solveSlopeEq(a,b,k){
  const den = 2*a;
  if(den===0) return []; // d√©riv√©e est constante -> ou pas de solution ou infiniment
  const x0 = (k-b)/den;
  return [x0];
}

/* format latex d'un polyn√¥me ax^2+bx+c (en enlevant 0x, +0, 1x -> x, -1x -> -x) */
function quadToLatex(a,b,c){
  const parts=[];
  // ax^2
  if(a!==0){
    const aa = Math.abs(a);
    const m2 = (aa===1? 'x^{2}' : aa+'x^{2}');
    parts.push((a<0?'- ':'+ ')+m2);
  }
  // bx
  if(b!==0){
    const bb = Math.abs(b);
    const m1 = (bb===1? 'x' : bb+'x');
    parts.push((b<0?'- ':'+ ')+m1);
  }
  // c
  if(c!==0 || parts.length===0){
    const cc = Math.abs(c);
    parts.push((c<0?'- ':'+ ')+cc);
  }
  return parts.join(' ').replace(/^\+\s*/,'').trim();
}

/* f'(x)=2ax+b en latex */
function quadDerivLatex(a,b){
  // 2ax+b
  const A = 2*a;
  const B = b;
  const out=[];
  if(A!==0){
    const AA=Math.abs(A);
    const mono = (AA===1? 'x' : AA+'x');
    out.push((A<0?'- ':'+ ')+mono);
  }
  if(B!==0 || !out.length){
    const BB=Math.abs(B);
    out.push((B<0?'- ':'+ ')+BB);
  }
  return out.join(' ').replace(/^\+\s*/,'').trim();
}

/* affichage latex d'une droite y = m x + p */
function lineLatex(m,p){
  // y = mx + p  (sans 1x ni +0)
  const terms=[];
  if(m!==0){
    const mm=Math.abs(m);
    const mono=(mm===1? 'x' : mm+'x');
    terms.push( (m<0?'- ':'')+mono );
  }
  if(p!==0 || !terms.length){
    const pp=Math.abs(p);
    terms.push( (p<0?'- ':'+ ')+pp );
  }
  let rhs=terms.join(' ').replace(/^\+\s*/,'').trim();
  return 'y = '+rhs;
}

/* v√©rification √©l√®ve ExoA :
   - champ1 : abscisses // horizontales
   - champ2 : abscisses // parall√®le √† y = m x + p
*/
function checkExoA(st){
  // on parse les r√©ponses
  const ans1 = parseAbscissaList( $('#ans1')?.value || '' );
  const ans2 = parseAbscissaList( $('#ans2')?.value || '' );

  // les vraies solutions num√©riques (ensembles d'abscisses)
  const sol1 = st.roots0; // pente 0
  const sol2 = st.rootsM; // pente m

  // On accepte : m√™me cardinal et chaque x correspond ~ num√©riquement
  function sameSolutions(user, sol){
    if(sol.length===0) return user.length===0;
    if(user.length!==sol.length) return false;
    for(let i=0;i<sol.length;i++){
      if(!almost(user[i], sol[i], 1e-6)) return false;
    }
    return true;
  }

  const ok1 = sameSolutions(ans1, sol1);
  const ok2 = sameSolutions(ans2, sol2);

  setTick('#tick1', ok1);
  setTick('#tick2', ok2);

  return {count:2, good:(ok1?1:0)+(ok2?1:0)};
}



/* =========================================================
   Helpers repris du style "√©quations du second degr√©"
   (tu en as d√©j√† une partie ; ne duplique pas si d√©j√† d√©fini)
   ========================================================= */

// pgcd + fraction irr√©ductible
function gcdLoc(u,v){
  u=Math.trunc(u); v=Math.trunc(v);
  u=Math.abs(u); v=Math.abs(v);
  while(v){ const t=u%v; u=v; v=t; }
  return u||1;
}
function simpLoc(p,q){
  if(q<0){ p=-p; q=-q; }
  const g=gcdLoc(p,q);
  return [p/g,q/g];
}
function texFracIrred(p,q){
  const [P,Q]=simpLoc(p,q);
  if(Q===1) return `${P}`;
  return `\\dfrac{${P}}{${Q}}`;
}

function isSquareInt(n){
  if(n<0) return false;
  const r = Math.floor(Math.sqrt(n));
  return r*r===n;
}

// √©criture latex d'un polyn√¥me du 2nd degr√© A x¬≤ + B x + C
function polyQuadLatexNum(A,B,C){
  let s='';
  // terme x¬≤
  if(A===1) s='x^{2}';
  else if(A===-1) s='-x^{2}';
  else s=`${A}x^{2}`;

  // terme x
  if(B!==0){
    const seg = (Math.abs(B)===1) ? 'x' : `${Math.abs(B)}x`;
    s += (B>0? ' + ' : ' - ') + seg.replace(/^-/, '');
  }

  // constante
  if(C!==0){
    s += (C>0? ' + ' : ' - ') + String(Math.abs(C));
  }

  return s;
}

// version sans constante C
function polyQuadNoConstLatexNum(A,B){
  let s='';
  if(A===1) s='x^{2}';
  else if(A===-1) s='-x^{2}';
  else s=`${A}x^{2}`;

  if(B!==0){
    const seg = (Math.abs(B)===1) ? 'x' : `${Math.abs(B)}x`;
    s += (B>0? ' + ' : ' - ') + seg.replace(/^-/, '');
  }
  return s;
}

// factorisation x(Ax+B)
function factoredLatexNum(A,B){
  let inside = (A===1) ? 'x'
              : (A===-1) ? '-x'
              : `${A}x`;
  if(B!==0){
    inside += (B>0?' + ':' - ') + String(Math.abs(B));
  }
  return `x\\big(${inside}\\big)`;
}

// √©value g(x)=a x^3+ b x^2+ c x + d √† x = p/q, retourne fraction irr√©ductible
function evalCubicFrac(a,b,c,d,p,q){
  const num = (
    a*p*p*p +
    b*p*p*q +
    c*p*q*q +
    d*q*q*q
  );
  const den = q*q*q;
  return simpLoc(num,den); // [num,den] irr√©ductible
}

// point de contact en LaTeX : (x ; g(x))
function pointTexFrac(p,q,a,b,c,d){
  const [Yn,Yd] = evalCubicFrac(a,b,c,d,p,q);
  return `\\(\\left(${texFracIrred(p,q)}\\,;\\,${texFracIrred(Yn,Yd)}\\right)\\)`;
}

// teste si k = num/den est un carr√© rationnel parfait >=0
// renvoie {ok, roots:[[p,q],[‚àíp,q]]}
function rationalSquareRoots(num,den){
  // signe
  if(den===0) return {ok:false};
  const [P,Q] = simpLoc(num,den); // P/Q
  if(P<0) return {ok:false};      // pas r√©el
  // P et Q doivent √™tre carr√©s parfaits
  if(!isSquareInt(P) || !isSquareInt(Q)) return {ok:false};
  const rP = Math.round(Math.sqrt(P));
  const rQ = Math.round(Math.sqrt(Q));
  const [N,D] = simpLoc(rP,rQ); // racine = ¬± N/D
  return { ok:true, roots:[[ N, D],[ -N, D]] };
}

/* √©criture latex d'une droite y = m x + p */
function lineLatex(m,p){
  // pente m, ordonn√©e √† l'origine p
  // m toujours !=0 dans nos tirages
  let txt = 'y = ';
  // pente
  if(m===1) txt+='x';
  else if(m===-1) txt+='-x';
  else txt+= `${m}x`;
  // + p
  if(p!==0){
    txt += (p>0?' + ':' - ') + Math.abs(p);
  }
  return txt;
}

/* √©criture latex du cubique g(x)=... */
function cubicToLatex(a,b,c,d){
  // a x^3 + b x^2 + c x + d
  let s='';
  // x^3
  if(a===1) s='x^{3}';
  else if(a===-1) s='-x^{3}';
  else s=`${a}x^{3}`;

  // x^2
  if(b!==0){
    const seg = (Math.abs(b)===1) ? 'x^{2}' : `${Math.abs(b)}x^{2}`;
    s += (b>0?' + ':' - ') + seg.replace(/^-/, '');
  }

  // x
  if(c!==0){
    const seg = (Math.abs(c)===1) ? 'x' : `${Math.abs(c)}x`;
    s += (c>0?' + ':' - ') + seg.replace(/^-/, '');
  }

  // constant
  if(d!==0){
    s += (d>0?' + ':' - ') + String(Math.abs(d));
  }

  return s;
}

/* d√©riv√©e g'(x)=3ax^2+2bx+c en latex */
function cubicDerivLatex(a,b,c){
  const A = 3*a;
  const B = 2*b;
  const C = c;
  return polyQuadLatexNum(A,B,C);
}

// ======================================================
// R√©solution "propre lyc√©e" de A x¬≤ + B x + C = 0
// avec mise en forme EXACTEMENT style tes captures d'√©cran
// Retourne { html, rootsFrac }
// - html : bloc <div>...</div> pr√™t √† injecter dans la solution
// - rootsFrac : tableau de racines rationnelles sous forme [p,q] SI Œî>=0
//               (utile pour construire les points de tangence)
// ======================================================

// R√©solution "propre lyc√©e" de A x¬≤ + B x + C = 0
// avec l'affichage EXACT du calcul du discriminant (Œî)
function solveQuadraticPretty(A,B,C) {

  // outils fraction
  function pgcd(u,v){
    u=Math.trunc(u); v=Math.trunc(v);
    u=Math.abs(u); v=Math.abs(v);
    while(v!==0){ const t=u%v; u=v; v=t; }
    return u===0?1:u;
  }
  function simp(p,q){
    if(q<0){ p=-p; q=-q; }
    const g=pgcd(p,q);
    return [p/g,q/g];
  }
  function texFrac(p,q){
    const [P,Q]=simp(p,q);
    if(Q===1) return `${P}`;
    return `\\dfrac{${P}}{${Q}}`;
  }

  // calcul Œî
  const prod4ac = 4 * A * C;
  const b2      = B * B;

  // √©criture du terme b¬≤ avec parenth√®ses si b<0
  // ex : b=-3 -> "(-3)^{2}"
  //      b=4  -> "4^{2}"
  const bSquaredTex = (B < 0)
    ? `(${B})^{2}`
    : `${B}^{2}`;

  // 4 √ó a √ó c avec parenth√®ses autour de a ou c si n√©gatifs
  const prettyProd = `4 \\times ${A<0?`(${A})`:A} \\times ${C<0?`(${C})`:C}`;

  // milieu apr√®s distribution du signe :
  // si 4ac est n√©gatif => b¬≤ + |4ac|
  // si 4ac est positif => b¬≤ - 4ac
  const middle = prod4ac < 0
    ? `${b2} + ${Math.abs(prod4ac)}`
    : `${b2} - ${prod4ac}`;

  const Delta   = b2 - prod4ac;
  const tail    = Delta>0 ? ' > 0' : (Delta<0 ? ' < 0' : ' ');

  // ligne Œî en rouge, style demand√©
  let html = '';
  html += `<div class="line" style="color:#b00020;font-weight:500">` +
          `\\(\\Delta = b^{2} - 4ac = ${bSquaredTex} - ${prettyProd} = ${middle} = ${Delta}${tail}\\)` +
          `</div>`;


  const rootsFrac = [];

  // cas Œî < 0 : pas de solution r√©elle
  if(Delta < 0){
    html += `<div class="line">L‚Äô√©quation n‚Äôadmet pas de solution r√©elle.</div>`;
    return { html, rootsFrac: [] };
  }

  // cas Œî = 0 : une seule racine alpha = -b / (2a)
  if(Delta === 0){
    // alpha = -B / (2A)
    const [p0,q0] = simp(-B, 2*A);

    html += `<div class="line">Donc \\(\\Delta = 0\\) et l‚Äô√©quation admet une seule solution :</div>`;
    html += `<div class="line">\\(\\alpha = \\dfrac{-b}{2a} = \\dfrac{${-B}}{2\\times ${A}} = ${texFrac(p0,q0)}\\)</div>`;

    rootsFrac.push([p0,q0]);
    return { html, rootsFrac };
  }

  // ici Œî > 0
  const sqrtD  = Math.round(Math.sqrt(Math.abs(Delta)));
  const perfect = (sqrtD*sqrtD === Delta);

  // petite phrase d‚Äôencha√Ænement
  // (tu ne veux pas "Et ‚àöŒî = ...", tu veux juste encha√Æner proprement)
  html += `<div class="line">Comme \\( \\)\\(\\Delta > 0\\), l‚Äô√©quation admet deux solutions r√©elles :</div>`;

  // fabrique la colonne de calcul pour x1 / x2
  function buildCol(sign){
    // sign = -1 pour x1 ( -‚àöŒî ), +1 pour x2 ( +‚àöŒî )
    const numSymb   = `-b ${sign<0?'-':'+'} \\sqrt{\\Delta}`;
    const numSubRaw = `${-B} ${sign<0?'-':'+'} ${perfect ? sqrtD : `\\sqrt{${Delta}}`}`;
    const denSymb   = `2a`;
    const denSub1   = `2 \\times ${A}`;
    const denSub2   = `${2*A}`;

    // troisi√®me ligne : on remplace ¬±‚àöŒî num√©riquement si possible
    const numAfterSqrt = perfect
      ? `${-B + sign*sqrtD}`
      : `${-B} ${sign<0?'-':'+'} \\sqrt{${Delta}}`;

    // derni√®re ligne : fraction simplifi√©e si parfaite
    let finalLine;
    if(perfect){
      const [pS,qS] = simp(-B + sign*sqrtD, 2*A);
      rootsFrac.push([pS,qS]);
      finalLine = texFrac(pS,qS);
    }else{
      // Œî pas carr√© parfait ‚áí on garde la forme fractionnelle non simplifi√©e
      finalLine = `\\dfrac{${-B + sign*sqrtD}}{${2*A}}`;
      // (si tu veux ignorer ces racines irrationnelles pour la suite tangente,
      // on ne push pas dans rootsFrac dans ce cas)
    }

    return `
      <div class="line">\\(x = \\dfrac{${numSymb}}{${denSymb}}\\)</div>
      <div class="line">\\(x = \\dfrac{${numSubRaw}}{${denSub1}}\\)</div>
      <div class="line">\\(x = \\dfrac{${numAfterSqrt}}{${denSub2}}\\)</div>
      <div class="line">\\(x = ${finalLine}\\)</div>
    `;
  }

  html += `
    <div style="display:flex;flex-wrap:wrap;gap:1rem;align-items:flex-start;margin-top:.4rem">
      <div style="min-width:240px;border:1px solid #ddd;border-radius:8px;padding:.5rem .8rem;">
        <div style="text-align:center;font-weight:600;margin-bottom:.4rem">\\(x_{1}\\)</div>
        ${buildCol(-1)}
      </div>
      <div style="min-width:240px;border:1px solid #ddd;border-radius:8px;padding:.5rem .8rem;">
        <div style="text-align:center;font-weight:600;margin-bottom:.4rem">\\(x_{2}\\)</div>
        ${buildCol(+1)}
      </div>
    </div>
  `;

  // rootsFrac ne contient que les racines rationnelles jolies (si Œî carr√©)
  const cleaned = rootsFrac.filter(r => Array.isArray(r));
  return { html, rootsFrac: cleaned };
}



/* =========================================================
   G√©n√©rateur cubique propre avec r√©daction style "Œî"
   ========================================================= */

function genExTangentesDegre3(){

  // tirage coefficients "propres"
  let a,b,c,d, prof=null;
  for(let tries=0; tries<400 && !prof; tries++){
    a = choice([-2,-1,1,2]);
    b = rnd(-3,3);
    c = choice([-4,-3,-2,-1,1,2,3,4]); // c‚â†0
    d = rnd(-5,5);

    const A = 3*a;
    const B = 2*b;
    const C = c;

    // m√™mes conditions que tu avais
    if(C===0){
      prof = {kind:"C0",A,B,C,a,b,c,d};
      break;
    }
    if(B===0){
      const num = -C;
      const den = A;
      if(num*den >= 0){
        const test = rationalSquareRoots(Math.abs(num),Math.abs(den));
        if(test.ok){
          prof = {kind:"B0",A,B,C,a,b,c,d,rootsB0:test.roots};
          break;
        }
      }
      continue;
    }

    const Delta = B*B - 4*A*C;
    if(Delta < 0){
      prof = {kind:"DISC",A,B,C,Delta,a,b,c,d};
      break;
    }else if(Delta === 0){
      prof = {kind:"DISC",A,B,C,Delta,a,b,c,d};
      break;
    }else{
      if(isSquareInt(Delta)){
        prof = {kind:"DISC",A,B,C,Delta,a,b,c,d};
        break;
      }
    }
  }

  // fallback
  if(!prof){
    a=1;b=1;c=2;d=0;
    const A=3*a,B=2*b,C=c;
    prof={kind:"DISC",A,B,C,Delta:(B*B-4*A*C),a,b,c,d};
  }

  const {A,B,C} = prof;

  const gLatex = cubicToLatex(a,b,c,d);
  const gPrime = cubicDerivLatex(a,b,c);

  // droite cible pente = c
  const m = c;
  const p0 = rnd(-6,6);
  const droiteLt = lineLatex(m,p0);

  // =========================
  // Q1 : tangente horizontale
  // pente = 0 <=> g'(x)=0 <=> A x¬≤ + B x + C = 0
  // On g√©n√®re TON pav√© Œî avec solveQuadraticPretty
  // =========================
  const pretty = solveQuadraticPretty(A,B,C); // {html, rootsFrac}

  // points pour Q1
  let ptsQ1Tex = '\\( \\) \\(\\text{aucun point r√©el.}\\)';
  if(pretty.rootsFrac.length){
    ptsQ1Tex = pretty.rootsFrac.map(([p,q])=>{
      const [Yn,Yd] = evalCubicFrac(a,b,c,d,p,q);
      return `\\(\\left(${texFracIrred(p,q)}\\,;\\,${texFracIrred(Yn,Yd)}\\right)\\)`;
    }).join(' , ');
  }

  // =========================
  // Q2 : tangente // droite y = m x + p0
  // pente m = c
  // On r√©sout g'(x)=c:
  // A x¬≤ + B x + C = c  ‚áî A x¬≤ + B x + (C-c)=0  ‚áî mais comme C=c, √ßa devient A x¬≤ + B x = 0
  // donc x(Ax+B)=0 -> x=0 ou x=-B/A
  // =========================

  const [pRoot,qRoot]=simpLoc(-B,A);
  const texX2 = texFracIrred(pRoot,qRoot);

  const solsQ2Frac = [ [0,1],[pRoot,qRoot] ];
  const ptsQ2Tex = solsQ2Frac.map(([p,q])=>{
    const [Yn,Yd] = evalCubicFrac(a,b,c,d,p,q);
    return `\\(\\left(${texFracIrred(p,q)}\\,;\\,${texFracIrred(Yn,Yd)}\\right)\\)`;
  }).join(' , ');

  const q2BlockHTML = `
    <div class="line stepTitle">2) Tangente parall√®le √† ${droiteLt}</div>
    <div class="line">Une tangente parall√®le √† \\( \\) \\(${droiteLt}\\) \\( \\) a pour pente \\( \\) \\(${m}\\).</div>
    <div class="line">On cherche les points o√π \\( \\) \\(g'(x) = ${m}\\).</div>
    <div class="line">\\(${polyQuadLatexNum(A,B,C)}=${m}\\) <br> \\(${A===1?'x^{2}':A+'x^{2}'} ${B>=0?'+':'-'} ${Math.abs(B)}x = 0\\)</div>
    <div class="line">\\(x(${A===1?'x':A+'x'} ${B>=0?'+':'-'} ${Math.abs(B)})=0\\)</div>
    <div class="line">\\(x=0\\) ou \\(x=${texX2}\\)</div>
    <div class="line">Point(s) de contact : \\( \\) ${ptsQ2Tex}.</div>
  `;

  // =========================
  // Assemblage final stepsHTML
  // =========================
  const stepsHTML = `
    <div class="steps">
      <div class="line"><strong>On a :</strong> \\(g(x)=${gLatex}\\) <br> Donc : \\( \\) \\(g'(x)=${gPrime}\\).</div>

      <div class="line stepTitle">1) Tangente parall√®le √† l‚Äôaxe des abscisses</div>
      <div class="line">Tangente parall√®le √† l‚Äôaxe des abscisses \\(\\iff\\) pente = 0 \\(\\iff g'(x)=0.\\)</div>
      <div class="line">On r√©sout \\( \\) \\(g'(x)=0\\), c‚Äôest-√†-dire : \\( \\) \\(${polyQuadLatexNum(A,B,C)} = 0\\).</div>

      ${pretty.html}

      <div class="line">Abscisse(s) obtenue(s) : \\( \\) \\(${
        pretty.rootsFrac.length
          ? pretty.rootsFrac.map(([p,q])=>texFracIrred(p,q)).join('\\text{ et }')
          : '\\text{aucune}'
      }\\).</div>
      <div class="line">Point(s) de contact :  ${ptsQ1Tex}</div>

      ${q2BlockHTML}
    </div>
  `;

  // =========================
  // Pour l‚Äôauto-check dans checkExoA :
  // -> roots0 : les abscisses o√π pente = 0
  // -> rootsM : les abscisses o√π pente = m
  // checkExoA attend des NOMBRES (pas [p,q])
  // On convertit les fractions en d√©cimaux
  // =========================
  function fracToNumber(p,q){ return p/q; }

  const roots0Nums = pretty.rootsFrac.map(([p,q])=>p/q);
  const rootsMNums = solsQ2Frac.map(([p,q])=>p/q);

  // =========================
  // Enonc√©
  // =========================
  const enonceHTML = `
    Soit \\(g\\) la fonction d√©finie sur \\(\\mathbb{R}\\) par :
    \\[ g(x)=${gLatex} \\]
    et \\(\\mathcal{C}_g\\) sa courbe repr√©sentative.
    <ol style="margin-top:.5rem">
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† l‚Äôaxe des abscisses ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† la droite d‚Äô√©quation
        \\(${droiteLt}\\) ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
    </ol>
  `;

  return {
    title : "Exercice 1 : D√©riv√©es et tangentes",
    enonce: enonceHTML,
    solHTML: stepsHTML,
    roots0: roots0Nums,
    rootsM: rootsMNums
  };
}



function genExTangentesDegre2() {
  // ======================
  // Tirage des coefficients
  // ======================
  // g(x) = a x¬≤ + b x + c avec a ‚â† 0
  function nzChoose(list){ return list.filter(x=>x!==0)[Math.floor(Math.random()*list.filter(x=>x!==0).length)]; }
  function rnd(A,B){ return Math.floor(Math.random()*(B-A+1))+A; }

  const a = nzChoose([-3,-2,-1,1,2,3]);
  const b = rnd(-5,5);
  const c = rnd(-5,5);

  // droite cible : y = m x + p, pente m ‚â† 0
  const m = nzChoose([-4,-3,-2,-1,1,2,3,4]);
  const p = rnd(-6,6);

  // ======================
  // Helpers d'affichage LaTeX
  // ======================
  function quadToLatex(a,b,c){
    // retourne "ax^{2}+bx+c" propre (pas de 1x, pas de + -)
    const parts=[];
    if(a!==0){
        const aa=Math.abs(a);
        parts.push((a<0?'- ':'+ ')+(aa===1?'x^{2}':aa+'x^{2}'));
    }
    if(b!==0){
        const bb=Math.abs(b);
        parts.push((b<0?'- ':'+ ')+(bb===1?'x':bb+'x'));
    }
    if(c!==0 || !parts.length){
        const cc=Math.abs(c);
        parts.push((c<0?'- ':'+ ')+cc);
    }
    return parts.join(' ').replace(/^\+\s*/,'').trim();
  }

  function quadDerivLatex(a,b){
    // g'(x)=2ax+b
    const A=2*a, B=b;
    const parts=[];
    if(A!==0){
      const AA=Math.abs(A);
      parts.push((A<0?'- ':'+ ')+(AA===1?'x':AA+'x'));
    }
    if(B!==0 || !parts.length){
      const BB=Math.abs(B);
      parts.push((B<0?'- ':'+ ')+BB);
    }
    return parts.join(' ').replace(/^\+\s*/,'').trim();
  }

  function lineLatex(m,p){
    // y = m x + p (sans 1x, sans +0)
    const terms=[];
    if(m!==0){
      const mm=Math.abs(m);
      const mono=(mm===1?'x':mm+'x');
      terms.push( (m<0?'- ':'')+mono );
    }
    if(p!==0 || !terms.length){
      const pp=Math.abs(p);
      terms.push( (p<0?'- ':'+ ')+pp );
    }
    let rhs=terms.join(' ').replace(/^\+\s*/,'').trim();
    return 'y = '+rhs;
  }

  // fractions irr√©ductibles pour les abscisses
  function pgcd(u,v){
    u=Math.trunc(u); v=Math.trunc(v);
    u=Math.abs(u); v=Math.abs(v);
    while(v!==0){ const t=u%v; u=v; v=t; }
    return u===0?1:u;
  }
  function frac(num,den){
    if(den<0){ num=-num; den=-den; }
    const g=pgcd(num,den);
    return {num:num/g, den:den/g};
  }
  function fracToLatex(F){
    if(F.den===1) return ''+F.num;
    return `\\dfrac{${F.num}}{${F.den}}`;
  }

  // √©valuer g(x) = a x¬≤ + b x + c sur une fraction num/den
  function evalPoly2(a,b,c,F){
    const p=F.num, q=F.den;
    // num = a p¬≤ + b p q + c q¬≤
    // den = q¬≤
    const num = a*p*p + b*p*q + c*q*q;
    const den = q*q;
    const g=pgcd(num,den);
    const N=num/g, D=den/g;
    return {num:N, den:D};
  }
  function pointTexFrac(F){
    const Y = evalPoly2(a,b,c,F);
    return `\\(\\left(${fracToLatex(F)}\\,;\\,${fracToLatex(Y)}\\right)\\)`;
  }

  const gLatex   = quadToLatex(a,b,c);
  const gPrime   = quadDerivLatex(a,b);
  const droiteLt = lineLatex(m,p);

  // ======================
  // Q1 : tangente // axe des abscisses
  // pente = 0  <=>  g'(x)=0  <=> 2ax + b = 0
  // => x = -b/(2a)
  // ======================
  const sol0 = frac(-b, 2*a); // abscisse o√π pente=0
  const s0_line1 = `${(2*a===1?'':2*a+'') }x ${b>=0?'+ '+b:'- '+Math.abs(b)} = 0`;
  const s0_line2 = `${(2*a===1?'':2*a+'') }x = ${-b}`;
  const s0_line3 = `x = ${fracToLatex(sol0)}`;

  // point(s) de contact pour Q1
  const pts0TexList = [ pointTexFrac(sol0) ];

  // ======================
  // Q2 : tangente // droite y = m x + p
  // pente = m  <=>  g'(x)=m  <=> 2ax+b = m
  // => x = (m - b)/(2a)
  // ======================
  const solM = frac(m - b, 2*a);
  const sM_line1 = `${(2*a===1?'':2*a+'') }x ${b>=0?'+ '+b:'- '+Math.abs(b)} = ${m}`;
  const sM_line2 = `${(2*a===1?'':2*a+'') }x = ${m-b}`;
  const sM_line3 = `x = ${fracToLatex(solM)}`;

  const ptsMTexList = [ pointTexFrac(solM) ];

  // ======================
  // blocs de solution r√©dig√©e (comme dans ta fiche)
  // ======================

  const stepsQ1_block = `
    <div class="line stepTitle">1) Tangente parall√®le √† l‚Äôaxe des abscisses</div>
    <div class="line">Tangente parall√®le √† l‚Äôaxe des abscisses \\(\\iff\\) pente = 0 \\(\\iff\\ g'(x)=0.\\)</div>
    <div class="line">On r√©sout \\(g'(x)=0\\), soit :</div>
    <div class="line">\\(${s0_line1}\\)</div>
    <div class="line">\\(\\Rightarrow ${s0_line2}\\)</div>
    <div class="line">\\(\\Rightarrow ${s0_line3}\\)</div>
    <div class="line">Donc \\(\\mathcal{C}_g\\) admet une tangente horizontale pour \\(x=${fracToLatex(sol0)}\\).</div>
    <div class="line">Point(s) de contact : ${pts0TexList.join(', ')}.</div>
  `;

  const stepsQ2_block = `
    <div class="line stepTitle">2) Tangente parall√®le √† \\(${droiteLt}\\)</div>
    <div class="line">Une tangente parall√®le √† \\(${droiteLt}\\) a pour pente \\(${m}\\).</div>
    <div class="line">On cherche les points o√π \\(g'(x)=${m}\\).</div>
    <div class="line">On r√©sout \\(g'(x)=${m}\\), soit :</div>
    <div class="line">\\(${sM_line1}\\)</div>
    <div class="line">\\(\\Rightarrow ${sM_line2}\\)</div>
    <div class="line">\\(\\Rightarrow ${sM_line3}\\)</div>
    <div class="line">Donc \\(\\mathcal{C}_g\\) admet une tangente parall√®le √† \\(${droiteLt}\\) pour \\(x=${fracToLatex(solM)}\\).</div>
    <div class="line">Point(s) de contact : ${ptsMTexList.join(', ')}.</div>
  `;

  const solHTML = `
    <div class="steps">
      <div class="line"><strong>On a :</strong> \\(g(x)=${gLatex}\\) donc \\(g'(x)=${gPrime}\\).</div>
      ${stepsQ1_block}
      ${stepsQ2_block}
    </div>
  `;

  // ======================
  // Enonc√© affich√© √† l'√©l√®ve
  // ======================
  const enonceHTML = `
    Soit \\(g\\) la fonction d√©finie sur \\(\\mathbb{R}\\) par :
    \\[ g(x)=${gLatex} \\]
    et \\(\\mathcal{C}_g\\) sa courbe repr√©sentative.
    <ol style="margin-top:.5rem">
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† l‚Äôaxe des abscisses ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
      <li>
        La courbe \\(\\mathcal{C}_g\\) admet-elle des tangentes parall√®les √† la droite d‚Äô√©quation
        \\(${droiteLt}\\) ?<br/>
        Si oui, donner l‚Äôabscisse du ou des point(s) de tangence.
      </li>
    </ol>
  `;

  // ======================
  // Pour la v√©rification auto :
  // roots0 = abscisses o√π pente = 0
  // rootsM = abscisses o√π pente = m
  // Chaque racine est une fraction {num,den}
  // ======================

  const roots0 = [ sol0 ];
  const rootsM = [ solM ];

  return {
    title : "Exercice 1 : D√©riv√©es et tangentes",
    enonce: enonceHTML,
    solHTML,
    roots0,
    rootsM
  };
}





/* =========================================================
   Exercice A : Tangentes parall√®les
   On prend g(x)=ax^2+bx+c avec a!=0
   Q1 : parall√®les √† l'axe des abscisses ?  <=> pente 0 <=> g'(x)=0
   Q2 : parall√®les √† y = m x + p ?        <=> pente m <=> g'(x)=m
   ========================================================= */
function genExTangentes(){
  if (modeTangentes === 'deg2'){
    return genExTangentesDegre2();
  }
  if (modeTangentes === 'deg3'){
    return genExTangentesDegre3();
  }
  // mode "mix" = comportement ancien : 50/50
  if (Math.random() < 0.5){
    return genExTangentesDegre2();
  } else {
    return genExTangentesDegre3();
  }
}




/* =========================================================
   Exercice B : Retrouver la fonction √† partir des conditions,
   puis donner f'(x).
   Deux sous-types :
   - P2 : f(x)=ax^2+bx+c
     Conditions :
       * f(0)=0
       * f'(0)=m0
       * f(x1)=y1
   - QUOT : f(x)=(a x^2 + b)/(3x-2)
     Conditions :
       * C_f coupe l'axe des ordonn√©es en A(0;y0)
       * Tangente horizontale en x=1
   ========================================================= */

function genExCoeffs(){
  if(Math.random()<0.5){
    return genP2();
  }else{
    return genQuot();
  }
}

/* ----- Sous-type P2 ----- */
function genP2(){
  // param√®tres al√©atoires simples
  const m0 = nzChoose([-4,-3,-2,-1,1,2,3,4]); // pente de la tangente en 0
  const x1 = nzChoose([-3,-2,-1,1,2,3]);      // un point donn√©
  const a  = nzChoose([-3,-2,-1,1,2,3]);      // on choisit a,
  // on imposera f(0)=0  => c=0
  // f'(x)=2ax+b, donc f'(0)=b = m0
  const b  = m0;
  // f(x)=ax^2+bx+c, et c=0
  // On choisit y1 coh√©rent : y1 = a x1^2 + b x1
  const y1 = a*x1*x1 + b*x1;
  const c  = 0;

  const fLatex    = quadToLatex(a,b,c);
  const fpLatex   = quadDerivLatex(a,b);

  const enonceHTML = `
  On consid√®re la fonction \\(f\\) d√©finie sur \\(\\mathbb{R}\\) par
  \\(f(x)=ax^{2}+bx+c\\), et l‚Äôon note \\(\\mathcal{C}_f\\) sa courbe repr√©sentative dans un rep√®re \\((O;\\vec{i},\\vec{j})\\).
  <ol style="margin-top:.5rem">
    <li>Calculer \\(f'(x)\\).</li>
    <li>D√©terminer \\(a,b,c\\) sachant que \\(\\mathcal{C}_f\\) v√©rifie les hypoth√®ses suivantes :
      <ul>
        <li>\\(\\mathcal{C}_f\\) passe par l‚Äôorigine du rep√®re \\(O(0;0)\\).</li>
        <li>La tangente √† \\(\\mathcal{C}_f\\) en \\(O\\) a pour coefficient directeur \\(${m0}\\).</li>
        <li>\\(\\mathcal{C}_f\\) passe par le point \\(A(${x1}\\,;\\,${y1})\\).</li>
      </ul>
      Donner l‚Äôexpression finale de \\(f(x)\\).
    </li>
  </ol>
  `;

  const solHTML = `
  <div class="steps">
    <div class="line stepTitle">1) D√©riv√©e g√©n√©rale</div>
    <div class="line">Si \\(f(x)=ax^{2}+bx+c\\) alors \\(f'(x)=2ax+b\\).</div>
    <div class="line">Donc \\(f'(x)=${fpLatex}\\).</div>

    <div class="line stepTitle">2) Utilisation des hypoth√®ses</div>
    <table class="sysTab">
      <tr>
        <td class="eq">\\(\\mathcal{C}_f\\) passe par \\(O(0;0)\\)</td>
        <td class="eq">\\(\\Rightarrow f(0)=0 \\Rightarrow c=0.\\)</td>
      </tr>
      <tr>
        <td class="eq">Tangente en \\(O\\) de pente \\(${m0}\\)</td>
        <td class="eq">\\(\\Rightarrow f'(0)=${m0}\\Rightarrow b=${m0}.\\)</td>
      </tr>
      <tr>
        <td class="eq">Point \\(A(${x1};${y1})\\) sur \\(\\mathcal{C}_f\\)</td>
        <td class="eq">\\(\\Rightarrow f(${x1})=${y1}\\Rightarrow a\\cdot ${x1}^{2}+b\\cdot ${x1}+c=${y1}.\\)</td>
      </tr>
    </table>

    <div class="line">Comme \\( \\) \\(c=0\\) \\( \\)et\\( \\) \\(b=${b}\\), on obtient \\( \\) \\(a=${a}\\).</div>

    <div class="line stepTitle">Conclusion</div>
    <div class="line">On a \\(a=${a},\\;b=${b},\\;c=${c}.\\)</div>
    <div class="line">Donc \\(f(x)=${fLatex}\\).</div>
    <div class="line">Et \\(f'(x)=${fpLatex}\\).</div>
  </div>
  `;

  // auto-check :
  // √©l√®ve doit donner f'(x) dans ansMain
  // puis "a=..., b=..., c=..." dans ansCoeff (on va tol√©rer juste "a=2,b=3,c=0" ou "2;3;0")
  function refFp(x){ return 2*a*x + b; }
  const coeffsRef = {a,b,c};

  return {
    title:"Exercice 2 : Retrouver la fonction",
    enonce:enonceHTML,
    solHTML,
    fpEval:refFp,
    fpLatex,
    coeffsRef
  };
}

/* ----- Sous-type QUOT ----- */
function genQuot(){
  // f(x) = (a x^2 + b)/(3x-2)
  // Conditions :
  //  - Cf coupe l'axe des ordonn√©es en A(0;y0)  => f(0)=y0
  //  - Cf admet une tangente horizontale au point d'abscisse 1 => f'(1)=0

  const a = nzChoose([-3,-2,-1,1,2,3]);
  // f(0)= b/(-2) = y0 => b = -2*y0
  const y0 = rnd(-4,4);
  const b  = -2*y0;

  // On va calculer f'(x) pour ce quotient :
  // u(x)=a x^2 + b ; u'(x)=2 a x
  // v(x)=3x-2       ; v'(x)=3
  // f'(x)= (u'v - v'u)/(v^2)
  // f'(x)= (2ax(3x-2) - 3(a x^2 + b))/(3x-2)^2
  //      = (6ax^2 -4ax -3ax^2 -3b)/(3x-2)^2
  //      = ((3a)x^2 -4ax -3b)/(3x-2)^2

  function fprimeNum(x){
    return ((3*a)*x*x -4*a*x -3*b)/((3*x-2)*(3*x-2));
  }

  // tangente horizontale en x=1 => f'(1)=0
  // Num√©rateur doit √™tre 0 √† x=1 :
  // (3a)*1 -4a*1 -3b = 0
  // 3a -4a -3b = 0 => (-a -3b)=0 => a = -3b
  // Mais √ßa impose relation entre a et b. On a d√©j√† impos√© a plus haut.
  // Pour garantir coh√©rence, je vais en fait construire (a,b) *apr√®s* :
  // Re-faisons proprement :

  // On veut :
  //   1) f(0)=y0 -> b = -2*y0
  //   2) f'(1)=0 -> 3a -4a -3b = 0 -> -a -3b = 0 -> a = -3b
  //
  // Donc : a = -3b = -3(-2*y0) = 6*y0
  const Y0 = rnd(-2,2); // plus petit pr pas exploser
  const BB = -2*Y0;
  const AA = 6*Y0;

  // Remplace avec coh√©rents :
  const a2 = AA;
  const b2 = BB;

  // f'(x) latex :
  // num(x)= (3a2)x^2 - 4a2 x -3b2
  const A3 = 3*a2;
  const B4 = -4*a2;
  const Cc = -3*b2;

  function polyNumLatex(Acoef,Bcoef,Ccoef){
    const arr=[];
    if(Acoef!==0){
      const AA=Math.abs(Acoef);
      arr.push((Acoef<0?'- ':'+ ')+ (AA===1?'x^{2}':AA+'x^{2}'));
    }
    if(Bcoef!==0){
      const BB=Math.abs(Bcoef);
      arr.push((Bcoef<0?'- ':'+ ') + (BB===1?'x':BB+'x'));
    }
    if(Ccoef!==0 || !arr.length){
      const CC=Math.abs(Ccoef);
      arr.push((Ccoef<0?'- ':'+ ') + CC);
    }
    return arr.join(' ').replace(/^\+\s*/,'').trim();
  }

  const numLatex = polyNumLatex(A3,B4,Cc);
  const denomLatex = '\\left(3x-2\\right)^{2}';
  const fpLatex = `\\dfrac{${numLatex}}{${denomLatex}}`;

  // f(x) latex :
  function quotLatex(a,b){
    // (a x^2 + b)/(3x-2)
    const numParts=[];
    if(a!==0){
      const aa=Math.abs(a);
      numParts.push((a<0?'- ':'+ ')+(aa===1?'x^{2}':aa+'x^{2}'));
    }
    if(b!==0 || !numParts.length){
      const bb=Math.abs(b);
      numParts.push((b<0?'- ':'+ ')+bb);
    }
    const numL = numParts.join(' ').replace(/^\+\s*/,'').trim();
    return `\\dfrac{${numL}}{3x-2}`;
  }

  const fLatex = quotLatex(a2,b2);

  const enonceHTML = `
  On consid√®re la fonction \\(f\\) d√©finie par
  \\[ f(x)=${fLatex} \\]
  et l‚Äôon note \\(\\mathcal{C}_f\\) sa courbe repr√©sentative dans le plan muni d‚Äôun rep√®re \\((O;\\vec{i},\\vec{j})\\).
  <ol style="margin-top:.5rem">
    <li>Calculer \\(f'(x)\\).</li>
    <li>D√©terminer \\(a\\) et \\(b\\) sachant que \\(\\mathcal{C}_f\\) v√©rifie les hypoth√®ses suivantes :
      <ul>
        <li>\\(\\mathcal{C}_f\\) coupe l‚Äôaxe des ordonn√©es au point d‚Äôordonn√©e \\(${Y0}\\).</li>
        <li>\\(\\mathcal{C}_f\\) admet une tangente horizontale au point d‚Äôabscisse \\(1\\).</li>
      </ul>
      Donner l‚Äôexpression finale de \\(f(x)\\).
    </li>
  </ol>
  `;

  const solHTML = `
  <div class="steps">
    <div class="line stepTitle">1) D√©riv√©e g√©n√©rale du quotient</div>
    <div class="line">On pose \\(u(x)=ax^{2}+b\\) et \\(v(x)=3x-2\\).</div>
    <div class="line">Alors \\(u'(x)=2ax\\) et \\(v'(x)=3\\).</div>
    <div class="line">R√®gle du quotient : \\(f'(x)=\\dfrac{u'(x)v(x)-v'(x)u(x)}{(v(x))^{2}}\\).</div>
    <div class="line">Ici : \\(f'(x)=\\dfrac{2ax(3x-2)-3(ax^{2}+b)}{(3x-2)^{2}}\\).</div>
    <div class="line">On d√©veloppe le num√©rateur :
      \\(2ax(3x-2)=6ax^{2}-4ax\\) et \\(-3(ax^{2}+b)=-3ax^{2}-3b\\).</div>
    <div class="line">Donc \\(f'(x)=\\dfrac{(3a)x^{2}-4ax-3b}{(3x-2)^{2}}\\).</div>

    <div class="line stepTitle">2) Utilisation des hypoth√®ses</div>
    <table class="sysTab">
      <tr>
        <td class="eq">\\(\\mathcal{C}_f\\) coupe l‚Äôaxe des ordonn√©es en \\((0;${Y0})\\)</td>
        <td class="eq">\\(\\Rightarrow f(0)=${Y0}\\Rightarrow \\dfrac{b}{-2}=${Y0}\\Rightarrow b=-2\\times ${Y0}=${b2}.\\)</td>
      </tr>
      <tr>
        <td class="eq">Tangente horizontale en \\(x=1\\)</td>
        <td class="eq">\\(\\Rightarrow f'(1)=0\\Rightarrow (3a)(1)^{2}-4a(1)-3b=0\\Rightarrow -a-3b=0\\Rightarrow a=-3b.\\)</td>
      </tr>
    </table>

    <div class="line">On sait \\(b=${b2}\\). Donc \\(a=-3\\times (${b2})=${a2}.\\)</div>

    <div class="line stepTitle">Conclusion</div>
    <div class="line">\\(a=${a2},\\;b=${b2}.\\)</div>
    <div class="line">Donc \\(f(x)=${fLatex}\\).</div>
    <div class="line">Et \\(f'(x)=${fpLatex}\\).</div>
  </div>
  `;

  // auto-check :
  // ansMain => f'(x)   ; ansCoeff => "a=..., b=..."
  function fpEval(x){
    return ((3*a2)*x*x -4*a2*x -3*b2)/((3*x-2)*(3*x-2));
  }
  const coeffsRef={a:a2,b:b2};

  return {
    title:"Exercice 2 : Retrouver la fonction (quotient)",
    enonce:enonceHTML,
    solHTML,
    fpEval,
    fpLatex,
    coeffsRef
  };
}

/* v√©rif ExoB :
   ansMain doit √™tre √©quivalent √† f'(x)
   ansCoeff doit contenir les bons coeffs
*/
function numEvalExpr(expr, x){
  // version light : ^ en ** ; x¬≤ etc.
  if(!expr) return NaN;
  let s = String(expr);

  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      );

  s = s.replace(/\^/g,'**');
  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');

  // sqrt
  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'Math.sqrt($1)')
       .replace(/sqrt\s*\(/g,'Math.sqrt(');

  // implicite : nombre( ou x( -> *(
  s = s.replace(/(\d)\s*\(/g,'$1*(')
       .replace(/x\s*\(/g,'x*(')
       .replace(/\)\s*\(/g,')*(');

  // fractions a/b -> (a)/(b)
  s = s.replace(/([0-9A-Za-z_\)\]])\s*\/\s*([0-9A-Za-z_\(])/g,'($1)/($2)');

  s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g,'(XVAL)');

  try{
    return Number(Function("XVAL","return ("+s+");")(x));
  }catch(e){
    return NaN;
  }
}

function checkExoB(st){
  const ansMain  = $('#ansMain')?.value || '';
  const ansCoeff = $('#ansCoeff')?.value || '';

  // check d√©riv√©e
  const xs=[-2,-1,0,1,2,3];
  let okD=true;
  for(const x of xs){
    const vUser=numEvalExpr(ansMain,x);
    const vRef = st.fpEval(x);
    if(!Number.isFinite(vUser)||!Number.isFinite(vRef)||!almost(vUser,vRef,1e-6)){
      okD=false;break;
    }
  }

  // check coeffs
  // On tol√®re soit "a=2,b=5,c=0" soit "2;5;0" etc.
  function parseCoeff(str){
    const obj={};
    const parts=str.split(/[,;]+/).map(s=>s.trim()).filter(Boolean);
    parts.forEach(p=>{
      const m = p.match(/^([abc])\s*=\s*(-?\d+)$/i);
      if(m){
        obj[m[1].toLowerCase()]=Number(m[2]);
      }else{
        // juste nombre nu -> on push dans un tableau
        if(!obj._arr) obj._arr=[];
        const n = Number(p.replace(',','.'));
        if(!Number.isNaN(n)) obj._arr.push(n);
      }
    });
    return obj;
  }
  const got = parseCoeff(ansCoeff);
  let okC=true;
  const ref=st.coeffsRef;
  if(ref.c!==undefined){
    // cas P2 : a,b,c
    if( got.a!==ref.a || got.b!==ref.b || got.c!==ref.c ){
      // fallback tableau [_arr] en ordre a,b,c
      if(!(got._arr && got._arr.length===3 &&
           got._arr[0]===ref.a && got._arr[1]===ref.b && got._arr[2]===ref.c)){
        okC=false;
      }
    }
  }else{
    // cas QUOT : a,b
    if( got.a!==ref.a || got.b!==ref.b ){
      if(!(got._arr && got._arr.length===2 &&
           got._arr[0]===ref.a && got._arr[1]===ref.b)){
        okC=false;
      }
    }
  }

  setTick('#tickMain', okD);
  setTick('#tickCoeff', okC);

  return {count:2, good:(okD?1:0)+(okC?1:0)};
}

/* =========================================================
   RENDU / UI
   ========================================================= */

function buildHostHTML_A(st){
  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>

      <div style="margin-bottom:.6rem; display:flex; flex-wrap:wrap; align-items:center; gap:.5rem;">
        <label for="mode-tangentes" style="font-weight:600; white-space:nowrap;">
          Type de fonction tir√©e :
        </label>
        <select id="mode-tangentes" style="padding:4px 8px; border:1px solid #ccc; border-radius:6px; font-size:.9rem; line-height:1.3;">
          <option value="mix"${modeTangentes==='mix'?' selected':''}>M√©lange</option>
          <option value="deg2"${modeTangentes==='deg2'?' selected':''}>2nd degr√©</option>
          <option value="deg3"${modeTangentes==='deg3'?' selected':''}>3√®me degr√©</option>
        </select>
        <button type="button" id="regen-tangentes" class="btn" style="font-size:.8rem;padding:6px 10px;">
          üîÑ Re-tirer
        </button>
      </div>

      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ans1"><strong>1) abscisse(s) tangente horizontale :</strong></label>
          <input id="ans1" class="inp" style="min-width:260px">
          <span id="tick1" class="tick" style="margin-left:6px"></span>
        </div>
        <div class="qa-row">
          <label for="ans2"><strong>2) abscisse(s) tangente // droite :</strong></label>
          <input id="ans2" class="inp" style="min-width:260px">
          <span id="tick2" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}


function buildHostHTML_B(st){
  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>
      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ansMain"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansMain" class="inp" style="min-width:360px">
          <span id="tickMain" class="tick" style="margin-left:6px"></span>
        </div>

        <div class="qa-row">
          <label for="ansCoeff"><strong>Coefficients :</strong></label>
          <input id="ansCoeff" class="inp" style="min-width:260px"
            placeholder="ex : a=2,b=5,c=0 ou 2;5;0">
          <span id="tickCoeff" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}

function setTick(sel, ok){
  const el = (typeof sel==="string"? $(sel): sel);
  if(!el) return;
  el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
  el.textContent = ok===true?'‚úì': ok===false?'‚úó':'‚Äî';
}

/* =========================================================
   REGISTRY des exos
   ========================================================= */

const EXO_A = {
  id:'exoA',
  title:'Exercice 1 ‚Äî Tangentes parall√®les',
gen(host){
  const st = genExTangentes();
  if(host){
    host.innerHTML = buildHostHTML_A(st);
    host.__state = st;
    host.dataset.state = JSON.stringify({
      title   : st.title,
      enonce  : st.enonce,
      solHTML : st.solHTML
    });

    // brancher le s√©lecteur interne "mode-tangentes"
    const modeSel = $('#mode-tangentes', host);
    if(modeSel){
      modeSel.addEventListener('change', e=>{
        modeTangentes = e.target.value; // maj globale
      });
    }

    // bouton "Re-tirer" pour r√©g√©n√©rer cet exo 1 avec le mode courant
    const regenBtn = $('#regen-tangentes', host);
    if(regenBtn){
      regenBtn.addEventListener('click', ()=>{
        const fresh = genExTangentes(); // r√©g√©n√®re selon modeTangentes
        host.innerHTML = buildHostHTML_A(fresh);
        host.__state = fresh;
        host.dataset.state = JSON.stringify({
          title   : fresh.title,
          enonce  : fresh.enonce,
          solHTML : fresh.solHTML
        });

        // rebrancher les listeners sur la nouvelle version recr√©√©e :
        const newSel = $('#mode-tangentes', host);
        if(newSel){
          newSel.value = modeTangentes;
          newSel.addEventListener('change', e=>{
            modeTangentes = e.target.value;
          });
        }
        const newBtn = $('#regen-tangentes', host);
        if(newBtn){
          newBtn.addEventListener('click', ()=>{ regenBtn.click(); });
          // astuce simple : reboucle sur lui-m√™me
        }

        if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
        else if(window.MathJax?.typeset)   MathJax.typeset([host]);
        scanFractions(host);
      });
    }

    // affichage MathJax pour la premi√®re g√©n√©ration
    if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
    else if(window.MathJax?.typeset)   MathJax.typeset([host]);
    scanFractions(host);
  }
  return st;
},

  correct(host, st){
    const r = checkExoA(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typesetPromise) MathJax.typesetPromise([$('#res',host)]);
    else if(window.MathJax?.typeset)   MathJax.typeset([$('#res',host)]);
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick('#tick1', null);
    setTick('#tick2', null);
    const i1 = $('#ans1',host); if(i1) i1.value='';
    const i2 = $('#ans2',host); if(i2) i2.value='';
  }
};

const EXO_B = {
  id:'exoB',
  title:'Exercice 2 ‚Äî Retrouver la fonction',
  gen(host){
    const st = genExCoeffs();
    if(host){
      host.innerHTML = buildHostHTML_B(st);
      host.__state = st;
      host.dataset.state = JSON.stringify({
        title   : st.title,
        enonce  : st.enonce,
        solHTML : st.solHTML
      });
      if(window.MathJax?.typesetPromise) MathJax.typesetPromise([host]);
      else if(window.MathJax?.typeset)   MathJax.typeset([host]);
      scanFractions(host);
    }
    return st;
  },
  correct(host, st){
    const r = checkExoB(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    $('#res',host).innerHTML = st.solHTML;
    if(window.MathJax?.typesetPromise) MathJax.typesetPromise([$('#res',host)]);
    else if(window.MathJax?.typeset)   MathJax.typeset([$('#res',host)]);
  },
  reset(host){
    $('#res',host).textContent = '';
    setTick('#tickMain', null);
    setTick('#tickCoeff', null);
    const i1 = $('#ansMain',host); if(i1) i1.value='';
    const i2 = $('#ansCoeff',host); if(i2) i2.value='';
  }
};





const REG = [EXO_A,EXO_B];
window.REG = REG;
window.REGISTRY = REG;

/* =========================================================
   Montage UI / Score / Raccourcis
   ========================================================= */

function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);


/* =========================================================
   Adaptateur PDF (reprend ta logique SVG)
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try { st = JSON.parse(hostTmp.dataset.state || '{}'); } catch(_){}
        return st;
      },

      beforeRender(def, st, withSolutions){
        return (async () => {
          let host = null;
          try {
            host = document.createElement('div');
            host.id = 'pdf-host';
            host.style.position='fixed';
            host.style.left='-10000px';
            host.style.top='-10000px';
            document.body.appendChild(host);

            // reconstruit bloc exo basique
            host.innerHTML = `
              <div class="exo-block">
                <span class="exo-title">${st.title||''}</span>
                <div class="enonce">${st.enonce||''}</div>
                ${withSolutions?('<div style="margin-top:1rem;font-weight:600">Corrig√© :</div>'+(st.solHTML||'')):""}
              </div>
            `;
            host.dataset.state = JSON.stringify(st);

            // IFRAME sandbox pour MathJax SVG
            const iframe = document.createElement('iframe');
            iframe.style.position   = 'fixed';
            iframe.style.left       = '-10000px';
            iframe.style.top        = '-10000px';
            iframe.style.width      = '0';
            iframe.style.height     = '0';
            iframe.style.visibility = 'hidden';
            document.body.appendChild(iframe);

            const iwin = iframe.contentWindow;
            const idoc = iframe.contentDocument;

            idoc.open();
            idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
            idoc.close();

            const contentDiv = idoc.getElementById('content');
            contentDiv.innerHTML = host.innerHTML;

            contentDiv.querySelectorAll('mjx-container').forEach(mjx => {
              mjx.replaceWith(mjx.textContent || '');
            });
            contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml')
              .forEach(n => n.remove());

            // config MathJax SVG dans l'iframe
            const cfg = idoc.createElement('script');
            cfg.type = 'text/javascript';
            cfg.text = `
              window.MathJax = {
                tex: {
                  inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
                  displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
                  processEscapes: true,
                  packages: { '[+]': ['bbox','ams'] }
                },
                svg: { fontCache:'none' },
                options: { skipHtmlTags:['script','noscript','style','textarea'] },
                startup: { typeset:false }
              };
            `;
            idoc.head.appendChild(cfg);

            const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
            const mj = idoc.createElement('script');
            mj.type = 'text/javascript';
            mj.src  = svgScriptURL;
            idoc.head.appendChild(mj);

            // attendre le chargement + pr√™t
            await new Promise(resolve=>{ mj.onload=resolve; mj.onerror=resolve; });
            async function waitMathJaxReady(win){
              const limit = 200;
              let n = 0;
              while ((!win.MathJax) || (!win.MathJax.typesetPromise && !win.MathJax.typeset)){
                await new Promise(res=>setTimeout(res,5));
                n++; if(n>limit) break;
              }
            }
            await waitMathJaxReady(iwin);

            if (iwin.MathJax && iwin.MathJax.typesetPromise){
              await iwin.MathJax.typesetPromise([ contentDiv ]);
            } else if (iwin.MathJax && iwin.MathJax.typeset){
              iwin.MathJax.typeset([ contentDiv ]);
            }

            // Purge CHTML (on ne garde que SVG)
            (function purgeCHTML(){
              contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n => n.remove());
              contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n => n.remove());
              contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n => n.remove());
            })();

            const finalHTML = contentDiv.innerHTML;

            iframe.remove();
            host.remove();

            return finalHTML;
          } catch(e){
            console.error('beforeRender SVG error:', e);
            let fallbackHTML = '';
            if (host) {
              fallbackHTML = host.innerHTML;
              host.remove();
              host = null;
            }
            return fallbackHTML;
          }
        })();
      }

    });
  });
})();

/* =========================================================
   mobile tweaks (inchang√©)
   ========================================================= */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type='button';
          clone.removeAttribute('id');
          clone.addEventListener('click',(e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className='btn';
          fallback.type='button';
          fallback.textContent=label;
          fallback.addEventListener('click',(e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r<10) c.setAttribute('r','12');
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
