<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1ère — Fonctions dérivées de référence</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.code{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
/* Ticks de validation */
.tick{margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}
/* Ticks de validation */
.tick{
  display:none;           /* ← caché au départ */
  margin-left:.35rem;
  font-weight:700;
}
.tick.ok{ color:#11823b }
.tick.ko{ color:#b00020 }
/* Cache les ticks tant qu'ils ne sont ni ok ni ko */
.tick:not(.ok):not(.ko){ display:none !important; }

.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.frac{display:inline-flex;flex-direction:column;vertical-align:middle;line-height:1}
.frac>.num{border-bottom:1px solid #000;padding:0 .15em;text-align:center}
.frac>.den{padding:0 .15em;text-align:center}
/* PDF/print : éviter la disparition des barres de fraction */
@media print {
  .frac>.num{ border-bottom-width: 2px !important; }
}

/* Bonus : un peu plus visible aussi à l'écran sans être agressif */
.frac>.num{ border-bottom-width: 1.5px; }
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
/* Fraction plus robuste (ligne sous le numérateur) */
.frac{ display:inline-flex; flex-direction:column; align-items:stretch; line-height:1; }
.frac>.num,
.frac>.den{ display:block; text-align:center; padding:0 .2em; position:relative; }
.frac>.num{ border-bottom:1.5px solid currentColor; } /* écran : plus lisible */

/* Impression/PDF : certaines pipelines "mangent" les hairlines -> pseudo-ligne solide */
@media print{
  .frac>.num{ border-bottom:0 !important; }
  .frac>.num::after{
    content:"";
    position:absolute;
    left:0; right:0; bottom:-1px;
    height:2px;                    /* trait épais et visible */
    background:currentColor;
  }
}
@media print{
  /* transforme les champs en grands traits (si jamais ExoPDF n'est pas utilisé) */
  input, textarea, select{
    background: transparent !important;
    border: none !important;
    border-bottom: 2px solid #000 !important;  /* ← grand trait */
    color: transparent !important;             /* cache le texte/placeholder */
    caret-color: transparent !important;
    outline: none !important;
    height: 1.4em !important;
  }
  input::placeholder, textarea::placeholder{ color: transparent !important; }

  /* nettoie l'UI */
  .tick, .optionline, button, select, .kbd-host, .header, .controls{ 
    display: none !important; 
  }
}
/* Fallback universel : si l'input existe encore au moment du rendu PDF,
   on le masque et on montre un "grand trait" de même largeur. */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{
  display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline;
}

/* Impression / PDF (html2canvas, etc.) */
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
@media print{ .controls{display:none !important;} }

.svgbox{
  touch-action: manipulation;
  user-select: none;
}

</style>

<!-- Librairies communes MatHeron -->
<script src='../../../../js/math-kbd.js' defer></script>
<script>
/* ====== HERMITE5 – Générateur quintique Hermite sur repère interne [-6,6] ====== */
(function(global){
  "use strict";
  const UMINUS = '−';
  const RDEF = {xmin:-6,xmax:6,ymin:-6,ymax:6};
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rchoice(a){ return a[Math.floor(Math.random()*a.length)] }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
  function pickDistinctInt(a,b, forbid=new Set()){
    const pool=[]; for(let x=a;x<=b;x++) if(!forbid.has(x)) pool.push(x);
    return pool.length? rchoice(pool) : a;
  }
  const ZERO = {n:0n, d:1n}; const ONE  = {n:1n, d:1n};
  function rat(n, d=1n){ n=BigInt(n); d=BigInt(d); if(d===0n) throw Error('den=0'); if(d<0n){n=-n; d=-d;}
    const g=(a,b)=>{ a=a<0n?-a:a; b=b<0n?-b:b; while(b){ const t=a%b; a=b; b=t; } return a; };
    const gg=g(n<0n?-n:n, d); return {n:n/gg, d:d/gg};
  }
  function add(a,b){ return rat(a.n*b.d + b.n*a.d, a.d*b.d); }
  function mul(a,b){ return rat(a.n*b.n, a.d*b.d); }
  function div(a,b){ return rat(a.n*b.d, a.d*b.n); }
  function pConst(c){ return [c]; }
  function pAdd(a,b){ const n=Math.max(a.length,b.length); const out=Array.from({length:n},(_,i)=> add(a[i]||ZERO,b[i]||ZERO)); return out; }
  function pScale(a, s){ return a.map(c => mul(c,s)); }
  function pMul(a,b){ const out=Array.from({length:a.length+b.length-1},()=>ZERO);
    for(let i=0;i<a.length;i++) for(let j=0;j<b.length;j++) out[i+j]=add(out[i+j], mul(a[i],b[j]));
    return out;
  }
  function pEval(a, x){ let acc=rat(0n), X=rat(1n); for(let i=0;i<a.length;i++){ acc=add(acc, mul(a[i],X)); X=mul(X,x);} return acc; }
  function pDer(a){ if(a.length<=1) return [rat(0n)]; const out=[]; for(let i=1;i<a.length;i++) out.push( mul(a[i], rat(i,1n)) ); return out; }
  function xMinus(t){ return [rat(-BigInt(t),1n), rat(1n,1n)]; }
  function lagrangeBasis(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    let num = pMul( xMinus(others[0]), xMinus(others[1]) );
    const den = rat( (BigInt(xi)-BigInt(others[0])) * (BigInt(xi)-BigInt(others[1])) , 1n);
    return pScale(num, div(ONE, den));
  }
  function sumInv(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    const t1 = div(ONE, rat(BigInt(xi)-BigInt(others[0]),1n));
    const t2 = div(ONE, rat(BigInt(xi)-BigInt(others[1]),1n));
    return add(t1,t2);
  }
  function hermiteCardinals(xi, nodes){
    const L = lagrangeBasis(xi, nodes);
    const L2 = pMul(L,L);
    const Si = sumInv(xi, nodes);
    const P = pAdd( pConst(ONE), pScale( xMinus(xi), mul(rat(-2n), Si)) );
    const Hi0 = pMul(P, L2);
    const Hi1 = pMul( xMinus(xi), L2 );
    return {Hi0, Hi1};
  }
  function toVH(m){
    if(Number.isInteger(m)) return [m,1];
    const maxH = 7;
    for(let H=1; H<=maxH; H++){
      const V = Math.round(m*H);
      if(Math.abs(m - V/H) < 1e-6) return [V,H];
    }
    return null;
  }
  function buildPoly(a,b,c, m,k,l, n, q_num, q_den){
    const nodes=[a,b,c];
    const H0 = hermiteCardinals(a, nodes);
    const H1 = hermiteCardinals(b, nodes);
    const H2 = hermiteCardinals(c, nodes);
    const term0 = pScale(H0.Hi0, rat(BigInt(m),1n));
    const term1 = pScale(H0.Hi1, rat(0n,1n)); // f'(a)=0
    const term2 = pScale(H1.Hi0, rat(BigInt(k),1n));
    const term3 = pScale(H1.Hi1, rat(BigInt(n),1n));
    const term4 = pScale(H2.Hi0, rat(BigInt(l),1n));
    const term5 = pScale(H2.Hi1, rat(BigInt(q_num), BigInt(q_den)));
    let P = pConst(rat(0n)); [term0,term1,term2,term3,term4,term5].forEach(t => P=pAdd(P,t));
    return P;
  }
  function evalPolyNum(P, x){ let y=0; for(let i=P.length-1;i>=0;i--) y = y*x + (Number(P[i].n)/Number(P[i].d)); return y; }
  function okInView(P, R){
    const steps = Math.round((R.xmax-R.xmin)*50);
    for(let i=0;i<=steps;i++){
      const x = R.xmin + i*(R.xmax-R.xmin)/steps;
      let y=0; for(let j=P.length-1;j>=0;j--) y = y*x + (Number(P[j].n)/Number(P[j].d));
      if(!Number.isFinite(y)) return false;
      if(y<R.ymin-1e-9 || y>R.ymax+1e-9) return false;
    }
    return true;
  }
  function generate(opts={}){
  const R    = opts.R || RDEF;
  const MAG  = opts.mag ?? 5;
  const DENM = Math.max(2, opts.denMax ?? 4);

  let tries = 0;
  let GAP   = (typeof opts.gap === 'number') ? opts.gap : 2; // démarre à 2

  while (tries++ < 6000){                       // ← plus large que 1200
    let a = pickDistinctInt(R.xmin+1, R.xmax-1);
    let b = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a]));
    let c = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a,b]));
    [a,b,c] = [a,b,c].sort((u,v)=>u-v);

    let m = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1); // y_A
    let k = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1); // y_B
    let l = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1); // y_C

    // A ne partage JAMAIS sa hauteur
    if (k === m || l === m) continue;
    if (Math.abs(k - m) < GAP || Math.abs(l - m) < GAP) continue;

    // reste de tes tirages
    let n = rchoice([-3,-2,-1,1,2,3]);
    let H = rchoice([2,3,4,5].filter(h=>h<=DENM));
    let Vcands = [-5,-4,-3,-2,-1,1,2,3,4,5].filter(v => (v%H)!==0);
    let V = rchoice(Vcands);

    if(!(c+H<=R.xmax && l+V>=R.ymin && l+V<=R.ymax)) continue;

    const P  = buildPoly(a,b,c, m,k,l, n, V, H);
    if(!okInView(P,R)) continue;

    const dP = pDer(P);
    const f  = x => evalPolyNum(P,x);
    const df = x => evalPolyNum(dP,x);

    const A  = {x:a, y:m,   m:0};
    const B  = {x:b, y:k,   m:n};
    const C  = {x:c, y:l,   m:V/H};

    // re-check sécurité
    if (A.y === B.y || A.y === C.y) continue;

    // échantillonnage pour le tracé
    const xs=[], grid=[5,4,4,5];
    const segments=[[R.xmin,A.x],[A.x,B.x],[B.x,C.x],[C.x,R.xmax]];
    for(let s=0;s<4;s++){
      const [x0,x1]=segments[s], npts=grid[s];
      for(let i=0;i<npts;i++){
        const t=(i+1)/(npts+1), x=x0+t*(x1-x0), y=f(x);
        xs.push([Math.round(x*1000)/1000, Math.round(y*1000)/1000]);
      }
    }
    return {R, f, df, A, B, C, VH:[V,H], pts20: xs};
  }

  // Phase 2 : si ça coince, on relâche un peu le GAP puis on retente
  if (GAP > 0) return generate({...opts, gap:GAP-1});

      // Fallback ultime (très rare) : on garantit y_C ≠ y_A
  const f=x=>0, df=x=>0;
  return {
    R:RDEF,
    f, df,
    A:{x:-2,y:1,m:0},
    B:{x:0, y:0,m:1},
    C:{x:3, y:2,m:1/2},     // ← y différent de A
    VH:[1,2],
    pts20:[]
  };
}

  global.HERMITE5 = { generate, toVH, RDEF };
})(window);
</script>
<!-- MathJax (SVG, sans Assistive MathML) -->
<!-- ⭐ MATHJAX CONFIG CHTML (PAS SVG) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<!-- FIN MathJax -->


<!-- Ceinture + bretelles : au cas où, on masque aussi l’Assistive MathML en CSS -->
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1ère — Fonctions dérivées de référence</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-sol" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <div id="host" class="card" data-active="" data-state=""></div>

<div class="card small" id="info-saisie">
  <strong>Saisie & réponses acceptées :</strong>

        <li>Division : saisir en <span class="code">a/b</span> ; puissances : <span class="code">x^2</span> ou <span class="code">x²</span>.</li>
                <li>Racine: saisir <span class="code">√(x)</span>, <span class="code">sqrt(x)</span> ou  <span class="code">rac(x)</span>.</li>
		</div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>


   
  </div>

<script>
/* =========== Outils génériques =========== */

/* ==== Canonisation d'affichage (signes, ×, doublons) ==== */
const UMINUS = '−'; // (déjà défini chez toi, laissé ici pour clarté)

/* 1) Normalise les suites de signes */
/* 1) Normalise les suites de signes (sans --, -+, +- etc.) */
function normalizeSignsStr(s){
  const U = UMINUS; // '−'
  s = String(s)
    // 0) Unifie tous les tirets en « grand moins »
    .replace(/[–—\-]/g, U)

    // 1) Réduit les doubles signes (indépendant des espaces)
    .replace(/\+\s*\+/g, ' + ')
    .replace(/−\s*−/g, ' + ')
    .replace(/\+\s*−/g, ` ${U} `)
    .replace(/−\s*\+/g, ` ${U} `)

    // 2) Nettoyage autour de "=" et parenthèses (évite "= +", "( +", etc.)
    .replace(/=\s*\+/g, '= ')
    .replace(/\(\s*\+/g, '(')

    // 3) Espaces propres
    .replace(/\s+/g, ' ')
    .replace(/\s+([\)\],;:])/g,'$1')
    .replace(/([\(\[])\s+/g,'$1');

  return s;
}
/* === [AJOUT GLOBAL, une seule fois] : re-typeset MathJax après injection === */
function retypeMath(scope){
  if (!window.MathJax) return;
  const node = scope || document;
  if (MathJax.typesetPromise) { MathJax.typesetPromise([node]); }
  else if (MathJax.typeset)   { MathJax.typeset([node]); }
}

/* 2) Forçage des multiplications explicites "×" là où nécessaire */

// Remplace TOUTE ancienne version de forceTimesStr par ceci :
function timesNumbersOnly(s){
  s = String(s);

  // 0) Nettoyage : on enlève toute * ou × indésirable devant x, ( ... ) non numérique, ou √
  s = s.replace(/(\d)\s*[\*×]\s*x\b/g, '$1x');  // 3*x → 3x ; 3×x → 3x
  s = s.replace(/(\d)\s*[\*×]\s*√/g, '$1√');    // 3*√x → 3√x ; 3×√x → 3√x
  s = s.replace(/(\d)\s*[\*×]\s*\(/g, '$1(');   // 3*( … ) → 3( … ) (on ré-insèrera × si ( … ) est numérique)

  // 1) × entre nombres séparés par un espace : "3 4" → "3 × 4"
  s = s.replace(/(\d)\s+(?=\d)/g, '$1 × ');

  // 2) × entre nombre et ( … ) si le contenu est PUREMENT NUMÉRIQUE
  //    (signes + décimales autorisés) : "5(2)" → "5 × (2)", "3(−3)" → "3 × (−3)"
  s = s.replace(/(\d)\s*(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))/g, '$1 × $2');

  // 3) × entre ( … ) numérique et nombre : "(2)3" → "(2) × 3"
  s = s.replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*(\d)/g, '$1 × $2');

  return s;
}



/* 3) Supprime les répétitions du type "= 3 = 3" ou "= −5 = −5" (anti-doublon inline) */
function dedupInlineEquals(s){
  // nombres entiers/décimaux
  s = s.replace(/=\s*([−\-]?\d+(?:[.,]\d+)?)\s*=\s*\1\b/g, '= $1');
  // cas très courant : fraction "a/b = a/b" (quand elle n'est pas encore mise en pile)
  s = s.replace(/=\s*([−\-]?\d+\/\d+)\s*=\s*\1\b/g, '= $1');
  return s;
}

/* 4) Post-traitement HTML des blocs d'étapes .steps */
function canonMathHTML(html){
  let s = String(html);
  s = timesNumbersOnly(s); // ← important : ne pas utiliser d'autres "forceTimes"
  s = normalizeSignsStr(s);
  s = dedupInlineEquals(s);
  s = s.replace(/(\d)\s*\*\s*(\d)/g, '$1 × $2') // * entre nombres -> ×
     .replace(/(\d)\s*\*\s*x\b/g, '$1x')
     .replace(/(\d)\s*\*\s*√/g, '$1√')
     .replace(/(\d)\s*\*\s*\(/g, '$1(');

  return s;
}

/* 5) Passe le peigne sur tous les blocs .steps d'un host */
function canonizeAllSteps(host){
  $$('.steps', host).forEach(el => {
    // 🔒 Si MathJax a déjà produit du <mjx-container>, on NE TOUCHE PAS
    if (el.querySelector('mjx-container')) return;
    el.innerHTML = canonMathHTML(el.innerHTML);
  });
}



const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const rnd   = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const rchoice = L => L[rnd(0,L.length-1)];
const fmtNum = v => (Math.abs(v)===Infinity? '∞' : (Number.isInteger(v)? String(v) : String(Math.round(v*1000)/1000).replace('.',',')));
const normMinus = s => String(s||'').replace(/−/g,'-').trim();

function parseNum(s){
  s = normMinus(String(s).replace(',','.'));
  if(!s) return NaN;
  if(/^\s*ND\s*$/i.test(s)) return NaN;
  if(s.includes('/')){
    const [a,b] = s.split('/').map(x=>parseFloat(x));
    if(!isFinite(a) || !isFinite(b) || b===0) return NaN;
    return a/b;
  }
  return parseFloat(s);
}

function eqNum(a,b,tol=1e-6){
  if(!Number.isFinite(a) || !Number.isFinite(b)) return null; // neutre
  return Math.abs(a-b)<=tol;
}


function typesetNode(node){
  try{
    if (!window.MathJax) return;
    if (MathJax.typesetPromise) MathJax.typesetPromise([node]);
    else if (MathJax.typeset)   MathJax.typeset([node]);
  }catch(e){}
}

// Remplace f'(x) → f′(x) (prime U+2032) dans les nœuds texte
function replacePrimesForPDF(root){
  const tw = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  const re = /([A-Za-z])'(?=\s*\()/g; // f'(x), g'(a)...
  const nodes = [];
  while (tw.nextNode()) nodes.push(tw.currentNode);
  for (const n of nodes) n.nodeValue = n.nodeValue.replace(re, (_,L)=> L + '\u2032');
}

// Uniformise rac/√/sqrt → \sqrt{…} dans les nœuds texte
function fixRadicalsForPDF(root){
  const tw = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  const nodes = [];
  while (tw.nextNode()) nodes.push(tw.currentNode);
  for (const n of nodes){
    let s = n.nodeValue;
    if (/\\sqrt\{/.test(s)) continue; // déjà en TeX
    s = s.replace(/√\s*\(\s*([^()]+?)\s*\)/g, '\\\\sqrt{$1}');
    s = s.replace(/√\s*x\b/g, '\\\\sqrt{x}');
    s = s.replace(/\brac\s*\(\s*([^()]+?)\s*\)/gi, '\\\\sqrt{$1}');
    s = s.replace(/\bsqrt\s*\(\s*([^()]+?)\s*\)/gi, '\\\\sqrt{$1}');
    n.nodeValue = s;
  }
}
// Encapsule en \( ... \) les motifs math si on les trouve à l'état "texte nu"
function wrapMathIfNeeded(root){
  const tw = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  const nodes = [];
  while (tw.nextNode()) nodes.push(tw.currentNode);

  for (const n of nodes){
    const s0 = n.nodeValue;
    if (!s0) continue;

    // on évite de toucher aux zones déjà TeX-ifiées
    if (/\(.*\\sqrt|\\dfrac|\\frac|\\prime/.test(s0)) continue;

    let s = s0;

    // √x, √( … ), rac( … ) → \( \sqrt{…} \)
    s = s.replace(/√\s*x\b/g, '\\(\\sqrt{x}\\)')
         .replace(/√\s*\(\s*([^()]+)\s*\)/g, (_,$1)=>`\\(\\sqrt{${$1}}\\)`)
         .replace(/\brac\s*\(\s*([^()]+)\s*\)/gi, (_,$1)=>`\\(\\sqrt{${$1}}\\)`);

    // f'(...) ou g'(x) → \( f'(…) \)  (dans du texte pur)
    s = s.replace(/\b([a-zA-Z])'\s*\(\s*([^()]+)\s*\)/g, (_,$f,$x)=>`\\(${$f}'(${ $x })\\)`);

    if (s !== s0) n.nodeValue = s;
  }
}



/* ===== Ticks (neutre caché) ===== */
function setTick(el,val){
  if(!el) return;
  if(val===true){  el.textContent='✓'; el.classList.add('ok'); el.classList.remove('ko'); el.style.display='inline'; }
  else if(val===false){ el.textContent='✕'; el.classList.add('ko'); el.classList.remove('ok'); el.style.display='inline'; }
  else { el.textContent=''; el.classList.remove('ok','ko'); el.style.display='none'; } // neutre caché
}

/* =========== Fractions & formats (pile partout) =========== */
function fracHTML(V,H){
  return `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`;
}

// -> [V,H] réduit si possible via HERMITE5.toVH ; sinon entier
// -> [V,H] réduit si possible via HERMITE5.toVH ; sinon approx rationnelle (den ≤ 24)
function slopeVH(m){
  const vh = (window.HERMITE5 && HERMITE5.toVH) ? HERMITE5.toVH(m) : null;
  if (vh) return vh;                       // cas "classique"
  for (let H = 1; H <= 24; H++){           // fallback : fraction simple
    const V = Math.round(m * H);
    if (Math.abs(m - V/H) < 1e-12) return reduce(V, H);
  }
  return [Math.round(m), 1];               // dernier recours (entier)
}


// V/H en pile (même si 2/1)
function vhHTML(m){ const [V,H]=slopeVH(m); return fracHTML(V,H); }

// f'(a) : entier si H=1, sinon fraction en pile (jamais “/1”)
function fprimeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }
// Rétro-compat : certains blocs appellent encore fprimeHTML_strict
const fprimeHTML_strict = fprimeHTML;

// Phrase “pentes” : 0 → “0 (tangente horizontale)”, entier ≠0 → “(−1/1) = −1”, sinon fraction pile
// --- PATCH fprimeForSentence (zéro doublon ; entier si /1) ---
function fprimeForSentence(m){
  const [V,H]=slopeVH(m);
  if(V===0) return '0 (tangente horizontale)';
  return (H===1) ? String(V) : fracHTML(V,H);
}


// Affichage générique d’une pente (pile ou entier)
function fmtSlopeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }

/* =========== Parsers stricts (pas de décimales) =========== */
// “a/b” uniquement (existante, conservée)
function parseFracStrict(s){
  s = normMinus(String(s).replace(',','.')).trim();
  if(!/^[+-]?\d+\s*\/\s*[1-9]\d*$/.test(s)) return null;
  const [A,B] = s.split('/').map(t=>parseInt(t.replace(/\s+/g,''),10));
  if(!Number.isFinite(A) || !Number.isFinite(B) || B===0) return null;
  return {a:A, b:B, val:A/B};
}

// entier strict (pas de fraction, pas de décimal)
function parseIntStrict(s){
  s = normMinus(String(s||'').trim());
  if(!/^[+-]?\d+$/.test(s)) return null;
  return parseInt(s,10);
}

// PGCD + réduction
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function reduce(n,d){ if(d<0){ n=-n; d=-d; } const g=gcd(n,d); return [n/g,d/g]; }

// entier OU fraction “a/b” → [N,D] réduit (null sinon)
function parseRatStrict(s){
  s = normMinus(String(s||'').trim());
  if(/^[+-]?\d+$/.test(s)) return [parseInt(s,10),1];
  const fr=parseFracStrict(s);
  return fr ? reduce(fr.a, fr.b) : null;
}
// décimal exact / entier / fraction -> [N,D] réduit, sinon null
function parseRatOrDecStrict(s){
  s = normMinus(String(s||'').trim());
  if(!s) return null;

  // entier
  if(/^[+\-]?\d+$/.test(s)) return [parseInt(s,10), 1];

  // fraction a/b
  const fr = parseFracStrict(s);
  if(fr) return reduce(fr.a, fr.b);

  // décimal fini (.,)
  if(/^[+\-]?\d+[.,]\d+$/.test(s)){
    const neg = s.startsWith('-');
    const t = s.replace('+','').replace('-','').replace(',','.');
    const [A,B] = t.split('.');
    const num = parseInt(A + B, 10);
    const den = 10 ** B.length;
    return reduce(neg ? -num : num, den);
  }
  return null;
}

// pour les coefficients devant x : '', '+', '-', '(…)','-(…)', nombres…
function parseCoeff(tok){
  tok = String(tok||'');
  if(tok==='' || tok==='+') return [ 1,1 ];
  if(tok==='-')             return [-1,1 ];

  // signe extérieur possible : '-(1/2)'
  let sign = 1;
  if(tok.startsWith('+(') && tok.endsWith(')')) tok = tok.slice(2,-1);
  else if(tok.startsWith('-(') && tok.endsWith(')')){ sign=-1; tok = tok.slice(2,-1); }

  // enlève des paires de parenthèses externes : '(1/2)' -> '1/2'
  while(tok.startsWith('(') && tok.endsWith(')')) tok = tok.slice(1,-1);

  const r = parseRatOrDecStrict(tok);
  return r ? reduce(sign*r[0], r[1]) : null;
}

// remplace l’ancienne slopeOKStrict
function slopeOKStrict(input, expected){
  input = String(input||'').trim();
  if(input==='') return null;                  // champ vide → tick neutre

  const rat = parseRatOrDecStrict(input);      // entier, fraction ou décimal exact
  if(!rat) return false;

  const [V,H] = slopeVH(expected);             // valeur attendue (réduite)
  const R = reduce(rat[0], rat[1]);            // valeur saisie (réduite)
  return (R[0] === V && R[1] === H);
}


/* ====== Équations de droites ====== */
// parties d’affichage : m·x et +p en pile
function mxHTML([V,H]){
  const sgn = V<0 ? '−' : '';
  const A = Math.abs(V);
  if(H===1 && A===1) return `${sgn}x`;
  return `${(H===1)? String(V) : fracHTML(V,H)}x`;
}
function signedRatHTML([N,D]){
  if(N===0) return ' + 0';
  const s = (N<0) ? ' − ' : ' + ';
  const A = Math.abs(N);
  return s + ((D===1)? String(A) : fracHTML(A,D));
}
// Affiche une rationnelle [N,D] en entier ou fraction pile
function ratHTML([N,D]){
  const R = reduce(N,D);
  return (R[1] === 1) ? String(R[0]) : fracHTML(R[0], R[1]);
}

// Équation joliment formatée : pas de “+ 0” / “− 0”, gère m = 0 et ±x
function eqHTML(mVH, pVH){
  const M = reduce(mVH[0], mVH[1]);
  const P = reduce(pVH[0], pVH[1]);

  // y = p si m = 0
  if (M[0] === 0) return `y = ${ratHTML(P)}`;

  // y = mx (+ p) sinon (sans afficher +0)
  const mx = mxHTML(M);                  // déjà “−x” quand ±1
  if (P[0] === 0) return `y = ${mx}`;    // pas de +0

  const sign = (P[0] < 0) ? ' − ' : ' + ';
  const pAbs = [Math.abs(P[0]), P[1]];
  return `y = ${mx}${sign}${ratHTML(pAbs)}`;
}

// p = y - (V/H) x  en fraction réduite
function pFromPoint(V,H,x,y){ return reduce(y*H - V*x, H); }

// outils d’affichage/ratios déjà présents :
/* gcd, reduce, slopeVH, parseRatOrDecStrict, mxHTML, signedRatHTML, pFromPoint */

// remplace l’ancienne lineOKStrict
function lineOKStrict(expr, mVH, pVH){
  expr = normMinus(String(expr||'')).replace(/\s+/g,'');
  if(!expr || !expr.startsWith('y=')) return false;
  const rhs = expr.slice(2);

  // motif commun pour un coefficient devant x : vide / signe / nombre (avec () possibles)
  const COEF_RE = '([+\\-]?(?:\\(?\\d+(?:\\/[1-9]\\d*)?\\)?|\\(?\\d+(?:[.,]\\d+)?\\)?)*?)';
  const RAT_RE  = '([+\\-]?(?:\\d+(?:\\/[1-9]\\d*)?|\\d+(?:[.,]\\d+)?))';

  let m=null, p=null;

  // 0) y = p (constante)
  let m0 = rhs.match(new RegExp('^'+RAT_RE+'$'));
  if(m0){ m=[0,1]; p=parseRatOrDecStrict(m0[1]); }

  // 1) y = m x + p    (m peut être '', '+', '-', '1/2', '(1/2)', '-(1/2)', etc.)
  if(!m || !p){
    let m1 = rhs.match(new RegExp('^'+COEF_RE+'x([+\\-])'+RAT_RE+'$'));
    if(m1){
      const mTok=m1[1], sign=m1[2], pTok=m1[3];
      m = parseCoeff(mTok);
      p = parseRatOrDecStrict((sign==='-'?'-':'')+pTok);
    }
  }

  // 2) y = p + m x
  if(!m || !p){
    let m2 = rhs.match(new RegExp('^'+RAT_RE+'([+\\-])'+COEF_RE+'x$'));
    if(m2){
      const pTok=m2[1], sign=m2[2], mTok=m2[3];
      p = parseRatOrDecStrict(pTok);
      m = parseCoeff((sign==='-'?'-':'')+mTok);
    }
  }

  // 3) y = m(x ± a) ± yA  (a,yA entiers ; m rationnel/entier/décimal exact)
  if(!m || !p){
    let m3 = rhs.match(new RegExp('^'+COEF_RE+'\\((?:x)([+\\-])(\\d+)\\)([+\\-])(\\d+)$'));
    if(m3){
      const mTok=m3[1], s1=m3[2], aTok=m3[3], s2=m3[4], yATok=m3[5];
      const mRat = parseCoeff(mTok); if(!mRat) return false;
      const a = parseInt(aTok,10), yA = parseInt(yATok,10);
      if(!Number.isInteger(a) || !Number.isInteger(yA)) return false;
      const aEff  = (s1==='-') ? a : -a;           // x - a  / x + a
      const yEff  = (s2==='-') ? -yA :  yA;        // + yA / - yA
      // y = m x + (yEff - m*aEff)
      const pRat = reduce(yEff*mRat[1] - mRat[0]*aEff, mRat[1]);
      m = mRat; p = pRat;
    }
  }

  if(!m || !p) return false;

  // comparaison rationnelle exacte
  const M   = reduce(m[0], m[1]);
  const P   = reduce(p[0], p[1]);
  const Mxp = reduce(mVH[0], mVH[1]);
  const Pxp = reduce(pVH[0], pVH[1]);
  return (M[0]===Mxp[0] && M[1]===Mxp[1] && P[0]===Pxp[0] && P[1]===Pxp[1]);
}



/* ====== Vérif “souple” (utile pour d’autres exos si tu veux la garder) ====== */
/* ===== Vérif “souple” — accepte 4x, -1x, 2(x-3), x(x+1), etc. ===== */
function parseUserLine(expr){
  // normalisations de base
  let rhs = normMinus(String(expr||'')).trim();   // remplace « − » par '-'
  if(!rhs) return null;

  // retirer un éventuel "y=" au début
  rhs = rhs.replace(/\s+/g,'');
  rhs = rhs.startsWith('y=') ? rhs.slice(2) : rhs;

  // caret -> ** (au cas où), et signes exotiques
  rhs = rhs.replace(/\^/g,'**')
           .replace(/[×·•]/g,'*')
           .replace(/,/g,'.');

  // ---- Multiplications implicites ----
  // 4x   -> 4*x
  rhs = rhs.replace(/(\d)\s*x\b/g, '$1*x');
  // )x   -> )*x
  rhs = rhs.replace(/\)\s*x\b/g, ')*x');
  // x(   -> x*( 
  rhs = rhs.replace(/\bx\s*\(/g, 'x*(');
  // 2(   -> 2*(
  rhs = rhs.replace(/(\d)\s*\(/g, '$1*(');
  // )(   -> )*(
  rhs = rhs.replace(/\)\s*\(/g, ')*(');

  // JS n’aime pas "-x**2" (pas utile ici, mais harmless)
  rhs = rhs.replace(/(^|[^\w\)])-\s*(x\s*\*\*\s*\d+)/g, '$1-($2)');

  try{
    const f = new Function('x','return ('+rhs+');');
    return (x)=> f(x);
  }catch(e){
    return null;
  }
}

// ===== Vérif "souple" mais OBLIGE 'y=' en tête =====
function isSameLine(userExpr, m, p){
  const raw = String(userExpr || '');
  const normalized = normMinus(raw).replace(/\s+/g, '');

  // ⛔️ on n'accepte pas sans 'y='
  if (!/^y=/.test(normalized)) return false;

  const f = parseUserLine(raw);   // garde la tolérance 4x, 2(x-3), etc.
  if(!f) return false;

  const xs = [-5,-3,-1,0,2,4];
  try{
    return xs.every(x => {
      const yu = f(x);
      const y  = m*x + p;
      return Number.isFinite(yu) && Math.abs(yu - y) <= 1e-3;
    });
  }catch(e){ return false; }
}



/* === UI helpers : conteneur avec/sans repère à droite pour l’énoncé === */
function renderWithRepere(host, R){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row';
  const left  = document.createElement('div');
  const right = document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);

  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  left.appendChild(rep.el);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {rep,left,right,equ,actions,res};
}

function renderNoRepere(host){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row norepere';
  const right = document.createElement('div');
  row.appendChild(right); host.appendChild(row);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {left:null,right,equ,actions,res};
}




/* tirage de 3 entiers distincts lisibles */
function pick3DistinctInts(pool=[-5,-4,-3,-2,-1,0,1,2,3,4,5]){
  const P=[...pool], xs=[];
  while(xs.length<3) xs.push(P.splice(rnd(0,P.length-1),1)[0]);
  return xs.sort((a,b)=>a-b);
}



function fmtSlopeHTML(m){ const vh=toVH(m); return vh? fracHTML(vh[0],vh[1]) : fmtNum(m); }

/* === Inputs & ticks helpers (globaux) === */
function mkInput(id, w=120, ph='', pdfw=null){
  const W = Number(pdfw ?? w); // largeur du trait en PDF
  return `
    <span class="blank-wrap" data-w="${W}">
      <input id="${id}" style="width:${w}px" autocomplete="off" inputmode="text" placeholder="${ph}">
      <span class="blank" aria-hidden="true" style="width:${W}px">&nbsp;</span>
    </span>
  `.trim();
}


function setVal(host,id,val){
  // ne pas auto-remplir pendant l'affichage de la solution
  if(host && host._noFillSolution) return;
  const el = host.querySelector('#'+id);
  if(el) el.value = val;
}
function getVal(host,id){
  const el = host.querySelector('#'+id);
  return el ? String(el.value||'').trim() : '';
}


  // Cache des derniers paramètres générés par exercice
  window.__EXO_PARAMS_CACHE = window.__EXO_PARAMS_CACHE || {};

function normalizeRac(s){
  s = String(s||'');

  // LaTeX -> sqrt(...)
  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  // ----- cas "rac(" sous TOUTES ses formes -----
  // 2rac(...), )rac(...) -> 2*sqrt(...), )*sqrt(...)
  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  // début de chaîne ou séparateur non-mot avant rac( -> sqrt(
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  // ----- variantes avec le symbole √ -----
  // 2√(...), )√(...) -> 2*sqrt(...), )*sqrt(...)
  s = s.replace(/(\d|\))\s*√\s*\(/g, '$1*sqrt(');
  // 2√x, )√x -> 2*sqrt(x), )*sqrt(x)
  s = s.replace(/(\d|\))\s*√\s*x\b/gi, '$1*sqrt(x)');
  // √(…) / √x "nus" -> sqrt(...)
  s = s.replace(/√\s*\(/g,   'sqrt(')
       .replace(/√\s*x\b/gi, 'sqrt(x)');

  // Sécurité : ")sqrt(" -> ")*sqrt("
  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');

  // Cas classique du dénominateur : 1/(2sqrt(...)) si l’étoile manquait encore
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');

  return s;
}



/* ============================================================
   Affichage propre (√, exposants ²/³, × entre nombres, fractions)
   ============================================================ */
function prettyExprHTML(expr){
  const U = '−';
  const frac = (N,D)=>`<span class="frac"><span class="num">${N}</span><span class="den">${D}</span></span>`;
  let s = String(expr||'').trim();

  // Signes + espaces
  s = s.replace(/-/g, U).replace(/\s+/g, ' ');

  // --- Racines pour l'affichage ---
  // rac(...), y compris après chiffre/")"  -> √(...)
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(\s*([^()]+)\s*\)/gi, '$1√($2)');
  // sqrt(x|...) -> √x | √(...)
  s = s.replace(/sqrt\(\s*x\s*\)/gi, '√x')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '√($1)');

  // Cas spécial joli : 1/(2*sqrt(x)) -> 1/(2√x)
  s = s.replace(/1\s*\/\s*\(\s*2\s*[*×·]?\s*sqrt\(\s*x\s*\)\s*\)/gi,
                ()=> frac('1','2√x'));

  // ---- Puissances → balises <sup> ----
  // x^n
  s = s.replace(/x\^2\b/gi, 'x²')
       .replace(/x\^3\b/gi, 'x³')
       .replace(/x\^(\d+)/gi, (_,$1)=>`x<sup>${$1}</sup>`);
  // (±nombre)^n
  s = s.replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*2/g, '$1²')
       .replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*3/g, '$1³')
       .replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*(\d+)/g,
                (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);
  // nombre^n
  s = s.replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*2/g, '$1²')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*3/g, '$1³')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g,
                (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);
  // Fallback : ")^n"
  s = s.replace(/(\))\s*\^\s*(\d+)/gi, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // × uniquement entre nombres (pas avant x, √, parenthèse)
  s = timesNumbersOnly(s);

  // Nettoyage des signes
  s = s.replace(/\+\s*−/g, ` ${U} `)
       .replace(/−\s*\+/g, ` ${U} `)
       .replace(/−\s*−/g, ' + ')
       .replace(/\s+/g, ' ');

  return s;
}


/* ============================================================
   Évaluation sûre (caret ^ → **, multiplications implicites, √/rac)
   ============================================================ */
function evalExprSafe(expr, x){
let code = String(expr||'')
  .replace(/\ufeff/g,'')
  .replace(/<\/?[^>]+>/g,'')
  .replace(/[\u00A0\u202F\u2009\u200A\u2005\u2006\u2007\u2008\u2002\u2003\u2004]/g,' ')
  .replace(/−|–|—/g,'-')
  .replace(/[×·•]/g,'*')
  .replace(/[⁄∕]/g,'/')
  .replace(/,/g,'.');

code = normalizeRac(code).replace(/sqrt\(/g,'Math.sqrt(');
// puis ^ -> **, multiplications implicites générales, filtre caractères, etc.


  // 3) Puissances '^' → '**'
  code = code
    .replace(/x\^(\d+)/gi, 'x**$1')
    .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)**$2')
    .replace(/(\d+(?:\.\d+)?)\s*\^\s*(\d+)/g, '($1**$2)');

  // 4) Multiplications implicites générales
  code = code
    .replace(/(\d)\s*x\b/g, '$1*x')   // 2x -> 2*x
    .replace(/\)\s*x\b/g, ')*x')      // )x -> )*x
    .replace(/\bx\s*\(/g, 'x*(')      // x( -> x*(
    .replace(/(\d)\s*\(/g, '$1*(')    // 2( -> 2*(
    .replace(/\)\s*\(/g, ')*(')       // )( -> )*(
    .replace(/(\d)\s*(?=Math\.)/g, '$1*')
    .replace(/\)\s*(?=Math\.)/g, ')*');

  // 5) Filtre caractères autorisés
  code = code.replace(/[^0-9eE+\-*/().x\sA-Za-z_]/g, '');

  // 6) JS n’aime pas "-x**2"
  code = code.replace(/(^|[^\w\)])-\s*(x\s*\*\*\s*\d+)/g, '$1-($2)');

  const f = new Function('x', 'return (' + code + ');');
  return f(x);
}


/* ============================================================
   TeX/entrée → expression évaluables par evalExprSafe
   ============================================================ */
function asEvalExpr(expr){
let s = normalizeRac(expr);
// puis le reste (puissances, \cdot -> *, etc.)

  // Superscripts Unicode → ^n
  s = s.replace(/([A-Za-z0-9)\]])\s*²/g, '$1^2')
       .replace(/([A-Za-z0-9)\]])\s*³/g, '$1^3');

  // \dfrac / \frac {A}{B} -> (A)/(B)
  s = s.replace(/\\(?:d)?frac\{([^{}]+)\}\{([^{}]+)\}/g, '($1)/($2)');



  // x^{n} -> x^n
  s = s.replace(/x\^\{(\d+)\}/gi, 'x^$1');

  // \cdot, \times -> *
  s = s.replace(/\\cdot|\\times/g, '*');

  // Accolades simples -> parenthèses ; espaces
  s = s.replace(/\{/g, '(').replace(/\}/g, ')')
       .replace(/\s+/g, ' ');

  return s;
}




// Remplace x par la valeur en insérant * si un nombre ou ')' précède x
function substXWithMul(str, X){
  const sub = (X < 0 ? `(${X})` : String(X));  // parenthèses seulement si X<0
  return str
    .replace(/(\d|\))\s*x\b/g, '$1*' + sub)    // a x^n → a*X^n  (ou )x → )*X)
    .replace(/x\b/g, sub);                     // le reste : x → X
}

// f(x) évaluée en x=a — insère \times correctement (pas "times")
function texFxEvalLine(expr, a){
  const pr = v => fmtNum(v);
  const A  = (a < 0) ? `(${pr(a)})` : `${pr(a)}`;
  let t = String(expr||'').trim().replace(/,/g,'.');

  // 1) TeX-ification de l’expression
  t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}')
       .replace(/x\^(\d+)/gi, 'x^{$1}')
       .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{$2}')
       .replace(/(\d+(?:\.\d+)?)\s*\^\s*(\d+)/g, '{$1}^{$2}')
       .replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{$1}}')
       .replace(/\b1\s*\/\s*x\^(\d+)/gi,  '\\dfrac{1}{x^{$1}}')
       .replace(/-\s*1\s*\/\s*x\b/gi,     '-\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*x\b/gi,       '\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}');

  // 2) Substitution x -> a (avec parenthèses si a<0)
  t = t.replace(/x\^{(\d+)}/gi,  `${A}^{$1}`)
       .replace(/\\sqrt\{x\}/gi, `\\sqrt{${A}}`)
       .replace(/x\b/gi,         A);

  // 3) Insertion des \times entre nombre et (a)^p, a, √(...), (...)
  const escA = A.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');

  // n (a)^p  → n \times (a)^p
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}\\^\\{(\\d+)\\}`,'g'),
                '$1 \\\\times ' + A + '^{\$2}');
  // n a      → n \times a
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}(?![\\w])`,'g'),
                '$1 \\\\times ' + A);
  // n √(...) → n \times √(...)
  t = t.replace(/([+\-]?\d+)\s*\\sqrt\{/g, '$1 \\\\times \\\\sqrt{');
  // n (...)  → n \times (...)
  t = t.replace(/([+\-]?\d+)\s*\(/g,        '$1 \\\\times (');

  // 4) Filet de sécurité si un "times" nu subsistait
  t = t.replace(/\btimes\b/g, '\\times');

  return t;
}

// Normalise toutes les écritures de racine pour l'évaluation/compare
function normalizeRadicalsAll(s){
  s = String(s||'');

  // LaTeX → forme "sqrt(...)"
  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  // rac(...) / √(...) / √x  → sqrt(...)
  s = s.replace(/\brac\s*\(/gi, 'sqrt(')
       .replace(/√\s*\(/g,       'sqrt(')
       .replace(/√\s*x\b/gi,     'sqrt(x)');

  // nombres collés : 2sqrt(...) → 2*sqrt(...)
  s = s.replace(/(\d)\s*(?=sqrt\()/g, '$1*');

  // cas 1/(2sqrt(...)) → 1/(2*sqrt(...))
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');

  // sécurité : ")sqrt(" → ")*sqrt("
  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');

  return s;
}

// Compare deux expressions en x numériquement, en tolérant rac/sqrt/√
function eqExpr(userExpr, expectedExpr){
const normRad = s => normalizeRac(s);


  const U = normRad(userExpr);
  const E = normRad(expectedExpr);

  const xs = [-5,-3,-2,-1,-0.5,0.5,1,2,3,4];
  let ok=true, tested=0;
  for(const x of xs){
    try{
      const yu = evalExprSafe(asEvalExpr(U), x);
      const ye = evalExprSafe(asEvalExpr(E), x);
      if(Number.isFinite(yu) && Number.isFinite(ye)){
        tested++;
        if(Math.abs(yu-ye)>1e-3){ ok=false; break; }
      }
    }catch(_){ /* on ignore les x hors domaine */ }
  }
  return tested>=4 && ok;
}




/* ================== Exercices ================== */
function makeExos(){
  const L=[];
/* ===== Ex. 6 — Équation de la tangente (f et f' donnés) + SÉLECTEUR ===== */
L.push({
  id:'ex6_eq_tangente_f_fx',
  title:"Ex. Fonction dérivée et équation de la tangente",
  gen(forcedKind){
    // → on conserve 'poly' (exclut affine), et on ajoute 'affine' & 'linear'
    const kinds = ['square','cube','inverse','sqrt','affine','linear','poly'];
    const kind  = (forcedKind && forcedKind!=='random') ? forcedKind : rchoice(kinds);

    // Fabrique un polynôme de degré 2 ou 3 (≠ affine)
    // … à l’intérieur de gen(forcedKind) …
// dans gen(forcedKind) de l'exo 6
// Dans gen() de l'Ex.6
// --- PATCH polyGen (corrige l'affichage de dfx) ---
function polyGen(){
  const UMINUS = '−';
  const deg = rchoice([2,3]);                 // jamais affine
  const a = rchoice([-3,-2,-1,1,2,3]);
  const b = rchoice([-3,-2,-1,0,1,2,3]);
  const c = rchoice([-3,-2,-1,0,1,2,3]);
  const d = rchoice([-3,-2,-1,0,1,2,3]);

  // Monôme intérieur " ± A x^p " (cache A si A=1 et p>=1)
  const term = (K, p) => {
    if (K === 0) return '';
    const s = K > 0 ? ' + ' : ` ${UMINUS} `;
    const A = Math.abs(K);
    if (p === 0) return s + A;
    if (p === 1) return s + (A === 1 ? '' : A) + 'x';
    return s + (A === 1 ? '' : A) + `x^${p}`;
  };

  // Monôme de tête (sans " + " devant)
  const lead = (K, p) => {
    const S = K < 0 ? UMINUS : '';
    const A = Math.abs(K);
    if (p === 1) return S + (A === 1 ? '' : A) + 'x';
    return S + (A === 1 ? '' : A) + `x^${p}`;
  };

  let fx = '', dfx = '';

  if (deg === 3) {
    // f(x) = ax^3 + bx^2 + cx + d
    fx  = lead(a,3) + term(b,2) + term(c,1) + term(d,0);

    // f'(x) = 3ax^2 + 2bx + c
    const A3 = 3*a, B2 = 2*b;
    dfx = lead(A3,2) + term(B2,1) + term(c,0);
  } else {
    // f(x) = ax^2 + bx + c
    fx  = lead(a,2) + term(b,1) + term(c,0);

    // f'(x) = 2ax + b
    const A2 = 2*a;
    dfx = lead(A2,1) + term(b,0);
  }

  return {
    fx:  String(fx).replace(/^\+\s*/,'').trim(),
    dfx: String(dfx).replace(/^\+\s*/,'').trim()
  };
}



    let fx, dfx, xA;

    if(kind==='square'){    fx='x^2';             dfx='2x';            xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='cube'){ fx='x^3';             dfx='3x^2';          xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='inverse'){ fx='1/x';          dfx='-\\dfrac{1}{x^2}';        xA=rchoice([-3,-2,-1,1,2,3]);   } // ≠0
    else if(kind==='sqrt'){    fx='sqrt(x)';      dfx='\\dfrac{1}{2sqrt(x)}'; xA=rchoice([1,4,9]);   } // simple
    else if(kind==='affine'){
      const m = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // pente ≠0
      const b = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // b ≠0 pour éviter linéaire
      fx  = `${m}x ${b>=0?'+':''}${b}`;
      dfx = `${m}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else if(kind==='linear'){
      const k = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      fx  = `${k}x`;                                          // pas de “+ 0”
      dfx = `${k}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else{ // 'poly' (degré 2 ou 3 uniquement)
      const P = polyGen();
      fx=P.fx; dfx=P.dfx;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }

   const st = { kind, fx, dfx, xA };

  // ⭐️ AJOUT : expose aussi un "params" que le kit utilise dans sa clé d’unicité
  st.params = {
    fx, dfx, xA,
    // mini-signature pour garantir l’unicité même si deux tirages aboutissent aux mêmes chaînes
    sig: Math.random().toString(36).slice(2)
  };

  return st;
  },

  render(host, st){
  const chosen = (window.__EXO6_KIND__ || 'random');

  const safeParse = s => { try { return JSON.parse(s || '{}'); } catch { return {}; } };
  const prev      = safeParse(host.dataset.state);
  const cached    = (window.__EXO_PARAMS_CACHE && window.__EXO_PARAMS_CACHE[this.id]) || null;

  // 🔧 Normalise l’état quelle que soit la forme (avec/ sans params)
  const pick = (src) => {
    if (!src) return null;
    // cas 1 : src = { kind, fx, dfx, xA, params:{...} }
    if ('fx' in src && 'dfx' in src && 'xA' in src) return src;
    // cas 2 : src = { params:{fx,dfx,xA,...}, kind? }
    if (src.params && ('fx' in src.params) && ('dfx' in src.params) && ('xA' in src.params)){
      const k = src.kind || src.params.kind || chosen;
      return { kind: k, fx: src.params.fx, dfx: src.params.dfx, xA: src.params.xA, params: src.params };
    }
    return null;
  };

  // ordre de priorité : st (PDF/kit) → host.dataset.state → cache → nouveau tirage
  let s = pick(st) || pick(prev?.params) || pick(cached?.params) || this.gen(chosen);

  // Mémorise partout
  host.dataset.state = JSON.stringify({ params: s });
  host._state = s;
  window.__EXO_PARAMS_CACHE = window.__EXO_PARAMS_CACHE || {};
  window.__EXO_PARAMS_CACHE[this.id] = { params: s };


  const ui = renderNoRepere(host);

  // -- Helpers LaTeX très simples (suffisants pour nos formes) --
  const toTeX = (expr)=>{
    let t = String(expr||'').trim();

    // racines
    t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
         .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}');

    // puissances
    t = t.replace(/x\^(\d+)/gi, 'x^{$1}')
         .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{$2}')
         .replace(/(\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, '{$1}^{$2}');

    // cas fraction simples
    t = t.replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{$1}}')
         .replace(/-\s*1\s*\/\s*x\b/gi, '-\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*x\^(\d+)/gi, '\\dfrac{1}{x^{$1}}')
         .replace(/\b1\s*\/\s*x\b/gi, '\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}');

    // décimale française → point (au cas où)
    t = t.replace(/,/g,'.');

    // multiplications : on laisse implicites (3x, 2x, …)
    return t;
  };

  // — Sélecteur textuel + bouton (inchangés) —
const selectorHTML = `
  <div class="optionline small hide-print" style="margin-bottom:.4rem">
    <label for="kind6"><b>Type de fonction :</b></label>
    <select id="kind6">
      <option value="random">Aléatoire</option>
      <option value="square">Carré (x^2)</option>
      <option value="cube">Cube (x^3)</option>
      <option value="inverse">Inverse (1/x)</option>
      <option value="sqrt">Racine carrée (√x)</option>
      <option value="affine">Affine (mx + p)</option>
      <option value="linear">Linéaire (mx)</option>
      <option value="poly">Polynôme (deg 2–3)</option>
    </select>
    <button id="regen6" class="btn">↻ Tirer</button>
  </div>
`;


  // — ÉNONCÉ : formules et points en LaTeX —
  ui.equ.innerHTML = `
    ${selectorHTML}
    <p>Donner une équation de la tangente \\(T\\) au point \\(A\\) de \\(C_f\\) d’abscisse \\(x_A\\).</p>
    <p>\\( f(x) = ${toTeX(s.fx)} \\) &nbsp; en \\( x_A = ${fmtNum(s.xA)} \\).</p>
       <p>\\( f(${fmtNum(s.xA)})=\\) ${mkInput('fa',260)} <span id="tfa" class="tick">—</span></p>
<p>\\( f'(x)= \\)${mkInput('fd',260)} <span id="tfd" class="tick">—</span></p>
       <p>\\( f'(${fmtNum(s.xA)})=\\) ${mkInput('fda',260)} <span id="tfda" class="tick">—</span></p>



   <p> Equation : ${mkInput('r1',260,'y = ...')} <span id="tr1" class="tick">—</span></p>
    <div id="steps6" class="steps"></div>
  `;

  host._state = s; host._ui = ui;

  // sélectionner l’option active et callbacks
  $('#kind6',host).value = chosen;
  const regenerate = (kind)=>{ window.__EXO6_KIND__ = kind; this.render(host,{params:this.gen(kind)}); };
  $('#kind6',host).addEventListener('change', e=>regenerate(e.target.value));
  $('#regen6',host).addEventListener('click', ()=>regenerate($('#kind6',host).value));

  // Typeset LaTeX de l’énoncé (incluant l’aperçu des formules)
  if (window.retypeMath) retypeMath(host);
},

verify(host){
  const s = host._state;
  const a = s.xA;

  // Références
  const yA = evalExprSafe(asEvalExpr(s.fx),  a);
  const m  = evalExprSafe(asEvalExpr(s.dfx), a);
  const p  = yA - m*a;

  // 1) f(a)
  const faStr = getVal(host,'fa');
  let ok_fa = null;
  if (faStr !== ''){
    const faUser = parseNum(faStr);
    ok_fa = Number.isFinite(yA) && Number.isFinite(faUser) && Math.abs(faUser - yA) <= 1e-3;
  }
  setTick($('#tfa', host), ok_fa);

  // 2) f'(x)
  const fdStr = getVal(host,'fd');
  let ok_fd = null;
  if (fdStr !== ''){
ok_fd = eqExpr(fdStr, s.dfx)
     || (s.kind==='sqrt' && (
           eqExpr(fdStr, '1/(2sqrt(x))') ||
           eqExpr(fdStr, '1/(2rac(x))')   // ← accepte explicitement rac
        ))
     || (s.kind==='inverse' && eqExpr(fdStr, '-1/x^2'));

  }
  setTick($('#tfd', host), ok_fd);

  // 3) f'(a)
  const fdaStr = getVal(host,'fda');
  let ok_fda = null;
  if (fdaStr !== ''){
    const fdaUser = parseNum(fdaStr);
    ok_fda = Number.isFinite(m) && Number.isFinite(fdaUser) && Math.abs(fdaUser - m) <= 1e-3;
  }
  setTick($('#tfda', host), ok_fda);

  // 4) Équation
  const eqStr = getVal(host,'r1');
  let ok_eq = null;
  if (eqStr !== ''){
    ok_eq = isSameLine(eqStr, m, p);
  }
  setTick($('#tr1', host), ok_eq);

  // → Résultat global : seulement si TOUT est rempli et correct
  const filled = (faStr!=='' && fdStr!=='' && fdaStr!=='' && eqStr!=='');
  return filled && (ok_fa===true && ok_fd===true && ok_fda===true && ok_eq===true);
}
,


  /* ===== Ex.6 — PATCH : only show \times on the f'(a) line ===== */
solution(host){
  const s  = host._state;
  const ui = host._ui;

  const pr = v => fmtNum(v);
function pushUnique(L, s){ if(!L.length || L[L.length-1]!==s) L.push(s); }

  // ------- LaTeX helpers (sans \times sauf pour la ligne d’évaluation de f') -------
  const texRat = (val)=>{                   // entier ou fraction
    const [V,H] = slopeVH(val);
    if(H===1) return String(V);
    const sgn = V<0 ? '-' : '';
    return `${sgn}\\dfrac{${Math.abs(V)}}{${H}}`;
  };
  /* === 1) mx sans \times (corrigé : gère m = 0) === */
const texMxNoTimes = (m)=>{
  const [V,H] = slopeVH(m);
  if (V === 0) return '0';                 // <- empêche "0x"
  if (H===1 && V=== 1) return 'x';
  if (H===1 && V===-1) return '-x';
  return `${texRat(m)}x`;
};

  // + a  /  - a  / rien si 0 — a est formaté en fraction exacte
const signAbsTex = (val)=>{
  const [V,H] = slopeVH(val);          // rationnalise val -> V/H
  if (V === 0) return '';
  const A = Math.abs(V);
  const chunk = (H === 1) ? String(A) : `\\dfrac{${A}}{${H}}`;
  return (V > 0 ? ' + ' : ' - ') + chunk;
};

  // Mise en TeX simple (pas de \times)
  const toTeX = (expr)=>{
    let t = String(expr||'').trim();

    // racines
    t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
         .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}');

    // puissances
    t = t.replace(/x\^(\d+)/gi, 'x^{$1}')
         .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{$2}')
         .replace(/(\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, '{$1}^{$2}');

    // cas fraction simples
    t = t.replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{$1}}')
         .replace(/-\s*1\s*\/\s*x\b/gi, '-\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*x\^(\d+)/gi, '\\dfrac{1}{x^{$1}}')
         .replace(/\b1\s*\/\s*x\b/gi, '\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}');

    // décimale française → point (au cas où)
    t = t.replace(/,/g,'.');

    // multiplications : on laisse implicites (3x, 2x, …)
    return t;
  };


  // >>> LIGNE 2 : f'(a) avec \times UNIQUEMENT ici <<<
 // ——— Ex.6 : f'(a) avec × UNIQUEMENT sur cette ligne ———
function texDerivEvalLine(expr, a){
  const pr = v => fmtNum(v);
  const aTex = (a < 0) ? `(${pr(a)})` : `${pr(a)}`;

  // TeX propre de f'(x), puis substitution x -> a
  let t = String(expr||'').trim();
  t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}')
       .replace(/x\^(\d+)/gi, 'x^{$1}')
       .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{$2}')
       .replace(/(\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, '{$1}^{$2}')
       .replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{$1}}')
       .replace(/-\s*1\s*\/\s*x\b/gi,       '-\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*x\^(\d+)/gi,    '\\dfrac{1}{x^{$1}}')
       .replace(/\b1\s*\/\s*x\b/gi,         '\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}')
       .replace(/,/g,'.');

  // Substitution x -> a (brackets si négatif)
  t = t.replace(/x\^{(\d+)}/gi, `${aTex}^{$1}`)
       .replace(/\\sqrt\{x\}/gi, `\\sqrt{${aTex}}`)
       .replace(/x\b/gi, aTex);

  // — Insertion du symbole × (Unicode) entre coefficient numérique et a/√a/(a)^n/(...)
  const escA = aTex.replace(/[-()]/g,'\\$&');
  // n (a)^n
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}\\^\\{(\\d+)\\}`,'g'),
                '$1 × ' + aTex + '^{$2}');
  // n a
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}(?![\\w])`,'g'),
                '$1 × ' + aTex);
  // n √(...)
  t = t.replace(/([+\-]?\d+)\s*\\sqrt\{/g, '$1 × \\sqrt{');
  // n ( ... )
  t = t.replace(/([+\-]?\d+)\s*\(/g,        '$1 × (');

  return t;
}
// --- utilitaire : comparaison "visuelle" de deux lignes LaTeX ---
function sameLatexLine(a, b){
  const norm = s => String(s)
    .replace(/<\/?[^>]+>/g, '')            // enlève HTML
    .replace(/\\\\\(|\\\\\)/g, '')         // enlève \( \)
    .replace(/\\,|\\;|\\!|\\:|~|\\ /g, '') // espaces LaTeX
    .replace(/\s+/g, '')                   // plus aucun espace
    .replace(/\\frac/g, '\\dfrac')         // unifie frac/dfrac
    .replace(/−/g, '-')                    // moins unicode
    .replace(/\+\-/g, '-')                 // "+ -" -> "-"
    .replace(/\-\+/g, '-')                 // "- +" -> "-"
    .replace(/\-\-/g, '+');                // "--" -> "+"
  return norm(a) === norm(b);
}


  // --- Évaluations robustes (même si s.fx/s.dfx avaient déjà du TeX) ---
  const a  = s.xA;
  const m  = evalExprSafe( asEvalExpr(s.dfx), a );
  const yA = evalExprSafe( asEvalExpr(s.fx) , a );

  const mVH = slopeVH(m);
  const pVH = pFromPoint(...mVH, a, yA);

  // --- Pré-remplissage ASCII (oblige "y =", * explicites, pas de 1x/-1x) ---
 /* === 2) Pré-remplissage ASCII (corrigé : pas de 0x) === */
(function prefillASCII(){
  // m = V/H ; p = pVH[0]/pVH[1]
  const [mV,mH] = mVH, [pV,pH] = pVH;
  let rhs = 'y = ';
  if (mV === 0) {
    // y = p
    rhs += (pH===1) ? String(pV) : '('+pV+'/'+pH+')';
  } else {
    // y = (V/H)*x [+/- p]
    let mTerm;
    if (mH===1 && mV=== 1) mTerm = 'x';
    else if (mH===1 && mV===-1) mTerm = '-x';
    else mTerm = '('+mV+'/'+mH+')*x';
    rhs += mTerm;
    if (pV !== 0){
      const pAbs = (pH===1) ? String(Math.abs(pV))
                            : '('+Math.abs(pV)+'/'+pH+')';
      rhs += (pV > 0 ? ' + ' : ' - ') + pAbs;
    }
  }
  setVal(host,'r1', rhs);
})();


  // Pas de .steps (prime) -> on enlève si présent
  const old = $('#steps6', host);
  if (old) old.remove();

const resBox = ui.right.querySelector('#res');
resBox.classList.add('solution','solbox');   // important : pour le style + détection kit
// (On nettoie)
resBox.innerHTML = '';


 function fixSigns(s){
  return String(s)
    .replace(/\+\s*-\s*/g, ' - ')
    .replace(/-\s*\+\s*/g, ' - ')
    .replace(/-\s*-\s*/g, ' + ');
}
// Normalisation d’un fragment TeX en ligne (pas une ligne entière)
function normTexInline(t){
  return String(t)
    .replace(/\s+/g,'')          // espaces
    .replace(/\\frac/g,'\\dfrac')// unifie frac/dfrac
    .replace(/−/g,'-')           // moins unicode
    .replace(/\+\-/g,'-')        // +-
    .replace(/\-\+/g,'-')        // -+
    .replace(/\-\-/g,'+');       // --
}

// "lhs [= rhs]" mais on supprime rhs si identique à lhs
function eqOnce(lhs, rhs){
  return (normTexInline(lhs) === normTexInline(rhs)) ? lhs : `${lhs} = ${rhs}`;
}

  /* === 3) Lignes de solution : pas de "0x" ni doublons === */
const L = [];

// L1 : f(a)
const fEval = texFxEvalLine(s.fx, a); // ex: \dfrac{1}{3} ou \sqrt{9}
const fVal  = texRat(yA);             // ex: \dfrac{1}{3} ou 3
L.push(`<p>\\( f(x) = ${toTeX(s.fx)} \\) donc : \\(f(${fmtNum(a)}) = ${eqOnce(fEval, fVal)}\\)</p>`);


// L2 : f'(a) (c’est la seule ligne avec le symbole ×)
const dEval = texDerivEvalLine(s.dfx, a); // ex: 3, \dfrac{1}{2}\sqrt{...}, ...
const dVal  = texRat(m);                  // valeur numérique en fraction
L.push(`<p>\\( f'(x) = ${toTeX(s.dfx)} \\) donc : \\(f'(${pr(a)}) = ${eqOnce(dEval, dVal)}\\)</p>`);
L.push(`<p>L'équation de la tangente \\(T\\) au point \\(A\\) de \\(C_f\\) d’abscisse \\( x_A = ${fmtNum(s.xA)} \\) est \\( \\) : </p>`);
L.push(`<p>\\(y = f'(${pr(a)})(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))}) + f(${pr(a)})\\)</p>`);

// L3 : équation point-pente
// L3 : équation point-pente (jamais '+ -', jamais décimal)
L.push(`<p>\\(y = ${texRat(m)}(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))})${signAbsTex(yA)}\\)</p>`);

// L4 : remplacement m,f(a) — simplifie le cas m=0
if (m === 0) {
  L.push(`<p>\\(y = ${texRat(yA)}\\)</p>`);
} else {
  L.push(`<p>\\(y = ${texRat(m)}(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))}) + ${texRat(yA)}\\)</p>`);
}


// L5 : développement — n’affiche pas "0x" et jamais de décimal
const t1 = m * (-a);
if (m !== 0) {
  L.push(`<p>\\(y = ${texMxNoTimes(m)}${signAbsTex(t1)}${signAbsTex(yA)}\\)</p>`);
}


// L6 : forme finale — compacte (m=0 -> y=p ; p=0 -> y=mx)
// ...après avoir rempli L avec les étapes précédentes...
const finalLine = (()=>{
  const pTex = (pVH[0]===0) ? '0'
           : (pVH[1]===1) ? String(Math.abs(pVH[0]))
                           : `\\dfrac{${Math.abs(pVH[0])}}{${pVH[1]}}`;
  if (m === 0)           return `y = ${(pVH[0]===0)?'0':(pVH[0]<0?'- ':'')+pTex}`;
  if (pVH[0]===0)        return `y = ${texMxNoTimes(m)}`;
  return `y = ${texMxNoTimes(m)} ${pVH[0]>0?'+':'-'} ${pTex}`;
})();

const finalHTML = `<p><b>\\(${finalLine}\\)</b></p>`;
if (!sameLatexLine(L[L.length-1], finalHTML)) {
  L.push(finalHTML);   // on n’ajoute la dernière ligne que si elle apporte quelque chose
}


/* --- 4) Anti-doublon (consécutif) avant rendu --- */
function dedupConsecutive(htmlLines){
  const out=[]; let prev='';
  for(const s of htmlLines){
    const n = s.replace(/<\/?[^>]+>/g,'').replace(/\\\\\(|\\\\\)/g,'').replace(/\s+/g,' ').trim();
    if(n!==prev){ out.push(s); prev=n; }
  }
  return out;
}
const Lfixed = L.map(fixSigns);
resBox.innerHTML = `<div class="steps">${dedupConsecutive(Lfixed).join('')}</div>`;

// Canonisation + MathJax dans la box qui sera réellement extraite par le kit
if (window.canonizeAllSteps) canonizeAllSteps(resBox);
if (window.retypeMath)       retypeMath(resBox);


}


});



  return L;
}


/* ===== REGISTRY & UI glue — VERSION FINALE ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, {});
	// -- PATCH: mémorise les paramètres tirés pour cet exo --
try {
  const st = JSON.parse(host.dataset.state || '{}');
  if (def.id && st && st.params) {
    window.__EXO_PARAMS_CACHE[def.id] = st; // ex: {params: ...}
  }
} catch(e){ /* no-op */ }

  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d’affichage :</b> ${e.message}<br>Ouvre la console pour le détail.
    </div>`;
  }
}

function scoreSet(a,b){ const s=document.querySelector('#score'); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
const rerender = ()=>{
  SCORE=[0,0]; scoreSet(0,0);
  const host = document.querySelector('#host');
  const def  = window.REGISTRY.find(e => e.id === document.querySelector('#exo-select').value);
  const kind = window.__EXO6_KIND__ || 'random';
  const params = def.gen(kind);                  // nouveau tirage cohérent avec le choix
  window.__EXO_PARAMS_CACHE[def.id] = { params };
  def.render(host, { params });
};
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  // init UI exercices
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
document.querySelector('#btn-new')?.addEventListener('click', ()=>{
  const host = document.querySelector('#host');
  const def  = window.REGISTRY.find(e => e.id === host.dataset.active);
  const kind = window.__EXO6_KIND__ || 'random';
  const params = def.gen(kind);                  // ← nouveau tirage, explicite
  window.__EXO_PARAMS_CACHE[def.id] = { params };
  def.render(host, { params });                  // ← on passe les params, pas {}
  SCORE=[0,0]; scoreSet(0,0);
});

  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    host._noFillSolution = true;
    try{ def.solution(host); }catch(e){ console.error(e); }
        host._noFillSolution = false;
  });

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    const inputs = Array.from(host.querySelectorAll('input'));
    const allFilled = inputs.every(i => String(i.value||'').trim()!=='');
    let ok=false;
    try{ ok = def.verify(host); }catch(e){ console.error(e); }
    if(allFilled){
      if(ok){ SCORE[0]++; SCORE[1]++; } else { SCORE[1]++; }
      scoreSet(...SCORE);
    }
  });
});




/* =========================================================
   Adaptateur PDF : version iframe SVG
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
  if (window.ExoPDF && typeof ExoPDF.init==='function'){
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      // on veut renvoyer l'état exact (params) qu'a l'exo actif
beforeGen(def, _ignored, ctx){
  // récupère le "kind" courant (carré, racine, etc.)
  const kind = window.__EXO6_KIND__ || 'random';

  // on génère de nouveaux paramètres frais
  const params = def.gen(kind);

  // on met à jour le cache global pour cohérence UI <-> PDF
  window.__EXO_PARAMS_CACHE[def.id] = { params };

  // c'est cet objet qui sera passé à beforeRender
  return { params };
},


      // ATTENTION: doit renvoyer une Promise<string> (HTML final SVG-ready)
beforeRender(def, st, withSolutions){
  return (async () => {

    // 0. Récup params
    const usableParams = st && st.params ? st.params : st;

    // 1. Host caché pour générer enoncé+solution SANS MathJax écran
    const tmpHost = document.createElement('div');
    tmpHost.style.position='fixed';
    tmpHost.style.left='-10000px';
    tmpHost.style.top='-10000px';
    tmpHost.style.width='800px';
    tmpHost.style.zIndex='-1';
    document.body.appendChild(tmpHost);

    // on sauve et on neutralise retypeMath pour ne PAS lancer CHTML
    const savedRetypeMath = window.retypeMath;
    window.retypeMath = function(){};

    // 2. Générer l'énoncé dans tmpHost
    def.render(tmpHost, {params: usableParams});

    // récupérer le HTML de l'énoncé (.equ)
    const equEl = tmpHost.querySelector('.equ');
    let enonceHTML = '';
    if (equEl){
      const clone = equEl.cloneNode(true);

      // virer sélecteur "Type de fonction" & boutons
      clone.querySelector('.hide-print')?.remove();
      clone.querySelectorAll('button').forEach(b=>b.remove());
      clone.querySelectorAll('select').forEach(s=>s.remove());

      // virer ticks
      clone.querySelectorAll('.tick').forEach(t=>t.remove());

      // virer zone steps vide
      clone.querySelectorAll('#steps6').forEach(s=>s.remove());

      // remplacer les <input> par des jolis "____"
      clone.querySelectorAll('input').forEach(inp=>{
        const span = document.createElement('span');
        span.style.display='inline-block';
        span.style.minWidth = (inp.style.width||'120px');
        span.style.borderBottom = '1px solid #000';
        span.style.height='1.2em';
        span.style.verticalAlign='baseline';
        inp.replaceWith(span);
      });

      enonceHTML = clone.innerHTML;
    }

    // 3. Générer la solution SI demandé
    let solBlockHTML = '';
    if (withSolutions){
      def.solution(tmpHost); // génère #res avec .steps en LaTeX
      const stepsBox = tmpHost.querySelector('#res .steps');
      if (stepsBox){
        solBlockHTML = `
          <p><b>Corrigé :</b></p>
          <div class="steps">${stepsBox.innerHTML}</div>
        `;
      }
    }

    // on restaure retypeMath pour le reste du site
    window.retypeMath = savedRetypeMath;

    // 4. Construire le HTML complet à envoyer dans l'iframe SVG
    const blockHTML = `
      <div class="exo-block">
        ${enonceHTML}
        ${solBlockHTML}
      </div>
    `;

    // 5. Iframe sandbox MathJax SVG
    const iframe = document.createElement('iframe');
    iframe.style.position='fixed';
    iframe.style.left='-10000px';
    iframe.style.top='-10000px';
    iframe.style.width='0';
    iframe.style.height='0';
    iframe.style.visibility='hidden';
    document.body.appendChild(iframe);

    const iwin = iframe.contentWindow;
    const idoc = iframe.contentDocument;

    idoc.open();
    idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
    idoc.close();

    const contentDiv = idoc.getElementById('content');
    contentDiv.innerHTML = blockHTML;

    // ⚠ IMPORTANT : ON NE TOUCHE PAS AU LATEX ICI
    // surtout pas de "replaceWith(mjx.textContent)"

    // 6. Charger MathJax SVG dans l’iframe
    const cfg = idoc.createElement('script');
    cfg.type='text/javascript';
    cfg.text = `
      window.MathJax = {
        tex: {
          inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
          displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
          processEscapes: true,
          packages: { '[+]': ['bbox','ams'] }
        },
        svg: { fontCache: 'none' },
        options: { skipHtmlTags: ['script','noscript','style','textarea'] },
        startup: { typeset: false }
      };
    `;
    idoc.head.appendChild(cfg);

          const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
          const mj = idoc.createElement('script');
          mj.type='text/javascript';
          mj.src = svgScriptURL;
          idoc.head.appendChild(mj);

    // helper attente
    async function waitMathJaxReady(win){
      const limit=200; let n=0;
      while( (!win.MathJax) ||
             (!win.MathJax.typesetPromise && !win.MathJax.typeset) ){
        await new Promise(res=>setTimeout(res,5));
        n++; if(n>limit) break;
      }
    }

    await new Promise(res=>{
      mj.onload=res;
      mj.onerror=res;
    });
    await waitMathJaxReady(iwin);

    if(iwin.MathJax && iwin.MathJax.typesetPromise){
      await iwin.MathJax.typesetPromise([contentDiv]);
    }else if(iwin.MathJax && iwin.MathJax.typeset){
      iwin.MathJax.typeset([contentDiv]);
    }

    // 7. On purge tout sauf le SVG
    contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n=>n.remove());
    contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());

    // 8. HTML final pour le PDF
    const finalHTML = contentDiv.innerHTML;

    // ménage DOM temporaire
    iframe.remove();
    tmpHost.remove();

    return finalHTML;
  })();
}

    });
  }
  }); // <-- FERMETURE addEventListener DOMContentLoaded
})(); // <-- FERMETURE IIFE global


</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d’actions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on déclenche .click() sur eux)
[['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l’original est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si présent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s’ouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>