<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1ère — Dérivation : Produit par un réel</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}

  /* tableau avec espace horizontal pour les étapes */
  .table.xgap{ border-collapse:separate; border-spacing:22px 0; }
  .table.xgap th,.table.xgap td{ border:1px solid #e5e5e5; padding:10px 14px; white-space:nowrap; }
  @media print{ .table.xgap{ border-spacing:24px 0; } }

  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .line{white-space:nowrap}
  .tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
  .tick.ok{color:#11823b}.tick.ko{color:#b00020}

  .answers{ display:flex; flex-wrap:wrap; gap:.4rem .5rem; }
  .answers .qa-row{ flex-basis:100%; display:flex; align-items:center; gap:.4rem; margin-top:.35rem; }
  .answers .qa-row label{ margin-right:.3rem; }

  @media print{ .controls{display:none !important;} }

  /* espacement lisible des lignes LaTeX */
  .steps .line{ margin:.32rem 0; line-height:1.9 }
  .steps mjx-container{ padding-bottom:.08em }

  @media print{
    .steps .line{ margin:.36rem 0; line-height:2 }
  }
</style>

<!-- MathJax (SVG, sans Assistive MathML) -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true,
    packages: { '[+]': ['bbox','ams'] },
    macros: { frac: ['\\dfrac{#1}{#2}', 2] }
  },
  options: {
    skipHtmlTags: ['script','noscript','style','textarea'],
    renderActions: { assistiveMml: [] }
  },
  startup: { typeset:true }
};
</script>
<script defer src="../../../../es5/tex-svg.js"></script>

<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem"><strong>1ère – Dérivation : Produit par un réel</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; réponses acceptées :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x²</code>…</li>
        <li>Racines : <code>sqrt(…)</code>, <code>rac(…)</code>, <code>√(…)</code>.</li>
        <li>Fractions : <code>a/b</code>. Multiplications implicites acceptées.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- Dépendances projet -->
  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
  <script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

  /* ==== Utils ==== */
  const $  = (s,r)=> (r||document).querySelector(s);
  const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
  let scoreOK=0, scoreTot=0;
  function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
  const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const choice=a=>a[Math.floor(Math.random()*a.length)];
  const UMINUS = (window.DevRules && DevRules.consts && DevRules.consts.UMINUS) || '−';
  function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

  /* ==== Normalisation / éval saisie ==== */
  function normalizeRac(s){
    s = String(s||'');

    // \sqrt{...} et \rac{...} → sqrt(...)
    s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
         .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

    // 2rac(...), )rac(...), etc.
    s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
    s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

    // variantes avec √
    s = s.replace(/(\d|\))\s*√\s*\(/g, '$1*sqrt(');
    s = s.replace(/(\d|\))\s*√\s*x\b/gi, '$1*sqrt(x)');
    s = s.replace(/√\s*\(/g,   'sqrt(')
         .replace(/√\s*x\b/gi, 'sqrt(x)');

    // ")sqrt(" -> ")*sqrt("
    s = s.replace(/\)\s*(?=sqrt\()/g, ')*');

    // cas 1/(2sqrt(...)) si étoile manquait
    s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
    return s;
  }

  function numEval(expr, x){
    if(expr==null) return NaN;
    let s = String(expr);

    // normalisations de base
    s = s.replace(/−/g,'-').replace(/[×·]/g,'*');

    // racine
    s = normalizeRac(s);

    // puissances unicode -> ^ -> **
    const SUP = {'⁰':'0','¹':'1','²':'2','³':'3','⁴':'4','⁵':'5','⁶':'6','⁷':'7','⁸':'8','⁹':'9'};
    s = s.replace(/([A-Za-z0-9\)\]])([⁰¹²³⁴⁵⁶⁷⁸⁹]+)/g,
          (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
        )
        .replace(/\^/g,'**');

    // sqrt -> Math.sqrt
    s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

    // multiplications implicites
    s = s
      .replace(/\)\s*\(/g, ')*(')
      .replace(/(\d)\s*\(/g, '$1*(')
      .replace(/(\d)\s*x/g, '$1*x')
      .replace(/\)\s*x/g, ')*x')
      .replace(/x\s*\(/g, 'x*(');

    // étoile implicite avant Math.sqrt
    s = s
      .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
      .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

    // substituer x par la valeur test
    if (typeof x === 'number') {
      s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
    }

    try { return Number(Function('"use strict";return ('+s+')')()); }
    catch { return NaN; }
  }

  function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }

  /* ==== Outils d'assemblage LaTeX & simplification ==== */
  function isZeroTex(t){ return /^\s*[+-]?\s*0\s*$/.test(String(t||'')); }
  function stripSign(s){ return String(s||'').replace(/^\s*[+]\s*/,'').trim(); }
  function joinTermsNoZero(terms){
    const kept=[];
    for(const raw of (terms||[])){
      const t=String(raw||'').trim();
      if(!t) continue;
      if(isZeroTex(t)) continue;
      kept.push(t);
    }
    if(kept.length===0) return '0';
    let out = kept[0].startsWith('-') ? kept[0] : stripSign(kept[0]);
    for(let i=1;i<kept.length;i++){
      const t=kept[i].trim();
      out += (t.startsWith('-') ? ' - ' + t.slice(1).trim()
                                : ' + ' + stripSign(t));
    }
    return out.replace(/\s+[+]\s+0\b/g,'').replace(/\s+[-]\s+0\b/g,'').trim();
  }

  function _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }

  // mets le signe devant la fraction plutôt que dans le numérateur
  function moveSignOutOfFracNum(lx){
    const re = /\\dfrac\{\s*([+-])\s*(\d+)\s*\}\{\s*(x(?:\^\{\d+\})?)\s*\}/g;
    return String(lx||'').replace(re, (_m, sign, p, den) =>
      (sign === '-' ? '-' : '') + `\\dfrac{${p}}{${den}}`
    );
  }

  // 2/(2√x) -> 1/√x etc.
  function simplifySqrtHalf(lx){
    return String(lx||'').replace(/\\dfrac\{([+-]?\d+)\}\{2\\sqrt\{x\}\}/g, (_m, nStr) => {
      const n = parseInt(nStr,10);
      if (!Number.isFinite(n) || (n % 2)) return _m;
      const m = n/2;
      if (m === 1)  return '\\dfrac{1}{\\sqrt{x}}';
      if (m === -1) return '-\\dfrac{1}{\\sqrt{x}}';
      return `\\dfrac{${m}}{\\sqrt{x}}`;
    });
  }

  // \dfrac{p}{q}x^{n} etc.
  function simplifyFracIntXOverInt(lx){
    const re = /\\dfrac\{\s*([+-]?\d+)\s*x(?:\^\{(\d+)\})?\s*\}\{\s*([+-]?\d+)\s*\}/g;
    return String(lx||'').replace(re, (_m, pStr, exp, qStr)=>{
      let p = parseInt(pStr,10), q = parseInt(qStr,10);
      if(!Number.isFinite(p) || !Number.isFinite(q) || q===0) return _m;
      const neg = (p<0) ^ (q<0);
      p = Math.abs(p); q = Math.abs(q);
      const g = _gcd(p,q); p/=g; q/=g;
      const xpow = exp ? `x^{${exp}}` : 'x';
      if(q===1){
        const c = neg ? -p : p;
        if(c=== 1)  return xpow;
        if(c===-1)  return '-'+xpow;
        return `${c}${xpow}`;
      }
      const frac = `\\dfrac{${p}}{${q}}`;
      return (neg?'-':'') + frac + xpow;
    });
  }

  // \dfrac{p}{q} (sans x derrière)
  function simplifyDfracIntInt(lx){
    const re = /\\dfrac\{\s*([+-]?\d+)\s*\}\{\s*([+-]?\d+)\s*\}(\s*x(?:\^\{\d+\})?)?/g;
    return String(lx||'').replace(re, (_m, pStr, qStr, xpart='')=>{
      let p = parseInt(pStr,10), q = parseInt(qStr,10);
      if(!Number.isFinite(p) || !Number.isFinite(q) || q===0) return _m;
      const neg = (p<0) ^ (q<0); p=Math.abs(p); q=Math.abs(q);
      const g = _gcd(p,q); p/=g; q/=g;
      const xp = (xpart||'').trim();
      if(q===1){
        const c = neg ? -p : p;
        if(!xp) return String(c);
        if(c=== 1) return xp;
        if(c===-1) return '-'+xp;
        return String(c)+xp;
      }
      const core = `\\dfrac{${p}}{${q}}`;
      return (neg?'-':'') + core + (xp? xp : '');
    });
  }

  // nettoyer +-, --, etc.
  function tidySigns(lx){
    let s = String(lx||'');
    const M='[\\-−]';
    s = s.replace(new RegExp('\\+\\s*'+M,'g'),' - ');
    s = s.replace(new RegExp(M+'\\s*'+M,'g'),' + ');
    s = s.replace(/\+\s*\+/g,' + ');
    return s.trim();
  }

  // virer "1x" / "-1x"
  function stripUnitCoeff(lx){
    let s = String(lx||'');
    s = s.replace(/(^|[+\-]\s*)1(?=x(\^\{\d+\})?)/g,'$1');
    s = s.replace(/(^|[+\-]\s*)-1(?=x(\^\{\d+\})?)/g,'$1-');
    return s;
  }

  function simplifyAll(lx){
    return tidySigns(
             stripUnitCoeff(
               simplifyDfracIntInt(
                 simplifyFracIntXOverInt(
                   simplifySqrtHalf(
                     moveSignOutOfFracNum(String(lx||''))
                   )
                 )
               )
             )
           );
  }

  /* ==== Générateur : Produit par un réel d'une fonction de référence ==== */

  // k entier ≠0
  function pickCoef(){
    const vals=[-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9];
    return choice(vals);
  }

  // formateur pour k*x^n (n>=2) et k*x (identité)
  function make_k_x_pow_n(k,n){
    // f(x)
    let fLatex;
    if(n===1){
      // kx
      if(k===1) fLatex='x';
      else if(k===-1) fLatex='-x';
      else fLatex=`${k}x`;
    }else{
      // k x^n
      const absK = Math.abs(k);
      if(absK===1){
        fLatex = (k<0?'-':'') + `x^{${n}}`;
      }else{
        fLatex = `${k}x^{${n}}`;
      }
    }

    // dérivée symbolique brute (Application)
    // d/dx [k x^n] = k*n x^{n-1}
    const kn = k*n;
    let fpRaw;
    if(n-1===0){
      // cste
      fpRaw = String(kn);
    }else if(n-1===1){
      // k*n * x
      const absKN = Math.abs(kn);
      if(absKN===1){
        fpRaw = (kn<0?'-':'')+'x';
      }else{
        fpRaw = `${kn}x`;
      }
    }else{
      // k*n x^{n-1}
      const absKN = Math.abs(kn);
      if(absKN===1){
        fpRaw = (kn<0?'-':'')+`x^{${n-1}}`;
      }else{
        fpRaw = `${kn}x^{${n-1}}`;
      }
    }

    // règle à afficher
    const rulePow = "\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}";
    const ruleProd = "\\text{Produit par un réel : } (k\\,u)'=k\\,u'";
    const ruleId   = "\\text{Si } f(x)=x \\text{ alors } f'(x)=1";

    const rules = [];
    if(n===1){
      rules.push([ruleId, ruleProd]);
    }else{
      rules.push([rulePow, ruleProd]);
    }

    return {
      title:"Exercice — Produit par un réel",
      latexF: fLatex,
      latexFp_raw: fpRaw,
      latexFp: simplifyAll(fpRaw),
      rules,
      f: x => k*Math.pow(x,n),
      fp: x => k*n*Math.pow(x,n-1)
    };
  }

  // k * sqrt(x)
  function make_k_sqrt_x(k){
    // f(x) = k√x
    let fLatex;
    if(k===1) fLatex="\\sqrt{x}";
    else if(k===-1) fLatex="-\\sqrt{x}";
    else fLatex = `${k}\\,\\sqrt{x}`;

    // dérivée brute : k * (1/(2√x)) => k/(2√x)
    const fpRaw = `\\dfrac{${k}}{2\\sqrt{x}}`;

    const ruleSqrt = "\\text{Si } f(x)=\\sqrt{x} \\text{ alors } f'(x)=\\dfrac{1}{2\\sqrt{x}}";
    const ruleProd = "\\text{Produit par un réel : } (k\\,u)'=k\\,u'";

    return {
      title:"Exercice — Produit par un réel",
      latexF: fLatex,
      latexFp_raw: fpRaw,
      latexFp: simplifyAll(fpRaw),
      rules:[[ruleSqrt, ruleProd]],
      f: x => k*Math.sqrt(x),
      fp: x => k*(1/(2*Math.sqrt(x)))
    };
  }

  // k * (1/x)
  function make_k_inv_x(k){
    // f(x)=k/x
    let fLatex;
    if(k===1) fLatex="\\dfrac{1}{x}";
    else if(k===-1) fLatex="-\\dfrac{1}{x}";
    else fLatex=`\\dfrac{${k}}{x}`;

    // dérivée brute :
    // d/dx [k * 1/x] = k * (-1/x^2) = -(k)/x^2
    // On fabrique proprement une fraction avec le signe dehors.
    const num = -k;
    const absNum = Math.abs(num);
    let fpRaw;
    if(absNum===1){
      fpRaw = (num<0)
        ? "-\\dfrac{1}{x^{2}}"
        : "\\dfrac{1}{x^{2}}";
    }else{
      fpRaw = (num<0)
        ? `-\\dfrac{${absNum}}{x^{2}}`
        : `\\dfrac{${absNum}}{x^{2}}`;
    }

    const ruleInv = "\\text{Si } f(x)=\\dfrac{1}{x} \\text{ alors } f'(x)=-\\dfrac{1}{x^{2}}";
    const ruleProd= "\\text{Produit par un réel : } (k\\,u)'=k\\,u'";

    return {
      title:"Exercice — Produit par un réel",
      latexF: fLatex,
      latexFp_raw: fpRaw,
      latexFp: simplifyAll(fpRaw),
      rules:[[ruleInv, ruleProd]],
      f: x => k*(1/x),
      fp: x => k*(-1/(x*x))
    };
  }

  function genProduitReel(){
    // Choix du type de fonction de référence
    // 0 : k*x^n (n>=2)
    // 1 : k*x (identité)
    // 2 : k*sqrt(x)
    // 3 : k*(1/x)
    const which = choice([0,1,2,3]);
    const k = pickCoef();

    if(which===0){
      const n = rnd(2,5); // x^2, x^3, x^4, x^5
      return make_k_x_pow_n(k,n);
    }
    if(which===1){
      return make_k_x_pow_n(k,1); // identité
    }
    if(which===2){
      return make_k_sqrt_x(k);
    }
    return make_k_inv_x(k); // which===3
  }

  /* ==== Affichage / Vérification / Solution ==== */

  function buildHostHTML(st){
    const fClean = joinTermsNoZero([st.latexF]);
    return `
      <div class="card">
        <div><strong>Exercice :</strong> Soit la fonction \\(f\\) définie par : \\(f(x)=${fClean}\\). <br>Donner sa fonction dérivée définie par :</div>
        <div class="answers">
          <div class="qa-row">
            <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
            <input id="ansF" class="inp" style="min-width:360px">
            <span id="tickF" class="tick" style="margin-left:6px"></span>
          </div>
        </div>
      </div>
      <div id="res"></div>
    `;
  }

  function setTick(host, ok){
    const el = $('#tickF', host);
    if(!el) return;
    el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
    el.textContent = ok===true?'✓': ok===false?'✗':'—';
  }

  function checkAnswer(st, val){
    if(!val || !String(val).trim()) return null;
    if(typeof st?.fp !== 'function') return false;
    const xs = [1.2, 1.8, 2.5, 3.7, 5.1];
    try{
      for(const x of xs){
        const got = numEval(val, x);
        const ref = st.fp(x);
        if(!Number.isFinite(got) || !Number.isFinite(ref) || !almost(got, ref, 1e-6)) return false;
      }
      return true;
    }catch(_){ return false; }
  }

  function solutionHTML(st){
    const rows = [];
    const seen = new Set();

    (st.rules||[]).forEach(pair=>{
      const rule = pair[0]||'';
      if(rule && !seen.has(rule)) {
        rows.push(`<tr><td><em>Règle</em></td><td>\\(${rule}\\)</td></tr>`);
        seen.add(rule);
      }
    });

    // On ajoute toujours la règle produit par un réel si elle est dans pair[1]
    (st.rules||[]).forEach(pair=>{
      const rule2 = pair[1]||'';
      if(rule2 && !seen.has(rule2)) {
        rows.push(`<tr><td><em>Règle</em></td><td>\\(${rule2}\\)</td></tr>`);
        seen.add(rule2);
      }
    });

    const fpRaw  = st.latexFp_raw || st.latexFp || '';
    const fpSimp = simplifyAll(fpRaw);

    // Application brute
    rows.push(`<tr><td><em>Application</em></td><td>\\(f'(x) = ${fpRaw}\\)</td></tr>`);

    // Ligne simplification seulement si ça change vraiment
    const showSimp = tidySigns(fpRaw) !== tidySigns(fpSimp);
    if (showSimp){
      rows.push(`<tr><td><em>Simplification</em></td><td>\\(f'(x) = ${fpSimp}\\)</td></tr>`);
    }

    return `
      <div class="steps">
        <table class="table xgap">
          <thead>
            <tr><th style="text-align:center">Justification</th><th style="text-align:center">Écriture</th></tr>
          </thead>
          <tbody>${rows.join('')}</tbody>
        </table><br>
        <div class="line"><strong>Conclusion :</strong> \\(\\;f'(x) = ${fpSimp}\\).</div>
      </div>
    `;
  }

  /* ==== Définition unique de l'exercice ==== */

  const EXO_PROD = {
    id:'prod-reel',
    title:'Produit par un réel',
    gen(host){
      const st = genProduitReel();
      host.innerHTML = buildHostHTML(st);

      // garder l'état riche pour Vérifier
      host.__state = st;

      // sauvegarde "light" POUR LE PDF (⚠ inclure latexFp_raw !)
      host.dataset.state = JSON.stringify({
        latexF:      st.latexF,
        latexFp:     st.latexFp,
        latexFp_raw: st.latexFp_raw,
        rules:       st.rules || []
      });

      if (window.MathJax?.typeset) MathJax.typeset();
    },
    correct(host, st){
      const val=$('#ansF',host)?.value||'';
      const ok=checkAnswer(st,val);
      scoreTot+= (val.trim()?1:0);
      scoreOK+= (ok?1:0);
      updateScore();
      setTick(host, val.trim()?ok:null);
    },
    solution(host, st){
      $('#res',host).innerHTML = solutionHTML(st);
      if (window.MathJax?.typeset) MathJax.typeset();
    },
    reset(host){
      $('#res',host).textContent='';
      setTick(host,null);
    }
  };

  const REG = [EXO_PROD];
  window.REG=REG;
  window.REGISTRY=REG;

  /* ==== Montage UI ==== */
  function mount(){
    const sel=$("#exo-select"); if(!sel) return;
    sel.innerHTML=REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

    function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
    function newOne(){ const ex=get(); const host=$("#host"); ex.gen(host); scanFractions(host); }
    function check(){ const ex=get(); const host=$("#host"); ex.correct(host, host.__state); }
    function sol(){ const ex=get(); const host=$("#host"); ex.solution(host, host.__state); }
    function reset(){ const ex=get(); const host=$("#host"); ex.reset(host); }

    sel.onchange=newOne;
    $("#btn-new").onclick=newOne;
    $("#btn-check").onclick=check;
    $("#btn-solution").onclick=sol;
    $("#btn-reset").onclick=reset;
    document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

    sel.value=REG[0].id;
    newOne();
  }
  document.addEventListener('DOMContentLoaded', mount);
</script>

<!-- === Adaptateur PDF === -->
<script>
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(def, _st, ctx){
        const host = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(host);
        let st = {};
        try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
        return st;
      },
      beforeRender(def, st, withSolutions){
        try{
          const host = document.createElement('div');
          host.id = 'pdf-host';
          host.style.position='fixed'; host.style.left='-10000px'; host.style.top='-10000px';
          document.body.appendChild(host);

          host.innerHTML = (typeof window.buildHostHTML === 'function') ? buildHostHTML(st) : '';
          host.dataset.state = JSON.stringify(st);

          if (withSolutions && def && typeof def.solution === 'function'){
            def.solution(host, st); // va utiliser latexFp_raw -> donc "Simplification" réapparaît si besoin
          }

          // remplace les inputs par du texte dans la sortie PDF
          (host.querySelectorAll('input, textarea, select, [contenteditable="true"]')||[])
            .forEach(el=>{
              const t = document.createTextNode(el.value||' ');
              el.replaceWith(t);
            });

          const outHTML = withSolutions
            ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
            : host.innerHTML;

          document.body.removeChild(host);
          return outHTML;
        }catch(e){
          console.error('PDF beforeRender error:', e);
          return null;
        }
      }
    });
  });
})();
</script>

<!-- === SHIM universel (inchangé) === -->
<script>
(function(){
  function isHost(x){ return x && x.nodeType===1; }
  function scaffold(host){
    if(!host) return;
    ['enonce','res','solution','statement'].forEach(function(id){
      if(!host.querySelector('#'+id)){
        var d=document.createElement('div');
        d.id=id;
        host.appendChild(d);
      }
    });
  }
  function wrapDef(def){
    if(!def || typeof def!=='object') return;

    // Wrap gen
    var oldGen = def.gen;
    if(typeof oldGen==='function'){
      def.gen = function(a,b){
        if(isHost(a)) return oldGen.call(this, a, b);
        var st = (a && typeof a==='object') ? a : (b && typeof b==='object' ? b : {});
        var host = document.createElement('div');
        scaffold(host);
        var r = oldGen.call(this, host, st);
        if(!host.dataset.state) try{ host.dataset.state = JSON.stringify(st||{}); }catch(_){}
        return host;
      };
      if(typeof def.render!=='function'){
        def.render = function(host, st){ scaffold(host); return oldGen.call(this, host, st); };
      }
    }

    var oldSol = def.solution;
    if(typeof oldSol==='function'){
      def.solution = function(a,b){
        if(isHost(a)) return oldSol.call(this, a, b);
        var st = (a && typeof a==='object') ? a : (b && typeof b==='object' ? b : {});
        var host = document.createElement('div');
        scaffold(host);
        return oldSol.call(this, host, st);
      };
    }
  }

  function apply(){
    var list = (window.REGISTRY || window.REG || []);
    if(Array.isArray(list)) list.forEach(wrapDef);
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', apply); else apply();
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
