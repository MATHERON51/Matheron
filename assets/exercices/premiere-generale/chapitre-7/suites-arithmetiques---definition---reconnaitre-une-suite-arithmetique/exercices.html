<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1Ã¨re - Suites arithmÃ©tiques - DÃ©finition - ReconnaÃ®tre une suite arithmÃ©tique (formule de rÃ©currence) </title>

<!-- mÃªmes feuilles que ton modÃ¨le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles Ã  lâ€™Ã©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de rÃ©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}

.tbl-suites{
  border-collapse:collapse;
  border:1px solid #ccc;
}
.tbl-suites th,
.tbl-suites td{
  border:1px solid #ccc;
  padding:4px 6px;
}


ul.no-bullet{
  list-style:none;
  padding-left:0;
  margin-left:0;
}


</style>

<!-- MathJax comme dans ton modÃ¨le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- mÃªmes libs partagÃ©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1Ã¨re - Suites arithmÃ©tiques - DÃ©finition - ReconnaÃ®tre une suite arithmÃ©tique (formule de rÃ©currence)</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contrÃ´le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-sol" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- HÃ´te dâ€™exercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & rÃ©ponses acceptÃ©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & rÃ©ponses acceptÃ©es :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> acceptÃ©es
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenthÃ¨ses/accolades, soulignÃ©s, <code>*</code> ou <code>Ã—</code> sont normalisÃ©s).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = 'âˆ’';

/* ===== Utilitaires gÃ©nÃ©riques (mÃªmes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tolÃ¨re u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, Ã—, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/Ã—|\*/g,'');
  s = s.replace(/[âˆ’â€“â€”]/g,'-');

  // normaliser les Ã©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'âœ“':'âœ—'; }
// âœ“ / âœ— / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='âœ“'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='âœ—'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] â†’ an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "âˆ’" collÃ©s
  let s = parts.join(' + ').replace(/\+\s*âˆ’/g, UMINUS).replace(/âˆ’\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/âˆ’ en LaTeX
  s = s.replace(/\+/g,'+').replace(/âˆ’/g, UMINUS);
  return s || '0';
}

function makeExos(){
  const L = [];


/* === Ex. 1 â€” Suite arithmÃ©tique (u0 et r) === */
L.push({
  id: 'ex1_suite_arith',
  title: "Ex. 1 â€” Suite arithmÃ©tique (u_0 et raison r)",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){ if(d===0) return {n:NaN,d:0}; if(d<0){n=-n;d=-d;} const g=this._gcd(n,d); return {n:n/g,d:d/g}; },
  _fracTex(n,d){
    if(d===0){ return '\\text{indÃ©fini}'; }
    const s = this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,'âˆ’');
    const sign = s.n<0 ? 'âˆ’' : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _signText(r){
    if(r>0) return 'croissante';
    if(r<0) return 'dÃ©croissante';
    return 'constante';
  },
  _parseSens(raw){
    if(!raw) return null;
    let s = String(raw).toLowerCase().trim();
    // on enlÃ¨ve les accents
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;

    // c... â†’ croissante
    if(s[0] === 'c') return 'croissante';

    // d... â†’ dÃ©croissante
    if(s[0] === 'd') return 'dÃ©croissante';

    // "const", "constante", etc.
    if(s.includes('const')) return 'constante';

    return null;
  },

  _evalFormulaOk(input, cas){
    if(!input) return null;

    // On rÃ©cupÃ¨re uniquement le membre de droite (aprÃ¨s =), sinon tout.
    let norm = normRelation(input);
    let rhs = norm.includes('=') ? norm.split('=')[1] : norm;
    if(!rhs) return false;

    // Remplacements symboliques â†’ numÃ©riques
    rhs = rhs
      .replace(/[âˆ’â€“â€”]/g,'-')
      .replace(/\\cdot/g,'*')
      .replace(/[Ã—Â·]/g,'*');

    // u_0 / u0 / u0 avec accolades
    rhs = rhs.replace(/u_\{?0\}?/g, `(${cas.u0})`)
             .replace(/u0/g, `(${cas.u0})`);

    // r Ã©ventuel
    rhs = rhs.replace(/\br\b/g, `(${cas.r})`);

    // gÃ©rer "4n" ou "-3n"
    rhs = rhs.replace(/(\d)n/g, '$1*n');
    // (rare) "n4"
    rhs = rhs.replace(/n(\d)/g, 'n*$1');

    // puissance
    rhs = rhs.replace(/\^/g,'**');

    // variable n
    // (on laisse "n" tel quel, la fonction JS l'utilisera)

    // sÃ©curitÃ© grossiÃ¨re : uniquement caractÃ¨res autorisÃ©s
    if(/[^0-9n()+\-*/.,]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => cas.u0 + n*cas.r;
    const tests = [0,1,2,5];
    try{
      for(const n of tests){
        const v = Number(f(n));
        if(!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },

  _evalRecurrenceOk(input, cas){
    if (!input) return null;

    // 1) normalisation souple : u(n+1), u_(n+1) â†’ u_{n+1}, etc.
    let s = normRelation(input);

    // On ne garde que le membre de droite aprÃ¨s le dernier "="
    const parts = s.split('=');
    let rhs = parts[parts.length - 1];
    if (!rhs) return false;

    // 2) Nettoyage des signes / produits
    rhs = rhs
      .replace(/[âˆ’â€“â€”]/g, '-')      // tous les "gros moins" â†’ "-"
      .replace(/\\cdot/g, '*')
      .replace(/[Ã—Â·]/g, '*');

    // 3) Remplacement de u_n par u0 + n*r
    //    (sans espaces pour ne pas gÃªner le filtre plus bas)
    const uExpr = `(${cas.u0}+n*${cas.r})`;
    rhs = rhs.replace(/u_\{?n\}?/g, uExpr);  // u_n, u_{n}

    // 4) Au cas oÃ¹ : u0 et r Ã©crits explicitement
    rhs = rhs
      .replace(/u0/g, `(${cas.u0})`)
      .replace(/\br\b/g, `(${cas.r})`);

    // 5) GÃ©rer "4n" ou "n4"
    rhs = rhs.replace(/(\d)n/g, '$1*n');
    rhs = rhs.replace(/n(\d)/g, 'n*$1');

    // 6) Puissances "^" â†’ "**"
    rhs = rhs.replace(/\^/g, '**');

    // 7) Supprimer tous les espaces Ã©ventuels (y compris ceux ajoutÃ©s par nous)
    rhs = rhs.replace(/\s+/g, '');

    // 8) SÃ©curitÃ© : uniquement chiffres, n, (), + - * / . , autorisÃ©s
    if (/[^0-9n()+\-*/.,]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    // 9) Valeur attendue : u_{n+1} = u0 + (n+1)r
    const expected = n => cas.u0 + (n+1)*cas.r;
    const tests = [0, 1, 2, 5];

    try{
      for (const n of tests){
        const v = Number(f(n));
        if (!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },




   gen(){
    const N = 25; // u_25

    const buildCase = (u0, num, den)=>{
      const r   = num / den;
      const u1  = u0 + r;
      const u2  = u0 + 2*r;
      const uN  = u0 + N*r;
      const sens = this._signText(r);
      const rTex = this._fracTex(num, den);

      // forme explicite TeX
      let coefN;
      if(den===1){
        if(num===1)       coefN = 'n';
        else if(num===-1) coefN = 'âˆ’n';
        else              coefN = `${num}n`.replace(/-/g,'âˆ’');
      }else{
        coefN = `${this._fracTex(num,den)}\\,n`;
      }
      const explTeX =
        `u_n = ${String(u0).replace(/-/g,'âˆ’')}` +
        (r===0 ? '' : (r>0 ? ' + ' : ' âˆ’ ') + (r>0 ? coefN : coefN.replace(/^âˆ’/,'') ));

      return {
        u0, r, num, den,
        rTex,
        u1, u2, uN,
        N,
        sens,
        explTeX
      };
    };

    const cases = [];

    // 1) u0 > 0, r entier > 0
    cases.push(
      buildCase(
        rint(1,10),     // u0 > 0
        rint(1,8),      // r > 0
        1               // entier
      )
    );

    // 2) u0 < 0, r entier > 0
    cases.push(
      buildCase(
        rint(-10,-1),   // u0 < 0
        rint(1,8),      // r > 0
        1
      )
    );

    // 3) u0 > 0, r entier < 0
    cases.push(
      buildCase(
        rint(1,10),     // u0 > 0
        rint(-8,-1),    // r < 0
        1
      )
    );

    // 4) u0 > 0, r fraction (Â± /2)
    cases.push(
      buildCase(
        rint(1,10),                   // u0 > 0
        choice([-5,-3,-1,1,3,5]),     // num fractionnaire, Â±
        2                             // /2
      )
    );

    // MÃ©lange alÃ©atoire de l'ordre des cas (Fisherâ€“Yates)
    for(let i = cases.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [cases[i], cases[j]] = [cases[j], cases[i]];
    }

    return { cases };
  },



  render(host, s){
    host.__state = s;

const listItems = s.cases.map((c,idx)=>{
  const k = idx+1;
  return `\\(${k}.\\ u_0 = ${String(c.u0).replace(/-/g,'âˆ’')}\\ \\text{ et }\\ r = ${c.rTex}\\quad\\)`;
}).join(' ');


    // lignes dâ€™inputs
    const rowsHtml = s.cases.map((c,idx)=>{
      const k = idx+1;
      return `
        <tr>
          <td>\\(${k}.\\)</td>
          <td>\\(u_1=\\) ${mkInput('a'+k+'1',80)} <span id="ta${k}1" class="tick"></span></td>
          <td>\\(u_2=\\) ${mkInput('a'+k+'2',80)} <span id="ta${k}2" class="tick"></span></td>
          <td>${mkInput('b'+k,170)} <span id="tb${k}" class="tick"></span></td>

        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(r\\) dâ€™une suite arithmÃ©tique.</p>
          <p>${listItems}</p>

   <p>Pour chacun des cas :</p>
<ul class="no-bullet">
  <li>a) DÃ©terminer \\(u_1\\) et \\(u_2\\).</li>
  <li>b) Exprimer \\(u_{n+1}\\) en fonction de \\(u_n\\).</li>

</ul>


          <table style="border-collapse:collapse;width:50%;font-size:.95rem">
            <thead>
              <tr>
                <th></th>
                <th>a) \\(u_1\\)</th>
                <th>a) \\(u_2\\)</th>
                <th>b) \\(u_{n+1}\\) en fonction de \\(u_n\\)</th>

              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>

          <div class="equ-offscreen" style="display:none">
            <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(r\\) dâ€™une suite arithmÃ©tique.</p>
            <p>${listItems}</p>
<p>Pour chacun des cas :</p>
<ul class="no-bullet">
  <li>a) DÃ©terminer \\(u_1\\) et \\(u_2\\).</li>
  <li>b) Exprimer \\(u_{n+1}\\) en fonction de \\(u_n\\).</li>

</ul>

          </div>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    // Enter â†’ VÃ©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.cases.forEach((cas,idx)=>{
      const k = idx+1;

      const v11 = val('a'+k+'1').trim();
      const v12 = val('a'+k+'2').trim();
      const vb  = val('b'+k).trim();
      const vc  = val('c'+k).trim();
      const vd  = val('d'+k).trim();
      const ve  = val('e'+k).trim();

      if(!v11 || !v12 || !vb || !vc || !vd || !ve) allFilled = false;

      const ok11 = v11==='' ? null : near(parseNumber(v11), cas.u1);
      const ok12 = v12==='' ? null : near(parseNumber(v12), cas.u2);

      const okb  = vb==='' ? null : this._evalRecurrenceOk(vb, cas);


      const okc  = this._evalFormulaOk(vc, cas);

      const okd  = vd==='' ? null : near(parseNumber(vd), cas.uN);

      const sensUser = this._parseSens(ve);
      const oke = ve==='' ? null : (sensUser === cas.sens);

      tickTri($('#ta'+k+'1',host), ok11);
      tickTri($('#ta'+k+'2',host), ok12);
      tickTri($('#tb'+k,host),    okb);
      tickTri($('#tc'+k,host),    okc);
      tickTri($('#td'+k,host),    okd);
      tickTri($('#te'+k,host),    oke);

      if(ok11===false || ok12===false || okb===false || okc===false || okd===false || oke===false){
        allOk = false;
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

    solution(host){
    const s = host.__state;
    const W = $('#steps', host);
    const UMINUS = 'âˆ’';

    const texInt = x => String(x).replace(/-/g, UMINUS);

    const html = `
      <ol style="padding-left:1.2rem;margin:0">
        ${s.cases.map((cas, idx) => {
          const N    = cas.N;      // ici 25
          const u0T  = texInt(cas.u0);
          const u1T  = texInt(cas.u1);
          const u2T  = texInt(cas.u2);

          const isFrac   = cas.den !== 1;
          const rAbsTex  = this._fracTex(Math.abs(cas.num), cas.den); // r sans signe
          const rTexSign = this._fracTex(cas.num, cas.den);           // r avec signe
          const signR    = cas.r >= 0 ? '+' : 'âˆ’';

          /* ====== a) u1 et u2 ====== */

          let partAHtml;

          if (!isFrac){
            // --- CAS r ENTIER : prÃ©sentation simple comme avant ---
            let plusR_a = '';
            if (cas.r > 0)      plusR_a = ` + ${rAbsTex}`;
            else if (cas.r < 0) plusR_a = ` âˆ’ ${rAbsTex}`;

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = u_0 ${plusR_a}\\)<br>
                      \\(u_1 = ${u0T}${plusR_a}\\)<br>
                      \\(u_1 = ${u1T}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = u_1 ${plusR_a}\\)<br>
                      \\(u_2 = ${u1T}${plusR_a}\\)<br>
                      \\(u_2 = ${u2T}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          } else {
            // --- CAS r FRACTION : tout en fraction, pas de dÃ©cimales ---

            // Pour u1 : u1 = u0 + num/den = (u0*den + num)/den
            const u1RawNum = cas.u0 * cas.den + cas.num;
            const u1FracTex = this._fracTex(u1RawNum, cas.den);

            // Pour u2 : u2 = u0 + 2*num/den
            const u2RawNum = cas.u0 * cas.den + 2*cas.num;
            const u2FracTex = this._fracTex(u2RawNum, cas.den);

            const u0FracNum = cas.u0 * cas.den; // numÃ©rateur de u0 avec dÃ©nominateur commun

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = u_0 ${signR} ${rAbsTex}\\)<br>
                      \\(u_1 = ${u0T} ${signR} ${rAbsTex}\\)<br>
                      \\(u_1 = \\dfrac{${u0FracNum}}{${cas.den}} ${signR} \\dfrac{${Math.abs(cas.num)}}{${cas.den}}\\)<br>
                      \\(u_1 = ${u1FracTex}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = u_1 ${signR} ${rAbsTex}\\)<br>
                      \\(u_2 = ${u1FracTex} ${signR} ${rAbsTex}\\)<br>
                      \\(u_2 = \\dfrac{${u2RawNum}}{${cas.den}}\\)<br>
					  \\(u_2 = ${u2FracTex}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          }

          /* ====== b) rÃ©currence ====== */

          let recLine;
          if (cas.r > 0)      recLine = `u_{n+1} = u_n + ${rAbsTex}`;
          else if (cas.r < 0) recLine = `u_{n+1} = u_n âˆ’ ${rAbsTex}`;
          else                recLine = `u_{n+1} = u_n`;

          

          return `
            <li style="margin-bottom:.6rem">
              <div class="steps">
                ${partAHtml}

                <div class="step" style="margin-top:.35rem">
                  <strong>b.</strong> Pour tout entier naturel \\(n\\), on a :
                  \\(${recLine}\\).
                </div>

               
              </div>
            </li>`;
        }).join('')}
      </ol>
    `;

    W.innerHTML = html;
    retypeMath(W);


  }

});






/* === Ex. 2 â€” Suites rÃ©currentes : arithmÃ©tiques ou non ? (2 suites) === */
L.push({
  id: 'ex2_suite_recurrente',
  title: "Ex. 2 â€” Suites rÃ©currentes : arithmÃ©tiques ou non ?",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; },
  _simp(n,d){
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    const UMINUS='âˆ’';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _parseOuiNon(str){
    if(!str) return null;
    let s = String(str).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='o' || s[0]==='y') return true;   // oui / yes
    if(s[0]==='n') return false;                // non
    return null;
  },

  gen(){
    const UMINUS='âˆ’';
    const texInt = x => String(x).replace(/-/g,UMINUS);

    // --- 1) suite arithmÃ©tique : u_{n+1} = u_n + r avec r â‰  0 ---
    const makeArith = ()=>{
      let u0 = 0;
      while(u0===0) u0 = rint(-5,5);

      // r entier ou fraction, NON nul
      const kind = choice(['int','frac']);
      let num, den;
      if(kind==='int'){
        num = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
        den = 1;
      }else{
        den = choice([2,3,4]);
        num = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      }
      const simp = this._simp(num,den);
      num = simp.n; den = simp.d;
      const r = num/den;
      if(r===0) return makeArith(); // sÃ©curitÃ©

      const rAbsTex = this._fracTex(Math.abs(num),den).replace(/^âˆ’/,'');
      const rTex    = this._fracTex(num,den);

      let rec;
      if(num>0){
        rec = `u_{n+1} = u_n + ${rAbsTex}`;
      }else{
        rec = `u_{n+1} = u_n âˆ’ ${rAbsTex}`;
      }

      const sys = `\\left\\{\\begin{array}{l}
u_0 = ${texInt(u0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;

      return {
        name:'u',
        kind:'arith',
        isArith:true,
        u0,
        r,
        rNum:num,
        rDen:den,
        tex:sys
      };
    };

    // --- 2a) suite gÃ©omÃ©trique : v_{n+1} = q v_n avec q â‰  1 ---
    const makeGeom = ()=>{
      let v0 = 0;
      while(v0===0) v0 = rint(-5,5);

      let num, den;
      const kind = choice(['int','frac']);
      if(kind==='int'){
        // q entier, â‰ 0, â‰ 1
        num = choice([-4,-3,-2,2,3,4]); // pas 0, pas 1
        den = 1;
      }else{
        den = choice([2,3,4]);
        num = choice([-5,-4,-3,-2,2,3,4,5]); // pas 0
        // Ã©viter q = Â±1 : |num| â‰  den
        if(Math.abs(num)===den) return makeGeom();
      }
      const simp = this._simp(num,den);
      num = simp.n; den = simp.d;
      const q = num/den;

      const qTex = this._fracTex(num,den);
      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${texInt(v0)}\\\\[2pt]
v_{n+1} = ${qTex}v_n
\\end{array}\\right.`;

      return {
        name:'v',
        kind:'geom',
        isArith:false,
        v0,
        q,
        tex:sys
      };
    };

    // --- 2b) suite arithmÃ©tico-gÃ©omÃ©trique : v_{n+1} = a v_n + b (aâ‰ 1, bâ‰ 0) ---
    const makeArithGeo = ()=>{
      let v0 = 0;
      while(v0===0) v0 = rint(-5,5);

      let a = choice([-4,-3,-2,2,3,4]); // a â‰  0,1
      let b = 0;
      while(b===0) b = rint(-5,5);

      const texInt2 = x => String(x).replace(/-/g,UMINUS);

      let aTex;
      if(a===1)      aTex = '';
      else if(a===-1)aTex = 'âˆ’';
      else           aTex = texInt2(a);

      let bTex;
      if(b>0) bTex = ' + ' + texInt2(b);
      else    bTex = ' âˆ’ ' + texInt2(Math.abs(b));

      const rec = (Math.abs(a)===1)
        ? `v_{n+1} = ${a===1?'': 'âˆ’'}v_n${bTex}`
        : `v_{n+1} = ${aTex}v_n${bTex}`;

      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${texInt2(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;

      return {
        name:'v',
        kind:'arithgeo',
        isArith:false,
        v0,a,b,
        tex:sys
      };
    };

    // --- 2c) suite v_{n+1} = v_n + affine(n) avec coefficient de n non nul ---
      // --- 2c) suite v_{n+1} = v_n + affine(n) avec coefficient de n non nul ---
    const makeVPlusAffine = ()=>{
      let v0 = 0;
      while(v0===0) v0 = rint(-5,5);

      let alpha = 0;
      while(alpha===0) alpha = choice([-3,-2,-1,1,2,3]);
      let beta = rint(-5,5);

      const texInt2 = x => String(x).replace(/-/g,UMINUS);

      const absA  = Math.abs(alpha);
      const aCore = (absA===1) ? 'n' : `${absA}n`;

      let bPart = '';
      if(beta>0)      bPart = ' + ' + texInt2(beta);
      else if(beta<0) bPart = ' âˆ’ ' + texInt2(Math.abs(beta));

      // â–º plus de parenthÃ¨ses et pas de "+ -" :
      //    si alpha>0 :  v_{n+1} = v_n + 2n + 5
      //    si alpha<0 :  v_{n+1} = v_n âˆ’ 3n âˆ’ 4
      let rec;
      if(alpha > 0){
        rec = `v_{n+1} = v_n + ${aCore}${bPart}`;
      }else{
        rec = `v_{n+1} = v_n âˆ’ ${aCore}${bPart}`;
      }

      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${texInt2(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;

      return {
        name:'v',
        kind:'u_plus_affine',
        isArith:false,
        v0,alpha,beta,
        tex:sys
      };
    };


    // suite arithmÃ©tique (pour lâ€™une des deux)
       // suite arithmÃ©tique (pour lâ€™une des deux)
    const arith = makeArith.call(this);

    // suite non arithmÃ©tique : au hasard parmi les trois types
    const nonFactories = [makeGeom, makeArithGeo, makeVPlusAffine];
    const non = choice(nonFactories).call(this);

    // â–º On mÃ©lange seulement lâ€™ORDRE (a) / (b),
    //   mais on garde les lettres de suite :
    //   (u_n) reste (u_n), (v_n) reste (v_n)
    let seqs;
    if(Math.random() < 0.5){
      seqs = [
        { letter:'a', ...arith },
        { letter:'b', ...non   }
      ];
    }else{
      seqs = [
        { letter:'a', ...non   },
        { letter:'b', ...arith }
      ];
    }

    return { seqs };
  },


  render(host,s){
    host.__state = s;

    const rows = s.seqs.map((seq,i)=>{
      const k = i+1;
      const label = (seq.name==='u') ? '\\((u_n)\\)' : '\\((v_n)\\)';
      return `
        <tr>
          <td>${seq.letter}.</td>
          <td>\\(${seq.tex}\\)</td>
          <td>${mkInput('q'+k,90)} <span id="tq${k}" class="tick"></span></td>
          <td>${mkInput('r_'+k,80)} <span id="tr_${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Les suites \\((u_n)\\) et \\((v_n)\\) sont dÃ©finies sur \\(\\mathbb{N}\\) par les relations de rÃ©currence suivantes.
          </p>
          <p>
            Pour chacune dâ€™elles, prÃ©ciser sâ€™il sâ€™agit dâ€™une <strong>suite arithmÃ©tique</strong> et, le cas Ã©chÃ©ant,
            indiquer sa raison.
          </p>

          <table class="tbl-suites" style="width:100%;font-size:.95rem;margin-top:.4rem">
            <thead>
              <tr>
                <th></th>
                <th>DÃ©finition rÃ©currente</th>
                <th>Suite arithmÃ©tique ?<br><span style="font-size:.85em">(Ã©crire Â« oui Â» ou Â« non Â»)</span></th>
                <th>Si oui, raison \\(r\\)</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.seqs.forEach((seq,i)=>{
      const k = i+1;
      const ynStr = val('q'+k);
      const rStr  = val('r_'+k);

      const tYN = $('#tq'+k,host);
      const tR  = $('#tr_'+k,host);

      const yn = this._parseOuiNon(ynStr);

      if(yn===null){
        allFilled = false;
        tickTri(tYN,null);
      }else{
        const okYN = (yn === seq.isArith);
        tickTri(tYN, okYN);
        if(okYN===false) allOk=false;
      }

      if(seq.isArith){
        if(!rStr) allFilled = false;
        const okR = rStr==='' ? null : near(parseNumber(rStr), seq.r);
        tickTri(tR, okR);
        if(okR===false) allOk=false;
      }else{
        // non arithmÃ©tique : la case raison doit rester vide
        if(rStr){
          tickTri(tR,false);
          allOk=false;
        }else{
          tickTri(tR,null);
        }
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

       solution(host){
    const s = host.__state;
    const W = $('#steps',host);
    const UMINUS = 'âˆ’';

    const texInt = x => String(x).replace(/-/g, UMINUS);

    // ===== helpers fractions (en s'appuyant sur _simp et _fracTex) =====
    const simp    = (n,d) => this._simp(n,d);
    const fracTex = (n,d) => this._fracTex(n,d);

    const fInt  = n     => ({ n, d:1 });
    const fFrac = (n,d) => simp(n,d);
    const fAdd  = (A,B) => simp(A.n*B.d + B.n*A.d, A.d*B.d);
    const fSub  = (A,B) => simp(A.n*B.d - B.n*A.d, A.d*B.d);
    const fMul  = (A,B) => simp(A.n*B.n, A.d*B.d);
    const fTex  = F     => fracTex(F.n, F.d);

    const approxFrac = (x)=>{
      const maxD = 10;
      for(let d=1; d<=maxD; d++){
        const n = Math.round(x*d);
        if(Math.abs(n/d - x) < 1e-9) return fFrac(n,d);
      }
      return fInt(Math.round(x));
    };

    const parenIfNegTex = F => F.n < 0 ? `(${fTex(F)})` : fTex(F);

    const items = s.seqs.map(seq => {
      const label = seq.letter + ')';
      const name  = seq.name;   // "u" ou "v"

      /* ========== 1) CAS SUITE ARITHMÃ‰TIQUE ========== */
      if (seq.isArith){
        const u0F   = fInt(seq.u0);
        const rF    = fFrac(seq.rNum, seq.rDen); // on garde la VRAIE fraction
        const u0Tex = fTex(u0F);
        const rTex  = fTex(rF);

        const rAbsF   = fFrac(Math.abs(rF.n), rF.d);
        const rAbsTex = fTex(rAbsF);

        let recExplain;
        if (rF.n > 0){
          recExplain = `${name}_{n+1} = ${name}_n + ${rAbsTex}`;
        } else if (rF.n < 0){
          recExplain = `${name}_{n+1} = ${name}_n âˆ’ ${rAbsTex}`;
        } else {
          recExplain = `${name}_{n+1} = ${name}_n`;
        }

        return `
          <li style="margin-bottom:.6rem">
            <div class="steps">
              <div class="step">
                <strong>${label}</strong> \\(${seq.tex}\\)
              </div>

              <div class="step" style="margin-top:.35rem">
                Pour tout entier naturel \\(n\\), on a : \\(${recExplain}\\).
              </div>

              <div class="step">
                Pour passer dâ€™un terme au suivant, on ajoute toujours \\(${rTex}\\).
              </div>

              <div class="step">
                Ainsi la suite \\((${name}_n)\\) est une suite arithmÃ©tique
                de raison \\(r = ${rTex}\\) (et de premier terme \\(${name}_0 = ${u0Tex}\\)).
              </div>
            </div>
          </li>`;
      }

      /* ========== 2) CAS SUITE NON ARITHMÃ‰TIQUE ========== */
      // On calcule 3 termes EN FRACTION + dÃ©tail des calculs de ${name}_1 et ${name}_2

      let u0F;
      if (typeof seq.u0 === 'number')       u0F = fInt(seq.u0);
      else if (typeof seq.v0 === 'number')  u0F = fInt(seq.v0);
      else                                  u0F = fInt(0);

      let u1F, u2F;
      let calc1Lines = [];   // lignes pour ${name}_1
      let calc2Lines = [];   // lignes pour ${name}_2

      /* ---- a) Suite gÃ©omÃ©trique : v_{n+1} = q v_n ---- */
      if (seq.kind === 'geom'){
        const qF   = approxFrac(seq.q);
        const qTex = fTex(qF);

        u1F = fMul(qF, u0F);
        calc1Lines = [
          `\\(${name}_1 = ${qTex}${name}_0\\)`,
          `\\(${name}_1 = ${qTex}\\times ${parenIfNegTex(u0F)}\\)`,
          `\\(${name}_1 = ${fTex(u1F)}\\)`
        ];

        u2F = fMul(qF, u1F);
        calc2Lines = [
          `\\(${name}_2 = ${qTex}${name}_1\\)`,
          `\\(${name}_2 = ${qTex}\\times ${parenIfNegTex(u1F)}\\)`,
          `\\(${name}_2 = ${fTex(u2F)}\\)`
        ];
      }

      /* ---- b) Suite arithmÃ©tico-gÃ©omÃ©trique : v_{n+1} = a v_n + b ---- */
      else if (seq.kind === 'arithgeo'){
        const aF   = fInt(seq.a);
        const bF   = fInt(seq.b);
        const aTex = fTex(aF);
        const bAbsTex = fTex(fFrac(Math.abs(bF.n), bF.d));
        const signB = (bF.n >= 0) ? '+' : 'âˆ’';

        u1F = fAdd(fMul(aF, u0F), bF);
        calc1Lines = [
          `\\(${name}_1 = ${aTex}${name}_0 ${signB} ${bAbsTex}\\)`,
          `\\(${name}_1 = ${aTex}\\times ${parenIfNegTex(u0F)} ${signB} ${bAbsTex}\\)`,
          `\\(${name}_1 = ${fTex(u1F)}\\)`
        ];

        u2F = fAdd(fMul(aF, u1F), bF);
        calc2Lines = [
          `\\(${name}_2 = ${aTex}${name}_1 ${signB} ${bAbsTex}\\)`,
          `\\(${name}_2 = ${aTex}\\times ${parenIfNegTex(u1F)} ${signB} ${bAbsTex}\\)`,
          `\\(${name}_2 = ${fTex(u2F)}\\)`
        ];
      }

      /* ---- c) Suite v_{n+1} = v_n + (affine en n) ---- */
      else { // seq.kind === 'u_plus_affine'
        const aF       = fInt(seq.alpha);
        const bF       = fInt(seq.beta);
        const aAbsTex  = fTex(fFrac(Math.abs(aF.n), aF.d));
        const bAbsTex  = fTex(fFrac(Math.abs(bF.n), bF.d));
        const signA    = (aF.n >= 0) ? ' + ' : ' âˆ’ ';
        const signB    = (bF.n >= 0) ? ' + ' : ' âˆ’ ';

        // n = 0
        u1F = fAdd(u0F, bF);  // car Î±Â·0 = 0
        calc1Lines = [
          `\\(${name}_1 = ${name}_0${signA}${aAbsTex}\\times 0${signB}${bAbsTex}\\)`,
          `\\(${name}_1 = ${name}_0${signB}${bAbsTex}\\)`,
  `\\(${name}_1 = ${fTex(u0F)}${signB}${bAbsTex}\\)`,
          `\\(${name}_1 = ${fTex(u1F)}\\)`
        ];

        // n = 1
        const aPlusbF       = fAdd(aF, bF);
        const aPlusbAbsTex  = fTex(fFrac(Math.abs(aPlusbF.n), aPlusbF.d));
        const signApB       = (aPlusbF.n >= 0) ? ' + ' : ' âˆ’ ';

        u2F = fAdd(u1F, aPlusbF);

        calc2Lines = [
          `\\(${name}_2 = ${name}_1${signA}${aAbsTex}\\times 1${signB}${bAbsTex}\\)`,
          `\\(${name}_2 = ${name}_1${signA}${aAbsTex}${signB}${bAbsTex}\\)`,
          `\\(${name}_2 = ${name}_1${signApB}${aPlusbAbsTex}\\)`,
  `\\(${name}_2 = ${fTex(u1F)}${signApB}${aPlusbAbsTex}\\)`,
          `\\(${name}_2 = ${fTex(u2F)}\\)`
        ];
      }

      const d1F = fSub(u1F, u0F);
      const d2F = fSub(u2F, u1F);

      const u0Tex = fTex(u0F);
      const d1Tex = fTex(d1F);
      const d2Tex = fTex(d2F);

      const diffLines = (Uk, Ukm1, Dk, kLabel) => {
        const UkTex   = fTex(Uk);
        const Ukm1Tex = fTex(Ukm1);
        const Ukm1Abs = fTex(fFrac(Math.abs(Ukm1.n), Ukm1.d));

        let l1;
        if (Ukm1.n >= 0){
          l1 = `${name}_${kLabel} - ${name}_${kLabel-1} = ${UkTex} âˆ’ ${Ukm1Tex}`;
        } else {
          // pas de "-(-â€¦)", on passe directement en "+"
          l1 = `${name}_${kLabel} - ${name}_${kLabel-1} = ${UkTex} + ${Ukm1Abs}`;
        }
        const l2 = `${name}_${kLabel} - ${name}_${kLabel-1} = ${fTex(Dk)}`;
        return { l1, l2 };
      };

      const diff01 = diffLines(u1F, u0F, d1F, 1);
      const diff12 = diffLines(u2F, u1F, d2F, 2);

      return `
        <li style="margin-bottom:.6rem">
          <div class="steps">
            <div class="step">
              <strong>${label}</strong> \\(${seq.tex}\\)
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule les trois premiers termes de la suite en appliquant la relation de rÃ©currence :
            </div>

            <div class="step">
              <table style="border-collapse:collapse;border:1px solid #ccc;font-size:.95rem">
                <tbody>
                  <tr>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      \\(${name}_0 = ${u0Tex}\\)
                    </td>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      ${calc1Lines.join('<br>')}
                    </td>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      ${calc2Lines.join('<br>')}
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule ensuite les diffÃ©rences successives :
            </div>

            <div class="step">
              <table style="border-collapse:collapse;border:1px solid #ccc;font-size:.95rem">
                <tbody>
                  <tr>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      \\(${diff01.l1}\\)<br>
                      \\(${diff01.l2}\\)
                    </td>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      \\(${diff12.l1}\\)<br>
                      \\(${diff12.l2}\\)
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="step" style="margin-top:.35rem">
              \\(${d1Tex} \\neq ${d2Tex}\\) donc la diffÃ©rence entre deux termes successifs
              nâ€™est pas constante.
            </div>
            <div class="step">
              La suite \\((${name}_n)\\) nâ€™est donc <strong>pas arithmÃ©tique</strong>.
            </div>
          </div>
        </li>`;
    }).join('');

W.innerHTML = `<ol style="list-style:none;padding-left:0;margin:0">${items}</ol>`;
    retypeMath(W);
  }



});


  return L;
}

/* ===== REGISTRY & UI (mÃªmes hooks que ton modÃ¨le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // EntrÃ©e => VÃ©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur dâ€™affichage :</b> ${e.message}<br>Ouvre la console pour le dÃ©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit prÃªt et que le kit soit chargÃ©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: '1Ã¨re - Suites arithmÃ©tiques - DÃ©finition - ReconnaÃ®tre une suite arithmÃ©tique (formule de rÃ©currence)',
        max: 50,
        // Monte l'UI PDF juste aprÃ¨s ta carte "Saisie & rÃ©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte dâ€™amorce par type (affichÃ© avant chaque exo dans le PDF)
                // Optionnel : laisse Ã  false pour ne pas lancer lâ€™impression automatiquement
        autoPrint: false
      });
    } else {
      // rÃ©essaie briÃ¨vement si le kit ou REGISTRY nâ€™est pas encore prÃªts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui Ã©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas rÃ©fÃ©rencer ok4 si la Q(b) est commentÃ©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un Ã©ventuel tick fantÃ´me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit sâ€™Ã©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
