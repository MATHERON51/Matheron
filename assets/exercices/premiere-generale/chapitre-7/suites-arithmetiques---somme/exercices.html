<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1Ã¨re - Suites arithmÃ©tiques - Somme </title>

<!-- mÃªmes feuilles que ton modÃ¨le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles Ã  lâ€™Ã©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de rÃ©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}

.tbl-suites{
  border-collapse:collapse;
  border:1px solid #ccc;
}
.tbl-suites th,
.tbl-suites td{
  border:1px solid #ccc;
  padding:4px 6px;
}


ul.no-bullet{
  list-style:none;
  padding-left:0;
  margin-left:0;
}


</style>

<!-- MathJax comme dans ton modÃ¨le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- mÃªmes libs partagÃ©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1Ã¨re - Suites arithmÃ©tiques - Somme </strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contrÃ´le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-sol" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- HÃ´te dâ€™exercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & rÃ©ponses acceptÃ©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & rÃ©ponses acceptÃ©es :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> acceptÃ©es
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenthÃ¨ses/accolades, soulignÃ©s, <code>*</code> ou <code>Ã—</code> sont normalisÃ©s).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = 'âˆ’';

/* ===== Utilitaires gÃ©nÃ©riques (mÃªmes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tolÃ¨re u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, Ã—, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/Ã—|\*/g,'');
  s = s.replace(/[âˆ’â€“â€”]/g,'-');

  // normaliser les Ã©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'âœ“':'âœ—'; }
// âœ“ / âœ— / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='âœ“'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='âœ—'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] â†’ an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "âˆ’" collÃ©s
  let s = parts.join(' + ').replace(/\+\s*âˆ’/g, UMINUS).replace(/âˆ’\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/âˆ’ en LaTeX
  s = s.replace(/\+/g,'+').replace(/âˆ’/g, UMINUS);
  return s || '0';
}

function makeExos(){
  const L = [];


/* === Ex.  â€” Somme de termes dâ€™une suite arithmÃ©tique === */
L.push({
  id: 'ex_somme_suite_arith',
  title: "Ex. â€” Somme de termes dâ€™une suite arithmÃ©tique",

  gen(){
    const r = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);   // raison non nulle
    let u0 = rint(-10,10);
    while(u0 === 0) u0 = rint(-10,10);              // Ã©vite le cas trop trivial

    // 40% : on donne u0 ; 60% : on donne u_p avec pâ‰¥1
    let knownIndex;
    if(Math.random() < 0.4){
      knownIndex = 0;
    }else{
      knownIndex = rint(1,5);
    }
    const knownValue = u0 + knownIndex * r;

    // indices de la somme S = u_a + ... + u_b
    const a = rint(5,20);
    const b = a + rint(5,20);       // au moins 6 termes

    const uA = u0 + a*r;
    const uB = u0 + b*r;
    const N  = b - a + 1;
    const S  = N * (uA + uB) / 2;

    return {
      r, u0,
      knownIndex, knownValue,
      a, b,
      uA, uB,
      N, S
    };
  },

render(host,s){
  host.__state = s;
  const UMINUS = 'âˆ’';
  const texInt = x => String(x).replace(/-/g, UMINUS);

  const rTex = texInt(s.r);

  // on prÃ©pare juste la partie "u_known = ..."
  let knownTex;
  if(s.knownIndex === 0){
    knownTex = `u_0 = ${texInt(s.u0)}`;
  }else{
    knownTex = `u_{${s.knownIndex}} = ${texInt(s.knownValue)}`;
  }

  const a = s.a, b = s.b;

  host.innerHTML = `
    <div class="row norepere">
      <div class="statement">
        <p>Soit \\((u_n)\\) une suite arithmÃ©tique de raison \\(${rTex}\\).</p>
        <p>On sait que \\(r = ${rTex}\\) et \\(${knownTex}\\).</p>
        <p>Calculer la somme :</p>
        <p style="margin-left:1.2rem">
          \\(S = u_{${a}} + u_{${a+1}} + \\cdots + u_{${b}}\\).
        </p>

        <p>
          ${mkInput('S',140)} <span id="tS" class="tick"></span>
        </p>

    
      </div>

      <div><div class="steps" id="steps"></div></div>
    </div>
  `;

  retypeMath(host);

  host.querySelectorAll('input').forEach(inp=>{
    inp.addEventListener('keydown', ev=>{
      if(ev.key === 'Enter'){
        document.querySelector('#btn-check')?.click();
      }
    });
  });
}
,

  check(host){
    const s = host.__state;
    const raw = val('S');
    const t   = $('#tS',host);

    if(!raw){
      tickTri(t,null);
      return false;
    }

    const x = parseNumber(raw);
    const ok = !Number.isNaN(x) && near(x, s.S);

    tickTri(t, ok);

    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);

    return ok;
  },

solution(host){
  const s = host.__state;
  const W = $('#steps',host);
  const UMINUS = 'âˆ’';
  const texInt = x => String(x).replace(/-/g, UMINUS);

  const r  = s.r;
  const a  = s.a, b = s.b;
  const N  = s.N;
  const uA = s.uA;
  const uB = s.uB;
  const S  = s.S;

  const absR = Math.abs(r);

  // ===== 1) Ã©ventuelle reconstitution de u0 (pour l'explication) =====
  let u0 = s.u0;
  let blocU0 = '';

  if(s.knownIndex !== 0){
    const p  = s.knownIndex;
    const up = s.knownValue;
    const pr = p * r;
    const absPR   = Math.abs(pr);

    // Quand on remonte : u0 = up - p*r.
    // On veut Ã©viter les "-(-...)" â†’ directement Â±
    const signeAffiche = pr >= 0 ? UMINUS : '+';

    u0 = up - pr;

    blocU0 = `
      <div class="step">
        \\((u_n)\\) est une suite arithmÃ©tique de raison \\(r = ${texInt(r)}\\) et on connaÃ®t \\(u_{${p}} = ${texInt(up)}\\).<br>
      </div>
    `;
  }

  // ===== 2) bloc "formule explicite" selon ce qu'on connaÃ®t Ã  l'Ã©noncÃ© =====
  let blocFormule = '';
  const p = s.knownIndex;
  const up = s.knownValue;

  // pour Ã©viter 1n / -1n
  const coefN = k => {
    const ak = Math.abs(k);
    if(ak === 1) return 'n';
    return `${ak}n`;
  };

  if(p === 0){
    // Cas : on connaÃ®t u0 â†’ u_n = u_0 + rn
    const coefLine2 = coefN(r);

    blocFormule = `
      <div class="step">
        On utilise la formule explicite dâ€™une suite arithmÃ©tique :<br>
        \\(u_n = u_0 + rn\\)<br>
        \\(u_n = ${texInt(u0)} ${r>=0?'+':'âˆ’'} ${coefLine2}\\)
      </div>
    `;
  }else{
    // Cas : on connaÃ®t u_p â†’ u_n = u_p + r(n-p)
    const coefLine2 = (absR === 1) ? `(n-${p})` : `${absR}(n-${p})`;
    const signeRP = r>=0 ? '+' : 'âˆ’';

    blocFormule = `
      <div class="step">
        On utilise la formule explicite Ã  partir de \\(u_{${p}}\\) :<br>
        \\(u_n = u_{${p}} + r\\bigl(n-${p}\\bigr)\\)<br>
        \\(u_n = ${texInt(up)} ${signeRP} ${coefLine2}\\)
      </div>
    `;
  }

  // ===== 3) calcul de u_a et u_b Ã  partir de la formule explicite =====

  // pour que les lignes soient propres
  const absAR  = Math.abs(a*r);
  const absBR  = Math.abs(b*r);
  const signeAR = (a*r) >= 0 ? '+' : 'âˆ’';
  const signeBR = (b*r) >= 0 ? '+' : 'âˆ’';

  // Cas 1 : on connaÃ®t u0 â†’ u_a = u_0 + ar, u_b = u_0 + br
  let blocAB;

  if(p === 0){
    blocAB = `
      <div class="step">
        On calcule le premier et le dernier terme de la somme Ã  lâ€™aide de la formule explicite :
      </div>

      <div class="step">
        <table style="width:60%;border-collapse:collapse">
          <tr>
            <td style="vertical-align:top;padding-right:1.5rem">
\\(u_{${a}} = ${texInt(u0)} ${r>=0?'+':'âˆ’'} ${texInt(absR)}\\times ${a}\\)<br>
              \\(u_{${a}} = ${texInt(u0)} ${signeAR} ${texInt(absAR)}\\)<br>
              \\(u_{${a}} = ${texInt(uA)}\\)
            </td>
            <td style="vertical-align:top">
\\(u_{${b}} = ${texInt(u0)} ${r>=0?'+':'âˆ’'} ${texInt(absR)}\\times ${b}\\)<br>
              \\(u_{${b}} = ${texInt(u0)} ${signeBR} ${texInt(absBR)}\\)<br>
              \\(u_{${b}} = ${texInt(uB)}\\)
            </td>
          </tr>
        </table>
      </div>
    `;
  }else{
    // Cas 2 : on connaÃ®t u_p â†’ on part de u_n = u_p + r(n-p)
    const diffA   = (a - p) * r;
    const diffB   = (b - p) * r;
    const absDiffA = Math.abs(diffA);
    const absDiffB = Math.abs(diffB);
    const signeDiffA = diffA >= 0 ? '+' : 'âˆ’';
    const signeDiffB = diffB >= 0 ? '+' : 'âˆ’';

    const coefA = (absR===1) ? `( ${a}-${p} )` : `${absR}( ${a}-${p} )`;
    const coefB = (absR===1) ? `( ${b}-${p} )` : `${absR}( ${b}-${p} )`;

    blocAB = `
      <div class="step">
        On calcule le premier et le dernier terme de la somme Ã  partir de la formule explicite :
      </div>

      <div class="step">
        <table style="width:60%;border-collapse:collapse">
          <tr>
            <td style="vertical-align:top;padding-right:1.5rem">
              \\(u_{${a}} = ${texInt(up)} ${r>=0?'+':'âˆ’'} ${coefA}\\)<br>
              \\(u_{${a}} = ${texInt(up)} ${signeDiffA} ${texInt(absDiffA)}\\)<br>
              \\(u_{${a}} = ${texInt(uA)}\\)
            </td>
            <td style="vertical-align:top">
              \\(u_{${b}} = ${texInt(up)} ${r>=0?'+':'âˆ’'} ${coefB}\\)<br>
              \\(u_{${b}} = ${texInt(up)} ${signeDiffB} ${texInt(absDiffB)}\\)<br>
              \\(u_{${b}} = ${texInt(uB)}\\)
            </td>
          </tr>
        </table>
      </div>
    `;
  }

  // ===== 4) calcul du nombre de termes et de la somme S =====

  // Ligne S avec gestion propre des signes dans (u_a + u_b)
  let sommeNumsLine;
  if(uB >= 0){
    // S = N * (uA + uB)/2  â†’ pas de "+ -"
    sommeNumsLine = `S = ${N} \\times \\dfrac{${texInt(uA)} + ${texInt(uB)}}{2}`;
  }else{
    // S = N * (uA - |uB|)/2
    sommeNumsLine = `S = ${N} \\times \\dfrac{${texInt(uA)} - ${texInt(Math.abs(uB))}}{2}`;
  }

  const html = `
    <div class="steps">

      ${blocU0 || `
      <div class="step">
        \\((u_n)\\) est une suite arithmÃ©tique de raison \\(r = ${texInt(r)}\\) et de premier terme : \\(u_0 = ${texInt(u0)}\\).
      </div>`}

      ${blocFormule}
<br>
      ${blocAB}
<br>
      <div class="step">
        Le nombre de termes ajoutÃ©s dans la somme est :<br>
        \\(N = ${b} - ${a} + 1 = ${N}\\).
      </div><br>
<div class="step">
  \\(\\displaystyle S = \\sum_{k=${a}}^{${b}} u_k\\)
</div>



      <div class="step">
        \\(S = N \\times \\dfrac{\\text{premier terme de la somme} + \\text{dernier terme de la somme}}{2}\\).
      </div>

      <div class="step">
        \\(S = N \\times \\dfrac{u_{${a}} + u_{${b}}}{2}\\)<br>
        \\(${sommeNumsLine}\\)<br>
        \\(S = ${S}\\)
      </div>
    </div>
  `;

  W.innerHTML = html;
  retypeMath(W);
}


});



  return L;
}

/* ===== REGISTRY & UI (mÃªmes hooks que ton modÃ¨le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // EntrÃ©e => VÃ©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur dâ€™affichage :</b> ${e.message}<br>Ouvre la console pour le dÃ©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit prÃªt et que le kit soit chargÃ©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: '1Ã¨re - Suites arithmÃ©tiques - Somme ',
        max: 50,
        // Monte l'UI PDF juste aprÃ¨s ta carte "Saisie & rÃ©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte dâ€™amorce par type (affichÃ© avant chaque exo dans le PDF)
                // Optionnel : laisse Ã  false pour ne pas lancer lâ€™impression automatiquement
        autoPrint: false
      });
    } else {
      // rÃ©essaie briÃ¨vement si le kit ou REGISTRY nâ€™est pas encore prÃªts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui Ã©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas rÃ©fÃ©rencer ok4 si la Q(b) est commentÃ©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un Ã©ventuel tick fantÃ´me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit sâ€™Ã©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
