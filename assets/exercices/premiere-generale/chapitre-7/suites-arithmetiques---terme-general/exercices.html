<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1√®re - Suites arithm√©tiques - Terme g√©n√©ral - Reconna√Ætre une suite arithm√©tique (formule explicite) - Variations</title>

<!-- m√™mes feuilles que ton mod√®le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles √† l‚Äô√©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de r√©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}

.tbl-suites{
  border-collapse:collapse;
  border:1px solid #ccc;
}
.tbl-suites th,
.tbl-suites td{
  border:1px solid #ccc;
  padding:4px 6px;
}


ul.no-bullet{
  list-style:none;
  padding-left:0;
  margin-left:0;
}


</style>

<!-- MathJax comme dans ton mod√®le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- m√™mes libs partag√©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re - Suites arithm√©tiques - Terme g√©n√©ral - Reconna√Ætre une suite arithm√©tique (formule explicite) - Variations</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contr√¥le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- H√¥te d‚Äôexercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & r√©ponses accept√©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> accept√©es
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenth√®ses/accolades, soulign√©s, <code>*</code> ou <code>√ó</code> sont normalis√©s).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = '‚àí';

/* ===== Utilitaires g√©n√©riques (m√™mes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tol√®re u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, √ó, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/√ó|\*/g,'');
  s = s.replace(/[‚àí‚Äì‚Äî]/g,'-');

  // normaliser les √©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'‚úì':'‚úó'; }
// ‚úì / ‚úó / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] ‚Üí an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "‚àí" coll√©s
  let s = parts.join(' + ').replace(/\+\s*‚àí/g, UMINUS).replace(/‚àí\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/‚àí en LaTeX
  s = s.replace(/\+/g,'+').replace(/‚àí/g, UMINUS);
  return s || '0';
}

function makeExos(){
  const L = [];


/* === Ex. 1 ‚Äî Suite arithm√©tique (u0 et r) === */
L.push({
  id: 'ex1_suite_arith',
  title: "Ex. 1 ‚Äî Suite arithm√©tique (u_0 et raison r)",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){ if(d===0) return {n:NaN,d:0}; if(d<0){n=-n;d=-d;} const g=this._gcd(n,d); return {n:n/g,d:d/g}; },
  _fracTex(n,d){
    if(d===0){ return '\\text{ind√©fini}'; }
    const s = this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,'‚àí');
    const sign = s.n<0 ? '‚àí' : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _signText(r){
    if(r>0) return 'croissante';
    if(r<0) return 'd√©croissante';
    return 'constante';
  },
  _parseSens(raw){
    if(!raw) return null;
    let s = String(raw).toLowerCase().trim();
    // on enl√®ve les accents
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;

    // c... ‚Üí croissante
    if(s[0] === 'c') return 'croissante';

    // d... ‚Üí d√©croissante
    if(s[0] === 'd') return 'd√©croissante';

    // "const", "constante", etc.
    if(s.includes('const')) return 'constante';

    return null;
  },

  _evalFormulaOk(input, cas){
    if(!input) return null;

    // On r√©cup√®re uniquement le membre de droite (apr√®s =), sinon tout.
    let norm = normRelation(input);
    let rhs = norm.includes('=') ? norm.split('=')[1] : norm;
    if(!rhs) return false;

    // Remplacements symboliques ‚Üí num√©riques
    rhs = rhs
      .replace(/[‚àí‚Äì‚Äî]/g,'-')
      .replace(/\\cdot/g,'*')
      .replace(/[√ó¬∑]/g,'*');

    // u_0 / u0 / u0 avec accolades
    rhs = rhs.replace(/u_\{?0\}?/g, `(${cas.u0})`)
             .replace(/u0/g, `(${cas.u0})`);

    // r √©ventuel
    rhs = rhs.replace(/\br\b/g, `(${cas.r})`);

    // g√©rer "4n" ou "-3n"
    rhs = rhs.replace(/(\d)n/g, '$1*n');
    // (rare) "n4"
    rhs = rhs.replace(/n(\d)/g, 'n*$1');

    // puissance
    rhs = rhs.replace(/\^/g,'**');

    // variable n
    // (on laisse "n" tel quel, la fonction JS l'utilisera)

    // s√©curit√© grossi√®re : uniquement caract√®res autoris√©s
    if(/[^0-9n()+\-*/.,]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => cas.u0 + n*cas.r;
    const tests = [0,1,2,5];
    try{
      for(const n of tests){
        const v = Number(f(n));
        if(!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },

  _evalRecurrenceOk(input, cas){
    if (!input) return null;

    // 1) normalisation souple : u(n+1), u_(n+1) ‚Üí u_{n+1}, etc.
    let s = normRelation(input);

    // On ne garde que le membre de droite apr√®s le dernier "="
    const parts = s.split('=');
    let rhs = parts[parts.length - 1];
    if (!rhs) return false;

    // 2) Nettoyage des signes / produits
    rhs = rhs
      .replace(/[‚àí‚Äì‚Äî]/g, '-')      // tous les "gros moins" ‚Üí "-"
      .replace(/\\cdot/g, '*')
      .replace(/[√ó¬∑]/g, '*');

    // 3) Remplacement de u_n par u0 + n*r
    //    (sans espaces pour ne pas g√™ner le filtre plus bas)
    const uExpr = `(${cas.u0}+n*${cas.r})`;
    rhs = rhs.replace(/u_\{?n\}?/g, uExpr);  // u_n, u_{n}

    // 4) Au cas o√π : u0 et r √©crits explicitement
    rhs = rhs
      .replace(/u0/g, `(${cas.u0})`)
      .replace(/\br\b/g, `(${cas.r})`);

    // 5) G√©rer "4n" ou "n4"
    rhs = rhs.replace(/(\d)n/g, '$1*n');
    rhs = rhs.replace(/n(\d)/g, 'n*$1');

    // 6) Puissances "^" ‚Üí "**"
    rhs = rhs.replace(/\^/g, '**');

    // 7) Supprimer tous les espaces √©ventuels (y compris ceux ajout√©s par nous)
    rhs = rhs.replace(/\s+/g, '');

    // 8) S√©curit√© : uniquement chiffres, n, (), + - * / . , autoris√©s
    if (/[^0-9n()+\-*/.,]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    // 9) Valeur attendue : u_{n+1} = u0 + (n+1)r
    const expected = n => cas.u0 + (n+1)*cas.r;
    const tests = [0, 1, 2, 5];

    try{
      for (const n of tests){
        const v = Number(f(n));
        if (!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },




   gen(){
    const N = 25; // u_25

    const buildCase = (u0, num, den)=>{
      const r   = num / den;
      const u1  = u0 + r;
      const u2  = u0 + 2*r;
      const uN  = u0 + N*r;
      const sens = this._signText(r);
      const rTex = this._fracTex(num, den);

      // forme explicite TeX
      let coefN;
      if(den===1){
        if(num===1)       coefN = 'n';
        else if(num===-1) coefN = '‚àín';
        else              coefN = `${num}n`.replace(/-/g,'‚àí');
      }else{
        coefN = `${this._fracTex(num,den)}\\,n`;
      }
      const explTeX =
        `u_n = ${String(u0).replace(/-/g,'‚àí')}` +
        (r===0 ? '' : (r>0 ? ' + ' : ' ‚àí ') + (r>0 ? coefN : coefN.replace(/^‚àí/,'') ));

      return {
        u0, r, num, den,
        rTex,
        u1, u2, uN,
        N,
        sens,
        explTeX
      };
    };

    const cases = [];

    // 1) u0 > 0, r entier > 0
    cases.push(
      buildCase(
        rint(1,10),     // u0 > 0
        rint(1,8),      // r > 0
        1               // entier
      )
    );

    // 2) u0 < 0, r entier > 0
    cases.push(
      buildCase(
        rint(-10,-1),   // u0 < 0
        rint(1,8),      // r > 0
        1
      )
    );

    // 3) u0 > 0, r entier < 0
    cases.push(
      buildCase(
        rint(1,10),     // u0 > 0
        rint(-8,-1),    // r < 0
        1
      )
    );

    // 4) u0 > 0, r fraction (¬± /2)
    cases.push(
      buildCase(
        rint(1,10),                   // u0 > 0
        choice([-5,-3,-1,1,3,5]),     // num fractionnaire, ¬±
        2                             // /2
      )
    );

    // M√©lange al√©atoire de l'ordre des cas (Fisher‚ÄìYates)
    for(let i = cases.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [cases[i], cases[j]] = [cases[j], cases[i]];
    }

    return { cases };
  },



  render(host, s){
    host.__state = s;

const listItems = s.cases.map((c,idx)=>{
  const k = idx+1;
  return `\\(${k}.\\ u_0 = ${String(c.u0).replace(/-/g,'‚àí')}\\ \\text{ et }\\ r = ${c.rTex}\\quad\\)`;
}).join(' ');


    // lignes d‚Äôinputs
    const rowsHtml = s.cases.map((c,idx)=>{
      const k = idx+1;
      return `
        <tr>
          <td>\\(${k}.\\)</td>
          <td>\\(u_1=\\) ${mkInput('a'+k+'1',80)} <span id="ta${k}1" class="tick"></span></td>
          <td>\\(u_2=\\) ${mkInput('a'+k+'2',80)} <span id="ta${k}2" class="tick"></span></td>
          <td>${mkInput('b'+k,170)} <span id="tb${k}" class="tick"></span></td>
          <td>${mkInput('c'+k,170)} <span id="tc${k}" class="tick"></span></td>
          <td>${mkInput('d'+k,90)} <span id="td${k}" class="tick"></span></td>
<td>${mkInput('e'+k,130)} <span id="te${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(r\\) d‚Äôune suite arithm√©tique.</p>
          <p>${listItems}</p>

   <p>Pour chacun des cas :</p>
<ul class="no-bullet">
  <li>a) D√©terminer \\(u_1\\) et \\(u_2\\).</li>
  <li>b) Exprimer \\(u_{n+1}\\) en fonction de \\(u_n\\).</li>
  <li>c) Exprimer \\(u_n\\) en fonction de \\(n\\).</li>
  <li>d) Calculer \\(u_{${s.cases[0].N}}\\).</li>
  <li>e) D√©terminer le sens de variation de la suite.</li>
</ul>


          <table style="border-collapse:collapse;width:100%;font-size:.95rem">
            <thead>
              <tr>
                <th></th>
                <th>a) \\(u_1\\)</th>
                <th>a) \\(u_2\\)</th>
                <th>b) \\(u_{n+1}\\) en fonction de \\(u_n\\)</th>
                <th>c) \\(u_n\\) en fonction de \\(n\\)</th>
                <th>d) \\(u_{${s.cases[0].N}}\\)</th>
                <th>e) Sens de variation</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>

          <div class="equ-offscreen" style="display:none">
            <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(r\\) d‚Äôune suite arithm√©tique.</p>
            <p>${listItems}</p>
<p>Pour chacun des cas :</p>
<ul class="no-bullet">
  <li>a) D√©terminer \\(u_1\\) et \\(u_2\\).</li>
  <li>b) Exprimer \\(u_{n+1}\\) en fonction de \\(u_n\\).</li>
  <li>c) Exprimer \\(u_n\\) en fonction de \\(n\\).</li>
  <li>d) Calculer \\(u_{${s.cases[0].N}}\\).</li>
  <li>e) D√©terminer le sens de variation de la suite.</li>
</ul>

          </div>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    // Enter ‚Üí V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.cases.forEach((cas,idx)=>{
      const k = idx+1;

      const v11 = val('a'+k+'1').trim();
      const v12 = val('a'+k+'2').trim();
      const vb  = val('b'+k).trim();
      const vc  = val('c'+k).trim();
      const vd  = val('d'+k).trim();
      const ve  = val('e'+k).trim();

      if(!v11 || !v12 || !vb || !vc || !vd || !ve) allFilled = false;

      const ok11 = v11==='' ? null : near(parseNumber(v11), cas.u1);
      const ok12 = v12==='' ? null : near(parseNumber(v12), cas.u2);

      const okb  = vb==='' ? null : this._evalRecurrenceOk(vb, cas);


      const okc  = this._evalFormulaOk(vc, cas);

      const okd  = vd==='' ? null : near(parseNumber(vd), cas.uN);

      const sensUser = this._parseSens(ve);
      const oke = ve==='' ? null : (sensUser === cas.sens);

      tickTri($('#ta'+k+'1',host), ok11);
      tickTri($('#ta'+k+'2',host), ok12);
      tickTri($('#tb'+k,host),    okb);
      tickTri($('#tc'+k,host),    okc);
      tickTri($('#td'+k,host),    okd);
      tickTri($('#te'+k,host),    oke);

      if(ok11===false || ok12===false || okb===false || okc===false || okd===false || oke===false){
        allOk = false;
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

    solution(host){
    const s = host.__state;
    const W = $('#steps', host);
    const UMINUS = '‚àí';

    const texInt = x => String(x).replace(/-/g, UMINUS);

    const html = `
      <ol style="padding-left:1.2rem;margin:0">
        ${s.cases.map((cas, idx) => {
          const N    = cas.N;      // ici 25
          const u0T  = texInt(cas.u0);
          const u1T  = texInt(cas.u1);
          const u2T  = texInt(cas.u2);

          const isFrac   = cas.den !== 1;
          const rAbsTex  = this._fracTex(Math.abs(cas.num), cas.den); // r sans signe
          const rTexSign = this._fracTex(cas.num, cas.den);           // r avec signe
          const signR    = cas.r >= 0 ? '+' : '‚àí';

          /* ====== a) u1 et u2 ====== */

          let partAHtml;

          if (!isFrac){
            // --- CAS r ENTIER : pr√©sentation simple comme avant ---
            let plusR_a = '';
            if (cas.r > 0)      plusR_a = ` + ${rAbsTex}`;
            else if (cas.r < 0) plusR_a = ` ‚àí ${rAbsTex}`;

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = u_0 ${plusR_a}\\)<br>
                      \\(u_1 = ${u0T}${plusR_a}\\)<br>
                      \\(u_1 = ${u1T}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = u_1 ${plusR_a}\\)<br>
                      \\(u_2 = ${u1T}${plusR_a}\\)<br>
                      \\(u_2 = ${u2T}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          } else {
            // --- CAS r FRACTION : tout en fraction, pas de d√©cimales ---

            // Pour u1 : u1 = u0 + num/den = (u0*den + num)/den
            const u1RawNum = cas.u0 * cas.den + cas.num;
            const u1FracTex = this._fracTex(u1RawNum, cas.den);

            // Pour u2 : u2 = u0 + 2*num/den
            const u2RawNum = cas.u0 * cas.den + 2*cas.num;
            const u2FracTex = this._fracTex(u2RawNum, cas.den);

            const u0FracNum = cas.u0 * cas.den; // num√©rateur de u0 avec d√©nominateur commun

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = u_0 ${signR} ${rAbsTex}\\)<br>
                      \\(u_1 = ${u0T} ${signR} ${rAbsTex}\\)<br>
                      \\(u_1 = \\dfrac{${u0FracNum}}{${cas.den}} ${signR} \\dfrac{${Math.abs(cas.num)}}{${cas.den}}\\)<br>
                      \\(u_1 = ${u1FracTex}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = u_1 ${signR} ${rAbsTex}\\)<br>
                      \\(u_2 = ${u1FracTex} ${signR} ${rAbsTex}\\)<br>
                      \\(u_2 = \\dfrac{${u2RawNum}}{${cas.den}}\\)<br>
					  \\(u_2 = ${u2FracTex}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          }

          /* ====== b) r√©currence ====== */

          let recLine;
          if (cas.r > 0)      recLine = `u_{n+1} = u_n + ${rAbsTex}`;
          else if (cas.r < 0) recLine = `u_{n+1} = u_n ‚àí ${rAbsTex}`;
          else                recLine = `u_{n+1} = u_n`;

          /* ====== c) explicite ====== */
          const expl = cas.explTeX;

          /* ====== d) u_25 ====== */

          const linesD = [];

          if (!isFrac){
            // r entier (y compris ¬±1)
            if (Math.abs(cas.r) === 1){
              const sign25 = cas.r > 0 ? '+' : UMINUS;
              const uN = cas.u0 + N*cas.r;
              linesD.push(`u_{${N}} = u_0 ${sign25} ${N}`);
              linesD.push(`u_{${N}} = ${u0T} ${sign25} ${N}`);
              linesD.push(`u_{${N}} = ${texInt(uN)}`);
            } else {
              const uN       = cas.u0 + N * cas.r;
              const delta    = cas.r * N;
              const deltaAbs = Math.abs(delta);
              const signDelta = delta >= 0 ? '+' : UMINUS;

              linesD.push(
                `u_{${N}} = ${u0T} ${cas.r>=0?'+':UMINUS} ${Math.abs(cas.r)}\\times ${N}`
              );
              linesD.push(
                `u_{${N}} = ${u0T} ${signDelta} ${deltaAbs}`
              );
              linesD.push(`u_{${N}} = ${texInt(uN)}`);
            }
          } else {
            // r fractionnaire : tout en fraction
            linesD.push(
              `u_{${N}} = ${u0T} ${signR} ${rAbsTex}\\times ${N}`
            );

            // r√óN en fraction simplifi√©e
            const rn = this._simp(cas.num * N, cas.den); // {n,d}
            const signRN = rn.n >= 0 ? '+' : '‚àí';
            const rnAbsTex = this._fracTex(Math.abs(rn.n), rn.d);

            linesD.push(
              `u_{${N}} = ${u0T} ${signRN} ${rnAbsTex}`
            );

            // u0 au m√™me d√©nominateur
            const numU0   = cas.u0 * rn.d;
            const u0Frac  = `\\dfrac{${numU0}}{${rn.d}}`;
            const rnFracA = `\\dfrac{${Math.abs(rn.n)}}{${rn.d}}`;

            linesD.push(
              `u_{${N}} = ${u0Frac} ${signRN} ${rnFracA}`
            );

            const numFinal = numU0 + rn.n;
            const finalTex = this._fracTex(numFinal, rn.d);

            linesD.push(`u_{${N}} = ${finalTex}`);
          }

          /* ====== e) sens de variation ====== */

          let varTex;
          if (cas.r > 0){
            varTex = `r > 0 \\text{ donc } (u_n) \\text{ est croissante sur } \\mathbb{N}.`;
          } else if (cas.r < 0){
            varTex = `r < 0 \\text{ donc } (u_n) \\text{ est d√©croissante sur } \\mathbb{N}.`;
          } else {
            varTex = `r = 0 \\text{ donc } (u_n) \\text{ est constante sur } \\mathbb{N}.`;
          }

          return `
            <li style="margin-bottom:.6rem">
              <div class="steps">
                ${partAHtml}

                <div class="step" style="margin-top:.35rem">
                  <strong>b.</strong> Pour tout entier naturel \\(n\\), on a :
                  \\(${recLine}\\).
                </div>

                <div class="step" style="margin-top:.35rem">
                  <strong>c.</strong> Pour tout entier naturel \\(n\\), on a :
                  \\(${expl}\\).
                </div>

                <div class="step" style="margin-top:.35rem">
                  <strong>d.</strong>
                </div>
                ${linesD.map(l => `<div class="step">\\(${l}\\)</div>`).join('')}

                <div class="step" style="margin-top:.35rem">
                  <strong>e.</strong> \\(${varTex}\\)
                </div>
              </div>
            </li>`;
        }).join('')}
      </ol>
    `;

    W.innerHTML = html;
    retypeMath(W);


  }

});


/* === Ex. 2 ‚Äî Terme quelconque : u_p connu, trouver u_n avec n>10 === */
L.push({
  id: 'ex2_suite_arith_terme_non_u0',
  title: "Ex. 2 ‚Äî Terme quelconque (u_p connu)",

  gen(){
    // r entier non nul
    let r = 0;
    while(r === 0) r = rint(-7,7);

    // rang du terme connu p (diff√©rent de 0, <10)
    const p = rint(1,9);

    // rang demand√© n (>10, >p)
    let n = rint(11,30);
    if(n <= p) n = p + rint(2,10);

    // valeur de u_p
	    let up = 0;
    while(up === 0) up = rint(-10,10);

    // u_n = u_p + (n-p)*r
    const un = up + (n-p)*r;

    return { r, p, n, up, un };
  },

  render(host, s){
    host.__state = s;
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);

    const rTex  = texInt(s.r);
    const upTex = texInt(s.up);

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Soit \\((u_n)\\) la suite arithm√©tique de raison
            \\(r = ${rTex}\\) et de premier terme
            \\(u_{${s.p}} = ${upTex}\\). Donner \\(u_{${s.n}}\\).
          </p>

          <p>
            \\(u_{${s.n}} = \\) ${mkInput('ans', 120)}
            <span id="tans" class="tick"></span>
          </p>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    // Enter ‚Üí V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    const v = val('ans').trim();
    const t = $('#tans', host);

    let allFilled = true;
    let allOk     = true;

    if(!v) allFilled = false;

    const ok = v==='' ? null : near(parseNumber(v), s.un);
    tickTri(t, ok);
    if(ok === false) allOk = false;

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0], SCORE[1]);
    }
    return allFilled && allOk;
  },

   solution(host){
  const s = host.__state;
  const W = $('#steps', host);
  const UMINUS = '‚àí';
  const texInt = x => String(x).replace(/-/g, UMINUS);

  const r   = s.r;
  const p   = s.p;
  const n   = s.n;
  const up  = s.up;
  const un  = s.un;

  const rTex      = texInt(r);
  const rAbsTex   = texInt(Math.abs(r));
  const upTex     = texInt(up);
  const unTex     = texInt(un);
  const diff      = n - p;
  const diffTex   = texInt(diff);
  const delta     = r * diff;
  const deltaAbs  = Math.abs(delta);
  const deltaAbsTex = texInt(deltaAbs);

  const signCoef  = (r >= 0) ? '+' : UMINUS;      // signe devant le terme en (n-p)
  const signDelta = (delta >= 0) ? '+' : UMINUS;  // signe devant le r√©sultat du produit
  const isAbsOne  = (Math.abs(r) === 1);

  // r(n-p) √©crit proprement :
  const termSymb = isAbsOne
    ? `(n-${p})`
    : `${rAbsTex}(n-${p})`;

  const lineFormulaGen =
    `u_n = u_{${p}} ${signCoef} ${termSymb}`;

  const termSymbSpec = isAbsOne
    ? `(${n}-${p})`
    : `${rAbsTex}(${n}-${p})`;

  const lineFormulaSpec =
    `u_{${n}} = u_{${p}} ${signCoef} ${termSymbSpec}`;

  // ligne num√©rique :
  //  - si |r| = 1 : u_n = u_p ¬± (n-p)
  //  - sinon      : u_n = u_p ¬± |r|√ó(n-p)
  const lineNumeric =
    isAbsOne
      ? `u_{${n}} = ${upTex} ${signCoef} ${diffTex}`
      : `u_{${n}} = ${upTex} ${signCoef} ${rAbsTex}\\times ${diffTex}`;

  const lineSimplified =
    `u_{${n}} = ${upTex} ${signDelta} ${deltaAbsTex}`;

  const lineFinal =
    `u_{${n}} = ${unTex}`;

  // bloc num√©rique : si |r| = 1 on ne garde qu'une des deux lignes
  const numericBlock = isAbsOne
    ? `
      <div class="step">
        \\( ${lineNumeric} \\)
      </div>`
    : `
      <div class="step">
        \\( ${lineNumeric} \\)
      </div>
      <div class="step">
        \\( ${lineSimplified} \\)
      </div>
    `;

  W.innerHTML = `
    <div class="steps">
      <div class="step">
        On sait que \\((u_n)\\) est une suite arithm√©tique de raison
        \\(r = ${rTex}\\) et que \\(u_{${p}} = ${upTex}\\).
      </div>

      <div class="step" style="margin-top:.3rem">
        Pour une suite arithm√©tique de raison \\(r = ${rTex}\\), on a pour tout entier naturel \\(n\\) :<br>
        \\( ${lineFormulaGen} \\)
      </div>

      <div class="step" style="margin-top:.3rem">
        En particulier, pour \\(n = ${n}\\) :<br>
        \\( ${lineFormulaSpec} \\)
      </div>

      ${numericBlock}

      <div class="step">
        \\( ${lineFinal} \\)
      </div>
    </div>
  `;

  retypeMath(W);
}


});


/* === Ex. 3 ‚Äî Calculer r et u0 √† partir de deux termes === */
L.push({
  id: 'ex3_suite_arith_2termes',
  title: "Ex. 3 ‚Äî Calculer r et u‚ÇÄ √† partir de deux termes",

  gen(){
    // Choix de p < q
    const p = rint(1,6);
    const q = p + rint(2,6);

    // Choix de r : entier ou fraction ¬±
    let num, den;
    const type = choice(['int','frac']);

    if(type === 'int'){
      num = choice([-7,-5,-3,-2,-1,1,2,3,5,7]);
      den = 1;
    } else {
      num = choice([-7,-5,-3,-1,1,3,5,7]);
      den = choice([2,3,4,5]);
    }

    const r = num/den;

    // Choix de u_p
    const up = rint(-10,10);

    // Calcul de u_q = u_p + (q-p)r
    const uq = up + (q-p)*r;

    return {p,q,up,uq, num,den, r};
  },

render(host,s){
  host.__state = s;
  const UMINUS = '‚àí';
  const TI = x => String(x).replace(/-/g, UMINUS);

  // outils fractions
  const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; };
  const simp = (n,d)=>{
    if(d<0){n=-n; d=-d;}
    const g = gcd(n,d);
    return {n:n/g, d:d/g};
  };
  const fracTex = (n,d)=>{
    const s = simp(n,d);
    if(s.d===1) return TI(s.n);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  };

  const p   = s.p;
  const q   = s.q;
  const up  = s.up;
  const num = s.num;
  const den = s.den;
  const diff = q - p;

  // u_p : entier (on le laisse comme √ßa)
  const upTex = TI(up);

  // u_q = up + (q-p)*num/den  ‚Üí fraction exacte
  let uqTex;
  if(den === 1){
    uqTex = TI(s.uq); // c'est un entier
  }else{
    const Nq = up*den + diff*num;   // num√©rateur
    uqTex = fracTex(Nq, den);
  }

  host.innerHTML = `
    <div class="statement">
      <p>
        Soit \\((u_n)\\) une suite arithm√©tique.
        On sait que \\(u_{${p}} = ${upTex}\\) et \\(u_{${q}} = ${uqTex}\\).
      </p>

      <ol>
        <li>Calculer \\(r\\) et \\(u_0\\).</li>
        <li>Donner \\(u_n\\) en fonction de \\(n\\).</li>
      </ol>

      <p>
        \\(r =\\) ${mkInput('r',80)} <span id="tr" class="tick"></span><br>
        \\(u_0 =\\) ${mkInput('u0',80)} <span id="tu0" class="tick"></span><br>
        \\(u_n =\\) ${mkInput('un',160)} <span id="tun" class="tick"></span>
      </p>
    </div>

    <div class="steps" id="steps"></div>
  `;

  retypeMath(host);
},


  check(host){
    const s = host.__state;
    const rUser = val('r');
    const u0User = val('u0');
    const unUser = val('un');

    const tR   = $('#tr',host);
    const tU0  = $('#tu0',host);
    const tUn  = $('#tun',host);

    let allFilled=true, allOk=true;

    if(!rUser || !u0User || !unUser) allFilled=false;

    const rOk = rUser==='' ? null : near(parseNumber(rUser), s.r);
    tickTri(tR, rOk);
    if(rOk===false) allOk=false;

    // u0 = u_p - p*r
    const u0 = s.up - s.p*s.r;
    const u0Ok = u0User==='' ? null : near(parseNumber(u0User), u0);
    tickTri(tU0, u0Ok);
    if(u0Ok===false) allOk=false;

    // u_n = u0 + nr
    const okFormula = (()=> {
      if(unUser==='') return null;
      let norm = normRelation(unUser);
      let rhs = norm.includes('=') ? norm.split('=')[1] : norm;

      rhs = rhs
        .replace(/[‚àí‚Äì‚Äî]/g,'-')
        .replace(/\\cdot/g,'*')
        .replace(/[√ó¬∑]/g,'*')
        .replace(/(\d)n/g,'$1*n')
        .replace(/n(\d)/g,'n*$1')
        .replace(/\^/g,'**');

      rhs = rhs.replace(/u0/g,`(${u0})`);
      rhs = rhs.replace(/\br\b/g,`(${s.r})`);

      try{
        const f=new Function('n',`return ${rhs}`);
        return [0,1,3,5].every(n=>near(f(n), u0 + n*s.r));
      }catch(e){return false;}
    })();
    tickTri(tUn, okFormula);
    if(okFormula===false) allOk=false;

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(...SCORE);
    }
  },

     solution(host){
    const s = host.__state;
    const W = $('#steps',host);
    const UMINUS = '‚àí';
    const TI = x => String(x).replace(/-/g, UMINUS);

    const p   = s.p;
    const q   = s.q;
    const up  = s.up;   // entier
    const num = s.num;  // num√©rateur de r
    const den = s.den;  // d√©nominateur > 0
    const diff = q - p; // q-p > 0
    const rVal = num / den;

    // ========= outils fractions =========
    const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; };
    const simp = (n,d)=>{
      if(d<0){n=-n; d=-d;}
      const g = gcd(n,d);
      return {n:n/g, d:d/g};
    };
    const fracTex = (n,d)=>{
      const s2 = simp(n,d);
      if(s2.d===1) return TI(s2.n);
      const sign = s2.n<0 ? UMINUS : '';
      return `${sign}\\dfrac{${Math.abs(s2.n)}}{${s2.d}}`;
    };

    const rTex    = fracTex(num, den);                            // r avec signe
    const rAbsTex = fracTex(Math.abs(num), den).replace(/^‚àí/,''); // r sans signe
    const upTex   = TI(up);

    // ----- u_q pour l‚Äô√©nonc√© -----
    let uqTex;
    if(den === 1){
      uqTex = TI(s.uq);
    } else {
      const Nq = up*den + diff*num;
      uqTex = fracTex(Nq, den);
    }

    // ================== 1) Calcul de r ==================

    // √âtape "On remplace" : jamais -(-u_p), on passe direct en +
    let numExprRemplace;
    if(up >= 0){
      numExprRemplace = `${uqTex} - ${upTex}`;
    } else {
      numExprRemplace = `${uqTex} + ${TI(-up)}`;
    }

    // D√©tails de calcul
    let fracDetailNum = ''; // mise sous m√™me d√©nominateur (que pour vraies fractions)
    let numCalcStep   = ''; // √©tape "On calcule le num√©rateur"

    const uqVal    = s.uq;                       // valeur num√©rique de u_q
    const bothInt  = Number.isInteger(uqVal) && Number.isInteger(up);

    if(bothInt){
      // === CAS : u_q et u_p entiers ‚Üí on fait juste la diff√©rence ===
      const numCalc = uqVal - up;               // (u_q - u_p)
      const numCalcTex = TI(numCalc);

      numCalcStep = `
        <div class="step">
          \\( r = \\dfrac{${numCalcTex}}{${diff}} \\).
        </div>`;
    } else {
      // === CAS : au moins une vraie fraction ‚Üí mise sous m√™me d√©nominateur ===
      const uqNum    = up*den + diff*num; // num√©rateur de u_q
      const upNum    = up*den;            // u_p avec m√™me d√©nominateur
      const signOp   = (up >= 0) ? '‚àí' : '+';
      const upNumAbs = Math.abs(upNum);

      // num√©rateur apr√®s op√©ration
      const combNum    = (up >= 0) ? (uqNum - upNum) : (uqNum + upNumAbs);
      const combNumTex = TI(combNum);

      fracDetailNum = `
        <div class="step">
          \\( r = \\dfrac{\\dfrac{${uqNum}}{${den}} ${signOp} \\dfrac{${upNumAbs}}{${den}}}{${diff}} \\).
        </div>`;

      numCalcStep = `
        <div class="step">
          \\( r = \\dfrac{\\dfrac{${combNumTex}}{${den}}}{${diff}} \\).
        </div>`;
    }

    // ================== 2) Calcul de u0 ==================

    // u0 = u_p - p*r, mais on g√®re le signe pour ne jamais afficher -(-‚Ä¶)
    const pTimesRTexBase = (p === 1) ? rAbsTex : `${p}\\times ${rAbsTex}`;

    let u0FormulaReplace;   // "On remplace"
    let u0CalcDetail = '';  // mise sous m√™me d√©nominateur si besoin
    let u0Tex;

    if(den === 1){
      // r entier
      const delta = p * Math.abs(rVal);

      if(rVal > 0){
        // u0 = up - p*r
        u0FormulaReplace = `u_0 = ${upTex} ‚àí ${p === 1 ? TI(num) : p + '\\times ' + TI(num)}`;
        const u0Val = up - delta;
        u0Tex = TI(u0Val);
      } else {
        // r < 0 : u0 = up + p*|r|
        u0FormulaReplace = `u_0 = ${upTex} + ${p === 1 ? TI(Math.abs(num)) : p + '\\times ' + TI(Math.abs(num))}`;
        const u0Val = up + delta;
        u0Tex = TI(u0Val);
      }
    } else {
      // r fractionnaire
      if(rVal > 0){
        // u0 = up - p*r
        u0FormulaReplace = `u_0 = ${upTex} ‚àí ${pTimesRTexBase}`;
        const u0Num    = up*den - p*num;
        const u0NumUp  = up*den;
        const u0NumPr  = p*num;
        u0CalcDetail = `
          <div class="step">
            \\( u_0 = \\dfrac{${u0NumUp}}{${den}} ‚àí \\dfrac{${u0NumPr}}{${den}} \\).
          </div>`;
        u0Tex = fracTex(u0Num, den);
      } else {
        // r < 0 : u0 = up + p*|r|
        const numAbs = Math.abs(num);
        u0FormulaReplace = `u_0 = ${upTex} + ${p === 1 ? fracTex(numAbs,den) : p + '\\times ' + fracTex(numAbs,den)}`;
        const u0Num    = up*den + p*numAbs;
        const u0NumUp  = up*den;
        const u0NumPr  = p*numAbs;
        u0CalcDetail = `
          <div class="step">
            \\( u_0 = \\dfrac{${u0NumUp}}{${den}} + \\dfrac{${u0NumPr}}{${den}} \\).
          </div>`;
        u0Tex = fracTex(u0Num, den);
      }
    }

    // ================== 3) Expression explicite u_n ==================
    let expl;
    if (Math.abs(rVal) === 1){
      expl = (rVal === 1)
        ? `u_n = ${u0Tex} + n`
        : `u_n = ${u0Tex} ‚àí n`;
    } else {
      const coefAbsTex = fracTex(Math.abs(num), den).replace(/^‚àí/,'');
      expl = (rVal > 0)
        ? `u_n = ${u0Tex} + ${coefAbsTex}n`
        : `u_n = ${u0Tex} ‚àí ${coefAbsTex}n`;
    }

    // ================== 4) Rendu HTML ==================
    W.innerHTML = `
      <div class="steps">

        <!-- 1. Calcul de r -->
        <div class="step">
          <strong>1) Calcul de la raison \\(r\\)</strong>
        </div>

        <div class="step">
          Formule du coefficient directeur :<br>
          \\( r = \\dfrac{u_n - u_k}{n-k} \\).
        </div>

        <div class="step" style="margin-top:.3rem">
          En prenant \\(n = ${q}\\) et \\(k = ${p}\\) :<br>
          \\( r = \\dfrac{u_{${q}} - u_{${p}}}{${q}-${p}} \\)
        </div>

        <div class="step" style="margin-top:.3rem">
          \\( r = \\dfrac{${numExprRemplace}}{${diff}} \\)
        </div>

        ${fracDetailNum}

        ${numCalcStep}

        <div class="step">
          \\( r = ${rTex} \\)
        </div>

        <!-- 2. Calcul de u0 -->
        <div class="step" style="margin-top:.8rem">
          <strong>Calcul de \\(u_0\\)</strong>
        </div>

        <div class="step">
          Formule g√©n√©rale d‚Äôune suite arithm√©tique :<br>
          \\( u_n = u_0 + nr \\)<br>
          Donc \\( u_0 = u_{${p}} - ${p}r \\)
        </div>

        <div class="step" style="margin-top:.3rem">
          \\( ${u0FormulaReplace} \\)
        </div>

        ${u0CalcDetail}

        <div class="step">
          \\( u_0 = ${u0Tex} \\)
        </div>

        <!-- 3. Expression explicite -->
        <div class="step" style="margin-top:.8rem">
          <strong>2) Expression de \\(u_n\\) en fonction de \\(n\\)</strong><br>
          Pour tout entier naturel \\(n\\) :<br>
          \\( ${expl} \\)
        </div>

      </div>
    `;

    retypeMath(W);
  }


});


/* === Ex. 4 ‚Äî Reconna√Ætre une suite arithm√©tique √† partir d‚Äôune expression explicite (al√©atoire) === */
L.push({
  id: 'ex4_suite_arith_reconnaitre',
  title: "Ex. 4 ‚Äî Suites explicites : arithm√©tiques ou non ?",

  /* Helpers fractions / oui-non / affichage propre */
  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; },
  _simp(n,d){
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _parseOuiNon(str){
    if(!str) return null;
    let s = String(str).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='o' || s[0]==='y') return true;   // oui / yes
    if(s[0]==='n') return false;                // non
    return false;
  },

   /* an + b propre : pas de 1n, pas de "+ -3" ni "- -3" */
  _affineTexForm(u0,num,den,form){
    const UMINUS='‚àí';

    // coefficient devant n : jamais 1n
    const absA  = Math.abs(num);
    let coefN;
    if(den===1){
      if(absA===0)      coefN = '';
      else if(absA===1) coefN = 'n';
      else              coefN = `${absA}n`;
    }else{
      coefN = `\\dfrac{${absA}}{${den}}n`;
    }

    let expr = '';

    if(num===0){
      // cas th√©orique (r = 0) -> suite constante
      expr = `u_n = ${u0}`;
    }
    else if(form === 'rn+u0'){
      // forme r n + u0, en √©vitant "+ -3"
      const absU0 = Math.abs(u0);
      if(u0 > 0){
        expr = `u_n = ${coefN} + ${absU0}`;
      }else if(u0 < 0){
        expr = `u_n = ${coefN} - ${absU0}`;
      }else{
        expr = `u_n = ${coefN}`;
      }
    }else{
      // forme u0 + r n, l√† le probl√®me ne se posait pas mais on reste propre
      const absU0 = Math.abs(u0);
      const first = (u0 > 0) ? `${absU0}` : `-${absU0}`;
      if(num > 0){
        expr = `u_n = ${first} + ${coefN}`;
      }else{
        expr = `u_n = ${first} - ${coefN}`;
      }
    }

    // remplace tous les "-" par le vrai signe '‚àí'
    return expr.replace(/-/g, UMINUS);
  },


  /* Canonique pour les solutions : tjs u_n = u0 + rn */
  _affineCanon(u0,num,den){
    return this._affineTexForm(u0,num,den,'u0+rn');
  },

  /* G√©n√©ration al√©atoire : 2 suites arithm√©tiques + 2 non arithm√©tiques */
  gen(){
    const letters = ['a','b','c','d'];
    const names   = ['u','v','w','x'];
    const seqsRaw = [];

    const makeArith = ()=>{
      let u0 = 0;
      while(u0===0) u0 = rint(-9,9);

      const typeR = choice(['int','frac']);
      let num, den;
      if(typeR==='int'){
        num = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);
        den = 1;
      }else{
        den = choice([2,3,4,5]);
        num = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      }
      const simp = this._simp(num,den);
      num = simp.n; den = simp.d;
      const r = num/den;

      const form = choice(['u0+rn','rn+u0']);
      const tex  = this._affineTexForm(u0,num,den,form);

      return { kind:'arith', isArith:true, u0, r, rNum:num, rDen:den, tex };
    };

    const makeGeom = ()=>{
      const a  = choice([-3,-2,-1,1,2,3,4]);
      const q  = choice([2,3,4]);
      const u0 = a;
      const u1 = a*q;
      const u2 = a*q*q;
      return {
        kind:'geom', isArith:false,
        name:'u', u0,u1,u2,
        d1:u1-u0, d2:u2-u1,
        tex:`u_n = ${a} \\times ${q}^n`
      };
    };

    const makePoly = ()=>{
      const a = choice([1,2,3]);
      const b = choice([-2,-1,0,1,2]);
      const c = choice([-4,-3,-2,-1,1,2,3,4]); // pas 0 pour √©viter +0/-0

      const UMINUS='‚àí';
      const aTex = (a===1) ? 'n^2' : `${a}n^2`;

      let termB = '';
      if(b>0) termB = (b===1) ? ' + n' : ` + ${b}n`;
      else if(b<0) termB = (b===-1) ? ' ‚àí n' : ` ‚àí ${-b}n`;

      let termC = '';
      if(c>0) termC = ` + ${c}`;
      else if(c<0) termC = ` ‚àí ${-c}`;

      const tex = `u_n = ${aTex}${termB}${termC}`.replace(/-/g,UMINUS);

      const u0 = a*0 + b*0 + c;
      const u1 = a*1*1 + b*1 + c;
      const u2 = a*4 + b*2 + c;
      const d1 = u1-u0;
      const d2 = u2-u1;

      return {
        kind:'poly', isArith:false,
        name:'u', u0,u1,u2,d1,d2,
        tex
      };
    };

    const makeArithGeo = ()=>{
      const p = choice([1,2,3,4]);
      const a = choice([-3,-2,-1,1,2,3]);
      const q = choice([2,3,4]);

      const UMINUS='‚àí';
      const pTerm = (Math.abs(p)===1) ? 'n' : `${p}n`;
      const signA = (a>=0)?' + ':' ‚àí ';
      const aAbs  = Math.abs(a);

      const tex = `u_n = ${pTerm}${signA}${aAbs}\\times ${q}^n`.replace(/-/g,UMINUS);

      const u0 = a;
      const u1 = p + a*q;
      const u2 = 2*p + a*q*q;
      const d1 = u1-u0;
      const d2 = u2-u1;
      if(d1===d2) return makeArithGeo(); // au cas o√π

      return {
        kind:'arithgeo', isArith:false,
        name:'u', u0,u1,u2,d1,d2,
        tex
      };
    };

    seqsRaw.push(makeArith(), makeArith());

    const nonFactories = [makeGeom, makePoly, makeArithGeo];
    while(seqsRaw.length<4){
      const f = choice(nonFactories);
      seqsRaw.push(f());
    }

    for(let i=seqsRaw.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [seqsRaw[i],seqsRaw[j]] = [seqsRaw[j],seqsRaw[i]];
    }

    const seqs = seqsRaw.map((s,i)=>({
      ...s,
      letter: letters[i],
      name:   names[i]
    }));

    return { seqs };
  },

  render(host,s){
    host.__state = s;
    const UMINUS='‚àí';

    const listTex = s.seqs.map(seq =>
      `\\(${seq.letter}.\\; ${seq.tex.replace(/-/g,UMINUS)} \\quad\\)`
    ).join(' ');

    const rows = s.seqs.map((seq,i)=>{
      const k=i+1;
      return `
        <tr>
          <td>${seq.letter}.</td>
          <td>\\(${seq.tex.replace(/-/g,UMINUS)}\\)</td>
          <td>${mkInput('q'+k,90)} <span id="tq${k}" class="tick"></span></td>
          <td>${mkInput('u0_'+k,80)} <span id="tu0_${k}" class="tick"></span></td>
          <td>${mkInput('r_'+k,80)} <span id="tr_${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Parmi les suites d√©finies sur \\(\\mathbb{N}\\) ci-dessous, reconna√Ætre celles qui sont
            arithm√©tiques et indiquer, pour celles qui le sont, le premier terme et la raison.
          </p>
     

<table class="tbl-suites" style="width:100%;font-size:.95rem;margin-top:.4rem">
            <thead>
              <tr>
                <th style="border:1px solid #ccc;padding:4px 6px"></th>
                <th style="border:1px solid #ccc;padding:4px 6px">Suite \\((u_n)\\)</th>
                <th style="border:1px solid #ccc;padding:4px 6px">Suite arithm√©tique ?<br><span style="font-size:.85em">(√©crire ¬´ oui ¬ª ou ¬´ non ¬ª)</span></th>
                <th style="border:1px solid #ccc;padding:4px 6px">Si oui, \\(u_0\\)</th>
                <th style="border:1px solid #ccc;padding:4px 6px">Si oui, raison \\(r\\)</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    const data = s.seqs;

    let allFilled=true, allOk=true;

    data.forEach((seq,i)=>{
      const k=i+1;
      const ynStr = val('q'+k);
      const u0Str = val('u0_'+k);
      const rStr  = val('r_'+k);

      const tYN = $('#tq'+k,host);
      const tU0 = $('#tu0_'+k,host);
      const tR  = $('#tr_'+k,host);

      const ansYN = this._parseOuiNon(ynStr);

      if(ansYN===null) allFilled=false;

      if(ansYN===null){
        tickTri(tYN,null);
      }else{
        const okYN = (ansYN === seq.isArith);
        tickTri(tYN, okYN);
        if(okYN===false) allOk=false;
      }

      if(seq.isArith){
        if(!u0Str || !rStr) allFilled=false;

        const okU0 = u0Str==='' ? null : near(parseNumber(u0Str), seq.u0);
        const okR  = rStr===''  ? null : near(parseNumber(rStr),  seq.r);

        tickTri(tU0, okU0);
        tickTri(tR,  okR);
        if(okU0===false || okR===false) allOk=false;
      }else{
        if(u0Str || rStr){
          tickTri(tU0,false);
          tickTri(tR,false);
          allOk=false;
        }else{
          tickTri(tU0,null);
          tickTri(tR,null);
        }
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

  // === √Ä mettre dans l'exercice ex4_suite_arith_reconnaitre ===
solution(host){
  const s = host.__state;
  const data = s.seqs;
  const W = $('#steps',host);
  const UMINUS='‚àí';
  const texInt = x => String(x).replace(/-/g,UMINUS);

  const itemsHtml = data.map((seq)=>{
    const idx = seq.letter + ')';

    if(seq.isArith){
      const u0Tex   = texInt(seq.u0);
      const rTex    = this._fracTex(seq.rNum,seq.rDen);
      const canon   = this._affineCanon(seq.u0,seq.rNum,seq.rDen);
      const absRTex = this._fracTex(Math.abs(seq.rNum),seq.rDen).replace(/^‚àí/,'');

      const isUnit  = (seq.rDen === 1 && Math.abs(seq.rNum) === 1);

      let uNp1_line1, uNp1_line2, uNp1_line3;
      let exprUnp1, exprUn;
      let sumTex = null;

      if (isUnit) {
        const u0plusr = seq.u0 + seq.rNum;
        const u0plusrTex = texInt(u0plusr);

        if (seq.rNum > 0) {
          uNp1_line1 = `u_{n+1} = ${u0Tex} + (n+1)`;
          uNp1_line2 = `u_{n+1} = ${u0Tex} + n + 1`;
          exprUnp1   = `${u0plusrTex} + n`;
          uNp1_line3 = `u_{n+1} = ${exprUnp1}`;
          exprUn     = `${u0Tex} + n`;
        } else {
          uNp1_line1 = `u_{n+1} = ${u0Tex} ‚àí (n+1)`;
          uNp1_line2 = `u_{n+1} = ${u0Tex} ‚àí n ‚àí 1`;
          exprUnp1   = `${u0plusrTex} ‚àí n`;
          uNp1_line3 = `u_{n+1} = ${exprUnp1}`;
          exprUn     = `${u0Tex} ‚àí n`;
        }

      } else {
        const sum  = this._simp(seq.u0 * seq.rDen + seq.rNum, seq.rDen);
        sumTex     = this._fracTex(sum.n, sum.d);

        if (seq.rNum > 0) {
          uNp1_line1 = `u_{n+1} = ${u0Tex} + ${absRTex}(n+1)`;
          uNp1_line2 = `u_{n+1} = ${u0Tex} + ${absRTex}n + ${absRTex}`;
          exprUnp1   = `${sumTex} + ${absRTex}n`;
          uNp1_line3 = `u_{n+1} = ${exprUnp1}`;
          exprUn     = `${u0Tex} + ${absRTex}n`;

        } else {
          uNp1_line1 = `u_{n+1} = ${u0Tex} ‚àí ${absRTex}(n+1)`;
          uNp1_line2 = `u_{n+1} = ${u0Tex} ‚àí ${absRTex}n ‚àí ${absRTex}`;
          exprUnp1   = `${sumTex} ‚àí ${absRTex}n`;
          uNp1_line3 = `u_{n+1} = ${exprUnp1}`;
          exprUn     = `${u0Tex} ‚àí ${absRTex}n`;
        }
      }

      // u_{n+1} - u_n : on √©vite -(-‚Ä¶) et +- / -+
      const minusU0 = (seq.u0 >= 0)
        ? `‚àí ${u0Tex}`
        : `+ ${texInt(Math.abs(seq.u0))}`;

      let diff2;
      if (seq.rNum > 0) {
        if (isUnit) {
          const u0plusrTex = texInt(seq.u0 + seq.rNum);
          diff2 = `u_{n+1} - u_n = ${u0plusrTex} + n ${minusU0} ‚àí n`;
        } else {
          diff2 = `u_{n+1} - u_n = ${sumTex} + ${absRTex}n ${minusU0} ‚àí ${absRTex}n`;
        }
      } else {
        if (isUnit) {
          const u0plusrTex = texInt(seq.u0 + seq.rNum);
          diff2 = `u_{n+1} - u_n = ${u0plusrTex} ‚àí n ${minusU0} + n`;
        } else {
          diff2 = `u_{n+1} - u_n = ${sumTex} ‚àí ${absRTex}n ${minusU0} + ${absRTex}n`;
        }
      }

      const rTexFull = this._fracTex(seq.rNum, seq.rDen);

      const diff1 = `u_{n+1} - u_n = ${exprUnp1} - (${exprUn})`;

      return `
      <li style="margin-bottom:.6rem">
        <div class="steps">
          <div class="step"><strong>${idx}  \\(${seq.tex}\\)</strong></div>

          <div class="step" style="margin-top:.35rem">
            <u>M√©thode 1 : reconnaissance de la formule explicite</u>
          </div>
          <div class="step">
            \\(${canon}\\)<br>
            On reconnait pour tout entier naturel \\(n\\) : \\(u_n = u_0 + rn\\) 
            avec : \\(u_0 = ${u0Tex}\\) et \\(r = ${rTexFull}\\).<br>
            Ainsi \\((u_n)\\) est une suite arithm√©tique de premier terme \\(u_0 = ${u0Tex}\\) et de raison \\(r = ${rTexFull}\\).
          </div>

          <div class="step" style="margin-top:.45rem">
            <u>M√©thode 2 : calcul de \\(u_{n+1} - u_n\\)</u>
          </div>
          <div class="step">
            Pour tout entier naturel \\(n\\), on a : <br>
            \\(${canon}\\)
          </div><br>
          <div class="step">
            \\(${uNp1_line1}\\)
          </div>
          <div class="step">
            \\(${uNp1_line2}\\)
          </div>
          <div class="step">
            \\(${uNp1_line3}\\)
          </div><br>
          <div class="step" style="margin-top:.25rem">
            \\(${diff1}\\).
          </div>
          <div class="step">
            \\(${diff2}\\).
          </div>
          <div class="step">
            Alors : \\(u_{n+1} - u_n = ${rTexFull}\\), la diff√©rence est constante.
          </div>
          <div class="step">
            La suite est donc arithm√©tique de premier terme \\(u_0 = ${u0Tex}\\) et de raison \\(r = ${rTexFull}\\).
          </div>
        </div>
      </li>`;
    }else{
      const u0 = seq.u0;
      const u1 = seq.u1;
      const u2 = seq.u2;
      const d1 = seq.d1;
      const d2 = seq.d2;

      const makeCalcLine = (k)=>{
        const kStr = String(k);
        let expr = seq.tex;
        const eqPos = expr.indexOf('=');
        if(eqPos >= 0){
          expr = expr.slice(eqPos + 1).trim();
        }
        let calc = expr;
        calc = calc.replace(/(\d)\s*n\b/g, `$1√ó${kStr}`);
        calc = calc.replace(/(\d)n\b/g, `$1√ó${kStr}`);
        calc = calc.replace(/([+\-])\s*n\b/g, `$1 ${kStr}`);
        calc = calc.replace(/\^n\b/g, `^${kStr}`);
        calc = calc.replace(/\bn\b/g, kStr);
        return `u_${k} = ${calc}`;
      };

      const calc0 = makeCalcLine(0);
      const calc1 = makeCalcLine(1);
      const calc2 = makeCalcLine(2);

      // lignes de diff√©rences SANS -(-...)
      const makeDiffLines = (uk, ukm1, dk, kLabel) => {
        let line1;
        if(ukm1 >= 0){
          line1 = `u_${kLabel} - u_${kLabel-1} = ${texInt(uk)} ‚àí ${texInt(ukm1)}`;
        }else{
          const absPrev = texInt(Math.abs(ukm1));
          line1 = `u_${kLabel} - u_${kLabel-1} = ${texInt(uk)} + ${absPrev}`;
        }
        const line2 = `u_${kLabel} - u_${kLabel-1} = ${texInt(dk)}`;
        return { line1, line2 };
      };

      const diff01 = makeDiffLines(u1,u0,d1,1);
      const diff12 = makeDiffLines(u2,u1,d2,2);

      return `
      <li style="margin-bottom:.6rem">
        <div class="steps">
          <div class="step"><strong>${idx}  \\(${seq.tex}\\)</strong></div>

          <div class="step" style="margin-top:.3rem">
            On calcule les trois premiers termes de la suite :
          </div>

          <div class="step">
            <table style="border-collapse:collapse;border:1px solid #ccc;font-size:.95rem">
              <tbody>
                <tr>
                  <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                    Calcul de \\(u_0\\) (on remplace \\(n\\) par 0)<br>
                    \\(${calc0}\\)<br>
                    \\(u_0 = ${texInt(u0)}\\)
                  </td>
                  <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                    Calcul de \\(u_1\\) (on remplace \\(n\\) par 1)<br>
                    \\(${calc1}\\)<br>
                    \\(u_1 = ${texInt(u1)}\\)
                  </td>
                  <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                    Calcul de \\(u_2\\) (on remplace \\(n\\) par 2)<br>
                    \\(${calc2}\\)<br>
                    \\(u_2 = ${texInt(u2)}\\)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="step" style="margin-top:.35rem">
            On calcule ensuite les diff√©rences successives :
          </div>

          <div class="step">
            <table style="border-collapse:collapse;border:1px solid #ccc;font-size:.95rem">
              <tbody>
                <tr>
                  <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                    \\(${diff01.line1}\\)<br>
                    \\(${diff01.line2}\\)
                  </td>
                  <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                    \\(${diff12.line1}\\)<br>
                    \\(${diff12.line2}\\)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="step" style="margin-top:.35rem">
            \\(${texInt(d1)} \\neq ${texInt(d2)}\\) donc la suite \\((u_n)\\) n‚Äôest pas arithm√©tique.
          </div>
        </div>
      </li>`;
    }

  }).join('');
W.innerHTML = `<ol style="list-style:none;padding-left:0;margin:0">${itemsHtml}</ol>`;

  retypeMath(W);
}


});


/* === Ex. 5 ‚Äî Suites r√©currentes : arithm√©tiques ou non ? (2 suites) === */
L.push({
  id: 'ex5_suite_recurrente',
  title: "Ex. 5 ‚Äî Suites r√©currentes : arithm√©tiques ou non ?",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; },
  _simp(n,d){
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _parseOuiNon(str){
    if(!str) return null;
    let s = String(str).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='o' || s[0]==='y') return true;   // oui / yes
    if(s[0]==='n') return false;                // non
    return null;
  },

  gen(){
    const UMINUS='‚àí';
    const texInt = x => String(x).replace(/-/g,UMINUS);

    // --- 1) suite arithm√©tique : u_{n+1} = u_n + r avec r ‚â† 0 ---
    const makeArith = ()=>{
      let u0 = 0;
      while(u0===0) u0 = rint(-5,5);

      // r entier ou fraction, NON nul
      const kind = choice(['int','frac']);
      let num, den;
      if(kind==='int'){
        num = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
        den = 1;
      }else{
        den = choice([2,3,4]);
        num = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      }
      const simp = this._simp(num,den);
      num = simp.n; den = simp.d;
      const r = num/den;
      if(r===0) return makeArith(); // s√©curit√©

      const rAbsTex = this._fracTex(Math.abs(num),den).replace(/^‚àí/,'');
      const rTex    = this._fracTex(num,den);

      let rec;
      if(num>0){
        rec = `u_{n+1} = u_n + ${rAbsTex}`;
      }else{
        rec = `u_{n+1} = u_n ‚àí ${rAbsTex}`;
      }

      const sys = `\\left\\{\\begin{array}{l}
u_0 = ${texInt(u0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;

      return {
        name:'u',
        kind:'arith',
        isArith:true,
        u0,
        r,
        rNum:num,
        rDen:den,
        tex:sys
      };
    };

    // --- 2a) suite g√©om√©trique : v_{n+1} = q v_n avec q ‚â† 1 ---
    const makeGeom = ()=>{
      let v0 = 0;
      while(v0===0) v0 = rint(-5,5);

      let num, den;
      const kind = choice(['int','frac']);
      if(kind==='int'){
        // q entier, ‚â†0, ‚â†1
        num = choice([-4,-3,-2,2,3,4]); // pas 0, pas 1
        den = 1;
      }else{
        den = choice([2,3,4]);
        num = choice([-5,-4,-3,-2,2,3,4,5]); // pas 0
        // √©viter q = ¬±1 : |num| ‚â† den
        if(Math.abs(num)===den) return makeGeom();
      }
      const simp = this._simp(num,den);
      num = simp.n; den = simp.d;
      const q = num/den;

      const qTex = this._fracTex(num,den);
      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${texInt(v0)}\\\\[2pt]
v_{n+1} = ${qTex}v_n
\\end{array}\\right.`;

      return {
        name:'v',
        kind:'geom',
        isArith:false,
        v0,
        q,
        tex:sys
      };
    };

    // --- 2b) suite arithm√©tico-g√©om√©trique : v_{n+1} = a v_n + b (a‚â†1, b‚â†0) ---
    const makeArithGeo = ()=>{
      let v0 = 0;
      while(v0===0) v0 = rint(-5,5);

      let a = choice([-4,-3,-2,2,3,4]); // a ‚â† 0,1
      let b = 0;
      while(b===0) b = rint(-5,5);

      const texInt2 = x => String(x).replace(/-/g,UMINUS);

      let aTex;
      if(a===1)      aTex = '';
      else if(a===-1)aTex = '‚àí';
      else           aTex = texInt2(a);

      let bTex;
      if(b>0) bTex = ' + ' + texInt2(b);
      else    bTex = ' ‚àí ' + texInt2(Math.abs(b));

      const rec = (Math.abs(a)===1)
        ? `v_{n+1} = ${a===1?'': '‚àí'}v_n${bTex}`
        : `v_{n+1} = ${aTex}v_n${bTex}`;

      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${texInt2(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;

      return {
        name:'v',
        kind:'arithgeo',
        isArith:false,
        v0,a,b,
        tex:sys
      };
    };

    // --- 2c) suite v_{n+1} = v_n + affine(n) avec coefficient de n non nul ---
      // --- 2c) suite v_{n+1} = v_n + affine(n) avec coefficient de n non nul ---
    const makeVPlusAffine = ()=>{
      let v0 = 0;
      while(v0===0) v0 = rint(-5,5);

      let alpha = 0;
      while(alpha===0) alpha = choice([-3,-2,-1,1,2,3]);
      let beta = rint(-5,5);

      const texInt2 = x => String(x).replace(/-/g,UMINUS);

      const absA  = Math.abs(alpha);
      const aCore = (absA===1) ? 'n' : `${absA}n`;

      let bPart = '';
      if(beta>0)      bPart = ' + ' + texInt2(beta);
      else if(beta<0) bPart = ' ‚àí ' + texInt2(Math.abs(beta));

      // ‚ñ∫ plus de parenth√®ses et pas de "+ -" :
      //    si alpha>0 :  v_{n+1} = v_n + 2n + 5
      //    si alpha<0 :  v_{n+1} = v_n ‚àí 3n ‚àí 4
      let rec;
      if(alpha > 0){
        rec = `v_{n+1} = v_n + ${aCore}${bPart}`;
      }else{
        rec = `v_{n+1} = v_n ‚àí ${aCore}${bPart}`;
      }

      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${texInt2(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;

      return {
        name:'v',
        kind:'u_plus_affine',
        isArith:false,
        v0,alpha,beta,
        tex:sys
      };
    };


    // suite arithm√©tique (pour l‚Äôune des deux)
       // suite arithm√©tique (pour l‚Äôune des deux)
    const arith = makeArith.call(this);

    // suite non arithm√©tique : au hasard parmi les trois types
    const nonFactories = [makeGeom, makeArithGeo, makeVPlusAffine];
    const non = choice(nonFactories).call(this);

    // ‚ñ∫ On m√©lange seulement l‚ÄôORDRE (a) / (b),
    //   mais on garde les lettres de suite :
    //   (u_n) reste (u_n), (v_n) reste (v_n)
    let seqs;
    if(Math.random() < 0.5){
      seqs = [
        { letter:'a', ...arith },
        { letter:'b', ...non   }
      ];
    }else{
      seqs = [
        { letter:'a', ...non   },
        { letter:'b', ...arith }
      ];
    }

    return { seqs };
  },


  render(host,s){
    host.__state = s;

    const rows = s.seqs.map((seq,i)=>{
      const k = i+1;
      const label = (seq.name==='u') ? '\\((u_n)\\)' : '\\((v_n)\\)';
      return `
        <tr>
          <td>${seq.letter}.</td>
          <td>\\(${seq.tex}\\)</td>
          <td>${mkInput('q'+k,90)} <span id="tq${k}" class="tick"></span></td>
          <td>${mkInput('r_'+k,80)} <span id="tr_${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Les suites \\((u_n)\\) et \\((v_n)\\) sont d√©finies sur \\(\\mathbb{N}\\) par les relations de r√©currence suivantes.
          </p>
          <p>
            Pour chacune d‚Äôelles, pr√©ciser s‚Äôil s‚Äôagit d‚Äôune <strong>suite arithm√©tique</strong> et, le cas √©ch√©ant,
            indiquer sa raison.
          </p>

          <table class="tbl-suites" style="width:100%;font-size:.95rem;margin-top:.4rem">
            <thead>
              <tr>
                <th></th>
                <th>D√©finition r√©currente</th>
                <th>Suite arithm√©tique ?<br><span style="font-size:.85em">(√©crire ¬´ oui ¬ª ou ¬´ non ¬ª)</span></th>
                <th>Si oui, raison \\(r\\)</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.seqs.forEach((seq,i)=>{
      const k = i+1;
      const ynStr = val('q'+k);
      const rStr  = val('r_'+k);

      const tYN = $('#tq'+k,host);
      const tR  = $('#tr_'+k,host);

      const yn = this._parseOuiNon(ynStr);

      if(yn===null){
        allFilled = false;
        tickTri(tYN,null);
      }else{
        const okYN = (yn === seq.isArith);
        tickTri(tYN, okYN);
        if(okYN===false) allOk=false;
      }

      if(seq.isArith){
        if(!rStr) allFilled = false;
        const okR = rStr==='' ? null : near(parseNumber(rStr), seq.r);
        tickTri(tR, okR);
        if(okR===false) allOk=false;
      }else{
        // non arithm√©tique : la case raison doit rester vide
        if(rStr){
          tickTri(tR,false);
          allOk=false;
        }else{
          tickTri(tR,null);
        }
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

       solution(host){
    const s = host.__state;
    const W = $('#steps',host);
    const UMINUS = '‚àí';

    const texInt = x => String(x).replace(/-/g, UMINUS);

    // ===== helpers fractions (en s'appuyant sur _simp et _fracTex) =====
    const simp    = (n,d) => this._simp(n,d);
    const fracTex = (n,d) => this._fracTex(n,d);

    const fInt  = n     => ({ n, d:1 });
    const fFrac = (n,d) => simp(n,d);
    const fAdd  = (A,B) => simp(A.n*B.d + B.n*A.d, A.d*B.d);
    const fSub  = (A,B) => simp(A.n*B.d - B.n*A.d, A.d*B.d);
    const fMul  = (A,B) => simp(A.n*B.n, A.d*B.d);
    const fTex  = F     => fracTex(F.n, F.d);

    const approxFrac = (x)=>{
      const maxD = 10;
      for(let d=1; d<=maxD; d++){
        const n = Math.round(x*d);
        if(Math.abs(n/d - x) < 1e-9) return fFrac(n,d);
      }
      return fInt(Math.round(x));
    };

    const parenIfNegTex = F => F.n < 0 ? `(${fTex(F)})` : fTex(F);

    const items = s.seqs.map(seq => {
      const label = seq.letter + ')';
      const name  = seq.name;   // "u" ou "v"

      /* ========== 1) CAS SUITE ARITHM√âTIQUE ========== */
      if (seq.isArith){
        const u0F   = fInt(seq.u0);
        const rF    = fFrac(seq.rNum, seq.rDen); // on garde la VRAIE fraction
        const u0Tex = fTex(u0F);
        const rTex  = fTex(rF);

        const rAbsF   = fFrac(Math.abs(rF.n), rF.d);
        const rAbsTex = fTex(rAbsF);

        let recExplain;
        if (rF.n > 0){
          recExplain = `${name}_{n+1} = ${name}_n + ${rAbsTex}`;
        } else if (rF.n < 0){
          recExplain = `${name}_{n+1} = ${name}_n ‚àí ${rAbsTex}`;
        } else {
          recExplain = `${name}_{n+1} = ${name}_n`;
        }

        return `
          <li style="margin-bottom:.6rem">
            <div class="steps">
              <div class="step">
                <strong>${label}</strong> \\(${seq.tex}\\)
              </div>

              <div class="step" style="margin-top:.35rem">
                Pour tout entier naturel \\(n\\), on a : \\(${recExplain}\\).
              </div>

              <div class="step">
                Pour passer d‚Äôun terme au suivant, on ajoute toujours \\(${rTex}\\).
              </div>

              <div class="step">
                Ainsi la suite \\((${name}_n)\\) est une suite arithm√©tique
                de raison \\(r = ${rTex}\\) (et de premier terme \\(${name}_0 = ${u0Tex}\\)).
              </div>
            </div>
          </li>`;
      }

      /* ========== 2) CAS SUITE NON ARITHM√âTIQUE ========== */
      // On calcule 3 termes EN FRACTION + d√©tail des calculs de ${name}_1 et ${name}_2

      let u0F;
      if (typeof seq.u0 === 'number')       u0F = fInt(seq.u0);
      else if (typeof seq.v0 === 'number')  u0F = fInt(seq.v0);
      else                                  u0F = fInt(0);

      let u1F, u2F;
      let calc1Lines = [];   // lignes pour ${name}_1
      let calc2Lines = [];   // lignes pour ${name}_2

      /* ---- a) Suite g√©om√©trique : v_{n+1} = q v_n ---- */
      if (seq.kind === 'geom'){
        const qF   = approxFrac(seq.q);
        const qTex = fTex(qF);

        u1F = fMul(qF, u0F);
        calc1Lines = [
          `\\(${name}_1 = ${qTex}${name}_0\\)`,
          `\\(${name}_1 = ${qTex}\\times ${parenIfNegTex(u0F)}\\)`,
          `\\(${name}_1 = ${fTex(u1F)}\\)`
        ];

        u2F = fMul(qF, u1F);
        calc2Lines = [
          `\\(${name}_2 = ${qTex}${name}_1\\)`,
          `\\(${name}_2 = ${qTex}\\times ${parenIfNegTex(u1F)}\\)`,
          `\\(${name}_2 = ${fTex(u2F)}\\)`
        ];
      }

      /* ---- b) Suite arithm√©tico-g√©om√©trique : v_{n+1} = a v_n + b ---- */
      else if (seq.kind === 'arithgeo'){
        const aF   = fInt(seq.a);
        const bF   = fInt(seq.b);
        const aTex = fTex(aF);
        const bAbsTex = fTex(fFrac(Math.abs(bF.n), bF.d));
        const signB = (bF.n >= 0) ? '+' : '‚àí';

        u1F = fAdd(fMul(aF, u0F), bF);
        calc1Lines = [
          `\\(${name}_1 = ${aTex}${name}_0 ${signB} ${bAbsTex}\\)`,
          `\\(${name}_1 = ${aTex}\\times ${parenIfNegTex(u0F)} ${signB} ${bAbsTex}\\)`,
          `\\(${name}_1 = ${fTex(u1F)}\\)`
        ];

        u2F = fAdd(fMul(aF, u1F), bF);
        calc2Lines = [
          `\\(${name}_2 = ${aTex}${name}_1 ${signB} ${bAbsTex}\\)`,
          `\\(${name}_2 = ${aTex}\\times ${parenIfNegTex(u1F)} ${signB} ${bAbsTex}\\)`,
          `\\(${name}_2 = ${fTex(u2F)}\\)`
        ];
      }

      /* ---- c) Suite v_{n+1} = v_n + (affine en n) ---- */
      else { // seq.kind === 'u_plus_affine'
        const aF       = fInt(seq.alpha);
        const bF       = fInt(seq.beta);
        const aAbsTex  = fTex(fFrac(Math.abs(aF.n), aF.d));
        const bAbsTex  = fTex(fFrac(Math.abs(bF.n), bF.d));
        const signA    = (aF.n >= 0) ? ' + ' : ' ‚àí ';
        const signB    = (bF.n >= 0) ? ' + ' : ' ‚àí ';

        // n = 0
        u1F = fAdd(u0F, bF);  // car Œ±¬∑0 = 0
        calc1Lines = [
          `\\(${name}_1 = ${name}_0${signA}${aAbsTex}\\times 0${signB}${bAbsTex}\\)`,
          `\\(${name}_1 = ${name}_0${signB}${bAbsTex}\\)`,
  `\\(${name}_1 = ${fTex(u0F)}${signB}${bAbsTex}\\)`,
          `\\(${name}_1 = ${fTex(u1F)}\\)`
        ];

        // n = 1
        const aPlusbF       = fAdd(aF, bF);
        const aPlusbAbsTex  = fTex(fFrac(Math.abs(aPlusbF.n), aPlusbF.d));
        const signApB       = (aPlusbF.n >= 0) ? ' + ' : ' ‚àí ';

        u2F = fAdd(u1F, aPlusbF);

        calc2Lines = [
          `\\(${name}_2 = ${name}_1${signA}${aAbsTex}\\times 1${signB}${bAbsTex}\\)`,
          `\\(${name}_2 = ${name}_1${signA}${aAbsTex}${signB}${bAbsTex}\\)`,
          `\\(${name}_2 = ${name}_1${signApB}${aPlusbAbsTex}\\)`,
  `\\(${name}_2 = ${fTex(u1F)}${signApB}${aPlusbAbsTex}\\)`,
          `\\(${name}_2 = ${fTex(u2F)}\\)`
        ];
      }

      const d1F = fSub(u1F, u0F);
      const d2F = fSub(u2F, u1F);

      const u0Tex = fTex(u0F);
      const d1Tex = fTex(d1F);
      const d2Tex = fTex(d2F);

      const diffLines = (Uk, Ukm1, Dk, kLabel) => {
        const UkTex   = fTex(Uk);
        const Ukm1Tex = fTex(Ukm1);
        const Ukm1Abs = fTex(fFrac(Math.abs(Ukm1.n), Ukm1.d));

        let l1;
        if (Ukm1.n >= 0){
          l1 = `${name}_${kLabel} - ${name}_${kLabel-1} = ${UkTex} ‚àí ${Ukm1Tex}`;
        } else {
          // pas de "-(-‚Ä¶)", on passe directement en "+"
          l1 = `${name}_${kLabel} - ${name}_${kLabel-1} = ${UkTex} + ${Ukm1Abs}`;
        }
        const l2 = `${name}_${kLabel} - ${name}_${kLabel-1} = ${fTex(Dk)}`;
        return { l1, l2 };
      };

      const diff01 = diffLines(u1F, u0F, d1F, 1);
      const diff12 = diffLines(u2F, u1F, d2F, 2);

      return `
        <li style="margin-bottom:.6rem">
          <div class="steps">
            <div class="step">
              <strong>${label}</strong> \\(${seq.tex}\\)
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule les trois premiers termes de la suite en appliquant la relation de r√©currence :
            </div>

            <div class="step">
              <table style="border-collapse:collapse;border:1px solid #ccc;font-size:.95rem">
                <tbody>
                  <tr>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      \\(${name}_0 = ${u0Tex}\\)
                    </td>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      ${calc1Lines.join('<br>')}
                    </td>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      ${calc2Lines.join('<br>')}
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule ensuite les diff√©rences successives :
            </div>

            <div class="step">
              <table style="border-collapse:collapse;border:1px solid #ccc;font-size:.95rem">
                <tbody>
                  <tr>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      \\(${diff01.l1}\\)<br>
                      \\(${diff01.l2}\\)
                    </td>
                    <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                      \\(${diff12.l1}\\)<br>
                      \\(${diff12.l2}\\)
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="step" style="margin-top:.35rem">
              \\(${d1Tex} \\neq ${d2Tex}\\) donc la diff√©rence entre deux termes successifs
              n‚Äôest pas constante.
            </div>
            <div class="step">
              La suite \\((${name}_n)\\) n‚Äôest donc <strong>pas arithm√©tique</strong>.
            </div>
          </div>
        </li>`;
    }).join('');

W.innerHTML = `<ol style="list-style:none;padding-left:0;margin:0">${items}</ol>`;
    retypeMath(W);
  }



});


  return L;
}

/* ===== REGISTRY & UI (m√™mes hooks que ton mod√®le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // Entr√©e => V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d‚Äôaffichage :</b> ${e.message}<br>Ouvre la console pour le d√©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit pr√™t et que le kit soit charg√©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: '1√®re - Suites arithm√©tiques - Terme g√©n√©ral - Reconna√Ætre une suite arithm√©tique (formule explicite) - Variations',
        max: 50,
        // Monte l'UI PDF juste apr√®s ta carte "Saisie & r√©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte d‚Äôamorce par type (affich√© avant chaque exo dans le PDF)
                // Optionnel : laisse √† false pour ne pas lancer l‚Äôimpression automatiquement
        autoPrint: false
      });
    } else {
      // r√©essaie bri√®vement si le kit ou REGISTRY n‚Äôest pas encore pr√™ts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui √©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas r√©f√©rencer ok4 si la Q(b) est comment√©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un √©ventuel tick fant√¥me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit s‚Äô√©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
