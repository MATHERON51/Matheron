<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1√®re - Suites g√©om√©triques - D√©finition - Reconna√Ætre une suite arithm√©tique (formule de r√©currence)</title>

<!-- m√™mes feuilles que ton mod√®le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles √† l‚Äô√©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de r√©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}

.tbl-suites{
  border-collapse:collapse;
  border:1px solid #ccc;
}
.tbl-suites th,
.tbl-suites td{
  border:1px solid #ccc;
  padding:4px 6px;
}


ul.no-bullet{
  list-style:none;
  padding-left:0;
  margin-left:0;
}


</style>

<!-- MathJax comme dans ton mod√®le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- m√™mes libs partag√©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re - Suites g√©om√©triques - D√©finition - Reconna√Ætre une suite arithm√©tique (formule de r√©currence)</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contr√¥le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- H√¥te d‚Äôexercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & r√©ponses accept√©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> accept√©es
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenth√®ses/accolades, soulign√©s, <code>*</code> ou <code>√ó</code> sont normalis√©s).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = '‚àí';

/* ===== Utilitaires g√©n√©riques (m√™mes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tol√®re u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, √ó, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/√ó|\*/g,'');
  s = s.replace(/[‚àí‚Äì‚Äî]/g,'-');

  // normaliser les √©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'‚úì':'‚úó'; }
// ‚úì / ‚úó / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] ‚Üí an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "‚àí" coll√©s
  let s = parts.join(' + ').replace(/\+\s*‚àí/g, UMINUS).replace(/‚àí\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/‚àí en LaTeX
  s = s.replace(/\+/g,'+').replace(/‚àí/g, UMINUS);
  return s || '0';
}

function makeExos(){
  const L = [];

/* === Ex. 1 ‚Äî Suite g√©om√©trique (u0 et q) === */
L.push({
  id: 'ex1_suite_arith', // on garde l'id pour ne rien casser ailleurs
  title: "Ex. 1 ‚Äî Suite g√©om√©trique (u_0 et raison q)",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){
    if(d===0) return {n:NaN,d:0};
    if(d<0){n=-n;d=-d;}
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    if(d===0) return '\\text{ind√©fini}';
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },

  _parseSens(raw){
    if(!raw) return null;
    let s = String(raw).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='c') return 'croissante';
    if(s[0]==='d') return 'd√©croissante';
    if(s.includes('const')) return 'constante';
    return null;
  },

  // u_n = u0 * q^n
  // u_n = u0 * q^n
  _evalFormulaOk(input, cas){
    if(!input) return null;

    // On part du texte brut
    let rhs = String(input);

    // Si l'√©l√®ve tape "u(n)=..." ou "u_n = ...", on garde juste ce qui est apr√®s le =
    const eqPos = rhs.indexOf('=');
    if(eqPos >= 0) rhs = rhs.slice(eqPos + 1);

    rhs = rhs.trim();
    if(!rhs) return false;

    // Normalisation minimale
    rhs = rhs
      .replace(/\s+/g,'')           // espaces
      .replace(/[‚àí‚Äì‚Äî]/g,'-')        // tous les "‚àí"
      .replace(/,/g,'.')            // virgule d√©cimale √©ventuelle
      .replace(/\\cdot/g,'*')
      .replace(/[√ó¬∑]/g,'*');

    // Multiplications implicites √©ventuelles : 4(‚Ä¶), (‚Ä¶)(‚Ä¶), 4n, n4
    rhs = rhs
      .replace(/(\d|\))\(/g,'$1*(')
      .replace(/\)(\d|\()/g,')*$1')
      .replace(/(\d)n/g,'$1*n')
      .replace(/n(\d)/g,'n*$1');

    // Remplacer u0 et q s'ils sont utilis√©s
    rhs = rhs.replace(/u_\{?0\}?|u0/g, `(${cas.u0})`);
    rhs = rhs.replace(/\bq\b/g, `(${cas.q})`);

    // Si jamais l'√©l√®ve a mis u(n) ou u_n dans la formule explicite, on le
    // remplace aussi par u0*q^n
    const uExpr = `(${cas.u0})*(${cas.q})**n`;
    rhs = rhs.replace(/u_\{?n\}?/g, uExpr);
    rhs = rhs.replace(/u\(\s*n\s*\)/g, uExpr);

    // Puissances clavier ^
    rhs = rhs.replace(/\^/g,'**');

    // On ne doit plus avoir que chiffres, n, (), + - * / . maintenant
    if(/[^0-9n()+\-*/.]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => cas.u0 * Math.pow(cas.q, n);
    const tests = [0,1,2,5];

    try{
      for(const n of tests){
        const v = Number(f(n));
        if(!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },




    // u_{n+1} = q u_n
  _evalRecurrenceOk(input, cas){
    if(!input) return null;

    let s = normRelation(input);

    const parts = s.split('=');
    let rhs = parts[parts.length-1];
    if(!rhs) return false;

    // on enl√®ve tous les espaces
    rhs = rhs.replace(/\s+/g,'');

    rhs = rhs
      .replace(/[‚àí‚Äì‚Äî]/g,'-')
      .replace(/\\cdot/g,'*')
      .replace(/[√ó¬∑]/g,'*');

    // produits implicites avec u_n ou u(n)
    // 4u(n), 4u_n, (5/8)u(n), (5/8)u_n, u(n)4, u_n4, u(n)(...), u_n(...)
    rhs = rhs
      .replace(/(\d|\))\s*(u\(\s*n\s*\)|u_\{?n\}?)/g, '$1*$2')
      .replace(/(u\(\s*n\s*\)|u_\{?n\}?)(\d|\()/g, '$1*$2');

    // u_n / u(n) -> u0*q^n
    const uExpr = `(${cas.u0})*(${cas.q})**n`;
    rhs = rhs.replace(/u_\{?n\}?/g, uExpr);      // u_n, u_{n}
    rhs = rhs.replace(/u\(\s*n\s*\)/g, uExpr);   // u(n)

    // u0 et q √©ventuels
    rhs = rhs
      .replace(/u_\{?0\}?|u0/g, `(${cas.u0})`)
      .replace(/\bq\b/g, `(${cas.q})`);

    // 4n, n4
    rhs = rhs.replace(/(\d)n/g,'$1*n');
    rhs = rhs.replace(/n(\d)/g,'n*$1');

    // puissances clavier ^
    rhs = rhs.replace(/\^/g,'**');

    // seuls chiffres, n, (), + - * / . , sont autoris√©s
    if(/[^0-9n()+\-*/.,]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => cas.u0 * Math.pow(cas.q, n+1);
    const tests = [0,1,2,5];

    try{
      for(const n of tests){
        const v = Number(f(n));
        if(!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },




  gen(){
    const N = 10; // u_10

    const buildCase = (u0, num, den)=>{
      const q   = num / den;
      const isFrac = den !== 1;
      const u1  = u0 * q;
      const u2  = u1 * q;
      const uN  = u0 * Math.pow(q,N);

      // sens de variation
      let sens;
      if(q > 1){
        if(u0 > 0) sens = 'croissante';
        else if(u0 < 0) sens = 'd√©croissante';
        else sens = 'constante';
      }else{ // 0<q<1
        if(u0 > 0) sens = 'd√©croissante';
        else if(u0 < 0) sens = 'croissante';
        else sens = 'constante';
      }

      return {
        u0, q, num, den,
        isFrac,
        u1, u2, uN,
        N,
        sens
      };
    };

    const cases = [];

    // 1) u0 > 0, q entier > 1
    cases.push(
      buildCase(
        rint(2,10),      // u0 > 0, jamais 1
        rint(2,5),       // q = 2..5
        1
      )
    );

    // 2) u0 < 0, q entier > 1
    cases.push(
      buildCase(
        rint(-10,-2),    // u0 < 0, jamais -1
        rint(2,5),
        1
      )
    );

    // 3) u0 > 0, 0<q<1 fraction
    (()=>{
      const u0 = rint(2,10);
      const den = choice([2,3,4,5,6,8,9]);
      const num = rint(1,den-1); // 0<num<den
      cases.push(buildCase(u0,num,den));
    })();

    // 4) u0 < 0, 0<q<1 fraction
    (()=>{
      const u0 = rint(-10,-2);
      const den = choice([2,3,4,5,6,8,9]);
      const num = rint(1,den-1);
      cases.push(buildCase(u0,num,den));
    })();

    // m√©lange
    for(let i=cases.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [cases[i],cases[j]] = [cases[j],cases[i]];
    }

    return { cases };
  },

  render(host, s){
    host.__state = s;

    const listItems = s.cases.map((c,idx)=>{
      const k = idx+1;
      const UMINUS='‚àí';
      const texInt = x => String(x).replace(/-/g,UMINUS);
      const u0T = texInt(c.u0);
      const qT  = this._fracTex(c.num,c.den);
      return `\\(${k}.\\ u_0 = ${u0T}\\ \\text{ et }\\ q = ${qT}\\quad\\)`;
    }).join(' ');

    const rowsHtml = s.cases.map((c,idx)=>{
      const k = idx+1;
      return `
        <tr>
          <td>\\(${k}.\\)</td>
          <td>\\(u_1=\\) ${mkInput('a'+k+'1',80)} <span id="ta${k}1" class="tick"></span></td>
          <td>\\(u_2=\\) ${mkInput('a'+k+'2',80)} <span id="ta${k}2" class="tick"></span></td>
          <td>${mkInput('b'+k,170)} <span id="tb${k}" class="tick"></span></td>

        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(q\\) d‚Äôune suite g√©om√©trique.</p>
          <p>${listItems}</p>

          <p>Pour chacun des cas :</p>
          <ul class="no-bullet">
            <li>a) D√©terminer \\(u_1\\) et \\(u_2\\).</li>
            <li>b) Exprimer \\(u_{n+1}\\) en fonction de \\(u_n\\).</li>

          </ul>

          <table style="border-collapse:collapse;width:50%;font-size:.95rem">
            <thead>
              <tr>
                <th></th>
                <th>a) \\(u_1\\)</th>
                <th>a) \\(u_2\\)</th>
                <th>b) \\(u_{n+1}\\) en fonction de \\(u_n\\)</th>

              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>

          <div class="equ-offscreen" style="display:none">
            <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(q\\) d‚Äôune suite g√©om√©trique.</p>
            <p>${listItems}</p>
          </div>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.cases.forEach((cas,idx)=>{
      const k = idx+1;

      const v11 = val('a'+k+'1').trim();
      const v12 = val('a'+k+'2').trim();
      const vb  = val('b'+k).trim();
      const vc  = val('c'+k).trim();
      const vd  = val('d'+k).trim();
      const ve  = val('e'+k).trim();

      if(!v11 || !v12 || !vb || !vc || !vd || !ve) allFilled = false;

      const ok11 = v11==='' ? null : near(parseNumber(v11), cas.u1);
      const ok12 = v12==='' ? null : near(parseNumber(v12), cas.u2);

      const okb  = vb==='' ? null : this._evalRecurrenceOk(vb, cas);
      const okc  = vc==='' ? null : this._evalFormulaOk(vc, cas);
      const okd  = vd==='' ? null : near(parseNumber(vd), cas.uN);

      const sensUser = this._parseSens(ve);
      const oke = ve==='' ? null : (sensUser === cas.sens);

      tickTri($('#ta'+k+'1',host), ok11);
      tickTri($('#ta'+k+'2',host), ok12);
      tickTri($('#tb'+k,host),    okb);
      tickTri($('#tc'+k,host),    okc);
      tickTri($('#td'+k,host),    okd);
      tickTri($('#te'+k,host),    oke);

      if(ok11===false || ok12===false || okb===false || okc===false || okd===false || oke===false){
        allOk = false;
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

solution(host){
    const s = host.__state;
    const W = $('#steps', host);
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);

    const html = `
      <ol style="padding-left:1.2rem;margin:0">
        ${s.cases.map((cas, idx) => {
          const N    = cas.N;
          const u0T  = texInt(cas.u0);
          const u1T  = texInt(cas.u1);
          const u2T  = texInt(cas.u2);

          const isFrac   = cas.isFrac;
          const qAbsTex  = this._fracTex(Math.abs(cas.num), cas.den);
          const qTex     = this._fracTex(cas.num, cas.den);

          // helper : met des parenth√®ses seulement si le nombre est n√©gatif
          const wrapIfNeg = str => str.startsWith(UMINUS) ? `\\left(${str}\\right)` : str;

          /* ====== a) u1 et u2 ====== */
          let partAHtml;

          if (!isFrac){
            // q entier
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);

            const u0Disp = wrapIfNeg(u0T);
            const u1Disp = wrapIfNeg(u1T);

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = ${qAbsT}  u_0\\)<br>
                      \\(u_1 = ${qAbsT} \\times ${u0Disp}\\)<br>
                      \\(u_1 = ${u1T}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = ${qAbsT}  u_1\\)<br>
                      \\(u_2 = ${qAbsT} \\times ${u1Disp}\\)<br>
                      \\(u_2 = ${u2T}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          } else {
            // q fraction : pas de mise au m√™me d√©nominateur pour la multiplication
            const u1Num   = cas.u0 * cas.num;
            const u1Den   = cas.den;
            const u1Frac  = this._fracTex(u1Num, u1Den);

            const u2Num   = u1Num * cas.num;
            const u2Den   = u1Den * cas.den;
            const u2Frac  = this._fracTex(u2Num, u2Den);

            const u0Disp    = wrapIfNeg(u0T);
            const u1DispFrac = wrapIfNeg(u1Frac);

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = ${qAbsTex}  u_0\\)<br>
                      \\(u_1 = ${qAbsTex} \\times ${u0Disp}\\)<br>
                      \\(u_1 = ${u1Frac}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = ${qAbsTex}  u_1\\)<br>
                      \\(u_2 = ${qAbsTex} \\times ${u1DispFrac}\\)<br>
                      \\(u_2 = ${u2Frac}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          }

          /* ====== b) r√©currence ====== */

          const recGen  = `u_{n+1} = q\\,u_n`;
          let   recNum;
          if(!isFrac){
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);
            recNum = `u_{n+1} = ${qAbsT}\\,u_n`;
          }else{
            recNum = `u_{n+1} = ${qTex}u_n`;
          }

          /* ====== c) explicite (u_n = u_0 q^n) ====== */

          const explGen = `u_n = u_0 q^n`;
          const explU0  = `u_n = ${u0T} q^n`;
          let   explNum;
          if(!isFrac){
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);
            explNum = `u_n = ${u0T} \\times  ${qAbsT}^n`;
          }else{
            explNum = `u_n = ${u0T} \\times \\left(${qTex}\\right)^n`;
          }

          /* ====== d) u_N ====== */
          const linesD = [];

          if (!isFrac){
            // q entier
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);
            const qPow   = Math.pow(cas.q, N);
            const qPowT  = texInt(qPow);
            const uN     = cas.u0 * qPow;
            const uNT    = texInt(uN);

            linesD.push(`u_{${N}} = u_0 \\times ${qAbsT}^{${N}}`);
            linesD.push(`u_{${N}} = ${u0T} \\times ${qPowT}`);
            linesD.push(`u_{${N}} = ${uNT}`);
          } else {
            // q fraction, grandes parenth√®ses pour q^N
            const qPowNum = Math.pow(cas.num, N);
            const qPowDen = Math.pow(cas.den, N);
            const qPowF   = this._simp(qPowNum, qPowDen);
            const qPowTex = this._fracTex(qPowF.n, qPowF.d);

            const uNNum   = cas.u0 * qPowF.n;
            const uNDen   = qPowF.d;
            const uNF     = this._simp(uNNum, uNDen);
            const uNTex   = this._fracTex(uNF.n, uNF.d);

            linesD.push(`u_{${N}} = ${u0T} \\times \\left(${qTex}\\right)^{${N}}`);
            linesD.push(`u_{${N}} = ${u0T} \\times ${qPowTex}`);
            linesD.push(`u_{${N}} = ${uNTex}`);
          }

          /* ====== e) sens de variation ====== */
          let varTex;
          if(cas.q > 1){
            if(cas.u0 > 0){
              varTex = `q > 1 \\text{ et } u_0 > 0 \\Rightarrow (u_n) \\text{ est croissante sur } \\mathbb{N}.`;
            }else if(cas.u0 < 0){
              varTex = `q > 1 \\text{ et } u_0 < 0 \\Rightarrow (u_n) \\text{ est d√©croissante sur } \\mathbb{N}.`;
            }else{
              varTex = `u_0 = 0 \\Rightarrow (u_n) \\text{ est constante.}`;
            }
          } else {
            // 0 < q < 1
            if(cas.u0 > 0){
              varTex = `0 < q < 1 \\text{ et } u_0 > 0 \\Rightarrow (u_n) \\text{ est d√©croissante sur } \\mathbb{N}.`;
            }else if(cas.u0 < 0){
              varTex = `0 < q < 1 \\text{ et } u_0 < 0 \\Rightarrow (u_n) \\text{ est croissante sur } \\mathbb{N}.`;
            }else{
              varTex = `u_0 = 0 \\Rightarrow (u_n) \\text{ est constante.}`;
            }
          }

          return `
            <li style="margin-bottom:.6rem">
              <div class="steps">
                ${partAHtml}

                <div class="step" style="margin-top:.35rem">
                  <strong>b.</strong> Pour tout entier naturel \\(n\\), on a :<br>
                  \\(${recGen}\\)<br>
                  \\(${recNum}\\)
                </div>

              
              </div>
            </li>`;
        }).join('')}
      </ol>
    `;

    W.innerHTML = html;
    retypeMath(W);
  }






});







/* === Ex. 2 ‚Äî Suites r√©currentes : g√©om√©triques ou non ? === */
L.push({
  id: 'ex2_suite_recurrente',
  title: "Ex. 2 ‚Äî Suites r√©currentes : g√©om√©triques ou non ?",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; },
  _simp(n,d){
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _parseOuiNon(str){
    if(!str) return null;
    let s = String(str).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='o' || s[0]==='y') return true;
    if(s[0]==='n') return false;
    return null;
  },

  gen(){
    const UMINUS='‚àí';
    const texInt = x => String(x).replace(/-/g,UMINUS);

    // (1) Vraie suite g√©om√©trique : u_{n+1} = q u_n
    const makeGeom = ()=>{
      let u0 = 0;
      while(u0===0) u0 = rint(-6,6);
      const q = choice([2,3,4,5]);
      const qTex = texInt(q);
      const sys = `\\left\\{\\begin{array}{l}
u_0 = ${texInt(u0)}\\\\[2pt]
u_{n+1} = ${qTex}u_n
\\end{array}\\right.`;
      return {
        name:'u',
        kind:'geom',
        isGeom:true,
        u0,q,
        tex:sys
      };
    };

    // (2) Suite non g√©om√©trique : au hasard parmi trois types
    const makeArith = ()=>{
      let v0=0;
      while(v0===0) v0=rint(-6,6);
      let r=0;
      while(r===0) r=rint(-5,5);
      const UMIN='‚àí';
      const TI = x => String(x).replace(/-/g,UMIN);
      const rAbsTex = TI(Math.abs(r));
      const rec = (r>0)
        ? `v_{n+1} = v_n + ${rAbsTex}`
        : `v_{n+1} = v_n ‚àí ${rAbsTex}`;
      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${TI(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;
      return {
        name:'v',
        kind:'arith',
        isGeom:false,
        v0,r,
        tex:sys
      };
    };

    const makeArithGeo = ()=>{
      let v0=0;
      while(v0===0) v0=rint(-6,6);
      let a = choice([-4,-3,-2,2,3,4]);
      let b = 0;
      while(b===0) b=rint(-5,5);
      const UMIN= '‚àí';
      const TI = x => String(x).replace(/-/g,UMIN);
      let aTex;
      if(a===1)      aTex = '';
      else if(a===-1)aTex = '‚àí';
      else           aTex = TI(a);
      let bTex;
      if(b>0) bTex = ' + ' + TI(b);
      else    bTex = ' ‚àí ' + TI(-b);
      const rec = (Math.abs(a)===1)
        ? `v_{n+1} = ${a===1?'':'‚àí'}v_n${bTex}`
        : `v_{n+1} = ${aTex}v_n${bTex}`;
      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${TI(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;
      return {
        name:'v',
        kind:'arithgeo',
        isGeom:false,
        v0,a,b,
        tex:sys
      };
    };

    const makeVPlusAffine = ()=>{
      let v0=0;
      while(v0===0) v0=rint(-6,6);
      let alpha=0;
      while(alpha===0) alpha = choice([-3,-2,-1,1,2,3]);
      let beta=rint(-5,5);
      const UMIN='‚àí';
      const TI = x => String(x).replace(/-/g,UMIN);

      const absA = Math.abs(alpha);
      const aCore = (absA===1)?'n':`${absA}n`;
      let bPart='';
      if(beta>0)      bPart = ' + ' + TI(beta);
      else if(beta<0) bPart = ' ‚àí ' + TI(-beta);

      let rec;
      if(alpha>0) rec = `v_{n+1} = v_n + ${aCore}${bPart}`;
      else        rec = `v_{n+1} = v_n ‚àí ${aCore}${bPart}`;

      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${TI(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;
      return {
        name:'v',
        kind:'u_plus_affine',
        isGeom:false,
        v0,alpha,beta,
        tex:sys
      };
    };

    const geom = makeGeom();

    const nonFactories = [makeArith, makeArithGeo, makeVPlusAffine];
    const non = choice(nonFactories)();

    let seqs;
    if(Math.random()<0.5){
      seqs = [
        {letter:'a', ...geom},
        {letter:'b', ...non}
      ];
    }else{
      seqs = [
        {letter:'a', ...non},
        {letter:'b', ...geom}
      ];
    }

    return { seqs };
  },

  render(host,s){
    host.__state = s;

    const rows = s.seqs.map((seq,i)=>{
      const k=i+1;
      return `
        <tr>
          <td>${seq.letter}.</td>
          <td>\\(${seq.tex}\\)</td>
          <td>${mkInput('q'+k,90)} <span id="tq${k}" class="tick"></span></td>
          <td>${mkInput('r_'+k,80)} <span id="tr_${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Les suites \\((u_n)\\) et \\((v_n)\\) sont d√©finies sur \\(\\mathbb{N}\\) par les relations de r√©currence suivantes.
          </p>
          <p>
            Pour chacune d‚Äôelles, pr√©ciser s‚Äôil s‚Äôagit d‚Äôune <strong>suite g√©om√©trique</strong> et, le cas √©ch√©ant,
            indiquer sa raison \\(q\\).
          </p>

          <table class="tbl-suites" style="width:100%;font-size:.95rem;margin-top:.4rem">
            <thead>
              <tr>
                <th></th>
                <th>D√©finition r√©currente</th>
                <th>Suite g√©om√©trique ?<br><span style="font-size:.85em">(√©crire ¬´ oui ¬ª ou ¬´ non ¬ª)</span></th>
                <th>Si oui, raison \\(q\\)</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.seqs.forEach((seq,i)=>{
      const k = i+1;
      const ynStr = val('q'+k);
      const rStr  = val('r_'+k);

      const tYN = $('#tq'+k,host);
      const tR  = $('#tr_'+k,host);

      const yn = this._parseOuiNon(ynStr);

      if(yn===null){
        allFilled = false;
        tickTri(tYN,null);
      }else{
        const okYN = (yn === seq.isGeom);
        tickTri(tYN, okYN);
        if(okYN===false) allOk=false;
      }

      if(seq.isGeom){
        if(!rStr) allFilled = false;
        const okR = rStr==='' ? null : near(parseNumber(rStr), seq.q);
        tickTri(tR, okR);
        if(okR===false) allOk=false;
      }else{
        if(rStr){
          tickTri(tR,false);
          allOk=false;
        }else{
          tickTri(tR,null);
        }
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },
  solution(host){
    const s = host.__state;
    const W = $('#steps',host);
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);
    const fracTex = (n,d)=>this._fracTex(n,d);
    const simp = (n,d)=>this._simp(n,d);

    const wrapIfNeg = t => String(t).startsWith(UMINUS) ? `\\left(${t}\\right)` : t;

    const items = s.seqs.map(seq=>{
      const label = seq.letter + ')';
      const name  = seq.name; // "u" ou "v"

      /* ===== CAS G√âOM√âTRIQUE : u_{n+1} = q u_n ===== */
      if(seq.isGeom){
        const u0 = seq.u0;
        const q  = seq.q;
        const u1 = u0 * q;
        const u2 = u1 * q;

        const u0Tex = texInt(u0);
        const qTex  = texInt(q);
        const u1Tex = texInt(u1);
        const u2Tex = texInt(u2);

        const u0Disp = wrapIfNeg(u0Tex);
        const u1Disp = wrapIfNeg(u1Tex);

        return `
          <li style="margin-bottom:.6rem">
            <div class="steps">
              <div class="step">
                <strong>${label}</strong> \\(${seq.tex}\\)
              </div>

              <div class="step" style="margin-top:.35rem">
               On reconnait pour tout entier naturel \\(n\\), \\(${name}_{n+1}=q ${name}_{n}\\) avec \\(q=${qTex}\\).<br>
Pour passer d‚Äôun terme au suivant on multiplie toujours par \\(${qTex}\\).<br>
Ainsi \\((${name}_{n})\\) est une suite g√©om√©trique de premier terme \\(${name}_0=${u0Tex}\\) et de raison \\(q=${qTex}\\).

              </div>

              
            </div>
          </li>`;
      }

      /* ===== CAS NON G√âOM√âTRIQUE ===== */

      // On calcule v0, v1, v2 suivant le type
      let u0,u1,u2;

      if(seq.kind==='arith'){
        u0 = seq.v0;
        u1 = u0 + seq.r;
        u2 = u1 + seq.r;
      }else if(seq.kind==='arithgeo'){
        u0 = seq.v0;
        u1 = seq.a*u0 + seq.b;
        u2 = seq.a*u1 + seq.b;
      }else{ // u_plus_affine : v_{n+1} = v_n + (alpha n + beta)
        const a = seq.alpha;
        const b = seq.beta;
        u0 = seq.v0;
        const aff0 = a*0 + b;
        const aff1 = a*1 + b;
        u1 = u0 + aff0;
        u2 = u1 + aff1;
      }

      const u0Tex = texInt(u0);
      const u1Tex = texInt(u1);
      const u2Tex = texInt(u2);
      const u0Disp = wrapIfNeg(u0Tex);
      const u1Disp = wrapIfNeg(u1Tex);

      // ===== Tableau d√©taill√© "Calcul de v0, v1, v2" =====

      let col0 = `
        <strong>Calcul de \\(${name}_0\\)</strong><br>
        \\(${name}_0 = ${texInt(seq.v0)}\\)
      `;

      let col1 = '';
      let col2 = '';

      if(seq.kind==='arith'){
        const r = seq.r;
        const rAbsTex = texInt(Math.abs(r));
        const signSym = (r>0) ? ' + ' : ' ‚àí ';

        col1 = `
          <strong>Calcul de \\(${name}_1\\)</strong><br>
          \\(${name}_1 = ${name}_0${signSym}${rAbsTex}\\)<br>
          \\(${name}_1 = ${u0Tex}${signSym}${rAbsTex}\\)<br>
          \\(${name}_1 = ${u1Tex}\\)
        `;

        col2 = `
          <strong>Calcul de \\(${name}_2\\)</strong><br>
          \\(${name}_2 = ${name}_1${signSym}${rAbsTex}\\)<br>
          \\(${name}_2 = ${u1Tex}${signSym}${rAbsTex}\\)<br>
          \\(${name}_2 = ${u2Tex}\\)
        `;
      }
      else if(seq.kind==='arithgeo'){
        const a = seq.a;
        const b = seq.b;
        const bAbsTex = texInt(Math.abs(b));
        const bSign = (b>0)?' + ':' ‚àí ';

        const mult = (coef,symb)=>{
          if(coef===1)  return symb;
          if(coef===-1) return UMINUS + symb;
          return `${texInt(coef)} \\times ${symb}`;
        };

        col1 = `
          <strong>Calcul de \\(${name}_1\\)</strong><br>
          \\(${name}_1 = ${mult(a, name+'_0')}${bSign}${bAbsTex}\\)<br>
          \\(${name}_1 = ${mult(a, u0Disp)}${bSign}${bAbsTex}\\)<br>
          \\(${name}_1 = ${u1Tex}\\)
        `;

        col2 = `
          <strong>Calcul de \\(${name}_2\\)</strong><br>
          \\(${name}_2 = ${mult(a, name+'_1')}${bSign}${bAbsTex}\\)<br>
          \\(${name}_2 = ${mult(a, u1Disp)}${bSign}${bAbsTex}\\)<br>
          \\(${name}_2 = ${u2Tex}\\)
        `;
      }
               else{ // u_plus_affine : v_{n+1} = v_n + (a n + b)
        const a = seq.alpha;
        const b = seq.beta;

        const absA = Math.abs(a);

        // construit "v0 ¬± a√ón ¬± b" SANS parenth√®ses et SANS "+ -"
        const lineExpr = (baseTex, n)=>{
          let s = baseTex;
          if(a !== 0){
            const core = (absA === 1)
              ? String(n)
              : `${texInt(absA)} \\times ${n}`;
            if(a > 0) s += ' + ' + core;
            else      s += ' ‚àí ' + core;
          }
          if(b !== 0){
            if(b > 0) s += ' + ' + texInt(b);
            else      s += ' ‚àí ' + texInt(-b);
          }
          return s;
        };

        const aff0 = a*0 + b;
        const aff1 = a*1 + b;
        const aff0AbsTex = texInt(Math.abs(aff0));
        const aff1AbsTex = texInt(Math.abs(aff1));

        const withSign = (baseTex, val, absTex) =>
          (val >= 0)
            ? `${baseTex} + ${absTex}`
            : `${baseTex} ‚àí ${absTex}`;

        col1 = `
          <strong>Calcul de \\(${name}_1\\)</strong><br>
          \\(${name}_1 = ${lineExpr(name+'_0','0')}\\)<br>
          \\(${name}_1 = ${withSign(u0Tex, aff0, aff0AbsTex)}\\)<br>
          \\(${name}_1 = ${u1Tex}\\)
        `;

        col2 = `
          <strong>Calcul de \\(${name}_2\\)</strong><br>
          \\(${name}_2 = ${lineExpr(name+'_1','1')}\\)<br>
          \\(${name}_2 = ${withSign(u1Tex, aff1, aff1AbsTex)}\\)<br>
          \\(${name}_2 = ${u2Tex}\\)
        `;
      }



      const termsTable = `
        <table style="border-collapse:collapse;margin:.25rem 0;font-size:.95em;width:100%">
          <tr>
            <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
              ${col0}
            </td>
            <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
              ${col1}
            </td>
            <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
              ${col2}
            </td>
          </tr>
        </table>
      `;

      // ===== Rapports successifs avec garde-fou division par 0 =====
      let ratiosBlock = '';
      let conclusion  = '';

      if(u1 !== 0){
        // cas normal : les 2 rapports existent
        const r1 = simp(u1,u0);
        const r2 = simp(u2,u1);
        const r1Tex = fracTex(r1.n,r1.d);
        const r2Tex = fracTex(r2.n,r2.d);

        ratiosBlock = `
          \\[
            \\dfrac{${name}_1}{${name}_0} = \\dfrac{${u1Tex}}{${u0Tex}} = ${r1Tex}
            \\quad\\text{et}\\quad
            \\dfrac{${name}_2}{${name}_1} = \\dfrac{${u2Tex}}{${u1Tex}} = ${r2Tex}.
          \\]
        `;

        conclusion = `
          Comme \\(${r1Tex} \\neq ${r2Tex}\\), les rapports successifs ne sont pas constants,
          donc la suite \\((${name}_n)\\) n‚Äôest pas g√©om√©trique.
        `;
      }else{
        // u1 = 0 : le second rapport n'est pas d√©fini
        const r1 = simp(u1,u0);
        const r1Tex = fracTex(r1.n,r1.d);

        ratiosBlock = `
          \\[
            \\dfrac{${name}_1}{${name}_0} = \\dfrac{${u1Tex}}{${u0Tex}} = ${r1Tex}
            \\quad\\text{et}\\quad
            \\dfrac{${name}_2}{${name}_1} \\text{ n‚Äôest pas d√©fini (division par }0\\text{)}.
          \\]
        `;

        conclusion = `
          Le rapport \\(\\dfrac{${name}_2}{${name}_1}\\) n‚Äôest pas d√©fini car on divise par 0.
          Les rapports successifs ne sont donc pas tous d√©finis : la suite \\((${name}_n)\\)
          ne peut pas √™tre g√©om√©trique.
        `;
      }

      return `
        <li style="margin-bottom:.6rem">
          <div class="steps">
            <div class="step">
              <strong>${label}</strong> \\(${seq.tex}\\)
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule les trois premiers termes de la suite :
            </div>

            <div class="step">
              ${termsTable}
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule ensuite les rapports successifs :
            </div>

            <div class="step">
              ${ratiosBlock}
            </div>

            <div class="step">
              ${conclusion}
            </div>
          </div>
        </li>`;
    }).join('');

    W.innerHTML = `<ol style="list-style:none;padding-left:0;margin:0">${items}</ol>`;
    retypeMath(W);
  }

});



  return L;
}

/* ===== REGISTRY & UI (m√™mes hooks que ton mod√®le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // Entr√©e => V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d‚Äôaffichage :</b> ${e.message}<br>Ouvre la console pour le d√©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit pr√™t et que le kit soit charg√©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: '1√®re - Suites g√©om√©triques - D√©finition - Reconna√Ætre une suite arithm√©tique (formule de r√©currence)',
        max: 50,
        // Monte l'UI PDF juste apr√®s ta carte "Saisie & r√©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte d‚Äôamorce par type (affich√© avant chaque exo dans le PDF)
                // Optionnel : laisse √† false pour ne pas lancer l‚Äôimpression automatiquement
        autoPrint: false
      });
    } else {
      // r√©essaie bri√®vement si le kit ou REGISTRY n‚Äôest pas encore pr√™ts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui √©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas r√©f√©rencer ok4 si la Q(b) est comment√©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un √©ventuel tick fant√¥me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit s‚Äô√©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
