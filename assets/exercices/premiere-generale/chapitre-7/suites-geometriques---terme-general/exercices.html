<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1√®re - Suites g√©om√©triques - Terme g√©n√©ral - Reconna√Ætre une suite g√©om√©trique (formule explicite) - Variations</title>

<!-- m√™mes feuilles que ton mod√®le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles √† l‚Äô√©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de r√©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}

.tbl-suites{
  border-collapse:collapse;
  border:1px solid #ccc;
}
.tbl-suites th,
.tbl-suites td{
  border:1px solid #ccc;
  padding:4px 6px;
}


ul.no-bullet{
  list-style:none;
  padding-left:0;
  margin-left:0;
}


</style>

<!-- MathJax comme dans ton mod√®le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- m√™mes libs partag√©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re - Suites g√©om√©triques - Terme g√©n√©ral - Reconna√Ætre une suite g√©om√©trique (formule explicite) - Variations</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contr√¥le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- H√¥te d‚Äôexercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & r√©ponses accept√©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul>
  <li>Ecritures <em>toutes</em> accept√©es
      <code>u(n+1)=...</code>, <code>u_(n+1)=...</code>, <code>u_{n+1)=...</code>
      (espaces, parenth√®ses/accolades, soulign√©s, <code>*</code> ou <code>√ó</code> sont normalis√©s).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = '‚àí';

/* ===== Utilitaires g√©n√©riques (m√™mes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... :
   - tol√®re u(n+1) / u_(n+1) / u_{n+1) / u_{ n+1 } etc.
   - supprime espaces, √ó, * ; unifie les tirets. */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/√ó|\*/g,'');
  s = s.replace(/[‚àí‚Äì‚Äî]/g,'-');

  // normaliser les √©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}


function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'‚úì':'‚úó'; }
// ‚úì / ‚úó / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
  else { el.textContent=''; } // neutre si vide
}


function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] ‚Üí an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  // joindre en nettoyant les signes "‚àí" coll√©s
  let s = parts.join(' + ').replace(/\+\s*‚àí/g, UMINUS).replace(/‚àí\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  // petits espaces fins autour de +/‚àí en LaTeX
  s = s.replace(/\+/g,'+').replace(/‚àí/g, UMINUS);
  return s || '0';
}

function makeExos(){
  const L = [];

/* === Ex. 1 ‚Äî Suite g√©om√©trique (u0 et q) === */
L.push({
  id: 'ex1_suite_arith', // on garde l'id pour ne rien casser ailleurs
  title: "Ex. 1 ‚Äî Suite g√©om√©trique (u_0 et raison q)",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){
    if(d===0) return {n:NaN,d:0};
    if(d<0){n=-n;d=-d;}
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    if(d===0) return '\\text{ind√©fini}';
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },

  _parseSens(raw){
    if(!raw) return null;
    let s = String(raw).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='c') return 'croissante';
    if(s[0]==='d') return 'd√©croissante';
    if(s.includes('const')) return 'constante';
    return null;
  },

  // u_n = u0 * q^n
  // u_n = u0 * q^n
  _evalFormulaOk(input, cas){
    if(!input) return null;

    // On part du texte brut
    let rhs = String(input);

    // Si l'√©l√®ve tape "u(n)=..." ou "u_n = ...", on garde juste ce qui est apr√®s le =
    const eqPos = rhs.indexOf('=');
    if(eqPos >= 0) rhs = rhs.slice(eqPos + 1);

    rhs = rhs.trim();
    if(!rhs) return false;

    // Normalisation minimale
    rhs = rhs
      .replace(/\s+/g,'')           // espaces
      .replace(/[‚àí‚Äì‚Äî]/g,'-')        // tous les "‚àí"
      .replace(/,/g,'.')            // virgule d√©cimale √©ventuelle
      .replace(/\\cdot/g,'*')
      .replace(/[√ó¬∑]/g,'*');

    // Multiplications implicites √©ventuelles : 4(‚Ä¶), (‚Ä¶)(‚Ä¶), 4n, n4
    rhs = rhs
      .replace(/(\d|\))\(/g,'$1*(')
      .replace(/\)(\d|\()/g,')*$1')
      .replace(/(\d)n/g,'$1*n')
      .replace(/n(\d)/g,'n*$1');

    // Remplacer u0 et q s'ils sont utilis√©s
    rhs = rhs.replace(/u_\{?0\}?|u0/g, `(${cas.u0})`);
    rhs = rhs.replace(/\bq\b/g, `(${cas.q})`);

    // Si jamais l'√©l√®ve a mis u(n) ou u_n dans la formule explicite, on le
    // remplace aussi par u0*q^n
    const uExpr = `(${cas.u0})*(${cas.q})**n`;
    rhs = rhs.replace(/u_\{?n\}?/g, uExpr);
    rhs = rhs.replace(/u\(\s*n\s*\)/g, uExpr);

    // Puissances clavier ^
    rhs = rhs.replace(/\^/g,'**');

    // On ne doit plus avoir que chiffres, n, (), + - * / . maintenant
    if(/[^0-9n()+\-*/.]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => cas.u0 * Math.pow(cas.q, n);
    const tests = [0,1,2,5];

    try{
      for(const n of tests){
        const v = Number(f(n));
        if(!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },




    // u_{n+1} = q u_n
  _evalRecurrenceOk(input, cas){
    if(!input) return null;

    let s = normRelation(input);

    const parts = s.split('=');
    let rhs = parts[parts.length-1];
    if(!rhs) return false;

    // on enl√®ve tous les espaces
    rhs = rhs.replace(/\s+/g,'');

    rhs = rhs
      .replace(/[‚àí‚Äì‚Äî]/g,'-')
      .replace(/\\cdot/g,'*')
      .replace(/[√ó¬∑]/g,'*');

    // produits implicites avec u_n ou u(n)
    // 4u(n), 4u_n, (5/8)u(n), (5/8)u_n, u(n)4, u_n4, u(n)(...), u_n(...)
    rhs = rhs
      .replace(/(\d|\))\s*(u\(\s*n\s*\)|u_\{?n\}?)/g, '$1*$2')
      .replace(/(u\(\s*n\s*\)|u_\{?n\}?)(\d|\()/g, '$1*$2');

    // u_n / u(n) -> u0*q^n
    const uExpr = `(${cas.u0})*(${cas.q})**n`;
    rhs = rhs.replace(/u_\{?n\}?/g, uExpr);      // u_n, u_{n}
    rhs = rhs.replace(/u\(\s*n\s*\)/g, uExpr);   // u(n)

    // u0 et q √©ventuels
    rhs = rhs
      .replace(/u_\{?0\}?|u0/g, `(${cas.u0})`)
      .replace(/\bq\b/g, `(${cas.q})`);

    // 4n, n4
    rhs = rhs.replace(/(\d)n/g,'$1*n');
    rhs = rhs.replace(/n(\d)/g,'n*$1');

    // puissances clavier ^
    rhs = rhs.replace(/\^/g,'**');

    // seuls chiffres, n, (), + - * / . , sont autoris√©s
    if(/[^0-9n()+\-*/.,]/.test(rhs)) return false;

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => cas.u0 * Math.pow(cas.q, n+1);
    const tests = [0,1,2,5];

    try{
      for(const n of tests){
        const v = Number(f(n));
        if(!isFinite(v) || !near(v, expected(n))) return false;
      }
      return true;
    }catch(e){
      return false;
    }
  },




  gen(){
    const N = 10; // u_10

    const buildCase = (u0, num, den)=>{
      const q   = num / den;
      const isFrac = den !== 1;
      const u1  = u0 * q;
      const u2  = u1 * q;
      const uN  = u0 * Math.pow(q,N);

      // sens de variation
      let sens;
      if(q > 1){
        if(u0 > 0) sens = 'croissante';
        else if(u0 < 0) sens = 'd√©croissante';
        else sens = 'constante';
      }else{ // 0<q<1
        if(u0 > 0) sens = 'd√©croissante';
        else if(u0 < 0) sens = 'croissante';
        else sens = 'constante';
      }

      return {
        u0, q, num, den,
        isFrac,
        u1, u2, uN,
        N,
        sens
      };
    };

    const cases = [];

    // 1) u0 > 0, q entier > 1
    cases.push(
      buildCase(
        rint(2,10),      // u0 > 0, jamais 1
        rint(2,5),       // q = 2..5
        1
      )
    );

    // 2) u0 < 0, q entier > 1
    cases.push(
      buildCase(
        rint(-10,-2),    // u0 < 0, jamais -1
        rint(2,5),
        1
      )
    );

    // 3) u0 > 0, 0<q<1 fraction
    (()=>{
      const u0 = rint(2,10);
      const den = choice([2,3,4,5,6,8,9]);
      const num = rint(1,den-1); // 0<num<den
      cases.push(buildCase(u0,num,den));
    })();

    // 4) u0 < 0, 0<q<1 fraction
    (()=>{
      const u0 = rint(-10,-2);
      const den = choice([2,3,4,5,6,8,9]);
      const num = rint(1,den-1);
      cases.push(buildCase(u0,num,den));
    })();

    // m√©lange
    for(let i=cases.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [cases[i],cases[j]] = [cases[j],cases[i]];
    }

    return { cases };
  },

  render(host, s){
    host.__state = s;

    const listItems = s.cases.map((c,idx)=>{
      const k = idx+1;
      const UMINUS='‚àí';
      const texInt = x => String(x).replace(/-/g,UMINUS);
      const u0T = texInt(c.u0);
      const qT  = this._fracTex(c.num,c.den);
      return `\\(${k}.\\ u_0 = ${u0T}\\ \\text{ et }\\ q = ${qT}\\quad\\)`;
    }).join(' ');

    const rowsHtml = s.cases.map((c,idx)=>{
      const k = idx+1;
      return `
        <tr>
          <td>\\(${k}.\\)</td>
          <td>\\(u_1=\\) ${mkInput('a'+k+'1',80)} <span id="ta${k}1" class="tick"></span></td>
          <td>\\(u_2=\\) ${mkInput('a'+k+'2',80)} <span id="ta${k}2" class="tick"></span></td>
          <td>${mkInput('b'+k,170)} <span id="tb${k}" class="tick"></span></td>
          <td>${mkInput('c'+k,170)} <span id="tc${k}" class="tick"></span></td>
          <td>${mkInput('d'+k,90)} <span id="td${k}" class="tick"></span></td>
          <td>${mkInput('e'+k,130)} <span id="te${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(q\\) d‚Äôune suite g√©om√©trique.</p>
          <p>${listItems}</p>

          <p>Pour chacun des cas :</p>
          <ul class="no-bullet">
            <li>a) D√©terminer \\(u_1\\) et \\(u_2\\).</li>
            <li>b) Exprimer \\(u_{n+1}\\) en fonction de \\(u_n\\).</li>
            <li>c) Exprimer \\(u_n\\) en fonction de \\(n\\).</li>
            <li>d) Calculer \\(u_{${s.cases[0].N}}\\).</li>
            <li>e) D√©terminer le sens de variation de la suite.</li>
          </ul>

          <table style="border-collapse:collapse;width:100%;font-size:.95rem">
            <thead>
              <tr>
                <th></th>
                <th>a) \\(u_1\\)</th>
                <th>a) \\(u_2\\)</th>
                <th>b) \\(u_{n+1}\\) en fonction de \\(u_n\\)</th>
                <th>c) \\(u_n\\) en fonction de \\(n\\)</th>
                <th>d) \\(u_{${s.cases[0].N}}\\)</th>
                <th>e) Sens de variation</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>

          <div class="equ-offscreen" style="display:none">
            <p>Dans chacun des cas suivants, on donne le premier terme \\(u_0\\) et la raison \\(q\\) d‚Äôune suite g√©om√©trique.</p>
            <p>${listItems}</p>
          </div>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.cases.forEach((cas,idx)=>{
      const k = idx+1;

      const v11 = val('a'+k+'1').trim();
      const v12 = val('a'+k+'2').trim();
      const vb  = val('b'+k).trim();
      const vc  = val('c'+k).trim();
      const vd  = val('d'+k).trim();
      const ve  = val('e'+k).trim();

      if(!v11 || !v12 || !vb || !vc || !vd || !ve) allFilled = false;

      const ok11 = v11==='' ? null : near(parseNumber(v11), cas.u1);
      const ok12 = v12==='' ? null : near(parseNumber(v12), cas.u2);

      const okb  = vb==='' ? null : this._evalRecurrenceOk(vb, cas);
      const okc  = vc==='' ? null : this._evalFormulaOk(vc, cas);
      const okd  = vd==='' ? null : near(parseNumber(vd), cas.uN);

      const sensUser = this._parseSens(ve);
      const oke = ve==='' ? null : (sensUser === cas.sens);

      tickTri($('#ta'+k+'1',host), ok11);
      tickTri($('#ta'+k+'2',host), ok12);
      tickTri($('#tb'+k,host),    okb);
      tickTri($('#tc'+k,host),    okc);
      tickTri($('#td'+k,host),    okd);
      tickTri($('#te'+k,host),    oke);

      if(ok11===false || ok12===false || okb===false || okc===false || okd===false || oke===false){
        allOk = false;
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

solution(host){
    const s = host.__state;
    const W = $('#steps', host);
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);

    const html = `
      <ol style="padding-left:1.2rem;margin:0">
        ${s.cases.map((cas, idx) => {
          const N    = cas.N;
          const u0T  = texInt(cas.u0);
          const u1T  = texInt(cas.u1);
          const u2T  = texInt(cas.u2);

          const isFrac   = cas.isFrac;
          const qAbsTex  = this._fracTex(Math.abs(cas.num), cas.den);
          const qTex     = this._fracTex(cas.num, cas.den);

          // helper : met des parenth√®ses seulement si le nombre est n√©gatif
          const wrapIfNeg = str => str.startsWith(UMINUS) ? `\\left(${str}\\right)` : str;

          /* ====== a) u1 et u2 ====== */
          let partAHtml;

          if (!isFrac){
            // q entier
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);

            const u0Disp = wrapIfNeg(u0T);
            const u1Disp = wrapIfNeg(u1T);

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = ${qAbsT}  u_0\\)<br>
                      \\(u_1 = ${qAbsT} \\times ${u0Disp}\\)<br>
                      \\(u_1 = ${u1T}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = ${qAbsT}  u_1\\)<br>
                      \\(u_2 = ${qAbsT} \\times ${u1Disp}\\)<br>
                      \\(u_2 = ${u2T}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          } else {
            // q fraction : pas de mise au m√™me d√©nominateur pour la multiplication
            const u1Num   = cas.u0 * cas.num;
            const u1Den   = cas.den;
            const u1Frac  = this._fracTex(u1Num, u1Den);

            const u2Num   = u1Num * cas.num;
            const u2Den   = u1Den * cas.den;
            const u2Frac  = this._fracTex(u2Num, u2Den);

            const u0Disp    = wrapIfNeg(u0T);
            const u1DispFrac = wrapIfNeg(u1Frac);

            partAHtml = `
              <div class="step"><strong>a.</strong></div>
              <div class="step">
                <table style="width:50%;border-collapse:collapse">
                  <tr>
                    <td style="vertical-align:top;padding-right:1.5rem">
                      \\(u_1 = ${qAbsTex}  u_0\\)<br>
                      \\(u_1 = ${qAbsTex} \\times ${u0Disp}\\)<br>
                      \\(u_1 = ${u1Frac}\\)
                    </td>
                    <td style="vertical-align:top">
                      \\(u_2 = ${qAbsTex}  u_1\\)<br>
                      \\(u_2 = ${qAbsTex} \\times ${u1DispFrac}\\)<br>
                      \\(u_2 = ${u2Frac}\\)
                    </td>
                  </tr>
                </table>
              </div>`;
          }

          /* ====== b) r√©currence ====== */

          const recGen  = `u_{n+1} = q\\,u_n`;
          let   recNum;
          if(!isFrac){
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);
            recNum = `u_{n+1} = ${qAbsT}\\,u_n`;
          }else{
            recNum = `u_{n+1} = ${qTex}u_n`;
          }

          /* ====== c) explicite (u_n = u_0 q^n) ====== */

          const explGen = `u_n = u_0 q^n`;
          const explU0  = `u_n = ${u0T} q^n`;
          let   explNum;
          if(!isFrac){
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);
            explNum = `u_n = ${u0T} \\times  ${qAbsT}^n`;
          }else{
            explNum = `u_n = ${u0T} \\times \\left(${qTex}\\right)^n`;
          }

          /* ====== d) u_N ====== */
          const linesD = [];

          if (!isFrac){
            // q entier
            const qAbs = Math.abs(cas.q);
            const qAbsT = texInt(qAbs);
            const qPow   = Math.pow(cas.q, N);
            const qPowT  = texInt(qPow);
            const uN     = cas.u0 * qPow;
            const uNT    = texInt(uN);

            linesD.push(`u_{${N}} = u_0 \\times ${qAbsT}^{${N}}`);
            linesD.push(`u_{${N}} = ${u0T} \\times ${qPowT}`);
            linesD.push(`u_{${N}} = ${uNT}`);
          } else {
            // q fraction, grandes parenth√®ses pour q^N
            const qPowNum = Math.pow(cas.num, N);
            const qPowDen = Math.pow(cas.den, N);
            const qPowF   = this._simp(qPowNum, qPowDen);
            const qPowTex = this._fracTex(qPowF.n, qPowF.d);

            const uNNum   = cas.u0 * qPowF.n;
            const uNDen   = qPowF.d;
            const uNF     = this._simp(uNNum, uNDen);
            const uNTex   = this._fracTex(uNF.n, uNF.d);

            linesD.push(`u_{${N}} = ${u0T} \\times \\left(${qTex}\\right)^{${N}}`);
            linesD.push(`u_{${N}} = ${u0T} \\times ${qPowTex}`);
            linesD.push(`u_{${N}} = ${uNTex}`);
          }

          /* ====== e) sens de variation ====== */
          let varTex;
          if(cas.q > 1){
            if(cas.u0 > 0){
              varTex = `q > 1 \\text{ et } u_0 > 0 \\Rightarrow (u_n) \\text{ est croissante sur } \\mathbb{N}.`;
            }else if(cas.u0 < 0){
              varTex = `q > 1 \\text{ et } u_0 < 0 \\Rightarrow (u_n) \\text{ est d√©croissante sur } \\mathbb{N}.`;
            }else{
              varTex = `u_0 = 0 \\Rightarrow (u_n) \\text{ est constante.}`;
            }
          } else {
            // 0 < q < 1
            if(cas.u0 > 0){
              varTex = `0 < q < 1 \\text{ et } u_0 > 0 \\Rightarrow (u_n) \\text{ est d√©croissante sur } \\mathbb{N}.`;
            }else if(cas.u0 < 0){
              varTex = `0 < q < 1 \\text{ et } u_0 < 0 \\Rightarrow (u_n) \\text{ est croissante sur } \\mathbb{N}.`;
            }else{
              varTex = `u_0 = 0 \\Rightarrow (u_n) \\text{ est constante.}`;
            }
          }

          return `
            <li style="margin-bottom:.6rem">
              <div class="steps">
                ${partAHtml}

                <div class="step" style="margin-top:.35rem">
                  <strong>b.</strong> Pour tout entier naturel \\(n\\), on a :<br>
                  \\(${recGen}\\)<br>
                  \\(${recNum}\\)
                </div>

                <div class="step" style="margin-top:.35rem">
                  <strong>c.</strong> Pour tout entier naturel \\(n\\), on a :<br>
                  \\(${explGen}\\)<br>
                  \\(${explNum}\\)
                </div>

                <div class="step" style="margin-top:.35rem">
                  <strong>d.</strong>
                </div>
                ${linesD.map(l => `<div class="step">\\(${l}\\)</div>`).join('')}

                <div class="step" style="margin-top:.35rem">
                  <strong>e.</strong> \\(${varTex}\\)
                </div>
              </div>
            </li>`;
        }).join('')}
      </ol>
    `;

    W.innerHTML = html;
    retypeMath(W);
  }






});



/* === Ex. 2 ‚Äî Terme quelconque : u_p connu, suite g√©om√©trique (q entier >1 ou 0<q<1 fraction) === */
L.push({
  id: 'ex2_suite_arith_terme_non_u0', // on garde l'id
  title: "Ex. 2 ‚Äî Suite g√©om√©trique ‚Äî Terme quelconque (u_p connu)",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){
    if(d===0) return {n:NaN,d:0};
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    if(d===0) return '\\text{ind√©fini}';
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },

  gen(){
    // On d√©cide al√©atoirement : q entier >1 OU 0<q<1 fraction
    const typeQ = choice(['int','frac']);

    // rang du terme connu p (1..6)
    const p = rint(1,6);

    // rang demand√© n (>p, <=12)
    let n = rint(p+2,12);

    // u_p non nul entier
    let up = 0;
    while(up === 0) up = rint(-10,10);

    let isFrac, q, num, den, diff, qPowNum, qPowDen, unNum, unDen, un;

    diff = n - p;

    if(typeQ === 'int'){
      // q entier >= 2
      q = choice([2,3,4,5]);
      isFrac = false;
      num = q;
      den = 1;

      const qPow = Math.pow(q, diff);
      qPowNum = qPow;
      qPowDen = 1;

      unNum = up * qPowNum;
      unDen = 1;
      un    = unNum; // entier
    }else{
      // 0 < q < 1 fraction (num/den)
      den = choice([2,3,4,5,6,8,9]);
      num = rint(1,den-1); // 0<num<den
      const sFrac = this._simp(num,den);
      num = sFrac.n;
      den = sFrac.d;
      q   = num/den;
      isFrac = true;

      qPowNum = Math.pow(num, diff);
      qPowDen = Math.pow(den, diff);
      const sPow = this._simp(qPowNum,qPowDen);
      qPowNum = sPow.n;
      qPowDen = sPow.d;

      unNum = up * qPowNum;
      unDen = qPowDen;
      const sU = this._simp(unNum,unDen);
      unNum = sU.n;
      unDen = sU.d;

      un = unNum / unDen;
    }

    return {
      isFrac,
      q, num, den,
      p, n, up,
      diff,
      qPowNum, qPowDen,
      unNum, unDen,
      un
    };
  },

  render(host, s){
    host.__state = s;
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);

    const qTex  = s.isFrac ? this._fracTex(s.num,s.den) : texInt(s.q);
    const upTex = texInt(s.up);

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Soit \\((u_n)\\) une suite g√©om√©trique de raison
            \\(q = ${qTex}\\). On sait que
            \\(u_{${s.p}} = ${upTex}\\).
          </p>

          <p>
            Donner \\(u_{${s.n}}\\).
          </p>

          <p>
            \\(u_{${s.n}} = \\) ${mkInput('ans', 120)}
            <span id="tans" class="tick"></span>
          </p>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    const v = val('ans').trim();
    const t = $('#tans', host);

    let allFilled = true;
    let allOk     = true;

    if(!v) allFilled = false;

    const ok = v==='' ? null : near(parseNumber(v), s.un);
    tickTri(t, ok);
    if(ok === false) allOk = false;

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0], SCORE[1]);
    }
    return allFilled && allOk;
  },

  solution(host){
    const s = host.__state;
    const W = $('#steps', host);
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);

    const p    = s.p;
    const n    = s.n;
    const up   = s.up;
    const diff = s.diff;

    const upTex   = texInt(up);
    const diffTex = texInt(diff);

    const upDisp = up < 0 ? `\\left(${upTex}\\right)` : upTex;

    let qTex, qPowTex, unTex, lines;

    if(!s.isFrac){
      // cas q entier >1
      qTex    = texInt(s.q);
      qPowTex = texInt(s.qPowNum); // entier
      unTex   = texInt(s.unNum);

      lines = `
        <div class="step">
          On consid√®re une suite g√©om√©trique \\((u_n)\\) de raison \\(q = ${qTex}\\)
          et on sait que \\(u_{${p}} = ${upTex}\\).
        </div>

        <div class="step" style="margin-top:.3rem">
          Pour une suite g√©om√©trique de raison \\(q\\), on a, pour tout entier naturel \\(n\\) et tout entier \\(p\\) :<br>
          \\( u_n = u_p \\times q^{n-p}. \\)
        </div>

        <div class="step" style="margin-top:.3rem">
          Ici, on cherche \\(u_{${n}}\\) √† partir de \\(u_{${p}}\\), avec \\(${n} - ${p} = ${diffTex}\\), donc :
        </div>

        <div class="step">
          \\(u_{${n}} = u_{${p}} \\times q^{${n}-${p}}\\)
        </div>
        <div class="step">
          \\(u_{${n}} = ${upTex} \\times ${qTex}^{${diffTex}}\\)
        </div>
        <div class="step">
          \\(u_{${n}} = ${upTex} \\times ${qPowTex}\\)
        </div>
        <div class="step">
          \\(u_{${n}} = ${unTex}\\)
        </div>
      `;
    }else{
      // cas 0<q<1 fraction
      qTex    = this._fracTex(s.num,s.den);
      qPowTex = this._fracTex(s.qPowNum,s.qPowDen);
      unTex   = this._fracTex(s.unNum,s.unDen);

      lines = `
        <div class="step">
          On consid√®re une suite g√©om√©trique \\((u_n)\\) de raison \\(q = ${qTex}\\)
          avec \\(0 < q < 1\\), et on sait que \\(u_{${p}} = ${upTex}\\).
        </div>

        <div class="step" style="margin-top:.3rem">
          Pour une suite g√©om√©trique de raison \\(q\\), on a, pour tout entier naturel \\(n\\) et tout entier \\(p\\) :<br>
          \\( u_n = u_p \\times q^{n-p}. \\)
        </div>

        <div class="step" style="margin-top:.3rem">
          Ici, on cherche \\(u_{${n}}\\) √† partir de \\(u_{${p}}\\), avec \\(${n} - ${p} = ${diffTex}\\), donc :
        </div>

        <div class="step">
          \\(u_{${n}} = u_{${p}} \\times q^{${n}-${p}}\\)
        </div>
        <div class="step">
          \\(u_{${n}} = ${upTex} \\times \\left(${qTex}\\right)^{${diffTex}}\\)
        </div>
        <div class="step">
          \\(u_{${n}} = ${upTex} \\times ${qPowTex}\\)
        </div>
        <div class="step">
          \\(u_{${n}} = ${unTex}\\)
        </div>
      `;
    }

    W.innerHTML = `<div class="steps">${lines}</div>`;
    retypeMath(W);
  }
});




/* === Ex. 3 ‚Äî Suite g√©om√©trique : calculer q et u‚ÇÄ √† partir de deux termes (non cons√©cutifs) === */
L.push({
  id: 'ex3_suite_arith_2termes',  // on garde l'id pour ne rien casser
  title: "Ex. 3 ‚Äî Suite g√©om√©trique : calculer q et u‚ÇÄ √† partir de u_p et u_n",

  // Outils fractions
  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; },
  _simp(n,d){
    if(d===0) return {n:NaN,d:0};
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    if(d===0) return '\\text{ind√©fini}';
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },

  gen(){
    // On choisit deux rangs NON cons√©cutifs p<n
    const p = rint(2,6);
    const n = rint(p+2,12); // au moins p+2
    const diff = n - p;

    // 50% q > 1 entier, 50% 0<q<1 fractionnaire
    const typeQ = Math.random() < 0.5 ? 'gt1' : 'frac';

    let qNum, qDen;

    if(typeQ === 'gt1'){
      // q entier > 1
      qNum = choice([2,3,4,5]);
      qDen = 1;
    }else{
      // 0 < q < 1, q fractionnaire
      const den0 = choice([2,3,4,5,6,8,9]);
      let num0   = rint(1,den0-1); // 0<num<den
      const frac = this._simp(num0,den0);
      qNum = frac.n;
      qDen = frac.d;
    }

    const q = qNum / qDen;

    // u0 entier non nul, pas trop gros
    let u0 = 0;
    while(u0 === 0) u0 = rint(-6,6);

    // u_n = u0 * q^n  ‚Üí on fabrique u_p et u_n (fractions simplifi√©es)
    const qNumP = Math.pow(qNum,p);
    const qDenP = Math.pow(qDen,p);
    const qNumN = Math.pow(qNum,n);
    const qDenN = Math.pow(qDen,n);

    let upNum = u0 * qNumP;
    let upDen = qDenP;
    let unNum = u0 * qNumN;
    let unDen = qDenN;

    const upFrac = this._simp(upNum,upDen);
    const unFrac = this._simp(unNum,unDen);
    upNum = upFrac.n; upDen = upFrac.d;
    unNum = unFrac.n; unDen = unFrac.d;

    // quotient R = u_n / u_p = q^{n-p}  (>0)
    const RNum0 = unNum * upDen;
    const RDen0 = unDen * upNum;
    const RFrac = this._simp(Math.abs(RNum0),Math.abs(RDen0));
    const RNum  = RFrac.n;
    const RDen  = RFrac.d;

    // q^p (pour le calcul de u0 dans la solution)
    const qPowPFrac = this._simp(qNumP,qDenP);
    const qPowPNum  = qPowPFrac.n;
    const qPowPDen  = qPowPFrac.d;

    return {
      p,n,diff,
      q, qNum,qDen,
      u0,
      upNum,upDen,
      unNum,unDen,
      RNum,RDen,
      qPowPNum,qPowPDen
    };
  },

  render(host,s){
    host.__state = s;
    const UMINUS = '‚àí';

    const upTex = this._fracTex(s.upNum,s.upDen);
    const unTex = this._fracTex(s.unNum,s.unDen);

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Soit \\((u_n)\\) une suite g√©om√©trique de raison \\(q > 0\\).
            On sait que :
          </p>
          <ul>
            <li>\\(u_{${s.p}} = ${upTex}\\)</li>
            <li>\\(u_{${s.n}} = ${unTex}\\)</li>
          </ul>

          <ol>
            <li>Calculer la raison \\(q\\) de la suite.</li>
            <li>En d√©duire \\(u_0\\).</li>
            <li>Donner l‚Äôexpression de \\(u_n\\) en fonction de \\(n\\).</li>
          </ol>

          <p>
            \\(q =\\) ${mkInput('q',80)} <span id="tq" class="tick"></span><br>
            \\(u_0 =\\) ${mkInput('u0',80)} <span id="tu0" class="tick"></span><br>
            \\(u_n =\\) ${mkInput('un',160)} <span id="tun" class="tick"></span>
          </p>
        </div>

        <div class="steps" id="steps"></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){
          document.querySelector('#btn-check')?.click();
        }
      });
    });
  },

  check(host){
  const s = host.__state;
  const qStr  = val('q');
  const u0Str = val('u0');
  const unStr = val('un');

  const tQ   = $('#tq',host);
  const tU0  = $('#tu0',host);
  const tUn  = $('#tun',host);

  let allFilled = true;
  let allOk     = true;

  if(!qStr || !u0Str || !unStr) allFilled = false;

  // q (q>0), accept√© en entier ou fraction
  const qOk = qStr==='' ? null : near(parseNumber(qStr), s.q);
  tickTri(tQ, qOk);
  if(qOk === false) allOk = false;

  // u0
  const u0Ok = u0Str==='' ? null : near(parseNumber(u0Str), s.u0);
  tickTri(tU0, u0Ok);
  if(u0Ok === false) allOk = false;

  // v√©rif de la formule explicite : u_n = u0 * q^n
  const okFormula = (() => {
    if(unStr === '') return null;

    // on garde seulement le membre de droite si l'√©l√®ve a √©crit "u_n = ..."
    let rhs = unStr.trim();
    const eqPos = rhs.indexOf('=');
    if(eqPos >= 0) rhs = rhs.slice(eqPos+1);

    rhs = rhs
      .replace(/\s+/g,'')
      .replace(/[‚àí‚Äì‚Äî]/g,'-')
      .replace(/,/g,'.')
      .replace(/\\cdot/g,'*')
      .replace(/[√ó¬∑]/g,'*')
      // puissances clavier
      .replace(/\^/g,'**');

    // multiplications implicites : 2(‚Ä¶), (‚Ä¶)(‚Ä¶), 2n, n2
    rhs = rhs
      .replace(/(\d|\))\(/g,'$1*(')
      .replace(/\)(\d|\()/g,')*$1')
      .replace(/(\d)n/g,'$1*n')
      .replace(/n(\d)/g,'n*$1');

    // u0 et q symboliques
    rhs = rhs.replace(/u_?0/g, `(${s.u0})`);
    rhs = rhs.replace(/\bq\b/g, `(${s.q})`);

    let f;
    try{
      f = new Function('n', `return ${rhs};`);
    }catch(e){
      return false;
    }

    const expected = n => s.u0 * Math.pow(s.q,n);

    try{
      return [0,1,2,4].every(n => near(Number(f(n)), expected(n)));
    }catch(e){
      return false;
    }
  })();

  tickTri(tUn, okFormula);
  if(okFormula === false) allOk = false;

  if(allFilled){
    SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
  }
  return allFilled && allOk;
},


  solution(host){
    const s = host.__state;
    const W = $('#steps',host);
    const UMINUS = '‚àí';

    // q est une fraction ssi son d√©nominateur est diff√©rent de 1
    const isFrac = (s.qDen && s.qDen !== 1);

    const upTex     = this._fracTex(s.upNum,s.upDen);
    const unTex     = this._fracTex(s.unNum,s.unDen);
    const qTex      = this._fracTex(s.qNum,s.qDen);
    const u0Tex     = String(s.u0).replace(/-/g,UMINUS);
    const diffTex   = String(s.diff).replace(/-/g,UMINUS);
    const RTex      = this._fracTex(s.RNum,s.RDen);
    const qPowPTex  = this._fracTex(s.qPowPNum,s.qPowPDen);

    const wrapIfNeg = str => str.startsWith(UMINUS) ? `\\left(${str}\\right)` : str;
    const u0Disp    = wrapIfNeg(u0Tex);

    const wrapIfFrac = (tex, isFrac) => isFrac
      ? `\\left(${tex}\\right)`
      : tex;

    const qpar = wrapIfFrac(qTex, isFrac);

    W.innerHTML = `
      <div class="steps">

        <!-- 1) Utilisation directe de u_n = u_p q^{n-p} pour trouver q -->
        <div class="step"><strong>1. </strong>
          Pour une suite g√©om√©trique de raison \\(q > 0\\), on a, pour tous entiers \\(n\\) et \\(p\\) :<br>
          \\(u_n = u_p \\times q^{n-p}.\\)
        </div>

        <div class="step" style="margin-top:.4rem">
          Ici, on prend \\(n = ${s.n}\\) et \\(p = ${s.p}\\), donc :<br>
          \\(u_{${s.n}} = u_{${s.p}} \\times q^{${s.n}-${s.p}}.\\)
        </div>

        <div class="step">
          \\(${unTex} = ${upTex} \\times q^{${diffTex}}\\)
        </div>
        <div class="step">
          \\(q^{${diffTex}} = \\dfrac{${unTex}}{${upTex}} \\)
        </div>
        <div class="step">
          \\(q^{${diffTex}} = ${RTex}\\)
        </div>
        <div class="step">
          \\(q = ${qTex}\\) (avec \\(q>0\\)).
        </div>

        <!-- 2) Calcul de u0 -->
        <div class="step" style="margin-top:.8rem"><strong>2. </strong>
          On sait aussi que, pour tout entier \\(n\\) : \\(u_n = u_0 q^n\\).<br>
          Pour \\(n = ${s.p}\\) :
        </div>

        <div class="step">
          \\(u_{${s.p}} = u_0 q^{${s.p}}\\)
        </div>
        <div class="step">
          \\(${upTex} = u_0 \\times ${qpar}^{${s.p}}\\)
        </div>
        <div class="step">
          \\(${upTex} = u_0 \\times ${qPowPTex}\\)
        </div>
        <div class="step">
          \\(u_0 = \\dfrac{${upTex}}{${qPowPTex}} \\)
        </div>
        <div class="step">
          \\(u_0 = ${u0Tex}\\)
        </div>

        <!-- 3) Expression explicite -->
        <div class="step" style="margin-top:.8rem"><strong>3. </strong>
          Pour tout entier naturel \\(n\\), on a donc :
        </div>
        <div class="step">
          \\(u_n = u_0 q^n\\)
        </div>
        <div class="step">
          \\(u_n = ${u0Tex} \\times ${qpar}^n.\\)
        </div>
      </div>
    `;

    retypeMath(W);
  }
});





/* === Ex. 4 ‚Äî Suites explicites : g√©om√©triques ou non ? === */
L.push({
  id: 'ex4_suite_arith_reconnaitre', // on garde l'id
  title: "Ex. 4 ‚Äî Suites explicites : g√©om√©triques ou non ?",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; },
  _simp(n,d){
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _parseOuiNon(str){
    if(!str) return null;
    let s = String(str).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='o' || s[0]==='y') return true;
    if(s[0]==='n') return false;
    return null;
  },

  gen(){
    const letters = ['a','b','c','d'];
    const names   = ['u','v','w','x'];
    const seqs    = [];

    const makeGeom = ()=>{
      let u0 = 0;
      while(u0===0) u0 = rint(-6,6);
      const q  = choice([2,3,4,5]);
      const UMINUS='‚àí';
      const TI = x => String(x).replace(/-/g, UMINUS);
      const u0Tex = TI(u0);
      const qTex  = TI(q);
      const tex   = `u_n = ${u0Tex} \\times ${qTex}^{n}`;
      return {
        kind:'geom',
        isGeom:true,
        u0, q,
        tex
      };
    };

    const makePoly = ()=>{
      const a = choice([1,2,3]);
      const b = choice([-3,-2,-1,0,1,2,3]);
      const c = choice([-5,-4,-3,-2,2,3,4,5]);
      const UMINUS='‚àí';
      const TI = x => String(x).replace(/-/g, UMINUS);

      const aTex = (a===1)?'n^2':`${a}n^2`;
      let termB='';
      if(b>0) termB = ` + ${TI(b)}n`;
      else if(b<0) termB = ` ‚àí ${TI(-b)}n`;

      let termC='';
      if(c>0) termC = ` + ${TI(c)}`;
      else if(c<0) termC = ` ‚àí ${TI(-c)}`;

      const tex = `u_n = ${aTex}${termB}${termC}`.replace(/-/g,UMINUS);

      const u0 = a*0 + b*0 + c;
      const u1 = a + b + c;
      const u2 = 4*a + 2*b + c;

      return {
        kind:'poly',
        isGeom:false,
        u0,u1,u2,
        tex
      };
    };

    const makeArith = ()=>{
      const UMINUS='‚àí';
      const TI = x => String(x).replace(/-/g, UMINUS);
      let u0 = 0;
      while(u0===0) u0 = rint(-8,8);
      let r  = 0;
      while(r===0) r  = rint(-5,5);
      const u0Tex = TI(u0);
      const rTex  = TI(Math.abs(r));
      let tex;
      if(r>0) tex = `u_n = ${u0Tex} + ${rTex}n`;
      else    tex = `u_n = ${u0Tex} ‚àí ${rTex}n`;
      tex = tex.replace(/-/g,UMINUS);

      const u1 = u0 + r;
      const u2 = u0 + 2*r;

      return {
        kind:'arith',
        isGeom:false,
        u0,u1,u2,
        tex
      };
    };

    const makeMix = ()=>{
      const UMINUS='‚àí';
      const TI = x => String(x).replace(/-/g, UMINUS);
      const a = choice([1,2,3]);
      const q = choice([2,3,4]);
      const b = choice([-4,-3,-2,2,3,4]);
      const aTex = (a===1)?`${q}^n`:`${a} \\times ${q}^n`;
      let termB='';
      if(b>0) termB = ` + ${TI(b)}`;
      else    termB = ` ‚àí ${TI(-b)}`;
      const tex = `u_n = ${aTex}${termB}`.replace(/-/g,UMINUS);

      const u0 = a*Math.pow(q,0) + b;
      const u1 = a*Math.pow(q,1) + b;
      const u2 = a*Math.pow(q,2) + b;

      return {
        kind:'mix',
        isGeom:false,
        u0,u1,u2,
        tex
      };
    };

    // 2 g√©om√©triques + 2 non g√©om√©triques
    seqs.push(makeGeom(), makeGeom());

    const nonFactories = [makePoly, makeArith, makeMix];
    while(seqs.length<4){
      const f = choice(nonFactories);
      seqs.push(f());
    }

    for(let i=seqs.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [seqs[i],seqs[j]] = [seqs[j],seqs[i]];
    }

    return {
      seqs: seqs.map((s,i)=>({
        ...s,
        letter: letters[i],
        name:   names[i]
      }))
    };
  },

  render(host,s){
    host.__state = s;
    const UMINUS='‚àí';

    const rows = s.seqs.map((seq,i)=>{
      const k=i+1;
      return `
        <tr>
          <td>${seq.letter}.</td>
          <td>\\(${seq.tex.replace(/-/g,UMINUS)}\\)</td>
          <td>${mkInput('q'+k,90)} <span id="tq${k}" class="tick"></span></td>
          <td>${mkInput('u0_'+k,80)} <span id="tu0_${k}" class="tick"></span></td>
          <td>${mkInput('r_'+k,80)} <span id="tr_${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Parmi les suites d√©finies sur \\(\\mathbb{N}\\) ci-dessous, reconna√Ætre celles qui sont
            <strong>g√©om√©triques</strong> et indiquer, pour celles qui le sont, le premier terme et la raison.
          </p>

          <table class="tbl-suites" style="width:100%;font-size:.95rem;margin-top:.4rem">
            <thead>
              <tr>
                <th></th>
                <th>Suite \\((u_n)\\)</th>
                <th>Suite g√©om√©trique ?<br><span style="font-size:.85em">(√©crire ¬´ oui ¬ª ou ¬´ non ¬ª)</span></th>
                <th>Si oui, \\(u_0\\)</th>
                <th>Si oui, raison \\(q\\)</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    const data = s.seqs;

    let allFilled=true, allOk=true;

    data.forEach((seq,i)=>{
      const k=i+1;
      const ynStr = val('q'+k);
      const u0Str = val('u0_'+k);
      const rStr  = val('r_'+k);

      const tYN = $('#tq'+k,host);
      const tU0 = $('#tu0_'+k,host);
      const tR  = $('#tr_'+k,host);

      const ansYN = this._parseOuiNon(ynStr);

      if(ansYN===null) allFilled=false;

      if(ansYN===null){
        tickTri(tYN,null);
      }else{
        const okYN = (ansYN === seq.isGeom);
        tickTri(tYN, okYN);
        if(okYN===false) allOk=false;
      }

      if(seq.isGeom){
        if(!u0Str || !rStr) allFilled=false;

        const okU0 = u0Str==='' ? null : near(parseNumber(u0Str), seq.u0);
        const okR  = rStr===''  ? null : near(parseNumber(rStr),  seq.q);

        tickTri(tU0, okU0);
        tickTri(tR,  okR);
        if(okU0===false || okR===false) allOk=false;
      }else{
        if(u0Str || rStr){
          tickTri(tU0,false);
          tickTri(tR,false);
          allOk=false;
        }else{
          tickTri(tU0,null);
          tickTri(tR,null);
        }
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },

  solution(host){
    const s = host.__state;
    const data = s.seqs;
    const W = $('#steps',host);
    const UMINUS='‚àí';
    const texInt = x => String(x).replace(/-/g,UMINUS);

    const fracTex = (n,d)=>this._fracTex(n,d);

    const itemsHtml = data.map((seq)=>{
      const idx = seq.letter + ')';

      if(seq.isGeom){
        const u0 = seq.u0;
        const q  = seq.q;
        const u1 = u0 * q;
        const u2 = u1 * q;

        const u0Tex = texInt(u0);
        const qTex  = texInt(q);
        const u1Tex = texInt(u1);
        const u2Tex = texInt(u2);

        const u0Disp = u0<0 ? `\\left(${u0Tex}\\right)` : u0Tex;
        const u1Disp = u1<0 ? `\\left(${u1Tex}\\right)` : u1Tex;

        return `
          <li style="margin-bottom:.6rem">
            <div class="steps">
              <div class="step"><strong>${idx}  \\(${seq.tex}\\)</strong></div>

              <div class="step" style="margin-top:.35rem">
                <u>M√©thode 1 : reconnaissance de la formule explicite</u>
              </div>
              <div class="step">
                On reconna√Æt une √©criture du type \\(u_n = u_0 q^n\\) avec
                \\(u_0 = ${u0Tex}\\) et \\(q = ${qTex}\\).<br>
                Donc \\((u_n)\\) est une suite g√©om√©trique de premier terme
                \\(u_0 = ${u0Tex}\\) et de raison \\(q = ${qTex}\\).
              </div>

    <div class="step" style="margin-top:.45rem">
  <u>M√©thode 2 : On cherche la relation de r√©currence</u>
</div>

<div class="step">
  Pour tout entier naturel \\(n\\), on a : \\(u_n = ${u0Tex} \\times ${qTex}^n\\).
</div>

<div class="step">
  Alors pour tout entier naturel \\(n\\), <br>
  \\(u_{n+1} = ${u0Tex} \\times ${qTex}^{\,n+1}\\)<br>
     \\(u_{n+1} = ${u0Tex} \\times ${qTex}^{\,n} \\times ${qTex}\\)<br>
      \\(u_{n+1}= u_n \\times ${qTex}\\)
</div>

<div class="step">
  Ainsi, pour passer d‚Äôun terme au suivant, on multiplie toujours par \\(${qTex}\\).<br>
  La suite \\((u_n)\\) est donc g√©om√©trique de raison \\(q = ${qTex}\\).
</div>

            </div>
          </li>`;
                       }else{
        // non g√©om√©trique : d√©tail des calculs de u0, u1, u2 dans un tableau,
        // puis √©tude des rapports successifs (avec gestion des divisions par 0)
        const u0 = seq.u0;
        const u1 = seq.u1;
        const u2 = seq.u2;

        const u0Tex = texInt(u0);
        const u1Tex = texInt(u1);
        const u2Tex = texInt(u2);

        // Expression explicite √† droite (sans "u_n =")
        const rhs = seq.tex.replace(/^u_n\s*=\s*/, '').trim();

        // remplace n par 0,1,2 dans l'expression
  // remplace n par 0,1,2 dans l'expression, en gardant le "√ó"
const makeExpr = (n)=>{
  let e = rhs;

  // 1) Mettre un "√ó" l√† o√π il y a un coefficient devant n ou n^2
  //    ex : 5+2n   -> 5+2 \times n
  //        3n^2    -> 3 \times n^2
  e = e.replace(/(\d+)n(\^2)?/g, '$1 \\times n$2');

  // 2) G√©rer les puissances : 2^n -> 2^0, 2^1, 2^2...
  e = e.replace(/\^n/g, '^' + n);

  // 3) Remplacer n par 0, 1 ou 2
  e = e.replace(/n/g, String(n));

  return e;
};


        const expr0 = makeExpr(0);
        const expr1 = makeExpr(1);
        const expr2 = makeExpr(2);

        // tableau "joli" : 3 colonnes, comme sur ton screen
        const termsTable = `
          <table style="border-collapse:collapse;margin:.25rem 0;font-size:.95em;width:100%">
            <tr>
              <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                <strong>Calcul de \\(u_0\\)</strong> (on remplace \\(n\\) par 0)<br>
                \\(u_0 = ${expr0}\\)<br>
                \\(u_0 = ${u0Tex}\\)
              </td>
              <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                <strong>Calcul de \\(u_1\\)</strong> (on remplace \\(n\\) par 1)<br>
                \\(u_1 = ${expr1}\\)<br>
                \\(u_1 = ${u1Tex}\\)
              </td>
              <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
                <strong>Calcul de \\(u_2\\)</strong> (on remplace \\(n\\) par 2)<br>
                \\(u_2 = ${expr2}\\)<br>
                \\(u_2 = ${u2Tex}\\)
              </td>
            </tr>
          </table>
        `;

        // --- rapports successifs ---

        let ratiosBlock = '';
        let conclusion  = '';

        if (u0 !== 0 && u1 !== 0) {
          // cas "normal" : aucun d√©nominateur nul
          const r1n = u1*u0 >= 0 ? Math.abs(u1) : -Math.abs(u1);
          const r1d = Math.abs(u0);
          const r2n = u2*u1 >= 0 ? Math.abs(u2) : -Math.abs(u2);
          const r2d = Math.abs(u1);

          const r1Tex = fracTex(r1n, r1d);
          const r2Tex = fracTex(r2n, r2d);

          ratiosBlock = `
            \\[
              \\dfrac{u_1}{u_0} = \\dfrac{${u1Tex}}{${u0Tex}} = ${r1Tex}
              \\quad\\text{et}\\quad
              \\dfrac{u_2}{u_1} = \\dfrac{${u2Tex}}{${u1Tex}} = ${r2Tex}.
            \\]
          `;

          conclusion = `
            Comme \\(${r1Tex} \\neq ${r2Tex}\\), les rapports successifs ne sont pas constants,
            donc la suite n‚Äôest pas g√©om√©trique.
          `;
        } else if (u0 === 0) {
          // u0 = 0 ‚Üí u1/u0 non d√©fini
          const r2n = u2*u1 >= 0 ? Math.abs(u2) : -Math.abs(u2);
          const r2d = Math.abs(u1);
          const r2Tex = fracTex(r2n, r2d);

          ratiosBlock = `
            \\[
              \\dfrac{u_1}{u_0} \\text{ n‚Äôest pas d√©fini (division par }0\\text{)}
              \\quad\\text{et}\\quad
              \\dfrac{u_2}{u_1} = \\dfrac{${u2Tex}}{${u1Tex}} = ${r2Tex}.
            \\]
          `;

          conclusion = `
            Comme le rapport \\(\\dfrac{u_1}{u_0}\\) n‚Äôest pas d√©fini,
            les rapports successifs ne sont pas tous d√©finis.
            La suite ne peut donc pas √™tre g√©om√©trique.
          `;
        } else { // ici forc√©ment u1 === 0 et u0 ‚â† 0
          const r1n = u1*u0 >= 0 ? Math.abs(u1) : -Math.abs(u1);
          const r1d = Math.abs(u0);
          const r1Tex = fracTex(r1n, r1d);

          ratiosBlock = `
            \\[
              \\dfrac{u_1}{u_0} = \\dfrac{${u1Tex}}{${u0Tex}} = ${r1Tex}
              \\quad\\text{et}\\quad
              \\dfrac{u_2}{u_1} \\text{ n‚Äôest pas d√©fini (division par }0\\text{)}.
            \\]
          `;

          conclusion = `
            Comme le rapport \\(\\dfrac{u_2}{u_1}\\) n‚Äôest pas d√©fini,
            les rapports successifs ne sont pas tous d√©finis.
            La suite ne peut donc pas √™tre g√©om√©trique.
          `;
        }

        return `
          <li style="margin-bottom:.6rem">
            <div class="steps">
              <div class="step"><strong>${idx}  \\(${seq.tex}\\)</strong></div>

              <div class="step" style="margin-top:.35rem">
                On calcule les trois premiers termes de la suite :
              </div>

              <div class="step">
                ${termsTable}
              </div>

              <div class="step" style="margin-top:.35rem">
                On calcule ensuite les rapports successifs :
              </div>

              <div class="step">
                ${ratiosBlock}
              </div>

              <div class="step">
                ${conclusion}
              </div>
            </div>
          </li>`;
      }


    }).join('');

    W.innerHTML = `<ol style="list-style:none;padding-left:0;margin:0">${itemsHtml}</ol>`;
    retypeMath(W);
  }
});



/* === Ex. 5 ‚Äî Suites r√©currentes : g√©om√©triques ou non ? === */
L.push({
  id: 'ex5_suite_recurrente',
  title: "Ex. 5 ‚Äî Suites r√©currentes : g√©om√©triques ou non ?",

  _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; },
  _simp(n,d){
    if(d<0){ n=-n; d=-d; }
    const g=this._gcd(n,d);
    return {n:n/g,d:d/g};
  },
  _fracTex(n,d){
    const UMINUS='‚àí';
    const s=this._simp(n,d);
    if(s.d===1) return String(s.n).replace(/-/g,UMINUS);
    const sign = s.n<0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(s.n)}}{${s.d}}`;
  },
  _parseOuiNon(str){
    if(!str) return null;
    let s = String(str).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if(!s) return null;
    if(s[0]==='o' || s[0]==='y') return true;
    if(s[0]==='n') return false;
    return null;
  },

  gen(){
    const UMINUS='‚àí';
    const texInt = x => String(x).replace(/-/g,UMINUS);

    // (1) Vraie suite g√©om√©trique : u_{n+1} = q u_n
    const makeGeom = ()=>{
      let u0 = 0;
      while(u0===0) u0 = rint(-6,6);
      const q = choice([2,3,4,5]);
      const qTex = texInt(q);
      const sys = `\\left\\{\\begin{array}{l}
u_0 = ${texInt(u0)}\\\\[2pt]
u_{n+1} = ${qTex}u_n
\\end{array}\\right.`;
      return {
        name:'u',
        kind:'geom',
        isGeom:true,
        u0,q,
        tex:sys
      };
    };

    // (2) Suite non g√©om√©trique : au hasard parmi trois types
    const makeArith = ()=>{
      let v0=0;
      while(v0===0) v0=rint(-6,6);
      let r=0;
      while(r===0) r=rint(-5,5);
      const UMIN='‚àí';
      const TI = x => String(x).replace(/-/g,UMIN);
      const rAbsTex = TI(Math.abs(r));
      const rec = (r>0)
        ? `v_{n+1} = v_n + ${rAbsTex}`
        : `v_{n+1} = v_n ‚àí ${rAbsTex}`;
      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${TI(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;
      return {
        name:'v',
        kind:'arith',
        isGeom:false,
        v0,r,
        tex:sys
      };
    };

    const makeArithGeo = ()=>{
      let v0=0;
      while(v0===0) v0=rint(-6,6);
      let a = choice([-4,-3,-2,2,3,4]);
      let b = 0;
      while(b===0) b=rint(-5,5);
      const UMIN= '‚àí';
      const TI = x => String(x).replace(/-/g,UMIN);
      let aTex;
      if(a===1)      aTex = '';
      else if(a===-1)aTex = '‚àí';
      else           aTex = TI(a);
      let bTex;
      if(b>0) bTex = ' + ' + TI(b);
      else    bTex = ' ‚àí ' + TI(-b);
      const rec = (Math.abs(a)===1)
        ? `v_{n+1} = ${a===1?'':'‚àí'}v_n${bTex}`
        : `v_{n+1} = ${aTex}v_n${bTex}`;
      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${TI(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;
      return {
        name:'v',
        kind:'arithgeo',
        isGeom:false,
        v0,a,b,
        tex:sys
      };
    };

    const makeVPlusAffine = ()=>{
      let v0=0;
      while(v0===0) v0=rint(-6,6);
      let alpha=0;
      while(alpha===0) alpha = choice([-3,-2,-1,1,2,3]);
      let beta=rint(-5,5);
      const UMIN='‚àí';
      const TI = x => String(x).replace(/-/g,UMIN);

      const absA = Math.abs(alpha);
      const aCore = (absA===1)?'n':`${absA}n`;
      let bPart='';
      if(beta>0)      bPart = ' + ' + TI(beta);
      else if(beta<0) bPart = ' ‚àí ' + TI(-beta);

      let rec;
      if(alpha>0) rec = `v_{n+1} = v_n + ${aCore}${bPart}`;
      else        rec = `v_{n+1} = v_n ‚àí ${aCore}${bPart}`;

      const sys = `\\left\\{\\begin{array}{l}
v_0 = ${TI(v0)}\\\\[2pt]
${rec}
\\end{array}\\right.`;
      return {
        name:'v',
        kind:'u_plus_affine',
        isGeom:false,
        v0,alpha,beta,
        tex:sys
      };
    };

    const geom = makeGeom();

    const nonFactories = [makeArith, makeArithGeo, makeVPlusAffine];
    const non = choice(nonFactories)();

    let seqs;
    if(Math.random()<0.5){
      seqs = [
        {letter:'a', ...geom},
        {letter:'b', ...non}
      ];
    }else{
      seqs = [
        {letter:'a', ...non},
        {letter:'b', ...geom}
      ];
    }

    return { seqs };
  },

  render(host,s){
    host.__state = s;

    const rows = s.seqs.map((seq,i)=>{
      const k=i+1;
      return `
        <tr>
          <td>${seq.letter}.</td>
          <td>\\(${seq.tex}\\)</td>
          <td>${mkInput('q'+k,90)} <span id="tq${k}" class="tick"></span></td>
          <td>${mkInput('r_'+k,80)} <span id="tr_${k}" class="tick"></span></td>
        </tr>`;
    }).join('');

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>
            Les suites \\((u_n)\\) et \\((v_n)\\) sont d√©finies sur \\(\\mathbb{N}\\) par les relations de r√©currence suivantes.
          </p>
          <p>
            Pour chacune d‚Äôelles, pr√©ciser s‚Äôil s‚Äôagit d‚Äôune <strong>suite g√©om√©trique</strong> et, le cas √©ch√©ant,
            indiquer sa raison \\(q\\).
          </p>

          <table class="tbl-suites" style="width:100%;font-size:.95rem;margin-top:.4rem">
            <thead>
              <tr>
                <th></th>
                <th>D√©finition r√©currente</th>
                <th>Suite g√©om√©trique ?<br><span style="font-size:.85em">(√©crire ¬´ oui ¬ª ou ¬´ non ¬ª)</span></th>
                <th>Si oui, raison \\(q\\)</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key==='Enter'){ document.querySelector('#btn-check')?.click(); }
      });
    });
  },

  check(host){
    const s = host.__state;
    let allFilled = true;
    let allOk     = true;

    s.seqs.forEach((seq,i)=>{
      const k = i+1;
      const ynStr = val('q'+k);
      const rStr  = val('r_'+k);

      const tYN = $('#tq'+k,host);
      const tR  = $('#tr_'+k,host);

      const yn = this._parseOuiNon(ynStr);

      if(yn===null){
        allFilled = false;
        tickTri(tYN,null);
      }else{
        const okYN = (yn === seq.isGeom);
        tickTri(tYN, okYN);
        if(okYN===false) allOk=false;
      }

      if(seq.isGeom){
        if(!rStr) allFilled = false;
        const okR = rStr==='' ? null : near(parseNumber(rStr), seq.q);
        tickTri(tR, okR);
        if(okR===false) allOk=false;
      }else{
        if(rStr){
          tickTri(tR,false);
          allOk=false;
        }else{
          tickTri(tR,null);
        }
      }
    });

    if(allFilled){
      SCORE[1]++; if(allOk) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);
    }
    return allFilled && allOk;
  },
  solution(host){
    const s = host.__state;
    const W = $('#steps',host);
    const UMINUS = '‚àí';
    const texInt = x => String(x).replace(/-/g, UMINUS);
    const fracTex = (n,d)=>this._fracTex(n,d);
    const simp = (n,d)=>this._simp(n,d);

    const wrapIfNeg = t => String(t).startsWith(UMINUS) ? `\\left(${t}\\right)` : t;

    const items = s.seqs.map(seq=>{
      const label = seq.letter + ')';
      const name  = seq.name; // "u" ou "v"

      /* ===== CAS G√âOM√âTRIQUE : u_{n+1} = q u_n ===== */
      if(seq.isGeom){
        const u0 = seq.u0;
        const q  = seq.q;
        const u1 = u0 * q;
        const u2 = u1 * q;

        const u0Tex = texInt(u0);
        const qTex  = texInt(q);
        const u1Tex = texInt(u1);
        const u2Tex = texInt(u2);

        const u0Disp = wrapIfNeg(u0Tex);
        const u1Disp = wrapIfNeg(u1Tex);

        return `
          <li style="margin-bottom:.6rem">
            <div class="steps">
              <div class="step">
                <strong>${label}</strong> \\(${seq.tex}\\)
              </div>

              <div class="step" style="margin-top:.35rem">
               On reconnait pour tout entier naturel \\(n\\), \\(${name}_{n+1}=q ${name}_{n}\\) avec \\(q=${qTex}\\).<br>
Pour passer d‚Äôun terme au suivant on multiplie toujours par \\(${qTex}\\).<br>
Ainsi \\((${name}_{n})\\) est une suite g√©om√©trique de premier terme \\(${name}_0=${u0Tex}\\) et de raison \\(q=${qTex}\\).

              </div>

              
            </div>
          </li>`;
      }

      /* ===== CAS NON G√âOM√âTRIQUE ===== */

      // On calcule v0, v1, v2 suivant le type
      let u0,u1,u2;

      if(seq.kind==='arith'){
        u0 = seq.v0;
        u1 = u0 + seq.r;
        u2 = u1 + seq.r;
      }else if(seq.kind==='arithgeo'){
        u0 = seq.v0;
        u1 = seq.a*u0 + seq.b;
        u2 = seq.a*u1 + seq.b;
      }else{ // u_plus_affine : v_{n+1} = v_n + (alpha n + beta)
        const a = seq.alpha;
        const b = seq.beta;
        u0 = seq.v0;
        const aff0 = a*0 + b;
        const aff1 = a*1 + b;
        u1 = u0 + aff0;
        u2 = u1 + aff1;
      }

      const u0Tex = texInt(u0);
      const u1Tex = texInt(u1);
      const u2Tex = texInt(u2);
      const u0Disp = wrapIfNeg(u0Tex);
      const u1Disp = wrapIfNeg(u1Tex);

      // ===== Tableau d√©taill√© "Calcul de v0, v1, v2" =====

      let col0 = `
        <strong>Calcul de \\(${name}_0\\)</strong><br>
        \\(${name}_0 = ${texInt(seq.v0)}\\)
      `;

      let col1 = '';
      let col2 = '';

      if(seq.kind==='arith'){
        const r = seq.r;
        const rAbsTex = texInt(Math.abs(r));
        const signSym = (r>0) ? ' + ' : ' ‚àí ';

        col1 = `
          <strong>Calcul de \\(${name}_1\\)</strong><br>
          \\(${name}_1 = ${name}_0${signSym}${rAbsTex}\\)<br>
          \\(${name}_1 = ${u0Tex}${signSym}${rAbsTex}\\)<br>
          \\(${name}_1 = ${u1Tex}\\)
        `;

        col2 = `
          <strong>Calcul de \\(${name}_2\\)</strong><br>
          \\(${name}_2 = ${name}_1${signSym}${rAbsTex}\\)<br>
          \\(${name}_2 = ${u1Tex}${signSym}${rAbsTex}\\)<br>
          \\(${name}_2 = ${u2Tex}\\)
        `;
      }
      else if(seq.kind==='arithgeo'){
        const a = seq.a;
        const b = seq.b;
        const bAbsTex = texInt(Math.abs(b));
        const bSign = (b>0)?' + ':' ‚àí ';

        const mult = (coef,symb)=>{
          if(coef===1)  return symb;
          if(coef===-1) return UMINUS + symb;
          return `${texInt(coef)} \\times ${symb}`;
        };

        col1 = `
          <strong>Calcul de \\(${name}_1\\)</strong><br>
          \\(${name}_1 = ${mult(a, name+'_0')}${bSign}${bAbsTex}\\)<br>
          \\(${name}_1 = ${mult(a, u0Disp)}${bSign}${bAbsTex}\\)<br>
          \\(${name}_1 = ${u1Tex}\\)
        `;

        col2 = `
          <strong>Calcul de \\(${name}_2\\)</strong><br>
          \\(${name}_2 = ${mult(a, name+'_1')}${bSign}${bAbsTex}\\)<br>
          \\(${name}_2 = ${mult(a, u1Disp)}${bSign}${bAbsTex}\\)<br>
          \\(${name}_2 = ${u2Tex}\\)
        `;
      }
               else{ // u_plus_affine : v_{n+1} = v_n + (a n + b)
        const a = seq.alpha;
        const b = seq.beta;

        const absA = Math.abs(a);

        // construit "v0 ¬± a√ón ¬± b" SANS parenth√®ses et SANS "+ -"
        const lineExpr = (baseTex, n)=>{
          let s = baseTex;
          if(a !== 0){
            const core = (absA === 1)
              ? String(n)
              : `${texInt(absA)} \\times ${n}`;
            if(a > 0) s += ' + ' + core;
            else      s += ' ‚àí ' + core;
          }
          if(b !== 0){
            if(b > 0) s += ' + ' + texInt(b);
            else      s += ' ‚àí ' + texInt(-b);
          }
          return s;
        };

        const aff0 = a*0 + b;
        const aff1 = a*1 + b;
        const aff0AbsTex = texInt(Math.abs(aff0));
        const aff1AbsTex = texInt(Math.abs(aff1));

        const withSign = (baseTex, val, absTex) =>
          (val >= 0)
            ? `${baseTex} + ${absTex}`
            : `${baseTex} ‚àí ${absTex}`;

        col1 = `
          <strong>Calcul de \\(${name}_1\\)</strong><br>
          \\(${name}_1 = ${lineExpr(name+'_0','0')}\\)<br>
          \\(${name}_1 = ${withSign(u0Tex, aff0, aff0AbsTex)}\\)<br>
          \\(${name}_1 = ${u1Tex}\\)
        `;

        col2 = `
          <strong>Calcul de \\(${name}_2\\)</strong><br>
          \\(${name}_2 = ${lineExpr(name+'_1','1')}\\)<br>
          \\(${name}_2 = ${withSign(u1Tex, aff1, aff1AbsTex)}\\)<br>
          \\(${name}_2 = ${u2Tex}\\)
        `;
      }



      const termsTable = `
        <table style="border-collapse:collapse;margin:.25rem 0;font-size:.95em;width:100%">
          <tr>
            <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
              ${col0}
            </td>
            <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
              ${col1}
            </td>
            <td style="border:1px solid #ccc;padding:4px 6px;vertical-align:top">
              ${col2}
            </td>
          </tr>
        </table>
      `;

      // ===== Rapports successifs avec garde-fou division par 0 =====
      let ratiosBlock = '';
      let conclusion  = '';

      if(u1 !== 0){
        // cas normal : les 2 rapports existent
        const r1 = simp(u1,u0);
        const r2 = simp(u2,u1);
        const r1Tex = fracTex(r1.n,r1.d);
        const r2Tex = fracTex(r2.n,r2.d);

        ratiosBlock = `
          \\[
            \\dfrac{${name}_1}{${name}_0} = \\dfrac{${u1Tex}}{${u0Tex}} = ${r1Tex}
            \\quad\\text{et}\\quad
            \\dfrac{${name}_2}{${name}_1} = \\dfrac{${u2Tex}}{${u1Tex}} = ${r2Tex}.
          \\]
        `;

        conclusion = `
          Comme \\(${r1Tex} \\neq ${r2Tex}\\), les rapports successifs ne sont pas constants,
          donc la suite \\((${name}_n)\\) n‚Äôest pas g√©om√©trique.
        `;
      }else{
        // u1 = 0 : le second rapport n'est pas d√©fini
        const r1 = simp(u1,u0);
        const r1Tex = fracTex(r1.n,r1.d);

        ratiosBlock = `
          \\[
            \\dfrac{${name}_1}{${name}_0} = \\dfrac{${u1Tex}}{${u0Tex}} = ${r1Tex}
            \\quad\\text{et}\\quad
            \\dfrac{${name}_2}{${name}_1} \\text{ n‚Äôest pas d√©fini (division par }0\\text{)}.
          \\]
        `;

        conclusion = `
          Le rapport \\(\\dfrac{${name}_2}{${name}_1}\\) n‚Äôest pas d√©fini car on divise par 0.
          Les rapports successifs ne sont donc pas tous d√©finis : la suite \\((${name}_n)\\)
          ne peut pas √™tre g√©om√©trique.
        `;
      }

      return `
        <li style="margin-bottom:.6rem">
          <div class="steps">
            <div class="step">
              <strong>${label}</strong> \\(${seq.tex}\\)
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule les trois premiers termes de la suite :
            </div>

            <div class="step">
              ${termsTable}
            </div>

            <div class="step" style="margin-top:.35rem">
              On calcule ensuite les rapports successifs :
            </div>

            <div class="step">
              ${ratiosBlock}
            </div>

            <div class="step">
              ${conclusion}
            </div>
          </div>
        </li>`;
    }).join('');

    W.innerHTML = `<ol style="list-style:none;padding-left:0;margin:0">${items}</ol>`;
    retypeMath(W);
  }

});



  return L;
}

/* ===== REGISTRY & UI (m√™mes hooks que ton mod√®le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // Entr√©e => V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d‚Äôaffichage :</b> ${e.message}<br>Ouvre la console pour le d√©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit pr√™t et que le kit soit charg√©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: '1√®re - Suites g√©om√©triques - Terme g√©n√©ral - Reconna√Ætre une suite g√©om√©trique (formule explicite) - Variations',
        max: 50,
        // Monte l'UI PDF juste apr√®s ta carte "Saisie & r√©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte d‚Äôamorce par type (affich√© avant chaque exo dans le PDF)
                // Optionnel : laisse √† false pour ne pas lancer l‚Äôimpression automatiquement
        autoPrint: false
      });
    } else {
      // r√©essaie bri√®vement si le kit ou REGISTRY n‚Äôest pas encore pr√™ts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui √©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas r√©f√©rencer ok4 si la Q(b) est comment√©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un √©ventuel tick fant√¥me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit s‚Äô√©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      // remplace tout "document.querySelector('#steps')" par "#steps" dans host
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
