<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1√®re - Suites g√©om√©triques - Somme </title>

<!-- m√™mes feuilles que ton mod√®le -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}

.row{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}

.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.tick{display:none;margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b;display:inline}
.tick.ko{color:#b00020;display:inline}

/* Traits de fraction plus visibles √† l‚Äô√©cran et au PDF */
.frac{display:inline-flex;flex-direction:column;line-height:1}
.frac>.num,.frac>.den{display:block;text-align:center;padding:0 .2em}
.frac>.num{border-bottom:1.5px solid currentColor}
@media print{
  .controls,.header,.kbd-host,.hide-print{display:none!important}
  .card{box-shadow:none}
  .frac>.num{border-bottom:0;position:relative}
  .frac>.num::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:currentColor}
}

/* Lignes de r√©ponse imprimables */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{ display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline; }
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}

.tbl-suites{
  border-collapse:collapse;
  border:1px solid #ccc;
}
.tbl-suites th,
.tbl-suites td{
  border:1px solid #ccc;
  padding:4px 6px;
}

ul.no-bullet{
  list-style:none;
  padding-left:0;
  margin-left:0;
}
</style>

<!-- MathJax comme dans ton mod√®le -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)'], ['$', '$']],
    displayMath: [['\\[','\\]'], ['$$','$$']],
    processEscapes: true
  },
  chtml: { matchFontHeight:false },
  startup: { typeset: true }
};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>

<!-- m√™mes libs partag√©es -->
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re - Suites g√©om√©triques - Somme </strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre de contr√¥le identique -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <!-- H√¥te d‚Äôexercice -->
    <div id="host" class="card" data-active="" data-state=""></div>

    <!-- Bloc "Saisie & r√©ponses accept√©es" -->
    <div class="card small" id="info-saisie">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul>
        <li>La somme demand√©e \\(S\\) est un <em>nombre</em> (entier ou fraction). Vous pouvez r√©pondre avec un entier (ex. <code>1245</code>) ou une fraction de la forme <code>a/b</code> (ex. <code>7/3</code>).</li>
      </ul>
    </div>
  </div>

<script>
(function(){
"use strict";
const UMINUS = '‚àí';

/* ===== Utilitaires g√©n√©riques (m√™mes patterns que tes autres pages) ===== */
function $(sel,root){ return (root||document).querySelector(sel); }
function $all(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function choice(A){ return A[Math.floor(Math.random()*A.length)]; }
function retypeMath(scope){
  if(!window.MathJax) return;
  if(MathJax.typesetPromise) MathJax.typesetPromise([scope||document]);
  else if(MathJax.typeset)   MathJax.typeset([scope||document]);
}
function mkInput(id,w){ return `<span class="blank-wrap"><input id="${id}" style="width:${w||120}px;font-size:15px;padding:6px;border:1px solid #ddd;border-radius:8px"> <span class="blank" style="width:${(w||120)-14}px"></span></span>`; }
function parseNumber(s){
  if(s==null) return NaN;
  s = String(s).trim().replace(/,/g,'.').replace(/\s+/g,'');
  if(/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(s)) return Number(s);
  const m = s.match(/^([-+]?\d+)\/(\d+)$/);
  if(m){ const a=+m[1], b=+m[2]; return b? a/b : NaN; }
  const m2 = s.match(/^\\d?frac\{?\s*([-+]?\d+)\s*\}?\{?\s*(\d+)\s*\}?$/); // \frac{a}{b}
  if(m2){ const a=+m2[1], b=+m2[2]; return b? a/b : NaN; }
  return NaN;
}
/* Normalise une relation de type u_{n+1}=... (pas vraiment utilis√© ici, mais gard√© pour homog√©n√©it√©) */
function normRelation(str){
  if(str==null) return '';
  let s = String(str).toLowerCase();

  // espaces & commandes d'espacement LaTeX
  s = s.replace(/\s+/g,'');
  s = s.replace(/\\(,|;|:|!|quad|qquad)/g,'');

  // produits & signes
  s = s.replace(/\\cdot/g,'');
  s = s.replace(/√ó|\*/g,'');
  s = s.replace(/[‚àí‚Äì‚Äî]/g,'-');

  // normaliser les √©critures de u(...)
  s = s.replace(/u_\(([^)]+)\)/g,'u_{$1}');  // u_(...) -> u_{...}
  s = s.replace(/u\(([^)]+)\)/g,'u_{$1}');   // u(...)  -> u_{...}
  s = s.replace(/u_\{([^}]+)\)/g,'u_{$1}');  // u_{... ) -> u_{...}

  // COMPRESSIONS utiles
  s = s.replace(/u_\{([a-z])\}/g,'u_$1');    // u_{n} -> u_n (et u_{k} -> u_k)
  s = s.replace(/\{(\d+)\}/g,'$1');          // {3} -> 3

  return s;
}

function near(a,b,eps){ return Math.abs(a-b) <= (eps||1e-9); }
function parseList(s){ return String(s).split(/[;,]/).map(t=>parseNumber(t)).filter(v=>!Number.isNaN(v)); }
function tick(el,ok){ if(!el) return; el.classList.remove('ok','ko'); el.classList.add(ok?'ok':'ko'); el.textContent = ok?'‚úì':'‚úó'; }
// ‚úì / ‚úó / neutre (champ vide)
function tickTri(el, state){
  if(!el) return;
  el.classList.remove('ok','ko');
  if(state===true){ el.classList.add('ok'); el.textContent='‚úì'; }
  else if(state===false){ el.classList.add('ko'); el.textContent='‚úó'; }
  else { el.textContent=''; } // neutre si vide
}

function scoreSet(a,b){ const s=$("#score"); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];
function val(id){ const el=document.getElementById(id); return el?el.value.trim():''; }
function setVal(id,v){ const el=document.getElementById(id); if(el) el.value=v; }

/* ===== Helpers affichage LaTeX ===== */
function fmtSigned(k){
  if(k===0) return '';
  const s = k<0 ? UMINUS : '+';
  const a = Math.abs(k);
  return ` ${s} ${a}`;
}
function monome(coeff, n, pow){ // coeff * n^pow
  const a = coeff;
  if(a===0) return '';
  const sgn = a<0 ? UMINUS : '';
  const c = Math.abs(a);
  const cstr = (c===1) ? '' : String(c);
  const nstr = (pow===0) ? '' : (pow===1 ? 'n' : 'n^'+pow);
  if(pow===0){ return `${sgn}${c}`; }
  return `${sgn}${cstr}${nstr}`;
}
function polyToLatex(coeffs){ // [a3,a2,a1,a0] ‚Üí an^3 + bn^2 + cn + d
  const parts=[];
  const pows=[3,2,1,0];
  for(let i=0;i<coeffs.length;i++){
    const t = monome(coeffs[i], 'n', pows[i]);
    if(!t) continue;
    parts.push(t);
  }
  let s = parts.join(' + ').replace(/\+\s*‚àí/g, UMINUS).replace(/‚àí\s*\+/g, UMINUS);
  s = s.replace(/\+\s*$/,'');
  s = s.replace(/\+/g,'+').replace(/‚àí/g, UMINUS);
  return s || '0';
}

function makeExos(){
  const L = [];

/* === Ex. ‚Äî Somme de termes d‚Äôune suite g√©om√©trique === */
L.push({
  id: 'ex_somme_suite_arith', // on garde l'id pour compatibilit√©
  title: "Ex. ‚Äî Somme de termes d‚Äôune suite g√©om√©trique",

gen(){
  // 50% : q > 1 entier (2 ou 3 ou 4)
  // 50% : 0 < q < 1 avec q = 1/2, 1/3, 1/4, 2/3, 3/4
  const gt1Qs   = [2,3,4];
  const fracQs  = [
    {num:1, den:2},
    {num:1, den:3},
    {num:1, den:4},
    {num:2, den:3},
    {num:3, den:4}
  ];

  let qNum, qDen;
  if(Math.random() < 0.5){
    qNum = choice(gt1Qs);
    qDen = 1;
  }else{
    const f = choice(fracQs);
    qNum = f.num;
    qDen = f.den;
  }
  const q = qNum / qDen;

  // u0 non nul
  let u0 = rint(-6,6);
  while(u0 === 0) u0 = rint(-6,6);

  // 40% : u0 connu ; 60% : u_p avec p entre 1 et 4
  // 40% : u0 connu ; 60% : u_p avec p entre 1 et 4
  let knownIndex;
  if(Math.random() < 0.4){
    knownIndex = 0;
  }else{
    knownIndex = rint(1,4);
  }
  const knownValue = u0 * Math.pow(q, knownIndex);

  // üîí Interdiction : terme donn√© nul (u0 ou u_p)
  if (knownIndex === 0 ? u0 === 0 : knownValue === 0){
    return this.gen(); // on reg√©n√®re un autre exo
  }


  // indices de la somme
  // *** important : le premier terme doit avoir un rang ‚â• rang connu ***
  // indices de la somme
  // - si u0 est connu : on peut commencer entre u2 et u6
  // - si u_p est connu (p ‚â• 1) : on commence au moins √† u_{p+2}
  const maxA = 6;
  let a;

  if (knownIndex === 0){
    // cas u0 connu : d√©part entre 2 et 6
    a = rint(2, maxA);
  }else{
    // cas u_p connu avec p ‚â• 1 : d√©part au moins √† p+2
    let minA = knownIndex + 2;
    if (minA > maxA) minA = maxA; // s√©curit√©
    a = rint(minA, maxA);
  }

  const N = rint(5, 10);      // nombre de termes
  const b = a + N - 1;        // dernier rang de la somme


  // valeurs num√©riques (pour la v√©rification uniquement)
  const uA    = u0 * Math.pow(q,a);
  const uB    = u0 * Math.pow(q,b);
  const qPowN = Math.pow(q,N);
  const S     = uA * (1 - qPowN) / (1 - q);

  return {
    q, u0,
    knownIndex, knownValue,
    a, b,
    uA, uB,
    N, S,
    qNum, qDen
  };
},




  render(host,s){
    host.__state = s;
const texInt = x => String(x).replace(/-/g, UMINUS);

// les m√™mes helpers gcd / floatToFrac / texFrac que dans solution()
const gcd = (a,b)=>{ a=Math.round(Math.abs(a)); b=Math.round(Math.abs(b));
  while(b){ const t=a%b; a=b; b=t; } return a||1; };
const floatToFrac = (x,maxDen=1000000)=>{
  if(Number.isInteger(x)) return {n:x,d:1};
  let sign = x<0?-1:1, v=Math.abs(x);
  let h1=1,h0=0,k1=0,k0=1,b=Math.floor(v),frac=v,iter=0;
  while(Math.abs(frac-b)>1e-12 && k1<maxDen && iter<20){
    const a0=b, h2=a0*h1+h0, k2=a0*k1+k0;
    h0=h1;h1=h2;k0=k1;k1=k2;
    frac=1/(frac-a0); b=Math.floor(frac); iter++;
  }
  let n=sign*h1,d=k1||1,g=gcd(n,d);
  return {n:n/g,d:d/g};
};
const texFrac = x=>{
  const r=floatToFrac(x);
  if(r.d===1) return texInt(r.n);
  const sign=r.n<0?UMINUS:'';
  return `${sign}\\dfrac{${Math.abs(r.n)}}{${r.d}}`;
};
    let knownTex;

if(s.knownIndex === 0){
  knownTex = `u_0 = ${texInt(s.u0)}`;
}else{
  knownTex = `u_{${s.knownIndex}} = ${texFrac(s.knownValue)}`;
}

 let qTex;
if (s.qDen && s.qDen !== 1){
  const sign = s.qNum < 0 ? UMINUS : '';
  qTex = `${sign}\\dfrac{${Math.abs(s.qNum)}}{${s.qDen}}`;
} else {
  qTex = texInt(s.q);
}



    const a = s.a, b = s.b;

    host.innerHTML = `
      <div class="row norepere">
        <div class="statement">
          <p>Soit \\((u_n)\\) une suite <strong>g√©om√©trique</strong> de raison \\(q\\).</p>
          <p>On sait que \\(q = ${qTex}\\) et \\(${knownTex}\\).</p>
          <p>Calculer la somme :</p>
          <p style="margin-left:1.2rem">
            \\(S = u_{${a}} + u_{${a+1}} + \\cdots + u_{${b}}\\).
          </p>

          <p>
            ${mkInput('S',140)} <span id="tS" class="tick"></span>
          </p>
        </div>

        <div><div class="steps" id="steps"></div></div>
      </div>
    `;

    retypeMath(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', ev=>{
        if(ev.key === 'Enter'){
          document.querySelector('#btn-check')?.click();
        }
      });
    });
  },

  check(host){
    const s = host.__state;
    const raw = val('S');
    const t   = $('#tS',host);

    if(!raw){
      tickTri(t,null);
      return false;
    }

    const x = parseNumber(raw);
    const ok = !Number.isNaN(x) && near(x, s.S);

    tickTri(t, ok);

    SCORE[1]++; if(ok) SCORE[0]++; scoreSet(SCORE[0],SCORE[1]);

    return ok;
  },

 solution(host){
// copie profonde = √©tat fig√©
const s = JSON.parse(JSON.stringify(host.__state));
  const W = $('#steps',host);

  const a  = s.a, b = s.b;
  const N  = s.N;          // nombre de termes
  const p  = s.knownIndex; // rang connu (0 ou >=1)
  const u0 = s.u0;         // entier choisi √† la g√©n√©ration

  // q = qNum / qDen (tous deux entiers >0)
  const qNum = s.qNum || s.q;
  const qDen = s.qDen || 1;

  const UMINUS = '‚àí';
  const texInt = x => String(x).replace(/-/g, UMINUS);

  /* ========= Outils fractions EXACTS (aucun flottant) ========= */

  const gcd = (a,b)=>{
    a = Math.abs(a); b = Math.abs(b);
    while(b){ const t=a%b; a=b; b=t; }
    return a || 1;
  };

  const simp = (n,d)=>{
    if(d<0){ n=-n; d=-d; }
    const g = gcd(n,d);
    return { n: n/g, d: d/g };
  };

  const frac = (n,d)=>simp(n,d);

  const addFrac = (A,B)=>frac(A.n*B.d + B.n*A.d, A.d*B.d);
  const subFrac = (A,B)=>frac(A.n*B.d - B.n*A.d, A.d*B.d);
  const mulFrac = (A,B)=>frac(A.n*B.n, A.d*B.d);
  const divFrac = (A,B)=>frac(A.n*B.d, A.d*B.n);

  const powInt = (a,n)=>{
    let r = 1;
    for(let i=0;i<n;i++) r *= a;
    return r;
  };

  const powFracInt = (num,den,n)=>frac(powInt(num,n), powInt(den,n));

  const fracToTex = (F)=>{
    if(F.d === 1) return texInt(F.n);
    const sign = F.n < 0 ? UMINUS : '';
    return `${sign}\\dfrac{${Math.abs(F.n)}}{${F.d}}`;
  };

  // q en LaTeX (entier ou fraction exacte qNum/qDen)
  const qFrac = frac(qNum,qDen);
  const qTex = fracToTex(qFrac);

  // q^exp en LaTeX
  const powQTex = exp => {
    const base = qTex;
    const wrapped = (qDen!==1) ? `\\left(${base}\\right)` : base;
    return `${wrapped}^{${exp}}`;
  };

  // entiers/fractions utiles
  const one = frac(1,1);
  const u0Frac = frac(u0,1);

  // Approxime un flottant en fraction raisonnable pour repartir de la valeur DONN√âE dans l‚Äô√©nonc√©
  const approxFromFloat = (x, maxDen = 1000000)=>{
    if (Number.isInteger(x)) return frac(x,1);
    let sign = x < 0 ? -1 : 1;
    let v = Math.abs(x);
    let h1 = 1, h0 = 0, k1 = 0, k0 = 1;
    let b = Math.floor(v), fracv = v, iter = 0;
    while (Math.abs(fracv - b) > 1e-12 && k1 < maxDen && iter < 20){
      const a0 = b, h2 = a0*h1 + h0, k2 = a0*k1 + k0;
      h0 = h1; h1 = h2; k0 = k1; k1 = k2;
      fracv = 1/(fracv - a0); b = Math.floor(fracv); iter++;
    }
    return frac(sign*h1, k1 || 1);
  };



  // u_p exact : on repart de la valeur DONN√âE dans l‚Äô√©nonc√©
  let upFrac;
  if (p === 0){
    // cas o√π on conna√Æt u0
    upFrac = u0Frac;
  } else {
    // cas o√π on conna√Æt u_p avec p ‚â• 1 : on prend exactement la valeur de l‚Äô√©nonc√©
    upFrac = approxFromFloat(s.knownValue);
  }


  // u_a exact
  let uAF;
  if(p === 0){
    // u_a = u0 * q^a
    const qPowA = powFracInt(qNum,qDen,a);
    uAF = mulFrac(u0Frac, qPowA);
  }else{
    // u_a = u_p * q^{a-p}
    const qPowAP = powFracInt(qNum,qDen, a-p);
    uAF = mulFrac(upFrac, qPowAP);
  }

  // (1 - q^N)/(1 - q) exact
  const qPowN = powFracInt(qNum,qDen,N);  // q^N
  const numFrac = subFrac(one, qPowN);    // 1 - q^N
  const denFrac = subFrac(one, qFrac);    // 1 - q
  const ratio = divFrac(numFrac, denFrac);

  // S exact : S = u_a * (1 - q^N)/(1 - q)
  const SFrac = mulFrac(uAF, ratio);

  /* ========= 1) Introduction ========= */

  let blocIntro = '';
  let blocFormule = '';

  if(p === 0){
    blocIntro = `
      <div class="step">
        \\((u_n)\\) est une suite <strong>g√©om√©trique</strong> de premier terme
        \\(u_0 = ${texInt(u0)}\\) et de raison \\(q = ${qTex}\\).
      </div>
    `;

    blocFormule = `
      <div class="step">
        Formule explicite d‚Äôune suite g√©om√©trique : <br>
		\\(u_n = u_0 \\times q^{n}\\)<br>
        \\(u_n = ${texInt(u0)} \\times ${powQTex('n')}\\)
      </div>
    `;
  }else{
    blocIntro = `
      <div class="step">
        \\((u_n)\\) est une suite <strong>g√©om√©trique</strong> de raison \\(q = ${qTex}\\)
        et on conna√Æt \\(u_{${p}} = ${fracToTex(upFrac)}\\).
      </div>
    `;

    blocFormule = `
      <div class="step">
        Pour une suite g√©om√©trique, on a pour tout entier \\(n\\) :<br>
        \\(u_n = u_{${p}} \\times q^{\\,n-${p}}\\)<br>
        \\(u_n = ${fracToTex(upFrac)} \\times ${powQTex('n-'+p)}\\)
      </div>
    `;
  }

  /* ========= 2) Calcul du premier terme de la somme : u_a ========= */

  let blocAB = '';

  if(p === 0){
    const qPowAFrac = powFracInt(qNum,qDen,a);
 const expTex1 = `${a}`; 
    blocAB = `
      <div class="step">
        On calcule le premier terme de la somme √† l‚Äôaide de la formule explicite :
      </div>

      <div class="step">
		\\(u_{${a}}= ${texInt(u0)} \\times ${powQTex(a)}\\)<br>
        \\(u_{${a}} = ${texInt(u0)} \\times ${fracToTex(qPowAFrac)}\\)<br>
        \\(u_{${a}} = ${fracToTex(uAF)}\\)
      </div>
    `;
  }else{
  const qPowAP = powFracInt(qNum, qDen, a - p);
  const expDiff = a - p;              // exposant simplifi√© (nombre)
  const expTex1 = `${a}-${p}`;        // exposant sous la forme "5-2"

  blocAB = `
    <div class="step">
      On calcule le premier terme de la somme √† partir de \\(u_{${p}}\\) :
    </div>

    <div class="step">
      \\(u_{${a}} = ${fracToTex(upFrac)} \\times ${powQTex(expTex1)}\\)<br>
      \\(u_{${a}} = ${fracToTex(upFrac)} \\times ${powQTex(expDiff)}\\)<br>
      \\(u_{${a}} = ${fracToTex(upFrac)} \\times ${fracToTex(qPowAP)}\\)<br>
      \\(u_{${a}} = ${fracToTex(uAF)}\\)
    </div>
  `;
}


  /* ========= 3) Nombre de termes & somme ========= */

  const sommeBloc = `
    <div class="step">
      Le nombre de termes ajout√©s dans la somme est :<br>
      \\(N = ${b} - ${a} + 1 = ${N}\\).
    </div><br>

    <div class="step">
      \\(\\displaystyle S = \\sum_{k=${a}}^{${b}} u_k \\)
    </div>
  <div class="step">
      \\(S = \\text{Premier terme de la somme} \\times \\dfrac{1 - q^{N}}{1 - q}\\)
    </div>
    <div class="step">
      \\(S = u_{${a}} \\times \\dfrac{1 - q^{${N}}}{1 - q}\\)
    </div>

    <div class="step">
      \\(S = ${fracToTex(uAF)} \\times \\dfrac{1 - ${powQTex(N)}}{1 - ${qTex}}\\)<br>
      \\(S = ${fracToTex(uAF)} \\times \\dfrac{${fracToTex(numFrac)}}{${fracToTex(denFrac)}}\\)<br>
      \\(S = ${fracToTex(SFrac)}\\)
    </div>
  `;

  const html = `
    <div class="steps">
      ${blocIntro}
      ${blocFormule}
      <br>
      ${blocAB}
      <br>
      ${sommeBloc}
    </div>
  `;

  W.innerHTML = html;
  retypeMath(W);
}



});

  return L;
}

/* ===== REGISTRY & UI (m√™mes hooks que ton mod√®le) ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, def.gen());
    // Entr√©e => V√©rifier
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ document.querySelector('#btn-check').click(); } });
    });
    if(window.MathJax) retypeMath(host);
  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d‚Äôaffichage :</b> ${e.message}<br>Ouvre la console pour le d√©tail.
    </div>`;
  }
}

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.check) return;
    def.check(host);
  });

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    if(!def || !def.solution) return;
    def.solution(host);
  });
});

document.addEventListener('DOMContentLoaded', ()=>{
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // ExoPDF : attend que REGISTRY soit pr√™t et que le kit soit charg√©
  (function waitForPDF(){
    if (window.ExoPDF?.init && Array.isArray(window.REGISTRY) && window.REGISTRY.length){
      ExoPDF.init({
        title: '1√®re - Suites g√©om√©triques - Somme ',
        max: 50,
        // Monte l'UI PDF juste apr√®s ta carte "Saisie & r√©ponses"
        mountAfterSelector: '#info-saisie',
        // Texte d‚Äôamorce par type (affich√© avant chaque exo dans le PDF)
        // Optionnel : laisse √† false pour ne pas lancer l‚Äôimpression automatiquement
        autoPrint: false
      });
    } else {
      // r√©essaie bri√®vement si le kit ou REGISTRY n‚Äôest pas encore pr√™ts
      setTimeout(waitForPDF, 60);
    }
  })();
});

// --- (2) PATCHS qui √©vitent des effets de bord lors du rendu PDF ---
// Exo 2 : ne pas r√©f√©rencer ok4 si la Q(b) est comment√©e
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.check==='function'){
    const _old = def.check;
    def.check = function(host){
      const res = _old.call(this, host);
      // Supprime un √©ventuel tick fant√¥me #t4 s'il existe
      const t4 = host.querySelector('#t4'); if(t4){ t4.textContent=''; t4.classList.remove('ok','ko'); }
      return res;
    };
  }
})();

// Exo 2 : la solution doit s‚Äô√©crire DANS le host (le kit clone un conteneur temporaire)
(function(){
  const def = (window.REGISTRY||[]).find(d=>d.id==='ex2_recurrence_1');
  if(def && typeof def.solution==='function'){
    const _old = def.solution;
    def.solution = function(host){
      const W = host.querySelector('#steps');
      if(!W){ const box=document.createElement('div'); box.id='steps'; host.appendChild(box); }
      return _old.call(this, host);
    };
  }
})();
})();
</script>
</body>
</html>
