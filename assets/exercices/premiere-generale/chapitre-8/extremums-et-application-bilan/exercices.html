<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1Ã¨re â€“ Ã‰tude de fonctions â€¢ Lien entre le signe de la dÃ©rivÃ©e et les variations d'une fonction f</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  /* mini tableaux â€œPDF-likeâ€ (cadre extÃ©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* BÃ‚TONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  /* 1 barre centrale (vide ou avec 0) */
  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  /* 0 plus grand mais moins Ã©pais */
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.zbar {
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }
  table.pdf-tbl td.zbar { font-weight:400!important; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* cellule ext (max/min) dans la ligne de f */
  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  /* Affichage conditionnel */
  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  /* Tableau QCM (Ã©cran) */
  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  /* 2 barres (||) â€” Ã©cart RESSERRÃ‰ */
  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }
  
  /* mini-table u,v / u',v' (comme fiche Quotient / Inverse) */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{ padding:4px 40px 4px 0; }
}


  
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1Ã¨re â€“ Ã‰tude de fonctions â€¢ Lien entre le signe de la dÃ©rivÃ©e et les variations d'une fonction f</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplissez dans la saisie du haut si <b>maximum</b> et dans la saisie du bas si <b>minimum</b> (valeur de \(f(x)\)).</li>
        <li>FlÃ¨ches : choisissez â†˜ ou â†—.</li>
        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, Ã©crire une liste. Exemple : -3;2</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* â€”â€”â€”â€”â€” Utils â€”â€”â€”â€”â€” */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='âˆ’';
function cleanSigns(s){
  if(!s) return s;
  let out = String(s);

  // 1) on ramÃ¨ne tous les "âˆ’" unicode en "-"
  out = out.replace(/\u2212/g, '-');

  // 2) on nettoie les espaces
  out = out.replace(/\s+/g,' ').trim();

  // 3) on simplifie les combinaisons de signes
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();

  // 4) on repasse tous les "-" en "âˆ’" pour l'affichage
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){
  if(!el) return null;

  // 1) si le prochain Ã©lÃ©ment est dÃ©jÃ  un tick, on le rÃ©utilise
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) {
    return s;
  }

  // 2) sinon on crÃ©e TOUJOURS un nouveau tick juste aprÃ¨s el
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}

function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

/* helpers */
function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   EXERCICE â€” DÃ©rivÃ©e, signe de fâ€²(x) et variations (sÃ©lecteur de fonction)
   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
const ex1 = {
  id: 'deriv_sign_var_types',
  title: "DÃ©rivÃ©e, signe de fâ€²(x) et variations (sÃ©lecteur de fonction)",

  _familyLabel(key){
    switch(key){
      case 'quad':          return "une fonction polynÃ´me du second degrÃ©";
      case 'cubic':         return "une fonction polynÃ´me du 3Ã¨me degrÃ©";
      case 'quot_aff':      return "un quotient d'expressions affines";
      case 'quot_aff_quad': return "un quotient ";
      default:              return key;
    }
  },

  _sgn(x){ return x>0 ? 1 : (x<0 ? -1 : 0); },

  _round(x, p=6){
    const k = Math.pow(10,p);
    return Math.round(x*k)/k;
  },

  _SX(x){
    const UMIN = 'âˆ’';
    return String(x).replace('-', UMIN);
  },

   // normalisation pour comparer la dÃ©rivÃ©e
  _normDeriv(str){
    if(!str) return '';
    let out = String(str);

    // 1) signes / exposants / espaces
    out = out
      .replace(/\u2212/g,'-')   // moins unicode â†’ "-"
      .replace(/Â²/g,'^2')
      .replace(/Â³/g,'^3')
      .replace(/â´/g,'^4')
      .replace(/âµ/g,'^5')
      .replace(/â¶/g,'^6')
      .replace(/â·/g,'^7')
      .replace(/â¸/g,'^8')
      .replace(/â¹/g,'^9')
      .replace(/Â·/g,'*')
      .replace(/Ã—/g,'*')
      .replace(/,/g,'.')
      .replace(/\s+/g,'');

  // 2) on enlÃ¨ve les parenthÃ¨ses "inutiles" autour d'un facteur simple
  //    Ã©ventuellement prÃ©cÃ©dÃ© d'un signe (+ ou -)
  //    ex : (2x) â†’ 2x, (-4x) â†’ -4x, mais (x^2+3) reste.
  out = out.replace(/\(([+-]?[^()+\-]+)\)/g, '$1');


    return out;
  },



  _parseExtList(str){
    if(!str) return [];
    const s = str.trim();
    if(!s) return [];
    const low = s.toLowerCase();
    if(low==='aucun' || low==='rien') return [];
    return s.split(';')
      .map(v=>v.trim())
      .filter(v=>v!=='')
      .map(v=>Number(v.replace(/\u2212/g,'-').replace(',','.')))
      .filter(v=>!Number.isNaN(v));
  },

  _sameSetNums(a,b){
    if(a.length!==b.length) return false;
    const A = [...a].map(x=>this._round(x,4)).sort((u,v)=>u-v);
    const B = [...b].map(x=>this._round(x,4)).sort((u,v)=>u-v);
    for(let i=0;i<A.length;i++){
      if(Math.abs(A[i]-B[i])>1e-4) return false;
    }
    return true;
  },

  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // GÃ©nÃ©ration dâ€™un Ã©noncÃ©
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  gen(familyOverride){
    const fams = ['quad','cubic','quot_aff','quot_aff_quad'];
    const fam  = familyOverride || fams[rint(0,fams.length-1)];
    const UMIN = 'âˆ’';

    // petit builder ASCII a2 x^2 + a1 x + a0
    function polyAscii(a2,a1,a0){
      let s = '';
      const add = (coef, power)=>{
        if(!coef) return;
        let part = '';
        const A = Math.abs(coef);
        if(power===0){
          part = String(A);
        }else if(power===1){
          part = (A===1 ? 'x' : A+'x');
        }else if(power===2){
          part = (A===1 ? 'x^2' : A+'x^2');
        }else if(power===3){
          part = (A===1 ? 'x^3' : A+'x^3');
        }else{
          part = (A===1 ? 'x^'+power : A+'x^'+power);
        }
        if(!s){
          s = (coef<0 ? '-' : '') + part;
        }else{
          s += (coef<0 ? '-' : '+') + part;
        }
      };
      add(a2,2); add(a1,1); add(a0,0);
      return s || '0';
    }

    // petites marges alÃ©atoires DISTINCTES pour les bornes
    function randMargins(){
      let mL = rint(2,4);
      let mR = rint(2,4);
      if(mL === mR){
        // on force une petite diffÃ©rence
        if(mR < 4) mR = mL + 1;
        else       mL = mR - 1;
      }
      return [mL, mR];
    }




    // builder TeX pour quadratique
    function polyTexQuad(a,b,c){
      const t=[];
      const add=(coef,power)=>{
        if(!coef) return;
        const A = Math.abs(coef);
        const sign = coef<0 ? UMIN : '+';
        let core='';
        if(power===2) core=(A===1?'':'${A}')+'x^2';
        if(power===1) core=(A===1?'':'${A}')+'x';
        if(power===0) core='${A}';
        t.push({sign,core:core.replace('${A}',String(A))});
      };
      add(a,2); add(b,1); add(c,0);
      if(!t.length) return '0';
      let s='';
      const first=t[0];
      if(first.sign===UMIN) s+=UMIN+first.core; else s+=first.core;
      for(let i=1;i<t.length;i++){
        const term=t[i];
        s+=(term.sign===UMIN?` ${UMIN} `:' + ')+term.core;
      }
      return s;
    }

    // builder TeX pour cubique ax^3+bx^2+cx+d
    function polyTexCubic(a,b,c,d){
      const t=[];
      const add=(coef,power)=>{
        if(!coef) return;
        const A=Math.abs(coef);
        const sign=coef<0?UMIN:'+';
        let core='';
        if(power===3) core=(A===1?'':'${A}')+'x^3';
        if(power===2) core=(A===1?'':'${A}')+'x^2';
        if(power===1) core=(A===1?'':'${A}')+'x';
        if(power===0) core='${A}';
        t.push({sign,core:core.replace('${A}',String(A))});
      };
      add(a,3); add(b,2); add(c,1); add(d,0);
      if(!t.length) return '0';
      let s='';
      const first=t[0];
      if(first.sign===UMIN) s+=UMIN+first.core; else s+=first.core;
      for(let i=1;i<t.length;i++){
        const term=t[i];
        s+=(term.sign===UMIN?` ${UMIN} `:' + ')+term.core;
      }
      return s;
    }

    // ============== CAS 1 : polynÃ´me du 2nd degrÃ© =================
    // ============== CAS 1 : polynÃ´me du 2nd degrÃ© =================
if(fam==='quad'){
  const a = choice([1,2,3,4,-1,-2,-3,-4]); // ta version avec |a| plus gros
  const x0 = choice([-2,-1,0,1,2]);
  const b = -2*a*x0;
  const c = rint(-5,5);

  const fTex = `f(x) = ${polyTexQuad(a,b,c)}`;

  const A1 = 2*a, B1 = b;
  const dfTex   = `f'(x) = ${polyTexQuad(0,A1,B1)}`;
  const dfCanon = polyAscii(0,A1,B1);

  const [mL, mR] = randMargins();
  const xL = x0 - mL;
  const xR = x0 + mR;


  const xPts = [xL, x0, xR];


  const fEval = x => a*x*x + b*x + c;
  const fVals = xPts.map(fEval);

  const mids = [ (xL+x0)/2, (x0+xR)/2 ];
  const signPattern = mids.map(m=>{
    const v = A1*m + B1;
    return v>=0 ? '+' : 'âˆ’';
  });

  const extType = a>0 ? 'min' : 'max';
  const ext = [{x:x0, y:fEval(x0), type:extType}];

  const critKind = ['', '0', ''];

  return {
    family:'quad',
    aCoeff: a,      // âœ… mÃ©morisation de a
    bCoeff: b,      // âœ… mÃ©morisation de b
    fTex, dfTex, dfCanon,
    xPts,
    fVals,
    yPts: fVals,
    signPattern,
    critKind,
    ext
  };
}


    // ============== CAS 2 : polynÃ´me du 3Ã¨me degrÃ© =================
    if(fam==='cubic'){
      // On veut plusieurs cas pour f'(x) :
      // - Î”>0 carrÃ© parfait, racines symÃ©triques (cas existant)
      // - Î”>0 carrÃ© parfait, racines non symÃ©triques
      // - Î”=0 (racine double)
      // - Î”<0 (pas de racine rÃ©elle)
      const mode = choice(['sym','deltaPosNonSym','delta0','deltaNeg']);
  const aChoices = [1,2,3,-1,-2,-3]; // âœ… coefficients plus gros pour a

      let a,b,c,d;
      let crit = []; // zÃ©ros de f'(x)

      if(mode==='sym'){
        // CAS DÃ‰JÃ€ EXISTANT : f'(x) = 3a(x^2 - k^2)
    a = choice(aChoices);
        const k = choice([1,2]);
        b = 0;
        c = -3*a*k*k;
        d = rint(-4,4);
        crit = [-k,k];
      }else if(mode==='delta0'){
        // f'(x) = 3a(x-Î±)^2 â†’ Î”=0
    a = choice(aChoices);
        const alpha = choice([-2,-1,0,1,2]);
        b = -3*a*alpha;
        c =  3*a*alpha*alpha;
        d = rint(-4,4);
        crit = [alpha];
      }else if(mode==='deltaPosNonSym'){
        // f'(x) = 3a(x-r1)(x-r2) avec r1,r2 entiers,
        // Î” = (3a(r1-r2))Â² > 0 et racines NON symÃ©triques
    a = choice(aChoices);
        let r1,r2;
        do{
          r1 = choice([-3,-2,-1,1,2,3]);   // pas 0
          r2 = choice([-3,-2,-1,1,2,3]);
        }while(
          r1===r2 ||
          r1===-r2 ||                 // Ã©vite symÃ©trie
          ((r1+r2)&1)!==0            // somme impaire â†’ b non entier
        );
        b = -3*a*(r1+r2)/2;
        c =  3*a*r1*r2;
        d = rint(-4,4);
        crit = [r1,r2].sort((u,v)=>u-v);
      }else{
        // Î”<0 : on cherche b,c tels que (2b)^2 - 4(3a)c < 0
    a = choice(aChoices);
        let ok=false;
        while(!ok){
          b = rint(-3,3);
          c = rint(-3,3);
          const A2 = 3*a, B1 = 2*b, C0 = c;
          const delta = B1*B1 - 4*A2*C0;
          ok = (delta<0);
        }
        d = rint(-4,4);
        crit = []; // pas de racines rÃ©elles
      }

      const fTex = `f(x) = ${polyTexCubic(a,b,c,d)}`;

      const A2 = 3*a;
      const B1 = 2*b;
      const C0 = c;

      const dfTex   = `f'(x) = ${polyTexQuad(A2,B1,C0)}`;
      const dfTex2   = `${polyTexQuad(A2,B1,C0)}`;

      const dfCanon = polyAscii(A2,B1,C0);

      // points critiques (zÃ©ros de f') triÃ©s
      const critSorted = [...crit].sort((u,v)=>u-v);
      const minCrit = critSorted.length ? critSorted[0] : 0;
      const maxCrit = critSorted.length ? critSorted[critSorted.length-1] : 0;

      const [mL, mR] = randMargins();
      const xL = minCrit - mL;
      const xR = maxCrit + mR;



      const xPts = [xL, ...critSorted, xR];

      const fEval = x => a*x*x*x + b*x*x + c*x + d;
      const fVals = xPts.map(fEval);

      // signes de f' sur les intervalles
      const signPattern = [];
      for(let i=0;i<xPts.length-1;i++){
        const m = (xPts[i]+xPts[i+1])/2;
        const v = A2*m*m + B1*m + C0;
        signPattern.push(v>=0 ? '+' : 'âˆ’');
      }

      // type de chaque abscisse : zÃ©ro de f' ou rien
      const critKind = xPts.map(x=>{
        const isZero = critSorted.some(z=>Math.abs(z-x)<1e-8);
        return isZero ? '0' : '';
      });

      // extremums locaux
      const ext = [];
      for(let j=1;j<xPts.length-1;j++){
        const sL = this._sgn(signPattern[j-1]==='+'?1:-1);
        const sR = this._sgn(signPattern[j]==='+'?1:-1);
        if(sL>0 && sR<0){
          ext.push({x:xPts[j], y:fEval(xPts[j]), type:'max'});
        }else if(sL<0 && sR>0){
          ext.push({x:xPts[j], y:fEval(xPts[j]), type:'min'});
        }
      }

  return {
    family:'cubic',
    // âœ… coefficients de f'(x) = A2 xÂ² + A1 x + A0
    dA: A2,
    dB: B1,
    dC: C0,

    fTex, dfTex,dfTex2, dfCanon,
    xPts,
    fVals,
    yPts: fVals,
    signPattern,
    critKind,
    ext
  };
    }

    // ============== CAS 3 : quotient de deux affines =================
    if(fam==='quot_aff'){
      let a,b,c,d,kDet,xPole;
      do{
        c = choice([-2,-1,1,2]);
        xPole = choice([-2,-1,1,2]);
        d = -c*xPole;
        a = rint(-4,4);
        b = rint(-4,4);
        kDet = a*d - b*c;
      }while(!kDet);

      const numTex = `${a===0?'':(a===1?'x':(a===-1?`${UMIN}x`:`${a}x`))}${b===0?'':(b>0?(a?`+${b}`:`${b}`):`${b}`)}` || '0';
      const denTex = `${c===0?'':(c===1?'x':(c===-1?`${UMIN}x`:`${c}x`))}${d===0?'':(d>0?(c?`+${d}`:`${d}`):`${d}`)}` || '0';
      const fTex  = `f(x) = \\dfrac{${numTex}}{${denTex}}`;

      const kAbs  = Math.abs(kDet);
      const signK = kDet>0 ? '' : UMIN;
const dfTex = `f'(x) = \\dfrac{${signK}${kAbs}}{\\bigl(${denTex}\\bigr)^2}`;
const dfTex2 = `\\dfrac{${signK}${kAbs}}{\\bigl(${denTex}\\bigr)^2}`;

// mÃªme dÃ©nominateur que dans l'Ã©noncÃ©, mais sans espaces et avec "-" ascii
const denCanonRaw = denTex
  .replace(/\s+/g,'')
  .replace(/\u2212/g,'-');

const dfCanon  = `${kDet}/(${denCanonRaw})^2`;
const dfDenTex = `\\bigl(${denTex}\\bigr)^2`;

      const dfNumTex = `${signK}${kAbs}`;
      const [mL, mR] = randMargins();
      const xL = xPole - mL;
      const xR = xPole + mR;


      const xPts = [xL, xPole, xR];


      const fEval = x => (x===xPole ? null : (a*x + b)/(c*x + d));
      const fVals = xPts.map(fEval);

      const s = this._sgn(kDet);
      const signPattern = [s>0?'+':'âˆ’', s>0?'+':'âˆ’'];

      // dÃ©rivÃ©e non dÃ©finie en xPole â†’ double barre
      const critKind = ['', 'bar', ''];

      const ext = []; // pas dâ€™extremums locaux

             const uTex      = numTex || '0';
  const vTex      = denTex || '0';
  const uPrimeTex = String(a).replace(/-/g, UMIN);
  const vPrimeTex = String(c).replace(/-/g, UMIN);

      return {
        family:'quot_aff',
        fTex, dfTex, dfCanon,
        xPts,
        fVals,
        yPts: fVals,
        signPattern,
        critKind,
        ext,
        // on mÃ©morise les coefficients de u et v pour dÃ©velopper le numÃ©rateur
        qA: a,   // u(x) = a x + b
        qB: b,
        qC: c,   // v(x) = c x + d
        qD: d,
        // ===== info pour la dÃ©rivation du quotient (mÃªme logique que la fiche Quotient) =====
        uTex,
        vTex,
        uPrimeTex,
        vPrimeTex,
        // infos numÃ©rateur/dÃ©nominateur de f'
        dNumType: 'const',
        dNumA2: 0,
        dNumB1: 0,
        dNumC0: kDet,      // numÃ©rateur = kDet
        dNumTex: dfNumTex, // TeX du numÃ©rateur
        dDenTex: dfDenTex  // TeX du dÃ©nominateur (dÃ©jÃ  au carrÃ©)
      };

}


    

    // ============== CAS 4 : quotients avec dÃ©nominateur du 2nd degrÃ© =================
    if(fam==='quot_aff_quad'){
      // 3 formes :
      // 1) f(x) = m x / (xÂ² âˆ’ aÂ²)          -> numÃ©rateur de f' : 2nd degrÃ© (Î”<0)
      // 2) f(x) = k / (xÂ² + s)            -> numÃ©rateur affine (âˆ’2kx)
      // 3) f(x) = (px+q)/(xÂ² + s)         -> numÃ©rateur 2nd degrÃ© avec Î”>0 carrÃ© parfait
      const mode = choice(['mx_over_diffSquares','const_over_quad','aff_over_quad_deltaPos']);
      let denBaseTex = '';
      let uTex = '', vTex = '', uPrimeTex = '', vPrimeTex = '';

      let fTex, dfTex, dfCanon;
      let fEval;
      let critZeros = []; // zÃ©ros de f'
      let critBars  = []; // pÃ´les (double barre)
      let A2=0,B1=0,C0=0; // numÃ©rateur de f'(x) = (A2 xÂ² + B1 x + C0) / (â€¦ )Â²

      // on mÃ©morise aussi le type de quotient et ses paramÃ¨tres
      let quotKind = mode;
      let mCoef = null, aParam = null;
      let kConst = null, sParam = null;
      let pCoef = null, qCoef = null;

      if(mode==='mx_over_diffSquares'){
        // CAS : f(x) = m x / (xÂ² âˆ’ aÂ²)
        const m = choice([1,2,-1,-2]);
        const a  = choice([1,2]);

        const numTex = `${m===1?'x':(m===-1?`${UMIN}x`:`${m}x`)}`;
        fTex   = `f(x) = \\dfrac{${numTex}}{x^2 ${UMIN} ${a*a}}`;

        denBaseTex = `x^2 ${UMIN} ${a*a}`;

        const x1=-a,x2=a;
        critBars = [x1,x2];
        critZeros = [];

        // numÃ©rateur dÃ©veloppÃ© : âˆ’m xÂ² âˆ’ m aÂ²
        A2 = -m;
        B1 = 0;
        C0 = -m*a*a;

        fEval = x => (x===-a || x===a ? null : m*x/(x*x - a*a));

        // donnÃ©es u,v,u',v'
        uTex      = numTex;
        vTex      = denBaseTex;
        uPrimeTex = String(m).replace(/-/g, UMIN);
        vPrimeTex = '2x';

        mCoef = m;
        aParam = a;
      }else if(mode==='const_over_quad'){
        // f(x) = k / (xÂ² + s)
        const k = choice([1,2,-1,-2]);
        const sPos = choice([1,2,3]);

        fTex = `f(x) = \\dfrac{${k}}{x^2 + ${sPos}}`;

        denBaseTex = `x^2 + ${sPos}`;

        critBars = [];
        critZeros = [0];

        // numÃ©rateur : âˆ’2kx (affine)
        A2 = 0;
        B1 = -2*k;
        C0 = 0;

        fEval = x => k/(x*x + sPos);

        // donnÃ©es u,v,u',v'
        uTex      = String(k).replace(/-/g, UMIN);
        vTex      = denBaseTex;
        uPrimeTex = '0';
        vPrimeTex = '2x';

        kConst = k;
        sParam = sPos;
      }else{
        // f(x) = (px+q)/(xÂ² + s) avec Î”>0 carrÃ© parfait pour le numÃ©rateur de f'
        let p,q,sPos,t;
        p = choice([1,-1]);
        while(true){
          q = choice([-3,-2,-1,1,2,3]);
          t = choice([1,2,3,4,5]);
          const candidate = t*t - q*q;
          if(candidate>0 && candidate<=9){
            sPos = candidate;
            break;
          }
        }

        const numTop = (p===1?'x':(p===-1?`${UMIN}x`:`${p}x`)) +
                       (q===0?'':(q>0?`+${q}`:`${q}`));
        fTex = `f(x) = \\dfrac{${numTop}}{x^2 + ${sPos}}`;

        denBaseTex = `x^2 + ${sPos}`;

        // numÃ©rateur : A2 xÂ² + B1 x + C0
        A2 = -p;
        B1 = -2*q;
        C0 = p*sPos;

        fEval = x => (p*x + q)/(x*x + sPos);

        // donnÃ©es u,v,u',v'
        uTex      = numTop;
        vTex      = denBaseTex;
        uPrimeTex = String(p).replace(/-/g, UMIN);
        vPrimeTex = '2x';

        // zÃ©ros de f'(x) : deux racines entiÃ¨res
        const r1 = (-q - t)/p;
        const r2 = (-q + t)/p;
        critZeros = [r1,r2].sort((u,v)=>u-v);
        critBars  = [];

        pCoef = p;
        qCoef = q;
        sParam = sPos;
      }

      // â€”â€“ forme finale de f'(x) : numÃ©rateur DÃ‰VELOPPÃ‰ axÂ²+bx+c (sans 1x, sans 1xÂ², sans +0)
      const numDfTex = polyTexQuad(A2,B1,C0);
      dfTex = `f'(x) = \\dfrac{${numDfTex}}{\\bigl(${denBaseTex}\\bigr)^2}`;

      // canon ascii pour la comparaison de saisie
      const numCanon = polyAscii(A2,B1,C0);
      const denCanonRaw = denBaseTex.replace(/\s+/g,'');
      dfCanon = `(${numCanon})/(${denCanonRaw})^2`;

      // ====================== Construction des x pour le tableau ======================
      const crit = [
        ...critZeros.map(x=>({x,kind:'0'})),
        ...critBars.map(x=>({x,kind:'bar'}))
      ].sort((u,v)=>u.x-v.x);

      let xL, xR, xPts, critKind;

      // 1) Cas "2 pÃ´les, aucun zÃ©ro" : f(x) = mx/(xÂ² - aÂ²)
      //    -> intervalle qui SE TERMINE par un seul de ces pÃ´les (plus simple pour les Ã©lÃ¨ves).
      if(critBars.length === 2 && critZeros.length === 0){
        const chosen = choice(critBars); // -a ou a
        xR = chosen;

        // borne gauche : un point du domaine (pas valeur interdite)
        let xCandidate = chosen - 2;
        while(critBars.some(z => Math.abs(z - xCandidate) < 1e-8)){
          xCandidate -= 2;
        }
        xL = xCandidate;

        xPts = [xL, xR];        // borne gauche / pÃ´le Ã  droite
        critKind = ['', 'bar']; // double barre seulement Ã  droite
      }

      // 2) Cas "numÃ©rateur 2nd degrÃ© avec Î”>0" (aff_over_quad_deltaPos)
      //    -> lâ€™intervalle DOIT contenir les 2 racines, et elles doivent apparaÃ®tre dans la ligne x.
      else if(mode === 'aff_over_quad_deltaPos' && critZeros.length === 2 && critBars.length === 0){
        const z1 = critZeros[0];
        const z2 = critZeros[1];
        const zMin = Math.min(z1,z2);
        const zMax = Math.max(z1,z2);

        const [mL, mR] = randMargins();
        xL = zMin - mL;   // une unitÃ© Ã  gauche
        xR = zMax + mR;   // une unitÃ© Ã  droite

        // ligne de x : borne gauche / racine 1 / racine 2 / borne droite
        xPts = [xL, zMin, zMax, xR];
        critKind = ['', '0', '0', ''];
      }

      // 3) Cas gÃ©nÃ©ral : on garde la logique "minCrit - 2 ; maxCrit + 2"
      else{
        const minCrit = crit.length ? crit[0].x : -1;
        const maxCrit = crit.length ? crit[crit.length-1].x : 1;

        const [mL, mR] = randMargins();
        xL = minCrit - mL;
        xR = maxCrit + mR;


        xPts = [xL, ...crit.map(c=>c.x), xR];

        critKind = xPts.map(x=>{
          const bar = critBars.some(z=>Math.abs(z-x)<1e-8);
          if(bar) return 'bar';
          const zero = critZeros.some(z=>Math.abs(z-x)<1e-8);
          return zero ? '0' : '';
        });
      }

      // valeurs de f(x) sur les points retenus
      const fVals = xPts.map(x=> fEval(x));

      // signes de f' sur chaque intervalle
      const signPattern = [];
      for(let i=0;i<xPts.length-1;i++){
        const m = (xPts[i]+xPts[i+1])/2;
        const num = A2*m*m + B1*m + C0;
        const s = num>=0 ? '+' : 'âˆ’';
        signPattern.push(s);
      }

      // extremums : uniquement sur les zÃ©ros de f' (pas sur les pÃ´les)
      const ext = [];
      for(let j=1;j<xPts.length-1;j++){
        if(critKind[j] !== '0') continue; // on ignore pÃ´les & points quelconques
        const sL = this._sgn(signPattern[j-1]==='+'?1:-1);
        const sR = this._sgn(signPattern[j]==='+'?1:-1);
        if(sL>0 && sR<0){
          ext.push({x:xPts[j], y:fVals[j], type:'max'});
        }else if(sL<0 && sR>0){
          ext.push({x:xPts[j], y:fVals[j], type:'min'});
        }
      }

      const dDenTex = denBaseTex ? `\\bigl(${denBaseTex}\\bigr)^2` : '';
      const dfTex2 = ` ${numDfTex}`;

      return {
        family:'quot_aff_quad',
        fTex, dfTex,dfTex2, dfCanon,
        xPts,
        fVals,
        yPts: fVals,
        signPattern,
        critKind,
        ext,
        // mÃ©morisation pour les Ã©tapes de calcul
        quotKind,
        mCoef,
        aParam,
        kConst,
        sParam,
        pCoef,
        qCoef,
        // donnÃ©es pour la rÃ©daction "MÃ©thode â€” RÃ¨gle du quotient"
        uTex,
        vTex,
        uPrimeTex,
        vPrimeTex,
        // infos numÃ©rateur/dÃ©nominateur de f'
        dNumType: (A2 !== 0 ? 'quad' : (B1 !== 0 ? 'lin' : 'const')),
        dNumA2: A2,
        dNumB1: B1,
        dNumC0: C0,
        dNumTex: numDfTex,
        dDenTex
      };
    }




    
  },

 // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Rendu
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
render(host, st){
  const famLabel = this._familyLabel(st.family);
  const UMIN = 'âˆ’';

  // points du tableau
  const xPts = st.xPts;
  const critKind = st.critKind || [];
  const n = xPts.length;

  const signPattern = st.signPattern || [];

  // cas spÃ©cial : 3 points, un seul zÃ©ro au milieu, mÃªme signe de chaque cÃ´tÃ©
  const specialSingleArrow =
    (n === 3 &&
     signPattern.length === 2 &&
     critKind[1] === '0' &&
     (signPattern[0] === '+' || signPattern[0] === 'âˆ’') &&
     signPattern[0] === signPattern[1]);



  const SX = x => String(x).replace(/-/g, UMIN);

  const xLeft  = xPts[0];
  const xRight = xPts[n-1];

  // crochets en fonction des valeurs interdites aux bornes
  let leftDelim  = '\\left[';
  let rightDelim = '\\right]';

  if(critKind[0] === 'bar')      leftDelim  = '\\left]';
  if(critKind[n-1] === 'bar')    rightDelim = '\\right[';

  const intervalTex = `${leftDelim}${SX(xLeft)};${SX(xRight)}${rightDelim}`;



  // rÃ´les pour les colonnes : xmin, c1, c2, ..., xmax
  const roles = (()=>{
    if(n <= 2) return ['xmin','xmax'];
    const inner = Array.from({length: n-2}, (_,i)=> 'r'+(i+1));
    return ['xmin', ...inner, 'xmax'];
  })();

  function rowX(){
    let r = '<tr><th>\\(x\\)</th>';
    for(let j=0; j<roles.length; j++){
      const role = roles[j];
      r += `<td><input class="dvx" data-role="${role}" type="text" placeholder="${role}"></td>`;
      if(j < roles.length-1) r += '<td></td>'; // colonne d'intervalle
    }
    r += '</tr>';
    return r;
  }

  function rowFp(){
    let r = '<tr><th style="border-top:1.5px solid #000">\\(f\'(x)\\)</th>';
    for(let j=0; j<roles.length; j++){
      const role = roles[j];
      // cellule sous l'abscisse : 0 / ||
      r += `
        <td class="bigsel" style="border-top:1.5px solid #000">
          <select class="dvz" data-role="${role}">
            <option value=""></option>
            <option value="0">0</option>
            <option value="||">||</option>
          </select>
        </td>
      `;
      // signe sur l'intervalle suivant
      if(j < roles.length-1){
        r += `
          <td class="bigsel" style="border-top:1.5px solid #000">
            <select class="dvs" data-i="${j}">
              <option></option>
              <option>+</option>
              <option>${UMIN}</option>
            </select>
          </td>
        `;
      }
    }
    r += '</tr>';
    return r;
  }

     function rowF(){
    let r = '<tr><th style="border-top:1.5px solid #000">\\(f\\)</th>';

    for(let j=0; j<roles.length; j++){
      const role = roles[j];

      // colonne centrale sous la racine, dans le cas Î”=0 avec +0+ ou âˆ’0âˆ’
      const isCentralZero =
        specialSingleArrow &&
        roles.length === 3 &&   // xmin, c1, xmax
        j === 1 &&              // colonne du milieu
        critKind[1] === '0';

      // ----- cellule sous x -----
      if(isCentralZero){
        // pas de max/min sous la racine : juste la flÃ¨che
        r += `
          <td style="border-top:1.5px solid #000">
            <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
              <select class="dvd dvd-mid" data-i="0">
                <option></option>
                <option>â†˜</option>
                <option>â†—</option>
                <option>â†’</option>
              </select>
            </div>
          </td>
        `;
      }else{
        // cas gÃ©nÃ©ral : || + max + min comme avant
        r += `
          <td style="border-top:1.5px solid #000">
            <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
              <select class="vfmark" data-role="${role}">
                <option value=""></option>
                <option value="||">||</option>
              </select>
              <input class="dvYmax" data-role="${role}" type="text" placeholder="max">
              <input class="dvYmin" data-role="${role}" type="text" placeholder="min">
            </div>
          </td>
        `;
      }

      // ----- cellule d'intervalle Ã  droite (flÃ¨che classique) -----
      if(j < roles.length-1){
        if(specialSingleArrow){
          // dans ce cas : PAS de flÃ¨che entre les colonnes, elle est sous la racine
          r += `<td style="border-top:1.5px solid #000"></td>`;
        }else{
          r += `
            <td class="bigsel" style="border-top:1.5px solid #000">
              <select class="dvd" data-i="${j}">
                <option></option>
                <option>â†˜</option>
                <option>â†—</option>
                <option>â†’</option>
              </select>
            </td>
          `;
        }
      }
    }

    r += '</tr>';
    return r;
  }



  host.innerHTML = `
    <div style="margin-bottom:.35rem">
      <label>
        <b>Type de fonction :</b>
        <select class="fam-select" style="margin-left:.4rem">
          <option value="quad">PolynÃ´me du second degrÃ©</option>
          <option value="cubic">PolynÃ´me du 3Ã¨me degrÃ©</option>
          <option value="quot_aff">Quotient de fonctions affines</option>
          <option value="quot_aff_quad">Quotient (numÃ©rateur affine, dÃ©nominateur du 2nd degrÃ©)</option>
        </select>
      </label>
    </div>

    <div>
      On considÃ¨re une fonction \\(f\\) qui est <b>${famLabel}</b>,
      dÃ©finie par :
      <div style="margin:.35rem 0 .2rem 0">\\(${st.fTex}\\)</div>
      <ol style="margin:.35rem 0 0 1.1rem;padding-left:.2rem">
        <li>Calculer sa dÃ©rivÃ©e \\(f'(x)\\).</li>
        <li>Donner le <b>tableau de signes</b> de \\(f'(x)\\)  sur l'intervalle \\(${intervalTex}\\).</li>
        <li>Donner le <b>tableau de variations</b> de \\(f\\)  sur l'intervalle \\(${intervalTex}\\).</li>
      </ol>
    </div>

    <div class="pdf-hide" style="margin-top:.45rem">
      \\(f'(x) =\\)
      <input type="text" class="df-input"
             style="width:260px;max-width:100%;text-align:left"
             placeholder="">
      <span class="tick nu"></span>
    </div>

    <div class="var-wrap pdf-hide" style="margin-top:.6rem">
      <table class="pdf-tbl">
        <tbody>
          ${rowX()}
          ${rowFp()}
          ${rowF()}
        </tbody>
      </table>
    </div>


    <div class="steps small" id="res" style="margin-top:.45rem"></div>
  `;

  // sÃ©lecteur de famille â†’ rÃ©gÃ©nÃ¨re un nouvel Ã©tat
  const famSel = host.querySelector('.fam-select');
  if(famSel){
    famSel.value = st.family;
    famSel.addEventListener('change', ()=>{
      const famKey = famSel.value;
      const newSt = this.gen(famKey);
      host.dataset.state = JSON.stringify(newSt);
      this.render(host, newSt);
    });
  }

  // tick sur la dÃ©rivÃ©e
  const dfInput = host.querySelector('.df-input');
  if(dfInput){
    ensureTickAfter(dfInput);
    dfInput.addEventListener('input', ()=>ensureTickAfter(dfInput));
  }

  // ticks pour signes / 0 / barres / flÃ¨ches du tableau
  host.querySelectorAll('.dvz, .dvs, .dvd, .vfmark').forEach(sel=>{
    ensureTickAfter(sel);
    sel.addEventListener('change', ()=>ensureTickAfter(sel));
  });

  // ticks pour les valeurs de f (max/min dans le tableau)
  host.querySelectorAll('.dvYmax, .dvYmin').forEach(inp=>{
    ensureTickAfter(inp);
    inp.addEventListener('input', ()=>ensureTickAfter(inp));
  });
  // ticks pour la ligne x
  host.querySelectorAll('.dvx').forEach(inp=>{
    ensureTickAfter(inp);
    inp.addEventListener('input', ()=>ensureTickAfter(inp));
  });

  // ticks pour les abscisses dâ€™extremums en bas
  ['.ext-max', '.ext-min'].forEach(sel=>{
    const inp = host.querySelector(sel);
    if(inp){
      ensureTickAfter(inp);
      inp.addEventListener('input', ()=>ensureTickAfter(inp));
    }
  });

  typesetAll(host);
},

  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Correction
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  correct(host, st){
    const UMIN        = 'âˆ’';
    const signPattern = st.signPattern || [];
    const critKind    = st.critKind    || [];
    const xPts        = st.xPts        || [];
    const fVals       = st.fVals || st.yPts || [];
    const extList     = st.ext  || [];
    const n           = xPts.length;

    // rÃ´les (cohÃ©rents avec render)
const roles = (()=>{
  if(n <= 2) return ['xmin','xmax'];
  const inner = Array.from({length:n-2}, (_,i)=> 'r'+(i+1)); // mÃªme logique que dans render
  return ['xmin', ...inner, 'xmax'];
})();

    const roleIndex = role => roles.indexOf(role);

    const expectedDir = signPattern.map(s => s === '+' ? 'â†—' : 'â†˜');

    const specialSingleArrow =
      (n === 3 &&
       signPattern.length === 2 &&
       critKind[1] === '0' &&
       (signPattern[0] === '+' || signPattern[0] === 'âˆ’') &&
       signPattern[0] === signPattern[1]);

    // parse nombre ou fraction "11/2"
    const parseNum = str => {
      const t = (str || '').trim();
      if(!t) return NaN;

      const norm = t
        .replace(UMIN, '-')   // moins unicode
        .replace(',', '.');   // virgule â†’ point

      const m = norm.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/);
      if(m){
        const num = parseFloat(m[1]);
        const den = parseFloat(m[2]);
        if(den === 0) return NaN;
        return num / den;
      }
      return Number(norm);
    };

    let ok        = 0;
    let tot       = 0;
    let allFilled = true;  // devient false dÃ¨s qu'une case obligatoire est vide

    // â€”â€”â€” 1) DÃ‰RIVÃ‰E f'(x) â€”â€”â€”
    const dfInput = host.querySelector('.df-input');
    if(dfInput){
      const raw = (dfInput.value || '').trim();
      if(!raw){
        allFilled = false;
        setTick(dfInput,'nu');
      }else{
        const user = this._normDeriv(raw);
        const good = this._normDeriv(st.dfCanon || '');
        tot++;
        if(user === good){
          ok++;
          setTick(dfInput,'ok');
        }else{
          setTick(dfInput,'ko');
        }
      }
    }

    // â€”â€”â€” 2) LIGNE x â€”â€”â€”
    host.querySelectorAll('.dvx').forEach(inp=>{
      const role = inp.dataset.role;
      const j    = roleIndex(role);
      const expectedX = (j >= 0 ? xPts[j] : null);
      const val  = (inp.value || '').trim();

      if(expectedX === null || expectedX === undefined){
        setTick(inp,'nu');
        return;
      }

      if(!val){
        allFilled = false;
        setTick(inp,'nu');
        return;
      }

      const u = parseNum(val);
      tot++;
      const good = Number.isFinite(u) && Math.abs(u - expectedX) < 1e-6;
      if(good){ ok++; setTick(inp,'ok'); }
      else     {       setTick(inp,'ko'); }
    });

    // â€”â€”â€” 3) f'(x) : 0 / || â€”â€”â€”
    host.querySelectorAll('.dvz').forEach(sel=>{
      const val   = (sel.value || '').trim();
      const role  = sel.dataset.role;
      const j     = roleIndex(role);
      const expected = (j >= 0 ? (critKind[j] || '') : '');

      if(!expected){
        if(!val){
          setTick(sel,'nu');   // facultatif
        }else{
          tot++;
          const good = (val === '');
          if(good){ ok++; setTick(sel,'ok'); }
          else     {       setTick(sel,'ko'); }
        }
        return;
      }

      if(!val){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      tot++;
      let good = false;
      if(expected === '0')   good = (val === '0');
      if(expected === 'bar') good = (val === '||');

      if(good){ ok++; setTick(sel,'ok'); }
      else     {       setTick(sel,'ko'); }
    });

    // â€”â€”â€” 4) f'(x) : signe â€”â€”â€”
    host.querySelectorAll('.dvs').forEach(sel=>{
      const idx = +sel.dataset.i;
      const v   = (sel.value || '').trim();

      if(idx < 0 || idx >= signPattern.length){
        setTick(sel,'nu');
        return;
      }

      if(!v){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      tot++;
      const goodSign = (signPattern[idx] === '+' ? '+' : UMIN);
      const good     = (v === goodSign);

      if(good){ ok++; setTick(sel,'ok'); }
      else     {       setTick(sel,'ko'); }
    });

    // â€”â€”â€” 5) f : barres || â€”â€”â€”
    host.querySelectorAll('.vfmark').forEach(sel=>{
      const val  = (sel.value || '').trim();
      const role = sel.dataset.role;
      const j    = roleIndex(role);
      const isBar = (j >= 0 && critKind[j] === 'bar');

      if(!isBar){
        if(!val){
          setTick(sel,'nu');
        }else{
          tot++;
          const good = (val === '');
          if(good){ ok++; setTick(sel,'ok'); }
          else     {       setTick(sel,'ko'); }
        }
        return;
      }

      if(!val){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      tot++;
      const good = (val === '||');
      if(good){ ok++; setTick(sel,'ok'); }
      else     {       setTick(sel,'ko'); }
    });

    // â€”â€”â€” 6) f : flÃ¨ches de variation â€”â€”â€”
    host.querySelectorAll('.dvd').forEach(sel=>{
      const v   = (sel.value || '').trim();
      const idx = +sel.dataset.i;

      if(!v){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      if(!specialSingleArrow){
        if(idx < 0 || idx >= expectedDir.length){
          setTick(sel,'nu');
          return;
        }
        tot++;
        const good = (v === expectedDir[idx]);
        if(good){ ok++; setTick(sel,'ok'); }
        else     {       setTick(sel,'ko'); }
      }else{
        const wanted = (signPattern[0] === '+' ? 'â†—' : 'â†˜');
        tot++;
        const good = (v === wanted);
        if(good){ ok++; setTick(sel,'ok'); }
        else     {       setTick(sel,'ko'); }
      }
    });

    // â€”â€”â€” 7) f : valeurs (bornes + extremums) â€”â€”â€”
    const yAt = j => (fVals[j] !== undefined && fVals[j] !== null)
                      ? fVals[j]
                      : null;

    for(let j=0;j<n;j++){
      const role = roles[j];
      const kind = critKind[j] || '';
      const x0   = xPts[j];
      const y    = yAt(j);

      const inpTop = host.querySelector(`.dvYmax[data-role="${role}"]`);
      const inpBot = host.querySelector(`.dvYmin[data-role="${role}"]`);

      if(!inpTop || !inpBot){
        continue;
      }

      // cas oÃ¹ f n'est pas dÃ©finie : aucune valeur attendue
      if(kind === 'bar' || y === null){
        const vTop = (inpTop.value || '').trim();
        const vBot = (inpBot.value || '').trim();
        if(!vTop) setTick(inpTop,'nu'); else { tot++; setTick(inpTop,'ko'); }
        if(!vBot) setTick(inpBot,'nu'); else { tot++; setTick(inpBot,'ko'); }
        continue;
      }

      // extremum local ?
      const extMaxHere = extList.find(e => e.type === 'max' && e.x === x0);
      const extMinHere = extList.find(e => e.type === 'min' && e.x === x0);

      const vTop = (inpTop.value || '').trim();
      const vBot = (inpBot.value || '').trim();

      // ===== CAS EXTREMUM LOCAL =====
      if(extMaxHere || extMinHere){
        const valExpected = (extMaxHere || extMinHere).y;

        if(extMaxHere){
          // top obligatoire, bottom doit rester vide
          if(!vTop){
            allFilled = false;
            setTick(inpTop,'nu');
          }else{
            tot++;
            const u = parseNum(vTop);
            const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
            if(good){ ok++; setTick(inpTop,'ok'); }
            else     {       setTick(inpTop,'ko'); }
          }

          if(!vBot){
            setTick(inpBot,'nu');
          }else{
            tot++;
            setTick(inpBot,'ko');
          }
        }else{
          // min local : bottom obligatoire, top vide
          if(!vBot){
            allFilled = false;
            setTick(inpBot,'nu');
          }else{
            tot++;
            const u = parseNum(vBot);
            const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
            if(good){ ok++; setTick(inpBot,'ok'); }
            else     {       setTick(inpBot,'ko'); }
          }

          if(!vTop){
            setTick(inpTop,'nu');
          }else{
            tot++;
            setTick(inpTop,'ko');
          }
        }
        continue;
      }

      // ===== CAS BORNE / POINT SANS EXTREMUM =====
      // Il faut Ã©crire f(x_j) soit en haut, soit en bas (on accepte les deux).
      const valExpected = y;

      const hasTop = !!vTop;
      const hasBot = !!vBot;

      if(!hasTop && !hasBot){
        // rien Ã©crit â†’ obligatoire
        allFilled = false;
        setTick(inpTop,'nu');
        setTick(inpBot,'nu');
        continue;
      }

      if(hasTop && hasBot){
        // deux valeurs : on pÃ©nalise les deux
        tot += 2;
        setTick(inpTop,'ko');
        setTick(inpBot,'ko');
        continue;
      }

      if(hasTop){
        tot++;
        const u = parseNum(vTop);
        const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
        if(good){ ok++; setTick(inpTop,'ok'); }
        else     {       setTick(inpTop,'ko'); }
        setTick(inpBot,'nu');
      }else{ // hasBot
        tot++;
        const u = parseNum(vBot);
        const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
        if(good){ ok++; setTick(inpBot,'ok'); }
        else     {       setTick(inpBot,'ko'); }
        setTick(inpTop,'nu');
      }
    }

    // â€”â€”â€” 8) RÃ©sumÃ© â€”â€”â€”
    const res = $('#res', host);
    if(res){
      res.innerHTML = '';
      ensureTickAfter(res).className = 'tick ' + (tot > 0 && ok === tot ? 'ok' : 'nu');
    }

    // â€”â€”â€” 9) si tout rempli et tout bon â†’ ticks vertes partout â€”â€”â€”
    if(tot > 0 && ok === tot && allFilled){
      host.querySelectorAll('.tick').forEach(t=>{
        t.className = 'tick ok';
      });
    }

    return { ok, total: tot };
  },




  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Solution
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  solution(host, st){
    const famLabel   = this._familyLabel(st.family);
    const SX         = x => this._SX(x);
    const xPts       = st.xPts || [];
    const fVals      = st.fVals || [];
    const n          = xPts.length;

    const signPattern = st.signPattern || [];   // signes de f' sur les intervalles
    const critKind    = st.critKind || [];      // ['', '0', 'bar', ...]
    const dirPattern  = signPattern.map(s => s === '+' ? 'â†—' : 'â†˜');

    const UMIN = 'âˆ’';
    const isQuot = (st.family === 'quot_aff' || st.family === 'quot_aff_quad');

    // approxime un flottant par une fraction raisonnable
    function floatToFrac(x, maxDen = 30){
      let sign = 1;
      if(x < 0){ sign = -1; x = -x; }
      let bestN = 0, bestD = 1;
      let bestErr = Infinity;
      for(let d = 1; d <= maxDen; d++){
        const n = Math.round(x * d);
        const approx = n / d;
        const err = Math.abs(x - approx);
        if(err < bestErr - 1e-12){
          bestErr = err;
          bestN = n;
          bestD = d;
        }
      }
      return { n: sign * bestN, d: bestD };
    }

// Ã‰tapes dÃ©taillÃ©es pour rÃ©soudre une Ã©quation linÃ©aire A x + B = 0
// âš ï¸ Cette fonction renvoie maintenant du HTML (div + TeX ligne par ligne)
function linearSolveStepsTex(A, B, label){
  label = label || "f'(x)";
  const UMIN = 'âˆ’';

  // approxime un flottant par une fraction raisonnable (on rÃ©utilise ta floatToFrac du haut)
  const fmtFrac = (fr) => {
    if(fr.d === 1){
      return String(fr.n).replace(/-/g, UMIN);
    }
    const sign = fr.n < 0 ? UMIN : '';
    const nAbs = Math.abs(fr.n);
    return `${sign}\\dfrac{${nAbs}}{${fr.d}}`;
  };

  const lines = [];

  // ===== CAS B = 0 =====
  if(B === 0){
    if(Math.abs(A) === 1){
      // jamais 1x, et si |A| = 1 : 2 lignes
      lines.push(`${label} = 0`);
      lines.push(`x = 0`);
    }else{
      lines.push(`${label} = 0`);
      lines.push(`${A}x = 0`);
      lines.push(`x = 0`);
    }
  }else{
    // ===== CAS GÃ‰NÃ‰RAL B â‰  0 =====
    const frac = floatToFrac(-B / A, 30);
    const xTex = fmtFrac(frac);

    const absB  = Math.abs(B);
    const signB = B > 0 ? '+ ' : 'âˆ’ ';

    let firstTerm;
    if(Math.abs(A) === 1){
      firstTerm = (A === 1 ? 'x' : 'âˆ’x');
    }else{
      firstTerm = `${A}x`;
    }
    const line2 = `${firstTerm} ${signB}${absB} = 0`;

    let line3;
    if(Math.abs(A) === 1){
      line3 = `x = ${(-B).toString().replace(/-/g, UMIN)}`;
    }else{
      line3 = `${A}x = ${(-B).toString().replace(/-/g, UMIN)}`;
    }
    const line4 = `x = ${xTex}`;
  const vTex      = st.vTex      || 'v(x)';

    // cas spÃ©cial pour v(x) avec A = Â±1 : seulement 2 lignes
    if(label === 'v(x)' && Math.abs(A) === 1){
      lines.push(`v(x) = 0`);
      lines.push(`${vTex} = 0`); // tu peux adapter si tu veux une autre 2e ligne
      lines.push(`x = ${xTex}`);
    }else{
      lines.push(`${label} = 0`);
      lines.push(line2);
      lines.push(line3);
      lines.push(line4);
    }
  }

  // on renvoie du HTML : une div englobante + une div par Ã©quation, chacune en TeX
  return `
    <div class="eq-steps">
      ${lines.map(t => `
        <div class="eq-line" style="text-align:left">\\(${t}\\)</div>
      `).join('')}
    </div>
  `;
}


// RÃ©solution dÃ©taillÃ©e d'une Ã©quation du 2nd degrÃ© : A xÂ² + B x + C = 0
// âš ï¸ Renvoie du HTML (div + TeX ligne par ligne)
function quadSolveStepsTex(A, B, C){
  const UMIN = 'âˆ’';

  function floatToFracLocal(x, maxDen=200){
    let sign = 1;
    if(x < 0){ sign = -1; x = -x; }
    let bestN = 0, bestD = 1;
    let bestErr = Infinity;
    for(let d = 1; d <= maxDen; d++){
      const n = Math.round(x * d);
      const approx = n / d;
      const err = Math.abs(x - approx);
      if(err < bestErr - 1e-12){
        bestErr = err;
        bestN = n;
        bestD = d;
      }
    }
    return { n: sign * bestN, d: bestD };
  }

  const fmtFrac = (fr) => {
    if(fr.d === 1){
      return String(fr.n).replace(/-/g, UMIN);
    }
    const sign = fr.n < 0 ? UMIN : '';
    const nAbs = Math.abs(fr.n);
    return `${sign}\\dfrac{${nAbs}}{${fr.d}}`;
  };

  const Atex = (A<0?`(${A})`:A);
  const Btex = (B<0?`(${B})`:B);
  const Ctex = (C<0?`(${C})`:C);

  const lines = [];

  // ===== CAS TRÃˆS SIMPLE : AxÂ² = 0 (B = 0 et C = 0) =====
  if(B === 0 && C === 0){
    lines.push(`${st.dfTex2} = 0`);
    lines.push(`x^{2} = 0`);
    lines.push(`x = 0`);
  }
  // ===== CAS AxÂ² + C = 0 (B = 0, C â‰  0) =====
  // ===== CAS AxÂ² + C = 0 (B = 0, C â‰  0) =====
else if(B === 0 && C !== 0){
  const k = -C / A;
  const kFrac = floatToFracLocal(k, 200);
  const kTex  = fmtFrac(kFrac);

  lines.push(`${st.dfTex2} = 0`);

  if (Math.abs(A) === 1){
    // si A = 1 ou -1 : on passe directement Ã  xÂ² = k, 
    // sinon on aurait une ligne doublon
    lines.push(`x^{2} = ${kTex}`);
  } else {
    const Acoef = String(A).replace(/-/g, UMIN);
    lines.push(`${Acoef}x^{2} = ${String(-C).replace(/-/g, UMIN)}`);
    lines.push(`x^{2} = ${kTex}`);
  }

  if(k < 0){
    lines.push(`TEXT:Comme \\(${kTex}\\) est nÃ©gatif, il n'y a pas de solution rÃ©elle.`);
  }else if(k === 0){
    lines.push(`x = 0`);
  }else{
    const sqrtK   = Math.sqrt(k);
    const x1Frac  = floatToFracLocal(-sqrtK, 200);
    const x2Frac  = floatToFracLocal( sqrtK, 200);
    const x1Tex   = fmtFrac(x1Frac);
    const x2Tex   = fmtFrac(x2Frac);
    lines.push(`x = ${x1Tex} \\text{ ou } x = ${x2Tex}`);
  }
}

  // ===== CAS AxÂ² + Bx = 0 (C = 0, B â‰  0) =====
  else if(C === 0 && B !== 0){
    const frac = floatToFracLocal(-B / A, 200);
    const solTex = fmtFrac(frac);

    lines.push(`${st.dfTex2} = 0`);
    lines.push(`x\\bigl(${A}x + ${Btex}\\bigr) = 0`);
    lines.push(`x = 0 \\text{ ou } ${A}x + ${Btex} = 0`);
    lines.push(`${A}x = ${String(-B).replace(/-/g, UMIN)}`);
    lines.push(`x = ${solTex}`);
  }
  // ===== CAS GÃ‰NÃ‰RAL : Î” =====
  else{
    const prod4ac = 4 * A * C;
    const b2      = B * B;

    const bSquaredTex = (B < 0) ? `(${B})^{2}` : `${B}^{2}`;
    const prettyProd  = `4 \\times ${A<0?`(${A})`:A} \\times ${C<0?`(${C})`:C}`;

    const middle = prod4ac < 0
      ? `${b2} + ${Math.abs(prod4ac)}`
      : `${b2} - ${prod4ac}`;

    const Delta = b2 - prod4ac;
    const tail  = Delta > 0 ? ' > 0'
                 : Delta < 0 ? ' < 0'
                 : ' = 0';

    const sqrtD   = Math.sqrt(Delta);

    lines.push(`\\Delta = b^{2} - 4ac = ${bSquaredTex} - ${prettyProd} = ${middle} = ${Delta}${tail}`);

    if(Delta < 0){
      lines.push(`\\text{Donc lâ€™Ã©quation } f'(x)=0 \\text{ nâ€™admet pas de solution rÃ©elle.}`);
    }else if(Delta === 0){
      const frac = floatToFracLocal(-B/(2*A), 200);
      const alphaTex = fmtFrac(frac);
      lines.push(`\\alpha = \\dfrac{-b}{2a} = \\dfrac{${-B}}{2\\times ${A<0?`(${A})`:A}} = ${alphaTex}`);
    }else{
      const x1frac  = floatToFracLocal((-B - sqrtD)/(2*A), 200);
      const x2frac  = floatToFracLocal((-B + sqrtD)/(2*A), 200);
      const x1Tex   = fmtFrac(x1frac);
      const x2Tex   = fmtFrac(x2frac);

      lines.push(`\\sqrt{\\Delta}=${sqrtD}`);
      lines.push(`x_1 = \\dfrac{-b - \\sqrt{\\Delta}}{2a} = \\dfrac{${-B} - ${sqrtD}}{2\\times ${A<0?`(${A})`:A}} = ${x1Tex}`);
      lines.push(`x_2 = \\dfrac{-b + \\sqrt{\\Delta}}{2a} = \\dfrac{${-B} + ${sqrtD}}{2\\times ${A<0?`(${A})`:A}} = ${x2Tex}`);
    }
  }

return `
  <div class="eq-steps">
    ${lines.map(t => {
      if(t.startsWith('TEXT:')){
        const txt = t.slice(5); // on enlÃ¨ve "TEXT:"
        return `<div class="eq-line" style="text-align:left">${txt}</div>`;
      }
      // cas normal : ligne purement math
      return `<div class="eq-line" style="text-align:left">\\(${t}\\)</div>`;
    }).join('')}
  </div>
`;

}




    // TeX pour une valeur de f(x)
    function texVal(v){
      if(v === '' || v === null || v === undefined || Number.isNaN(v)){
        return '&nbsp;';
      }

      const num = Number(v);
      if(!Number.isFinite(num)) return '&nbsp;';

      // Cas quotient : on affiche une fraction si ce n'est pas un entier
      if(isQuot){
        const intPart = Math.round(num);
        if(Math.abs(num - intPart) < 1e-9){
          const s = String(intPart).replace(/-/g, UMIN);
          return `\\(${s}\\)`;
        }
        const {n,d} = floatToFrac(num, 30);
        if(d === 1){
          const s = String(n).replace(/-/g, UMIN);
          return `\\(${s}\\)`;
        }
        const sign = n < 0 ? UMIN : '';
        const absN = Math.abs(n);
        return `\\(${sign}\\dfrac{${absN}}{${d}}\\)`;
      }

      // Sinon (polynÃ´mes) : Ã©criture simple avec virgule
      const s = String(num).replace(/-/g, UMIN).replace('.', ',');
      return `\\(${s}\\)`;
    }

    function cellTopBottom(topVal, bottomVal, extraCls=''){
      const top = texVal(topVal);
      const bot = texVal(bottomVal);
      return `
        <td class="${extraCls}" style="border-top:1.5px solid #000">
          <div style="text-align:center">${top}</div>
          <div style="height:6px"></div>
          <div style="text-align:center">${bot}</div>
        </td>
      `;
    }

    const yAt = j => (fVals[j] !== undefined && fVals[j] !== null) ? fVals[j] : '';

    // ===== Ligne x =====
    function rowX(){
      let r = '<tr><th>\\(x\\)</th>';
      for(let i=0;i<n;i++){
        r += `<td>\\(${SX(xPts[i])}\\)</td>`;
        if(i<n-1) r += '<td></td>';
      }
      r += '</tr>';
      return r;
    }

    // ===== Ligne f'(x) =====
    function rowFpFull(){
      let r = '<tr><th style="border-top:1.5px solid #000">\\(f\'(x)\\)</th>';

      // sous x0
      r += '<td style="border-top:1.5px solid #000"></td>';

      for(let i=0;i<n-1;i++){
        const s = signPattern[i] === '+' ? '+' : UMIN;

        // intervalle
        r += `<td style="border-top:1.5px solid #000">${s}</td>`;

        // sous x_{i+1}
        const j  = i+1;
        if(i<n-1){
          const ck = critKind[j] || '';
          if(ck === '0'){
            r += `<td class="zbar" style="border-top:1.5px solid #000">0</td>`;
          }else if(ck === 'bar'){
            r += `<td class="dbar" style="border-top:1.5px solid #000"></td>`;
          }else{
            r += `<td style="border-top:1.5px solid #000"></td>`;
          }
        }
      }
      r += '</tr>';
      return r;
    }

    // ===== Ligne f : bornes + extremums (max en haut, min en bas) =====
    function rowFFull(){
      if(n === 0) return '';

      let r = '<tr><th style="border-top:1.5px solid #000">\\(f\\)</th>';

      const specialSingleArrow =
        (n === 3 &&
         signPattern.length === 2 &&
         critKind[1] === '0' &&
         (signPattern[0] === '+' || signPattern[0] === 'âˆ’') &&
         signPattern[0] === signPattern[1]);

      const yAt = j => (fVals[j] !== undefined && fVals[j] !== null)
                        ? fVals[j]
                        : '';

      // ----- premiÃ¨re borne x0 -----
      const y0 = yAt(0);
      if(n === 1){
        r += cellTopBottom('', '');
        r += '</tr>';
        return r;
      }else{
        const s0 = signPattern[0];  // signe sur (x0, x1)
        if(s0 === '+'){
          r += cellTopBottom('', y0);
        }else if(s0 === 'âˆ’'){
          r += cellTopBottom(y0, '');
        }else{
          r += cellTopBottom('', '');
        }
      }

      // flÃ¨che unique (si cas spÃ©cial) : â†— si +0+, â†˜ si âˆ’0âˆ’
      const singleArrow =
        specialSingleArrow
          ? (signPattern[0] === '+' ? 'â†—' : 'â†˜')
          : '';

      // ----- colonnes intermÃ©diaires + borne droite -----
      for(let i=0;i<n-1;i++){
        // cellule dâ€™intervalle : flÃ¨che "classique"
        if(specialSingleArrow){
          // pas de flÃ¨che entre les colonnes dans ce cas
          r += `<td style="border-top:1.5px solid #000"></td>`;
        }else{
          r += `<td style="border-top:1.5px solid #000">${dirPattern[i]}</td>`;
        }

        const j      = i+1;
        const isLast = (j === n-1);

        if(isLast){
          // derniÃ¨re borne x_{n-1}
          const kindLast = critKind[j] || '';

          if(kindLast === 'bar'){
            r += `<td class="dbar" style="border-top:1.5px solid #000"></td>`;
          }else{
            const yR    = yAt(j);
            const sLast = signPattern[n-2]; // signe sur (x_{n-2}, x_{n-1})
            if(sLast === '+'){
              r += cellTopBottom(yR, '');
            }else if(sLast === 'âˆ’'){
              r += cellTopBottom('', yR);
            }else{
              r += cellTopBottom('', '');
            }
          }
        }else{
          // colonne centrale (j = 1) avec zÃ©ro et flÃ¨che unique dessous
          const kind = critKind[j] || '';

          if(kind === 'bar'){
            r += `<td class="dbar" style="border-top:1.5px solid #000"></td>`;
          }else if(specialSingleArrow && j === 1){
            // flÃ¨che sous la racine (sans valeur max/min car ce n'est pas un extremum)
            r += `
              <td style="border-top:1.5px solid #000;text-align:center;vertical-align:middle;font-size:1.2em">
                ${singleArrow}
              </td>
            `;
          }else{
            const yj = yAt(j);
            const sL = signPattern[j-1];
            const sR = signPattern[j];

            if(sL === '+' && sR === 'âˆ’'){
              r += cellTopBottom(yj, '');
            }else if(sL === 'âˆ’' && sR === '+'){
              r += cellTopBottom('', yj);
            }else{
              r += cellTopBottom('', '');
            }
          }
        }
      }

      r += '</tr>';
      return r;
    }



    const extMax = (st.ext || []).filter(e=>e.type==='max').map(e=>SX(e.x));
    const extMin = (st.ext || []).filter(e=>e.type==='min').map(e=>SX(e.x));

    const res = $('#res',host);
    if(!res) return;

        // Ã‰tape supplÃ©mentaire : rÃ©solution de f'(x)=0 pour le 2nd degrÃ©
    let extraDerivStep = '';
    if(st.family === 'quad' && typeof st.aCoeff === 'number' && typeof st.bCoeff === 'number'){
      const A = 2*st.aCoeff;   // coefficient de x dans f'(x)
      const B = st.bCoeff;     // terme constant de f'(x)
      const stepsTex = linearSolveStepsTex(A,B);

      extraDerivStep = `
	        <div class="step">
        On calcule la dÃ©rivÃ©e :
        \\[ ${st.dfTex} \\]
      </div>
        <div class="step">
          On Ã©tudie le signe de la dÃ©rivÃ©e en Ã©tudiant d'abord \\(f'(x) = 0\\) :
          
            ${stepsTex}
          
		  On met ensuite le signe de \\(m\\)  Â« Ã  droite Â» du zÃ©ro.
        </div>
      `;
    }
    // Ã‰tape supplÃ©mentaire : rÃ©solution de f'(x) = 0 pour le cas 3Ã¨me degrÃ©
        // Ã‰tape supplÃ©mentaire : rÃ©solution de f'(x) = 0 pour le cas 3Ã¨me degrÃ©
    let extraDerivCubicStep = '';
    if(st.family === 'cubic' && typeof st.dA === 'number'){
      const A = st.dA;
      const B = st.dB || 0;
      const C = st.dC || 0;
      const stepsTex = quadSolveStepsTex(A, B, C);
      const Delta = B*B - 4*A*C;

      let afterText = '';
      if(Delta < 0){
        afterText = `On met ensuite le signe de \\(a\\) dans le tableau du signe de \\(f'(x)\\).`;
      }else if(Delta === 0){
        afterText = `On met ensuite le signe de \\(a\\) Â« Ã  droite et Ã  gauche Â» du zÃ©ro.`;
      }else{
        afterText = `On met ensuite le signe de \\(a\\) Â« Ã  l'extÃ©rieur Â» des racines.`;
      }

      extraDerivCubicStep = `
	        <div class="step">
        On calcule la dÃ©rivÃ©e :
        \\[ ${st.dfTex} \\]
      </div>
        <div class="step">
          On Ã©tudie le signe de la dÃ©rivÃ©e en Ã©tudiant d'abord \\(f'(x) = 0\\) :
      
            ${stepsTex}
        
          ${afterText}
        </div>
      `;
    }

// Ã‰tape supplÃ©mentaire : fonctions quotient â€” mÃªme esprit que ta fiche Quotient / Inverse
let extraDerivQuotStep = '';
if((st.family === 'quot_aff' || st.family === 'quot_aff_quad') && st.dDenTex){
  const numType = st.dNumType || 'const';
  const denTex  = st.dDenTex;
  const numTex  = st.dNumTex || '';
  const A = st.dNumA2 || 0;
  const B = st.dNumB1 || 0;
  const C = st.dNumC0 || 0;
// pour afficher Ã©ventuellement >0 ou <0 aprÃ¨s le numÃ©rateur
let numSignIneq = '';
if(numType === 'const' && typeof C === 'number'){
  if(C > 0)      numSignIneq = ' > 0';
  else if(C < 0) numSignIneq = ' < 0';
  else           numSignIneq = ' = 0';
}

  const uTex      = st.uTex      || 'u(x)';
  const vTex      = st.vTex      || 'v(x)';
  const uPrimeTex = st.uPrimeTex || "u'(x)";
  const vPrimeTex = st.vPrimeTex || "v'(x)";

  const defDomLine =
    `<strong>Ensemble de dÃ©finition :</strong>\\( \\) \\( \\mathcal{D}_f = \\{ x \\in \\mathbb{R} \\mid ${vTex} \\neq 0 \\} \\).`;

  // RÃ©solution de v(x)=0 pour le cas quotient affine (dÃ©nominateur affine)
  let domSolveBlock = '';
  if(st.family === 'quot_aff' && typeof st.qC === 'number'){
    const A = st.qC;   // coefficient de x dans v(x)
    const B = st.qD;   // terme constant de v(x)
    const stepsTexDom = linearSolveStepsTex(A, B, 'v(x)');
    domSolveBlock = `
      <div class="step">
        On rÃ©sout \\(v(x)=0\\) pour trouver la valeur interdite :
     
          ${stepsTexDom}
      
        La solution ainsi obtenue est exclue de \\(\\mathcal{D}_f\\).
      </div>
    `;
  }


  // Ã©tude du numÃ©rateur pour le signe
  let numBlock = '';
  let afterNumText = '';

  if(numType === 'const'){
    const kTex = String(C).replace(/-/g, UMIN);
    afterNumText ='';
  }else if(numType === 'lin'){
    const stepsTex = linearSolveStepsTex(B, C);
 numBlock = stepsTex;

    afterNumText =
      `On met ensuite le signe du coefficient de \\(x\\) Â« Ã  droite Â» du zÃ©ro.`;
  }else if(numType === 'quad'){
    const stepsTex = quadSolveStepsTex(A, B, C);
    const Delta    = B*B - 4*A*C;
 numBlock = stepsTex;

    if(Delta < 0){
      afterNumText =
        `Comme \\(\\Delta < 0\\), le numÃ©rateur ne s'annule pas `+
        `et garde le signe de \\(a\\).`;
    }else if(Delta === 0){
      afterNumText =
        `Comme \\(\\Delta = 0\\), le numÃ©rateur ne change de signe `+
        `qu'en sa racine double et garde le signe de \\(a\\) `+
        `de part et d'autre.`;
    }else{
      afterNumText =
        `Comme \\(\\Delta > 0\\), on place ensuite le signe de \\(a\\) `+
        `Â« Ã  l'extÃ©rieur Â» des racines et l'opposÃ© entre les deux.`;
    }
  }

  // helpers pour dÃ©cider des parenthÃ¨ses
  const normalizeMinus = t => t.replace(/\u2212/g,'-');
  const hasPlusMinus   = t => /[+\-]/.test(normalizeMinus(t));

  const isPureNumber = t => {
    const s = normalizeMinus(t.trim());
    return /^-?\d+$/.test(s);
  };

  const wrapIfNeeded = t => hasPlusMinus(t) ? `(${t})` : t;

  // facteurs dans u'(x)v(x) - v'(x)u(x)
  const dispV      = wrapIfNeeded(vTex);
  const dispU      = wrapIfNeeded(uTex);

  const dispUprime = isPureNumber(uPrimeTex)
    ? uPrimeTex.trim()
    : wrapIfNeeded(uPrimeTex);

  const dispVprime = isPureNumber(vPrimeTex)
    ? vPrimeTex.trim()
    : wrapIfNeeded(vPrimeTex);

  const lineFormule =
    `f'(x)=\\dfrac{u'(x)v(x)-v'(x)u(x)}{(v(x))^{2}}`;

  let lineSub =
    `f'(x)=\\dfrac{${dispUprime}${dispV}-${dispVprime}${dispU}}{(${vTex})^{2}}`;
  lineSub = cleanSigns(lineSub);

  // ===== Ligne "numÃ©rateur dÃ©veloppÃ©" pour TOUS les quotients =====
  let lineNumExpanded = '';

  // 1) Quotient affine / affine
  if(st.family === 'quot_aff' && typeof st.qA === 'number'){
    const a = st.qA, b = st.qB, c = st.qC, d = st.qD;
    // u(x)=ax+b, v(x)=cx+d, u'(x)=a, v'(x)=c
    // u'v - v'u = a(cx+d) - c(ax+b)
    const term1x = a*c;      // a*c x
    const term10 = a*d;      // a*d
    const term2x = -c*a;     // -c*a x
    const term20 = -c*b;     // -c*b

    const pieces = [];
    if(term1x !== 0) pieces.push(`${term1x}x`);
    if(term10 !== 0) pieces.push(`${term10}`);
    if(term2x !== 0) pieces.push(`${term2x}x`);
    if(term20 !== 0) pieces.push(`${term20}`);

    let numExpanded = pieces.join(' + ');      // ex : " -6x + -6 + 6x + -2"
    numExpanded = cleanSigns(numExpanded);     // -> "âˆ’6xâˆ’6+6xâˆ’2"

    lineNumExpanded = `f'(x)=\\dfrac{${numExpanded}}{(${vTex})^{2}}`;
  }

  // 2) Quotients avec dÃ©nominateur du second degrÃ©
  if(st.family === 'quot_aff_quad' && st.quotKind){
    if(st.quotKind === 'mx_over_diffSquares' && typeof st.mCoef === 'number'){
      const m = st.mCoef;
      const a = st.aParam;
      // m(xÂ²âˆ’aÂ²) âˆ’ 2x(mx) = m xÂ² âˆ’ m aÂ² âˆ’ 2m xÂ²
      const pieces = [
        `${m}x^2`,
        `${-m*a*a}`,
        `${-2*m}x^2`
      ];
      let numExpanded = pieces.join(' + ');
      numExpanded = cleanSigns(numExpanded);
      lineNumExpanded = `f'(x)=\\dfrac{${numExpanded}}{(${vTex})^{2}}`;
    }else if(st.quotKind === 'aff_over_quad_deltaPos' && typeof st.pCoef === 'number'){
      const p = st.pCoef, q = st.qCoef, s = st.sParam;
      // p(xÂ²+s) âˆ’ 2x(px+q) = p xÂ² + ps âˆ’ 2p xÂ² âˆ’ 2q x
      const pieces = [
        `${p}x^2`,
        `${p*s}`,
        `${-2*p}x^2`,
        `${-2*q}x`
      ];
      let numExpanded = pieces.join(' + ');
      numExpanded = cleanSigns(numExpanded);
      lineNumExpanded = `f'(x)=\\dfrac{${numExpanded}}{(${vTex})^{2}}`;
    }
    // cas const_over_quad : on garde la rÃ¨gle de l'inverse, pas de u'vâˆ’v'u
  }

  // forme polynomiale "propre" du numÃ©rateur : ax^2+bx+c, mx, ou constante
  const lineNumDev =
    `f'(x)=\\dfrac{${numTex}}{(${vTex})^{2}}`;

  // version finale dÃ©jÃ  prÃªte (avec \\bigl( â€¦ \\bigr)^2, etc.)
  const finalLine = st.dfTex.replace(/^f'(x)\s*=/,"f'(x)=");

  // DÃ©cide si on utilise la rÃ¨gle de l'inverse ou du quotient
  const useInverse = (uPrimeTex.trim() === '0');

  let methodBlock = '';

  if(useInverse){
    // ======= CAS f(x)=k / v(x) : rÃ¨gle de l'inverse =======
    const kTex = uTex;
    const baseFormula =
      `f'(x)= ${kTex}\\,\\dfrac{-v'(x)}{\\big(v(x)\\big)^{2}}`;
    const subFormula =
      `f'(x)= ${kTex}\\,\\dfrac{-${wrapIfNeeded(vPrimeTex)}}{\\left(${vTex}\\right)^{2}}`;

    methodBlock = `
      <div class="step">
        <strong>MÃ©thode â€” RÃ¨gle de l'inverse d'une fonction</strong><br>
        On a \\( \\) \\(f(x)=\\dfrac{${kTex}}{v(x)}\\) \\( \\) avec :<br>
        \\(v(x)=${vTex}\\) <br> \\(v'(x)=${vPrimeTex}\\)<br><br>
       
         \\( ${baseFormula}\\)<br>
       
       
         \\( ${subFormula}\\)<br>
       
    
       
         \\( ${finalLine}\\)<br>
        
      </div>
    `;
  }else{
    // ======= CAS gÃ©nÃ©ral : rÃ¨gle du quotient =======
    methodBlock = `
      <div class="step">
        <strong>MÃ©thode â€” RÃ¨gle du quotient</strong><br>
        On a  \\( \\) \\(f(x)=\\dfrac{u(x)}{v(x)}\\)  \\( \\) avec :
        <table class="uvtab">
          <tr>
            <td>\\(u(x)=${uTex}\\)</td>
            <td>\\(v(x)=${vTex}\\)</td>
          </tr>
          <tr>
            <td>\\(u'(x)=${uPrimeTex}\\)</td>
            <td>\\(v'(x)=${vPrimeTex}\\)</td>
          </tr>
        </table>
      
         \\( ${lineFormule}\\)<br>
       
       
          \\( ${lineSub}\\)<br>
      
         \\(${lineNumExpanded ? ` ${lineNumExpanded} ` : ''}\\)<br>
 
        
          \\( ${finalLine}\\)<br>
        
      </div>
    `;
  }

    extraDerivQuotStep = `
    <div class="step">
      ${defDomLine}
    </div>
    ${
      domSolveBlock ||
      `
      <div class="step">
        Remarque : Si l'Ã©noncÃ© demande clairement l'ensemble de dÃ©finition de \\(f\\),
        il faut alors rÃ©soudre : \\( ${vTex}=0 \\) et exclure les racines Ã©ventuelles.
      </div>
      `
    }
    <div class="step">
      On calcule la dÃ©rivÃ©e :
    </div>
    ${methodBlock}
    <div class="step">
      Sur l'ensemble de dÃ©finition de \\(f\\),
      \\(${denTex} > 0\\) donc \\(f'(x)\\) est du
      signe de ${
        numTex
          ? `\\(${numTex}${numSignIneq}\\)`
          : `son numÃ©rateur`
      }.
      ${
        numType === 'const'
          ? `<br>${afterNumText}`
          : `<br>On Ã©tudie le signe de ce numÃ©rateur en rÃ©solvant \\(f'(x)=0\\) :
             ${numBlock}
             ${afterNumText}`
      }
    </div>
  `;


}






    res.innerHTML = `
      <div class="step">
        La fonction \\(f\\) est un <b>${famLabel}</b> avec
        \\[ ${st.fTex} \\]
      </div>

      ${extraDerivStep}
      ${extraDerivCubicStep}
      ${extraDerivQuotStep}


      <div class="step">
        <div class="var-wrap" style="margin-top:.25rem">
          <table class="pdf-tbl">
            <tbody>
              ${rowX()}
              ${rowFpFull()}
              ${rowFFull()}
            </tbody>
          </table>
        </div>
      </div>

    `;

    ensureTickAfter(res).className = 'tick ok';
    typesetAll(res);
  },

  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Reset
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  reset(host){
    const dfInput = host.querySelector('.df-input');
    if(dfInput){ dfInput.value=''; setTick(dfInput,'nu'); }

    host.querySelectorAll('.sign-int, .dir-int, .fp-zero-kind, .ext-max-tab, .ext-min-tab').forEach(sel=>{
      sel.value='';
      setTick(sel,'nu');
    });

    ['.ext-max','.ext-min'].forEach(sel=>{
      const inp = host.querySelector(sel);
      if(inp){ inp.value=''; setTick(inp,'nu'); }
    });

    const res = $('#res',host);
    if(res){
      res.innerHTML='';
      ensureTickAfter(res).className='tick nu';
    }
  }
};

/* â€”â€”â€”â€”â€” Registre & UI â€”â€”â€”â€”â€” */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1Ã¨re â€“ Ã‰tude de fonctions â€¢ Lien entre le signe de la dÃ©rivÃ©e et les variations d'une fonction f`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def = getDefById($("#exo-select").value);
  const host = $("#host");

  // On essaie de rÃ©cupÃ©rer la famille du dernier Ã©tat
  let famOverride;
  try{
    const prev = JSON.parse(host.dataset.state || '{}');
    if (prev && prev.family) {
      famOverride = prev.family;
    }
  }catch(e){
    famOverride = undefined;
  }

  // Si pas d'Ã©tat prÃ©cÃ©dent (premier appel), famOverride = undefined â†’ famille alÃ©atoire
  const st = def.gen(famOverride);

  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}

function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
