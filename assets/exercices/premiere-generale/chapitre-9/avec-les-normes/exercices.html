<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1Ã¨re â€“ Produit scalaire - Avec les normes (identitÃ© remarquable)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  table.pdf-tbl td.zbar{
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }

  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

  .uvtab{
    border-collapse:collapse;
    margin:.6rem 0 .8rem 0;
    font-size:0.95rem;
  }
  .uvtab td{
    border:none;
    padding:4px 32px 4px 0;
    white-space:nowrap;
    vertical-align:top;
    line-height:1.6;
  }
  @media print{
    .uvtab td{ padding:4px 40px 4px 0; }
  }

  .angle-mode-box{
    margin-bottom:.5rem;
    padding:.35rem .6rem;
    border-radius:8px;
    background:#f7f7f9;
    display:inline-flex;
    align-items:center;
    gap:.4rem;
  }
  
  /* Chapeau HTML pour l'angle dans le PDF */
  .html-angle{
    display:inline-block;
    position:relative;
    padding-top:0.25em;
  }
  .html-angle-base{
    display:inline-block;
  }
  .html-angle-cap{
    position:absolute;
    left:50%;
    top:0;
    transform:translate(-50%,-65%);
    font-size:0.7em;
    line-height:1;
  }

  /* ParenthÃ¨ses larges et "stretchy" autour des deux inputs */
  .colvec{
    --parenW: 10px;   /* largeur parenthÃ¨se */
    --padX:   6px;    /* marge interne gauche/droite */
    --gap:    4px;    /* Ã©cart entre les deux inputs */
    --inW:    54px;   /* largeur dâ€™un input */
    --inPx:   6px;    /* padding horizontal input */
    --inPy:   4px;    /* padding vertical input */
    --inFs:   14px;   /* font-size input */

    position: relative;
    display: inline-grid;
    grid-template-rows: auto auto;
    row-gap: var(--gap);
    padding: 6px calc(var(--padX) + var(--parenW));
    vertical-align: middle;
  }
  .colvec input{
    width: var(--inW);
    text-align: center;
    padding: var(--inPy) var(--inPx);
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: var(--inFs);
  }
  .colvec::before,
  .colvec::after{
    content: "";
    position: absolute;
    top: 0; bottom: 0;
    width: var(--parenW);
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    opacity: .95;
  }
  .colvec::before{
    left: 0;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
  }
  .colvec::after{
    right: 0; transform: scaleX(-1);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
  }

  /* Version compacte */
  .colvec.sm {
    --parenW: 9px;
    --padX: 6px;
    --gap: 4px;
    --inW: 48px;
    --inPy: 3px;
    --inFs: 13px;
  }

.fig-geom{
  display:flex;
  justify-content:center;
  margin:.35rem 0 .4rem;
}

/* NOUVELLE VERSION : figures bien plus petites */
.fig-geom svg{
  width:300px;        /* largeur fixe raisonnable */
  max-width:300px;    /* limite Ã©cran / mobile */
  height:auto;
}

</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1Ã¨re â€“ Produit scalaire - Avec les normes (identitÃ© remarquable)</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les produits scalaires et les longueurs : rÃ©pondre avec un nombre rÃ©el (entier, dÃ©cimal avec virgule ou fraction du type <code>a/b</code>).</li>
        <li>Pour les angles :
          <ul>
            <li>si lâ€™unitÃ© choisie est <strong>Radian</strong> : rÃ©pondre en radians, par exemple <code>pi/3</code> ou <code>Ï€/3</code> ; pour lâ€™exercice&nbsp;3, donner une valeur approchÃ©e au centiÃ¨me prÃ¨s ;</li>
            <li>si lâ€™unitÃ© choisie est <strong>DegrÃ©</strong> : rÃ©pondre en degrÃ©s (par exemple <code>60</code>) ; pour lâ€™exercice&nbsp;3, donner une valeur approchÃ©e au <strong>degrÃ© prÃ¨s</strong>.</li>
          </ul>
        </li>
        <li>Le signe Â« âˆ’ Â» peut Ãªtre saisi avec le tiret du clavier ; les espaces sont ignorÃ©s.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* â€”â€”â€”â€”â€” Utils â€”â€”â€”â€”â€” */
const $ = (s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='âˆ’';

function cleanSigns(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/\u2212/g, '-');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className='tick '+state;
}

function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}

const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

// UnitÃ© d'angle globale pour toute la page (et pour le PDF)
let ANGLE_MODE = 'rad';

function getAngleMode(){
  return ANGLE_MODE;
}
function setAngleMode(mode){
  ANGLE_MODE = mode || 'rad';
}


/* parseurs & format */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() â†’ Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  // fraction simple a/b
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const parts = s.split('/');
    const p = Number(parts[0]);
    const q = Number(parts[1]);
    if(!q) return NaN;
    return p/q;
  }

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


function approxEqual(a,b,eps=1e-6){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}

function formatNumber(x){
  if(!isFinite(x)) return String(x);
  const r = Math.round(x);
  if(Math.abs(x-r)<1e-9) return String(r);
  return String(x).replace('.',',');
}

function parseAngle(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() â†’ Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // pi ou Ï€ â†’ Math.PI
  s = s.replace(/Ï€|pi/gi,'Math.PI');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


/* parenthÃ¨ses aprÃ¨s une multiplication si le facteur est nÃ©gatif */
function texFactorAfterTimes(tex, numericValue){
  if(numericValue < 0){
    return '\\left('+tex+'\\right)';
  }
  return tex;
}

/* gcd pour fractions (exo 3 et PS symbolique) */
function gcd(a,b){
  a = Math.abs(Math.round(a));
  b = Math.abs(Math.round(b));
  while(b){ const t=a%b; a=b; b=t; }
  return a || 1;
}

/* conversion rad â†” degrÃ©s */
function radToDeg(val){
  return Math.round(val*180/Math.PI);
}
function radToDegTex(val){
  const d = radToDeg(val);
  return d+'^{\\circ}';
}

function fracTex(p, q){
  if (!q) return String(p);
  const g = gcd(p, q);
  p = p / g; q = q / g;
  if (q === 1) return String(p);
  return '\\dfrac{'+p+'}{'+q+'}';
}


/* ====== Affichages â€œcoordonnÃ©esâ€ ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages â€œcoordonnÃ©esâ€ â€” rÃ¨gles de parenthÃ¨ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenthÃ¨ses autour d'un nÃ©gatif
const nPlain = n => String(n);

// nombre entre parenthÃ¨ses UNIQUEMENT s'il suit un "âˆ’" dans une diffÃ©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenthÃ¨ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifiÃ©e (pour l'Ã©tape -- â†’ +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des nÃ©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// âœ… Vecteur en COLONNE (dÃ©finitif â€” laisse celui-ci et SUPPRIME toute redÃ©finition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\\\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }



function buildPsSymbolic(k, ang){
  const cos = ang;

  // cas cos = 0
  if(cos.num === 0){
    const factorTex = texFactorAfterTimes('0', 0);
    return {
      texTimes: k+'\\times '+factorTex,
      texFinal: '0',
      val: 0
    };
  }

  const factorTex = texFactorAfterTimes(cos.cosTex, cos.cosVal);
  const timesTex = k+'\\times '+factorTex;

  let num = k * cos.num;
  let den = cos.den;
  const rad = cos.rad;

  const g = gcd(num,den);
  num /= g; den /= g;

  let coefTex;
  if(den === 1){
    coefTex = String(num);
  }else{
    coefTex = '\\dfrac{'+num+'}{'+den+'}';
  }

  let finalTex;
  if(rad === 0){
    finalTex = coefTex;
  }else{
    finalTex = coefTex+'\\sqrt{'+rad+'}';
  }

  const val = k * cos.cosVal;

  return {
    texTimes: timesTex,
    texFinal: finalTex,
    val
  };
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }


/* â€”â€”â€”â€”â€” Exercice 1 : Formule avec les normes dans un triangle â€”â€”â€”â€”â€” */
const ex1 = {
  id: 'ps_norm_tri',
  title: `Produit scalaire â€“ Formule avec les normes dans un triangle`,

gen(){
  // Longueurs entiÃ¨res, triangle non isocÃ¨le, nombres raisonnables
  let AB, AC, BC;
  while(true){
    AB = rint(4,10);   // AB de 4 Ã  10
    AC = rint(3,10);   // AC de 3 Ã  10

    // on Ã©vite d'emblÃ©e AB = AC (triangle isocÃ¨le possible)
    if (AB === AC) continue;

    const minBC = Math.abs(AB - AC) + 1;
    const maxBC = Math.min(AB + AC - 1, 11); // BC â‰¤ 11

    if (minBC > maxBC) continue;

    BC = rint(minBC, maxBC);

    // on Ã©vite aussi BC = AB ou BC = AC (pas d'autre isocÃ¨le)
    if (BC === AB || BC === AC) continue;

    break;
  }

  const questions = [
    { id:'ba_ac',  tex:'\\overrightarrow{BA}\\cdot\\overrightarrow{AC}' },
    { id:'ba_bc',  tex:'\\overrightarrow{BA}\\cdot\\overrightarrow{BC}' },
    { id:'ca_bc',  tex:'\\overrightarrow{CA}\\cdot\\overrightarrow{BC}' },
  ];

  // mÃ©lange alÃ©atoire de lâ€™ordre
  const qs = questions.slice();
  for(let i = qs.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [qs[i], qs[j]] = [qs[j], qs[i]];
  }

  const AB2 = AB * AB, AC2 = AC * AC, BC2 = BC * BC;

  const expected = {
    // BAÂ·AC : BA + AC = BC
    ba_ac:  0.5 * (BC2 - AB2 - AC2),
    // BAÂ·BC : AB + BC = AC  puis BA = -AB
    ba_bc: -0.5 * (AC2 - AB2 - BC2),
    // CAÂ·BC : CA + BC = BA
    ca_bc:  0.5 * (AB2 - AC2 - BC2)
  };

  return { AB, AC, BC, questions: qs, expected };
},




  render(host, st){
    const {AB,AC,BC,questions} = st;

    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const equ    = host.querySelector('#equ');
    const inputs = host.querySelector('#inputs');

    if(lead){
      lead.innerHTML =
        "On utilisera uniquement la relation de Chasles et la formule " +
        "avec les normes : <br>" +
        L("\\vec u\\cdot\\vec v = \\dfrac12(\\|\\vec u+\\vec v\\|^2-\\|\\vec u\\|^2-\\|\\vec v\\|^2).");
    }

    if(equ){
      equ.innerHTML = `
        <p><strong>Exercice 1 :</strong></p>
        <p>
          On considÃ¨re un triangle \\(ABC\\) tel que
          \\(AB=${AB}\\), \\(BC=${BC}\\) et \\(AC=${AC}\\).
          Calculer les produits scalaires suivants.
        </p>
        <div class="fig-geom">
          <svg viewBox="0 0 220 160" xmlns="http://www.w3.org/2000/svg" aria-label="Triangle ABC (schÃ©ma)">
            <polygon points="40,130 180,130 110,40" fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
            <!-- sommets -->
            <circle cx="40" cy="130" r="3.2" fill="#111"/>
            <circle cx="180" cy="130" r="3.2" fill="#111"/>
            <circle cx="110" cy="40"  r="3.2" fill="#111"/>
            <!-- labels points -->
            <text x="32"  y="146" font-size="12">A</text>
            <text x="184" y="146" font-size="12">B</text>
            <text x="112" y="32"  font-size="12">C</text>
            <!-- longueurs (pas Ã  lâ€™Ã©chelle) -->
            <text x="110" y="148" font-size="11" text-anchor="middle">AB = ${AB}</text>
            <text x="26"  y="84"  font-size="11" text-anchor="middle" transform="rotate(-65 26 84)">AC = ${AC}</text>
            <text x="192" y="84"  font-size="11" text-anchor="middle" transform="rotate(65 192 84)">BC = ${BC}</text>
          </svg>
        </div>
      `;
    }

    if(inputs){
      inputs.innerHTML = `
        <table style="border-collapse:collapse; margin-top:4px;">
          ${questions.map((q,i)=>`
            <tr>
              <td style="padding:4px 10px 4px 0;"><strong>${i+1})</strong></td>
              <td style="padding:4px 10px 4px 0;">\\(${q.tex}=\\)</td>
              <td style="padding:4px 6px;">
                <input type="text" class="ps-norm-tri" data-id="${q.id}"
                       inputmode="decimal" autocomplete="off" style="width:80px;">
                <span class="tick nu"></span>
              </td>
            </tr>
          `).join('')}
        </table>
      `;
    }

    typesetAll(host);
  },

  correct(host, st){
    const inputs = host.querySelectorAll('.ps-norm-tri');
    const fb     = host.querySelector('#fb');
    const exp    = st.expected || {};

    let anyFilled = false;
    inputs.forEach(inp=>{
      if (inp.value.trim() !== '') anyFilled = true;
    });
    if(!anyFilled){
      inputs.forEach(inp=>setTick(inp,'nu'));
      if(fb) fb.textContent = '';
      return {ok:0,total:0};
    }

    let ok=0,total=0;
    inputs.forEach(inp=>{
      const id  = inp.dataset.id;
      const val = inp.value.trim();
      if(!exp.hasOwnProperty(id)) return;

      if(val === ''){
        setTick(inp,'nu');
        return;
      }
      total++;
      const v = parseNumber(val);
      if(!isNaN(v) && approxEqual(v, exp[id], 1e-6)){
        setTick(inp,'ok'); ok++;
      }else{
        setTick(inp,'ko');
      }
    });

    if(fb){
      fb.innerHTML =
        "On utilise la relation de Chasles pour Ã©crire une Ã©galitÃ© du type " +
        L("\\vec u+\\vec v=\\vec w") +
        " puis la formule avec les normes pour calculer le produit scalaire.";
      if(window.MathJax?.typesetPromise) MathJax.typesetPromise([fb]);
    }

    return {ok,total};
  },

  solution(host, st){
    const {AB,AC,BC,questions,expected} = st;
    const res = host.querySelector('#res');
    if(!res) return;

    const AB2 = AB*AB, AC2 = AC*AC, BC2 = BC*BC;

    function part(id){
      if(id === 'ba_ac'){
        const num = BC2 - AB2 - AC2;
        const val = expected.ba_ac;
        return `
        D'aprÃ¨s la relation de Chasles : \\(\\overrightarrow{BA}+\\overrightarrow{AC}
        = \\overrightarrow{BC}\\), on a donc :
        \\[
          \\overrightarrow{BA}\\cdot\\overrightarrow{AC}
          = \\dfrac12\\Bigl(\\|\\overrightarrow{BA}+\\overrightarrow{AC}\\|^2
                          -\\|\\overrightarrow{BA}\\|^2
                          -\\|\\overrightarrow{AC}\\|^2\\Bigr)
				=\\dfrac12\\Bigl(BC^2
                          -AB^2
                          -AC^2\\Bigr)					  
          = \\dfrac12\\bigl(${BC}^2 - ${AB}^2 - ${AC}^2\\bigr)
          = ${fracTex(num,2)}
          = ${formatNumber(val)}.
        \\]`;
      }
      if(id === 'ba_bc'){
        const num = AC2 - AB2 - BC2;
        const val = expected.ba_bc;
        return `
        D'aprÃ¨s la relation de Chasles : \\(\\overrightarrow{AB}+\\overrightarrow{BC}
        = \\overrightarrow{AC}\\), on a donc :
        \\[
          \\overrightarrow{BA}\\cdot\\overrightarrow{BC}
          = -\\overrightarrow{AB}\\cdot\\overrightarrow{BC}
          = -\\dfrac12\\Bigl(\\|\\overrightarrow{AB}+\\overrightarrow{BC}\\|^2
                           -\\|\\overrightarrow{AB}\\|^2
                           -\\|\\overrightarrow{BC}\\|^2\\Bigr)
				=-\\dfrac12\\Bigl(AC^2
                          -AB^2
                          -BC^2\\Bigr)	
          = -\\dfrac12\\bigl(${AC}^2 - ${AB}^2 - ${BC}^2\\bigr)
           = ${fracTex(-num,2)}
          = ${formatNumber(val)}.
        \\]`;
      }
      if(id === 'ca_bc'){
        const num = AB2 - AC2 - BC2;
        const val = expected.ca_bc;
        return `
        D'aprÃ¨s la relation de Chasles : \\(\\overrightarrow{CA}+\\overrightarrow{BC}
        = \\overrightarrow{BC}+\\overrightarrow{CA}=\\overrightarrow{BA}\\), on a donc :
        \\[
          \\overrightarrow{CA}\\cdot\\overrightarrow{BC}
          = \\dfrac12\\Bigl(\\|\\overrightarrow{CA}+\\overrightarrow{BC}\\|^2
                          -\\|\\overrightarrow{CA}\\|^2
                          -\\|\\overrightarrow{BC}\\|^2\\Bigr)
		=\\dfrac12\\Bigl(BA^2
                          -CA^2
                          -BC^2\\Bigr)			  
          = \\dfrac12\\bigl(${AB}^2 - ${AC}^2 - ${BC}^2\\bigr)
          = ${fracTex(num,2)}
          = ${formatNumber(val)}.
        \\]`;
      }
      return '';
    }

    let html = `
      <div class="fig-geom">
        <svg viewBox="0 0 220 160" xmlns="http://www.w3.org/2000/svg" aria-label="Triangle ABC (schÃ©ma)">
          <polygon points="40,130 180,130 110,40" fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
          <circle cx="40" cy="130" r="3.2" fill="#111"/>
          <circle cx="180" cy="130" r="3.2" fill="#111"/>
          <circle cx="110" cy="40"  r="3.2" fill="#111"/>
          <text x="32"  y="146" font-size="12">A</text>
          <text x="184" y="146" font-size="12">B</text>
          <text x="112" y="32"  font-size="12">C</text>
          <text x="110" y="148" font-size="11" text-anchor="middle">AB = ${AB}</text>
          <text x="26"  y="84"  font-size="11" text-anchor="middle" transform="rotate(-65 26 84)">AC = ${AC}</text>
          <text x="192" y="84"  font-size="11" text-anchor="middle" transform="rotate(65 192 84)">BC = ${BC}</text>
        </svg>
      </div>
      <ol style="padding-left:0; list-style:none;">
    `;
    questions.forEach((q,i)=>{
      html += `<li style="margin-bottom:.5rem;"><strong>${i+1})</strong> ${part(q.id)}</li>`;
    });
    html += '</ol>';

    res.innerHTML = html;
    typesetAll(res);
  },

  reset(host){
    const inputs = host.querySelectorAll('.ps-norm-tri');
    inputs.forEach(inp=>{
      inp.value=''; setTick(inp,'nu');
    });
    const fb  = host.querySelector('#fb');
    const sol = host.querySelector('#res');
    if(fb) fb.textContent='';
    if(sol) sol.innerHTML='';
  }
};

/* â€”â€”â€”â€”â€” Exercice 2 : Formule avec les normes dans un losange â€”â€”â€”â€”â€” */
const ex2 = {
  id: 'ps_norm_los',
  title: `Produit scalaire â€“ Formule avec les normes dans un losange`,

  gen(){
  // On gÃ©nÃ¨re un losange cohÃ©rent avec la rÃ©daction :
  // ABÂ² = AIÂ² + BIÂ² dans le triangle rectangle AIB,
  // puis AC = 2Â·AI et BD = 2Â·BI.

  // Liste de triples pythagoriciens (a, b, c) avec c l'hypotÃ©nuse.
  const triples = [
    {a:3,  b:4,  c:5},
    {a:4,  b:3,  c:5},
    {a:5,  b:12, c:13},
    {a:12, b:5,  c:13},
    {a:8,  b:15, c:17},
    {a:15, b:8,  c:17},
    {a:7,  b:24, c:25},
    {a:24, b:7,  c:25},
    {a:9,  b:40, c:41},
    {a:40, b:9,  c:41},
    {a:20, b:21, c:29},
    {a:21, b:20, c:29},
    {a:12, b:35, c:37},
    {a:35, b:12, c:37},
    {a:15, b:36, c:39},
    {a:36, b:15, c:39}
  ];

  let AI, BI, AB, AC, BD;

  // On choisit au hasard un triple et un facteur t,
  // en filtrant pour garder des longueurs raisonnables.
  while(true){
    const t  = rint(1, 3);                // facteur d'Ã©chelle
    const tr = choice(triples);           // triple pythagoricien

    AI = t * tr.a;
    BI = t * tr.b;
    AB = t * tr.c;

    AC = 2 * AI;
    BD = 2 * BI;

    // On limite les tailles pour rester "scolaires"
    if (AB <= 25 && AC <= 40 && BD <= 40) break;
  }

  const AB2 = AB * AB;
  const AC2 = AC * AC;
  const BD2 = BD * BD;

  const expected = {
    bd_len: BD,
    // ABÂ·AD
    ab_ad:  0.5 * (AC2 - AB2 - AB2),
    // BCÂ·BA
    bc_ba:  0.5 * (BD2 - AB2 - AB2),
    // CDÂ·AD = - CDÂ·DA
    cd_ad: -0.5 * (AC2 - AB2 - AB2),
    // colinÃ©aires sens opposÃ©s
    cd_ab: -AB2,
    // colinÃ©aires mÃªme sens
    bc_ad:  AB2
  };

  const questions = [
    { id:'ab_ad', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AD}' }, // reste en 1)
    { id:'bc_ba', tex:'\\overrightarrow{BC}\\cdot\\overrightarrow{BA}' },
    { id:'cd_ad', tex:'\\overrightarrow{CD}\\cdot\\overrightarrow{AD}' },
    { id:'cd_ab', tex:'\\overrightarrow{CD}\\cdot\\overrightarrow{AB}' },
    { id:'bc_ad', tex:'\\overrightarrow{BC}\\cdot\\overrightarrow{AD}' }
  ];

  // MÃ©lange alÃ©atoire des questions 2 Ã  5, en conservant ABÂ·AD en premiÃ¨re position.
  const first  = questions[0];
  const others = questions.slice(1);

  for (let i = others.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [others[i], others[j]] = [others[j], others[i]];
  }

  const qs = [first, ...others];

  return {
    AI,           // pour cohÃ©rence interne / debug si besoin
    BI,
    AB,
    AC,
    BD_guess: BD, // utilisÃ© dans l'Ã©noncÃ© "calculer BD"
    expected,
    questions: qs
  };
},




  render(host, st){
    const {AB,AC,questions} = st;

    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const equ    = host.querySelector('#equ');
    const inputs = host.querySelector('#inputs');

    if(lead){
      lead.innerHTML =
        "";
    }

    if(equ){
      equ.innerHTML = `
        <p><strong>Exercice 2 :</strong></p>
        <p>
          \\(ABCD\\) est un losange tel que \\(AB=${AB}\\) et \\(AC=${AC}\\).
          On note \\(I\\) le centre du losange (intersection des diagonales).
        </p>
        <div class="fig-geom">
          <svg viewBox="0 0 220 180" xmlns="http://www.w3.org/2000/svg" aria-label="Losange ABCD (schÃ©ma)">
            <!-- losange -->
            <polygon points="110,30 190,90 110,150 30,90" fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
            <!-- diagonales -->
            <line x1="110" y1="30"  x2="110" y2="150" stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
            <line x1="30"  y1="90"  x2="190" y2="90"  stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
            <!-- points -->
            <circle cx="110" cy="30"  r="3.2" fill="#111"/>
            <circle cx="190" cy="90"  r="3.2" fill="#111"/>
            <circle cx="110" cy="150" r="3.2" fill="#111"/>
            <circle cx="30"  cy="90"  r="3.2" fill="#111"/>
            <circle cx="110" cy="90"  r="3"   fill="#111"/>
            <!-- labels sommets -->
            <text x="112" y="22"  font-size="12">A</text>
            <text x="196" y="94"  font-size="12">B</text>
            <text x="112" y="164" font-size="12">C</text>
            <text x="20"  y="94"  font-size="12">D</text>
            <text x="116" y="96"  font-size="11">I</text>

          </svg>
        </div>
        <ol style="padding-left:1.1rem;">
          <li>Calculer la longueur de la diagonale \\([BD]\\).</li>
          <li>Ã€ lâ€™aide de la formule avec les normes, calculer les produits scalaires suivants.</li>
        </ol>
      `;
    }

    if(inputs){
      inputs.innerHTML = `
        <p class="pdf-hide"><strong>1)</strong> \\(BD =\\)
          <input type="text" class="len-bd" inputmode="decimal" autocomplete="off" style="width:80px;">
          <span class="tick nu"></span>
        </p>
        <p class="pdf-hide"><strong>2)</strong> Produits scalaires :</p>
        <table style="border-collapse:collapse; margin-top:4px;">
          ${questions.map((q,i)=>`
            <tr>
              <td style="padding:4px 10px 4px 0;"><strong>${i+1})</strong></td>
              <td style="padding:4px 10px 4px 0;">\\(${q.tex}=\\)</td>
              <td style="padding:4px 6px;">
                <input type="text" class="ps-norm-los" data-id="${q.id}"
                       inputmode="decimal" autocomplete="off" style="width:80px;">
                <span class="tick nu"></span>
              </td>
            </tr>
          `).join('')}
        </table>
      `;
    }

    typesetAll(host);
  },

  correct(host, st){
    const exp = st.expected;
    const fb  = host.querySelector('#fb');

    const bdInp = host.querySelector('.len-bd');
    const psInp = host.querySelectorAll('.ps-norm-los');

    let anyFilled = false;
    if(bdInp && bdInp.value.trim()!=='') anyFilled = true;
    psInp.forEach(inp=>{
      if (inp.value.trim()!=='') anyFilled = true;
    });

    if(!anyFilled){
      if(bdInp) setTick(bdInp,'nu');
      psInp.forEach(inp=>setTick(inp,'nu'));
      if(fb) fb.textContent='';
      return {ok:0,total:0};
    }

    let ok=0,total=0;

    // BD
    if(bdInp){
      const v = bdInp.value.trim();
      if(v===''){
        setTick(bdInp,'nu');
      }else{
        total++;
        const x = parseNumber(v);
        if(!isNaN(x) && approxEqual(x, exp.bd_len, 1e-6)){
          setTick(bdInp,'ok'); ok++;
        }else{
          setTick(bdInp,'ko');
        }
      }
    }

    // produits scalaires
    psInp.forEach(inp=>{
      const id  = inp.dataset.id;
      const val = inp.value.trim();
      if(!exp.hasOwnProperty(id)) return;

      if(val===''){
        setTick(inp,'nu');
        return;
      }
      total++;
      const x = parseNumber(val);
      if(!isNaN(x) && approxEqual(x, exp[id], 1e-6)){
        setTick(inp,'ok'); ok++;
      }else{
        setTick(inp,'ko');
      }
    });

    if(fb){
      fb.innerHTML =
        "On commence par calculer \\(BD\\) Ã  lâ€™aide du thÃ©orÃ¨me de Pythagore " +
        "dans le triangle rectangle \\(AIB\\).<br>" +
        "Pour les produits scalaires, on exprime dâ€™abord une relation de Chasles " +
        "ou une colinÃ©aritÃ©, puis on applique la formule avec les normes.";
      if(window.MathJax?.typesetPromise) MathJax.typesetPromise([fb]);
    }

    return {ok,total};
  },

  solution(host, st){
    const {AB,AC,expected,questions} = st;
    const res = host.querySelector('#res');
    if(!res) return;

    const AB2 = AB*AB;
    const AC2 = AC*AC;
    const BD  = expected.bd_len;
    const BD2 = BD*BD;
	const AI=AC/2;
	const BI2=AB*AB-AI*AI;


    let html = '<p><strong>RÃ©daction possible :</strong></p>';

    // Figure avec BD indiquÃ©
    html += `
      <div class="fig-geom">
        <svg viewBox="0 0 220 180" xmlns="http://www.w3.org/2000/svg" aria-label="Losange ABCD (schÃ©ma)">
          <polygon points="110,30 190,90 110,150 30,90" fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
          <line x1="110" y1="30"  x2="110" y2="150" stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
          <line x1="30"  y1="90"  x2="190" y2="90"  stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
          <circle cx="110" cy="30"  r="3.2" fill="#111"/>
          <circle cx="190" cy="90"  r="3.2" fill="#111"/>
          <circle cx="110" cy="150" r="3.2" fill="#111"/>
          <circle cx="30"  cy="90"  r="3.2" fill="#111"/>
          <circle cx="110" cy="90"  r="3"   fill="#111"/>
          <text x="112" y="22"  font-size="12">A</text>
          <text x="196" y="94"  font-size="12">B</text>
          <text x="112" y="164" font-size="12">C</text>
          <text x="20"  y="94"  font-size="12">D</text>
          <text x="116" y="96"  font-size="11">I</text>

        </svg>
      </div>
    `;

    // Question 1 : BD
    html += `
      <p><strong>1)</strong>
        Les diagonales dâ€™un losange sont perpendiculaires et se coupent en leur milieu.
        \\(I\\) est le milieu de \\([AC]\\) et de \\([BD]\\).<br>
		On a \\(AI = \\dfrac{AC}{2} = \\dfrac{${AC}}{2}=${AI}\\) et \\(AB=${AB}\\).<br>
        Dans le triangle \\(AIB\\) rectangle en \\(I\\), on a d'aprÃ¨s le thÃ©orÃ¨me de Pythagore :
        \\[
          AB^2 = AI^2 + BI^2
          \\; \\; donc \\; \\;
          BI^2 =AB^2-AI^2= ${AB}^2 - ${AI}^2
          = ${BI2}
        \\]
        On en dÃ©duit \\(BI = ${BD/2}\\) et donc \\(BD = 2BI = ${BD}.\\)
      </p>
    `;

    // Question 2 : produits scalaires
    function part(id){
      if(id === 'ab_ad'){
        return `
        \\(ABCD\\) est un parallÃ©logramme ainsi on a : \\(\\overrightarrow{AB}+\\overrightarrow{AD}
        = \\overrightarrow{AC}\\). On a donc :
        \\[
          \\overrightarrow{AB}\\cdot\\overrightarrow{AD}
          = \\dfrac12\\Bigl(\\|\\overrightarrow{AB}+\\overrightarrow{AD}\\|^2
                           -\\|\\overrightarrow{AB}\\|^2
                           -\\|\\overrightarrow{AD}\\|^2\\Bigr)
          = \\dfrac12\\bigl(AC^2 - AB^2 - AD^2\\bigr)						   
          = \\dfrac12\\bigl(${AC}^2 - ${AB}^2 - ${AB}^2\\bigr)
          = ${expected.ab_ad}
        \\]`;
      }
      if(id === 'bc_ba'){
        return `
        \\(ABCD\\) est un parallÃ©logramme ainsi on a :
        \\(\\overrightarrow{BC}+\\overrightarrow{BA}
        = \\overrightarrow{BD}\\). On a donc :
        \\[
          \\overrightarrow{BC}\\cdot\\overrightarrow{BA}
          = \\dfrac12\\Bigl(\\|\\overrightarrow{BC}+\\overrightarrow{BA}\\|^2
                           -\\|\\overrightarrow{BC}\\|^2
                           -\\|\\overrightarrow{BA}\\|^2\\Bigr)
          = \\dfrac12\\bigl(BD^2 - BC^2 - BA^2\\bigr)
          = \\dfrac12\\bigl(${BD}^2 - ${AB}^2 - ${AB}^2\\bigr)
          = ${expected.bc_ba}
        \\]`;
      }
      if(id === 'cd_ad'){
        return `
        Dâ€™aprÃ¨s la relation de Chasles : 
        \\(\\overrightarrow{CD}+\\overrightarrow{DA}
        = \\overrightarrow{CA}\\). On a donc :
        \\[
          \\overrightarrow{CD}\\cdot\\overrightarrow{AD}
		  = -\\overrightarrow{CD}\\cdot\\overrightarrow{DA}
          = -\\dfrac12\\Bigl(\\|\\overrightarrow{CD}+\\overrightarrow{DA}\\|^2
                           -\\|\\overrightarrow{CD}\\|^2
                           -\\|\\overrightarrow{DA}\\|^2\\Bigr)
          = -\\dfrac12\\bigl(CA^2 - CD^2 - DA^2\\bigr)   
          = -\\dfrac12\\bigl(${AC}^2 - ${AB}^2 - ${AB}^2\\bigr)
          = ${expected.cd_ad}.
        \\]`;
      }
      if(id === 'cd_ab'){
        return `
        Les vecteurs \\(\\overrightarrow{CD}\\) et \\(\\overrightarrow{AB}\\)
        sont colinÃ©aires de sens opposÃ©s. On a donc :
        \\[
          \\overrightarrow{CD}\\cdot\\overrightarrow{AB}
          = -CD\\times AB
          = -${AB}\\times${AB}
          = ${expected.cd_ab}.
        \\]`;
      }
      if(id === 'bc_ad'){
        return `
        Les vecteurs \\(\\overrightarrow{BC}\\) et \\(\\overrightarrow{AD}\\)
        sont colinÃ©aires de mÃªme sens. On a donc :
        \\[
          \\overrightarrow{BC}\\cdot\\overrightarrow{AD}
          = BC\\times AD
          = ${AB}\\times${AB}
          = ${expected.bc_ad}.
        \\]`;
      }
      return '';
    }

    html += '<p><strong>2)</strong> Produits scalaires :</p>';
    html += '<ol style="padding-left:0; list-style:none;">';
    questions.forEach((q,i)=>{
      html += `<li style="margin-bottom:.5rem;"><strong>${i+1})</strong> ${part(q.id)}</li>`;
    });
    html += `<strong>Remarque : </strong>Une fois qu'on a calculÃ© \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AD}\\), on aurait pu trouver \\(\\overrightarrow{BC}\\cdot\\overrightarrow{BA}\\) et \\(\\overrightarrow{CD}\\cdot\\overrightarrow{AD}\\) Ã  l'aide d'Ã©galitÃ©s de vecteurs.</ol>`;

    res.innerHTML = html;
    typesetAll(res);
  },

  reset(host){
    const bdInp = host.querySelector('.len-bd');
    if(bdInp){ bdInp.value=''; setTick(bdInp,'nu'); }
    const psInp = host.querySelectorAll('.ps-norm-los');
    psInp.forEach(inp=>{
      inp.value=''; setTick(inp,'nu');
    });
    const fb  = host.querySelector('#fb');
    const sol = host.querySelector('#res');
    if(fb) fb.textContent='';
    if(sol) sol.innerHTML='';
  }
};


/* â€”â€”â€”â€”â€” Registre & UI â€”â€”â€”â€”â€” */
const REGISTRY = [ex1,ex2];
window.REGISTRY = REGISTRY;

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1Ã¨re â€“ Produit scalaire - Avec les normes (identitÃ© remarquable)`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");

  let st = null;

  // En mode PDF : on essaie d'abord de rÃ©utiliser l'Ã©tat dÃ©jÃ  stockÃ©
  if (window.__PDF_BUILDING && host.dataset.state){
    try{
      st = JSON.parse(host.dataset.state);
    }catch(_){}
  }

  // Si on n'a toujours pas d'Ã©tat (cas host "cachÃ©" pour le PDF)
  if (!st){
    // Cas particulier : exercice 2 avec sÃ©lecteur de figure
    if (def.id === 'geom_proj_all' && typeof def._genForMode === 'function'){
      let mode = 'mix';

      // 1) en mode normal, on lit le select ou l'ancien state
      const figSel = host.querySelector('#fig-select');
      if (!window.__PDF_BUILDING && figSel && figSel.value){
        mode = figSel.value;
      } else {
        // 2) sinon on essaie de relire un ancien state local
        try{
          const prev = host.dataset.state ? JSON.parse(host.dataset.state) : null;
          if (prev && prev.mode) mode = prev.mode;
        }catch(_){}

        // 3) si on est en PDF et qu'on n'a rien trouvÃ©, on prend le dernier mode (localStorage)
        if (window.__PDF_BUILDING && (!mode || mode === 'mix')){
          mode = getLastGeomProjMode();
        }

      }

      st = def._genForMode(mode);
    } else {
      // Tous les autres exercices
      st = def.gen();
    }
  }

  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}




function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
