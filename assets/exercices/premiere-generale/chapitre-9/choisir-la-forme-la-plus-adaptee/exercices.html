<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äì Produit scalaire - Choisir la forme la plus adapt√©e</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  table.pdf-tbl td.zbar{
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }

  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

  .uvtab{
    border-collapse:collapse;
    margin:.6rem 0 .8rem 0;
    font-size:0.95rem;
  }
  .uvtab td{
    border:none;
    padding:4px 32px 4px 0;
    white-space:nowrap;
    vertical-align:top;
    line-height:1.6;
  }
  @media print{
    .uvtab td{ padding:4px 40px 4px 0; }
  }

  .angle-mode-box{
    margin-bottom:.5rem;
    padding:.35rem .6rem;
    border-radius:8px;
    background:#f7f7f9;
    display:inline-flex;
    align-items:center;
    gap:.4rem;
  }
  
  /* Chapeau HTML pour l'angle dans le PDF */
.html-angle{
  display:inline-block;
  position:relative;
  padding-top:0.25em;
}
.html-angle-base{
  display:inline-block;
}
.html-angle-cap{
  position:absolute;
  left:50%;
  top:0;
  transform:translate(-50%,-65%);
  font-size:0.7em;
  line-height:1;
}

/* Parenth√®ses larges et "stretchy" autour des deux inputs */
.colvec{
  --parenW: 10px;   /* largeur parenth√®se */
  --padX:   6px;    /* marge interne gauche/droite */
  --gap:    4px;    /* √©cart entre les deux inputs */
  --inW:    54px;   /* largeur d‚Äôun input */
  --inPx:   6px;    /* padding horizontal input */
  --inPy:   4px;    /* padding vertical input */
  --inFs:   14px;   /* font-size input */

  position: relative;
  display: inline-grid;
  grid-template-rows: auto auto;
  row-gap: var(--gap);
  padding: 6px calc(var(--padX) + var(--parenW));
  vertical-align: middle;
}
.colvec input{
  width: var(--inW);
  text-align: center;
  padding: var(--inPy) var(--inPx);
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: var(--inFs);
}
.colvec::before,
.colvec::after{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  width: var(--parenW);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: .95;
}
.colvec::before{
  left: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}
.colvec::after{
  right: 0; transform: scaleX(-1);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}

/* Version compacte */
.colvec.sm {
  --parenW: 9px;
  --padX: 6px;
  --gap: 4px;
  --inW: 48px;
  --inPy: 3px;
  --inFs: 13px;
}

.fig-geom{
  display:flex;
  justify-content:center;
  margin:.35rem 0 .4rem;
}

/* NOUVELLE VERSION : figures bien plus petites */
.fig-geom svg{
  width:300px;        /* largeur fixe raisonnable */
  max-width:300px;    /* limite √©cran / mobile */
  height:auto;
}
  
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re ‚Äì Produit scalaire - Choisir la forme la plus adapt√©e</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les produits scalaires et les longueurs : r√©pondre avec un nombre r√©el (entier, d√©cimal avec virgule ou fraction du type <code>a/b</code>).</li>
        <li>Pour les angles :
          <ul>
            <li>si l‚Äôunit√© choisie est <strong>Radian</strong> : r√©pondre en radians, par exemple <code>pi/3</code> ou <code>œÄ/3</code> ; pour l‚Äôexercice&nbsp;3, donner une valeur approch√©e au centi√®me pr√®s ;</li>
            <li>si l‚Äôunit√© choisie est <strong>Degr√©</strong> : r√©pondre en degr√©s (par exemple <code>60</code>) ; pour l‚Äôexercice&nbsp;3, donner une valeur approch√©e au <strong>degr√© pr√®s</strong>.</li>
          </ul>
        </li>
        <li>Le signe ¬´ ‚àí ¬ª peut √™tre saisi avec le tiret du clavier ; les espaces sont ignor√©s.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $ = (s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';

function cleanSigns(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/\u2212/g, '-');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className='tick '+state;
}

function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}

const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function shuffleInPlace(arr){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
}



function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

// Unit√© d'angle globale pour toute la page (et pour le PDF)
let ANGLE_MODE = 'rad';

function getAngleMode(){
  return ANGLE_MODE;
}
function setAngleMode(mode){
  ANGLE_MODE = mode || 'rad';
}


/* parseurs & format */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() ‚Üí Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  // fraction simple a/b
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const parts = s.split('/');
    const p = Number(parts[0]);
    const q = Number(parts[1]);
    if(!q) return NaN;
    return p/q;
  }

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


function approxEqual(a,b,eps=1e-6){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}

function formatNumber(x){
  if(!isFinite(x)) return String(x);
  const r = Math.round(x);
  if(Math.abs(x-r)<1e-9) return String(r);
  return String(x).replace('.',',');
}

function parseAngle(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() ‚Üí Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // pi ou œÄ ‚Üí Math.PI
  s = s.replace(/œÄ|pi/gi,'Math.PI');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


/* parenth√®ses apr√®s une multiplication si le facteur est n√©gatif */
function texFactorAfterTimes(tex, numericValue){
  if(numericValue < 0){
    return '\\left('+tex+'\\right)';
  }
  return tex;
}

/* gcd pour fractions (exo 3 et PS symbolique) */
function gcd(a,b){
  a = Math.abs(Math.round(a));
  b = Math.abs(Math.round(b));
  while(b){ const t=a%b; a=b; b=t; }
  return a || 1;
}

/* conversion rad ‚Üî degr√©s */
function radToDeg(val){
  return Math.round(val*180/Math.PI);
}
function radToDegTex(val){
  const d = radToDeg(val);
  return d+'^{\\circ}';
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// ‚úÖ Vecteur en COLONNE (d√©finitif ‚Äî laisse celui-ci et SUPPRIME toute red√©finition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\\\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Angles remarquables (et oppos√©s) ‚Äî‚Äî‚Äî‚Äî‚Äî
   cos(theta) = (num/den)*sqrt(rad)   (rad = 0,2,3) */
const ANGLES = [
  { tex:'0',                  label:'0',     val:0,                num:1,  den:1, rad:0, cosTex:'1' },
  { tex:'\\dfrac{\\pi}{6}',   label:'œÄ/6',   val:Math.PI/6,        num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\dfrac{\\pi}{4}',   label:'œÄ/4',   val:Math.PI/4,        num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{\\pi}{3}',   label:'œÄ/3',   val:Math.PI/3,        num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'\\dfrac{\\pi}{2}',   label:'œÄ/2',   val:Math.PI/2,        num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'\\dfrac{2\\pi}{3}',  label:'2œÄ/3',  val:2*Math.PI/3,      num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'\\dfrac{3\\pi}{4}',  label:'3œÄ/4',  val:3*Math.PI/4,      num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{5\\pi}{6}',  label:'5œÄ/6',  val:5*Math.PI/6,      num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\pi',               label:'œÄ',     val:Math.PI,          num:-1, den:1, rad:0, cosTex:'-1' },
  { tex:'-\\dfrac{\\pi}{6}',  label:'-œÄ/6',  val:-Math.PI/6,       num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\dfrac{\\pi}{4}',  label:'-œÄ/4',  val:-Math.PI/4,       num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{\\pi}{3}',  label:'-œÄ/3',  val:-Math.PI/3,       num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'-\\dfrac{\\pi}{2}',  label:'-œÄ/2',  val:-Math.PI/2,       num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'-\\dfrac{2\\pi}{3}', label:'-2œÄ/3', val:-2*Math.PI/3,     num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'-\\dfrac{3\\pi}{4}', label:'-3œÄ/4', val:-3*Math.PI/4,     num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{5\\pi}{6}', label:'-5œÄ/6', val:-5*Math.PI/6,     num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\pi',              label:'-œÄ',    val:-Math.PI,         num:-1, den:1, rad:0, cosTex:'-1' }
];

// on ajoute la valeur num√©rique du cosinus
ANGLES.forEach(a=>{
  const base = (a.rad===0 ? 1 : Math.sqrt(a.rad));
  a.cosVal = (a.num/a.den)*base;
});

/* construit le PS sous forme symbolique : k * cos(theta)
   renvoie : texTimes (k √ó cos(...) avec parenth√®ses si cos<0),
             texFinal (forme simplifi√©e : fraction √©ventuellement √ó racine),
             val (valeur num√©rique) */
function buildPsSymbolic(k, ang){
  const cos = ang;

  // cas cos = 0
  if(cos.num === 0){
    const factorTex = texFactorAfterTimes('0', 0);
    return {
      texTimes: k+'\\times '+factorTex,
      texFinal: '0',
      val: 0
    };
  }

  const factorTex = texFactorAfterTimes(cos.cosTex, cos.cosVal);
  const timesTex = k+'\\times '+factorTex;

  let num = k * cos.num;
  let den = cos.den;
  const rad = cos.rad;

  const g = gcd(num,den);
  num /= g; den /= g;

  let coefTex;
  if(den === 1){
    coefTex = String(num);
  }else{
    coefTex = '\\dfrac{'+num+'}{'+den+'}';
  }

  let finalTex;
  if(rad === 0){
    finalTex = coefTex;
  }else{
    finalTex = coefTex+'\\sqrt{'+rad+'}';
  }

  const val = k * cos.cosVal;

  return {
    texTimes: timesTex,
    texFinal: finalTex,
    val
  };
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 1 : Choisir la forme adapt√©e pour AB¬∑AC (8 cas) ‚Äî‚Äî‚Äî‚Äî‚Äî */
const ex1 = {
  id: 'ps_choix_forme',
  title: `Produit scalaire ‚Äì Choisir la forme adapt√©e pour \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}\\)`,

  gen(){
    const cases = [];

    // ===== Cas 1 : triangle avec les trois c√¥t√©s (formule avec les normes) =====
    (function(){
      let AB, AC, BC;
      while(true){
        AB = rint(3,9);
        AC = rint(3,9);
        const minBC = Math.abs(AB-AC)+1;
        const maxBC = Math.min(AB+AC-1, 12);
        if(minBC > maxBC) continue;
        BC = rint(minBC, maxBC);
        break;
      }
      const AB2 = AB*AB, AC2 = AC*AC, BC2 = BC*BC;
      const val = 0.5*(AB2 + AC2 - BC2);
      cases.push({ kind:'tri_sides', AB,AC,BC, val });
    })();

    // ===== Cas 2 : triangle avec angle en A (forme ||u||¬∑||v||¬∑cos) =====
    (function(){
      const AB = rint(3,9);
      const AC = rint(3,9);

      const angs = [
        { cosTex:'\\dfrac{\\sqrt{3}}{2}', num:1, den:2, rad:3,  cosVal: Math.sqrt(3)/2, tex:'\\dfrac{\\pi}{6}' },
        { cosTex:'\\dfrac{\\sqrt{2}}{2}', num:1, den:2, rad:2,  cosVal: Math.sqrt(2)/2, tex:'\\dfrac{\\pi}{4}' },
        { cosTex:'\\dfrac{1}{2}',         num:1, den:2, rad:1,  cosVal: 1/2,             tex:'\\dfrac{\\pi}{3}' },
        { cosTex:'-\\dfrac{1}{2}',        num:-1,den:2, rad:1,  cosVal: -1/2,            tex:'\\dfrac{2\\pi}{3}' },
        { cosTex:'-\\dfrac{\\sqrt{2}}{2}',num:-1,den:2, rad:2,  cosVal: -Math.sqrt(2)/2, tex:'\\dfrac{3\\pi}{4}' },
        { cosTex:'-\\dfrac{\\sqrt{3}}{2}',num:-1,den:2, rad:3,  cosVal: -Math.sqrt(3)/2, tex:'\\dfrac{5\\pi}{6}' }
      ];
      const A = choice(angs);
      const val = AB * AC * A.cosVal;
      cases.push({ kind:'tri_angle', AB,AC, angleTex:A.tex, cos:A, val });
    })();

    // ===== Cas 3 : B appartient √† [AC] (colin√©arit√©) =====
    (function(){
      const AC = rint(7,16);
      const AB = rint(2, AC-2);
      const BC = AC - AB;
      const val = AB * AC;      // m√™mes sens
      cases.push({ kind:'segment', AB,BC,AC, val });
    })();

    // ===== Cas 4 : coordonn√©es de A,B,C =====
    // ===== Cas 4 : coordonn√©es de A,B,C =====
    (function(){
      let Ax,Ay,Bx,By,Cx,Cy;
      while(true){
        Ax = rint(-3,3); Ay = rint(-3,3);
        Bx = rint(-3,3); By = rint(-3,3);
        Cx = rint(-3,3); Cy = rint(-3,3);

        const vABx = Bx-Ax, vABy = By-Ay;
        const vACx = Cx-Ax, vACy = Cy-Ay;

        // 3 points distincts : en plus de AB‚â†0 et AC‚â†0, on impose B‚â†C
        const BdiffC = (Bx !== Cx || By !== Cy);

        if (BdiffC && (vABx!==0 || vABy!==0) && (vACx!==0 || vACy!==0)) break;
      }

      const vABx = Bx-Ax, vABy = By-Ay;
      const vACx = Cx-Ax, vACy = Cy-Ay;
      const val  = vABx*vACx + vABy*vACy;

      cases.push({ kind:'coords', Ax,Ay,Bx,By,Cx,Cy, vABx,vABy,vACx,vACy, val });
    })();


    // ===== Cas 5 : losange, diagonale AC donn√©e (AB=BC) =====
    (function(){
      const AC = rint(8,18);
      const AB = rint(4,12);       // juste pour dire "losange"
      const val = 0.5 * AC * AC;   // 1/2 AC¬≤
      cases.push({ kind:'losange', AB,AC, val });
    })();

    // ===== Cas 6 : rectangle avec AB connu (AB¬∑AC = AB¬≤) =====
    (function(){
      const AB = rint(3,12);
      const val = AB * AB;
      cases.push({ kind:'rectangle', AB, val });
    })();

    // ===== Cas 7 : hexagone r√©gulier (AC = ‚àö3¬∑a, angle 30¬∞) =====
    (function(){
      const side = rint(3,8);
      const val  = 1.5 * side * side; // 3/2 a¬≤
      cases.push({ kind:'hexagone', side, val });
    })();

    // ===== Cas 8 : triangle isoc√®le en A, AB=AC, angle ABC donn√© =====
       (function(){
      const AB = rint(3,9);
      const opts = [
        {Bdeg:30, Adeg:120, cosA:-0.5, texB:'30^{\\circ}', texA:'120^{\\circ}'},
        {Bdeg:45, Adeg:90,  cosA: 0,   texB:'45^{\\circ}', texA:'90^{\\circ}' },
        {Bdeg:60, Adeg:60,  cosA: 0.5, texB:'60^{\\circ}', texA:'60^{\\circ}' }
      ];
      const ch = choice(opts);
      const val = AB*AB*ch.cosA;
      cases.push({
        kind:'iso_A',
        AB,
        angleBdeg: ch.Bdeg,
        angleAdeg: ch.Adeg,
        texB: ch.texB,
        texA: ch.texA,
        cosA: ch.cosA,
        val
      });
    })();

    // üîÄ M√©lange al√©atoire de l'ordre des questions
    shuffleInPlace(cases);

    return { cases };
  },


  render(host, st){
    const {cases} = st;
    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const equ    = host.querySelector('#equ');
    const inputs = host.querySelector('#inputs');

    if(lead){
      lead.innerHTML =
        "";
    }
    if(equ){
      equ.innerHTML = `<p><strong>Exercice :</strong> Calculer, dans chacun des cas, \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}.\\)</p>`;
    }

    const fmtPt = (x,y)=>`(${x}\\,;\\,${y})`;

    if(inputs){
      inputs.innerHTML = cases.map((cs,idx)=>{
        const n = idx+1;
        const figBtn = `
          <button type="button" class="btn btn-fig" data-i="${idx}">
            üñºÔ∏è Afficher la figure
          </button>
        `;

        if(cs.kind==='tri_sides'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(ABC\\) est un triangle tel que
              \\(AB=${cs.AB}\\), \\(AC=${cs.AC}\\) et \\(BC=${cs.BC}.\\)
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 220 160">
                <polygon points="40,130 180,130 110,40"
                  fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
                <circle cx="40" cy="130" r="3" fill="#111"/>
                <circle cx="180" cy="130" r="3" fill="#111"/>
                <circle cx="110" cy="40"  r="3" fill="#111"/>
                <text x="32"  y="146" font-size="12">A</text>
                <text x="184" y="146" font-size="12">B</text>
                <text x="112" y="30"  font-size="12">C</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='tri_angle'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(ABC\\) est un triangle tel que
              \\(AB=${cs.AB}\\), \\(AC=${cs.AC}\\) et
              \\(\\widehat{BAC} = ${cs.angleTex}.\\)
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 220 160">
                <polygon points="60,130 170,130 90,40"
                  fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
                <circle cx="60" cy="130" r="3" fill="#111"/>
                <circle cx="170" cy="130" r="3" fill="#111"/>
                <circle cx="90" cy="40"  r="3" fill="#111"/>
                <text x="52"  y="146" font-size="12">B</text>
                <text x="174" y="146" font-size="12">C</text>
                <text x="82"  y="30"  font-size="12">A</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='segment'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              Les trois points \\(A\\), \\(B\\) et \\(C\\) sont tels que
              \\(AB=${cs.AB}\\), \\(BC=${cs.BC}\\) et \\(B\\) appartient au segment \\([AC].\\)
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 260 70">
                <line x1="20" y1="35" x2="240" y2="35" stroke="#111" stroke-width="1.6"/>
                <circle cx="40"  cy="35" r="3" fill="#111"/>
                <circle cx="150" cy="35" r="3" fill="#111"/>
                <circle cx="230" cy="35" r="3" fill="#111"/>
                <text x="36"  y="22" font-size="11">A</text>
                <text x="146" y="22" font-size="11">B</text>
                <text x="226" y="22" font-size="11">C</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='coords'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(A${fmtPt(cs.Ax,cs.Ay)}\\),
              \\(B${fmtPt(cs.Bx,cs.By)}\\) et
              \\(C${fmtPt(cs.Cx,cs.Cy)}\\).
            </p>
           
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='losange'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(ABCD\\) est un losange dans lequel la diagonale \\([AC]\\) mesure \\(${cs.AC}\\) cm.
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 220 180">
                <!-- losange -->
                <polygon points="110,30 190,90 110,150 30,90"
                  fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
                <!-- diagonales -->
                <line x1="110" y1="30"  x2="110" y2="150" stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
                <line x1="30"  y1="90"  x2="190" y2="90"  stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
                <!-- sommets -->
                <circle cx="110" cy="30"  r="3" fill="#111"/>
                <circle cx="190" cy="90"  r="3" fill="#111"/>
                <circle cx="110" cy="150" r="3" fill="#111"/>
                <circle cx="30"  cy="90"  r="3" fill="#111"/>
                <!-- centre -->
                <circle cx="110" cy="90"  r="3" fill="#111"/>
                <text x="112" y="22"  font-size="12">A</text>
                <text x="196" y="94"  font-size="12">B</text>
                <text x="112" y="164" font-size="12">C</text>
                <text x="20"  y="94"  font-size="12">D</text>
                <text x="116" y="96"  font-size="11">O</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='rectangle'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(ABCD\\) est un rectangle dans lequel \\(AB=${cs.AB}.\\)
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 220 140">
                <rect x="40" y="40" width="140" height="80"
                  fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
                <circle cx="40"  cy="40"  r="3" fill="#111"/>
                <circle cx="180" cy="40"  r="3" fill="#111"/>
                <circle cx="180" cy="120" r="3" fill="#111"/>
                <circle cx="40"  cy="120" r="3" fill="#111"/>
                <text x="32"  y="32"  font-size="12">A</text>
                <text x="184" y="32"  font-size="12">B</text>
                <text x="184" y="132" font-size="12">C</text>
                <text x="32"  y="132" font-size="12">D</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='hexagone'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(ABCDEF\\) est un hexagone r√©gulier de c√¥t√© ${cs.side}.
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 220 190">
                <!-- hexagone r√©gulier approximatif -->
                <polygon points="110,30 160,55 160,115 110,140 60,115 60,55"
                  fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
                <!-- centre -->
                <circle cx="110" cy="85" r="3" fill="#111"/>
                <text x="116" y="89" font-size="11">O</text>
                <!-- diagonales principales AD, BE, CF -->
                <line x1="110" y1="30"  x2="110" y2="140" stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
                <line x1="160" y1="55"  x2="60"  y2="115" stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
                <line x1="160" y1="115" x2="60"  y2="55"  stroke="#777" stroke-width="1.2" stroke-dasharray="4 3"/>
                <!-- sommets -->
                <circle cx="110" cy="30"  r="3" fill="#111"/>
                <circle cx="160" cy="55"  r="3" fill="#111"/>
                <circle cx="160" cy="115" r="3" fill="#111"/>
                <circle cx="110" cy="140" r="3" fill="#111"/>
                <circle cx="60"  cy="115" r="3" fill="#111"/>
                <circle cx="60"  cy="55"  r="3" fill="#111"/>
                <text x="106" y="22"  font-size="11">A</text>
                <text x="166" y="57"  font-size="11">B</text>
                <text x="166" y="119" font-size="11">C</text>
                <text x="106" y="152" font-size="11">D</text>
                <text x="48"  y="119" font-size="11">E</text>
                <text x="48"  y="57"  font-size="11">F</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        if(cs.kind==='iso_A'){
          return `
          <div style="margin-bottom:.8rem;">
            <p><strong>${n})</strong>
              \\(ABC\\) est un triangle isoc√®le en \\(A\\) tel que \\(AB=AC=${cs.AB}\\)
              et \\(\\widehat{ABC} = ${cs.texB}.\\)
            </p>
            ${figBtn}
            <div class="fig-geom qfig" data-i="${idx}" style="display:none;">
              <svg viewBox="0 0 220 160">
                <polygon points="60,130 160,130 110,40"
                  fill="#f9fafb" stroke="#111" stroke-width="1.6"/>
                <circle cx="60"  cy="130" r="3" fill="#111"/>
                <circle cx="160" cy="130" r="3" fill="#111"/>
                <circle cx="110" cy="40"  r="3" fill="#111"/>
                <text x="54"  y="146" font-size="12">B</text>
                <text x="166" y="146" font-size="12">C</text>
                <text x="104" y="30"  font-size="12">A</text>
              </svg>
            </div>
            <p class="pdf-hide">
              \\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}=\\)
              <input type="text" class="ps-choix" data-i="${idx}" style="width:90px;">
              <span class="tick nu"></span>
            </p>
          </div>`;
        }

        return '';
      }).join('');
    }

    // gestion des boutons d‚Äôaffichage de figure
    const btns = host.querySelectorAll('.btn-fig');
    btns.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const i   = btn.dataset.i;
        const fig = host.querySelector(`.qfig[data-i="${i}"]`);
        if(!fig) return;
        const hidden = (fig.style.display === 'none' || !fig.style.display);
        fig.style.display = hidden ? 'flex' : 'none';
        btn.textContent   = hidden ? 'üñºÔ∏è Masquer la figure' : 'üñºÔ∏è Afficher la figure';
      });
    });

    typesetAll(host);
  },

  correct(host, st){
    const {cases} = st;
    const inputs = host.querySelectorAll('.ps-choix');
    const fb     = host.querySelector('#fb');

    let anyFilled = false;
    inputs.forEach(inp=>{ if(inp.value.trim()!=='') anyFilled = true; });
    if(!anyFilled){
      inputs.forEach(inp=>setTick(inp,'nu'));
      if(fb) fb.textContent='';
      return {ok:0,total:0};
    }

    let ok=0,total=0;
    inputs.forEach(inp=>{
      const i = Number(inp.dataset.i||0);
      const expVal = cases[i].val;
      const raw = inp.value.trim();
      if(raw===''){ setTick(inp,'nu'); return; }
      total++;
      const v = parseNumber(raw);
      if(!isNaN(v) && approxEqual(v, expVal, 1e-6)){
        setTick(inp,'ok'); ok++;
      }else{
        setTick(inp,'ko');
      }
    });

    if(fb){
      fb.innerHTML =
        "On devait, pour chaque situation, reconna√Ætre la configuration g√©om√©trique " +
        "et choisir la forme adapt√©e du produit scalaire : normes et c√¥t√©s d‚Äôun triangle, " +
        "angle connu, colin√©arit√©, coordonn√©es, rectangle, losange, hexagone r√©gulier ou triangle isoc√®le.";
      typesetAll(fb);
    }

    return {ok,total};
  },

  solution(host, st){
    const {cases} = st;
	    const {Ax,Ay,Bx,By,Cx,Cy} = st;
    const ABx = Bx - Ax;
    const ABy = By - Ay;
    const ACx = Cx - Ax;
    const ACy = Cy - Ay;
    const res = host.querySelector('#res');
	    function texDiff(p,q){
      if(q < 0){
        const absq = Math.abs(q);
        return `${p} + ${absq}`;
      }else{
        return `${p} - ${q}`;
      }
    }
    // a √ó b avec parenth√®ses autour des nombres n√©gatifs
    function texMul(a,b){
      const left  = (a < 0) ? `(${a})` : `${a}`;
      const right = (b < 0) ? `(${b})` : `${b}`;
      return `${left}\\times${right}`;
    }
    // a + b sans "+(-‚Ä¶)"
    function texSum(a,b){
      if(b === 0) return `${a}`;
      if(b > 0)   return `${a} + ${b}`;
      const absb = Math.abs(b);
      return `${a} - ${absb}`;
    }
	
    if(!res) return;

    let html = '<p><strong>R√©dactions possibles :</strong></p><ol style="padding-left:1.1rem;">';

    cases.forEach((cs,idx)=>{
      if(cs.kind==='tri_sides'){
        const {AB,AC,BC,val} = cs;
        html += `
        <li style="margin-bottom:.6rem;">
          On conna√Æt les trois c√¥t√©s du triangle \\(ABC\\).<br>
          Forme adapt√©e : <strong>formule avec les normes</strong> dans un triangle.<br>
              D‚Äôapr√®s la relation de Chasles : 
        \\(\\overrightarrow{BA}+\\overrightarrow{AC}
        = \\overrightarrow{BC}\\). On a donc :
        \\[
          \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
		  = -\\overrightarrow{BA}\\cdot\\overrightarrow{AC}
          = -\\dfrac12\\Bigl(\\|\\overrightarrow{BA}+\\overrightarrow{AC}\\|^2
                           -\\|\\overrightarrow{BA}\\|^2
                           -\\|\\overrightarrow{AC}\\|^2\\Bigr)
          = -\\dfrac12\\bigl(BC^2 - BA^2 - AC^2\\bigr)   
          = -\\dfrac12\\bigl(${BC}^2 - ${AB}^2 - ${AC}^2\\bigr)
          = ${formatNumber(val)}.
        \\]`;
		
		
      }

      else if(cs.kind==='tri_angle'){
        const {AB,AC,angleTex,cos,val} = cs;
        const ps = buildPsSymbolic(AB*AC, cos);
        html += `
        <li style="margin-bottom:.6rem;">
          On conna√Æt \\(AB\\), \\(AC\\) et l'angle \\(\\widehat{BAC}\\).<br>
          Forme adapt√©e : <strong>\\(\\vec u\\cdot\\vec v = \\|\\vec u\\|\\,\\|\\vec v\\|\\cos(\\theta)\\)</strong>.
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = AB\\times AC\\times\\cos(\\widehat{BAC})
            = ${AB}\\times${AC}\\times\\cos\\left(${angleTex}\\right)
            = ${ps.texTimes}
            = ${ps.texFinal}
          \\]
        </li>`;
      }

      else if(cs.kind==='segment'){
        const {AB,AC,val} = cs;
		
        html += `
        <li style="margin-bottom:.6rem;">
          \\(B\\) appartient √† \\([AC]\\), donc les vecteurs
          \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{AC}\\) sont colin√©aires de m√™me sens.<br>
		  De plus \\(AC=AB+BC=${AC}\\).<br>
          Forme adapt√©e : <strong>colin√©arit√©</strong> :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = AB\\times AC
            = ${AB}\\times${AC}
            = ${formatNumber(val)}.
          \\]
        </li>`;
      }

       else if(cs.kind==='coords'){
        const {Ax,Ay,Bx,By,Cx,Cy,vABx,vABy,vACx,vACy,val} = cs;

        const stepsAB = [
          `\\(\\overrightarrow{AB}\\begin{pmatrix} x_B - x_A \\\\ y_B - y_A \\end{pmatrix}\\)`,
          `\\(\\overrightarrow{AB}\\begin{pmatrix} ${texDiff(Bx, Ax)} \\\\ ${texDiff(By, Ay)} \\end{pmatrix}\\)`,
          `\\(\\overrightarrow{AB}\\begin{pmatrix} ${vABx} \\\\ ${vABy} \\end{pmatrix}\\)`
        ];

        const stepsAC = [
          `\\(\\overrightarrow{AC}\\begin{pmatrix} x_C - x_A \\\\ y_C - y_A \\end{pmatrix}\\)`,
          `\\(\\overrightarrow{AC}\\begin{pmatrix} ${texDiff(Cx, Ax)} \\\\ ${texDiff(Cy, Ay)} \\end{pmatrix}\\)`,
          `\\(\\overrightarrow{AC}\\begin{pmatrix} ${vACx} \\\\ ${vACy} \\end{pmatrix}\\)`
        ];

        const p1 = vABx * vACx;
        const p2 = vABy * vACy;

        const psSteps = [

          `\\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = ${texMul(vABx, vACx)} + ${texMul(vABy, vACy)}\\)`,
          `\\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = ${texSum(p1, p2)}\\) `,
			          `\\(\\overrightarrow{AB}\\cdot\\overrightarrow{AC}
             = ${formatNumber(val)}\\)`
        ];

        html += `
        <li style="margin-bottom:.6rem;">
          On conna√Æt les coordonn√©es de \\(A\\), \\(B\\) et \\(C\\).<br>
          Forme adapt√©e : <strong>formule avec les coordonn√©es</strong> :
          <table style="border-collapse:collapse; border:none; width:100%; max-width:620px; margin:0 auto;">
            <tr>
              <td style="vertical-align:top; padding-right:16px;">
                ${stepsAB.map(s=>`<p>${s}</p>`).join('')}
              </td>
              <td style="vertical-align:top; padding-left:16px;">
                ${stepsAC.map(s=>`<p>${s}</p>`).join('')}
              </td>
            </tr>
          </table>
          ${psSteps.map(s=>`<p>${s}</p>`).join('')}
        </li>`;
      }


           else if(cs.kind==='losange'){
        const {AC,val} = cs;
		const AO=AC/2;
        html += `
        <li style="margin-bottom:.6rem;">
          \\(ABCD\\) est un losange dans lequel la diagonale \\([AC]\\) mesure \\(${AC}\\) cm et \\(AO=\\dfrac{AC}{2}=${AO}\\).<br>
          Le centre \\(O\\) du losange est le projet√© orthogonal de \\(B\\) sur \\([AC]\\).
          Les vecteurs \\(\\overrightarrow{AO}\\) et \\(\\overrightarrow{AC}\\) sont colin√©aires de m√™me sens.<br>
          On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AO}\\cdot\\overrightarrow{AC}
            = AO\\times AC
            = ${AO}\\times ${AC}
            = ${formatNumber(val)}.
          \\]
        </li>`;
      }

      else if(cs.kind==='rectangle'){
        const {AB,val} = cs;
        html += `
        <li style="margin-bottom:.6rem;">
          \\(ABCD\\) est un rectangle dans lequel \\(AB=${AB}.\\)<br>
          \\(B\\) est le projet√© orthogonal de \\(C\\) sur \\([AB]\\). On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AB}\\cdot\\overrightarrow{AB}
            = AB^2
            = ${AB}^2
            = ${formatNumber(val)}.
          \\]
        </li>`;
      }

      else if(cs.kind==='hexagone'){
        const {side,val} = cs;
		const side2=side*side
		const side2s2=side*side/2
        html += `
        <li style="margin-bottom:.6rem;">
          \\(ABCDEF\\) est un hexagone r√©gulier de c√¥t√© ${side}.<br>
          Soit \\(O\\) le centre de l‚Äôhexagone r√©gulier \\(ABCDEF\\). On a :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AB}\\cdot(\\overrightarrow{AO}+\\overrightarrow{OC})
            = \\overrightarrow{AB}\\cdot\\overrightarrow{AO}
              + \\overrightarrow{AB}\\cdot\\overrightarrow{OC}.
          \\]
          Or
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AO}
            = AB\\times AO\\times\\cos\\left(\\dfrac{\\pi}{3}\\right)
            = ${side}\\times ${side}\\times\\dfrac12
            = ${side2s2}
          \\]
          et
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{OC}
            = AB\\times OC
            = ${side}\\times${side}
            = ${side2}
          \\]
          car \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{OC}\\) sont colin√©aires de m√™me sens.<br>
          Ainsi
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = ${side2s2} + ${side2}
            = ${formatNumber(val)}
          \\]
        </li>`;
      }


      else if(cs.kind==='iso_A'){
        const {AB,texB,texA,cosA,val} = cs;
		const AB2=AB*AB;
		        const cosTex = texFactorAfterTimes(formatNumber(cosA), cosA);

        html += `
        <li style="margin-bottom:.6rem;">
          Le triangle est isoc√®le en \\(A\\) : \\(AB=AC=${AB}\\) et
          \\(\\widehat{ABC} = ${texB}\\).<br>
          La somme des angles d'un triangle donne
          \\(\\widehat{BAC} = ${texA}\\).<br>
          Forme adapt√©e : <strong>formule avec un angle</strong> :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = AB \\times AC \\cos(\\widehat{BAC})
            = ${AB}^2\\times\\cos\\left(${texA}\\right)
            = ${AB2}\\times ${cosTex}
            = ${formatNumber(val)}.
          \\]
        </li>`;
      }
    });

    html += '</ol>';
    res.innerHTML = html;
    typesetAll(res);
  },

  reset(host){
    const inputs = host.querySelectorAll('.ps-choix');
    inputs.forEach(inp=>{ inp.value=''; setTick(inp,'nu'); });
    const fb  = host.querySelector('#fb');
    const sol = host.querySelector('#res');
    if(fb) fb.textContent='';
    if(sol) sol.innerHTML='';
  }
};



/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY = [ex1];
window.REGISTRY = REGISTRY;

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1√®re ‚Äì Produit scalaire - Choisir la forme la plus adapt√©e`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");

  let st = null;

  // En mode PDF : on essaie d'abord de r√©utiliser l'√©tat d√©j√† stock√©
  if (window.__PDF_BUILDING && host.dataset.state){
    try{
      st = JSON.parse(host.dataset.state);
    }catch(_){}
  }

  // Si on n'a toujours pas d'√©tat (cas host "cach√©" pour le PDF)
  if (!st){
    // Cas particulier : exercice 2 avec s√©lecteur de figure
    if (def.id === 'geom_proj_all' && typeof def._genForMode === 'function'){
      let mode = 'mix';

      // 1) en mode normal, on lit le select ou l'ancien state
      const figSel = host.querySelector('#fig-select');
      if (!window.__PDF_BUILDING && figSel && figSel.value){
        mode = figSel.value;
      } else {
        // 2) sinon on essaie de relire un ancien state local
        try{
          const prev = host.dataset.state ? JSON.parse(host.dataset.state) : null;
          if (prev && prev.mode) mode = prev.mode;
        }catch(_){}

        // 3) si on est en PDF et qu'on n'a rien trouv√©, on prend le dernier mode global
            // 3) si on est en PDF et qu'on n'a rien trouv√©, on prend le dernier mode (localStorage)
        if (window.__PDF_BUILDING && (!mode || mode === 'mix')){
          mode = getLastGeomProjMode();
        }

      }

      st = def._genForMode(mode);
    } else {
      // Tous les autres exercices
      st = def.gen();
    }
  }

  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}




function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
