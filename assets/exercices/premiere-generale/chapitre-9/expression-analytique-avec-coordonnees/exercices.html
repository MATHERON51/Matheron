<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1Ã¨re â€“ Produit scalaire - Expression analytique avec coordonnÃ©es</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  table.pdf-tbl td.zbar{
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }

  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

  .uvtab{
    border-collapse:collapse;
    margin:.6rem 0 .8rem 0;
    font-size:0.95rem;
  }
  .uvtab td{
    border:none;
    padding:4px 32px 4px 0;
    white-space:nowrap;
    vertical-align:top;
    line-height:1.6;
  }
  @media print{
    .uvtab td{ padding:4px 40px 4px 0; }
  }

  .angle-mode-box{
    margin-bottom:.5rem;
    padding:.35rem .6rem;
    border-radius:8px;
    background:#f7f7f9;
    display:inline-flex;
    align-items:center;
    gap:.4rem;
  }
  
  /* Chapeau HTML pour l'angle dans le PDF */
.html-angle{
  display:inline-block;
  position:relative;
  padding-top:0.25em;
}
.html-angle-base{
  display:inline-block;
}
.html-angle-cap{
  position:absolute;
  left:50%;
  top:0;
  transform:translate(-50%,-65%);
  font-size:0.7em;
  line-height:1;
}

/* ParenthÃ¨ses larges et "stretchy" autour des deux inputs */
.colvec{
  --parenW: 10px;   /* largeur parenthÃ¨se */
  --padX:   6px;    /* marge interne gauche/droite */
  --gap:    4px;    /* Ã©cart entre les deux inputs */
  --inW:    54px;   /* largeur dâ€™un input */
  --inPx:   6px;    /* padding horizontal input */
  --inPy:   4px;    /* padding vertical input */
  --inFs:   14px;   /* font-size input */

  position: relative;
  display: inline-grid;
  grid-template-rows: auto auto;
  row-gap: var(--gap);
  padding: 6px calc(var(--padX) + var(--parenW));
  vertical-align: middle;
}
.colvec input{
  width: var(--inW);
  text-align: center;
  padding: var(--inPy) var(--inPx);
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: var(--inFs);
}
.colvec::before,
.colvec::after{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  width: var(--parenW);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: .95;
}
.colvec::before{
  left: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}
.colvec::after{
  right: 0; transform: scaleX(-1);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}

/* Version compacte */
.colvec.sm {
  --parenW: 9px;
  --padX: 6px;
  --gap: 4px;
  --inW: 48px;
  --inPy: 3px;
  --inFs: 13px;
}

  
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1Ã¨re â€“ Produit scalaire - Expression analytique avec coordonnÃ©es</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les produits scalaires et les longueurs : rÃ©pondre avec un nombre rÃ©el (entier, dÃ©cimal avec virgule ou fraction du type <code>a/b</code>).</li>
        <li>Pour les angles :
          <ul>
            <li>si lâ€™unitÃ© choisie est <strong>Radian</strong> : rÃ©pondre en radians, par exemple <code>pi/3</code> ou <code>Ï€/3</code> ; pour lâ€™exercice&nbsp;3, donner une valeur approchÃ©e au centiÃ¨me prÃ¨s ;</li>
            <li>si lâ€™unitÃ© choisie est <strong>DegrÃ©</strong> : rÃ©pondre en degrÃ©s (par exemple <code>60</code>) ; pour lâ€™exercice&nbsp;3, donner une valeur approchÃ©e au <strong>degrÃ© prÃ¨s</strong>.</li>
          </ul>
        </li>
        <li>Le signe Â« âˆ’ Â» peut Ãªtre saisi avec le tiret du clavier ; les espaces sont ignorÃ©s.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* â€”â€”â€”â€”â€” Utils â€”â€”â€”â€”â€” */
const $ = (s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='âˆ’';

function cleanSigns(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/\u2212/g, '-');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className='tick '+state;
}

function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}

const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

// UnitÃ© d'angle globale pour toute la page (et pour le PDF)
let ANGLE_MODE = 'rad';

function getAngleMode(){
  return ANGLE_MODE;
}
function setAngleMode(mode){
  ANGLE_MODE = mode || 'rad';
}


/* parseurs & format */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() â†’ Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  // fraction simple a/b
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const parts = s.split('/');
    const p = Number(parts[0]);
    const q = Number(parts[1]);
    if(!q) return NaN;
    return p/q;
  }

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


function approxEqual(a,b,eps=1e-6){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}

function formatNumber(x){
  if(!isFinite(x)) return String(x);
  const r = Math.round(x);
  if(Math.abs(x-r)<1e-9) return String(r);
  return String(x).replace('.',',');
}

function parseAngle(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() â†’ Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // pi ou Ï€ â†’ Math.PI
  s = s.replace(/Ï€|pi/gi,'Math.PI');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


/* parenthÃ¨ses aprÃ¨s une multiplication si le facteur est nÃ©gatif */
function texFactorAfterTimes(tex, numericValue){
  if(numericValue < 0){
    return '\\left('+tex+'\\right)';
  }
  return tex;
}

/* gcd pour fractions (exo 3 et PS symbolique) */
function gcd(a,b){
  a = Math.abs(Math.round(a));
  b = Math.abs(Math.round(b));
  while(b){ const t=a%b; a=b; b=t; }
  return a || 1;
}

/* conversion rad â†” degrÃ©s */
function radToDeg(val){
  return Math.round(val*180/Math.PI);
}
function radToDegTex(val){
  const d = radToDeg(val);
  return d+'^{\\circ}';
}


/* ====== Affichages â€œcoordonnÃ©esâ€ ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages â€œcoordonnÃ©esâ€ â€” rÃ¨gles de parenthÃ¨ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenthÃ¨ses autour d'un nÃ©gatif
const nPlain = n => String(n);

// nombre entre parenthÃ¨ses UNIQUEMENT s'il suit un "âˆ’" dans une diffÃ©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenthÃ¨ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifiÃ©e (pour l'Ã©tape -- â†’ +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des nÃ©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// âœ… Vecteur en COLONNE (dÃ©finitif â€” laisse celui-ci et SUPPRIME toute redÃ©finition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\\\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }




/* â€”â€”â€”â€”â€” Angles remarquables (et opposÃ©s) â€”â€”â€”â€”â€”
   cos(theta) = (num/den)*sqrt(rad)   (rad = 0,2,3) */
const ANGLES = [
  { tex:'0',                  label:'0',     val:0,                num:1,  den:1, rad:0, cosTex:'1' },
  { tex:'\\dfrac{\\pi}{6}',   label:'Ï€/6',   val:Math.PI/6,        num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\dfrac{\\pi}{4}',   label:'Ï€/4',   val:Math.PI/4,        num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{\\pi}{3}',   label:'Ï€/3',   val:Math.PI/3,        num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'\\dfrac{\\pi}{2}',   label:'Ï€/2',   val:Math.PI/2,        num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'\\dfrac{2\\pi}{3}',  label:'2Ï€/3',  val:2*Math.PI/3,      num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'\\dfrac{3\\pi}{4}',  label:'3Ï€/4',  val:3*Math.PI/4,      num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{5\\pi}{6}',  label:'5Ï€/6',  val:5*Math.PI/6,      num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\pi',               label:'Ï€',     val:Math.PI,          num:-1, den:1, rad:0, cosTex:'-1' },
  { tex:'-\\dfrac{\\pi}{6}',  label:'-Ï€/6',  val:-Math.PI/6,       num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\dfrac{\\pi}{4}',  label:'-Ï€/4',  val:-Math.PI/4,       num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{\\pi}{3}',  label:'-Ï€/3',  val:-Math.PI/3,       num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'-\\dfrac{\\pi}{2}',  label:'-Ï€/2',  val:-Math.PI/2,       num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'-\\dfrac{2\\pi}{3}', label:'-2Ï€/3', val:-2*Math.PI/3,     num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'-\\dfrac{3\\pi}{4}', label:'-3Ï€/4', val:-3*Math.PI/4,     num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{5\\pi}{6}', label:'-5Ï€/6', val:-5*Math.PI/6,     num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\pi',              label:'-Ï€',    val:-Math.PI,         num:-1, den:1, rad:0, cosTex:'-1' }
];

// on ajoute la valeur numÃ©rique du cosinus
ANGLES.forEach(a=>{
  const base = (a.rad===0 ? 1 : Math.sqrt(a.rad));
  a.cosVal = (a.num/a.den)*base;
});

/* construit le PS sous forme symbolique : k * cos(theta)
   renvoie : texTimes (k Ã— cos(...) avec parenthÃ¨ses si cos<0),
             texFinal (forme simplifiÃ©e : fraction Ã©ventuellement Ã— racine),
             val (valeur numÃ©rique) */
function buildPsSymbolic(k, ang){
  const cos = ang;

  // cas cos = 0
  if(cos.num === 0){
    const factorTex = texFactorAfterTimes('0', 0);
    return {
      texTimes: k+'\\times '+factorTex,
      texFinal: '0',
      val: 0
    };
  }

  const factorTex = texFactorAfterTimes(cos.cosTex, cos.cosVal);
  const timesTex = k+'\\times '+factorTex;

  let num = k * cos.num;
  let den = cos.den;
  const rad = cos.rad;

  const g = gcd(num,den);
  num /= g; den /= g;

  let coefTex;
  if(den === 1){
    coefTex = String(num);
  }else{
    coefTex = '\\dfrac{'+num+'}{'+den+'}';
  }

  let finalTex;
  if(rad === 0){
    finalTex = coefTex;
  }else{
    finalTex = coefTex+'\\sqrt{'+rad+'}';
  }

  const val = k * cos.cosVal;

  return {
    texTimes: timesTex,
    texFinal: finalTex,
    val
  };
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

/* â€”â€”â€”â€”â€” Exercice 5 : Expression analytique â€” PerpendicularitÃ© â€”â€”â€”â€”â€” */
/* â€”â€”â€”â€”â€” Exercice 1 : Expression analytique â€” Droites perpendiculaires â€”â€”â€”â€”â€” */
const ex1 = {
  id: 'analytique_perp',
  title: `Expression analytique â€“ Droites perpendiculaires`,

    gen(){
    // vecteur AB non nul
    function randNonZero(a,b){
      let v = 0;
      while(v === 0){
        v = randInt(a,b);   // tu as dÃ©jÃ  randInt(a,b) dans le fichier
      }
      return v;
    }

    const u = randNonZero(-5,5);   // composantes de AB
    const v = randNonZero(-5,5);
    const AB = { x: u, y: v };

    // vecteur CD perpendiculaire Ã  AB
    const s  = Math.random() < 0.5 ? 1 : -1;
    const CD = { x: s*v, y: -s*u };

    // on choisit librement A et C (coords plus larges)
    const A = { x: randInt(-10,10), y: randInt(-10,10) };
    const C = { x: randInt(-10,10), y: randInt(-10,10) };

    // puis on construit B et D
    const B = { x: A.x + AB.x, y: A.y + AB.y };
    const D = { x: C.x + CD.x, y: C.y + CD.y };

    // le produit scalaire ABÂ·CD sera forcÃ©ment nul
    return { A, B, C, D };
  },

render(host, st){
  const { A, B, C, D } = st;

  host.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq"></div>
    <div id="fb"></div>
    <div id="inputs"></div>
    <div id="res" class="steps"></div>
  `;

  const equ    = host.querySelector('#equ');
  const inputs = host.querySelector('#inputs');

  equ.innerHTML = `
  <p><strong>Exercice 1 :</strong></p>
    <p>Dans un repÃ¨re orthonormÃ©, on considÃ¨re les points :</p>
    <p>
      \\(A(${A.x}\\;;\\;${A.y})\\),
      \\(B(${B.x}\\;;\\;${B.y})\\),
      \\(C(${C.x}\\;;\\;${C.y})\\),
      \\(D(${D.x}\\;;\\;${D.y})\\).
    </p>
    <p>
      Montrer que les droites \\((AB)\\) et \\((CD)\\) sont perpendiculaires.
    </p>
  `;

  inputs.innerHTML = `
    <div class="pdf-hide" style="margin:8px 0;">
      <strong>1)</strong>
      <table style="border-collapse:collapse; border:none; margin-top:4px;">
        <tr>
          <td style="padding-right:24px; vertical-align:top;">
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
              <span>\\(\\overrightarrow{AB} \\)</span>
              <span class="colvec sm">
                <input id="ab_u" type="text" inputmode="decimal" autocomplete="off">
                <input id="ab_v" type="text" inputmode="decimal" autocomplete="off">
              </span>
              <span id="tick_ab" class="tick nu"></span>
            </div>
          </td>
          <td style="vertical-align:top;">
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
              <span>\\(\\overrightarrow{CD} \\)</span>
              <span class="colvec sm">
                <input id="cd_u" type="text" inputmode="decimal" autocomplete="off">
                <input id="cd_v" type="text" inputmode="decimal" autocomplete="off">
              </span>
              <span id="tick_cd" class="tick nu"></span>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <div class="pdf-hide" style="margin-top:10px;">
      <strong>2)</strong>
      <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-top:4px;">
        <span>\\(\\overrightarrow{AB}\\cdot\\overrightarrow{CD} =\\)</span>
        <input id="ps" type="text" inputmode="decimal" autocomplete="off" style="width:80px;">
        <span id="tick_ps" class="tick nu"></span>
      </div>
    </div>
  `;

  typesetAll(host);
},



correct(host, st){
  const { A, B, C, D } = st;

  const ab_x = B.x - A.x;
  const ab_y = B.y - A.y;
  const cd_x = D.x - C.x;
  const cd_y = D.y - C.y;
  const psExact = ab_x * cd_x + ab_y * cd_y; // doit Ãªtre 0

  const fb  = host.querySelector('#fb');
  const val = id => (host.querySelector('#'+id)?.value || '').replace(',', '.').trim();

  const ab_u = val('ab_u');
  const ab_v = val('ab_v');
  const cd_u = val('cd_u');
  const cd_v = val('cd_v');
  const ps   = val('ps');

  const tick = (id, state) => {
    const el = host.querySelector('#'+id);
    if(!el) return;
    if(state === null){
      el.className = 'tick nu';
    }else{
      el.className = 'tick ' + (state ? 'ok' : 'ko');
    }
  };

  // tout vide â†’ neutre
  if(!ab_u && !ab_v && !cd_u && !cd_v && !ps){
    tick('tick_ab', null);
    tick('tick_cd', null);
    tick('tick_ps', null);
    if(fb) fb.textContent = '';
    return {ok:0,total:3};
  }

  const toNum = s => (s === '' ? NaN : Number(s));

  const ab_u_n = toNum(ab_u);
  const ab_v_n = toNum(ab_v);
  const cd_u_n = toNum(cd_u);
  const cd_v_n = toNum(cd_v);
  const ps_n   = toNum(ps);

  let okAB = false, okCD = false, okPS = false;

  // AB
  if(ab_u || ab_v){
    okAB = (!isNaN(ab_u_n) && !isNaN(ab_v_n) &&
            ab_u_n === ab_x && ab_v_n === ab_y);
    tick('tick_ab', okAB);
  }else{
    tick('tick_ab', null);
  }

  // CD
  if(cd_u || cd_v){
    okCD = (!isNaN(cd_u_n) && !isNaN(cd_v_n) &&
            cd_u_n === cd_x && cd_v_n === cd_y);
    tick('tick_cd', okCD);
  }else{
    tick('tick_cd', null);
  }

  // produit scalaire
  if(ps){
    okPS = (!isNaN(ps_n) && ps_n === psExact);
    tick('tick_ps', okPS);
  }else{
    tick('tick_ps', null);
  }

  const allCoordsFilled = (ab_u || ab_v) && (cd_u || cd_v);
  const allCoordsOK     = okAB && okCD;

  if(fb){
    if(!allCoordsFilled){
      fb.textContent = "Commence par complÃ©ter les coordonnÃ©es de \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{CD}\\).";
    }else if(!allCoordsOK){
      fb.textContent = "Corrige dâ€™abord les coordonnÃ©es de \\(\\overrightarrow{AB}\\) et/ou \\(\\overrightarrow{CD}\\).";
    }else if(allCoordsOK && !ps){
      fb.textContent = "CoordonnÃ©es correctes. Calcule maintenant \\(\\overrightarrow{AB}\\cdot\\overrightarrow{CD}\\).";
    }else if(allCoordsOK && okPS){
      fb.textContent = "âœ” Tout est correct. Comme le produit scalaire est nul, les droites \\((AB)\\) et \\((CD)\\) sont perpendiculaires.";
    }else{
      fb.textContent = "Les coordonnÃ©es sont correctes, mais le produit scalaire est incorrect.";
    }
    if (window.MathJax?.typesetPromise) MathJax.typesetPromise([fb]);
  }

  const okCount = (okAB?1:0) + (okCD?1:0) + (okPS?1:0);
  return {ok:okCount, total:3};
},


solution(host, st){
  const { A, B, C, D } = st;

  const ab_x = B.x - A.x;
  const ab_y = B.y - A.y;
  const cd_x = D.x - C.x;
  const cd_y = D.y - C.y;
  const psExact = ab_x * cd_x + ab_y * cd_y; // = 0 si bien construit

  // p - q, en Ã©vitant complÃ¨tement "-(-...)" :
  // si q < 0, on Ã©crit "p + |q|"
  function texDiff(p, q){
    if(q < 0){
      const absq = Math.abs(q);
      return `${p} + ${absq}`;
    }else{
      return `${p} - ${q}`;
    }
  }

  // a Ã— b avec parenthÃ¨ses autour des nombres nÃ©gatifs
  function texMul(a, b){
    const left  = (a < 0) ? `(${a})` : `${a}`;
    const right = (b < 0) ? `(${b})` : `${b}`;
    return `${left}\\times${right}`;
  }

  // a + b en Ã©vitant " + (-6)" â†’ " - 6"
  function texSum(a, b){
    const part1 = `${a}`;
    if(b === 0) return part1;
    if(b > 0)  return `${part1} + ${b}`;
    const absb = Math.abs(b);
    return `${part1} - ${absb}`;
  }

  const p1 = ab_x * cd_x;
  const p2 = ab_y * cd_y;

  // ðŸ”´ ICI LE CHANGEMENT IMPORTANT :
  const res = host.querySelector('#res');

  const stepsAB = [
    `\\(\\overrightarrow{AB} \\begin{pmatrix} x_B - x_A \\\\ y_B - y_A \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{AB}  \\begin{pmatrix} ${texDiff(B.x, A.x)} \\\\ ${texDiff(B.y, A.y)} \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{AB} \\begin{pmatrix} ${ab_x} \\\\ ${ab_y} \\end{pmatrix}\\)`
  ];

  const stepsCD = [
    `\\(\\overrightarrow{CD}  \\begin{pmatrix} x_D - x_C \\\\ y_D - y_C \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{CD}  \\begin{pmatrix} ${texDiff(D.x, C.x)} \\\\ ${texDiff(D.y, C.y)} \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{CD}  \\begin{pmatrix} ${cd_x} \\\\ ${cd_y} \\end{pmatrix}\\)`
  ];

  const stepsPS = [
    `\\(\\overrightarrow{AB}\\cdot\\overrightarrow{CD} = ${texMul(ab_x, cd_x)} + ${texMul(ab_y, cd_y)}\\)`,
    `\\(\\overrightarrow{AB}\\cdot\\overrightarrow{CD} = ${texSum(p1, p2)}\\)`,
    `\\(\\overrightarrow{AB}\\cdot\\overrightarrow{CD} = ${psExact}\\)`,
    `Ainsi les droites \\((AB)\\) et \\((CD)\\) sont perpendiculaires.`
  ];

  res.innerHTML = `
    <table style="border-collapse:collapse; border:none; width:100%; max-width:620px; margin:0 auto;">
      <tr>
        <td style="vertical-align:top; padding-right:16px;">
          ${stepsAB.map(s => `<p>${s}</p>`).join('')}
        </td>
        <td style="vertical-align:top; padding-left:16px;">
          ${stepsCD.map(s => `<p>${s}</p>`).join('')}
        </td>
      </tr>
    </table>
    <div style="margin-top:0.6rem;">
      ${stepsPS.map(s => `<p>${s}</p>`).join('')}
    </div>
  `;

  typesetAll(res);
},




  reset(host){
    ['ab_u','ab_v','cd_u','cd_v','ps'].forEach(id=>{
      const inp = host.querySelector('#'+id);
      if(inp) inp.value = '';
    });
    ['tick_ab','tick_cd','tick_ps'].forEach(id=>{
      const el = host.querySelector('#'+id);
      if(el){
        el.className = 'tick nu';
        el.textContent = '';
      }
    });
    const fb  = host.querySelector('#fb');
    const res = host.querySelector('#res');
    if(fb)  fb.textContent = '';
    if(res) res.innerHTML  = '';
  }
};




const ex2 = {
  id: 'analytique_triangle',
  title: `Expression analytique â€“ Nature dâ€™un triangle`,

  gen(){
    const MIN = -6, MAX = 6;

    function randPoint(){
      return {a: randInt(MIN,MAX), b: randInt(MIN,MAX)};
    }
    function d2(P,Q){
      const dx = Q.a - P.a;
      const dy = Q.b - P.b;
      return {dx, dy, S: dx*dx + dy*dy};
    }
    function dotAt(P,Q,R){
      // produit scalaire pour l'angle en Q : (QP)Â·(QR)
      const u = {x: P.a - Q.a, y: P.b - Q.b};
      const v = {x: R.a - Q.a, y: R.b - Q.b};
      return u.x*v.x + u.y*v.y;
    }

    function classify(A,B,C){
      const ABd = d2(A,B);
      const ACd = d2(A,C);
      const BCd = d2(B,C);
      const AB2 = ABd.S, AC2 = ACd.S, BC2 = BCd.S;

      // isocÃ¨le : sommet
      let isoAt = '';
      if (AB2 === AC2) isoAt = 'A';
      else if (AC2 === BC2) isoAt = 'C';
      else if (AB2 === BC2) isoAt = 'B';

      // rectangle : via produits scalaires
      let rectAt = '';
      const dA = dotAt(B,A,C);
      const dB = dotAt(A,B,C);
      const dC = dotAt(A,C,B);
      if (dA === 0) rectAt = 'A';
      else if (dB === 0) rectAt = 'B';
      else if (dC === 0) rectAt = 'C';

      let kind;
      if (rectAt && isoAt && rectAt === isoAt) kind = 'iso_right';
      else if (rectAt)                         kind = 'right_only';
      else if (isoAt)                          kind = 'iso_only';
      else                                     kind = 'scalene';

      let expected;
      if (kind === 'iso_right') expected = 'isocele rectangle';
      else if (kind === 'right_only') expected = 'rectangle';
      else if (kind === 'iso_only') expected = 'isocele';
      else expected = 'quelconque';

      return {A,B,C, AB2,AC2,BC2, isoAt,rectAt, kind,expected};
    }

    function nonDegenerate(A,B,C){
      // pas de points confondus, pas d'alignement
      if (A.a === B.a && A.b === B.b) return false;
      if (A.a === C.a && A.b === C.b) return false;
      if (B.a === C.a && B.b === C.b) return false;
      const det = (B.a-A.a)*(C.b-A.b) - (B.b-A.b)*(C.a-A.a);
      return det !== 0;
    }

    function randomTriangle(targetKind){
      for(;;){
        const A = randPoint();
        const B = randPoint();
        const C = randPoint();
        if (!nonDegenerate(A,B,C)) continue;
        const info = classify(A,B,C);
        if (info.kind === targetKind) return info;
      }
    }

    // pondÃ©rations voulues (Ã©quilatÃ©raux impossibles en entiers â‡’ rÃ©affectÃ©s)
    const r = Math.random();
    let targetKind;
    if (r < 0.10)                      targetKind = 'scalene';      // 10%
    else if (r < 0.10 + 0.25)          targetKind = 'right_only';   // 25%
    else if (r < 0.10 + 0.25 + 0.25)   targetKind = 'iso_only';     // 25%
    else                               targetKind = 'iso_right';    // â‰ƒ 50%

    return randomTriangle(targetKind);
  },

  render(host, st){
    const {A,B,C} = st;

    host.innerHTML = `
      <div class="pdf-hide" id="lead" class="small"></div>
      <div id="equ" class="eq"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const equ    = $('#equ',host);
    const inputs = $('#inputs',host);

    const lead = $('#lead',host);
    if(lead){
      lead.innerHTML = `
        RÃ©pondre : Â« quelconque Â», Â« Ã©quilatÃ©ral Â», Â« isocÃ¨le Â», Â« rectangle Â», Â« isocÃ¨le rectangle Â».
      `;
    }

    if(equ){
      equ.innerHTML = `
	  <p><strong>Exercice 2 :</strong></p>
        <p>On considÃ¨re \\(A${fmtPtLaNum(A)}\\), \\(B${fmtPtLaNum(B)}\\) et \\(C${fmtPtLaNum(C)}\\).</p>
        <p>Donner la nature du triangle \\(ABC\\).</p>
      `;
    }

    if(inputs){
      inputs.innerHTML = `
        <div class="pdf-hide" style="margin-top:8px;">
          Nature de \\(ABC\\) :
          <input type="text" class="ans-tri-type" size="24" autocomplete="off">
          <span class="tick nu"></span>
        </div>
      `;
    }

    typesetAll(host);
  },

  correct(host, st){
    const inp = host.querySelector('.ans-tri-type');
    const fb  = host.querySelector('#fb');
    let ok = 0, total = 1;

    const raw = (inp && inp.value ? inp.value : '')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    const s = raw.replace(/[^a-z ]/g,' ').replace(/\s+/g,' ').trim();

    const hasIso  = /\biso(c|s)?(o|0)?(c|s)?ele?\b/.test(s) || /\biso\b/.test(s);
    const hasRect = /\brect(ang(le)?)?\b/.test(s) || /\brect\b/.test(s);
    const hasQuel = /\bquelconque\b/.test(s);
    const hasEqui = /\bequilater(al)?e?\b/.test(s); // acceptÃ© mais jamais la bonne rÃ©ponse ici

    let answer = '';
    if (hasIso && hasRect) answer = 'isocele rectangle';
    else if (hasRect)      answer = 'rectangle';
    else if (hasIso)       answer = 'isocele';
    else if (hasQuel)      answer = 'quelconque';
    else if (hasEqui)      answer = 'equilateral';

    if (!answer){
      if(inp) setTick(inp,'ko');
      if (fb){
        fb.textContent = "Tape la nature (ex. Â« isocÃ¨le Â», Â« rectangle Â», Â« isocÃ¨le rectangle Â», Â« quelconque Â»).";
      }
      return {ok:0,total};
    }

    const expected = st.expected;
    const good = (answer === expected);

    if (inp) setTick(inp, good ? 'ok' : 'ko');
    if (good) ok = 1;

    if (fb){
      let extra = '';
      if (expected === 'rectangle' && st.rectAt){
        extra = ` (en ${st.rectAt})`;
      }
      if (expected === 'isocele' && st.isoAt){
        extra = ` (en ${st.isoAt})`;
      }
      if (expected === 'isocele rectangle' && st.rectAt && st.isoAt){
        extra = ` (rectangle en ${st.rectAt}, isocÃ¨le en ${st.isoAt})`;
      }
      const txt = good
        ? `Câ€™est bon : ${expected}${extra}.`
        : `Attendu : ${expected}${extra}.`;
      fb.innerHTML = txt;
      typesetAll(fb);
    }

    return {ok,total};
  },

solution(host, st){
  const {A,B,C} = st;
  const res = $('#res',host);
  if(!res) return;

  // ====== Bloc longueurs (norme uniquement) â€” EXACTEMENT ton style ======
  function d2(P,Q){
    const dx = Q.a - P.a;
    const dy = Q.b - P.b;
    return {dx,dy,S:dx*dx + dy*dy};
  }
  function powTerm(n){ return (n<0?`(${n})`:`${n}`)+`^2`; }

  // Bloc longueur (norme du vecteur uniquement)
  function lengthBlock(name, P, Q){
    const {dx,dy,S} = d2(P,Q);
    const perfect = Number.isInteger(Math.sqrt(S));
    const innerX    = minusExpr(Q.a,P.a);
    const innerY    = minusExpr(Q.b,P.b);
    const innerXFix = minusExprSimplified(Q.a,P.a);
    const innerYFix = minusExprSimplified(Q.b,P.b);
    const Vfix   = colVecExpr(innerXFix, innerYFix);
    const Vfinal = fmtVecLaNum(dx,dy);

    const Ls = [
      `\\(\\overrightarrow{${name}}${colVecExpr('x_'+name[1]+'-x_'+name[0],'y_'+name[1]+'-y_'+name[0])}\\)`,
      `\\(\\overrightarrow{${name}}${Vfix}\\)`,
      `\\(\\overrightarrow{${name}}${Vfinal}\\)`,
      `\\(${name}=\\sqrt{${powTerm(dx)}+${powTerm(dy)}}\\)`,
      `\\(${name}=\\sqrt{${dx*dx}+${dy*dy}}\\)`,
      `\\(${name}=\\sqrt{${S}}\\)`
    ];
    if (perfect) Ls.push(`\\(${name}=${Math.sqrt(S)}\\)`);
    return Ls.map(s=>`<p>${s}</p>`).join('');
  }

  // Tableau 3 colonnes invisible (AB, AC, BC)
  const colAB = `<div class="box"><p><strong>Calcul de \\(AB\\)</strong></p>${lengthBlock('AB',A,B)}</div>`;
  const colAC = `<div class="box"><p><strong>Calcul de \\(AC\\)</strong></p>${lengthBlock('AC',A,C)}</div>`;
  const colBC = `<div class="box"><p><strong>Calcul de \\(BC\\)</strong></p>${lengthBlock('BC',B,C)}</div>`;

  res.innerHTML =
    `<table style="border-collapse:collapse;width:100%;table-layout:fixed">
      <tr>
        <td style="width:33.33%;vertical-align:top;padding:6px;border:none">${colAB}</td>
        <td style="width:33.33%;vertical-align:top;padding:6px;border:none">${colAC}</td>
        <td style="width:33.33%;vertical-align:top;padding:6px;border:none">${colBC}</td>
      </tr>
    </table>`;
  typesetAll(res);

  // â€” dÃ©termination isocÃ¨le (mÃªme logique que ton code) â€”
  const ABv = d2(A,B);       // vect(AB)
  const ACv = d2(A,C);       // vect(AC)
  const BCv = d2(B,C);       // vect(BC)

  const AB2 = ABv.S, AC2 = ACv.S, BC2 = BCv.S;

  let isoAt = '';
  if (AB2===AC2) isoAt='A';
  else if (AC2===BC2) isoAt='C';
  else if (AB2===BC2) isoAt='B';

  let isoLine = '';
  if (isoAt==='A') isoLine=`\\(AB=AC\\) : <strong>isocÃ¨le en \\(A\\)</strong>.`;
  else if (isoAt==='B') isoLine=`\\(AB=BC\\) : <strong>isocÃ¨le en \\(B\\)</strong>.`;
  else if (isoAt==='C') isoLine=`\\(AC=BC\\) : <strong>isocÃ¨le en \\(C\\)</strong>.`;
  else isoLine=`\\(AB \\neq AC \\neq BC\\) : le triangle \\(ABC\\) nâ€™est <strong>ni isocÃ¨le, ni Ã©quilatÃ©ral</strong>.`;

  res.innerHTML += `<p>${isoLine}</p>`;
  typesetAll(res);

  // ====== PRODUITS SCALAIRES avec seulement AB, AC, BC ======
  function texMul(a,b){
    const sa = a<0 ? `(${a})` : `${a}`;
    const sb = b<0 ? `(${b})` : `${b}`;
    return `${sa}\\times${sb}`;
  }
  function texSum(a,b){
    return b<0 ? `${a} - ${Math.abs(b)}` : `${a} + ${b}`;
  }

  const vAB = {dx: ABv.dx, dy: ABv.dy};  // \vec{AB}
  const vAC = {dx: ACv.dx, dy: ACv.dy};  // \vec{AC}
  const vBC = {dx: BCv.dx, dy: BCv.dy};  // \vec{BC}

  // PS en A : ABÂ·AC
  const pA1 = vAB.dx * vAC.dx;
  const pA2 = vAB.dy * vAC.dy;
  const psA = pA1 + pA2;

  // PS en B : ABÂ·BC  (on n'utilise plus BA)
  const pB1 = vAB.dx * vBC.dx;
  const pB2 = vAB.dy * vBC.dy;
  const psB = pB1 + pB2;

  // PS en C : ACÂ·BC
  const pC1 = vAC.dx * vBC.dx;
  const pC2 = vAC.dy * vBC.dy;
  const psC = pC1 + pC2;

  function blocPS(nameU, nameV, U, V, p1, p2, ps, isRight){
    const l1 = `\\(\\overrightarrow{${nameU}}\\cdot\\overrightarrow{${nameV}} = ${texMul(U.dx, V.dx)} + ${texMul(U.dy, V.dy)}\\)`;
    const l2 = `\\(\\overrightarrow{${nameU}}\\cdot\\overrightarrow{${nameV}} = ${texSum(p1,p2)}\\)`;
    let l3;
    if (isRight){
      l3 = `\\(\\overrightarrow{${nameU}}\\cdot\\overrightarrow{${nameV}} = 0\\)`;
    }else{
      l3 = `\\(\\overrightarrow{${nameU}}\\cdot\\overrightarrow{${nameV}} = ${ps} \\neq 0\\)`;
    }
    return `<p>${l1}</p><p>${l2}</p><p>${l3}</p>`;
  }

  // DÃ©termination du sommet rectangle (si besoin), avec ces PS
  let rectAt = '';
  if (psA === 0) rectAt = 'A';
  else if (psB === 0) rectAt = 'B';
  else if (psC === 0) rectAt = 'C';

  // --- Cas 1 : triangle rectangle â†’ 1 seul PS au sommet droit ---
  if (rectAt){
    let bloc = '';
    if (rectAt === 'A'){
      bloc = blocPS('AB','AC',vAB,vAC,pA1,pA2,psA,true)
           + `<p>Ainsi, le triangle \\(ABC\\) est <strong>rectangle en \\(A\\)</strong>.</p>`;
    }else if (rectAt === 'B'){
      bloc = blocPS('AB','BC',vAB,vBC,pB1,pB2,psB,true)
           + `<p>Ainsi, le triangle \\(ABC\\) est <strong>rectangle en \\(B\\)</strong>.</p>`;
    }else{ // C
      bloc = blocPS('AC','BC',vAC,vBC,pC1,pC2,psC,true)
           + `<p>Ainsi, le triangle \\(ABC\\) est <strong>rectangle en \\(C\\)</strong>.</p>`;
    }
    res.innerHTML += bloc;

  // --- Cas 2 : isocÃ¨le non rectangle â†’ 1 seul PS au sommet isocÃ¨le ---
  }else if (isoAt){
    let bloc = '';
    if (isoAt === 'A'){
      bloc = blocPS('AB','AC',vAB,vAC,pA1,pA2,psA,false)
           + `<p>Le produit scalaire est non nul, donc lâ€™angle \\(\\widehat{BAC}\\) nâ€™est pas droit et le triangle nâ€™est pas rectangle.</p>`;
    }else if (isoAt === 'B'){
      // un seul produit scalaire en B, avec ABÂ·BC
      bloc = blocPS('AB','BC',vAB,vBC,pB1,pB2,psB,false)
           + `<p>Le produit scalaire est non nul, donc lâ€™angle \\(\\widehat{ABC}\\) nâ€™est pas droit et le triangle nâ€™est pas rectangle.</p>`;
    }else{ // C
      bloc = blocPS('AC','BC',vAC,vBC,pC1,pC2,psC,false)
           + `<p>Le produit scalaire est non nul, donc lâ€™angle \\(\\widehat{ACB}\\) nâ€™est pas droit et le triangle nâ€™est pas rectangle.</p>`;
    }
    res.innerHTML += bloc;

  // --- Cas 3 : quelconque â†’ 3 produits scalaires dans un TABLEAU 3 colonnes ---
  }else{
    const bA = blocPS('AB','AC',vAB,vAC,pA1,pA2,psA,false);
    const bB = blocPS('AB','BC',vAB,vBC,pB1,pB2,psB,false);
    const bC = blocPS('AC','BC',vAC,vBC,pC1,pC2,psC,false);

    const colA2 = `<div class="box"><p><strong>Angle en \\(A\\)</strong></p>${bA}</div>`;
    const colB2 = `<div class="box"><p><strong>Angle en \\(B\\)</strong></p>${bB}</div>`;
    const colC2 = `<div class="box"><p><strong>Angle en \\(C\\)</strong></p>${bC}</div>`;

    res.innerHTML += `
      <p>On calcule les produits scalaires associÃ©s aux trois angles du triangle :</p>
      <table style="border-collapse:collapse;width:100%;table-layout:fixed">
        <tr>
          <td style="width:33.33%;vertical-align:top;padding:6px;border:none">${colA2}</td>
          <td style="width:33.33%;vertical-align:top;padding:6px;border:none">${colB2}</td>
          <td style="width:33.33%;vertical-align:top;padding:6px;border:none">${colC2}</td>
        </tr>
      </table>
      <p>Aucun de ces produits scalaires nâ€™est nul, donc le triangle \\(ABC\\) nâ€™est pas rectangle.</p>
    `;
  }

  // Conclusion finale sur la nature
  let nature;
  if (rectAt && isoAt){ nature = `isocÃ¨le et rectangle en \\(${rectAt}\\)`; }
  else if (rectAt){ nature = `rectangle en \\(${rectAt}\\)`; }
  else if (isoAt){ nature = `isocÃ¨le en \\(${isoAt}\\)`; }
  else { nature = 'quelconque'; }

  res.innerHTML += `<p><strong>Conclusion :</strong> le triangle \\(ABC\\) est <strong>${nature}</strong>.</p>`;
  typesetAll(res);
}
,

  reset(host){
    const inp = host.querySelector('.ans-tri-type');
    if (inp){ inp.value=''; setTick(inp,'nu'); }
    const fb  = host.querySelector('#fb');
    if (fb) fb.textContent = '';
    const W = host.querySelector('#res');
    if (W) W.innerHTML = '';
  }
};


/* â€”â€”â€”â€”â€” Exercice 3 : Expression analytique du produit scalaire â€”â€”â€”â€”â€” */
const ex3 = {
  id: 'analytique_quad',
  title: `Expression analytique du produit scalaire â€“ QuadrilatÃ¨re`,

  gen(){
    // On fabrique un parallÃ©logramme dont les cÃ´tÃ©s ont mÃªme longueur :
    // -> parallelogramme => ABCD
    // -> |AB| = |BC| => parallÃ©logramme "de base" un losange
    // et dans ce cas les diagonales sont perpendiculaires.

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

    // vecteur non nul pour un cÃ´tÃ©
    function randNonZeroVec(min,max){
      let x=0,y=0;
      while(x===0 && y===0){
        x = randInt(min,max);
        y = randInt(min,max);
      }
      return {x,y};
    }

    // vecteur adjacent de mÃªme norme (ici rotation Ã  90Â°)
    const u = randNonZeroVec(-4,4);       // cÃ´tÃ© AB
    const v = {x:-u.y, y:u.x};            // cÃ´tÃ© AD, |v| = |u|

    // point A de dÃ©part (on garde des coordonnÃ©es raisonnables)
    const A = {
      x: randInt(-5,5),
      y: randInt(-5,5)
    };
    const B = { x: A.x + u.x,           y: A.y + u.y           };
    const D = { x: A.x + v.x,           y: A.y + v.y           };
    const C = { x: A.x + u.x + v.x,     y: A.y + u.y + v.y     };

    // vecteurs utiles
    const AB = { x: B.x - A.x, y: B.y - A.y };
    const DC = { x: C.x - D.x, y: C.y - D.y };
    const BD = { x: D.x - B.x, y: D.y - B.y };
    const AC = { x: C.x - A.x, y: C.y - A.y };

    // produit scalaire des diagonales
    const ps = BD.x*AC.x + BD.y*AC.y;   // doit Ãªtre 0

    return {A,B,C,D,AB,DC,BD,AC,ps};
  },

  render(host, st){
    host.innerHTML = `
      <p><strong>Exercice 3 :</strong></p>
      <p>Soient les points
        $A( ${st.A.x} ; ${st.A.y} ),\\;
         B( ${st.B.x} ; ${st.B.y} ),\\;
         C( ${st.C.x} ; ${st.C.y} )$ et
         $D( ${st.D.x} ; ${st.D.y} )$.
      </p>
      <ol>
        <li>Montrer que $\\overrightarrow{AB} = \\overrightarrow{DC}$.</li>
        <li>
          Calculer $\\overrightarrow{BD}\\cdot\\overrightarrow{AC}$.
          <br>
          <span class="pdf-hide">
            $\\overrightarrow{BD}\\cdot\\overrightarrow{AC} =$
            <input type="text" class="ans-ps7" size="6" autocomplete="off">
            <span class="tick nu"></span>
          </span>
        </li>
        <li>
          En dÃ©duire la nature du quadrilatÃ¨re $ABCD$.
          <br>
          <span class="pdf-hide">
            Nature de $ABCD$ :
            <select class="ans-type7">
              <option value="">â€”</option>
              <option value="parallelogramme">ParallÃ©logramme quelconque</option>
              <option value="rectangle">Rectangle</option>
              <option value="losange">Losange</option>
              <option value="carre">CarrÃ©</option>
            </select>
            <span class="tick nu"></span>
          </span>
        </li>
      </ol>

      <div id="steps" class="steps"></div>
    `;
    typesetAll(host);
  },

  correct(host, st){
    let ok = 0, total = 2;

    const inpPs = host.querySelector('.ans-ps7');
    const v     = parseNumber(inpPs && inpPs.value);
    if(!isNaN(v) && approxEqual(v, st.ps)){
      setTick(inpPs,'ok'); ok++;
    }else{
      setTick(inpPs,'ko');
    }

    const selType = host.querySelector('.ans-type7');
    if(selType){
      if(selType.value === 'losange'){
        setTick(selType,'ok'); ok++;
      }else{
        setTick(selType,'ko');
      }
    }

    return {ok, total};
  },

  solution(host, st){
  const W = $('#steps',host);
  if(!W) return;

  const {A,B,C,D,AB,DC,BD,AC,ps} = st;

  // ----- petites fonctions d'affichage, calquÃ©es sur l'exo 1 -----
  // p - q sans jamais Ã©crire -(-q) : on passe directement en "p + |q|"
  function texDiff(p,q){
    if(q < 0){
      const absq = Math.abs(q);
      return `${p} + ${absq}`;
    }else{
      return `${p} - ${q}`;
    }
  }

  // a Ã— b avec parenthÃ¨ses autour des nombres nÃ©gatifs
  function texMul(a,b){
    const left  = (a < 0) ? `(${a})` : `${a}`;
    const right = (b < 0) ? `(${b})` : `${b}`;
    return `${left}\\times${right}`;
  }

  // a + b en Ã©vitant "+(-...)" â†’ " - ..."
  function texSum(a,b){
    if(b === 0) return `${a}`;
    if(b > 0)   return `${a} + ${b}`;
    const absb = Math.abs(b);
    return `${a} - ${absb}`;
  }

  // ===== 1) Vecteurs AB et DC (mÃªme prÃ©sentation que l'exo 1, SANS =) =====
  const stepsAB = [
    `\\(\\overrightarrow{AB}\\begin{pmatrix} x_B - x_A \\\\ y_B - y_A \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{AB}\\begin{pmatrix} ${texDiff(B.x, A.x)} \\\\ ${texDiff(B.y, A.y)} \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{AB}\\begin{pmatrix} ${AB.x} \\\\ ${AB.y} \\end{pmatrix}\\)`
  ];

  const stepsDC = [
    `\\(\\overrightarrow{DC}\\begin{pmatrix} x_C - x_D \\\\ y_C - y_D \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{DC}\\begin{pmatrix} ${texDiff(C.x, D.x)} \\\\ ${texDiff(C.y, D.y)} \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{DC}\\begin{pmatrix} ${DC.x} \\\\ ${DC.y} \\end{pmatrix}\\)`
  ];

  // ===== 2) Vecteurs BD et AC, aussi dans un tableau =====
  const stepsBD = [
    `\\(\\overrightarrow{BD}\\begin{pmatrix} x_D - x_B \\\\ y_D - y_B \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{BD}\\begin{pmatrix} ${texDiff(D.x, B.x)} \\\\ ${texDiff(D.y, B.y)} \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{BD}\\begin{pmatrix} ${BD.x} \\\\ ${BD.y} \\end{pmatrix}\\)`
  ];

  const stepsAC = [
    `\\(\\overrightarrow{AC}\\begin{pmatrix} x_C - x_A \\\\ y_C - y_A \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{AC}\\begin{pmatrix} ${texDiff(C.x, A.x)} \\\\ ${texDiff(C.y, A.y)} \\end{pmatrix}\\)`,
    `\\(\\overrightarrow{AC}\\begin{pmatrix} ${AC.x} \\\\ ${AC.y} \\end{pmatrix}\\)`
  ];

  // ===== 3) Produit scalaire des diagonales =====
  const p1 = BD.x * AC.x;
  const p2 = BD.y * AC.y;

  const stepsPS = [
    `\\(\\overrightarrow{BD}\\cdot\\overrightarrow{AC}
      = ${texMul(BD.x, AC.x)} + ${texMul(BD.y, AC.y)}\\)`,
    `\\(\\overrightarrow{BD}\\cdot\\overrightarrow{AC}
      = ${texSum(p1, p2)}\\)`,
    `\\(\\overrightarrow{BD}\\cdot\\overrightarrow{AC}
      = ${ps}\\)`
  ];

  // ===== 4) Conclusion rÃ©digÃ©e =====
  const concl = [

    `3. Ainsi `,
    `les diagonales sont perpendiculaires.`,
    `Dans un parallÃ©logramme, si les diagonales sont perpendiculaires,`,
    `alors c'est un <strong>losange</strong>.`
  ];

  W.innerHTML = `
    <!-- Tableau AB / DC -->
    <div>1.
      <table style="border-collapse:collapse; border:none; width:100%; max-width:620px; margin:0 auto;">
        <tr>
          <td style="vertical-align:top; padding-right:16px;">
            ${stepsAB.map(s => `<p>${s}</p>`).join('')}
          </td>
          <td style="vertical-align:top; padding-left:16px;">
            ${stepsDC.map(s => `<p>${s}</p>`).join('')}
          </td>
        </tr>
      </table>
    </div>

    <!-- Phrase AB = DC juste aprÃ¨s le calcul des vecteurs -->
    <div style="margin-top:0.4rem;">
      <p>\\(\\overrightarrow{AB} = \\overrightarrow{DC}\\), donc \\(ABCD\\) est un parallÃ©logramme.</p>
    </div>

    <!-- Tableau BD / AC -->
    <div style="margin-top:0.6rem;">2.
      <table style="border-collapse:collapse; border:none; width:100%; max-width:620px; margin:0 auto;">
        <tr>
          <td style="vertical-align:top; padding-right:16px;">
            ${stepsBD.map(s => `<p>${s}</p>`).join('')}
          </td>
          <td style="vertical-align:top; padding-left:16px;">
            ${stepsAC.map(s => `<p>${s}</p>`).join('')}
          </td>
        </tr>
      </table>
    </div>

    <!-- Produit scalaire des diagonales -->
    <div style="margin-top:0.6rem;">
      ${stepsPS.map(s => `<p>${s}</p>`).join('')}
    </div>

    <!-- Conclusion finale -->
    <div style="margin-top:0.6rem;">
      <p>${concl[0]} ${concl[1]}</p>
      <p>${concl[2]} ${concl[3]}</p>

    </div>
  `;

  typesetAll(W);
},


  reset(host){
    const inpPs = host.querySelector('.ans-ps7');
    if(inpPs){ inpPs.value=''; setTick(inpPs,'nu'); }
    const selType = host.querySelector('.ans-type7');
    if(selType){ selType.value=''; setTick(selType,'nu'); }
    const W = $('#steps',host);
    if(W) W.innerHTML='';
  }
};



/* â€”â€”â€”â€”â€” Registre & UI â€”â€”â€”â€”â€” */
const REGISTRY=[ex1, ex2, ex3];
window.REGISTRY = REGISTRY;

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1Ã¨re â€“ Produit scalaire - Expression analytique avec coordonnÃ©es`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = def.gen();
  host.dataset.active = def.id;
host.dataset.state = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}

function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
