<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äì Produit scalaire - Choisir la forme la plus adapt√©e</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  table.pdf-tbl td.zbar{
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }

  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

  .uvtab{
    border-collapse:collapse;
    margin:.6rem 0 .8rem 0;
    font-size:0.95rem;
  }
  .uvtab td{
    border:none;
    padding:4px 32px 4px 0;
    white-space:nowrap;
    vertical-align:top;
    line-height:1.6;
  }
  @media print{
    .uvtab td{ padding:4px 40px 4px 0; }
  }

  .angle-mode-box{
    margin-bottom:.5rem;
    padding:.35rem .6rem;
    border-radius:8px;
    background:#f7f7f9;
    display:inline-flex;
    align-items:center;
    gap:.4rem;
  }
  
  /* Chapeau HTML pour l'angle dans le PDF */
.html-angle{
  display:inline-block;
  position:relative;
  padding-top:0.25em;
}
.html-angle-base{
  display:inline-block;
}
.html-angle-cap{
  position:absolute;
  left:50%;
  top:0;
  transform:translate(-50%,-65%);
  font-size:0.7em;
  line-height:1;
}

/* Parenth√®ses larges et "stretchy" autour des deux inputs */
.colvec{
  --parenW: 10px;   /* largeur parenth√®se */
  --padX:   6px;    /* marge interne gauche/droite */
  --gap:    4px;    /* √©cart entre les deux inputs */
  --inW:    54px;   /* largeur d‚Äôun input */
  --inPx:   6px;    /* padding horizontal input */
  --inPy:   4px;    /* padding vertical input */
  --inFs:   14px;   /* font-size input */

  position: relative;
  display: inline-grid;
  grid-template-rows: auto auto;
  row-gap: var(--gap);
  padding: 6px calc(var(--padX) + var(--parenW));
  vertical-align: middle;
}
.colvec input{
  width: var(--inW);
  text-align: center;
  padding: var(--inPy) var(--inPx);
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: var(--inFs);
}
.colvec::before,
.colvec::after{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  width: var(--parenW);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: .95;
}
.colvec::before{
  left: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}
.colvec::after{
  right: 0; transform: scaleX(-1);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}

/* Version compacte */
.colvec.sm {
  --parenW: 9px;
  --padX: 6px;
  --gap: 4px;
  --inW: 48px;
  --inPy: 3px;
  --inFs: 13px;
}

.fig-geom{
  display:flex;
  justify-content:center;
  margin:.35rem 0 .4rem;
}

/* NOUVELLE VERSION : figures bien plus petites */
.fig-geom svg{
  width:300px;        /* largeur fixe raisonnable */
  max-width:300px;    /* limite √©cran / mobile */
  height:auto;
}
  
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\\[','\\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re ‚Äì Produit scalaire - Choisir la forme la plus adapt√©e</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les produits scalaires et les longueurs : r√©pondre avec un nombre r√©el (entier, d√©cimal avec virgule ou fraction du type <code>a/b</code>).</li>
        <li>Pour les angles :
          <ul>
            <li>si l‚Äôunit√© choisie est <strong>Radian</strong> : r√©pondre en radians, par exemple <code>pi/3</code> ou <code>œÄ/3</code> ; pour l‚Äôexercice&nbsp;3, donner une valeur approch√©e au centi√®me pr√®s ;</li>
            <li>si l‚Äôunit√© choisie est <strong>Degr√©</strong> : r√©pondre en degr√©s (par exemple <code>60</code>) ; pour l‚Äôexercice&nbsp;3, donner une valeur approch√©e au <strong>degr√© pr√®s</strong>.</li>
          </ul>
        </li>
        <li>Le signe ¬´ ‚àí ¬ª peut √™tre saisi avec le tiret du clavier ; les espaces sont ignor√©s.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $ = (s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';

function cleanSigns(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/\u2212/g, '-');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className='tick '+state;
}

function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}

const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function shuffleInPlace(arr){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
}



function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

// Unit√© d'angle globale pour toute la page (et pour le PDF)
let ANGLE_MODE = 'rad';

function getAngleMode(){
  return ANGLE_MODE;
}
function setAngleMode(mode){
  ANGLE_MODE = mode || 'rad';
}


/* parseurs & format */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() ‚Üí Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  // fraction simple a/b
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const parts = s.split('/');
    const p = Number(parts[0]);
    const q = Number(parts[1]);
    if(!q) return NaN;
    return p/q;
  }

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


function approxEqual(a,b,eps=1e-6){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}

function formatNumber(x){
  if(!isFinite(x)) return String(x);
  const r = Math.round(x);
  if(Math.abs(x-r)<1e-9) return String(r);
  return String(x).replace('.',',');
}

function parseAngle(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() ‚Üí Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // pi ou œÄ ‚Üí Math.PI
  s = s.replace(/œÄ|pi/gi,'Math.PI');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


/* parenth√®ses apr√®s une multiplication si le facteur est n√©gatif */
function texFactorAfterTimes(tex, numericValue){
  if(numericValue < 0){
    return '\\left('+tex+'\\right)';
  }
  return tex;
}

/* gcd pour fractions (exo 3 et PS symbolique) */
function gcd(a,b){
  a = Math.abs(Math.round(a));
  b = Math.abs(Math.round(b));
  while(b){ const t=a%b; a=b; b=t; }
  return a || 1;
}

/* conversion rad ‚Üî degr√©s */
function radToDeg(val){
  return Math.round(val*180/Math.PI);
}
function radToDegTex(val){
  const d = radToDeg(val);
  return d+'^{\\circ}';
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// ‚úÖ Vecteur en COLONNE (d√©finitif ‚Äî laisse celui-ci et SUPPRIME toute red√©finition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Angles remarquables (et oppos√©s) ‚Äî‚Äî‚Äî‚Äî‚Äî
   cos(theta) = (num/den)*sqrt(rad)   (rad = 0,2,3) */
const ANGLES = [
  { tex:'0',                  label:'0',     val:0,                num:1,  den:1, rad:0, cosTex:'1' },
  { tex:'\\dfrac{\\pi}{6}',   label:'œÄ/6',   val:Math.PI/6,        num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\dfrac{\\pi}{4}',   label:'œÄ/4',   val:Math.PI/4,        num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{\\pi}{3}',   label:'œÄ/3',   val:Math.PI/3,        num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'\\dfrac{\\pi}{2}',   label:'œÄ/2',   val:Math.PI/2,        num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'\\dfrac{2\\pi}{3}',  label:'2œÄ/3',  val:2*Math.PI/3,      num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'\\dfrac{3\\pi}{4}',  label:'3œÄ/4',  val:3*Math.PI/4,      num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{5\\pi}{6}',  label:'5œÄ/6',  val:5*Math.PI/6,      num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\pi',               label:'œÄ',     val:Math.PI,          num:-1, den:1, rad:0, cosTex:'-1' },
  { tex:'-\\dfrac{\\pi}{6}',  label:'-œÄ/6',  val:-Math.PI/6,       num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\dfrac{\\pi}{4}',  label:'-œÄ/4',  val:-Math.PI/4,       num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{\\pi}{3}',  label:'-œÄ/3',  val:-Math.PI/3,       num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'-\\dfrac{\\pi}{2}',  label:'-œÄ/2',  val:-Math.PI/2,       num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'-\\dfrac{2\\pi}{3}', label:'-2œÄ/3', val:-2*Math.PI/3,     num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'-\\dfrac{3\\pi}{4}', label:'-3œÄ/4', val:-3*Math.PI/4,     num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{5\\pi}{6}', label:'-5œÄ/6', val:-5*Math.PI/6,     num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\pi',              label:'-œÄ',    val:-Math.PI,         num:-1, den:1, rad:0, cosTex:'-1' }
];

// on ajoute la valeur num√©rique du cosinus
ANGLES.forEach(a=>{
  const base = (a.rad===0 ? 1 : Math.sqrt(a.rad));
  a.cosVal = (a.num/a.den)*base;
});

/* construit le PS sous forme symbolique : k * cos(theta)
   renvoie : texTimes (k √ó cos(...) avec parenth√®ses si cos<0),
             texFinal (forme simplifi√©e : fraction √©ventuellement √ó racine),
             val (valeur num√©rique) */
function buildPsSymbolic(k, ang){
  const cos = ang;

  // cas cos = 0
  if(cos.num === 0){
    const factorTex = texFactorAfterTimes('0', 0);
    return {
      texTimes: k+'\\times '+factorTex,
      texFinal: '0',
      val: 0
    };
  }

  const factorTex = texFactorAfterTimes(cos.cosTex, cos.cosVal);
  const timesTex = k+'\\times '+factorTex;

  let num = k * cos.num;
  let den = cos.den;
  const rad = cos.rad;

  const g = gcd(num,den);
  num /= g; den /= g;

  let coefTex;
  if(den === 1){
    coefTex = String(num);
  }else{
    coefTex = '\\dfrac{'+num+'}{'+den+'}';
  }

  let finalTex;
  if(rad === 0){
    finalTex = coefTex;
  }else{
    finalTex = coefTex+'\\sqrt{'+rad+'}';
  }

  const val = k * cos.cosVal;

  return {
    texTimes: timesTex,
    texFinal: finalTex,
    val
  };
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 1 : Th√©or√®me d'Al-Kashi ‚Äî‚Äî‚Äî‚Äî‚Äî */
const ex1 = {
  id: 'ps_al_kashi',
  title: `Th√©or√®me d'Al-Kashi dans un triangle`,

  gen(){
    // On veut que l'angle CONNU soit toujours 60, 90 ou 120 degr√©s
    const angleOptions = [
      {deg:60,  cos:  1/2},
      {deg:90,  cos:  0   },
      {deg:120, cos: -1/2}
    ];

    let AB, AC, BC;
    let angleA, angleB, angleC;
    let unknown, knownVertex;
    let angleName, angleDeg;
    let g1Name, g2Name, g1Val, g2Val;

    while(true){
      const ang = choice(angleOptions);
      angleDeg = ang.deg;
      const c = ang.cos;           // cosinus de l‚Äôangle connu

      // On choisit AU HASARD le sommet o√π l‚Äôangle est connu :
      // A ‚Üí on demandera BC ; B ‚Üí on demandera AC ; C ‚Üí on demandera AB
      knownVertex = choice(['A','B','C']);

      if (knownVertex === 'A'){
        // Angle en A connu, c√¥t√©s adjacents AB et AC choisis
        AB = rint(4,10);
        AC = rint(4,10);

        const BC2 = AB*AB + AC*AC - 2*AB*AC*c;
        if (BC2 <= 0) continue;
        const k = Math.round(Math.sqrt(BC2));
        if (k*k !== BC2) continue;

        // In√©galit√© triangulaire
        if (AB + AC <= k || AB + k <= AC || AC + k <= AB) continue;

        // On √©vite l'√©quilat√©ral avec angle 60¬∞
        if (angleDeg === 60 && AB === AC) continue;

        BC = k;

        // On pose A = angle connu, puis on calcule B par Al-Kashi, C par somme
        angleA = angleDeg;
        const cosB = (AB*AB + BC*BC - AC*AC) / (2*AB*BC);
        const B = Math.acos(Math.max(-1,Math.min(1,cosB))) * 180 / Math.PI;
        angleB = Math.round(B);
        angleC = 180 - angleA - angleB;

        unknown   = 'BC';
        g1Name    = 'AB'; g2Name = 'AC';
        g1Val     = AB;   g2Val  = AC;
        angleName = '\\widehat{BAC}';

      } else if (knownVertex === 'B'){
        // Angle en B connu, c√¥t√©s adjacents AB et BC choisis
        AB = rint(4,10);
        BC = rint(4,10);

        const AC2 = AB*AB + BC*BC - 2*AB*BC*c;
        if (AC2 <= 0) continue;
        const k = Math.round(Math.sqrt(AC2));
        if (k*k !== AC2) continue;

        if (AB + BC <= k || AB + k <= BC || BC + k <= AB) continue;
        if (angleDeg === 60 && AB === BC) continue;

        AC = k;

        angleB = angleDeg;
        const cosA = (AB*AB + AC*AC - BC*BC) / (2*AB*AC);
        const A = Math.acos(Math.max(-1,Math.min(1,cosA))) * 180 / Math.PI;
        angleA = Math.round(A);
        angleC = 180 - angleA - angleB;

        unknown   = 'AC';
        g1Name    = 'AB'; g2Name = 'BC';
        g1Val     = AB;   g2Val  = BC;
        angleName = '\\widehat{ABC}';

      } else {
        // knownVertex === 'C'
        // Angle en C connu, c√¥t√©s adjacents AC et BC choisis
        AC = rint(4,10);
        BC = rint(4,10);

        const AB2 = AC*AC + BC*BC - 2*AC*BC*c;
        if (AB2 <= 0) continue;
        const k = Math.round(Math.sqrt(AB2));
        if (k*k !== AB2) continue;

        if (AC + BC <= k || AC + k <= BC || BC + k <= AC) continue;
        if (angleDeg === 60 && AC === BC) continue;

        AB = k;

        angleC = angleDeg;
        const cosA = (AB*AB + AC*AC - BC*BC) / (2*AB*AC);
        const A = Math.acos(Math.max(-1,Math.min(1,cosA))) * 180 / Math.PI;
        angleA = Math.round(A);
        angleB = 180 - angleA - angleC;

        unknown   = 'AB';
        g1Name    = 'AC'; g2Name = 'BC';
        g1Val     = AC;   g2Val  = BC;
        angleName = '\\widehat{ACB}';
      }

      // Petit garde-fou : pas d'angle nul ou n√©gatif
      if (angleA <= 0 || angleB <= 0 || angleC <= 0) continue;

      break;
    }

    // Les deux autres angles pour la question 2
    const askedAngles = ['A','B','C'].filter(L => L !== knownVertex);

    return {
      AB, AC, BC,
      angleA, angleB, angleC,
      unknown,
      g1Name, g2Name, g1Val, g2Val,
      angleName, angleDeg,
      knownVertex,
      askedAngles
    };
  },


  render(host, st){
    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const equ    = host.querySelector('#equ');
    const inputs = host.querySelector('#inputs');

    if (lead){
      lead.innerHTML = "";
    }

    if (equ){
      equ.innerHTML = "";
    }

    if (inputs){
      const {
        g1Name, g2Name, g1Val, g2Val,
        angleName, angleDeg,
        unknown,
        askedAngles
      } = st;

      const [ang1, ang2] = askedAngles;
      const letterToTex = L=>{
        if (L === 'A') return '\\widehat{BAC}';
        if (L === 'B') return '\\widehat{ABC}';
        return '\\widehat{ACB}';
      };

      const ang1Tex = letterToTex(ang1);
      const ang2Tex = letterToTex(ang2);

      inputs.innerHTML = `
        <div style="margin-bottom:.8rem;">
          <p><strong>Exercice</strong><br>
            On consid√®re un triangle \\(ABC\\) tel que
            \\(${g1Name}=${g1Val}\\) cm, \\(${g2Name}=${g2Val}\\) cm et
            \\(${angleName}=${angleDeg}^{\\circ}.\\)<br>
          <p><strong>1)</strong>  Calculer \\(${unknown}\\).
          </p>
          <p class="pdf-hide">
            \\(${unknown} =\\)
            <input type="text" class="alk-len" style="width:90px;">
            cm
            <span class="tick nu"></span>
          </p>
        </div>

        <div style="margin-bottom:.8rem;">
          <p><strong>2)</strong>
            En utilisant le r√©sultat pr√©c√©dent, d√©terminer la mesure des angles \\(${ang1Tex}\\) et \\(${ang2Tex}\\)
            <strong>au degr√© pr√®s</strong>.
          </p>
          <p class="pdf-hide">
            \\(${ang1Tex}=\\)
            <input type="text" class="alk-ang1" style="width:90px;">
            ¬∞ <span class="tick nu"></span>
          </p>
          <p class="pdf-hide">
            \\(${ang2Tex}=\\)
            <input type="text" class="alk-ang2" style="width:90px;">
            ¬∞ <span class="tick nu"></span>
          </p>
        </div>
      `;
    }

    typesetAll(host);
  },

  correct(host, st){
    const fb    = host.querySelector('#fb');
    const inL   = host.querySelector('.alk-len');
    const in1   = host.querySelector('.alk-ang1');
    const in2   = host.querySelector('.alk-ang2');

    const side = st.unknown || 'BC';
    let lenExp;
    if (side === 'AB') lenExp = st.AB;
    else if (side === 'AC') lenExp = st.AC;
    else lenExp = st.BC;

    const [ang1, ang2] = st.askedAngles || ['B','C'];
    const angleVals = { A: st.angleA, B: st.angleB, C: st.angleC };
    const A1exp = angleVals[ang1];
    const A2exp = angleVals[ang2];

    // Si tout est vide ‚Üí pas de comptage
    const allEmpty =
      (!inL || inL.value.trim()==='') &&
      (!in1 || in1.value.trim()==='') &&
      (!in2 || in2.value.trim()==='');

    if (allEmpty){
      [inL,in1,in2].forEach(inp=>{ if(inp) setTick(inp,'nu'); });
      if (fb) fb.textContent = '';
      return { ok:0, total:0 };
    }

    let ok = 0, total = 0;

    // ‚Äî Longueur inconnue (entier, mais on tol√®re un mini √©cart) ‚Äî
    if (inL){
      const raw = inL.value.trim();
      if (raw===''){
        setTick(inL,'nu');
      }else{
        total++;
        const v = parseNumber(raw);
        if (!isNaN(v) && approxEqual(v, lenExp, 0.11)){
          setTick(inL,'ok'); ok++;
        }else{
          setTick(inL,'ko');
        }
      }
    }

    // ‚Äî Angles 1 et 2 (au degr√© pr√®s, tol√©rance ~0,6¬∞ + cas invers√©) ‚Äî
    let v1 = NaN, v2 = NaN;
    if (in1 && in1.value.trim()!==''){
      v1 = parseNumber(in1.value.trim());
    }
    if (in2 && in2.value.trim()!==''){
      v2 = parseNumber(in2.value.trim());
    }

    const has1 = !isNaN(v1);
    const has2 = !isNaN(v2);

    const eps = 0.6;
    const matchDirect =
      has1 && has2 &&
      approxEqual(v1, A1exp, eps) &&
      approxEqual(v2, A2exp, eps);

    const matchSwapped =
      has1 && has2 &&
      approxEqual(v1, A2exp, eps) &&
      approxEqual(v2, A1exp, eps);

    if (has1 || has2){
      if (has1){
        total++;
        if (matchDirect || approxEqual(v1, A1exp, eps)){
          setTick(in1,'ok'); ok++;
        } else if (matchSwapped){
          setTick(in1,'ok');
        } else {
          setTick(in1,'ko');
        }
      }else if (in1){
        setTick(in1,'nu');
      }

      if (has2){
        total++;
        if (matchDirect || approxEqual(v2, A2exp, eps)){
          setTick(in2,'ok'); ok++;
        } else if (matchSwapped){
          setTick(in2,'ok');
        } else {
          setTick(in2,'ko');
        }
      }else if (in2){
        setTick(in2,'nu');
      }
    }else{
      if (in1) setTick(in1,'nu');
      if (in2) setTick(in2,'nu');
    }

    if (fb){
      fb.innerHTML =
        `On applique le th√©or√®me d'Al-Kashi une premi√®re fois pour trouver la longueur manquante (enti√®re dans les donn√©es g√©n√©r√©es), `+
        `puis une deuxi√®me fois pour obtenir l‚Äôun des deux angles restants, et on termine avec la somme `+
        `des angles d'un triangle (\\(180^{\\circ}\\)), en arrondissant les angles au degr√© pr√®s.`;
      typesetAll(fb);
    }

    return { ok, total };
  },

 solution(host, st){
  const res = host.querySelector('#res');
  if (!res) return;

  const { AB, AC, BC, angleA, angleB, angleC, askedAngles, angleDeg } = st;

  // ‚Äî 1) C√¥t√© inconnu ‚Äî
  const unknown = st.unknown || 'BC';
  let uName, uVal, s1Name, s2Name, s1Val, s2Val, angName, angDeg;

  if (unknown === 'BC'){
    uName = 'BC'; uVal = BC;
    s1Name = 'AB'; s2Name = 'AC';
    s1Val  = AB;   s2Val  = AC;
    angName = '\\widehat{BAC}'; angDeg = angleA;
  } else if (unknown === 'AC'){
    uName = 'AC'; uVal = AC;
    s1Name = 'AB'; s2Name = 'BC';
    s1Val  = AB;   s2Val  = BC;
    angName = '\\widehat{ABC}'; angDeg = angleB;
  } else { // 'AB'
    uName = 'AB'; uVal = AB;
    s1Name = 'AC'; s2Name = 'BC';
    s1Val  = AC;   s2Val  = BC;
    angName = '\\widehat{ACB}'; angDeg = angleC;
  }

  const s1sq = s1Val * s1Val;
  const s2sq = s2Val * s2Val;
  const u2   = uVal * uVal;

  // ‚Äî 2) Angles via Al-Kashi + somme ‚Äî
  const [ang1, ang2] = askedAngles || ['B','C'];

  const angleVals = { A: angleA, B: angleB, C: angleC };
  const A1val = angleVals[ang1];
  const A2val = angleVals[ang2];

  const letterToTex = L=>{
    if (L === 'A') return '\\widehat{BAC}';
    if (L === 'B') return '\\widehat{ABC}';
    return '\\widehat{ACB}';
  };

  const ang1Tex = letterToTex(ang1);
  const ang2Tex = letterToTex(ang2);

  const allLetters = ['A','B','C'];
  const knownVertex = allLetters.find(x=> x !== ang1 && x !== ang2) || 'A';
  const knownTex = letterToTex(knownVertex);
  const knownVal = angleVals[knownVertex];

  const AB2 = AB*AB;
  const AC2 = AC*AC;
  const BC2 = BC*BC;

  // donn√©es pour l‚Äôangle ang1 (Al-Kashi)
  let oppName, o1Name, o2Name, numcos, dencos;
  let oppVal,  o1Val,  o2Val;

  if (ang1 === 'A'){
    oppName = 'BC'; o1Name = 'AB'; o2Name = 'AC';
    oppVal  = BC;   o1Val  = AB;   o2Val  = AC;
    numcos = AB2 + AC2 - BC2;
    dencos = 2 * AB * AC;
  } else if (ang1 === 'B'){
    oppName = 'AC'; o1Name = 'AB'; o2Name = 'BC';
    oppVal  = AC;   o1Val  = AB;   o2Val  = BC;
    numcos = AB2 + BC2 - AC2;
    dencos = 2 * AB * BC;
  } else { // 'C'
    oppName = 'AB'; o1Name = 'AC'; o2Name = 'BC';
    oppVal  = AB;   o1Val  = AC;   o2Val  = BC;
    numcos = AC2 + BC2 - AB2;
    dencos = 2 * AC * BC;
  }

  // fraction irr√©ductible pour cos
  const g = gcd(numcos, dencos);
  let numRed = numcos / g;
  let denRed = dencos / g;

  // gestion du signe : si numRed < 0, on met le signe devant la fraction
  let fracRedTex = '';
  if (g > 1) {
    if (numRed < 0) {
      fracRedTex = ` = -\\dfrac{${Math.abs(numRed)}}{${denRed}}`;
    } else {
      fracRedTex = ` = \\dfrac{${numRed}}{${denRed}}`;
    }
  }

  const cos1_exact = numcos / dencos;
  const cos1_num = Math.round(cos1_exact * 1000) / 1000;
  const eqCos = (Math.abs(cos1_exact - cos1_num) < 1e-10) ? '=' : '\\approx';

  const A1_exact = Math.acos(Math.max(-1, Math.min(1, cos1_exact))) * 180 / Math.PI;
  const isExact1 = (Math.abs(A1_exact - A1val) < 1e-8);
  const sym1 = isExact1 ? '=' : '\\approx';

  const A2_exact = 180 - knownVal - A1_exact;
  const isExact2 = (Math.abs(A2_exact - A2val) < 1e-8);
  const sym2 = isExact2 ? '=' : '\\approx';

  // ‚ú® Remarque Pythagore si l‚Äôangle utilis√© dans la question 1 est droit (90¬∞)
  const remarkPyth = (angleDeg === 90)
    ? `<br><span style="font-style:italic">
        Remarque&nbsp;: comme le triangle est rectangle en \\(${knownVertex}\\), on aurait aussi pu utiliser le th√©or√®me de Pythagore pour calculer \\(${uName}\\).
       </span>`
    : '';

  res.innerHTML = `
    <ol style="padding-left:1.1rem;">

      <li style="margin-bottom:.6rem;">
        Dans le triangle \\(ABC\\), on conna√Æt deux c√¥t√©s et l‚Äôangle compris entre ces deux c√¥t√©s.<br>
        On applique le th√©or√®me d'Al-Kashi :<br>
        \\(
          ${uName}^2 = ${s1Name}^2 + ${s2Name}^2 - 2\\times ${s1Name}\\times ${s2Name}\\times \\cos(${angName})
        \\)
        <br>
        \\(
          ${uName}^2
          = ${s1Val}^2 + ${s2Val}^2
            - 2\\times${s1Val}\\times${s2Val}\\times\\cos(${angDeg}^{\\circ})
        \\)<br>
        \\(
          ${uName}^2 = ${u2}\\)<br>
        \\(${uName} = ${uVal}\\) cm
        ${remarkPyth}
      </li>

      <li style="margin-bottom:.6rem;">
        On conna√Æt maintenant les trois c√¥t√©s du triangle : \\(AB=${AB}\\), \\(AC=${AC}\\) et \\(BC=${BC}\\).<br>
        On applique √† nouveau le th√©or√®me d'Al-Kashi pour l‚Äôangle \\(${ang1Tex}\\) :<br>
        \\(
          ${oppName}^2 = ${o1Name}^2 + ${o2Name}^2 - 2\\times ${o1Name}\\times ${o2Name}\\times \\cos(${ang1Tex})
        \\)
        <br>
        \\(\\cos(${ang1Tex})= \\dfrac{${o1Name}^2 + ${o2Name}^2 - ${oppName}^2}{2\\times ${o1Name}\\times ${o2Name}}\\)<br>
        \\(\\cos(${ang1Tex}) = \\dfrac{${o1Val}^2 + ${o2Val}^2 - ${oppVal}^2}{2\\times ${o1Val}\\times ${o2Val}}\\)<br>
        \\(\\cos(${ang1Tex}) = \\dfrac{${numcos}}{${dencos}}\\)<br>
        \\(\\cos(${ang1Tex})${fracRedTex}\\)<br><br>

        On en d√©duit, au degr√© pr√®s :<br>
        \\(
          ${ang1Tex} ${sym1} ${formatNumber(A1val)}^{\\circ}
        \\)<br><br>

        De plus, dans tout triangle :<br>
        \\(
          ${knownTex} + ${ang1Tex} + ${ang2Tex} = 180^{\\circ}
        \\)<br>
        On a donc :<br>
        \\(${ang2Tex}${sym2} 180^{\\circ} - ${knownTex} - ${ang1Tex}\\)<br>
        \\(${ang2Tex} ${sym2} 180^{\\circ} - ${formatNumber(knownVal)}^{\\circ} - ${formatNumber(A1val)}^{\\circ}\\)<br>
        \\( ${ang2Tex}${sym2} ${formatNumber(A2val)}^{\\circ}\\)<br>
      </li>
    </ol>
  `;
  typesetAll(res);
},


  reset(host){
    const inL = host.querySelector('.alk-len');
    const in1 = host.querySelector('.alk-ang1');
    const in2 = host.querySelector('.alk-ang2');
    [inL,in1,in2].forEach(inp=>{
      if(!inp) return;
      inp.value = '';
      setTick(inp,'nu');
    });
    const fb  = host.querySelector('#fb');
    const sol = host.querySelector('#res');
    if (fb)  fb.textContent = '';
    if (sol) sol.innerHTML  = '';
  }
};


/* ‚Äî‚Äî‚Äî‚Äî‚Äî Banque de contextes Al-Kashi "sc√©naris√©s" ‚Äî‚Äî‚Äî‚Äî‚Äî */
/*
Chaque contexte fixe :
- knownVertex : sommet o√π l‚Äôangle est connu (A, B ou C)
- unknown     : c√¥t√© oppos√© √† cet angle (celui qu‚Äôon calcule en Q1)
- lenMin,lenMax : ordre de grandeur coh√©rent pour les longueurs (en m√®tres)
- angleMin,angleMax : type d‚Äôangle r√©aliste (aigu / obtus) pour la situation
- askAngles   : liste des sommets possibles pour l‚Äôangle demand√© en Q2
- intro       : description pr√©cise de la situation
- q1Text      : question contextualis√©e pour Q1
*/
const ALKASHI_CONTEXTS = [
  {
    id:'champ_cloture',
    knownVertex:'B',
    unknown:'AC',               // distance entre deux bornes du champ
    lenMin:40, lenMax:120,      // c√¥t√© de champ de l‚Äôordre de quelques dizaines de m√®tres
    angleMin:60, angleMax:120,  // angle de coin de champ, plut√¥t ni trop aigu ni trop plat
    askAngles:['A','C'],
    intro:`Un agriculteur veut cl√¥turer un champ dont les coins sont not√©s \\(A\\), \\(B\\) et \\(C\\). 
    Deux c√¥t√©s de la cl√¥ture partent du coin \\(B\\), vers \\(A\\) et vers \\(C\\).`,
    q1Text:`Calculer la longueur de cl√¥ture entre les bornes \\(A\\) et \\(C\\), c'est-√†-dire la distance \\(AC\\).`
  },
  {
    id:'riviere_pont',
    knownVertex:'A',
    unknown:'BC',               // largeur entre deux points de rives
    lenMin:30, lenMax:150,      // distances franchissables par un pont
    angleMin:20, angleMax:80,   // deux points de rive vus depuis A, pas √† l‚Äôoppos√©
    askAngles:['B','C'],
    intro:`On √©tudie la largeur d'une rivi√®re. 
    Depuis un point d'observation \\(A\\) sur une berge, on rep√®re deux points \\(B\\) et \\(C\\) situ√©s en face sur l'autre rive.`,
    q1Text:`D√©terminer la distance qui s√©pare les deux points \\(B\\) et \\(C\\) sur l'autre rive, c'est-√†-dire la distance \\(BC\\).`
  },
  {
    id:'grimpe_falaise',
    knownVertex:'B',
    unknown:'AC',               // distance entre prises
    lenMin:5, lenMax:25,        // prises sur une m√™me voie ou deux voisines
    angleMin:30, angleMax:120,  // voies ni trop align√©es ni compl√®tement oppos√©es
    askAngles:['A','C'],
    intro:`Sur une paroi d'escalade, un assureur est plac√© au point \\(B\\) au pied de la paroi. 
    Un grimpeur peut atteindre deux prises not√©es \\(A\\) et \\(C\\) gr√¢ce √† deux voies distinctes partant de \\(B\\).`,
    q1Text:`Calculer la distance entre les deux prises \\(A\\) et \\(C\\), c'est-√†-dire la longueur \\(AC\\) sur la paroi.`
  },
  {
    id:'pylones_elec',
    knownVertex:'A',
    unknown:'BC',               // distance directe entre pyl√¥nes
    lenMin:120, lenMax:260,     // entre deux grands pyl√¥nes
    angleMin:30, angleMax:130,  // lignes partant d‚Äôun m√™me pyl√¥ne
    askAngles:['B','C'],
    intro:`Trois pyl√¥nes √©lectriques sont install√©s en \\(A\\), \\(B\\) et \\(C\\). 
    Les lignes partant de \\(A\\) rejoignent les pyl√¥nes \\(B\\) et \\(C\\).`,
    q1Text:`On souhaite conna√Ætre la distance directe entre les pyl√¥nes \\(B\\) et \\(C\\), c'est-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'camping_tentes',
    knownVertex:'A',
    unknown:'BC',               // distance entre deux tentes
    lenMin:5, lenMax:25,        // emplacements de camping
    angleMin:30, angleMax:120,
    askAngles:['B','C'],
    intro:`Dans un camping, trois tentes sont install√©es aux emplacements \\(A\\), \\(B\\) et \\(C\\). 
    Les tentes \\(B\\) et \\(C\\) sont visibles depuis \\(A\\).`,
    q1Text:`Calculer la distance entre les tentes \\(B\\) et \\(C\\), c'est-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'navigation_mer',
    knownVertex:'A',
    unknown:'BC',               // distance entre deux balises au large
    lenMin:80, lenMax:220,      // rep√®res en mer
    angleMin:20, angleMax:120,  // directions depuis le bateau
    askAngles:['B','C'],
    intro:`En mer, un bateau se trouve au point \\(A\\). 
    Il rep√®re deux balises \\(B\\) et \\(C\\) au large, sous deux directions diff√©rentes.`,
    q1Text:`Estimer la distance entre les deux balises \\(B\\) et \\(C\\), c'est-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'parc_attractions',
    knownVertex:'A',
    unknown:'BC',               // distance entre deux man√®ges
    lenMin:30, lenMax:120,      // taille d‚Äôun parc
    angleMin:40, angleMax:120,
    askAngles:['B','C'],
    intro:`Dans un parc d'attractions, l'entr√©e principale est situ√©e en \\(A\\). 
    Deux man√®ges tr√®s fr√©quent√©s sont plac√©s en \\(B\\) et \\(C\\).`,
    q1Text:`D√©terminer la distance s√©parant les deux man√®ges \\(B\\) et \\(C\\), c'est-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'topographie_colline',
    knownVertex:'C',
    unknown:'AB',               // distance entre deux points sur la cr√™te
    lenMin:50, lenMax:150,      // points de cr√™te s√©par√©s
    angleMin:30, angleMax:130,
    askAngles:['A','B'],
    intro:`Lors d'un relev√© topographique sur une colline, on place une station de mesure en \\(C\\). 
    Deux points remarquables situ√©s sur la cr√™te sont not√©s \\(A\\) et \\(B\\).`,
    q1Text:`Calculer la distance entre les points de cr√™te \\(A\\) et \\(B\\), c'est-√†-dire la longueur \\(AB\\).`
  },
  {
    id:'plage_drapeaux',
    knownVertex:'A',
    unknown:'BC',               // distance entre drapeaux
    lenMin:20, lenMax:80,       // largeur d‚Äôune zone de baignade
    angleMin:20, angleMax:80,   // deux drapeaux le long de la plage vus depuis le poste
    askAngles:['B','C'],
    intro:`Sur une plage, un poste de secours est situ√© en \\(A\\). 
    Deux drapeaux \\(B\\) et \\(C\\) d√©limitent une zone de baignade surveill√©e.`,
    q1Text:`D√©terminer la distance qui s√©pare les deux drapeaux \\(B\\) et \\(C\\), c'est-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'parc_urbain_bancs',
    knownVertex:'B',
    unknown:'AC',               // distance entre deux bancs
    lenMin:10, lenMax:30,       // bancs dans un m√™me secteur
    angleMin:40, angleMax:140,  // all√©es qui se croisent
    askAngles:['A','C'],
    intro:`Dans un parc urbain, un carrefour pi√©ton est situ√© en \\(B\\). 
    Deux bancs sont plac√©s en \\(A\\) et \\(C\\) le long de deux all√©es diff√©rentes.`,
    q1Text:`Calculer la distance entre les deux bancs \\(A\\) et \\(C\\), c'est-√†-dire la longueur \\(AC\\).`
  },
  {
    id:'eclairage_projecteurs',
    knownVertex:'C',
    unknown:'AB',
    lenMin:5, lenMax:25,        // distance entre projecteurs en salle
    angleMin:20, angleMax:90,   // faisceaux plus ou moins √©cart√©s
    askAngles:['A','B'],
    intro:`Dans une salle de spectacle, deux projecteurs sont plac√©s en \\(A\\) et \\(B\\). 
  Un r√©gisseur se tient en \\(C\\) et mesure l'angle entre les directions des deux projecteurs pour calibrer la lumi√®re.`,
    q1Text:`D√©terminer la distance s√©parant les projecteurs \\(A\\) et \\(B\\), c‚Äôest-√†-dire la longueur \\(AB\\).`
  },
  {
    id:'electricite_triangulation',
    knownVertex:'C',
    unknown:'AB',
    lenMin:120, lenMax:260,     // grandes port√©es entre pyl√¥nes
    angleMin:30, angleMax:120,
    askAngles:['A','B'],
    intro:`Dans une zone vallonn√©e, trois pyl√¥nes √©lectriques \\(A\\), \\(B\\) et \\(C\\) servent de points de triangulation pour tracer une nouvelle ligne haute tension. 
  Depuis le pyl√¥ne \\(C\\), on mesure les directions des pyl√¥nes \\(A\\) et \\(B\\).`,
    q1Text:`D√©terminer la distance qui s√©pare les pyl√¥nes \\(A\\) et \\(B\\), c‚Äôest-√†-dire la longueur \\(AB\\).`
  },
  {
    id:'billard_rebond',
    knownVertex:'A',
    unknown:'BC',
    lenMin:0.5, lenMax:2.5,     // r√©alisme billard : ~0,5 m √† ~2,5 m
    angleMin:30, angleMax:150,  // trajectoires ni colin√©aires ni trop plates
    askAngles:['B','C'],
    intro:`Sur une table de billard, un joueur place sa bille blanche en \\(A\\). 
  Il vise un point \\(B\\) sur la bande, puis la bille doit atteindre une bille rouge plac√©e en \\(C\\). 
  Les directions \\(AB\\) et \\(AC\\) forment un certain angle mesur√© par le joueur.`,
    q1Text:`D√©terminer la distance entre le point d‚Äôimpact \\(B\\) et la bille rouge \\(C\\), c‚Äôest-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'ingenierie_lampadaire',
    knownVertex:'B',
    unknown:'AC',
    lenMin:15, lenMax:40,       // bornes lumineuses d‚Äôun m√™me carrefour / zone
    angleMin:40, angleMax:120,
    askAngles:['A','C'],
    intro:`Dans un projet d‚Äôam√©nagement urbain, deux bornes lumineuses sont d√©j√† plac√©es en \\(A\\) et \\(C\\). 
  Un technicien se positionne en \\(B\\) et mesure les directions vers \\(A\\) et \\(C\\) pour d√©terminer l‚Äôemplacement exact d‚Äôun troisi√®me lampadaire.`,
    q1Text:`Calculer la distance entre les bornes \\(A\\) et \\(C\\), c‚Äôest-√†-dire la longueur \\(AC\\).`
  },
  {
    id:'drone_photographie',
    knownVertex:'A',
    unknown:'BC',
    lenMin:50, lenMax:200,      // rep√®res au sol vus depuis un drone
    angleMin:20, angleMax:120,
    askAngles:['B','C'],
    intro:`Un drone plac√© en \\(A\\) photographie deux rep√®res au sol not√©s \\(B\\) et \\(C\\). 
  Le logiciel du drone conna√Æt les distances \\(AB\\) et \\(AC\\), ainsi que l‚Äôangle entre les deux directions.`,
    q1Text:`D√©terminer la distance s√©parant les points \\(B\\) et \\(C\\), c‚Äôest-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'parcours_sportif_balises',
    knownVertex:'B',
    unknown:'AC',
    lenMin:20, lenMax:60,       // balises d‚Äôun m√™me atelier
    angleMin:40, angleMax:120,
    askAngles:['A','C'],
    intro:`Dans un parcours sportif, une balise principale est plac√©e en \\(B\\). 
  Deux autres balises \\(A\\) et \\(C\\) doivent √™tre reli√©es pour former un triangle d‚Äô√©preuve. 
  Depuis \\(B\\), on conna√Æt les longueurs \\(AB\\) et \\(BC\\) ainsi que l‚Äôangle entre ces deux segments.`,
    q1Text:`Calculer la distance entre les balises \\(A\\) et \\(C\\), c‚Äôest-√†-dire la longueur \\(AC\\).`
  },
  {
    id:'marine_phare',
    knownVertex:'C',
    unknown:'AB',
    lenMin:200, lenMax:700,     // navires suffisamment √©loign√©s
    angleMin:15, angleMax:120,
    askAngles:['A','B'],
    intro:`En mer, un officier en poste au point \\(C\\) observe deux navires \\(A\\) et \\(B\\). 
  Il conna√Æt leurs distances par rapport √† \\(C\\) et mesure l‚Äôangle entre les deux directions.`,
    q1Text:`D√©terminer la distance entre les navires \\(A\\) et \\(B\\), c‚Äôest-√†-dire la longueur \\(AB\\).`
  },
  {
    id:'autodrome_cameras',
    knownVertex:'A',
    unknown:'BC',
    lenMin:30, lenMax:120,      // virages vus depuis une cam√©ra fixe
    angleMin:15, angleMax:90,
    askAngles:['B','C'],
    intro:`Sur un autodrome, une cam√©ra haute vitesse est plac√©e en \\(A\\). 
  Deux virages \\(B\\) et \\(C\\) sont dans son champ de vision, sous un angle mesur√©.`,
    q1Text:`Calculer la distance entre les deux virages \\(B\\) et \\(C\\), c‚Äôest-√†-dire la longueur \\(BC\\).`
  },
  {
    id:'foret_cartographie',
    knownVertex:'B',
    unknown:'AC',
    lenMin:20, lenMax:70,       // arbres remarquables dans une m√™me zone
    angleMin:30, angleMax:125,
    askAngles:['A','C'],
    intro:`Lors d‚Äôun relev√© en for√™t, un g√©om√®tre se positionne en \\(B\\). 
  Il rep√®re deux arbres remarquables en \\(A\\) et \\(C\\), et mesure l‚Äôangle form√© par les directions.`,
    q1Text:`D√©terminer la distance s√©parant les deux arbres \\(A\\) et \\(C\\), c‚Äôest-√†-dire la longueur \\(AC\\).`
  },
  {
    id:'velo_parcours',
    knownVertex:'A',
    unknown:'BC',
    lenMin:10, lenMax:40,       // portions de circuit visibles
    angleMin:20, angleMax:120,
    askAngles:['B','C'],
    intro:`Un cycliste au point \\(A\\) observe deux points du circuit not√©s \\(B\\) et \\(C\\). 
  Les distances \\(AB\\) et \\(AC\\) ont √©t√© mesur√©es √† l‚Äôaide d‚Äôun t√©l√©m√®tre.`,
    q1Text:`Calculer la distance entre les deux points \\(B\\) et \\(C\\), c‚Äôest-√†-dire la longueur \\(BC\\).`
  }
];



function getAlKashiContext(id){
  return ALKASHI_CONTEXTS.find(c=>c.id===id) || ALKASHI_CONTEXTS[0];
}




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 2 : Al-Kashi en contexte, longueur + angle ‚Äî‚Äî‚Äî‚Äî‚Äî */
/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 2 : Al-Kashi en contexte, longueur + angle ‚Äî‚Äî‚Äî‚Äî‚Äî */
const ex2 = {
  id: 'ps_al_kashi_ctx',
  title: `Th√©or√®me d'Al-Kashi ‚Äì Situations concr√®tes`,

  gen(){
    const ctx = choice(ALKASHI_CONTEXTS);

    const lenMin = ctx.lenMin;
    const lenMax = ctx.lenMax;

    let AB, AC, BC;
    let angleDeg, angleA, angleB, angleC;
    let knownVertex = ctx.knownVertex;
    let unknown     = ctx.unknown;
    let angleName;

    // On choisit un angle r√©aliste pour ce contexte
    while(true){
      angleDeg = rint(ctx.angleMin, ctx.angleMax);
      const rad = angleDeg * Math.PI / 180;

      if (knownVertex === 'A'){
        AB = rint(lenMin,lenMax);
        AC = rint(lenMin,lenMax);
        BC = Math.sqrt(AB*AB + AC*AC - 2*AB*AC*Math.cos(rad));
        if(!isFinite(BC) || BC < 1) continue;
      } else if (knownVertex === 'B'){
        AB = rint(lenMin,lenMax);
        BC = rint(lenMin,lenMax);
        AC = Math.sqrt(AB*AB + BC*BC - 2*AB*BC*Math.cos(rad));
        if(!isFinite(AC) || AC < 1) continue;
      } else { // 'C'
        AC = rint(lenMin,lenMax);
        BC = rint(lenMin,lenMax);
        AB = Math.sqrt(AC*AC + BC*BC - 2*AC*BC*Math.cos(rad));
        if(!isFinite(AB) || AB < 1) continue;
      }

      // On calcule les trois angles √† partir des longueurs
      const AB2 = AB*AB, AC2 = AC*AC, BC2 = BC*BC;
      const cosA = (AB2 + AC2 - BC2)/(2*AB*AC);
      const cosB = (AB2 + BC2 - AC2)/(2*AB*BC);
      const cosC = (AC2 + BC2 - AB2)/(2*AC*BC);

      angleA = Math.acos(Math.max(-1,Math.min(1,cosA)))*180/Math.PI;
      angleB = Math.acos(Math.max(-1,Math.min(1,cosB)))*180/Math.PI;
      angleC = Math.acos(Math.max(-1,Math.min(1,cosC)))*180/Math.PI;

      if (angleA <= 0.5 || angleB <= 0.5 || angleC <= 0.5) continue;

      break;
    }

    // Nom de l'angle connu (comme exo 1)
    if (knownVertex === 'A') angleName = '\\widehat{BAC}';
    else if (knownVertex === 'B') angleName = '\\widehat{ABC}';
    else angleName = '\\widehat{ACB}';

    // Angle demand√© : un des deux autres sommets impos√©s par le contexte
    const allowed = ctx.askAngles && ctx.askAngles.length
      ? ctx.askAngles.slice()
      : ['A','B','C'].filter(L => L !== knownVertex);
    const askedVertex = choice(allowed);

    const angleVals = { A: angleA, B: angleB, C: angleC };
    const angAskedExact = angleVals[askedVertex];
    const angAskedRound = Math.round(angAskedExact);

    return {
      ctxId: ctx.id,
      AB, AC, BC,
      angleDeg,
      angleA, angleB, angleC,
      knownVertex,
      unknown,
      angleName,
      askedVertex,
      angAskedExact,
      angAskedRound
    };
  },

  render(host, st){
    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const inputs = host.querySelector('#inputs');
    const ctx    = getAlKashiContext(st.ctxId);

    const angleDeg = st.angleDeg;
    const { unknown, knownVertex } = st;

    // Conversion sommet ‚Üí notation d‚Äôangle comme dans l‚Äôexo 1
    const letterToTex = L=>{
      if (L === 'A') return '\\widehat{BAC}';
      if (L === 'B') return '\\widehat{ABC}';
      return '\\widehat{ACB}';
    };

    const angleName = letterToTex(knownVertex);
    const angAskedTex = letterToTex(st.askedVertex);

    // C√¥t√©s associ√©s √† l‚Äôangle connu pour l‚Äô√©nonc√© num√©rique
    let g1Name,g2Name,g1Val,g2Val;
    if (knownVertex === 'A'){
      g1Name='AB'; g2Name='AC'; g1Val=st.AB; g2Val=st.AC;
    }else if(knownVertex === 'B'){
      g1Name='AB'; g2Name='BC'; g1Val=st.AB; g2Val=st.BC;
    }else{
      g1Name='AC'; g2Name='BC'; g1Val=st.AC; g2Val=st.BC;
    }

    if (lead){
      lead.innerHTML = `<strong>Exercice 2 ‚Äì Situation concr√®te (th√©or√®me d'Al-Kashi)</strong>`;
    }

    if (inputs){
      inputs.innerHTML = `
        <div style="margin-bottom:.8rem;">
          <p>${ctx.intro}</p>
          <p>
            On mod√©lise la situation par un triangle \\(ABC\\) tel que :<br>
\\(${g1Name} = ${formatNumber(g1Val)}\\) m, 
\\(${g2Name} = ${formatNumber(g2Val)}\\) m et
\\(${angleName} = ${angleDeg}^{\\circ}.\\)

          </p>

          <p><strong>1)</strong> ${ctx.q1Text} Donner une valeur arrondie √† 0,01 pr√®s.</p>

          <p class="pdf-hide">
            \\(${unknown} =\\)
            <input type="text" class="alk2-len" style="width:90px;">
            m
            <span class="tick nu"></span>
          </p>

          <p><strong>2)</strong> En d√©duire la mesure de l‚Äôangle \\(${angAskedTex}\\),
          <strong>au degr√© pr√®s</strong>.</p>

          <p class="pdf-hide">
            \\(${angAskedTex} =\\)
            <input type="text" class="alk2-ang" style="width:90px;">
            ¬∞ <span class="tick nu"></span>
          </p>
        </div>
      `;
    }

    typesetAll(host);
  },

  correct(host, st){
    const fb   = host.querySelector('#fb');
    const inL  = host.querySelector('.alk2-len');
    const inA  = host.querySelector('.alk2-ang');

    const side = st.unknown || 'BC';
    let lenExact;
    if (side === 'AB') lenExact = st.AB;
    else if (side === 'AC') lenExact = st.AC;
    else lenExact = st.BC;

    const angExpected = st.angAskedRound;

    const emptyLen = !inL || inL.value.trim()==='';
    const emptyAng = !inA || inA.value.trim()==='';

    if (emptyLen && emptyAng){
      if (inL) setTick(inL,'nu');
      if (inA) setTick(inA,'nu');
      if (fb)  fb.textContent = '';
      return { ok:0, total:0 };
    }

    let ok = 0, total = 0;

    // Q1 : longueur
    if (inL){
      if (emptyLen){
        setTick(inL,'nu');
      }else{
        total++;
        const v = parseNumber(inL.value.trim());
        if (!isNaN(v) && Math.abs(v - lenExact) <= 0.5){
          setTick(inL,'ok'); ok++;
        }else{
          setTick(inL,'ko');
        }
      }
    }

    // Q2 : angle
    if (inA){
      if (emptyAng){
        setTick(inA,'nu');
      }else{
        total++;
        const v = parseNumber(inA.value.trim());
        if (!isNaN(v) && Math.abs(v - angExpected) <= 0.6){
          setTick(inA,'ok'); ok++;
        }else{
          setTick(inA,'ko');
        }
      }
    }

    if (fb){
      fb.innerHTML =
        `On applique une premi√®re fois le th√©or√®me d'Al-Kashi pour calculer le c√¥t√© manquant, `+
        `puis une deuxi√®me fois pour d√©terminer l'angle demand√© √† partir des trois c√¥t√©s, `+
        `en arrondissant la longueur √† l‚Äôunit√© pr√®s et l‚Äôangle au degr√© pr√®s.`;
      typesetAll(fb);
    }

    return { ok, total };
  },

  solution(host, st){
    const res = host.querySelector('#res');
    if (!res) return;

    const {
      AB, AC, BC,
      angleDeg,
      angleA, angleB, angleC,
      knownVertex,
      askedVertex,
      angAskedExact,
      angAskedRound
    } = st;

    const side = st.unknown || 'BC';

    const letterToTex = L=>{
      if (L === 'A') return '\\widehat{BAC}';
      if (L === 'B') return '\\widehat{ABC}';
      return '\\widehat{ACB}';
    };

    const knownTex = letterToTex(knownVertex);
    const askedTex = letterToTex(askedVertex);

    // 1) C√¥t√© inconnu
    let uName, uVal, s1Name, s2Name, s1Val, s2Val;

    if (side === 'BC'){
      uName = 'BC'; uVal = BC;
      s1Name = 'AB'; s2Name = 'AC';
      s1Val  = AB;   s2Val  = AC;
    } else if (side === 'AC'){
      uName = 'AC'; uVal = AC;
      s1Name = 'AB'; s2Name = 'BC';
      s1Val  = AB;   s2Val  = BC;
    } else { // 'AB'
      uName = 'AB'; uVal = AB;
      s1Name = 'AC'; s2Name = 'BC';
      s1Val  = AC;   s2Val  = BC;
    }

    const s1sq = s1Val * s1Val;
    const s2sq = s2Val * s2Val;

    const rad   = angleDeg * Math.PI / 180;
    const cosK  = Math.cos(rad);
    const u2    = s1sq + s2sq - 2*s1Val*s2Val*cosK;
    const u2R   = Math.round(u2*100)/100;
    const uR    = Math.round(uVal*100)/100;
    const uInt  = Math.round(uVal);

    // 2) Angle demand√© (style exo 1)
    const AB2 = AB*AB, AC2 = AC*AC, BC2 = BC*BC;

    let oppName, o1Name, o2Name, oppVal, o1Val, o2Val;
    let numcos, dencos;

    if (askedVertex === 'A'){
      oppName = 'BC'; o1Name = 'AB'; o2Name = 'AC';
      oppVal  = BC;   o1Val  = AB;   o2Val  = AC;
      numcos  = AB2 + AC2 - BC2;
      dencos  = 2*AB*AC;
    } else if (askedVertex === 'B'){
      oppName = 'AC'; o1Name = 'AB'; o2Name = 'BC';
      oppVal  = AC;   o1Val  = AB;   o2Val  = BC;
      numcos  = AB2 + BC2 - AC2;
      dencos  = 2*AB*BC;
    } else { // 'C'
      oppName = 'AB'; o1Name = 'AC'; o2Name = 'BC';
      oppVal  = AB;   o1Val  = AC;   o2Val  = BC;
      numcos  = AC2 + BC2 - AB2;
      dencos  = 2*AC*BC;
    }
const o1Valar  = Math.round(o1Val);
const o2Valar  = Math.round(o2Val);

// petit helper : arrondi √† 0,01 pr√®s
const rnd2 = x => Math.round(x * 100) / 100;

// versions "affichage" des longueurs, arrondies √† 0,01 puis pass√©es en virgule
const ABtex  = formatNumber(rnd2(AB));
const ACtex  = formatNumber(rnd2(AC));
const BCtex  = formatNumber(rnd2(BC));

const o1Tex  = formatNumber(rnd2(o1Val));
const o2Tex  = formatNumber(rnd2(o2Val));
const oppTex = formatNumber(rnd2(oppVal));


    const g = gcd(numcos, dencos);
    let numRed = numcos / g;
    let denRed = dencos / g;

    let fracRedTex = '';
    if (g > 1) {
      if (numRed < 0) {
        fracRedTex = ` = -\\dfrac{${Math.abs(numRed)}}{${denRed}}`;
      } else {
        fracRedTex = ` = \\dfrac{${numRed}}{${denRed}}`;
      }
    }

    const cosExact  = numcos / dencos;
    const cosApprox = Math.round(cosExact * 1000) / 1000;
    const eqCos     = (Math.abs(cosExact - cosApprox) < 1e-10) ? '=' : '\\approx';

    const A_exact = angAskedExact;
    const A_round = angAskedRound;
    const eqAng   = (Math.abs(A_exact - A_round) < 1e-8) ? '=' : '\\approx';

    res.innerHTML = `
      <ol style="padding-left:1.1rem;">

        <li style="margin-bottom:.6rem;">
          On mod√©lise la situation par un triangle \\(ABC\\). 
          On conna√Æt deux c√¥t√©s et l‚Äôangle compris entre ces deux c√¥t√©s.<br>
          On applique le th√©or√®me d'Al-Kashi :<br>
          \\(
            ${uName}^2 = ${s1Name}^2 + ${s2Name}^2 - 2\\times ${s1Name}\\times ${s2Name}\\times \\cos(${knownTex})
          \\)<br>
          \\(
            ${uName}^2
            = ${s1Name}^2 + ${s2Name}^2
              - 2\\times ${s1Name}\\times ${s2Name}\\times \\cos(${angleDeg}^{\\circ})
          \\)<br>
          \\(
            ${uName}^2
            = ${s1Val}^2 + ${s2Val}^2
              - 2\\times ${s1Val}\\times ${s2Val}\\times \\cos(${angleDeg}^{\\circ})
          \\)<br>
          \\(
            ${uName}^2 \\approx ${formatNumber(u2R)}
          \\)<br>
          \\(
            ${uName} \\approx ${formatNumber(uR)}\\text{ m}
          \\)<br>

 
        </li>

        <li style="margin-bottom:.6rem;">
  On conna√Æt maintenant les trois c√¥t√©s du triangle : 
\\(AB=${ABtex}\\) m, \\(AC=${ACtex}\\) m et \\(BC=${BCtex}\\) m.<br>
On applique √† nouveau le th√©or√®me d'Al-Kashi pour l‚Äôangle \\(${askedTex}\\) :<br>
          \\(
            ${oppName}^2 = ${o1Name}^2 + ${o2Name}^2
              - 2\\times ${o1Name}\\times ${o2Name}\\times \\cos(${askedTex})
          \\)<br>
          \\(
            \\cos(${askedTex}) =
            \\dfrac{${o1Name}^2 + ${o2Name}^2 - ${oppName}^2}{2\\times ${o1Name}\\times ${o2Name}}
          \\)<br>
          \\(
            \\cos(${askedTex}) =
  \\dfrac{${o1Tex}^2 + ${o2Tex}^2 - ${oppTex}^2}{2\\times ${o1Tex}\\times ${o2Tex}}
          \\)<br>
<br>

          On obtient num√©riquement :<br>
          \\(
            \\cos(${askedTex}) ${eqCos} ${formatNumber(cosApprox)}
          \\)<br><br>
          D‚Äôo√π, au degr√© pr√®s :<br>
          \\(
            ${askedTex} ${eqAng} ${A_round}^{\\circ}.
          \\)
        </li>

      </ol>
    `;
    typesetAll(res);
  },

  reset(host){
    const inL = host.querySelector('.alk2-len');
    const inA = host.querySelector('.alk2-ang');
    if (inL){
      inL.value = '';
      setTick(inL,'nu');
    }
    if (inA){
      inA.value = '';
      setTick(inA,'nu');
    }
    const fb  = host.querySelector('#fb');
    const sol = host.querySelector('#res');
    if (fb)  fb.textContent = '';
    if (sol) sol.innerHTML  = '';
  }
};




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY = [ex1,ex2];
window.REGISTRY = REGISTRY;

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1√®re ‚Äì Produit scalaire - Choisir la forme la plus adapt√©e`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");

  let st = null;

  // En mode PDF : on essaie d'abord de r√©utiliser l'√©tat d√©j√† stock√©
  if (window.__PDF_BUILDING && host.dataset.state){
    try{
      st = JSON.parse(host.dataset.state);
    }catch(_){}
  }

  // Si on n'a toujours pas d'√©tat (cas host "cach√©" pour le PDF)
  if (!st){
    // Cas particulier : exercice 2 avec s√©lecteur de figure
    if (def.id === 'geom_proj_all' && typeof def._genForMode === 'function'){
      let mode = 'mix';

      // 1) en mode normal, on lit le select ou l'ancien state
      const figSel = host.querySelector('#fig-select');
      if (!window.__PDF_BUILDING && figSel && figSel.value){
        mode = figSel.value;
      } else {
        // 2) sinon on essaie de relire un ancien state local
        try{
          const prev = host.dataset.state ? JSON.parse(host.dataset.state) : null;
          if (prev && prev.mode) mode = prev.mode;
        }catch(_){}

        // 3) si on est en PDF et qu'on n'a rien trouv√©, on prend le dernier mode global
            // 3) si on est en PDF et qu'on n'a rien trouv√©, on prend le dernier mode (localStorage)
        if (window.__PDF_BUILDING && (!mode || mode === 'mix')){
          mode = getLastGeomProjMode();
        }

      }

      st = def._genForMode(mode);
    } else {
      // Tous les autres exercices
      st = def.gen();
    }
  }

  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}




function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
