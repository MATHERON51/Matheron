<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re ‚Äì Produit scalaire - Vecteurs colin√©aires et projet√© orthogonal</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  table.pdf-tbl td.zbar{
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }

  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

  .uvtab{
    border-collapse:collapse;
    margin:.6rem 0 .8rem 0;
    font-size:0.95rem;
  }
  .uvtab td{
    border:none;
    padding:4px 32px 4px 0;
    white-space:nowrap;
    vertical-align:top;
    line-height:1.6;
  }
  @media print{
    .uvtab td{ padding:4px 40px 4px 0; }
  }

  .angle-mode-box{
    margin-bottom:.5rem;
    padding:.35rem .6rem;
    border-radius:8px;
    background:#f7f7f9;
    display:inline-flex;
    align-items:center;
    gap:.4rem;
  }
  
  /* Chapeau HTML pour l'angle dans le PDF */
.html-angle{
  display:inline-block;
  position:relative;
  padding-top:0.25em;
}
.html-angle-base{
  display:inline-block;
}
.html-angle-cap{
  position:absolute;
  left:50%;
  top:0;
  transform:translate(-50%,-65%);
  font-size:0.7em;
  line-height:1;
}

/* Parenth√®ses larges et "stretchy" autour des deux inputs */
.colvec{
  --parenW: 10px;   /* largeur parenth√®se */
  --padX:   6px;    /* marge interne gauche/droite */
  --gap:    4px;    /* √©cart entre les deux inputs */
  --inW:    54px;   /* largeur d‚Äôun input */
  --inPx:   6px;    /* padding horizontal input */
  --inPy:   4px;    /* padding vertical input */
  --inFs:   14px;   /* font-size input */

  position: relative;
  display: inline-grid;
  grid-template-rows: auto auto;
  row-gap: var(--gap);
  padding: 6px calc(var(--padX) + var(--parenW));
  vertical-align: middle;
}
.colvec input{
  width: var(--inW);
  text-align: center;
  padding: var(--inPy) var(--inPx);
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: var(--inFs);
}
.colvec::before,
.colvec::after{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  width: var(--parenW);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: .95;
}
.colvec::before{
  left: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}
.colvec::after{
  right: 0; transform: scaleX(-1);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}

/* Version compacte */
.colvec.sm {
  --parenW: 9px;
  --padX: 6px;
  --gap: 4px;
  --inW: 48px;
  --inPy: 3px;
  --inFs: 13px;
}

  
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1√®re ‚Äì Produit scalaire - Expression analytique avec coordonn√©es</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les produits scalaires et les longueurs : r√©pondre avec un nombre r√©el (entier, d√©cimal avec virgule ou fraction du type <code>a/b</code>).</li>
        <li>Pour les angles :
          <ul>
            <li>si l‚Äôunit√© choisie est <strong>Radian</strong> : r√©pondre en radians, par exemple <code>pi/3</code> ou <code>œÄ/3</code> ; pour l‚Äôexercice&nbsp;3, donner une valeur approch√©e au centi√®me pr√®s ;</li>
            <li>si l‚Äôunit√© choisie est <strong>Degr√©</strong> : r√©pondre en degr√©s (par exemple <code>60</code>) ; pour l‚Äôexercice&nbsp;3, donner une valeur approch√©e au <strong>degr√© pr√®s</strong>.</li>
          </ul>
        </li>
        <li>Le signe ¬´ ‚àí ¬ª peut √™tre saisi avec le tiret du clavier ; les espaces sont ignor√©s.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $ = (s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';

function cleanSigns(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/\u2212/g, '-');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className='tick '+state;
}

function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}

const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

// Unit√© d'angle globale pour toute la page (et pour le PDF)
let ANGLE_MODE = 'rad';

function getAngleMode(){
  return ANGLE_MODE;
}
function setAngleMode(mode){
  ANGLE_MODE = mode || 'rad';
}


/* parseurs & format */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() ‚Üí Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  // fraction simple a/b
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const parts = s.split('/');
    const p = Number(parts[0]);
    const q = Number(parts[1]);
    if(!q) return NaN;
    return p/q;
  }

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


function approxEqual(a,b,eps=1e-6){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}

function formatNumber(x){
  if(!isFinite(x)) return String(x);
  const r = Math.round(x);
  if(Math.abs(x-r)<1e-9) return String(r);
  return String(x).replace('.',',');
}

function parseAngle(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;

  // normalisation signe et virgule
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');

  // rac() ‚Üí Math.sqrt()
  s = s.replace(/rac\s*\(/gi, 'Math.sqrt(');

  // pi ou œÄ ‚Üí Math.PI
  s = s.replace(/œÄ|pi/gi,'Math.PI');

  // --- Multiplication implicite ---
  s = s
    .replace(/(\d)\s*(?=(Math\.sqrt|Math\.PI|\())/g, '$1*')
    .replace(/\)\s*(?=(\d|Math\.sqrt|Math\.PI|\())/g, ')*')
    .replace(/Math\.PI\s*(?=(\d|Math\.sqrt|\())/g, 'Math.PI*');

  try{
    return Function('"use strict";return('+s+')')();
  }catch(e){
    return NaN;
  }
}


/* parenth√®ses apr√®s une multiplication si le facteur est n√©gatif */
function texFactorAfterTimes(tex, numericValue){
  if(numericValue < 0){
    return '\\left('+tex+'\\right)';
  }
  return tex;
}

/* gcd pour fractions (exo 3 et PS symbolique) */
function gcd(a,b){
  a = Math.abs(Math.round(a));
  b = Math.abs(Math.round(b));
  while(b){ const t=a%b; a=b; b=t; }
  return a || 1;
}

/* conversion rad ‚Üî degr√©s */
function radToDeg(val){
  return Math.round(val*180/Math.PI);
}
function radToDegTex(val){
  const d = radToDeg(val);
  return d+'^{\\circ}';
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// ‚úÖ Vecteur en COLONNE (d√©finitif ‚Äî laisse celui-ci et SUPPRIME toute red√©finition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\\\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Angles remarquables (et oppos√©s) ‚Äî‚Äî‚Äî‚Äî‚Äî
   cos(theta) = (num/den)*sqrt(rad)   (rad = 0,2,3) */
const ANGLES = [
  { tex:'0',                  label:'0',     val:0,                num:1,  den:1, rad:0, cosTex:'1' },
  { tex:'\\dfrac{\\pi}{6}',   label:'œÄ/6',   val:Math.PI/6,        num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\dfrac{\\pi}{4}',   label:'œÄ/4',   val:Math.PI/4,        num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{\\pi}{3}',   label:'œÄ/3',   val:Math.PI/3,        num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'\\dfrac{\\pi}{2}',   label:'œÄ/2',   val:Math.PI/2,        num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'\\dfrac{2\\pi}{3}',  label:'2œÄ/3',  val:2*Math.PI/3,      num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'\\dfrac{3\\pi}{4}',  label:'3œÄ/4',  val:3*Math.PI/4,      num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'\\dfrac{5\\pi}{6}',  label:'5œÄ/6',  val:5*Math.PI/6,      num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'\\pi',               label:'œÄ',     val:Math.PI,          num:-1, den:1, rad:0, cosTex:'-1' },
  { tex:'-\\dfrac{\\pi}{6}',  label:'-œÄ/6',  val:-Math.PI/6,       num:1,  den:2, rad:3, cosTex:'\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\dfrac{\\pi}{4}',  label:'-œÄ/4',  val:-Math.PI/4,       num:1,  den:2, rad:2, cosTex:'\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{\\pi}{3}',  label:'-œÄ/3',  val:-Math.PI/3,       num:1,  den:2, rad:0, cosTex:'\\dfrac{1}{2}' },
  { tex:'-\\dfrac{\\pi}{2}',  label:'-œÄ/2',  val:-Math.PI/2,       num:0,  den:1, rad:0, cosTex:'0' },
  { tex:'-\\dfrac{2\\pi}{3}', label:'-2œÄ/3', val:-2*Math.PI/3,     num:-1, den:2, rad:0, cosTex:'-\\dfrac{1}{2}' },
  { tex:'-\\dfrac{3\\pi}{4}', label:'-3œÄ/4', val:-3*Math.PI/4,     num:-1, den:2, rad:2, cosTex:'-\\dfrac{\\sqrt{2}}{2}' },
  { tex:'-\\dfrac{5\\pi}{6}', label:'-5œÄ/6', val:-5*Math.PI/6,     num:-1, den:2, rad:3, cosTex:'-\\dfrac{\\sqrt{3}}{2}' },
  { tex:'-\\pi',              label:'-œÄ',    val:-Math.PI,         num:-1, den:1, rad:0, cosTex:'-1' }
];

// on ajoute la valeur num√©rique du cosinus
ANGLES.forEach(a=>{
  const base = (a.rad===0 ? 1 : Math.sqrt(a.rad));
  a.cosVal = (a.num/a.den)*base;
});

/* construit le PS sous forme symbolique : k * cos(theta)
   renvoie : texTimes (k √ó cos(...) avec parenth√®ses si cos<0),
             texFinal (forme simplifi√©e : fraction √©ventuellement √ó racine),
             val (valeur num√©rique) */
function buildPsSymbolic(k, ang){
  const cos = ang;

  // cas cos = 0
  if(cos.num === 0){
    const factorTex = texFactorAfterTimes('0', 0);
    return {
      texTimes: k+'\\times '+factorTex,
      texFinal: '0',
      val: 0
    };
  }

  const factorTex = texFactorAfterTimes(cos.cosTex, cos.cosVal);
  const timesTex = k+'\\times '+factorTex;

  let num = k * cos.num;
  let den = cos.den;
  const rad = cos.rad;

  const g = gcd(num,den);
  num /= g; den /= g;

  let coefTex;
  if(den === 1){
    coefTex = String(num);
  }else{
    coefTex = '\\dfrac{'+num+'}{'+den+'}';
  }

  let finalTex;
  if(rad === 0){
    finalTex = coefTex;
  }else{
    finalTex = coefTex+'\\sqrt{'+rad+'}';
  }

  const val = k * cos.cosVal;

  return {
    texTimes: timesTex,
    texFinal: finalTex,
    val
  };
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }


/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 1 : Produit scalaire et projet√©s orthogonaux dans un rectangle ‚Äî‚Äî‚Äî‚Äî‚Äî */
/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 1 : Produit scalaire et projet√©s orthogonaux dans un rectangle ‚Äî‚Äî‚Äî‚Äî‚Äî */
const ex1 = {
  id: 'geom_proj_rect',
  title: `Produit scalaire ‚Äì Projections orthogonales dans un rectangle`,

  gen(){
    // on choisit des longueurs simples
    const AB = randInt(4,7);   // cot√© horizontal
    const AD = randInt(2,5);   // cot√© vertical

    // liste des questions avec id + √©criture latex
    const questions = [
      {id:'ps_ab_cd', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CD}'},
      {id:'ps_ab_ad', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AD}'},
      {id:'ps_ab_ac', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}'},
      {id:'ps_cb_ca', tex:'\\overrightarrow{CB}\\cdot\\overrightarrow{CA}'},
      {id:'ps_da_ac', tex:'\\overrightarrow{DA}\\cdot\\overrightarrow{AC}'},
      {id:'ps_ab_od', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{OD}'},
      {id:'ps_do_cb', tex:'\\overrightarrow{DO}\\cdot\\overrightarrow{CB}'},
    ];

    // m√©lange al√©atoire
    const qs = questions.slice();
    for(let i = qs.length - 1; i > 0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [qs[i], qs[j]] = [qs[j], qs[i]];
    }

    return {AB, AD, questions: qs};
  },

  render(host, st){
    const {AB, AD} = st;
    const questions = st.questions || [
      {id:'ps_ab_cd', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CD}'},
      {id:'ps_ab_ad', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AD}'},
      {id:'ps_ab_ac', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}'},
      {id:'ps_cb_ca', tex:'\\overrightarrow{CB}\\cdot\\overrightarrow{CA}'},
      {id:'ps_da_ac', tex:'\\overrightarrow{DA}\\cdot\\overrightarrow{AC}'},
      {id:'ps_ab_od', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{OD}'},
      {id:'ps_do_cb', tex:'\\overrightarrow{DO}\\cdot\\overrightarrow{CB}'},
    ];

    function svgRect(){
      return `
<svg viewBox="0 0 260 130" width="260" height="130">
  <!-- rectangle -->
  <polygon points="30,25 230,25 230,105 30,105"
           fill="#f7f3ef" stroke="#000" stroke-width="1.5"/>

  <!-- diagonales -->
  <line x1="30"  y1="25"  x2="230" y2="105" stroke="#000" stroke-width="1"/>
  <line x1="30"  y1="105" x2="230" y2="25"  stroke="#000" stroke-width="1"/>

  <!-- milieux I et J -->
  <circle cx="130" cy="25"  r="3" fill="#000"/>
  <circle cx="230" cy="65"  r="3" fill="#000"/>

  <!-- centre O -->
  <circle cx="130" cy="65" r="3" fill="#000"/>

  <!-- sommets -->
  <circle cx="30"  cy="25"  r="3" fill="#000"/>
  <circle cx="230" cy="25"  r="3" fill="#000"/>
  <circle cx="230" cy="105" r="3" fill="#000"/>
  <circle cx="30"  cy="105" r="3" fill="#000"/>

  <!-- lettres √† l‚Äôext√©rieur -->
  <text x="22"  y="20"  font-size="12">A</text>
  <text x="232" y="20"  font-size="12">B</text>
  <text x="232" y="118" font-size="12">C</text>
  <text x="22"  y="118" font-size="12">D</text>
  <text x="132" y="20"  font-size="12">I</text>
  <text x="236" y="68"  font-size="12">J</text>
  <text x="134" y="62"  font-size="12">O</text>
</svg>`;
    }

    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const equ    = host.querySelector('#equ');
    const inputs = host.querySelector('#inputs');

    if(lead){
      lead.innerHTML = "";
    }

    if(equ){
      equ.innerHTML = `
        <p><strong>Exercice 1 :</strong></p>
        <p>
          On consid√®re un rectangle \\(ABCD\\) de centre \\(O\\) tel que
          \\(AB = ${AB}\\) et \\(AD = ${AD}\\).
        </p>
        <div  style="margin-top:.4rem; text-align:center;">
          ${svgRect()}
        </div>
        <p>
          Sur la figure, \\(I\\) est le milieu de \\([AB]\\) et
          \\(J\\) est le milieu de \\([CB]\\).
        </p>
      `;
    }

    if(inputs){
      inputs.innerHTML = `
        <p>Calculer les produits scalaires suivants&nbsp;:</p>
        <table style="border-collapse:collapse; margin-top:4px;">
          ${questions.map((q,i)=>`
            <tr>
              <td style="padding:4px 10px 4px 0;"><strong>${i+1})</strong></td>
              <td style="padding:4px 10px 4px 0;">\\(${q.tex}=\\)</td>
              <td style="padding:4px 6px;">
                <input type="text" class="ps-rect" data-id="${q.id}"
                       inputmode="decimal" autocomplete="off" style="width:80px;">
                <span class="tick nu"></span>
              </td>
            </tr>
          `).join('')}
        </table>
      `;
    }

    typesetAll(host);
  },

  correct(host, st){
    const {AB, AD} = st;
    const AB2 = AB*AB;
    const AD2 = AD*AD;

    // valeurs attendues (l‚Äôordre n‚Äôa pas d‚Äôimportance ici)
    const expected = {
      ps_ab_cd: -AB2,          // colin√©aires de sens oppos√©s
      ps_ab_ad: 0,             // angle droit en A
      ps_ab_ac:  AB2,          // B projet√© orthogonal de C sur (AB)
      ps_cb_ca:  AD2,          // B projet√© orthogonal de A sur (CB)
      ps_da_ac: -AD2,          // D projet√© orthogonal de C sur (AD)
      ps_ab_od: -AB2/2,        // projection de O sur (AB) via I
      ps_do_cb:  AD2/2         // projection de O sur (CB) via J
    };

    const inputs = host.querySelectorAll('.ps-rect');
    const fb     = host.querySelector('#fb');

    // tout vide ‚Üí neutre
    let anyFilled = false;
    inputs.forEach(inp=>{
      if (inp.value.trim() !== '') anyFilled = true;
    });

    if(!anyFilled){
      inputs.forEach(inp=>setTick(inp,'nu'));
      if(fb) fb.textContent = '';
      return {ok:0,total:0};
    }

    let ok = 0, total = 0;

    inputs.forEach(inp=>{
      const id = inp.dataset.id;
      if(!expected.hasOwnProperty(id)) return;

      const raw = inp.value.trim();

      // case vide ‚Üí neutre, pas compt√©e
      if(raw === ''){
        setTick(inp,'nu');
        return;
      }

      total++;
      const v = parseNumber(raw);
      if(!isNaN(v) && approxEqual(v, expected[id], 1e-6)){
        setTick(inp,'ok');
        ok++;
      }else{
        setTick(inp,'ko');
      }
    });

    if(fb){
      fb.innerHTML =
        "On utilise :<br>‚Ä¢ produit scalaire nul si les vecteurs sont perpendiculaires ;" +
        "<br>‚Ä¢ produit scalaire √©gal √† \\(\\pm\\|u\\|\\times\\|v\\|\\) si les vecteurs sont colin√©aires ;" +
        "<br>‚Ä¢ l‚Äô√©galit√© de vecteurs obtenue gr√¢ce √† des projet√©s orthogonaux.";
      if(window.MathJax?.typesetPromise) MathJax.typesetPromise([fb]);
    }

    return {ok,total};
  },

  solution(host, st){
    const {AB, AD} = st;
    const questions = st.questions || [];
    const AB2  = AB*AB;
    const AD2  = AD*AD;
    const AB2h = AB2/2;
    const AD2h = AD2/2;

    const AB2hDec = formatNumber(AB2h);
    const AD2hDec = formatNumber(AD2h);

    const res = host.querySelector('#res');
    if(!res) return;

    // petite fonction qui donne la r√©daction pour UNE question
    function expFor(id){
      if(id === 'ps_ab_cd'){
        return `
          \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{CD}\\) sont
          colin√©aires de sens oppos√©s, donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{CD}
            = -AB\\times CD
            = -${AB}\\times${AB}
            = -${AB2}.
          \\]`;
      }
      if(id === 'ps_ab_ad'){
        return `
          \\(ABCD\\) est un rectangle, donc l‚Äôangle en \\(A\\) est droit.
          On a alors :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AD} = 0.
          \\]`;
      }
      if(id === 'ps_ab_ac'){
        return `
          Le point \\(B\\) est le projet√© orthogonal de \\(C\\) sur la droite \\((AB)\\),
          donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AB}\\cdot\\overrightarrow{AB}
            = AB^2 = ${AB2}.
          \\]`;
      }
      if(id === 'ps_cb_ca'){
        return `
          Le point \\(B\\) est le projet√© orthogonal de \\(A\\) sur la droite \\((CB)\\),
          et \\(CB = AD\\).
          On a donc :
          \\[
            \\overrightarrow{CB}\\cdot\\overrightarrow{CA}
            = \\overrightarrow{CB}\\cdot\\overrightarrow{CB}
            = CB^2 = AD^2 = ${AD2}.
          \\]`;
      }
      if(id === 'ps_da_ac'){
        return `
          Le point \\(D\\) est le projet√© orthogonal de \\(C\\) sur la droite \\((AD)\\),
          donc :
          \\[
            \\overrightarrow{DA}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{DA}\\cdot\\overrightarrow{AD}
            = -DA\\times DA
            = -DA^2 = -${AD2},
          \\]
          car \\(\\overrightarrow{DA}\\) et \\(\\overrightarrow{AD}\\) sont colin√©aires
          de sens oppos√©s.`;
      }
      if(id === 'ps_ab_od'){
        return `
          Le point \\(I\\) est le milieu de \\([AB]\\); sur la figure, \\(I\\) est
          le projet√© orthogonal de \\(O\\) sur \\((AB)\\) et
          \\(D\\) est le projet√© orthogonal de \\(A\\) sur \\((AB)\\). On a :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{OD}
            = \\overrightarrow{AB}\\cdot\\overrightarrow{IA}
            = \\overrightarrow{AB}\\cdot\\left(-\\dfrac12\\overrightarrow{AB}\\right)
            = -\\dfrac12 AB^2
            = -\\dfrac{${AB2}}{2}
            = -${AB2hDec}.
          \\]`;
      }
      if(id === 'ps_do_cb'){
        return `
          Le point \\(J\\) est le milieu de \\([CB]\\); sur la figure, \\(D\\) est
          le projet√© orthogonal de \\(C\\) sur \\((AD)\\) et
          \\(J\\) est le projet√© orthogonal de \\(O\\) sur \\((CB)\\).
          On obtient :
          \\[
            \\overrightarrow{DO}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{CJ}\\cdot\\overrightarrow{CB}
            = \\dfrac12\\overrightarrow{CB}\\cdot\\overrightarrow{CB}
            = \\dfrac12 CB^2
            = \\dfrac{${AD2}}{2}
            = ${AD2hDec}.
          \\]`;
      }
      return '';
    }

    // construction : liste 1), 2), 3)‚Ä¶ dans L‚ÄôORDRE des questions pos√©es
    let html = "";
    html += '<ol style="padding-left:0; list-style:none;">';

    questions.forEach((q, i)=>{
      html += `
        <li style="margin-bottom:.4rem;">
          <strong>${i+1})</strong> ${expFor(q.id)}
        </li>
      `;
    });

    html += '</ol>';

    res.innerHTML = html;
    typesetAll(res);
  },

  reset(host){
    const inputs = host.querySelectorAll('.ps-rect');
    inputs.forEach(inp=>{
      inp.value = '';
      setTick(inp,'nu');
    });
    const fb  = host.querySelector('#fb');
    const res = host.querySelector('#res');
    if(fb) fb.textContent = '';
    if(res) res.innerHTML = '';
  }
};


/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 2 : Projections orthogonales avec toutes les figures ‚Äî‚Äî‚Äî‚Äî‚Äî */
const ex2 = {
  id: 'geom_proj_all',
  title: `Produit scalaire ‚Äì Projections orthogonales (choix de figure)`,

  _kindsAll: ['rect','trap','carre','los','tri_rect','tri_alt'],

  _genForMode(mode){
    // m√©morise le dernier mode choisi (pour √©cran + PDF)
    mode = mode || getLastGeomProjMode();
    setLastGeomProjMode(mode);

    let kind;
    if(mode === 'mix'){

      kind = this._kindsAll[Math.floor(Math.random()*this._kindsAll.length)];
    }else{
      kind = mode;
    }

    let data = {};
    let questions = [];
    let expected = {};

    /* =========================================================
       1) RECTANGLE ABCD, centre O, milieux I et J  (comme exo 2)
       ========================================================= */
    if(kind === 'rect'){
      const AB = randInt(4,7);
      const AD = randInt(2,5);

      data = { kind, mode, AB, AD };

      questions = [
        // 1 nul (angle droit en A)
        { id:'ps_ab_ad', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AD}' },

        // 1 colin√©arit√© sens oppos√©s (bases)
        { id:'ps_ab_cd', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CD}' },

        // 3 par projet√©s orthogonaux (comme ton exo 2)
        { id:'ps_ab_ac', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}' },
        { id:'ps_cb_ca', tex:'\\overrightarrow{CB}\\cdot\\overrightarrow{AC}' },
        { id:'ps_do_cb', tex:'\\overrightarrow{DO}\\cdot\\overrightarrow{CB}' },
      ];

      expected = {
        ps_ab_ad:  0,               // angle droit en A
        ps_ab_cd: -AB*AB,           // AB // CD, sens oppos√©s
        ps_ab_ac:  AB*AB,           // C projet√© orthogonal de C sur (AB) ‚Üí B
        ps_cb_ca:  -AD*AD,           // A projet√© orthogonal de A sur (CB) ‚Üí B
        ps_do_cb:  (AD*AD)/2        // O projet√© sur (CB) en J, CJ = AD/2
      };
    }

    /* =========================================================
       2) TRAP√àZE RECTANGLE ABCD, bases AB // CD,
          AD ‚üÇ AB et AD ‚üÇ CD
       ========================================================= */
    else if(kind === 'trap'){
      // AB > CD pour un trap√®ze rectangle
      const CD = randInt(3,7);
      const AB = CD + randInt(2,5);
      const AD = randInt(2,6);

      data = { kind, mode, AB, CD, AD };

      questions = [
        // 1 nul (angle droit en A)
        { id:'ps_ab_ad', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AD}' },

        // 1 colin√©arit√© sens oppos√©s (AB // CD)
        { id:'ps_ab_cd', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CD}' },

        // 3 via projet√©s orthogonaux
        // H : projet√© orthogonal de C sur (AB)
        { id:'ps_ab_ac', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}' },

        // D : projet√© orthogonal de C sur (AD)
        { id:'ps_ad_ac', tex:'\\overrightarrow{AD}\\cdot\\overrightarrow{AC}' },

        // M : projet√© orthogonal de B sur (CD)
        { id:'ps_cd_cb', tex:'\\overrightarrow{CD}\\cdot\\overrightarrow{CB}' },
      ];

      expected = {
        ps_ab_ad: 0,                 // angle droit en A
        ps_ab_cd: -AB*CD,            // AB // CD, sens oppos√©s

        // Projection de C sur (AB) : AH = CD
        // ‚Üí AB¬∑AC = AB¬∑AH = AB√óCD
        ps_ab_ac: AB*CD,

        // Projection de C sur (AD) : AK = AD
        // ‚Üí AD¬∑AC = AD¬∑AD = AD¬≤
        ps_ad_ac: AD*AD,

        // Projection de B sur (CD) : CM = AB ‚àí CD
        // ‚Üí CD¬∑CB = CD¬∑CM = -CD√ó(AB‚àíCD) (sens oppos√©s)
        ps_cd_cb: -CD*(AB-CD),
      };
    }

    /* =========================================================
       3) CARR√â ABCD, centre O
       ========================================================= */
    else if(kind === 'carre'){
      // c√¥t√© pair pour que a¬≤/2 soit entier
      const k  = randInt(1,4);
      const a  = 2*k;

      data = { kind, mode, a };

      questions = [
        // 1 nul (angle droit au sommet A)
        { id:'ps_ab_ad',  tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AD}' },

        // 1 colin√©arit√© sens oppos√©s (AB // DC)
        { id:'ps_ab_dc',  tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{DC}' },

        // 3 via projet√©s
        // H projet√© de C sur (AB)
        { id:'ps_ab_ac',  tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}' },

        // K projet√© de A sur (CB)
        { id:'ps_cb_ca',  tex:'\\overrightarrow{BC}\\cdot\\overrightarrow{CA}' },

        // L projet√© de O sur (CB)
        { id:'ps_co_cb',  tex:'\\overrightarrow{CO}\\cdot\\overrightarrow{CB}' },
      ];

      expected = {
        ps_ab_ad: 0,            // angle droit en A
        ps_ab_dc: -a*a,         // AB // DC, sens oppos√©s

        // H projet√© orthogonal de C sur (AB) : AH = AB
        // ‚Üí AB¬∑AC = AB¬∑AB = a¬≤
        ps_ab_ac: a*a,

        // K projet√© orthogonal de A sur (CB) : CK = CB
        // ‚Üí CB¬∑CA = CB¬∑CB = a¬≤
        ps_cb_ca: -a*a,

        // L projet√© orthogonal de O sur (CB) : CL = a/2
        // ‚Üí CO¬∑CB = CL¬∑CB = (a/2)√óa = a¬≤/2
        ps_co_cb: (a*a)/2
      };
    }

    /* =========================================================
       4) LOSANGE ABCD, diagonales perpendiculaires, centre O
          On choisit une configuration type (diagonales 6m et 8m)
       ========================================================= */
       else if(kind === 'los'){
      // diagonales 6m et 8m ‚áí c√¥t√© = 5m (12-16-10 pour m=2, etc.)
      const m   = randInt(1,3);
      const d1  = 6*m;   // AC
      const d2  = 8*m;   // BD
      const a   = 5*m;   // c√¥t√©

      data = { kind, mode, m, d1, d2, a };

      questions = [
        // 1 produit scalaire nul : diagonales perpendiculaires
        { id:'ps_ac_bd', tex:'\\overrightarrow{AC}\\cdot\\overrightarrow{BD}' },

        // 1 produit scalaire par colin√©arit√© sens oppos√©s (AB // CD)
        { id:'ps_ab_cd', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CD}' },

        // 3 produits scalaires obtenus par projet√©s orthogonaux sur les diagonales
        // (le projet√© orthogonal de B et D sur (AC) est O, idem pour C sur (BD))
        { id:'ps_ab_ac', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}' },
        { id:'ps_bc_bd', tex:'\\overrightarrow{BC}\\cdot\\overrightarrow{BD}' },
        { id:'ps_ad_ac', tex:'\\overrightarrow{DA}\\cdot\\overrightarrow{AC}' },
      ];

      const AC = d1;
      const BD = d2;
      const side = a;

      expected = {
        // diagonales perpendiculaires
        ps_ac_bd: 0,

        // c√¥t√©s oppos√©s colin√©aires de sens oppos√©s
        ps_ab_cd: -side*side,        // = -a^2

        // B est sur (BD) et O est l'intersection de (AC) et (BD).
        // Comme (BD) ‚üÇ (AC), O est le projet√© orthogonal de B sur (AC).
        // On a AO = AC/2, donc AB¬∑AC = AO¬∑AC = (AC/2)√óAC = AC^2/2.
        ps_ab_ac: (AC*AC)/2,

        // De m√™me, O est le projet√© orthogonal de C sur (BD),
        // donc BC¬∑BD = BO¬∑BD = (BD/2)√óBD = BD^2/2.
        ps_bc_bd: (BD*BD)/2,

        // O est aussi le projet√© orthogonal de D sur (AC),
        // donc AD¬∑AC = AO¬∑AC = AC^2/2.
        ps_ad_ac: -(AC*AC)/2
      };
    }


    /* =========================================================
       5) TRIANGLE RECTANGLE ABC, rectangle en A,
          hauteur issue de A sur [BC], H projet√© orthogonal
       ========================================================= */
    else if(kind === 'tri_rect'){
      const BH = randInt(2,7);
      const HC = randInt(2,7);
      const BC = BH + HC;
      const AH = randInt(3,8);

      data = { kind, mode, BC, BH, HC, AH };

      questions = [
        // 1 nul : angle droit en A
        { id:'ps_ab_ac', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{AC}' },

        // 1 colin√©arit√© sens oppos√©s (BC // CB)
        { id:'ps_bc_cb', tex:'\\overrightarrow{BC}\\cdot\\overrightarrow{CB}' },

        // 3 via projet√©s (exactement comme le triangle quelconque, mais ici le tri est rectangle)
        // H projet√© orthogonal de A sur (BC)
        { id:'ps_ab_bc', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{BC}' },
        { id:'ps_ca_cb', tex:'\\overrightarrow{CA}\\cdot\\overrightarrow{CB}' },
        { id:'ps_ab_cb', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CB}' },
      ];

      expected = {
        // angle droit en A
        ps_ab_ac: 0,

        // BC et CB colin√©aires de sens oppos√©s
        ps_bc_cb: -BC*BC,

        // H projet√© orthogonal de A sur (BC) :
        // AB¬∑BC = HB¬∑BC = BH√óBC
        ps_ab_bc: -BH*BC,

        // CA¬∑CB = CH¬∑CB = HC√óBC
        ps_ca_cb: HC*BC,

        // AB¬∑CB = (-HB)¬∑CB = -BH√óBC
        ps_ab_cb: BH*BC
      };
    }

    /* =========================================================
       6) TRIANGLE QUELCONQUE ABC, hauteur AH sur [BC]
       ========================================================= */
    else if(kind === 'tri_alt'){
      const BC = randInt(8,16);
      const BH = randInt(2, BC-3);
      const HC = BC - BH;
      const AH = randInt(3,8);

      data = { kind, mode, BC, BH, HC, AH };

      questions = [
        // 1 nul (AH ‚üÇ BC)
        { id:'ps_ah_bc', tex:'\\overrightarrow{AH}\\cdot\\overrightarrow{BC}' },

        // 1 colin√©arit√© sens oppos√©s (BC // CB)
        { id:'ps_bc_cb', tex:'\\overrightarrow{BC}\\cdot\\overrightarrow{CB}' },

        // 3 via projet√© orthogonal de A sur (BC)
        { id:'ps_ab_bc', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{BC}' },
        { id:'ps_ca_cb', tex:'\\overrightarrow{CA}\\cdot\\overrightarrow{CB}' },
        { id:'ps_ab_cb', tex:'\\overrightarrow{AB}\\cdot\\overrightarrow{CB}' },
      ];

      expected = {
        ps_ah_bc: 0,                     // AH ‚üÇ BC
        ps_bc_cb: -BC*BC,                // BC // CB, sens oppos√©s

        // AB¬∑BC = HB¬∑BC = BH√óBC
        ps_ab_bc: -BH*BC,

        // CA¬∑CB = CH¬∑CB = HC√óBC
        ps_ca_cb: HC*BC,

        // AB¬∑CB = (-HB)¬∑CB = -BH√óBC
        ps_ab_cb: BH*BC
      };
    }

    // M√©lange al√©atoire de l‚Äôordre des questions
    const questionsShuffled = questions.slice();
    for (let i = questionsShuffled.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [questionsShuffled[i], questionsShuffled[j]] = [questionsShuffled[j], questionsShuffled[i]];
    }

    // CONTRAINTE : pour les triangles, il faut AB¬∑BC avant AB¬∑CB
    if (kind === 'tri_rect' || kind === 'tri_alt'){
      const idABBC = 'ps_ab_bc';
      const idABCB = 'ps_ab_cb';

      let idxABBC = -1;
      let idxABCB = -1;

      for (let i = 0; i < questionsShuffled.length; i++){
        if (questionsShuffled[i].id === idABBC) idxABBC = i;
        if (questionsShuffled[i].id === idABCB) idxABCB = i;
      }

      // si AB¬∑BC est apr√®s AB¬∑CB, on les √©change
      if (idxABBC !== -1 && idxABCB !== -1 && idxABBC > idxABCB){
        const tmp = questionsShuffled[idxABBC];
        questionsShuffled[idxABBC] = questionsShuffled[idxABCB];
        questionsShuffled[idxABCB] = tmp;
      }
    }

    return { kind, mode, data, questions: questionsShuffled, expected };

  },

  gen(){
    // üîπ Pour l‚Äô√©cran ET pour le PDF :
    // on utilise le dernier mode choisi, m√©moris√© dans __GEOM_PROJ_LAST_MODE
    // (d√©fini plus bas et mis √† jour par _genForMode)
    const mode = window.__GEOM_PROJ_LAST_MODE || 'mix';
    return this._genForMode(mode);
  },


  render(host, st){
    const {kind, mode, data, questions} = st;

    function figureSVG(){
      /* RECTANGLE (comme exo 2) */
      if(kind === 'rect'){
        return `
<svg viewBox="0 0 260 130" width="260" height="130">
  <polygon points="30,25 230,25 230,105 30,105"
           fill="#f7f3ef" stroke="#000" stroke-width="1.5"/>
  <line x1="30"  y1="25"  x2="230" y2="105" stroke="#000" stroke-width="1"/>
  <line x1="30"  y1="105" x2="230" y2="25"  stroke="#000" stroke-width="1"/>
  <circle cx="130" cy="65" r="3" fill="#000"/>
  <text x="134" y="62" font-size="11">O</text>
  <circle cx="130" cy="25"  r="3" fill="#000"/>
  <text x="132" y="20"  font-size="11">I</text>
  <circle cx="230" cy="65"  r="3" fill="#000"/>
  <text x="236" y="68"  font-size="11">J</text>
  <circle cx="30"  cy="25"  r="3" fill="#000"/>
  <circle cx="230" cy="25"  r="3" fill="#000"/>
  <circle cx="230" cy="105" r="3" fill="#000"/>
  <circle cx="30"  cy="105" r="3" fill="#000"/>
  <text x="22"  y="20"  font-size="12">A</text>
  <text x="232" y="20"  font-size="12">B</text>
  <text x="232" y="118" font-size="12">C</text>
  <text x="22"  y="118" font-size="12">D</text>
</svg>`;
      }

      /* TRAP√àZE RECTANGLE */
      if(kind === 'trap'){
        return `
<svg viewBox="0 0 260 130" width="260" height="130">
  <polygon points="40,100 210,100 180,40 40,40"
           fill="#f7f3ef" stroke="#000" stroke-width="1.5"/>
  <!-- angle droit en A -->
  <rect x="40" y="90" width="10" height="10"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <!-- angle droit en D -->
  <rect x="40" y="40" width="10" height="10"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <text x="32"  y="112" font-size="12">A</text>
  <text x="214" y="112" font-size="12">B</text>
  <text x="182" y="34"  font-size="12">C</text>
  <text x="32"  y="34"  font-size="12">D</text>
</svg>`;
      }

      /* CARR√â ABCD, centre O, projet√©s implicites */
           /* CARR√â ABCD, centre O, diagonales et point H milieu de [CB] */
      if(kind === 'carre'){
        return `
<svg viewBox="0 0 170 130" width="170" height="130">
  <rect x="30" y="30" width="90" height="90"
        fill="#f7f3ef" stroke="#000" stroke-width="1.5"/>
  <!-- diagonales -->
  <line x1="30" y1="120" x2="120" y2="30"
        stroke="#000" stroke-width="1"/>
  <line x1="30" y1="30" x2="120" y2="120"
        stroke="#000" stroke-width="1"/>
  <!-- angle droit en A -->
  <rect x="30" y="110" width="10" height="10"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <!-- centre O -->
  <circle cx="75" cy="75" r="3" fill="#000"/>
  <text x="80" y="72" font-size="11">O</text>
  <!-- point H milieu de [CB] -->
  <circle cx="120" cy="75" r="3" fill="#000"/>
  <text x="124" y="72" font-size="11">H</text>
  <text x="24"  y="124" font-size="12">A</text>
  <text x="122" y="124" font-size="12">B</text>
  <text x="122" y="28"  font-size="12">C</text>
  <text x="24"  y="28"  font-size="12">D</text>
</svg>`;
      }


      /* LOSANGE ABCD, diagonales perpendiculaires, centre O */
      if(kind === 'los'){
        return `
<svg viewBox="0 0 200 150" width="200" height="150">
  <polygon points="100,20 170,75 100,130 30,75"
           fill="#f7f3ef" stroke="#000" stroke-width="1.5"/>
  <line x1="100" y1="20"  x2="100" y2="130"
        stroke="#000" stroke-width="1"/>
  <line x1="30"  y1="75"  x2="170" y2="75"
        stroke="#000" stroke-width="1"/>
  <!-- petit carr√© au centre -->
  <rect x="96" y="71" width="8" height="8"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <!-- centre O -->
  <circle cx="100" cy="75" r="3" fill="#000"/>
  <text x="104" y="70" font-size="11">O</text>
  <text x="94"  y="16"  font-size="12">A</text>
  <text x="174" y="80"  font-size="12">B</text>
  <text x="94"  y="142" font-size="12">C</text>
  <text x="20"  y="80"  font-size="12">D</text>
</svg>`;
      }

      /* TRIANGLE RECTANGLE avec hauteur AH sur BC */
      if(kind === 'tri_rect'){
        return `
<svg viewBox="0 0 200 140" width="200" height="140">
  <!-- base BC (hypot√©nuse) -->
  <line x1="30" y1="110" x2="170" y2="110"
        stroke="#000" stroke-width="1.5"/>
  <!-- c√¥t√©s vers A -->
  <line x1="30" y1="110" x2="100" y2="30"
        stroke="#000" stroke-width="1.5"/>
  <line x1="170" y1="110" x2="100" y2="30"
        stroke="#000" stroke-width="1.5"/>
  <!-- hauteur AH -->
  <line x1="100" y1="30" x2="100" y2="110"
        stroke="#000" stroke-width="1.5"/>
  <!-- angle droit en A -->
  <rect x="92" y="30" width="10" height="10"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <!-- angle droit en H -->
  <rect x="100" y="102" width="10" height="10"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <text x="24"  y="124" font-size="12">B</text>
  <text x="174" y="124" font-size="12">C</text>
  <text x="96"  y="22"  font-size="12">A</text>
  <text x="112" y="114" font-size="12">H</text>
</svg>`;
      }

      /* TRIANGLE QUELCONQUE avec hauteur AH sur BC */
      /* TRIANGLE QUELCONQUE avec hauteur AH sur BC (AH ‚üÇ BC) */
      return `
<svg viewBox="0 0 200 140" width="200" height="140">
  <line x1="30" y1="110" x2="170" y2="110"
        stroke="#000" stroke-width="1.5"/>
  <line x1="30" y1="110" x2="120" y2="30"
        stroke="#000" stroke-width="1.5"/>
  <line x1="170" y1="110" x2="120" y2="30"
        stroke="#000" stroke-width="1.5"/>
  <!-- hauteur AH (verticale, perpendiculaire √† BC) -->
  <line x1="120" y1="30" x2="120" y2="110"
        stroke="#000" stroke-width="1.5"/>
  <!-- angle droit en H -->
  <rect x="120" y="102" width="10" height="10"
        fill="none" stroke="#000" stroke-width="1.5"/>
  <text x="24"  y="124" font-size="12">B</text>
  <text x="174" y="124" font-size="12">C</text>
  <text x="116" y="22"  font-size="12">A</text>
  <text x="124" y="114" font-size="12">H</text>
</svg>`;

    }

    let intro = '';
    if(kind === 'rect'){
      const {AB,AD} = data;
      intro = `
        On consid√®re un rectangle \\(ABCD\\) de centre \\(O\\) tel que
        \\(AB=${AB}\\) et \\(AD=${AD}\\).
        On note \\(I\\) le milieu de \\([AB]\\) et \\(J\\) le milieu de \\([CB]\\).`;
    }else if(kind === 'trap'){
      const {AB,CD,AD} = data;
      intro = `
        On consid√®re un trap√®ze rectangle \\(ABCD\\) tel que
        \\((AB)\\parallel(DC)\\), \\((AD)\\perp(AB)\\) et \\((AD)\\perp(DC)\\),
        avec \\(AB=${AB}\\), \\(CD=${CD}\\) et \\(AD=${AD}\\).
        On note \\(H\\) le projet√© orthogonal de \\(C\\) sur \\((AB)\\) et
        \\(K\\) le projet√© orthogonal de \\(B\\) sur \\((CD)\\).`;
    }else if(kind === 'carre'){
      const {a} = data;
      intro = `
        On consid√®re un carr√© \\(ABCD\\) de c√¥t√© \\(AB=BC=CD=DA=${a}\\),
        de centre \\(O\\).
        On note \\(H\\) le milieu de \\([CB]\\).`;
    }else if(kind === 'los'){
      const {d1,d2,a} = data;
      intro = `
        On consid√®re un losange \\(ABCD\\) de centre \\(O\\). On sait que \\(AB=${a}\\), \\(AC=${d1}\\) et \\(BD=${d2}\\).`;

    }else if(kind === 'tri_rect'){
      const {BC,BH,HC,AH} = data;
      intro = `
        On consid√®re un triangle rectangle \\(ABC\\), rectangle en \\(A\\).
        La hauteur issue de \\(A\\) coupe le segment \\([BC]\\) en \\(H\\).<br>
        On donne \\(BC=${BC}\\), \\(BH=${BH}\\) et \\(AH=${AH}\\).`;
    }else if(kind === 'tri_alt'){
      const {BC,BH,HC,AH} = data;
      intro = `
        On consid√®re un triangle quelconque \\(ABC\\) dont la hauteur issue de \\(A\\)
        coupe \\([BC]\\) en \\(H\\).<br>
        On donne \\(BC=${BC}\\), \\(HC=${HC}\\) et \\(AH=${AH}\\).`;
    }

    host.innerHTML = `
      <div id="lead" class="small"></div>
      <div id="equ"></div>
      <div id="fb"></div>
      <div id="inputs"></div>
      <div id="res" class="steps"></div>
    `;

    const lead   = host.querySelector('#lead');
    const equ    = host.querySelector('#equ');
    const inputs = host.querySelector('#inputs');

    if(lead){
      lead.innerHTML = "";
    }

    if(equ){
      equ.innerHTML = `
        <p><strong>Exercice 2 :</strong></p>
        <div style="margin-bottom:.4rem;">
          <label><strong>Figure :</strong>
            <select id="fig-select" style="margin-left:.4rem; padding:.2rem .4rem;">
              <option value="mix"${mode==='mix'?' selected':''}>M√©lange</option>
              <option value="rect"${mode==='rect'?' selected':''}>Rectangle</option>
              <option value="trap"${mode==='trap'?' selected':''}>Trap√®ze</option>
              <option value="carre"${mode==='carre'?' selected':''}>Carr√©</option>
              <option value="los"${mode==='los'?' selected':''}>Losange</option>
              <option value="tri_rect"${mode==='tri_rect'?' selected':''}>Triangle rectangle</option>
              <option value="tri_alt"${mode==='tri_alt'?' selected':''}>Triangle quelconque</option>
            </select>
          </label>
        </div>
        <p>${intro}</p>
        <div  style="margin-top:.4rem; text-align:center;">
          ${figureSVG()}
        </div>
        <p>(Figure non √† l‚Äô√©chelle.)</p>
      `;
    }

    if(inputs){
      inputs.innerHTML = `
        <p>Calculer les produits scalaires suivants :</p>
        <table style="border-collapse:collapse; margin-top:4px;">
          ${questions.map((q,i)=>`
            <tr>
              <td style="padding:4px 10px 4px 0;"><strong>${i+1})</strong></td>
              <td style="padding:4px 10px 4px 0;">\\(${q.tex}=\\)</td>
              <td style="padding:4px 6px;">
                <input type="text" class="ps-all" data-id="${q.id}"
                       inputmode="decimal" autocomplete="off" style="width:80px;">
                <span class="tick nu"></span>
              </td>
            </tr>
          `).join('')}
        </table>
      `;
    }


       const figSel = host.querySelector('#fig-select');
    if(figSel){
      figSel.addEventListener('change', ()=>{
        const mode2 = figSel.value || 'mix';
        const st2   = ex2._genForMode(mode2);   // ‚¨Ö ex2 au lieu de ex3
        host.dataset.state = JSON.stringify(st2);
        ex2.render(host, st2);                  // ‚¨Ö ex2 au lieu de ex3

        // r√©-attacher le clavier apr√®s re-render
        try{
          if (window.MathKbd?.attachAllInputs){
            MathKbd.attachAllInputs(host);
          }
        }catch(_){}
      });
    }


    typesetAll(host);
  },

  correct(host, st){
    const inputs = host.querySelectorAll('.ps-all');
    const fb     = host.querySelector('#fb');
    const exp    = st.expected || {};

    // Est-ce qu'au moins UNE case est remplie ?
    let anyFilled = false;
    inputs.forEach(inp=>{
      if (inp.value.trim() !== '') anyFilled = true;
    });

    // Si aucune case n'est remplie : tout neutre, score 0 / 0
    if(!anyFilled){
      inputs.forEach(inp=>setTick(inp,'nu'));
      if(fb) fb.textContent = '';
      return {ok:0,total:0};
    }

    let ok = 0;
    let total = 0;

    inputs.forEach(inp=>{
      const id = inp.dataset.id;
      if(!Object.prototype.hasOwnProperty.call(exp,id)) return;

      const raw = inp.value.trim();

      // üîπ Case vide : on ne sanctionne pas, tick neutre, pas compt√©e dans le total
      if(raw === ''){
        setTick(inp,'nu');
        return;
      }

      total++;
      const v = parseNumber(raw);
      if(!isNaN(v) && approxEqual(v, exp[id], 1e-6)){
        setTick(inp,'ok'); 
        ok++;
      } else {
        setTick(inp,'ko');
      }
    });

    if(fb){
      fb.innerHTML =
        "On rappelle :<br>" +
        "‚Ä¢ produit scalaire nul si les vecteurs sont perpendiculaires ;<br>" +
        "‚Ä¢ produit scalaire √©gal √† \\(\\pm\\|u\\|\\times\\|v\\|\\) si les vecteurs sont colin√©aires ;<br>" +
        "‚Ä¢ gr√¢ce au projet√© orthogonal, on remplace un vecteur par un autre colin√©aire ayant la m√™me projection sur une droite donn√©e.";
      if(window.MathJax?.typesetPromise) MathJax.typesetPromise([fb]);
    }

    return {ok,total};
  },


    solution(host, st){
    const {kind, data, expected} = st;
    const res = host.querySelector('#res');
    if(!res) return;

    // On r√©cup√®re la figure d√©j√† construite dans l‚Äô√©nonc√©
    let figHTML = '';
    const equ = host.querySelector('#equ');
 if(equ){
   const printFig = equ.querySelector('.print-only');
   const scrFig   = equ.querySelector('.screen-only');
   const src      = printFig || scrFig;
   if(src) figHTML = src.innerHTML;
 }

    // Pr√©-calculs selon la figure
    let AB, AD, CD, a, d1, d2, BC, BH, HC;
    if(kind === 'rect'){
      AB = data.AB; AD = data.AD;
    }else if(kind === 'trap'){
      AB = data.AB; CD = data.CD; AD = data.AD;
    }else if(kind === 'carre'){
      a = data.a;
    }else if(kind === 'los'){
      d1 = data.d1; d2 = data.d2; a = data.a;
    }else if(kind === 'tri_rect' || kind === 'tri_alt'){
      BC = data.BC; BH = data.BH; HC = data.HC;
    }

    const AB2   = AB!=null ? AB*AB : null;
    const AD2   = AD!=null ? AD*AD : null;
    const a2    = a!=null  ? a*a    : null;
    const a2h   = a2!=null ? a2/2   : null;
    const AD2h  = AD2!=null? AD2/2  : null;
    const AC2sur2 = d1!=null ? (d1*d1)/2 : null;
    const BD2sur2 = d2!=null ? (d2*d2)/2 : null;

    const AD2hStr    = AD2h!=null    ? formatNumber(AD2h)    : '';
    const a2hStr     = a2h!=null     ? formatNumber(a2h)     : '';
    const AC2sur2Str = AC2sur2!=null ? formatNumber(AC2sur2) : '';
    const BD2sur2Str = BD2sur2!=null ? formatNumber(BD2sur2) : '';
    const side2Str   = a2!=null      ? formatNumber(a2)      : '';

    const AO = d1!=null ? d1/2 : null;
    const BO = d2!=null ? d2/2 : null;

    // Fabrique la r√©daction correspondant √† UNE question (en fonction de son id)
    function expFor(id){
      /* ‚Äî RECTANGLE ‚Äî */
      if(kind === 'rect'){
        if(id === 'ps_ab_ad'){
          return `
          \\(ABCD\\) est un rectangle en \\(A\\). On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AD}=0
          \\]`;
        }
        if(id === 'ps_ab_cd'){
          return `

          \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{CD}\\) sont colin√©aires
          de sens oppos√©s. On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{CD}
            = -AB\\times CD = -${AB}\\times${AB} = -${AB2}
          \\]`;
        }
        if(id === 'ps_ab_ac'){
          return `
          \\(B\\) est le projet√© orthogonal de \\(C\\) sur \\((AB)\\). On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AB}\\cdot\\overrightarrow{AB}
            = AB^2 = ${AB2}
          \\]`;
        }
        if(id === 'ps_cb_ca'){
          return `
          \\(B\\) est le projet√© orthogonal de \\(A\\) sur \\((CB)\\), et \\(CB=AD\\).
          On a donc :
          \\[
            \\overrightarrow{CB}\\cdot\\overrightarrow{CA}
            = \\overrightarrow{CB}\\cdot\\overrightarrow{CB}
            = -CB^2 = -${AD2}
          \\]`;
        }
        if(id === 'ps_do_cb'){
          return `
          \\(J\\) est le projet√© orthogonal de \\(O\\) sur \\((CB)\\). On a
          \\(CJ = \\dfrac{CB}{2} = \\dfrac{AD}{2}\\), donc :
          \\[
            \\overrightarrow{CO}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{CJ}\\cdot\\overrightarrow{CB}
            = CJ\\times CB
            = \\dfrac{AD}{2}\\times AD
            = \\dfrac{${AD2}}{2}
            = ${AD2hStr}
          \\]`;
        }
      }

      /* ‚Äî TRAP√àZE RECTANGLE ‚Äî */
      if(kind === 'trap'){
        const ABxCD = AB*CD;
        const AD2   = AD*AD;
        const diff  = AB - CD;
        const last  = -CD*(AB-CD);

        if(id === 'ps_ab_ad'){
          return `
          Le trap√®ze est rectangle en \\(A\\). On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AD}=0
          \\]`;
        }
        if(id === 'ps_ab_cd'){
          return `
          \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{CD}\\) sont colin√©aires
          de sens oppos√©s, donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{CD}
            = -AB\\times CD
            = -${AB}\\times${CD}
            = -${ABxCD}
          \\]`;
        }
        if(id === 'ps_ab_ac'){
          return `
          \\(H\\) est le projet√© orthogonal de \\(C\\) sur \\((AB)\\).
          Or \\(AH=CD\\), donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AB}\\cdot\\overrightarrow{AH}
            = AB\\times AH
            = ${AB}\\times${CD}
            = ${ABxCD}
          \\]`;
        }
        if(id === 'ps_ad_ac'){
          return `
          \\(D\\) est le projet√© orthogonal de \\(C\\) sur \\((AD)\\).
          On a donc :
          \\[
            \\overrightarrow{AD}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AD}\\cdot\\overrightarrow{AD}
            = AD^2 = ${AD}^2 = ${AD2}
          \\]`;
        }
        if(id === 'ps_cd_cb'){
          return `
          \\(K\\) est le projet√© orthogonal de \\(B\\) sur \\((CD)\\).
          On a \\(CK = AB - CD = ${diff}\\), et
          \\(\\overrightarrow{CK}\\) et \\(\\overrightarrow{CD}\\)sont colin√©aires de sens oppos√©.
          On a donc :
          \\[
            \\overrightarrow{CD}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{CD}\\cdot\\overrightarrow{CK}
            = -CD\\times CK
            = -${CD}\\times${diff}
            = ${last}
          \\]`;
        }
      }

      /* ‚Äî CARR√â ‚Äî */
      if(kind === 'carre'){
        if(id === 'ps_ab_ad'){
          return `
          Dans un carr√©, les c√¥t√©s cons√©cutifs sont perpendiculaires.
          On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AD}=0
          \\]`;
        }
        if(id === 'ps_ab_dc'){
          return `
          \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{DC}\\) sont colin√©aires
          de sens oppos√©s. On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{DC}
            = -AB\\times DC
            = -${a}\\times${a}
            = -${a2}
          \\]`;
        }
        if(id === 'ps_ab_ac'){
          return `
          \\(B\\) est le projet√© orthogonal de \\(C\\) sur la droite \\((AB)\\).
          On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AB}\\cdot\\overrightarrow{AB}
            = AB^2
            = ${a}^2
            = ${a2}
          \\]`;
        }
        if(id === 'ps_cb_ca'){
          return `
          \\(C\\) est le projet√© orthogonal de \\(A\\) sur \\((CB)\\).
          On a :
          \\[
            \\overrightarrow{BC}\\cdot\\overrightarrow{CA}
            = \\overrightarrow{BC}\\cdot\\overrightarrow{CB}
            = -CB^2
            = -${a}^2
            = -${a2}
          \\]`;
        }
        if(id === 'ps_co_cb'){
          return `
          \\(H\\) est le projet√© orthogonal de \\(O\\) sur \\((CB)\\). \\(H\\) est donc le milieu de \\([CB]\\).
          On a \\(CH = \\dfrac{CB}{2} = \\dfrac{${a}}{2}\\), d‚Äôo√π :
          \\[
            \\overrightarrow{CO}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{CH}\\cdot\\overrightarrow{CB}
            = CH\\times CB
            = \\dfrac{${a}}{2}\\times${a}
            = \\dfrac{${a2}}{2}
            = ${a2hStr}
          \\]`;
        }
      }

      /* ‚Äî LOSANGE ‚Äî */
      if(kind === 'los'){
        if(id === 'ps_ac_bd'){
          return `
          Les diagonales \\([AC]\\) et \\([BD]\\) du losange sont perpendiculaires.
          On a donc :
          \\[
            \\overrightarrow{AC}\\cdot\\overrightarrow{BD}=0
          \\]`;
        }
        if(id === 'ps_ab_cd'){
          return `
          \\(\\overrightarrow{AB}\\) et \\(\\overrightarrow{CD}\\) sont colin√©aires
          de sens oppos√©s. On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{CD}
            = -AB\\times CD
            = -${a}\\times${a}
            = -${side2Str}
          \\]`;
        }
        if(id === 'ps_ab_ac'){
          return `
          \\(O\\) est le projet√© orthogonal de \\(B\\) sur la droite \\((AC)\\).
          On a \\(AO = \\dfrac{AC}{2} = \\dfrac{${d1}}{2} = ${AO}\\). On en d√©duit :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{AO}\\cdot\\overrightarrow{AC}
            = AO\\times AC
            = ${AO}\\times${d1}
            = ${AC2sur2Str}
          \\]`;
        }
        if(id === 'ps_bc_bd'){
          return `
          \\(O\\) est le projet√© orthogonal de \\(C\\) sur \\((BD)\\). 
          On a \\(BO = \\dfrac{BD}{2} = \\dfrac{${d2}}{2} = ${BO}\\). Donc :
          \\[
            \\overrightarrow{BC}\\cdot\\overrightarrow{BD}
            = \\overrightarrow{BO}\\cdot\\overrightarrow{BD}
            = BO\\times BD
            = ${BO}\\times${d2}
            = ${BD2sur2Str}
          \\]`;
        }
        if(id === 'ps_ad_ac'){
          return `
          \\(O\\) est le projet√© orthogonal de \\(D\\) sur \\((AC)\\). Or
          \\(\\overrightarrow{OA}\\) et \\(\\overrightarrow{AC}\\) sont colin√©aires de sens oppos√©.
          On a donc :
          \\[
            \\overrightarrow{DA}\\cdot\\overrightarrow{AC}
            = \\overrightarrow{OA}\\cdot\\overrightarrow{AC}
            = -OA\\times AC
            = -${AO}\\times${d1}
            = -${AC2sur2Str}
          \\]`;
        }
      }

      /* ‚Äî TRIANGLE RECTANGLE ‚Äî */
      if(kind === 'tri_rect'){
        const BC2 = BC*BC;
        if(id === 'ps_ab_ac'){
          return `
          Le triangle est rectangle en \\(A\\). On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{AC}=0
          \\]`;
        }
        if(id === 'ps_bc_cb'){
          return `
          Les vecteurs \\(\\overrightarrow{BC}\\) et \\(\\overrightarrow{CB}\\)
          sont colin√©aires de sens oppos√©s. On a donc :
          \\[
            \\overrightarrow{BC}\\cdot\\overrightarrow{CB}
            = -BC\\times BC
            = -${BC2}
          \\]`;
        }
        if(id === 'ps_ab_bc'){
          return `
          \\(H\\) est le projet√© orthogonal de \\(A\\) sur \\((BC)\\). Or \\(\\overrightarrow{HB}\\) et \\(\\overrightarrow{BC}\\) sont colin√©aires
          de sens oppos√©s. On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{BC}
            = \\overrightarrow{HB}\\cdot\\overrightarrow{BC}
            = -HB\\times BC
            = -${BH}\\times${BC}
            = -${BH*BC}
          \\]`;
        }
        if(id === 'ps_ca_cb'){
          return `
          \\(H\\) est le projet√© orthogonal de \\(A\\) sur la droite \\((CB)\\). Or \\(HC=BC-BH=${HC}\\).
          On a donc :
          \\[
            \\overrightarrow{CA}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{CH}\\cdot\\overrightarrow{CB}
            = CH\\times CB
            = ${HC}\\times${BC}
            = ${HC*BC}
          \\]`;
        }
        if(id === 'ps_ab_cb'){
          return `
      
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{AB}\\cdot(-\\overrightarrow{BC})
            = -\\overrightarrow{AB}\\cdot\\overrightarrow{BC}
            = -(-${BH*BC})
            = ${BH*BC}
          \\]`;
        }
      }

      /* ‚Äî TRIANGLE QUELCONQUE AVEC HAUTEUR ‚Äî */
      if(kind === 'tri_alt'){
        const BC2 = BC*BC;
        if(id === 'ps_ah_bc'){
          return `
          \\(AH\\) est une hauteur, donc \\((AH)\\perp (BC)\\). On a donc :
          \\[
            \\overrightarrow{AH}\\cdot\\overrightarrow{BC} = 0
          \\]`;
        }
        if(id === 'ps_bc_cb'){
          return `
          Les vecteurs \\(\\overrightarrow{BC}\\) et \\(\\overrightarrow{CB}\\)
          sont colin√©aires de sens oppos√©s. On a donc :
          \\[
            \\overrightarrow{BC}\\cdot\\overrightarrow{CB}
            = -BC\\times BC
            = -${BC2}
          \\]`;
        }
        if(id === 'ps_ab_bc'){
          return `
          \\(H\\) est le projet√© orthogonal de \\(A\\) sur \\((BC)\\). Or \\(\\overrightarrow{HB}\\) et \\(\\overrightarrow{BC}\\) sont colin√©aires
          de sens oppos√©s et \\(BH=BC-HC=${BH}\\). On a donc :
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{BC}
            = \\overrightarrow{HB}\\cdot\\overrightarrow{BC}
            = -HB\\times BC
            = -${BH}\\times${BC}
            = -${BH*BC}
          \\]`;
        }
        if(id === 'ps_ca_cb'){
          return `
          \\(H\\) est le projet√© orthogonal de \\(A\\) sur \\((BC)\\).
          On a donc :
          \\[
            \\overrightarrow{CA}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{CH}\\cdot\\overrightarrow{CB}
            = CH\\times CB
            = ${HC}\\times${BC}
            = ${HC*BC}
          \\]`;
        }
        if(id === 'ps_ab_cb'){
          return `
       
          \\[
            \\overrightarrow{AB}\\cdot\\overrightarrow{CB}
            = \\overrightarrow{AB}\\cdot(-\\overrightarrow{BC})
            = -\\overrightarrow{AB}\\cdot\\overrightarrow{BC}
            = -(-${BH*BC})
            = ${BH*BC}
          \\]`;
        }
      }

      return '';
    }

    // Construction HTML : figure + liste num√©rot√©e
    let html = '';

    if(figHTML){
      html += `
        <div  style="text-align:center;margin-bottom:.4rem;">
          ${figHTML}
        </div>
      `;
    }

    html += '<ol style="padding-left:0; list-style:none;">';

    const qs = st.questions || [];
    qs.forEach((q, idx)=>{
      html += `
        <li style="margin-bottom:.4rem;">
          <strong>${idx+1})</strong> ${expFor(q.id)}
        </li>
      `;
    });

    html += '</ol>';

    res.innerHTML = html;
    typesetAll(res);
  },


  reset(host){
    const inputs = host.querySelectorAll('.ps-all');
    inputs.forEach(inp=>{
      inp.value = '';
      setTick(inp,'nu');
    });
    const fb  = host.querySelector('#fb');
    const res = host.querySelector('#res');
    if(fb) fb.textContent = '';
    if(res) res.innerHTML = '';
  }
};



// Mode choisi pour l'exercice "geom_proj_all" (exercice 2)
// On le stocke aussi dans localStorage pour que la fen√™tre PDF
// puisse r√©cup√©rer la m√™me info.
function setLastGeomProjMode(mode){
  mode = mode || 'mix';
  try{
    localStorage.setItem('geom_proj_last_mode', mode);
  }catch(e){}
  window.__GEOM_PROJ_LAST_MODE = mode;
}

function getLastGeomProjMode(){
  if (window.__GEOM_PROJ_LAST_MODE) return window.__GEOM_PROJ_LAST_MODE;
  try{
    return localStorage.getItem('geom_proj_last_mode') || 'mix';
  }catch(e){
    return 'mix';
  }
}


/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY = [ex1,ex2];
window.REGISTRY = REGISTRY;

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1√®re ‚Äì Produit scalaire - Expression analytique avec coordonn√©es`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");

  let st = null;

  // En mode PDF : on essaie d'abord de r√©utiliser l'√©tat d√©j√† stock√©
  if (window.__PDF_BUILDING && host.dataset.state){
    try{
      st = JSON.parse(host.dataset.state);
    }catch(_){}
  }

  // Si on n'a toujours pas d'√©tat (cas host "cach√©" pour le PDF)
  if (!st){
    // Cas particulier : exercice 2 avec s√©lecteur de figure
    if (def.id === 'geom_proj_all' && typeof def._genForMode === 'function'){
      let mode = 'mix';

      // 1) en mode normal, on lit le select ou l'ancien state
      const figSel = host.querySelector('#fig-select');
      if (!window.__PDF_BUILDING && figSel && figSel.value){
        mode = figSel.value;
      } else {
        // 2) sinon on essaie de relire un ancien state local
        try{
          const prev = host.dataset.state ? JSON.parse(host.dataset.state) : null;
          if (prev && prev.mode) mode = prev.mode;
        }catch(_){}

        // 3) si on est en PDF et qu'on n'a rien trouv√©, on prend le dernier mode global
            // 3) si on est en PDF et qu'on n'a rien trouv√©, on prend le dernier mode (localStorage)
        if (window.__PDF_BUILDING && (!mode || mode === 'mix')){
          mode = getLastGeomProjMode();
        }

      }

      st = def._genForMode(mode);
    } else {
      // Tous les autres exercices
      st = def.gen();
    }
  }

  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}




function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
