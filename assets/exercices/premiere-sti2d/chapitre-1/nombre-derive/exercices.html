<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1STI2D — Nombre dérivé d'une fonction</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .frame{border:2px solid #000;border-radius:10px;padding:10px 12px;margin-top:.6rem}
  .frame ul{margin:.2rem 0 .2rem 1.1rem}
  .frame li{margin:.25rem 0}
/* ——— Alignements lisibles à l'écran ——— */
:root{ --li-indent: 1.35em; }

.frame ul,
ul.steps{
  list-style: disc;
  margin:.2rem 0;
  padding-left: var(--li-indent);   /* retrait maîtrisé, identique partout */
}

ul.steps > li{ margin:.28rem 0; line-height:1.55; }

/* sous-lignes alignées exactement sous le texte des puces */
.sub{
  display:block;
  margin:.14rem 0 .18rem var(--li-indent);
  line-height:1.55;
  white-space:normal;
}

/* pouvoir enlever la puce sur une ligne donnée (pour la conclusion) */
ul.steps > li.nomark{ list-style:none; padding-left:0; }
ul.steps > li.nomark::marker{ content:""; }

/* ——— PDF : on supprime *toutes* les puces pour éviter le "é" parasite ——— */
@media print{
  .frame ul, .frame ul.steps{ list-style:none !important; padding-left:0 !important; }
  .frame ul li::marker{ content:"" !important; }
}


  /* Sélecteur LaTeX custom (pour afficher du LaTeX dans le “menu déroulant”) */
  .mselect{ position:relative; display:inline-block; }
  .mselect-btn{
    padding:8px 12px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer;
    min-width:140px; text-align:left;
  }
  .mselect[aria-expanded="true"] .mselect-list{ display:block; }
  .mselect-list{
    display:none; position:absolute; z-index:10; top:42px; left:0; background:#fff;
    border:1px solid #ddd; border-radius:8px; min-width:200px; box-shadow:0 6px 24px rgba(0,0,0,.08);
    padding:6px;
  }
  .mselect-item{
    display:block; width:100%; text-align:left; padding:8px 10px; border:0; background:#fff; cursor:pointer;
    border-radius:6px;
  }
  .mselect-item:hover{ background:#f6f6f6; }

  .ans{display:flex;gap:8px;align-items:center;margin-top:10px}
  .ans input{flex:1;padding:9px 11px;border:1px solid #dcdcdc;border-radius:10px;font-size:16px}
  .msg{margin-left:6px;font-weight:600}
  .ok{color:var(--ok)} .ko{color:var(--ko)}

  .enonce-controls{ margin:.25rem 0 .75rem; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  @media print{ .controls,.enonce-controls{display:none!important} }
  /* Étapes : pouvoir enlever le bullet sur une ligne précise (PDF safe) */
ul.steps > li.nomark { list-style: none; margin-left: 0; padding-left: 0; }
ul.steps > li.nomark::marker { content: ""; } /* pour les navigateurs qui gèrent ::marker */
/* LISTES DANS LES SOLUTIONS (.frame) — bullets robustes (PDF safe) */
:root { --li-indent: 1.25rem; }

.frame ul.steps{
  list-style: none;           /* on tue le bullet natif */
  margin:.25rem 0;
  padding:0;
}
.frame ul.steps > li{
  position: relative;
  padding-left: var(--li-indent);
  line-height: 1.55;
}
/* petit rond vectoriel (pas un caractère !) */
.frame ul.steps > li::before{
  content:"";
  position:absolute; left:.35rem; top:.68em;
  width:.36em; height:.36em;
  border-radius:50%;
  background: currentColor;
}
/* pas de rond pour les éléments marqués .nomark (si tu en gardes) */
.frame ul.steps > li.nomark::before{ display:none; }

/* sous-lignes alignées sous le texte de la puce */
.sub{
  display:block;
  margin:.12rem 0 .18rem var(--li-indent);
  line-height:1.55;
  white-space: normal;
}

/* rien de spécial à l'impression : pas de caractères spéciaux à convertir */

</style>

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>

<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem"><strong>1STI2D — Nombre dérivé d'une fonction</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
  <label for="exo-select"><strong>Type d’exercice :</strong></label>
  <select id="exo-select"></select>

  <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
  <button id="btn-check" class="btn">✅ Vérifier</button>
  <button id="btn-solution" class="btn">💡 Solution</button>
  <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
  <span class="score">Score : <span id="score">0 / 0</span></span>
</div>


    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; réponses acceptées :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Écrire la <b>valeur finale</b> de la dérivée (ce qui est écrit après <code>f′(…)=</code>).</li>
        <li>Ex. 1 (au point n) : une valeur numérique (ex. <code>-17</code>). Ex. 2 (au point a) : réponds <code>2a</code>, <code>3a^2</code>, <code>-1/a^2</code>, etc.</li>
        <li>Notation clavier acceptée : <code>^</code>, <code>/</code>, parenthèses.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
  <script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

function mountMenuIn(host){
  const root = host.querySelector('.mselect[data-role="fn"]');
  if(!root) return;
  const btn = root.querySelector('.mselect-btn');
  const hidden = host.querySelector('#fn-select');
  const labels = {auto:'Aléatoire', carre:'x^{2}', cube:'x^{3}',
                  inverse:'\\frac{1}{x}', affine:'ax+b', quad:'ax^{2}+bx+c'};

  root.addEventListener('click', (e)=>{
    const it = e.target.closest('.mselect-item');
    if(it){
      hidden.value = it.dataset.val;
      btn.innerHTML = `\\(${labels[hidden.value]}\\)`;
      root.setAttribute('aria-expanded','false');
      // régénère l’énoncé courant (en gardant Ex.1/Ex.2)
      const exId = ($('#exo-select').value==='ex2') ? 'ex2' : 'ex1';
      const ex = window.REGISTRY.find(e=>e.id===exId);
      ex.gen($('#host'));
      if (window.MathJax?.typeset) MathJax.typeset();
    } else if(e.target === btn){
      root.setAttribute('aria-expanded', root.getAttribute('aria-expanded')==='true' ? 'false' : 'true');
    }
  });

  document.addEventListener('click', (e)=>{
    if(!root.contains(e.target)) root.setAttribute('aria-expanded','false');
  }, {passive:true});

  if (window.MathJax?.typeset) MathJax.typeset();
}

const $  = (s,r)=> (r||document).querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
const UMINUS = (window.DevRules && DevRules.consts && DevRules.consts.UMINUS) || '−';

/* —————————————————————— Helpers LaTeX —————————————————————— */

// \( ... \)
const wrap = s => `\\(${s}\\)`;
const num     = x => String(x).replace(/−/g,'-');

const fnArg   = n => num(n);

// nombre n affiché, parenthésé uniquement si on le met en puissance ou en produit
const texNum = n => String(n).replace(/-/g,'-');
const texNumPar = n => (n < 0 ? `(${texNum(n)})` : texNum(n));

// a×b×c (avec \times uniquement entre nombres)
const times = (a,b)=> `${a}\\times${b}`;
const times3= (a,b,c)=> `${a}\\times${b}\\times${c}`;

// fraction LaTeX (sans wrap)
const Q = (num, den)=> `\\frac{${num}}{${den}}`;

// Limite \lim_{h\to 0}
const LIM = `\\lim\\limits_{h\\to 0}`;

/* —————————————————————— Texte LaTeX pour f(x) —————————————————————— */
function fxTeX(type, params={}){
  switch(type){
    case 'carre':   return 'x^{2}';
    case 'cube':    return 'x^{3}';
    case 'inverse': return Q('1','x');
    case 'affine': {
      const {m=1,p=0}=params;
      let s = (m===1?'x':m===-1?'-x':`${m}x`);
      if(p) s += (p<0?` - ${Math.abs(p)}`:` + ${p}`);
      return s.replace(/^ \+ /,'');
    }
    case 'quad': {
      const {a=1,b=0,c=0}=params;
      let s='';
      if(a){ s += (a===1?'x^{2}':a===-1?'-x^{2}':`${a}x^{2}`); }
      if(b){ s += (b<0?` - ${Math.abs(b)}x`:` + ${b}x`); }
      if(c){ s += (c<0?` - ${Math.abs(c)}`:` + ${c}`); }
      return s.replace(/^ \+ /,'') || '0';
    }
  }
}

/* —————————————————————— Génération d'états —————————————————————— */

function getSelectedType(){
  const sel = $('#fn-select');
  return sel ? (sel.value || 'auto') : 'auto';
}

function genState_ex1(){
  const forced = getSelectedType();
  const type = forced !== 'auto' ? forced : choice(['carre','cube','inverse','affine','quad']);
  let n = rnd(-3,3);
  if(type==='inverse'){ while(n===0) n=rnd(-3,3); }
  const params = {};
  if(type==='affine'){ params.m=choice([-3,-2,-1,1,2,3]); params.p=rnd(-5,5); }
  if(type==='quad'){ params.a=choice([-2,-1,1,2]); params.b=rnd(-5,5); params.c=rnd(-6,6); }
  return {kind:'ex1', type, n, params, h:'h', _forced: forced};
}

function genState_ex2(){
  const forced = getSelectedType();
  const type = forced !== 'auto' ? forced : choice(['carre','cube','inverse','affine','quad']);
  const params = {};
  if(type==='affine'){ params.m=choice([-5,-3,-2,-1,1,2,3,5]); params.p=rnd(-6,6); }
  if(type==='quad'){ params.a=choice([-2,-1,1,2]); params.b=rnd(-6,6); params.c=rnd(-6,6); }
  return {kind:'ex2', type, params, h:'h', _forced: forced};
}
// "Pour h ≠ 0," rendu par MathJax (évite le décalage d'interligne)
const pourHne0 = h => wrap(`\\text{Pour } ${h} \\ne 0,`);

/* —————————————————————— Énoncé + sélecteur —————————————————————— */

function renderEnonce(host, st){
  const f = fxTeX(st.type, st.params||{});
const labelFor = v => ({
  auto:'Aléatoire', carre:'x^{2}', cube:'x^{3}',
  inverse:'\\frac{1}{x}', affine:'ax+b', quad:'ax^{2}+bx+c'
})[v] || 'Aléatoire';

const selectorHTML = `
  <div class="enonce-controls">
    <label><strong>\\(f(x)=\\) </strong></label>
    <div class="mselect" data-role="fn" aria-expanded="false">
      <button type="button" class="mselect-btn">\\(${labelFor(st._forced || 'auto')}\\)</button>
      <div class="mselect-list">
        <button class="mselect-item" data-val="auto">Aléatoire</button>
        <button class="mselect-item" data-val="carre">\\(x^{2}\\)</button>
        <button class="mselect-item" data-val="cube">\\(x^{3}\\)</button>
        <button class="mselect-item" data-val="inverse">\\(\\frac{1}{x}\\)</button>
        <button class="mselect-item" data-val="affine">\\(ax+b\\)</button>
        <button class="mselect-item" data-val="quad">\\(ax^{2}+bx+c\\)</button>
      </div>
    </div>
    <input type="hidden" id="fn-select" value="${st._forced || 'auto'}">
  </div>`;

  const head = st.kind==='ex1'
    ? `<p><strong>Exercice 1 :</strong></p>
       <p>Soit la fonction \\( f \\) définie sur \\(\\mathbb{R}\\) par \\( f(x)= ${f} \\).</p>
       <p>Prouver l’existence du nombre dérivé au point d'abscisse ${wrap(fnArg(st.n))} de la fonction \\( f \\) indiquée, puis calculer sa valeur.</p>`
    : `<p><strong>Exercice 2 :</strong></p>
       <p>Soit la fonction \\( f \\) définie sur \\(\\mathbb{R}\\) par \\( f(x)= ${f} \\).</p>
       <p>Prouver l’existence du nombre dérivé au point d'abscisse ${wrap('a')} de la fonction \\( f \\) indiquée, puis calculer sa valeur.</p>`;

  host.innerHTML = `
  ${selectorHTML}
  <div>${head}</div>
  <div class="ans">
    <label for="ans" style="white-space:nowrap"><strong>Réponse :</strong></label>
    <input id="ans" placeholder="">
    <span id="msg" class="msg"></span>
  </div>
  <div id="solution" class="frame" style="display:none"></div>
`;


  // Synchroniser le menu
  const sel = $('#fn-select', host);
  if (sel) {
    sel.value = st._forced || 'auto';
    sel.onchange = () => {
      const ex = ($('#exo-select').value === 'ex2')
        ? window.REGISTRY.find(e=>e.id==='ex2')
        : window.REGISTRY.find(e=>e.id==='ex1');
      ex.gen($('#host'));
    };
  }
mountMenuIn(host);
if (window.MathJax?.typeset) MathJax.typeset();
}
// Convertit un petit TeX (fractions, exposants) en texte simple
function texToPlain(s){
  if(!s) return '';
  let t = String(s);
  t = t.replace(/\\frac\s*{([^}]*)}\s*{([^}]*)}/g, '($1)/($2)'); // \frac{a}{b} -> (a)/(b)
  t = t.replace(/\^{\s*([^}]*)\s*}/g, '^$1');                    // ^{2} -> ^2
  t = t.replace(/[{}]/g, '');                                   // enlève { }
  t = t.replace(/\\cdot|\\times/g, '*');                        // éventuels produits
  return t.replace(/\s+/g,' ').trim();
}
// k·h en TeX avec le bon signe : -h, h, 2h, 0…
const kTimesH = (k, h='h') => {
  if (!k) return '0';
  const s = k < 0 ? '-' : '';
  const a = Math.abs(k);
  return s + (a === 1 ? '' : a) + h;
};

/* —————————————————————— Limites + conclusion (100% LaTeX) —————————————————————— */
function pushConclusionLines(L, st, rhsTex){
  const point = (st.kind === 'ex1') ? String(st.n) : 'a';
  const P     = num(point);
  const frac  = Q(`f(${P}+h)-f(${P})`, 'h');
  const nice  = rhsTex || expectedExprToTeX(st, expectedExpression(st));
  const final = finalLimitTeX(st);

  // Étapes en LaTeX
  L.push(`<li>${wrap(`${LIM}\\, ${frac} = ${LIM}\\, ${nice}`)}</li>`);
  L.push(`<div class="sub">${wrap(`${LIM}\\, ${frac} = ${final}`)}</div>`);

  // Conclusion : texte HTML + formules en LaTeX
  const concl = `Donc ${wrap('f')} est dérivable en ${wrap(P)} ` +
                `et ${wrap(`f'(${P}) = ${final}`)}.`;
  L.push(`<li class="concl">${concl}</li>`);

  // ⭐ Remarque spécifique aux fonctions affines
  if (st.type === 'affine') {
    const m = st?.params?.m ?? 0;
    const remark =
      `Remarque : On savait que le taux de variation d'une fonction affine ` +
      `est son coefficient directeur. Ici ${wrap(`m = ${m}`)}, ` +
      `donc ${wrap(`f'(${P}) = ${m}`)}.`;
    L.push(`<li class="remark">${remark}</li>`);
  }
}









function wrapUL(L){ return '<ul class="math steps">'+L.join('')+'</ul>'; }

/* —————————————————————— Cas particuliers n=0 (mêmes étapes) —————————————————————— */

function solEX1_n0_carre(){
  const h='h'; const L=[]; const sub=t=>`<div class="sub">${wrap(t)}</div>`;
  L.push(`<li>${wrap('f(0)=0')}</li>`);
  L.push(`<li>${wrap(`f(0+${h}) = (0+${h})^{2}`)}</li>`);
  L.push(sub(`f(0+${h}) = ${h}^{2}`));
  L.push(`<li>${wrap(`f(0+${h})-f(0) = ${h}^{2}-0`)}</li>`);
  L.push(sub(`f(0+${h})-f(0) = ${h}^{2}`));
L.push(`<li>${pourHne0(h)}</li>`);
  L.push(sub(`${Q(`f(0+${h})-f(0)`,`h`)} = ${Q(`${h}^{2}`,'h')} = ${h}`));
  pushConclusionLines(L, {kind:'ex1',type:'carre',n:0,params:{}}, `${h}`);
  return wrapUL(L);
}

function solEX1_n0_cube(){
  const h='h'; const L=[]; const sub=t=>`<div class="sub">${wrap(t)}</div>`;
  L.push(`<li>${wrap('f(0)=0')}</li>`);
  L.push(`<li>${wrap(`f(0+${h}) = (0+${h})^{3}`)}</li>`);
  L.push(sub(`f(0+${h}) = ${h}^{3}`));
  L.push(`<li>${wrap(`f(0+${h})-f(0) = ${h}^{3}-0`)}</li>`);
  L.push(sub(`f(0+${h})-f(0) = ${h}^{3}`));
L.push(`<li>${pourHne0(h)}</li>`);
  L.push(sub(`${Q(`f(0+${h})-f(0)`,`h`)} = ${Q(`${h}^{3}`,'h')} = ${h}^{2}`));
  pushConclusionLines(L, {kind:'ex1',type:'cube',n:0,params:{}}, `${h}^{2}`);
  return wrapUL(L);
}

function solEX1_n0_affine(st){
  const h='h', { m, p } = st.params;
  const L=[]; const sub=t=>`<div class="sub">${wrap(t)}</div>`;
  const m0 = m===0 ? '0' : (m===1?'1':String(m));
  L.push(`<li>${wrap(`f(0) = ${m}\\times 0 ${p? (p<0?`- ${Math.abs(p)}`:`+ ${p}`):''}`)}</li>`);
  L.push(sub(`f(0) = ${p||0}`));
  const par = m===1 ? `(0+${h})` : (m===-1 ? `-(0+${h})` : `${m}(0+${h})`);
  L.push(`<li>${wrap(`f(0+${h}) = ${par}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`)}</li>`);
L.push(sub(`f(0+${h}) = ${kTimesH(m,h)}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`));
  const minusP = p<0 ? ` + ${Math.abs(p)}` : ` - ${p||0}`;
  L.push(`<li>${wrap(`f(0+${h}) - f(0) = ${m? (m===-1?`-${h}`:(m===1?`${h}`:`${Math.abs(m)}${h}`)):'0'}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}${minusP}`)}</li>`);
L.push(sub(`f(0+${h}) - f(0) = ${kTimesH(m,h)}`));
L.push(`<li>${pourHne0(h)}</li>`);
L.push(sub(`${Q(`f(0+${h})-f(0)`,'h')} = ${Q(kTimesH(m,h),'h')} = ${m}`));
  pushConclusionLines(L, st, `${m}`);
  return wrapUL(L);
}

function solEX1_n0_quad(st){
  const h='h', { a:A, b:B, c:C } = st.params;
  const L=[]; const sub=t=>`<div class="sub">${wrap(t)}</div>`;
  L.push(`<li>${wrap(`f(0) = ${C||0}`)}</li>`);
  // f(0+h)
  const tAh2 = A ? `${A===-1?'-':''}${Math.abs(A)===1?'':Math.abs(A)}${h}^{2}` : '';
  const tBh  = B ? `${B<0?'-':'+'} ${Math.abs(B)}${h}` : '';
  const tC   = C ? `${C<0?'-':'+'} ${Math.abs(C)}` : '';
  const f0h  = (tAh2 + (tBh? ` ${tBh}`:'') + (tC? ` ${tC}`:'')).replace(/^\+\s/,'') || '0';
  L.push(`<li>${wrap(`f(0+${h}) = ${f0h}`)}</li>`);
  const minusC = C<0 ? ` + ${Math.abs(C)}` : ` - ${C||0}`;
  L.push(`<li>${wrap(`f(0+${h}) - f(0) = ${f0h}${minusC}`)}</li>`);
  // simplification
  let diff = (tAh2 + (tBh? ` ${tBh}`:'')).replace(/^\+\s/,'') || '0';
  L.push(sub(`f(0+${h}) - f(0) = ${diff}`));
  const inside = `${A? (A<0?'-':'') + (Math.abs(A)===1?'':Math.abs(A)) + h : ''}${A&&B? (B<0?' - ':' + '):''}${B? Math.abs(B):''}`.replace(/^\s+/,'') || '0';
  L.push(sub(`f(0+${h}) - f(0) = ${h}\\,( ${inside} )`));
L.push(`<li>${pourHne0(h)}</li>`);
  L.push(sub(`${Q(`f(0+${h})-f(0)`,'h')} = ${Q(`${h}( ${inside} )`,'h')} = ${inside}`));
  pushConclusionLines(L, st, `${inside}`);
  return wrapUL(L);
}

/* —————————————————————— Solutions EX1 (général) —————————————————————— */

function solHTML_ex1(st){
  const h='h', type=st.type, n=(st.params && 'n' in st.params) ? st.params.n : (st.n ?? 0);
  if (st.n === 0) {
    if (type === 'affine')  return solEX1_n0_affine(st);
    if (type === 'quad')    return solEX1_n0_quad(st);
    if (type === 'carre')   return solEX1_n0_carre(st);
    if (type === 'cube')    return solEX1_n0_cube(st);
  }

  const u = x => String(x).replace(/-/g,'-');
  const L = []; const sub=t=>`<div class="sub">${wrap(t)}</div>`;
  let limRHS = '';

  switch(type){

    /* f(x) = x^2 */
    case 'carre': {
      const n2 = n*n, two_n = 2*n;

      L.push(`<li>${wrap(`f(${u(n)}) = ${texNumPar(n)}^{2}`)}</li>`);
      L.push(sub(`f(${u(n)}) = ${u(n2)}`));

      L.push(`<li>${wrap(`f(${u(n)}+${h}) = (${u(n)}+${h})^{2}`)}</li>`);
      L.push(sub(`f(${u(n)}+${h}) = ${u(n2)} ${two_n<0?'-':'+'} ${Math.abs(two_n)}${h} + ${h}^{2}`));
      L.push(sub(`f(${u(n)}+${h}) = ${h}^{2} ${two_n<0?'-':'+'} ${Math.abs(two_n)}${h} ${n2<0?'-':'+'} ${Math.abs(n2)}`));

      L.push(`<li>${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}^{2} ${two_n<0?'-':'+'} ${Math.abs(two_n)}${h} ${n2<0?'-':'+'} ${Math.abs(n2)} - ${u(n2)}`)}</li>`);
      L.push(sub(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}^{2} ${two_n<0?'-':'+'} ${Math.abs(two_n)}${h}`));
      L.push(sub(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}( ${h} ${two_n<0?'-':'+'} ${Math.abs(two_n)} )`));

L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(${u(n)}+${h}) - f(${u(n)})`,'h')} = ${Q(`${h}( ${h} ${two_n<0?'-':'+'} ${Math.abs(two_n)} )`,'h')} = ${h} ${two_n<0?'-':'+'} ${Math.abs(two_n)}`));
      limRHS = `${h} ${two_n<0?'-':'+'} ${Math.abs(two_n)}`;
      break;
    }

    /* f(x) = x^3 */
    case 'cube': {
      const n2=n*n, n3=n2*n;
      L.push(`<li>${wrap(`f(${u(n)}) = ${texNumPar(n)}^{3}`)}</li>`);
      L.push(sub(`f(${u(n)}) = ${u(n3)}`));

      L.push(`<li>${wrap(`f(${u(n)}+${h}) = (${u(n)}+${h})^{3}`)}</li>`);
      L.push(sub(`f(${u(n)}+${h}) = (${u(n)}+${h})^{2}(${u(n)}+${h})`));
      L.push(sub(`f(${u(n)}+${h}) = (${u(n2)} ${2*n<0?'-':'+'} ${Math.abs(2*n)}${h} + ${h}^{2})(${u(n)}+${h})`));
      L.push(sub(`f(${u(n)}+${h}) = ${h}^{3} ${3*n<0?'-':'+'} ${Math.abs(3*n)}a${h}^{2} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)}${h} ${n3<0?'-':'+'} ${Math.abs(n3)}`.replace(/a/g,''))); // garde la structure

      L.push(`<li>${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}^{3} ${3*n<0?'-':'+'} ${Math.abs(3*n)}${h}^{2} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)}${h} ${n3<0?'-':'+'} ${Math.abs(n3)} - (${u(n3)})`)}</li>`);
      L.push(sub(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}^{3} ${3*n<0?'-':'+'} ${Math.abs(3*n)}${h}^{2} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)}${h}`));
      L.push(sub(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}( ${h}^{2} ${3*n<0?'-':'+'} ${Math.abs(3*n)}${h} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)} )`));

L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(${u(n)}+${h}) - f(${u(n)})`,'h')} = ${Q(`${h}( ${h}^{2} ${3*n<0?'-':'+'} ${Math.abs(3*n)}${h} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)} )`,'h')} = ${h}^{2} ${3*n<0?'-':'+'} ${Math.abs(3*n)}${h} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)}`));
      limRHS = `${h}^{2} ${3*n<0?'-':'+'} ${Math.abs(3*n)}${h} ${3*n2<0?'-':'+'} ${Math.abs(3*n2)}`;
      break;
    }

    /* f(x) = 1/x */
    case 'inverse': {
      L.push(`<li>${wrap(`f(${u(n)}) = ${Q('1', u(n))}`)}</li>`);
      L.push(`<li>${wrap(`f(${u(n)}+${h}) = ${Q('1', `${u(n)}+${h}`)}`)}</li>`);
      L.push(`<li>${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${Q('1', `${u(n)}+${h}`)} - ${Q('1', u(n))}`)}</li>`);
      L.push(sub(`f(${u(n)}+${h}) - f(${u(n)})=${Q(u(n), `${u(n)}(${u(n)}+${h})`)} - ${Q(`${u(n)}+${h}`, `${u(n)}(${u(n)}+${h})`)} = ${Q(`${u(n)}-${u(n)}-${h}`, `${u(n)}(${u(n)}+${h})`)} = ${Q(`-${h}`, `${u(n)}(${u(n)}+${h})`)}`));
L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(${u(n)}+${h}) - f(${u(n)})`,'h')} = ${Q(`-${h}`, `${u(n)}(${u(n)}+${h})`)}\\times ${Q('1','h')} = ${Q('-1', `${u(n)}(${u(n)}+${h})`)}`));
      limRHS = `${Q('-1', `${u(n)}(${u(n)}+${h})`)}`;
      break;
    }

    /* f(x) = mx + p */
    case 'affine': {
      const m = st.params.m, p = st.params.p;
      const mn = m*n, f0 = mn + (p||0);
      L.push(`<li>${wrap(`f(${u(n)}) = ${m}\\times ${texNumPar(n)}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`)}</li>`);
      L.push(sub(`f(${u(n)}) = ${mn}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`));
      L.push(sub(`f(${u(n)}) = ${f0}`));

      L.push(`<li>${wrap(`f(${u(n)}+${h}) = ${m}(${u(n)}+${h})${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`)}</li>`);
      L.push(sub(`f(${u(n)}+${h}) = ${mn} ${m<0?'-':'+'} ${Math.abs(m)}${h}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`));

      const minusF0 = f0<0 ? ` + ${Math.abs(f0)}` : ` - ${f0}`;
	    const mh = kTimesH(m,h); // <-- NEW

      L.push(`<li>${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${mn} ${m<0?'-':'+'} ${Math.abs(m)}${h}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}${minusF0}`)}</li>`);
  L.push(sub(`f(${u(n)}+${h}) - f(${u(n)}) = ${mh}`));                       // <-- FIX
  L.push(`<li>${pourHne0(h)}</li>`);
  L.push(sub(`${Q(`f(${u(n)}+${h}) - f(${u(n)})`,'h')} = ${Q(mh,'h')} = ${m}`)); // <-- FIX
limRHS = `${m}`;
      break;
    }

    /* f(x) = Ax^2 + Bx + C */
    case 'quad': {
      const A=st.params.a, B=st.params.b, C=st.params.c;
      const n2=n*n, two_n=2*n, An2=A*n2, Bn=B*n, f0=(A?An2:0)+(B?Bn:0)+(C||0);

      // f(n)
      let line1 = '';
      if (A) line1 += (A===1?`${texNumPar(n)}^{2}`:A===-1?`-${texNumPar(n)}^{2}`:`${Math.abs(A)}${texNumPar(n)}^{2}`.replace(/^/,(A<0?'-':'')));
      if (A) line1 = (A===1?`${texNumPar(n)}^{2}`:A===-1?`-${texNumPar(n)}^{2}`:`${A}${texNumPar(n)}^{2}`);
      if (B) line1 += (line1?' ':'') + (B<0?`- ${Math.abs(B)}${texNumPar(n)}`:`+ ${B}${texNumPar(n)}`);
      if (C) line1 += (line1?' ':'') + (C<0?`- ${Math.abs(C)}`:`+ ${C}`);
      L.push(`<li>${wrap(`f(${u(n)}) = ${line1||'0'}`)}</li>`);

      // produits numériques
      const partA = A ? (A<0?'-':'') + (Math.abs(A)===1? `${n2}` : `${Math.abs(A)}\\times ${texNumPar(n2)}`) : '';
      const partB = B ? (Bn<0?` - ${Math.abs(Bn)}`:` + ${Math.abs(Bn)}`) : '';
      const partC = C ? (C<0?` - ${Math.abs(C)}`:` + ${Math.abs(C)}`) : '';
      if (A||B||C) L.push(`<div class="sub">${wrap(`f(${u(n)}) = ${(partA + partB + partC).replace(/^ \+ /,'')}`)}</div>`);
      L.push(`<div class="sub">${wrap(`f(${u(n)}) = ${u(f0)}`)}</div>`);

      // f(n+h) (tête)
      const headA = A ? `${A===1?'':A===-1?'-':A}(${u(n)}+${h})^{2}` : '';
      const headB = B ? `${B<0?'-':'+'} ${Math.abs(B)}(${u(n)}+${h})` : '';
      const headC = C ? `${C<0?'-':'+'} ${Math.abs(C)}` : '';
      const head = (headA + (headB?` ${headB}`:'') + (headC?` ${headC}`:'')).replace(/^\+\s/,'') || '0';
      L.push(`<li>${wrap(`f(${u(n)}+${h}) = ${head}`)}</li>`);

      // expansion
      const insideA = `${u(n2)} ${two_n<0?'-':'+'} ${Math.abs(two_n)}${h} + ${h}^{2}`;
      let mid = '';
      if (A) mid += (A===1?`(${insideA})`:A===-1?`-(${insideA})`:`${A}(${insideA})`);
      if (B) mid += (Bn<0?` - ${Math.abs(Bn)}`:` + ${Math.abs(Bn)}`) + (B<0?` - ${Math.abs(B)}${h}`:` + ${Math.abs(B)}${h}`);
      if (C) mid += (C<0?` - ${Math.abs(C)}`:` + ${Math.abs(C)}`);
      L.push(`<div class="sub">${wrap(`f(${u(n)}+${h}) = ${mid.replace(/^\+\s/,'')}`)}</div>`);

      // distribution & regroupement
      const A2n = A*two_n;
      let distA = '';
      if (A){
        distA = `${u(An2)}`;
        if (A2n) distA += ` ${A2n<0?'-':'+'} ${Math.abs(A2n)}${h}`;
        distA += ` ${A<0?'-':'+'} ${Math.abs(A)}${h}^{2}`;
      }
      const distB = B ? ` ${Bn<0?'-':'+'} ${Math.abs(Bn)} ${B<0?'-':'+'} ${Math.abs(B)}${h}` : '';
      L.push(`<div class="sub">${wrap(`f(${u(n)}+${h}) = ${(distA + distB + (C? ` ${C<0?'-':'+'} ${Math.abs(C)}` : '') ).replace(/^ \+ /,'')}`)}</div>`);

      // Regroupement Ah² + (2An+B)h + (An²+Bn+C)
      const Ah2=A, H1=2*A*n + (B||0), H0=f0;
      const termH2 = k => (Math.abs(k)===1? `${h}^{2}` : `${Math.abs(k)}${h}^{2}`);
      const termH1 = k => (Math.abs(k)===1? `${h}`     : `${Math.abs(k)}${h}`);
      const regroup = `${Ah2? (Ah2<0?'- ':'') + termH2(Ah2) : ''}${
         H1? (Ah2? (H1<0?' - ':' + '): (H1<0?'- ':'')) + termH1(H1) : ''}${
         H0? ((Ah2||H1)? (H0<0?' - ':' + '): (H0<0?'- ':'')) + `${Math.abs(H0)}` : ''}`.trim().replace(/^\+\s/,'');
      L.push(`<div class="sub">${wrap(`f(${u(n)}+${h}) = ${regroup}`)}</div>`);

      // différence
      const diffPoly = `${Ah2? (Ah2<0?'- ':'') + termH2(Ah2):''}${H1? (Ah2? (H1<0?' - ':' + '):(H1<0?'- ':'')) + termH1(H1):''}`.trim().replace(/^\+\s/,'') || '0';
      L.push(`<li>${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${regroup} ${H0<0?'+':'-'} ${Math.abs(H0)}`)}</li>`);
      L.push(`<div class="sub">${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${diffPoly}`)}</div>`);

      // factorisation
      const inside = `${Ah2? (Ah2<0?'- ':'') + termH1(Ah2) : ''}${H1? (Ah2? (H1<0?' - ':' + '):(H1<0?'- ':'')) + `${Math.abs(H1)}` : ''}`.trim().replace(/^\+\s/,'') || '0';
      L.push(`<div class="sub">${wrap(`f(${u(n)}+${h}) - f(${u(n)}) = ${h}( ${inside} )`)}</div>`);

      // quotient
L.push(`<li>${pourHne0(h)}</li>`);
      L.push(`<div class="sub">${wrap(`${Q(`f(${u(n)}+${h}) - f(${u(n)})`,'h')} = ${Q(`${h}( ${inside} )`,'h')} = ${inside}`)}</div>`);
      limRHS = `${inside}`;
      break;
    }
  }

  pushConclusionLines(L, st, limRHS);
  return wrapUL(L);
}

/* —————————————————————— Solutions EX2 (général) —————————————————————— */

function solHTML_ex2(st){
  const h='h';
  const L=[]; const sub=t=>`<div class="sub">${wrap(t)}</div>`;
  let limRHS = '';

  switch(st.type){

    case 'carre': {
      L.push(`<li>${wrap(`f(a)=a^{2}`)}</li>`);
      L.push(`<li>${wrap(`f(a+${h}) = (a+${h})^{2}`)}</li>`);
      L.push(sub(`f(a+${h}) = a^{2} + 2a${h} + ${h}^{2}`));
      L.push(sub(`f(a+${h}) = ${h}^{2} + 2a${h} + a^{2}`));
      L.push(`<li>${wrap(`f(a+${h})-f(a) = ${h}^{2} + 2a${h} + a^{2} - a^{2}`)}</li>`);
      L.push(sub(`f(a+${h})-f(a) = ${h}^{2} + 2a${h}`));
      L.push(sub(`f(a+${h})-f(a) = ${h}( ${h} + 2a )`));
L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(a+${h})-f(a)`,'h')} = ${Q(`${h}( ${h} + 2a )`,'h')} = ${h} + 2a`));
      limRHS = `${h} + 2a`;
      break;
    }

    case 'cube': {
      L.push(`<li>${wrap(`f(a)=a^{3}`)}</li>`);
      L.push(`<li>${wrap(`f(a+${h}) = (a+${h})^{3}`)}</li>`);
      L.push(sub(`f(a+${h}) = (a+${h})^{2}(a+${h})`));
      L.push(sub(`f(a+${h}) = (a^{2}+2a${h}+${h}^{2})(a+${h})`));
      L.push(sub(`f(a+${h}) = a^{3}+3a^{2}${h}+3a${h}^{2}+${h}^{3}`));
      L.push(sub(`f(a+${h}) = ${h}^{3}+3a${h}^{2}+3a^{2}${h}+a^{3}`));
      L.push(`<li>${wrap(`f(a+${h})-f(a) = ${h}^{3}+3a${h}^{2}+3a^{2}${h}+a^{3} - a^{3}`)}</li>`);
      L.push(sub(`f(a+${h})-f(a) = ${h}^{3}+3a${h}^{2}+3a^{2}${h}`));
      L.push(sub(`f(a+${h})-f(a) = ${h}( ${h}^{2}+3a${h}+3a^{2} )`));
L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(a+${h})-f(a)`,'h')} = ${Q(`${h}( ${h}^{2}+3a${h}+3a^{2})`,'h')} = ${h}^{2}+3a${h}+3a^{2}`));
      limRHS = `${h}^{2}+3a${h}+3a^{2}`;
      break;
    }

    case 'inverse': {
      L.push(`<li>${wrap(`f(a) = ${Q('1','a')}`)}</li>`);
      L.push(`<li>${wrap(`f(a+${h}) = ${Q('1',`a+${h}`)}`)}</li>`);
      L.push(`<li>${wrap(`f(a+${h}) - f(a) = ${Q('1',`a+${h}`)} - ${Q('1','a')}`)}</li>`);
      L.push(sub(`f(a+${h}) - f(a) =${Q('a','a(a+'+h+')')} - ${Q('a+'+h,'a(a+'+h+')')} = ${Q('a-a-'+h,'a(a+'+h+')')} = ${Q('-'+h,'a(a+'+h+')')}`));
L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(a+${h})-f(a)`,'h')} = ${Q('-'+h,'a(a+'+h+')')}\\times ${Q('1','h')} = ${Q('-1','a(a+'+h+')')}`));
      limRHS = `${Q('-1','a(a+'+h+')')}`;
      break;
    }

    case 'affine': {
      const m = st.params.m, p = st.params.p;
      L.push(`<li>${wrap(`f(a) = ${m}a${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`)}</li>`);
      L.push(`<li>${wrap(`f(a+${h}) = ${m}(a+${h})${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`)}</li>`);
      L.push(sub(`f(a+${h}) = ${m}a ${m<0?'-':'+'} ${Math.abs(m)}${h}${p? (p<0?` - ${Math.abs(p)}`:` + ${p}`):''}`));
      L.push(`<li>${wrap(`f(a+${h}) - f(a) = ${m}${h}`)}</li>`);
L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(a+${h})-f(a)`,'h')} = ${Q(`${m}${h}`,'h')} = ${m}`));
      limRHS = `${m}`;
      break;
    }

    case 'quad': {
      const A=st.params.a, B=st.params.b, C=st.params.c;
      const H1 = 2*A + (B? (B>0?` + ${B}`:` - ${Math.abs(B)}`) : '');
      L.push(`<li>${wrap(`f(a) = ${A? (A===1?'a^{2}':A===-1?'-a^{2}':`${A}a^{2}`):''}${B? (B<0?` - ${Math.abs(B)}a`:` + ${B}a`):''}${C? (C<0?` - ${Math.abs(C)}`:` + ${C}`):''}`.replace(/^ \+ /,''))}</li>`);
      L.push(`<li>${wrap(`f(a+${h}) = ${A? (A===1?'(a+${h})^{2}':A===-1?`-(a+${h})^{2}`:`${A}(a+${h})^{2}`):''}${B? (B<0?` - ${Math.abs(B)}(a+${h})`:` + ${B}(a+${h})`):''}${C? (C<0?` - ${Math.abs(C)}`:` + ${C}`):''}`.replace(/^ \+ /,''))}</li>`);
      L.push(sub(`f(a+${h}) = ${A? (A===1?`(a^{2}+2a${h}+${h}^{2})`:A===-1?`-(a^{2}+2a${h}+${h}^{2})`:`${A}(a^{2}+2a${h}+${h}^{2})`):''}${B? (B<0?` - ${Math.abs(B)}a - ${Math.abs(B)}${h}`:` + ${B}a + ${B}${h}`):''}${C? (C<0?` - ${Math.abs(C)}`:` + ${C}`):''}`.replace(/^ \+ /,'')));
      L.push(sub(`f(a+${h}) = ${A? `${A}a^{2} ${2*A<0?'-':'+'} ${Math.abs(2*A)}a${h} ${A<0?'-':'+'} ${Math.abs(A)}${h}^{2}`:''}${B? (B<0?` - ${Math.abs(B)}a ${B<0?'-':'+'} ${Math.abs(B)}${h}`:` + ${B}a + ${B}${h}`):''}${C? (C<0?` - ${Math.abs(C)}`:` + ${C}`):''}`.replace(/^ \+ /,'')));
      const regroup = `${A? `${A}${h}^{2}`:''}${(2*A||B)? `${(A? ' + ':'')}( ${2*A}a${B? (B<0?` - ${Math.abs(B)}`:` + ${B}`):''} )${h}`:''}${(A||B||C)? ` + (${A?`${A}a^{2}`:''}${B? (A? (B<0?` - ${Math.abs(B)}a`:` + ${B}a`): `${B<0?` - ${Math.abs(B)}a`:` + ${B}a`}`):''}${C? (A||B? (C<0?` - ${Math.abs(C)}`:` + ${C}`): `${C}`):''})`:''}`.replace(/^\s*\+\s*/,'');
      L.push(sub(`f(a+${h}) = ${regroup}`));

      const diff = `${A? `${A}${h}^{2}`:''}${(2*A||B)? `${A? ' + ':''}( ${2*A}a${B? (B<0?` - ${Math.abs(B)}`:` + ${B}`):''} )${h}`:''}`.replace(/^\s*\+\s*/,'') || '0';
      L.push(`<li>${wrap(`f(a+${h}) - f(a) = ${regroup} - ( ${A? (A===1?'a^{2}':A===-1?'-a^{2}':`${A}a^{2}`):''}${B? (B<0?` - ${Math.abs(B)}a`:` + ${B}a`):''}${C? (C<0?` - ${Math.abs(C)}`:` + ${C}`):''} )`.replace(/\s\+\s\)/,' )'))}</li>`);
      L.push(sub(`f(a+${h}) - f(a) = ${diff}`));

      const inside = `${A? `${A}${h}`:''}${(2*A||B)? `${A? ' + ':''}${2*A}a${B? (B<0?` - ${Math.abs(B)}`:` + ${B}`):''}`:''}`.replace(/^\s*\+\s*/,'') || '0';
      L.push(sub(`f(a+${h}) - f(a) = ${h}( ${inside} )`));

L.push(`<li>${pourHne0(h)}</li>`);
      L.push(sub(`${Q(`f(a+${h})-f(a)`,'h')} = ${Q(`${h}( ${inside} )`,'h')} = ${inside}`));
      limRHS = `${inside}`;
      break;
    }
  }

  pushConclusionLines(L, st, limRHS);
  return wrapUL(L);
}

/* —————————————————————— Helpers pour les limites finales —————————————————————— */
function expectedExprToTeX(st, expr){
  if(st.type==='inverse'){
    const den = (st.kind==='ex1') ? `${st.n}(${st.n}+h)` : 'a(a+h)';
    return Q('-1', den);
  }
  // expr déjà « algébrique » → on garde ^ et * qui seront compris ailleurs
  return String(expr)
    .replace(/\*/g,'')          // ah, 2a, etc.
    .replace(/\^/g,'^');        // conservé (MathJax le lit)
}

function finalLimitTeX(st){
  if(st.kind==='ex1'){
    const n = st.n;
    switch(st.type){
      case 'carre':  return String(2*n);
      case 'cube':   return String(3*n*n);
case 'inverse': {
  const d = Math.abs(n*n);
  return d === 1 ? '-1' : Q('-1', String(d));
}
      case 'affine': return String(st.params.m);
      case 'quad':   return String(2*st.params.a*n + (st.params.b||0));
    }
  } else {
    switch(st.type){
      case 'carre':  return '2a';
      case 'cube':   return '3a^{2}';
      case 'inverse':return Q('-1', 'a^{2}');
      case 'affine': return String(st.params.m);
      case 'quad': {
        const A=st.params.a, B=st.params.b;
        const sB = B ? (B>0 ? ` + ${B}` : ` - ${Math.abs(B)}`) : '';
        return `${2*A}a${sB}`;
      }
    }
  }
  return '';
}

/* —————————————————————— Vérification —————————————————————— */

function expectedFinalForCheck(st){
  if(st.kind==='ex1'){
    switch(st.type){
      case 'carre':   return String(2*st.n);
      case 'cube':    return String(3*st.n*st.n);
      case 'inverse': return `-1/${st.n*st.n}`;
      case 'affine':  return String(st.params.m);
      case 'quad':    return String(2*st.params.a*st.n + (st.params.b||0));
    }
  }else{
    const A = st.params.a, B = st.params.b, m = st.params.m;
    switch(st.type){
      case 'carre':   return `2*a`;
      case 'cube':    return `3*a^2`;
      case 'inverse': return `-1/a^2`;
      case 'affine':  return String(m);
      case 'quad':    return `${2*A}*a${B? (B>0? ' + '+B : ' - '+Math.abs(B)) : ''}`;
    }
  }
  return '';
}

function expectedExpression(st){
  const h='h';
  if(st.kind==='ex1'){
    const n=st.n;
    switch(st.type){
      case 'carre':   return `h + ${2*n}`;
      case 'cube':    return `3*${n}^2 + 3*${n}*h + h^2`;
      case 'inverse': return `-1/(${n}*(${n}+h))`;
      case 'affine':  return String(st.params.m);
      case 'quad': {
        const a=st.params.a, b=st.params.b;
        return `${a}*h + ( ${2*a*n}${b? (b>0? ' + '+b : ' - '+Math.abs(b)) : ''} )`;
      }
    }
  } else {
    switch(st.type){
      case 'carre':   return `h + 2*a`;
      case 'cube':    return `h^2 + 3*a*h + 3*a^2`;
      case 'inverse': return `-1/(a*(a+h))`;
      case 'affine':  return String(st.params.m);
      case 'quad': {
        const a=st.params.a, b=st.params.b;
        return `${a}*h + ( ${2*a}*a${b? (b>0? ' + '+b : ' - '+Math.abs(b)) : ''} )`;
      }
    }
  }
  return '';
}

function safeEval(expr){
  let s = String(expr).trim()
    .replace(/\u00A0/g, ' ')
    .replace(/\u2212/g, '-')
    .replace(/(\d),(\d)/g, '$1.$2');

  const SUP = {'\u2070':'0','\u00B9':'1','\u00B2':'2','\u00B3':'3',
               '\u2074':'4','\u2075':'5','\u2076':'6','\u2077':'7',
               '\u2078':'8','\u2079':'9'};
  s = s.replace(/([0-9a-zA-Z\)])\s*([⁰¹²³⁴⁵⁶⁷⁸⁹²³])/g, (_, base, sup) => {
    const d = SUP[sup] || '2'; return `${base}^${d}`;
  });

  s = s.replace(/\^/g, '**');
  s = s
    .replace(/(\d)\s*(?=[a-zA-Z(])/g, '$1*')
    .replace(/([a-zA-Z])\s*(?=\d)/g, '$1*')
    .replace(/([a-zA-Z])\s*(?=\()/g, '$1*')
    .replace(/\)\s*(?=[a-zA-Z(])/g, ')*')
    .replace(/([a-zA-Z])\s*(?=[a-zA-Z])/g, '$1*');

  if(!/^[0-9a-zA-Z\s\+\-\*\/\.\(\)]+$/.test(s)) throw new Error('caractères interdits');
  const f = new Function('h','a','n',`return (${s});`);
  return function(h,a,n){ return f(h,a,n); };
}

function verify(st){
  const inp = $('#ans'); const msg=$('#msg');
  const user = (inp.value||'').trim();
  if(!user){ msg.textContent='Entrez une expression.'; msg.className='msg ko'; return false; }

  let fuser;
  try{ fuser = safeEval(user,{}); }
  catch(e){ msg.textContent='Expression invalide.'; msg.className='msg ko'; return false; }

  const exp = expectedFinalForCheck(st);
  if(!exp){ msg.textContent='Erreur interne.'; msg.className='msg ko'; return false; }

  let ftrue;
  try{ ftrue = safeEval(exp,{}); }
  catch(e){ msg.textContent='Erreur interne.'; msg.className='msg ko'; return false; }

  let testsA;
  if(st.kind==='ex1'){
    testsA = [1];
  }else{
    testsA = [-3,-2,-1,-0.5,0.5,1,2,3].filter(a=>{
      if(st.type==='inverse') return Math.abs(a) > 1e-9;
      return true;
    });
  }

  for(const a0 of testsA){
    let u,v;
    try{ u = fuser(0, a0, st.n); v = ftrue(0, a0, st.n); }
    catch(e){ msg.textContent='Expression invalide.'; msg.className='msg ko'; return false; }
    if(!isFinite(u) || !isFinite(v)) continue;
    if(Math.abs(u - v) > 1e-6){
      msg.textContent='Incorrect.'; msg.className='msg ko'; return false;
    }
  }

  msg.textContent='Correct !'; msg.className='msg ok'; return true;
}

/* —————————————————————— REGISTRY —————————————————————— */

const REG = [
  {
    id:'ex1',
    title:'Exercice 1 — Entre n et n+h',
    gen(host){
      const st = genState_ex1();
      if (host) { host.dataset.state = JSON.stringify(st); renderEnonce(host, st); }
      return st;
    },
    render(host, st){
      const S = st || genState_ex1();
      host.dataset.state = JSON.stringify(S);
      renderEnonce(host, S);
    },
    solution(host, st){
  const S = st || JSON.parse(host.dataset.state || '{}');
  const box = $('#solution', host);
  box.style.display = 'block';
  box.innerHTML = (this.id==='ex2' ? solHTML_ex2(S) : solHTML_ex1(S));
  if (window.MathJax?.typeset) MathJax.typeset();
},


    reset(host){
      const box = $('#solution', host);
      box.style.display = 'none'; box.innerHTML = '';
      $('#ans', host).value = ''; $('#msg', host).textContent = '';
    }
  },
  {
    id:'ex2',
    title:'Exercice 2 — Entre a et a+h (général)',
    gen(host){
      const st = genState_ex2();
      if (host) { host.dataset.state = JSON.stringify(st); renderEnonce(host, st); }
      return st;
    },
    render(host, st){
      const S = st || genState_ex2();
      host.dataset.state = JSON.stringify(S);
      renderEnonce(host, S);
    },
    solution(host, st){
  const S = st || JSON.parse(host.dataset.state || '{}');
  const box = $('#solution', host);
  box.style.display = 'block';
  box.innerHTML = (this.id==='ex2' ? solHTML_ex2(S) : solHTML_ex1(S));
  if (window.MathJax?.typeset) MathJax.typeset();
},


    reset(host){
      const box = $('#solution', host);
      box.style.display = 'none'; box.innerHTML = '';
      $('#ans', host).value = ''; $('#msg', host).textContent = '';
    }
  }
];

window.REGISTRY = REG;

/* —————————————————————— Mount —————————————————————— */

function mount(){
  const sel=$("#exo-select");
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
  function render(){ const ex=get(); ex.gen($('#host')); }
  function sol(){ const ex=get(); ex.solution($('#host')); }
  function reset(){ const ex=get(); ex.reset($('#host')); }

  function check(){
    const st=JSON.parse($('#host').dataset.state||'{}');
    if(!st || !st.type){ $('#msg').textContent=''; return; }
    const ok = verify(st);
    const sc = $('#score');
    const [a,b] = sc.textContent.split('/').map(s=>+s.trim());
    sc.textContent = (a + (ok?1:0)) + ' / ' + (b+1);
  }

  sel.onchange=render; $('#btn-new').onclick=render;
  $('#btn-solution').onclick=sol;
  $('#btn-reset').onclick=reset;
  $('#btn-check').onclick=check;

  // Changement de fonction → régénère l’énoncé courant
  const fnSel = $('#fn-select');
  if(fnSel){ fnSel.onchange = render; }

  // Enter = vérifier
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      const a=$('#ans');
      if(a && document.activeElement===a) { e.preventDefault(); $('#btn-check').click(); }
    }
  });

  render();
}
document.addEventListener('DOMContentLoaded', mount);
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    ExoPDF.init({ mountAfterSelector: '#info-saisie' });
  });
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d’actions mobile
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn'; fallback.type = 'button'; fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si présent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
