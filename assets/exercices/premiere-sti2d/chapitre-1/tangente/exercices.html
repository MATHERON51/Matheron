<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1STI2D — Nombres dérivés & tangentes</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.code{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
/* Ticks de validation */
.tick{margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}
/* Ticks de validation */
.tick{
  display:none;           /* ← caché au départ */
  margin-left:.35rem;
  font-weight:700;
}
.tick.ok{ color:#11823b }
.tick.ko{ color:#b00020 }
/* Cache les ticks tant qu'ils ne sont ni ok ni ko */
.tick:not(.ok):not(.ko){ display:none !important; }

.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.frac{display:inline-flex;flex-direction:column;vertical-align:middle;line-height:1}
.frac>.num{border-bottom:1px solid #000;padding:0 .15em;text-align:center}
.frac>.den{padding:0 .15em;text-align:center}
/* PDF/print : éviter la disparition des barres de fraction */
@media print {
  .frac>.num{ border-bottom-width: 2px !important; }
}

/* Bonus : un peu plus visible aussi à l'écran sans être agressif */
.frac>.num{ border-bottom-width: 1.5px; }
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
/* Fraction plus robuste (ligne sous le numérateur) */
.frac{ display:inline-flex; flex-direction:column; align-items:stretch; line-height:1; }
.frac>.num,
.frac>.den{ display:block; text-align:center; padding:0 .2em; position:relative; }
.frac>.num{ border-bottom:1.5px solid currentColor; } /* écran : plus lisible */

/* Impression/PDF : certaines pipelines "mangent" les hairlines -> pseudo-ligne solide */
@media print{
  .frac>.num{ border-bottom:0 !important; }
  .frac>.num::after{
    content:"";
    position:absolute;
    left:0; right:0; bottom:-1px;
    height:2px;                    /* trait épais et visible */
    background:currentColor;
  }
}
@media print{
  /* transforme les champs en grands traits (si jamais ExoPDF n'est pas utilisé) */
  input, textarea, select{
    background: transparent !important;
    border: none !important;
    border-bottom: 2px solid #000 !important;  /* ← grand trait */
    color: transparent !important;             /* cache le texte/placeholder */
    caret-color: transparent !important;
    outline: none !important;
    height: 1.4em !important;
  }
  input::placeholder, textarea::placeholder{ color: transparent !important; }

  /* nettoie l'UI */
  .tick, .optionline, button, select, .kbd-host, .header, .controls{ 
    display: none !important; 
  }
}
/* Fallback universel : si l'input existe encore au moment du rendu PDF,
   on le masque et on montre un "grand trait" de même largeur. */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{
  display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline;
}

/* Impression / PDF (html2canvas, etc.) */
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
@media print{ .controls{display:none !important;} }

.svgbox{
  touch-action: manipulation;
  user-select: none;
}

</style>

<!-- Librairies communes MatHeron -->
<script src='../../../../js/math-kbd.js' defer></script>
<script>
/* ====== HERMITE5 – Générateur quintique Hermite sur repère interne [-6,6] ====== */
(function(global){
  "use strict";
  const UMINUS = '−';
  const RDEF = {xmin:-6,xmax:6,ymin:-6,ymax:6};
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rchoice(a){ return a[Math.floor(Math.random()*a.length)] }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
  function pickDistinctInt(a,b, forbid=new Set()){
    const pool=[]; for(let x=a;x<=b;x++) if(!forbid.has(x)) pool.push(x);
    return pool.length? rchoice(pool) : a;
  }
  const ZERO = {n:0n, d:1n}; const ONE  = {n:1n, d:1n};
  function rat(n, d=1n){ n=BigInt(n); d=BigInt(d); if(d===0n) throw Error('den=0'); if(d<0n){n=-n; d=-d;}
    const g=(a,b)=>{ a=a<0n?-a:a; b=b<0n?-b:b; while(b){ const t=a%b; a=b; b=t; } return a; };
    const gg=g(n<0n?-n:n, d); return {n:n/gg, d:d/gg};
  }
  function add(a,b){ return rat(a.n*b.d + b.n*a.d, a.d*b.d); }
  function mul(a,b){ return rat(a.n*b.n, a.d*b.d); }
  function div(a,b){ return rat(a.n*b.d, a.d*b.n); }
  function pConst(c){ return [c]; }
  function pAdd(a,b){ const n=Math.max(a.length,b.length); const out=Array.from({length:n},(_,i)=> add(a[i]||ZERO,b[i]||ZERO)); return out; }
  function pScale(a, s){ return a.map(c => mul(c,s)); }
  function pMul(a,b){ const out=Array.from({length:a.length+b.length-1},()=>ZERO);
    for(let i=0;i<a.length;i++) for(let j=0;j<b.length;j++) out[i+j]=add(out[i+j], mul(a[i],b[j]));
    return out;
  }
  function pEval(a, x){ let acc=rat(0n), X=rat(1n); for(let i=0;i<a.length;i++){ acc=add(acc, mul(a[i],X)); X=mul(X,x);} return acc; }
  function pDer(a){ if(a.length<=1) return [rat(0n)]; const out=[]; for(let i=1;i<a.length;i++) out.push( mul(a[i], rat(i,1n)) ); return out; }
  function xMinus(t){ return [rat(-BigInt(t),1n), rat(1n,1n)]; }
  function lagrangeBasis(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    let num = pMul( xMinus(others[0]), xMinus(others[1]) );
    const den = rat( (BigInt(xi)-BigInt(others[0])) * (BigInt(xi)-BigInt(others[1])) , 1n);
    return pScale(num, div(ONE, den));
  }
  function sumInv(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    const t1 = div(ONE, rat(BigInt(xi)-BigInt(others[0]),1n));
    const t2 = div(ONE, rat(BigInt(xi)-BigInt(others[1]),1n));
    return add(t1,t2);
  }
  function hermiteCardinals(xi, nodes){
    const L = lagrangeBasis(xi, nodes);
    const L2 = pMul(L,L);
    const Si = sumInv(xi, nodes);
    const P = pAdd( pConst(ONE), pScale( xMinus(xi), mul(rat(-2n), Si)) );
    const Hi0 = pMul(P, L2);
    const Hi1 = pMul( xMinus(xi), L2 );
    return {Hi0, Hi1};
  }
  function toVH(m){
    if(Number.isInteger(m)) return [m,1];
    const maxH = 7;
    for(let H=1; H<=maxH; H++){
      const V = Math.round(m*H);
      if(Math.abs(m - V/H) < 1e-6) return [V,H];
    }
    return null;
  }
  function buildPoly(a,b,c, m,k,l, n, q_num, q_den){
    const nodes=[a,b,c];
    const H0 = hermiteCardinals(a, nodes);
    const H1 = hermiteCardinals(b, nodes);
    const H2 = hermiteCardinals(c, nodes);
    const term0 = pScale(H0.Hi0, rat(BigInt(m),1n));
    const term1 = pScale(H0.Hi1, rat(0n,1n)); // f'(a)=0
    const term2 = pScale(H1.Hi0, rat(BigInt(k),1n));
    const term3 = pScale(H1.Hi1, rat(BigInt(n),1n));
    const term4 = pScale(H2.Hi0, rat(BigInt(l),1n));
    const term5 = pScale(H2.Hi1, rat(BigInt(q_num), BigInt(q_den)));
    let P = pConst(rat(0n)); [term0,term1,term2,term3,term4,term5].forEach(t => P=pAdd(P,t));
    return P;
  }
  function evalPolyNum(P, x){ let y=0; for(let i=P.length-1;i>=0;i--) y = y*x + (Number(P[i].n)/Number(P[i].d)); return y; }
  function okInView(P, R){
    const steps = Math.round((R.xmax-R.xmin)*50);
    for(let i=0;i<=steps;i++){
      const x = R.xmin + i*(R.xmax-R.xmin)/steps;
      let y=0; for(let j=P.length-1;j>=0;j--) y = y*x + (Number(P[j].n)/Number(P[j].d));
      if(!Number.isFinite(y)) return false;
      if(y<R.ymin-1e-9 || y>R.ymax+1e-9) return false;
    }
    return true;
  }
  function generate(opts={}){
  const R    = opts.R || RDEF;
  const MAG  = opts.mag ?? 5;
  const DENM = Math.max(2, opts.denMax ?? 4);

  let tries = 0;
  let GAP   = (typeof opts.gap === 'number') ? opts.gap : 2; // démarre à 2

  while (tries++ < 6000){                       // ← plus large que 1200
    let a = pickDistinctInt(R.xmin+1, R.xmax-1);
    let b = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a]));
    let c = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a,b]));
    [a,b,c] = [a,b,c].sort((u,v)=>u-v);

    let m = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1); // y_A
    let k = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1); // y_B
    let l = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1); // y_C

    // A ne partage JAMAIS sa hauteur
    if (k === m || l === m) continue;
    if (Math.abs(k - m) < GAP || Math.abs(l - m) < GAP) continue;

    // reste de tes tirages
    let n = rchoice([-3,-2,-1,1,2,3]);
    let H = rchoice([2,3,4,5].filter(h=>h<=DENM));
    let Vcands = [-5,-4,-3,-2,-1,1,2,3,4,5].filter(v => (v%H)!==0);
    let V = rchoice(Vcands);

    if(!(c+H<=R.xmax && l+V>=R.ymin && l+V<=R.ymax)) continue;

    const P  = buildPoly(a,b,c, m,k,l, n, V, H);
    if(!okInView(P,R)) continue;

    const dP = pDer(P);
    const f  = x => evalPolyNum(P,x);
    const df = x => evalPolyNum(dP,x);

    const A  = {x:a, y:m,   m:0};
    const B  = {x:b, y:k,   m:n};
    const C  = {x:c, y:l,   m:V/H};

    // re-check sécurité
    if (A.y === B.y || A.y === C.y) continue;

    // échantillonnage pour le tracé
    const xs=[], grid=[5,4,4,5];
    const segments=[[R.xmin,A.x],[A.x,B.x],[B.x,C.x],[C.x,R.xmax]];
    for(let s=0;s<4;s++){
      const [x0,x1]=segments[s], npts=grid[s];
      for(let i=0;i<npts;i++){
        const t=(i+1)/(npts+1), x=x0+t*(x1-x0), y=f(x);
        xs.push([Math.round(x*1000)/1000, Math.round(y*1000)/1000]);
      }
    }
    return {R, f, df, A, B, C, VH:[V,H], pts20: xs};
  }

  // Phase 2 : si ça coince, on relâche un peu le GAP puis on retente
  if (GAP > 0) return generate({...opts, gap:GAP-1});

      // Fallback ultime (très rare) : on garantit y_C ≠ y_A
  const f=x=>0, df=x=>0;
  return {
    R:RDEF,
    f, df,
    A:{x:-2,y:1,m:0},
    B:{x:0, y:0,m:1},
    C:{x:3, y:2,m:1/2},     // ← y différent de A
    VH:[1,2],
    pts20:[]
  };
}

  global.HERMITE5 = { generate, toVH, RDEF };
})(window);
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D — <strong>Nombres dérivés & tangentes</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-sol" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <div id="host" class="card" data-active="" data-state=""></div>

<div class="card small" id="info-saisie">
  <strong>Saisie & réponses acceptées :</strong>

	    <li>Attention : Si vous voyez une ligne horizontale rouge : Cliquez sur nouvel énoncé</li>
        <li>Division : saisir en <span class="code">a/b</span> ; puissances : <span class="code">x^2</span> (affichage en <span class="code">x²</span>).</li>
        <li>Équations de droites : vous pouvez écrire <span class="code">y = mx + p</span> ou <span class="code">y - y_A = m(x - x_A)</span>. Les formes algébriquement équivalentes sont acceptées.</li>
        <li>Le signe <b>−</b> affiché est le « grand moins » (Unicode). La saisie accepte <span class="code">-</span> classique.</li>
        </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>


   
  </div>

<script>
/* =========== Outils génériques =========== */

/* ==== Canonisation d'affichage (signes, ×, doublons) ==== */
const UMINUS = '−'; // (déjà défini chez toi, laissé ici pour clarté)

/* 1) Normalise les suites de signes */
/* 1) Normalise les suites de signes (sans --, -+, +- etc.) */
function normalizeSignsStr(s){
  const U = UMINUS; // '−'
  s = String(s)
    // 0) Unifie tous les tirets en « grand moins »
    .replace(/[–—\-]/g, U)

    // 1) Réduit les doubles signes (indépendant des espaces)
    .replace(/\+\s*\+/g, ' + ')
    .replace(/−\s*−/g, ' + ')
    .replace(/\+\s*−/g, ` ${U} `)
    .replace(/−\s*\+/g, ` ${U} `)

    // 2) Nettoyage autour de "=" et parenthèses (évite "= +", "( +", etc.)
    .replace(/=\s*\+/g, '= ')
    .replace(/\(\s*\+/g, '(')

    // 3) Espaces propres
    .replace(/\s+/g, ' ')
    .replace(/\s+([\)\],;:])/g,'$1')
    .replace(/([\(\[])\s+/g,'$1');

  return s;
}
/* === [AJOUT GLOBAL, une seule fois] : re-typeset MathJax après injection === */
function retypeMath(scope){
  if (!window.MathJax) return;
  const node = scope || document;
  if (MathJax.typesetPromise) { MathJax.typesetPromise([node]); }
  else if (MathJax.typeset)   { MathJax.typeset([node]); }
}

/* 2) Forçage des multiplications explicites "×" là où nécessaire */

// Remplace TOUTE ancienne version de forceTimesStr par ceci :
function timesNumbersOnly(s){
  s = String(s);

  // 0) Nettoyage : on enlève toute * ou × indésirable devant x, ( ... ) non numérique, ou √
  s = s.replace(/(\d)\s*[\*×]\s*x\b/g, '$1x');  // 3*x → 3x ; 3×x → 3x
  s = s.replace(/(\d)\s*[\*×]\s*√/g, '$1√');    // 3*√x → 3√x ; 3×√x → 3√x
  s = s.replace(/(\d)\s*[\*×]\s*\(/g, '$1(');   // 3*( … ) → 3( … ) (on ré-insèrera × si ( … ) est numérique)

  // 1) × entre nombres séparés par un espace : "3 4" → "3 × 4"
  s = s.replace(/(\d)\s+(?=\d)/g, '$1 × ');

  // 2) × entre nombre et ( … ) si le contenu est PUREMENT NUMÉRIQUE
  //    (signes + décimales autorisés) : "5(2)" → "5 × (2)", "3(−3)" → "3 × (−3)"
  s = s.replace(/(\d)\s*(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))/g, '$1 × $2');

  // 3) × entre ( … ) numérique et nombre : "(2)3" → "(2) × 3"
  s = s.replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*(\d)/g, '$1 × $2');

  return s;
}



/* 3) Supprime les répétitions du type "= 3 = 3" ou "= −5 = −5" (anti-doublon inline) */
function dedupInlineEquals(s){
  // nombres entiers/décimaux
  s = s.replace(/=\s*([−\-]?\d+(?:[.,]\d+)?)\s*=\s*\1\b/g, '= $1');
  // cas très courant : fraction "a/b = a/b" (quand elle n'est pas encore mise en pile)
  s = s.replace(/=\s*([−\-]?\d+\/\d+)\s*=\s*\1\b/g, '= $1');
  return s;
}

/* 4) Post-traitement HTML des blocs d'étapes .steps */
function canonMathHTML(html){
  let s = String(html);
  s = timesNumbersOnly(s); // ← important : ne pas utiliser d'autres "forceTimes"
  s = normalizeSignsStr(s);
  s = dedupInlineEquals(s);
  s = s.replace(/(\d)\s*\*\s*(\d)/g, '$1 × $2') // * entre nombres -> ×
     .replace(/(\d)\s*\*\s*x\b/g, '$1x')
     .replace(/(\d)\s*\*\s*√/g, '$1√')
     .replace(/(\d)\s*\*\s*\(/g, '$1(');

  return s;
}

/* 5) Passe le peigne sur tous les blocs .steps d'un host */
function canonizeAllSteps(host){
  $$('.steps', host).forEach(el => {
    el.innerHTML = canonMathHTML(el.innerHTML);
  });
}


const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const rnd   = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const rchoice = L => L[rnd(0,L.length-1)];
const fmtNum = v => (Math.abs(v)===Infinity? '∞' : (Number.isInteger(v)? String(v) : String(Math.round(v*1000)/1000).replace('.',',')));
const normMinus = s => String(s||'').replace(/−/g,'-').trim();

function parseNum(s){
  s = normMinus(String(s).replace(',','.'));
  if(!s) return NaN;
  if(/^\s*ND\s*$/i.test(s)) return NaN;
  if(s.includes('/')){
    const [a,b] = s.split('/').map(x=>parseFloat(x));
    if(!isFinite(a) || !isFinite(b) || b===0) return NaN;
    return a/b;
  }
  return parseFloat(s);
}

function eqNum(a,b,tol=1e-6){
  if(!Number.isFinite(a) || !Number.isFinite(b)) return null; // neutre
  return Math.abs(a-b)<=tol;
}

/* ===== Ticks (neutre caché) ===== */
function setTick(el,val){
  if(!el) return;
  if(val===true){  el.textContent='✓'; el.classList.add('ok'); el.classList.remove('ko'); el.style.display='inline'; }
  else if(val===false){ el.textContent='✕'; el.classList.add('ko'); el.classList.remove('ok'); el.style.display='inline'; }
  else { el.textContent=''; el.classList.remove('ok','ko'); el.style.display='none'; } // neutre caché
}

/* =========== Fractions & formats (pile partout) =========== */
function fracHTML(V,H){
  return `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`;
}

// -> [V,H] réduit si possible via HERMITE5.toVH ; sinon entier
// -> [V,H] réduit si possible via HERMITE5.toVH ; sinon approx rationnelle (den ≤ 24)
function slopeVH(m){
  const vh = (window.HERMITE5 && HERMITE5.toVH) ? HERMITE5.toVH(m) : null;
  if (vh) return vh;                       // cas "classique"
  for (let H = 1; H <= 24; H++){           // fallback : fraction simple
    const V = Math.round(m * H);
    if (Math.abs(m - V/H) < 1e-12) return reduce(V, H);
  }
  return [Math.round(m), 1];               // dernier recours (entier)
}


// V/H en pile (même si 2/1)
function vhHTML(m){ const [V,H]=slopeVH(m); return fracHTML(V,H); }

// f'(a) : entier si H=1, sinon fraction en pile (jamais “/1”)
function fprimeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }
// Rétro-compat : certains blocs appellent encore fprimeHTML_strict
const fprimeHTML_strict = fprimeHTML;

// Phrase “pentes” : 0 → “0 (tangente horizontale)”, entier ≠0 → “(−1/1) = −1”, sinon fraction pile
// --- PATCH fprimeForSentence (zéro doublon ; entier si /1) ---
function fprimeForSentence(m){
  const [V,H]=slopeVH(m);
  if(V===0) return '0 (tangente horizontale)';
  return (H===1) ? String(V) : fracHTML(V,H);
}


// Affichage générique d’une pente (pile ou entier)
function fmtSlopeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }

/* =========== Parsers stricts (pas de décimales) =========== */
// “a/b” uniquement (existante, conservée)
function parseFracStrict(s){
  s = normMinus(String(s).replace(',','.')).trim();
  if(!/^[+-]?\d+\s*\/\s*[1-9]\d*$/.test(s)) return null;
  const [A,B] = s.split('/').map(t=>parseInt(t.replace(/\s+/g,''),10));
  if(!Number.isFinite(A) || !Number.isFinite(B) || B===0) return null;
  return {a:A, b:B, val:A/B};
}

// entier strict (pas de fraction, pas de décimal)
function parseIntStrict(s){
  s = normMinus(String(s||'').trim());
  if(!/^[+-]?\d+$/.test(s)) return null;
  return parseInt(s,10);
}

// PGCD + réduction
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function reduce(n,d){ if(d<0){ n=-n; d=-d; } const g=gcd(n,d); return [n/g,d/g]; }

// entier OU fraction “a/b” → [N,D] réduit (null sinon)
function parseRatStrict(s){
  s = normMinus(String(s||'').trim());
  if(/^[+-]?\d+$/.test(s)) return [parseInt(s,10),1];
  const fr=parseFracStrict(s);
  return fr ? reduce(fr.a, fr.b) : null;
}
// décimal exact / entier / fraction -> [N,D] réduit, sinon null
function parseRatOrDecStrict(s){
  s = normMinus(String(s||'').trim());
  if(!s) return null;

  // entier
  if(/^[+\-]?\d+$/.test(s)) return [parseInt(s,10), 1];

  // fraction a/b
  const fr = parseFracStrict(s);
  if(fr) return reduce(fr.a, fr.b);

  // décimal fini (.,)
  if(/^[+\-]?\d+[.,]\d+$/.test(s)){
    const neg = s.startsWith('-');
    const t = s.replace('+','').replace('-','').replace(',','.');
    const [A,B] = t.split('.');
    const num = parseInt(A + B, 10);
    const den = 10 ** B.length;
    return reduce(neg ? -num : num, den);
  }
  return null;
}

// pour les coefficients devant x : '', '+', '-', '(…)','-(…)', nombres…
function parseCoeff(tok){
  tok = String(tok||'');
  if(tok==='' || tok==='+') return [ 1,1 ];
  if(tok==='-')             return [-1,1 ];

  // signe extérieur possible : '-(1/2)'
  let sign = 1;
  if(tok.startsWith('+(') && tok.endsWith(')')) tok = tok.slice(2,-1);
  else if(tok.startsWith('-(') && tok.endsWith(')')){ sign=-1; tok = tok.slice(2,-1); }

  // enlève des paires de parenthèses externes : '(1/2)' -> '1/2'
  while(tok.startsWith('(') && tok.endsWith(')')) tok = tok.slice(1,-1);

  const r = parseRatOrDecStrict(tok);
  return r ? reduce(sign*r[0], r[1]) : null;
}

// remplace l’ancienne slopeOKStrict
function slopeOKStrict(input, expected){
  input = String(input||'').trim();
  if(input==='') return null;                  // champ vide → tick neutre

  const rat = parseRatOrDecStrict(input);      // entier, fraction ou décimal exact
  if(!rat) return false;

  const [V,H] = slopeVH(expected);             // valeur attendue (réduite)
  const R = reduce(rat[0], rat[1]);            // valeur saisie (réduite)
  return (R[0] === V && R[1] === H);
}


/* ====== Équations de droites ====== */
// parties d’affichage : m·x et +p en pile
function mxHTML([V,H]){
  const sgn = V<0 ? '−' : '';
  const A = Math.abs(V);
  if(H===1 && A===1) return `${sgn}x`;
  return `${(H===1)? String(V) : fracHTML(V,H)}x`;
}
function signedRatHTML([N,D]){
  if(N===0) return ' + 0';
  const s = (N<0) ? ' − ' : ' + ';
  const A = Math.abs(N);
  return s + ((D===1)? String(A) : fracHTML(A,D));
}
// Affiche une rationnelle [N,D] en entier ou fraction pile
function ratHTML([N,D]){
  const R = reduce(N,D);
  return (R[1] === 1) ? String(R[0]) : fracHTML(R[0], R[1]);
}

// Équation joliment formatée : pas de “+ 0” / “− 0”, gère m = 0 et ±x
function eqHTML(mVH, pVH){
  const M = reduce(mVH[0], mVH[1]);
  const P = reduce(pVH[0], pVH[1]);

  // y = p si m = 0
  if (M[0] === 0) return `y = ${ratHTML(P)}`;

  // y = mx (+ p) sinon (sans afficher +0)
  const mx = mxHTML(M);                  // déjà “−x” quand ±1
  if (P[0] === 0) return `y = ${mx}`;    // pas de +0

  const sign = (P[0] < 0) ? ' − ' : ' + ';
  const pAbs = [Math.abs(P[0]), P[1]];
  return `y = ${mx}${sign}${ratHTML(pAbs)}`;
}

// p = y - (V/H) x  en fraction réduite
function pFromPoint(V,H,x,y){ return reduce(y*H - V*x, H); }

// outils d’affichage/ratios déjà présents :
/* gcd, reduce, slopeVH, parseRatOrDecStrict, mxHTML, signedRatHTML, pFromPoint */

// remplace l’ancienne lineOKStrict
function lineOKStrict(expr, mVH, pVH){
  expr = normMinus(String(expr||'')).replace(/\s+/g,'');
  if(!expr || !expr.startsWith('y=')) return false;
  const rhs = expr.slice(2);

  // motif commun pour un coefficient devant x : vide / signe / nombre (avec () possibles)
  const COEF_RE = '([+\\-]?(?:\\(?\\d+(?:\\/[1-9]\\d*)?\\)?|\\(?\\d+(?:[.,]\\d+)?\\)?)*?)';
  const RAT_RE  = '([+\\-]?(?:\\d+(?:\\/[1-9]\\d*)?|\\d+(?:[.,]\\d+)?))';

  let m=null, p=null;

  // 0) y = p (constante)
  let m0 = rhs.match(new RegExp('^'+RAT_RE+'$'));
  if(m0){ m=[0,1]; p=parseRatOrDecStrict(m0[1]); }

  // 1) y = m x + p    (m peut être '', '+', '-', '1/2', '(1/2)', '-(1/2)', etc.)
  if(!m || !p){
    let m1 = rhs.match(new RegExp('^'+COEF_RE+'x([+\\-])'+RAT_RE+'$'));
    if(m1){
      const mTok=m1[1], sign=m1[2], pTok=m1[3];
      m = parseCoeff(mTok);
      p = parseRatOrDecStrict((sign==='-'?'-':'')+pTok);
    }
  }

  // 2) y = p + m x
  if(!m || !p){
    let m2 = rhs.match(new RegExp('^'+RAT_RE+'([+\\-])'+COEF_RE+'x$'));
    if(m2){
      const pTok=m2[1], sign=m2[2], mTok=m2[3];
      p = parseRatOrDecStrict(pTok);
      m = parseCoeff((sign==='-'?'-':'')+mTok);
    }
  }

  // 3) y = m(x ± a) ± yA  (a,yA entiers ; m rationnel/entier/décimal exact)
  if(!m || !p){
    let m3 = rhs.match(new RegExp('^'+COEF_RE+'\\((?:x)([+\\-])(\\d+)\\)([+\\-])(\\d+)$'));
    if(m3){
      const mTok=m3[1], s1=m3[2], aTok=m3[3], s2=m3[4], yATok=m3[5];
      const mRat = parseCoeff(mTok); if(!mRat) return false;
      const a = parseInt(aTok,10), yA = parseInt(yATok,10);
      if(!Number.isInteger(a) || !Number.isInteger(yA)) return false;
      const aEff  = (s1==='-') ? a : -a;           // x - a  / x + a
      const yEff  = (s2==='-') ? -yA :  yA;        // + yA / - yA
      // y = m x + (yEff - m*aEff)
      const pRat = reduce(yEff*mRat[1] - mRat[0]*aEff, mRat[1]);
      m = mRat; p = pRat;
    }
  }

  if(!m || !p) return false;

  // comparaison rationnelle exacte
  const M   = reduce(m[0], m[1]);
  const P   = reduce(p[0], p[1]);
  const Mxp = reduce(mVH[0], mVH[1]);
  const Pxp = reduce(pVH[0], pVH[1]);
  return (M[0]===Mxp[0] && M[1]===Mxp[1] && P[0]===Pxp[0] && P[1]===Pxp[1]);
}



/* ====== Vérif “souple” (utile pour d’autres exos si tu veux la garder) ====== */
/* ===== Vérif “souple” — accepte 4x, -1x, 2(x-3), x(x+1), etc. ===== */
function parseUserLine(expr){
  // normalisations de base
  let rhs = normMinus(String(expr||'')).trim();   // remplace « − » par '-'
  if(!rhs) return null;

  // retirer un éventuel "y=" au début
  rhs = rhs.replace(/\s+/g,'');
  rhs = rhs.startsWith('y=') ? rhs.slice(2) : rhs;

  // caret -> ** (au cas où), et signes exotiques
  rhs = rhs.replace(/\^/g,'**')
           .replace(/[×·•]/g,'*')
           .replace(/,/g,'.');

  // ---- Multiplications implicites ----
  // 4x   -> 4*x
  rhs = rhs.replace(/(\d)\s*x\b/g, '$1*x');
  // )x   -> )*x
  rhs = rhs.replace(/\)\s*x\b/g, ')*x');
  // x(   -> x*( 
  rhs = rhs.replace(/\bx\s*\(/g, 'x*(');
  // 2(   -> 2*(
  rhs = rhs.replace(/(\d)\s*\(/g, '$1*(');
  // )(   -> )*(
  rhs = rhs.replace(/\)\s*\(/g, ')*(');

  // JS n’aime pas "-x**2" (pas utile ici, mais harmless)
  rhs = rhs.replace(/(^|[^\w\)])-\s*(x\s*\*\*\s*\d+)/g, '$1-($2)');

  try{
    const f = new Function('x','return ('+rhs+');');
    return (x)=> f(x);
  }catch(e){
    return null;
  }
}

// ===== Vérif "souple" mais OBLIGE 'y=' en tête =====
function isSameLine(userExpr, m, p){
  const raw = String(userExpr || '');
  const normalized = normMinus(raw).replace(/\s+/g, '');

  // ⛔️ on n'accepte pas sans 'y='
  if (!/^y=/.test(normalized)) return false;

  const f = parseUserLine(raw);   // garde la tolérance 4x, 2(x-3), etc.
  if(!f) return false;

  const xs = [-5,-3,-1,0,2,4];
  try{
    return xs.every(x => {
      const yu = f(x);
      const y  = m*x + p;
      return Number.isFinite(yu) && Math.abs(yu - y) <= 1e-3;
    });
  }catch(e){ return false; }
}


/* =========== Repère (SVG) =========== */
/* =========== Repère (SVG) =========== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.el=this._makeSVG();
    this.gGrid=this.el.querySelector('g[data-layer="grid"]');
    this.gAxes=this.el.querySelector('g[data-layer="axes"]');
    this.gGeom=this.el.querySelector('g[data-layer="geom"]');
    this.gUser=this.el.querySelector('g[data-layer="user"]');
    this._labelRects = [];               // mémoires des bbox des labels posés
    this.redraw();
  }
  _makeSVG(){
    const s=document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
	s.setAttribute('preserveAspectRatio','xMidYMid meet');
    const layers=['grid','axes','geom','user'];
    layers.forEach(L=>{
      const g=document.createElementNS(s.namespaceURI,'g'); g.dataset.layer=L; s.appendChild(g);
    });
    return s;
  }
  coordToScreen(x,y){
    const R=this.R, w=420, h=420;
    const X=(x-R.xmin)/(R.xmax-R.xmin)*w;
    const Y=h-(y-R.ymin)/(R.ymax-R.ymin)*h;
    return {x:X,y:Y};
  }
  screenToCoord(X,Y){
    const R=this.R, w=420, h=420;
    const x=R.xmin + X/w*(R.xmax-R.xmin);
    const y=R.ymin + (h-Y)/h*(R.ymax-R.ymin);
    return {x,y};
  }
  redraw(){
    const R=this.R;
    const w=420,h=420;
    this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gGeom.innerHTML=''; this.gUser.innerHTML='';
    this._labelRects = []; // reset anti-collisions

    // grille
    const mkLine=(x1,y1,x2,y2,thick=false)=>{
      const L=document.createElementNS(this.el.namespaceURI,'line');
      L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2);
      L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); L.setAttribute('opacity',thick?1:.35);
      return L;
    };
    for(let t=R.xmin;t<=R.xmax;t++){
      const P1=this.coordToScreen(t,R.ymin), P2=this.coordToScreen(t,R.ymax);
      this.gGrid.appendChild(mkLine(P1.x,P1.y,P2.x,P2.y));
    }
    for(let t=R.ymin;t<=R.ymax;t++){
      const P1=this.coordToScreen(R.xmin,t), P2=this.coordToScreen(R.xmax,t);
      this.gGrid.appendChild(mkLine(P1.x,P1.y,P2.x,P2.y));
    }
    // axes
    const A1=this.coordToScreen(R.xmin,0), A2=this.coordToScreen(R.xmax,0);
    const B1=this.coordToScreen(0,R.ymin), B2=this.coordToScreen(0,R.ymax);
    this.gAxes.appendChild(mkLine(A1.x,A1.y,A2.x,A2.y,true));
    this.gAxes.appendChild(mkLine(B1.x,B1.y,B2.x,B2.y,true));

    // O, I, J
    const mkPt=(x,y)=>{
      const g=document.createElementNS(this.el.namespaceURI,'g');
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','4'); c.setAttribute('fill','#000');
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','12'); t.setAttribute('fill','#000'); t.setAttribute('dominant-baseline','central');
      const P=this.coordToScreen(x,y); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
      g.appendChild(c); g.appendChild(t);
      return {g,c,t,P};
    };
    const O=mkPt(0,0);  O.t.textContent='O'; this.gAxes.appendChild(O.g);
    const I=mkPt(1,0);  I.t.textContent='I'; this.gAxes.appendChild(I.g);
    const J=mkPt(0,1);  J.t.textContent='J'; this.gAxes.appendChild(J.g);

    // placement O/I/J avec anti-collision
    this._placeLabel(O.t, O.P.x, O.P.y);
    this._placeLabel(I.t, I.P.x, I.P.y);
    this._placeLabel(J.t, J.P.x, J.P.y);

    /* === Graduations === */
    const TICK=6, u = s=>String(s).replace(/-/g,UMINUS);
    const P0=this.coordToScreen(0,0);

    // graduations axe X
    if (R.ymin <= 0 && 0 <= R.ymax){
      const Y0 = P0.y;
      for (let t=Math.ceil(R.xmin); t<=Math.floor(R.xmax); t++){
        const Px = this.coordToScreen(t,0).x;
        const tick=document.createElementNS(this.el.namespaceURI,'line');
        tick.setAttribute('x1',Px); tick.setAttribute('x2',Px);
        tick.setAttribute('y1',Y0-TICK); tick.setAttribute('y2',Y0+TICK);
        tick.setAttribute('stroke','#000'); tick.setAttribute('stroke-width','1.2');
        this.gAxes.appendChild(tick);
        if(t!==0){
          const lab=document.createElementNS(this.el.namespaceURI,'text');
          lab.setAttribute('x',Px);
          const yOff = (Y0 > h - 18) ? -12 : 10;
          lab.setAttribute('y',Y0 + yOff);
          lab.setAttribute('font-size','12'); lab.setAttribute('fill','#333');
          lab.setAttribute('text-anchor','middle');
          if(yOff>0) lab.setAttribute('dominant-baseline','hanging');
          lab.textContent = u(t);
          this.gAxes.appendChild(lab);
          this._registerLabel(lab);
        }
      }
    }
    // graduations axe Y
    if (R.xmin <= 0 && 0 <= R.xmax){
      const X0 = P0.x;
      for (let t=Math.ceil(R.ymin); t<=Math.floor(R.ymax); t++){
        const Py = this.coordToScreen(0,t).y;
        const tick=document.createElementNS(this.el.namespaceURI,'line');
        tick.setAttribute('y1',Py); tick.setAttribute('y2',Py);
        tick.setAttribute('x1',X0-TICK); tick.setAttribute('x2',X0+TICK);
        tick.setAttribute('stroke','#000'); tick.setAttribute('stroke-width','1.2');
        this.gAxes.appendChild(tick);
        if(t!==0){
          const lab=document.createElementNS(this.el.namespaceURI,'text');
          const xOff = (X0 < 18) ? 10 : -8;
          lab.setAttribute('x',X0 + xOff);
          lab.setAttribute('y',Py);
          lab.setAttribute('font-size','12'); lab.setAttribute('fill','#333');
          lab.setAttribute('text-anchor', xOff < 0 ? 'end' : 'start');
          lab.setAttribute('dominant-baseline','central');
          lab.textContent = u(t);
          this.gAxes.appendChild(lab);
          this._registerLabel(lab);
        }
      }
    }
  }
  drawCurve(fn,color='#c62828',thick=2){
    const path=document.createElementNS(this.el.namespaceURI,'path');
    const N=300; const R=this.R; let d='M';
    for(let i=0;i<=N;i++){
      const x=R.xmin + i/N*(R.xmax-R.xmin);
      const y=fn(x);
      const P=this.coordToScreen(x,y);
      d += (i===0? '':' L') + P.x.toFixed(2)+','+P.y.toFixed(2);
    }
    path.setAttribute('d',d); path.setAttribute('fill','none'); path.setAttribute('stroke',color); path.setAttribute('stroke-width',thick);
    this.gGeom.appendChild(path);
  }
  drawPoint(label,x,y,color='#c62828'){
    const g=document.createElementNS(this.el.namespaceURI,'g');
    const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
    const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','12'); t.setAttribute('fill',color); t.setAttribute('font-weight','700');
    const P=this.coordToScreen(x,y); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
    t.textContent=label;
    g.appendChild(c); g.appendChild(t); this.gGeom.appendChild(g);
    this._placeLabel(t, P.x, P.y); // anti-collision pour le label
  }
  drawLineThroughPointSlope(x0,y0,m,color='#1565c0',dash=true){
    const x1=this.R.xmin, y1=m*(x1-x0)+y0;
    const x2=this.R.xmax, y2=m*(x2-x0)+y0;
    const a=this.coordToScreen(x1,y1), b=this.coordToScreen(x2,y2);
    const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','2');
    if(dash) L.setAttribute('stroke-dasharray','6 6');
    this.gGeom.appendChild(L);
  }

  // ----- anti-collision labels -----
  _registerLabel(textEl){
    try{
      const bb = textEl.getBBox();
      this._labelRects.push({x:bb.x, y:bb.y, w:bb.width, h:bb.height});
    }catch(e){}
  }
  _rectsIntersect(a,b){
    return !( b.x > a.x+a.w || b.x+b.w < a.x || b.y > a.y+a.h || b.y+b.h < a.y );
  }
  _placeLabel(textEl, px, py){
    const W=420, H=420;
    const cand = [
      {dx:  6, dy:-10, anchor:'start', baseline:'auto'},     // NE
      {dx: -6, dy:-10, anchor:'end',   baseline:'auto'},     // NO
      {dx: -8, dy: 12, anchor:'end',   baseline:'hanging'},  // SO
      {dx:  8, dy: 12, anchor:'start', baseline:'hanging'},  // SE
      {dx: 12, dy:  0, anchor:'start', baseline:'central'},  // Est
      {dx:-12, dy:  0, anchor:'end',   baseline:'central'}   // Ouest
    ];
    for(let s=1; s<=3; s++){
      for(const c of cand){
        textEl.setAttribute('text-anchor', c.anchor);
        textEl.setAttribute('dominant-baseline', c.baseline);
        textEl.setAttribute('x', px + c.dx*s);
        textEl.setAttribute('y', py + c.dy*s);
        let bb;
        try{ bb = textEl.getBBox(); }catch(e){ continue; }
        const rect = {x:bb.x, y:bb.y, w:bb.width, h:bb.height};
        if(rect.x<0 || rect.y<0 || rect.x+rect.w>W || rect.y+rect.h>H) continue;
        const collide = this._labelRects.some(r => this._rectsIntersect(r, rect));
        if(!collide){ this._labelRects.push(rect); return; }
      }
    }
    // fallback
    textEl.setAttribute('text-anchor','start');
    textEl.setAttribute('dominant-baseline','auto');
    textEl.setAttribute('x', px + 6);
    textEl.setAttribute('y', py - 10);
    this._registerLabel(textEl);
  }
}


/* ================== Courbe C¹ par Hermite + utilitaires ================== */
function hermiteSeg(x0,y0,m0,x1,y1,m1){
  const dx = x1 - x0;
  return {
    f(x){
      const t = (x - x0)/dx;
      const h00 =  2*t*t*t - 3*t*t + 1;
      const h10 =    t*t*t - 2*t*t + t;
      const h01 = -2*t*t*t + 3*t*t;
      const h11 =    t*t*t -   t*t;
      return h00*y0 + h10*dx*m0 + h01*y1 + h11*dx*m1;
    },
    df(x){
      const t = (x - x0)/dx;
      const dh00 =  6*t*t - 6*t;
      const dh10 =  3*t*t - 4*t + 1;
      const dh01 = -6*t*t + 6*t;
      const dh11 =  3*t*t - 2*t;
      return (dh00*y0 + dh10*dx*m0 + dh01*y1 + dh11*dx*m1)/dx;
    }
  };
}

/* Courbe C¹ par morceaux avec “caps” doux aux extrémités */
function makePiecewiseHermite(P){
  P=[...P].sort((a,b)=>a.x-b.x);
  const segsCore=[];
  for(let i=0;i<P.length-1;i++){
    const s=hermiteSeg(P[i].x,P[i].y,P[i].m, P[i+1].x,P[i+1].y,P[i+1].m);
    segsCore.push({x0:P[i].x,x1:P[i+1].x, f:s.f, df:s.df});
  }
  function evalHerm(x){
    for(const s of segsCore) if(x>=s.x0 && x<=s.x1) return s.f(x);
    if(x<=P[0].x)    return P[0].y  + P[0].m  * (x-P[0].x);
    if(x>=P.at(-1).x) return P.at(-1).y + P.at(-1).m * (x-P.at(-1).x);
  }

  const left=P[0], next=P[1], right=P.at(-1), prev=P.at(-2);
  const wL = Math.min(1.4, Math.max(0.6, 0.45*Math.abs(next.x-left.x)));
  const wR = Math.min(1.4, Math.max(0.6, 0.45*Math.abs(right.x-prev.x)));
  const xL = left.x+wL, xR = right.x-wR;

  const bump    = t => { const t2=t*t, u=1-t2; return t2*u*u; };
  const dbumpdt = t => { const t2=t*t; return 2*t*(1-t2)*(1-3*t2); };

  const epsL = Math.min(0.2, 0.2*wL), epsR = Math.min(0.2, 0.2*wR);
  const yLineL = x => left.y  + left.m  * (x-left.x);
  const yLineR = x => right.y + right.m * (x-right.x);
  const signL = Math.sign( evalHerm(xL+epsL) - yLineL(xL+epsL) ) || (left.m>=0?1:-1);
  const signR = Math.sign( evalHerm(xR-epsR) - yLineR(xR-epsR) ) || (right.m>=0?1:-1);
  const AL = 3.4*wL*wL, AR = 3.4*wR*wR;

  function fCapLeft(x){  const t=(x-left.x)/wL;  return yLineL(x) + signL*AL*bump(t); }
  function dfCapLeft(x){ const t=(x-left.x)/wL;  return left.m + signL*AL*dbumpdt(t)*(1/wL); }
  function fCapRight(x){ const t=(right.x-x)/wR; return yLineR(x) + signR*AR*bump(t); }
  function dfCapRight(x){const t=(right.x-x)/wR; return right.m - signR*AR*dbumpdt(t)*(1/wR); }

  const guardL = {x:xL, y:yLineL(xL), m:left.m};
  const guardR = {x:xR, y:yLineR(xR), m:right.m};
  const Q=[guardL, ...P.slice(1,-1), guardR];
  const segs=[];
  for(let i=0;i<Q.length-1;i++){
    const s=hermiteSeg(Q[i].x,Q[i].y,Q[i].m, Q[i+1].x,Q[i+1].y,Q[i+1].m);
    segs.push({x0:Q[i].x,x1:Q[i+1].x, f:s.f, df:s.df});
  }

  const f=(x)=>{
    if(x<=left.x) return yLineL(x);
    if(x<xL) return fCapLeft(x);
    if(x>xR && x<right.x) return fCapRight(x);
    if(x>=right.x) return yLineR(x);
    for(const s of segs) if(x>=s.x0 && x<=s.x1) return s.f(x);
  };
  const df=(x)=>{
    if(x<=left.x) return left.m;
    if(x<xL) return dfCapLeft(x);
    if(x>xR && x<right.x) return dfCapRight(x);
    if(x>=right.x) return right.m;
    for(const s of segs) if(x>=s.x0 && x<=s.x1) return s.df(x);
  };
  return {f,df};
}
/* === UI helpers : conteneur avec/sans repère à droite pour l’énoncé === */
function renderWithRepere(host, R){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row';
  const left  = document.createElement('div');
  const right = document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);

  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  left.appendChild(rep.el);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {rep,left,right,equ,actions,res};
}

function renderNoRepere(host){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row norepere';
  const right = document.createElement('div');
  row.appendChild(right); host.appendChild(row);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {left:null,right,equ,actions,res};
}



/* ======= BANQUE DE COURBES "PROPRES" =======
   - 3 points clés P=[A,B,C] avec pentes imposées (B = extremum : m=0).
   - pentes: une entière, une fraction simple (1/2, 2/3, −1/2, ...).
   - Abscisses et ordonnées entières (lisibles), abscisse du point "fraction"
     multiple du dénominateur → p entiers si besoin.
   - La forme finale est obtenue par makePiecewiseHermite (douce). */
const CURVE_BANK = [
  //        A(x,y,m)            B(x,y,0)             C(x,y,m)
  { id:'K1', P:[{x:-4,y: 0,m: 1   }, {x:-1,y: 2,m:0}, {x: 2,y:-1,m: 1/2 }]},
  { id:'K2', P:[{x:-3,y: 2,m:-1   }, {x: 0,y:-1,m:0}, {x: 3,y:  2,m: 2/3 }]},
  { id:'K3', P:[{x:-5,y: 2,m: 2   }, {x:-2,y: 4,m:0}, {x: 2,y:  1,m:-1/2 }]},
  { id:'K4', P:[{x:-4,y: 1,m: 1   }, {x: 0,y: 3,m:0}, {x: 3,y:  1,m:-2/3 }]},
  { id:'K5', P:[{x:-6,y: 0,m: 2/3 }, {x:-3,y: 2,m:0}, {x: 3,y:  1,m:-1   }]},
  { id:'K6', P:[{x:-4,y: 2,m:-2   }, {x:-1,y: 3,m:0}, {x: 2,y:  0,m: 1/2 }]},
];

/* symétries / translations entières (sx,sy ∈ {+1,−1}) */
function transformPoints(P, {tx=0, ty=0, sx=1, sy=1}={}){
  return P.map(p=>({x:sx*(p.x)+tx, y:sy*(p.y)+ty, m:sy/sx * p.m}));
}

/* points intérieurs d'un intervalle ouvert (sans extrémités) */
function sampleOpen(a,b,n){
  const out=[]; if(n<=0) return out;
  for(let i=1;i<=n;i++){ const t=i/(n+1); out.push(a*(1-t)+b*t); }
  return out;
}

/* 5 points avant A, puis A, points, B, points, C, puis 5 points après C */
function samplePointsABC(f, A, B, C, R, cfg={left:5, mAB:4, mBC:4, right:5}){
  const L=[];
  // avant A (sans inclure A)
  for(const x of sampleOpen(R.xmin, A.x, cfg.left)) L.push({x, y:f(x)});
  // A
  L.push({x:A.x, y:f(A.x)});
  // entre A et B (ouvert)
  for(const x of sampleOpen(A.x, B.x, cfg.mAB)) L.push({x, y:f(x)});
  // B
  L.push({x:B.x, y:f(B.x)});
  // entre B et C (ouvert)
  for(const x of sampleOpen(B.x, C.x, cfg.mBC)) L.push({x, y:f(x)});
  // C
  L.push({x:C.x, y:f(C.x)});
  // après C (sans inclure C)
  for(const x of sampleOpen(C.x, R.xmax, cfg.right)) L.push({x, y:f(x)});
  return L;
}


function instantiateBankCurve(bankItem, R, opt={}){
  const P = transformPoints(bankItem.P, opt).sort((a,b)=>a.x-b.x);
  const {f,df} = makePiecewiseHermite(P);
  // 5 – A – (AB) – B – (BC) – C – 5
  const pts20 = samplePointsABC(f, P[0], P[1], P[2], R, {left:5, mAB:4, mBC:4, right:5});
  return {P,f,df,pts20};
}


/* contrôle "lecture depuis le point" + points dans le cadre */
function slopesReadableInFrame(P, R){
  const okInt=(x,y,k)=> (x+1<=R.xmax && y+k>=R.ymin && y+k<=R.ymax);
  const okFrac=(x,y,q)=>{ const vh=toVH(q); if(!vh) return false; const [V,H]=vh;
                          return (x+H<=R.xmax && y+V>=R.ymin && y+V<=R.ymax); };
  const inBox = P.every(p=>p.x>=R.xmin && p.x<=R.xmax && p.y>=R.ymin && p.y<=R.ymax);
  const A=P[0], B=P[1], C=P[2];
  const okA = toVH(A.m)? okFrac(A.x,A.y,A.m) : okInt(A.x,A.y,A.m);
  const okC = toVH(C.m)? okFrac(C.x,C.y,C.m) : okInt(C.x,C.y,C.m);
  return inBox && okA && okC && (B.m===0);
}

/* petite vérification "vraie tangence" : pas de recoupement immédiat */
function tangentDoesNotCrossNear(f, P, R, side='both'){
  const h=0.6; const line=x=>P.y + P.m*(x-P.x);
  let arr=[];
  if(side!=='right' && P.x-h>=R.xmin) arr.push( Math.sign(f(P.x-h)-line(P.x-h)) );
  if(side!=='left'  && P.x+h<=R.xmax) arr.push( Math.sign(f(P.x+h)-line(P.x+h)) );
  arr=arr.filter(s=>s!==0);
  return arr.length>=1 && arr.every(s=>s===arr[0]);
}




/* tirage de 3 entiers distincts lisibles */
function pick3DistinctInts(pool=[-5,-4,-3,-2,-1,0,1,2,3,4,5]){
  const P=[...pool], xs=[];
  while(xs.length<3) xs.push(P.splice(rnd(0,P.length-1),1)[0]);
  return xs.sort((a,b)=>a-b);
}



function fmtSlopeHTML(m){ const vh=toVH(m); return vh? fracHTML(vh[0],vh[1]) : fmtNum(m); }

/* === Inputs & ticks helpers (globaux) === */
function mkInput(id, w=120, ph='', pdfw=null){
  const W = Number(pdfw ?? w); // largeur du trait en PDF
  return `
    <span class="blank-wrap" data-w="${W}">
      <input id="${id}" style="width:${w}px" autocomplete="off" inputmode="text" placeholder="${ph}">
      <span class="blank" aria-hidden="true" style="width:${W}px">&nbsp;</span>
    </span>
  `.trim();
}


function setVal(host,id,val){
  // ne pas auto-remplir pendant l'affichage de la solution
  if(host && host._noFillSolution) return;
  const el = host.querySelector('#'+id);
  if(el) el.value = val;
}
function getVal(host,id){
  const el = host.querySelector('#'+id);
  return el ? String(el.value||'').trim() : '';
}


  // Cache des derniers paramètres générés par exercice
  window.__EXO_PARAMS_CACHE = window.__EXO_PARAMS_CACHE || {};


/* ================== Exercices ================== */
function makeExos(){
  const L=[];

  /* ===== Ex. 1 — Lire f'(a) sur la courbe ===== */
  L.push({
    id:'ex1_deriv_graph',
    title:"Ex. 1 — Lire f'(a) sur la courbe",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  return {R:RVIS, f:g.f, df:g.df, pts:[g.A,g.B,g.C], pts20:g.pts20};
},

/* === Ex. 1 — render() : ÉNONCÉ 100% LaTeX + re-typeset === */
render(host, st){
  const s = st.params || this.gen();
  host.dataset.state = JSON.stringify({params:s});
  const ui = renderWithRepere(host, s.R);

  ui.rep.drawCurve(s.f,'#e53935',2.5);
  const labels = ['A','B','C'];
  s.pts.forEach((P,i)=>{
    ui.rep.drawPoint(labels[i], P.x, P.y, '#1565c0');
    ui.rep.drawLineThroughPointSlope(P.x, P.y, P.m, '#1565c0', true);
  });

  const idx = [0,1,2].sort(()=>Math.random()-0.5);
  ui.equ.innerHTML = `
    <p>La courbe de la fonction \\(f\\) est tracée en rouge.</p>
    <p>Les droites bleues sont les tangentes en \\(A\\), \\(B\\) et \\(C\\).</p>
    <p>\\(f'(${fmtNum(s.pts[idx[0]].x)})=\\) ${mkInput('d1',80)} <span id="t1" class="tick"></span></p>
    <p>\\(f'(${fmtNum(s.pts[idx[1]].x)})=\\) ${mkInput('d2',80)} <span id="t2" class="tick"></span></p>
    <p>\\(f'(${fmtNum(s.pts[idx[2]].x)})=\\) ${mkInput('d3',80)} <span id="t3" class="tick"></span></p>
    <div class="steps" id="steps"></div>
  `;
  s._order = idx;

  ui.actions.innerHTML = '';
  host._state = s; host._ui = ui;

  // → (nouveau) faire composer MathJax pour l’énoncé
  retypeMath(host);
},

verify(host){
  const s=host._state;
  const idx = s._order || [0,1,2];

  const a1 = slopeOKStrict(getVal(host,'d1'), s.pts[idx[0]].m);
  const a2 = slopeOKStrict(getVal(host,'d2'), s.pts[idx[1]].m);
  const a3 = slopeOKStrict(getVal(host,'d3'), s.pts[idx[2]].m);

  setTick($('#t1',host), a1); setTick($('#t2',host), a2); setTick($('#t3',host), a3);

  const allFilled = [a1,a2,a3].every(x => x !== null);
  return allFilled && (a1===true && a2===true && a3===true);
},

// === Ex. 1 — solution() en dehors de .steps, dans une boîte .solbox ===
solution(host){
  const {pts} = host._state;
  const order = (host._state._order && Array.isArray(host._state._order))
               ? host._state._order : [0,1,2];
  const labs = ['A','B','C'];
  const fracTex = (N,D)=>`\\dfrac{${N}}{${D}}`;

  // Zone solution : hors .steps, avec .solbox (fond grisé)
  let zone = document.querySelector('#steps', host);
  if (zone){
    zone.classList.remove('steps');
    zone.classList.add('solution','solbox'); // <— fond grisé neutre
    zone.id = 'sol-ex1';
  }else{
    zone = document.createElement('div');
    zone.className = 'solution solbox';
    host._ui.right.appendChild(zone);
  }

  const html = order.map(k=>{
    const P = pts[k];
    const x = fmtNum(P.x);
    if (Math.abs(P.m) < 1e-12){
      return `<p>\\( ${labs[k]}(${x}\\,;\\,f(${x})) \\) et pente : \\(0\\)
              donc \\( f^{\\prime}(${x}) = 0 \\) (tangente horizontale)</p>`;
    }
    const [V,H] = slopeVH(P.m);
    return `<p>\\( ${labs[k]}(${x}\\,;\\,f(${x})) \\) et pente :
              \\( \\dfrac{V}{H} = ${fracTex(V,H)} \\)
              donc \\( f^{\\prime}(${x}) = ${H===1 ? V : fracTex(V,H)} \\)</p>`;
  }).join('');

  zone.innerHTML = html;
  if (window.retypeMath) retypeMath(zone); // re-typeset MathJax
}






  });

  /* ===== Ex. 2 — Tangentes & lectures ===== */
  L.push({
    id:'ex2_tangentes_triple',
    title:"Ex. 2 — Nombre dérivé et tangentes (A, B, D)",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  const A=g.A, B=g.B, C=g.C;

  const T1={m:A.m, p:A.y - A.m*A.x};
  const T2={m:B.m, p:B.y - B.m*B.x};
  const T3={m:C.m, p:C.y - C.m*C.x};

  // Point auxiliaire D pour que (CD) soit la tangente en C
  const vh = HERMITE5.toVH(C.m) || [Math.round(C.m),1];
  let D = { x: C.x + vh[1], y: C.y + vh[0] };
  if(D.x>RVIS.xmax || D.x<RVIS.xmin || D.y>RVIS.ymax || D.y<RVIS.ymin){ 
    D = { x: C.x - vh[1], y: C.y - vh[0] }; 
  }
  return {R:RVIS, f:g.f, A,B,C, T1,T2,T3, D, pts20:g.pts20};
},

    /* ===== Ex. 2 — ÉNONCÉ 100% LaTeX ===== */
render(host, st){
  const s=st.params||this.gen(); 
  host.dataset.state=JSON.stringify({params:s});
  const ui=renderWithRepere(host, s.R);

  // ---- dessin des courbes/tangentes + labels ----
  function segmentInBox_throughPointSlope(x0,y0,m,R){
    const cand=[];
    const yL = m*(R.xmin - x0) + y0; if (yL>=R.ymin && yL<=R.ymax) cand.push({x:R.xmin,y:yL});
    const yR = m*(R.xmax - x0) + y0; if (yR>=R.ymin && yR<=R.ymax) cand.push({x:R.xmax,y:yR});
    if (Math.abs(m)>1e-12){
      const xB = x0 + (R.ymin - y0)/m; if (xB>=R.xmin && xB<=R.xmax) cand.push({x:xB,y:R.ymin});
      const xT = x0 + (R.ymax - y0)/m; if (xT>=R.xmin && xT<=R.xmax) cand.push({x:xT,y:R.ymax});
    } else { cand.push({x:ui.rep.R.xmin,y:y0},{x:ui.rep.R.xmax,y:y0}); }
    const u=[]; for(const p of cand){ if(!u.some(q=>Math.abs(q.x-p.x)<1e-9&&Math.abs(q.y-p.y)<1e-9)) u.push(p); }
    while(u.length<2) u.push({x:ui.rep.R.xmin,y:y0},{x:ui.rep.R.xmax,y:y0});
    return u.slice(0,2);
  }
  function addPdfSafeLine(rep, Q1, Q2, color){
    const NS = rep.el.namespaceURI;
    let g = rep.el.querySelector('g.tangent-pdf-safe');
    if(!g){ g = document.createElementNS(NS,'g'); g.setAttribute('class','tangent-pdf-safe'); rep.el.appendChild(g); }
    const A = rep.coordToScreen(Q1.x, Q1.y);
    const B = rep.coordToScreen(Q2.x, Q2.y);
    const L = document.createElementNS(NS,'line');
    L.setAttribute('x1', A.x); L.setAttribute('y1', A.y);
    L.setAttribute('x2', B.x); L.setAttribute('y2', B.y);
    L.setAttribute('stroke', color);
    L.setAttribute('stroke-width', '2.5');
    L.setAttribute('stroke-dasharray', '6 6');
    L.setAttribute('stroke-linecap', 'round');
    g.appendChild(L);
  }
  function drawTangentWithLabel(P, color, labelText){
    ui.rep.drawLineThroughPointSlope(P.x, P.y, P.m, color, true);
    const [Q1,Q2] = segmentInBox_throughPointSlope(P.x,P.y,(Math.abs(P.m)<1e-12?0:P.m), s.R);
    addPdfSafeLine(ui.rep, Q1, Q2, color);
    const NS = ui.rep.el.namespaceURI;
    const T = document.createElementNS(NS,'text');
    const mid = ui.rep.coordToScreen((Q1.x+Q2.x)/2,(Q1.y+Q2.y)/2);
    T.textContent = labelText;
    T.setAttribute('x', mid.x+6);
    T.setAttribute('y', mid.y-6);
    T.setAttribute('font-size', '12');
    T.setAttribute('font-weight','700');
    T.setAttribute('fill', color);
    T.setAttribute('stroke','#fff');
    T.setAttribute('stroke-width','3');
    T.setAttribute('paint-order','stroke');
    ui.rep.gUser.appendChild(T);
    if (typeof ui.rep._placeLabel === 'function') ui.rep._placeLabel(T, mid.x+6, mid.y-6);
  }

  const COLORS = ['#1e40af', '#7c3aed', '#16a34a']; // bleu, violet, vert
  const SUB    = ['₁','₂','₃'];

  ui.rep.drawCurve(s.f,'#e53935',2.5);
  // --- montrer explicitement les points A, B, C et D ---
ui.rep.drawPoint('A', s.A.x, s.A.y, '#1565c0');
ui.rep.drawPoint('B', s.B.x, s.B.y, '#1565c0');
ui.rep.drawPoint('C', s.C.x, s.C.y, '#1565c0');
ui.rep.drawPoint('D', s.D.x, s.D.y, '#1565c0');  // (CD) est la tangente en C

  drawTangentWithLabel(s.A, COLORS[0], 'T'+SUB[0]);
  drawTangentWithLabel(s.B, COLORS[1], 'T'+SUB[1]);
  drawTangentWithLabel(s.C, COLORS[2], 'T'+SUB[2]);

  // --- ordre COMMUN pour f(.) et f'(.) ---
  const order = [0,1,2].sort(()=>Math.random()-0.5);
  const P=[s.A,s.B,s.C], LAB=['A','B','C'];

  // helpers TeX
  const pt = (L,p)=>`\\( ${L}(${fmtNum(p.x)}\\,;\\,${fmtNum(p.y)}) \\)`;
  const tex = (str)=>str;

  const valRow = order.map(k =>
    `${tex(`\\( f(${fmtNum(P[k].x)}) = \\)`)} ${mkInput('f'+LAB[k], 80, '', 140)} <span id="tf${LAB[k]}" class="tick"></span>`
  ).join(' ; ');

  const derRow = order.map(k =>
    `${tex(`\\( f'(${fmtNum(P[k].x)}) = \\)`)} ${mkInput('df'+LAB[k], 80, '', 140)} <span id="tdf${LAB[k]}" class="tick"></span>`
  ).join(' ; ');

  // — ÉNONCÉ LaTeX —
  ui.equ.innerHTML = `
    <p>Soit une fonction \\(f\\). Les droites
      <b style="color:${COLORS[0]}">\\(T_{1}\\)</b>, <b style="color:${COLORS[1]}">\\(T_{2}\\)</b> et
      <b style="color:${COLORS[2]}">\\(T_{3}\\)</b> sont les tangentes à \\(C_{f}\\) aux points
      \\(A\\), \\(B\\) et \\(C\\).</p>
    <p>Le point ${pt('D', s.D)} est choisi de sorte que \\((CD)\\) soit la tangente à \\(C_{f}\\) au point \\(C\\).</p>
    <ol>
      <li>Déterminer : ${valRow}.</li>
      <li>Déterminer : ${derRow}.</li>
      <li>Donner une équation des tangentes :<br>
        <span style="font-weight:700;color:${COLORS[0]}">\\(T_{1}\\)</span> :
        ${mkInput('t1', 220, 'y = ...', 320)} <span id="tt1" class="tick"></span><br>
        <span style="font-weight:700;color:${COLORS[1]}">\\(T_{2}\\)</span> :
        ${mkInput('t2', 220, 'y = ...', 320)} <span id="tt2" class="tick"></span><br>
        <span style="font-weight:700;color:${COLORS[2]}">\\(T_{3}\\)</span> :
        ${mkInput('t3', 220, 'y = ...', 320)} <span id="tt3" class="tick"></span>
      </li>
    </ol>
    <div class="steps" id="steps2"></div>
  `;

  // mémorise l’ordre commun
  host._state = {...s, _order:order};
  host._ui=ui;

  if (window.retypeMath) retypeMath(host);
},



verify(host){
  const s = host._state;
  const P = { A: s.A, B: s.B, C: s.C };

  // entiers stricts pour f(·)
  const checkInt = (id, expected, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const v = parseIntStrict(raw);
    const ok = (v !== null && v === expected);
    setTick($(tickSel,host), ok);
    return ok;
  };
  // pente (entier ou fraction réduite) pour f'(·)
  const checkSlope = (id, expected, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const ok = slopeOKStrict(raw, expected);
    setTick($(tickSel,host), ok);
    return ok;
  };
  // équation stricte y = mx + p
  const checkLine = (id, mVH, pVH, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const ok = lineOKStrict(raw, mVH, pVH) ||
           isSameLine(raw, mVH[0]/mVH[1], pVH[0]/pVH[1]);
    setTick($(tickSel,host), ok);
    return ok;
  };

  const r = [];
  // valeurs
  r.push( checkInt('fA', P.A.y, '#tfA') );
  r.push( checkInt('fB', P.B.y, '#tfB') );
  r.push( checkInt('fC', P.C.y, '#tfC') );

  // dérivées
  r.push( checkSlope('dfA', P.A.m, '#tdfA') );
  r.push( checkSlope('dfB', P.B.m, '#tdfB') );
  r.push( checkSlope('dfC', P.C.m, '#tdfC') );

  // équations T1/T2/T3 (en A/B/C)
  const mA = slopeVH(P.A.m), pA = pFromPoint(...mA, P.A.x, P.A.y);
  const mB = slopeVH(P.B.m), pB = pFromPoint(...mB, P.B.x, P.B.y);
  const mC = slopeVH(P.C.m), pC = pFromPoint(...mC, P.C.x, P.C.y);

  r.push( checkLine('t1', mA, pA, '#tt1') );
  r.push( checkLine('t2', mB, pB, '#tt2') );
  r.push( checkLine('t3', mC, pC, '#tt3') );

  return r.every(v => v === true);
},



 solution(host){
  const s=host._state, ui=host._ui;

  // pré-remplissages
  setVal(host,'fA', s.A.y); setVal(host,'fB', s.B.y); setVal(host,'fC', s.C.y);
  setVal(host,'dfA', fprimeHTML_strict(s.A.m));
  setVal(host,'dfB', fprimeHTML_strict(s.B.m));
  setVal(host,'dfC', fprimeHTML_strict(s.C.m));

  const mA=slopeVH(s.A.m), pA=pFromPoint(...mA, s.A.x, s.A.y);
  const mB=slopeVH(s.B.m), pB=pFromPoint(...mB, s.B.x, s.B.y);
  const mC=slopeVH(s.C.m), pC=pFromPoint(...mC, s.C.x, s.C.y);

  setVal(host,'t1', eqHTML(mA,pA));
  setVal(host,'t2', eqHTML(mB,pB));
  setVal(host,'t3', eqHTML(mC,pC));

  // helpers TeX
  const frac   = (N,D)=>`\\dfrac{${N}}{${D}}`;
  const ratTex = ([N,D]) => D===1 ? `${N}` : frac(N,D);
  const mxTex  = ([N,D]) => D===1 ? `${N}x` : `${frac(N,D)}x`;
  const eqTex  = (m,p) => {
    if (m[0]===0) return `y = ${ratTex(p)}`;
    const sign = (p[0]<0)? ' - ' : ' + ';
    const pAbs = [Math.abs(p[0]), p[1]];
    return `y = ${mxTex(m)}${(p[0]===0)? '' : sign + ratTex(pAbs)}`;
  };
  const fprimeTex = (m)=>{ const [V,H]=slopeVH(m); return H===1 ? `${V}` : frac(V,H); };
  const value = (P)=>`\\( f(${fmtNum(P.x)}) = ${fmtNum(P.y)} \\)`;
  const deriv = (P)=>`\\( f'(${fmtNum(P.x)}) = ${fprimeTex(P.m)} \\)`;

  // supprime l’ancienne .steps
  const old = ui.right.querySelector('#steps2'); if(old) old.remove();

  // boîte grisée .solbox
  let sol = ui.right.querySelector('#sol-ex2');
  if (!sol){
    sol = document.createElement('div');
    sol.id='sol-ex2';
    sol.className='solution solbox';
    ui.right.appendChild(sol);
  } else { sol.classList.add('solution','solbox'); sol.innerHTML=''; }

  // ordre commun
  const ord = s._order || [0,1,2];
  const P = [s.A,s.B,s.C];

  const valTex = ord.map(k => value(P[k])).join(', ');
  const derTex = ord.map(k => deriv(P[k])).join(', ');

  const eq1 = eqTex(mA,pA);
  const eq2 = eqTex(mB,pB);
  const eq3 = eqTex(mC,pC);

  sol.innerHTML = [
    `<p><b>Valeurs :</b> ${valTex}.</p>`,
    `<p><b>Pentes :</b> ${derTex}.</p>`,
    `<p>\\( y = f'(a)\\,(x-a) + f(a) \\) ou par lecture graphique : </p>`,
    `<p><span style="font-weight:700;color:#1e40af">\\(T_{1}\\)</span> : \\( ${eq1} \\)</p>`,
    `<p><span style="font-weight:700;color:#7c3aed">\\(T_{2}\\)</span> : \\( ${eq2} \\)</p>`,
    `<p><span style="font-weight:700;color:#16a34a">\\(T_{3}\\)</span> : \\( ${eq3} \\)</p>`
  ].join('');

  if (window.retypeMath) retypeMath(sol);
},



  });

/* ===== Ex. 3 — f'(x) linéaire ===== */
L.push({
  id:'ex3_derivee_lineaire',
  title:"Ex. 3 — f'(x) = ax + b",
  gen(){
    const a = rchoice([-6,-4,-2,2,3,5]);
    const b = rchoice([-4,-2,0,2,4,11]);
    const poolN = [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1, 1,2,3,4,5,6,7,8,9,10];
    const n = rchoice(poolN);                 // n ≠ 0
    return {a,b,n};
  },
  render(host, st){
  const s = st.params || this.gen();
  host.dataset.state = JSON.stringify({params:s});
  const ui = renderNoRepere(host);

  // ÉNONCÉ 100% LaTeX (aucun <code class="equ"> ni <span class="equ">)
  const nDisp = (s.n < 0) ? `(${fmtNum(s.n)})` : fmtNum(s.n);
  ui.equ.innerHTML = `
    <p>On donne, pour tout réel \\(x\\) : \\(\\;f'(x)= ${s.a}x ${s.b>=0?'+':''}${s.b}\\;\\).</p>
    <p>On considère les points \\(A\\) et \\(B\\) de \\(C_f\\) d’abscisses respectives \\(0\\) et \\(${fmtNum(s.n)}\\).</p>
    <ol>
      <li>
        Calculer : \\(f'(0)\\) = ${mkInput('v1',80)} <span id="tv1" class="tick">—</span>
        et \\(f'(${fmtNum(s.n)})\\) = ${mkInput('v2',80)} <span id="tv2" class="tick">—</span>.
      </li>
      <li>
        En déduire les coefficients directeurs des tangentes à \\(C_f\\) aux points \\(A\\) et \\(B\\) :
        \\(m_A\\) = ${mkInput('mA',80)} <span id="tmA" class="tick">—</span>,
        \\(m_B\\) = ${mkInput('mB',80)} <span id="tmB" class="tick">—</span>.
      </li>
    </ol>
    <div class="steps" id="steps3"></div>
  `;

  host._state = s; host._ui = ui;

  // Typeset MathJax local (si utilitaire présent)
  if (window.retypeMath) retypeMath(host);
},

  verify(host){
    const s = host._state;
    const A = s.a*0   + s.b;          // f'(0)
    const B = s.a*s.n + s.b;          // f'(n)
    const v1 = parseNum(getVal(host,'v1'));
    const v2 = parseNum(getVal(host,'v2'));
    const ok1 = eqNum(v1, A);
    const ok2 = eqNum(v2, B);
    setTick($('#tv1',host), ok1);
    setTick($('#tv2',host), ok2);

    const okA = eqNum(parseNum(getVal(host,'mA')), A);
    const okB = eqNum(parseNum(getVal(host,'mB')), B);
    setTick($('#tmA',host), okA);
    setTick($('#tmB',host), okB);

    return ok1 && ok2 && okA && okB;
  },
  solution(host){
  const s = host._state;
  const ui = host._ui;

  // Valeurs exactes
  const A = s.a*0   + s.b;          // f'(0)
  const B = s.a*s.n + s.b;          // f'(n)

  // Pré-remplissage des inputs pour garder la logique de vérif
  setVal(host,'v1', A);
  setVal(host,'v2', B);
  setVal(host,'mA', A);
  setVal(host,'mB', B);

  // Supprimer le bloc .steps pour éviter le bug d’alignement du prime
  const old = $('#steps3', host);
  if (old) old.remove();

  // Boîte grisée .solbox (hors .steps), comme pour les exos 1 & 2
  let sol = ui.right.querySelector('#sol-ex3');
  if(!sol){
    sol = document.createElement('div');
    sol.id = 'sol-ex3';
    sol.className = 'solution solbox';
    ui.right.appendChild(sol);
  }else{
    sol.classList.add('solution','solbox');
    sol.innerHTML = '';
  }

  // Affichage LaTeX des trois étapes (même niveau de détail qu’avant)
  const nDisp = (s.n < 0) ? `(${fmtNum(s.n)})` : fmtNum(s.n);
  const plusB = s.b>=0 ? '+' : '';       // pour "a×0 + b"
  const plusB2= s.b>=0 ? '+' : '';       // pour "a×n + b"

  sol.innerHTML = [
    `<p> \\(\\;f'(0) = ${s.a}\\times 0 ${plusB}${s.b} = ${A}\\;\\).</p>`,
    `<p>\\(\\;f'(${fmtNum(s.n)}) = ${s.a}\\times ${nDisp} ${plusB2}${s.b} = ${B}\\;\\).</p>`,
    `<p>Le coefficient directeur de la tangente en \\(x=a\\) vaut \\(f'(a)\\). 
       Donc \\(m_A = f'(0) = ${A}\\) et \\(m_B = f'(${fmtNum(s.n)}) = ${B}\\).</p>`
  ].join('');

  // Typeset MathJax uniquement dans la boîte
  if (window.retypeMath) retypeMath(sol);
}
});


  /* ===== Ex. 4 — f'(x_A) avec la tangente passant par B ===== */
L.push({
  id:'ex4_tangent_par_deux_points',
  title:"Ex. 4 — f'(x_A) avec la tangente passant par B",
  gen(){
    // A et B entiers lisibles dans [-6,6], x_B ≠ x_A
    const R = {xmin:-6,xmax:6,ymin:-6,ymax:6};
    let tries = 0;
    while(tries++ < 500){
      const xA = rnd(R.xmin+1, R.xmax-1);
      const yA = rnd(R.ymin+1, R.ymax-1);
      const dx = rchoice([-5,-4,-3,-2,-1, 1,2,3,4,5]); // pas de verticale
      const V  = rnd(-5,5);                             // décalage en y
      const xB = xA + dx, yB = yA + V;
      if(xB<R.xmin || xB>R.xmax || yB<R.ymin || yB>R.ymax) continue;
      return {A:{x:xA,y:yA}, B:{x:xB,y:yB}};
    }
    // fallback
    return {A:{x:-3,y:1}, B:{x:2,y:-1}};
  },
  render(host, st){
  const s = st.params || this.gen();
  host.dataset.state = JSON.stringify({params:s});
  const ui = renderNoRepere(host);

  // ÉNONCÉ 100% LaTeX (aucun <code class="equ"> ni <span class="equ">)
  ui.equ.innerHTML = `
    <p>Dans le plan muni du repère \\((O,I,J)\\), la tangente à \\(C_{f}\\) au point
    \\(A\\big(${fmtNum(s.A.x)}\\,;\\,${fmtNum(s.A.y)}\\big)\\) passe par le point
    \\(B\\big(${fmtNum(s.B.x)}\\,;\\,${fmtNum(s.B.y)}\\big)\\).</p>
    <p>Déterminer le nombre dérivé \\(\\;f'\\big(${fmtNum(s.A.x)}\\big)\\) :
      ${mkInput('m',100)} <span id="tm" class="tick">—</span></p>
    <div class="steps" id="steps4"></div>
  `;

  host._state = s; host._ui = ui;

  // Typeset MathJax local (si utilitaire dispo)
  if (window.retypeMath) retypeMath(host);
},
  verify(host){
    const s = host._state;
    const m = (s.B.y - s.A.y) / (s.B.x - s.A.x);              // pente (AB)
    const ok = eqNum(parseNum(getVal(host,'m')), m, 1e-6);    // accepte entier, a/b, décimal exact
    setTick($('#tm',host), ok);
    return ok;
  },
  solution(host){
  const s  = host._state;
  const ui = host._ui;

  // Calculs exacts
  const dy = s.B.y - s.A.y;   // y_B − y_A
  const dx = s.B.x - s.A.x;   // x_B − x_A

  // Réduction pour l'affichage final
  const [Nred, Dred] = reduce(Math.abs(dy), Math.abs(dx)); // >0
  const isNeg = (dy < 0) !== (dx < 0);                     // signe global

  // Valeur pour l’input (ASCII pour le parseur : entier ou "a/b")
  const inputVal = (Dred===1) ? (isNeg ? -Nred : Nred) : `${isNeg?'-':''}${Nred}/${Dred}`;
  setVal(host,'m', inputVal);

  // Supprimer le bloc .steps (on rend la correction dans une boîte grisée dédiée)
  const old = $('#steps4', host);
  if (old) old.remove();

  // Boîte grisée .solbox (hors .steps)
  let sol = ui.right.querySelector('#sol-ex4');
  if(!sol){
    sol = document.createElement('div');
    sol.id = 'sol-ex4';
    sol.className = 'solution solbox';
    ui.right.appendChild(sol);
  }else{
    sol.classList.add('solution','solbox');
    sol.innerHTML = '';
  }

  // Helpers TeX
  const frac = (a,b)=>`\\dfrac{${a}}{${b}}`;
  // b - a  →  "b - a" si a>=0,  sinon "b + |a|"
  const diffPretty = (b,a) => (a<0 ? `${b} + ${Math.abs(a)}` : `${b} - ${a}`);

  // Lignes LaTeX sans "--", "-+" ni "+-"
  const line1 = `\\( f'\\big(${fmtNum(s.A.x)}\\big) \\)`;
  const line2 = `\\( =m_{(AB)} = ${frac('y_B - y_A','x_B - x_A')} = ${frac(diffPretty(s.B.y, s.A.y), diffPretty(s.B.x, s.A.x))} \\)`;
  const line3 = `\\( = ${isNeg?'-':''}${frac(Math.abs(dy), Math.abs(dx))} \\)`;
  const line4 = (Dred===1)
    ? `\\(= \\boxed{\\;${isNeg?'-':''}${Nred}\\;} \\)`
    : `\\(= \\boxed{\\;${isNeg?'-':''}${frac(Nred,Dred)}\\;} \\)`;

  // Rendu
  sol.innerHTML = [
    `<p>${line1}${line2}  ${line4}</p>`,
      ].join('');

  // Typeset MathJax uniquement dans la boîte
  if (window.retypeMath) retypeMath(sol);
}



});


  /* ===== Ex. 5 — Équation de tangentes (A et B varient) ===== */
L.push({
  id:'ex5_eq_tangente_point_pente',
  title:"Ex. 5 — Équation de tangentes (points A et B)",
  gen(){
    // Tirages lisibles (entiers)
    const pick = () => ({
      x: rnd(-5,5),
      y: rnd(-5,5),
      m: rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]) // pente non nulle
    });
    let A = pick(), B = pick();
    // évite A=B trop souvent
    let guard=0; 
    while(guard++<50 && (A.x===B.x && A.y===B.y)) B = pick();
    return {A,B};
  },
  render(host, st){
  const s = st.params || this.gen();
  host.dataset.state = JSON.stringify({params:s});
  const ui = renderNoRepere(host);

  // ÉNONCÉ 100% LaTeX (zéro <code class="equ"> / <span class="equ">)
  ui.equ.innerHTML = `
    <ol>
      <li>
        Déterminer une équation de la tangente \\(T\\) au point
        \\(A\\big(${fmtNum(s.A.x)}\\,;\\,${fmtNum(s.A.y)}\\big)\\) à \\(C_f\\),
        sachant que \\(f'(${fmtNum(s.A.x)})=${fmtNum(s.A.m)}\\).<br>
        ${mkInput('eq1',260,'')} <span id="te1" class="tick">—</span>
      </li>
      <li>
        Déterminer une équation de la tangente \\(T\\) au point
        \\(B\\big(${fmtNum(s.B.x)}\\,;\\,${fmtNum(s.B.y)}\\big)\\) à \\(C_f\\),
        sachant que le coefficient directeur de \\(T\\) est \\(${fmtNum(s.B.m)}\\).<br>
        ${mkInput('eq2',260,'')} <span id="te2" class="tick">—</span>
      </li>
    </ol>
    <div class="steps" id="steps5"></div>
  `;

  host._state = s; host._ui = ui;
  if (window.retypeMath) retypeMath(host);   // typeset local
},
 verify(host){
  const s = host._state;
  const pA = s.A.y - s.A.m*s.A.x;
  const pB = s.B.y - s.B.m*s.B.x;

  // helper : ne sanctionne pas si vide → tick neutre
  const checkLine = (id, m, p, tickSel) => {
    const raw = String(getVal(host, id) || '').trim();
    if (raw === '') { setTick($(tickSel, host), null); return null; } // NEUTRE
    const ok = isSameLine(raw, m, p);
    setTick($(tickSel, host), ok);
    return ok; // true / false
  };

  const r1 = checkLine('eq1', s.A.m, pA, '#te1');
  const r2 = checkLine('eq2', s.B.m, pB, '#te2');

  // succès uniquement si les deux sont corrects (true)
  return (r1 === true && r2 === true);
},

  solution(host){
  const s  = host._state;
  const ui = host._ui;

  // on ne rend pas dans .steps (prime propre)
  const old = $('#steps5', host);
  if (old) old.remove();

  // boîte grisée
  let sol = ui.right.querySelector('#sol-ex5');
  if(!sol){
    sol = document.createElement('div');
    sol.id = 'sol-ex5';
    sol.className = 'solution solbox';
    ui.right.appendChild(sol);
  }else{
    sol.classList.add('solution','solbox');
    sol.innerHTML = '';
  }

  // helpers (zéro '--', '+-', '-+' ; pas de "1x")
  const pr = v => fmtNum(v);
  const bracket = a => a < 0 ? `(x + ${pr(-a)})` : `(x - ${pr(a)})`;
  const signAbs = k => (k >= 0 ? ` + ${pr(Math.abs(k))}` : ` - ${pr(Math.abs(k))}`);
  const mx = m => (m === 1 ? 'x' : (m === -1 ? '−x' : `${pr(m)}x`));
  const mParen = m => (m === 1 ? '' : (m === -1 ? '−' : pr(m))); // devant (x±a)

  function block(P, label, inputId){
    const m  = P.m, a = P.x, yA = P.y;
    const p  = yA - m*a;
    const t1 = m * (-a);                       // terme issu du développement m(x-a)

    // 1 → 6 : même structure que la version HTML, en LaTeX
    const L1 = `<p><b>\\(${label}\\big(${pr(a)} \\; ; \\; ${pr(yA)}\\big)\\)</b> donc <b>\\(f(${pr(a)})=${pr(yA)}\\)</b> et on sait que <b>\\(f'(${pr(a)})=${pr(m)}\\)</b> donc :</p>`;
    const L2 = `<p>L’équation de la tangente <b>\\(T_{${label}}\\)</b> est :</p>`;
    const L3 = `<p>\\(y = f'(${pr(a)})\\,${bracket(a)} + f(${pr(a)})\\)</p>`;
    // Substitution : pas de "+ -2" et pas de "1(x−a)"
    const L4 = `<p>\\(y = ${mParen(m)}${bracket(a)}${signAbs(yA)}\\)</p>`;
    // Développement : pas de "−1x"
    const L5 = `<p>\\(y = ${mx(m)}${signAbs(t1)}${signAbs(yA)}\\)</p>`;

    // Équation finale (remplissage de l’input en ASCII pour la vérif)
    const finalTex = `y = ${mx(m)}${p===0 ? '' : signAbs(p)}`;
    const finalAscii = finalTex.replace(/−/g,'-');     // pour le parseur
    setVal(host, inputId, finalAscii);

    const L6 = `<p><b>\\(${finalTex}\\)</b></p>`;

    return L1 + L2 + L3 + L4 + L5 + L6;
  }

  // A puis B (même ordre/format que l’HTML d’origine)
  sol.innerHTML = block(s.A,'A','eq1') + '<br>' + block(s.B,'B','eq2');

  if (window.retypeMath) retypeMath(sol);
}

});


// Affichage propre (√, ²/³, ×, fraction 1/(2√x) en pile)
// Affichage propre (√, ²/³, ×, fractions…)
function prettyExprHTML(expr){
  const U = '−';
  const frac = (N,D)=>`<span class="frac"><span class="num">${N}</span><span class="den">${D}</span></span>`;
  let s = String(expr||'').trim();

  // Signes + espaces
  s = s.replace(/-/g, U).replace(/\s+/g, ' ');

  // √x / √(...)
  s = s.replace(/sqrt\(\s*x\s*\)/gi, '√x')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '√($1)');

  // 1/(2*sqrt(x)) → 1/(2√x)
  s = s.replace(/1\s*\/\s*\(\s*2\s*[*×·]?\s*sqrt\(\s*x\s*\)\s*\)/gi, ()=> frac('1','2√x'));

  // ---- Puissances → affichage HTML (tous les cas) ----
  // x^n
  s = s.replace(/x\^2\b/gi, 'x²')
       .replace(/x\^3\b/gi, 'x³')
       .replace(/x\^(\d+)/gi, (_,$1)=>`x<sup>${$1}</sup>`);

  // (±nombre)^n
  s = s.replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*2/g, '$1²')
       .replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*3/g, '$1³')
       .replace(/(\(\s*[−\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*(\d+)/g, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // nombre^n
  s = s.replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*2/g, '$1²')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*3/g, '$1³')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // Fallback : toute occurrence résiduelle ")^n" ou "x^n"
  s = s.replace(/(\)|x)\s*\^\s*(\d+)/gi, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // × uniquement entre nombres (pas avant x, √, ()
  s = timesNumbersOnly(s);

  // Signes nettoyés
  s = s.replace(/\+\s*−/g, ` ${U} `)
       .replace(/−\s*\+/g, ` ${U} `)
       .replace(/−\s*−/g, ' + ')
       .replace(/\s+/g, ' ');

  return s;
}



// Évaluation sûre : ajoute les * implicites et parenthèse "-x**2"
// Évaluation sûre : caret ^ → **, multiplications implicites, etc.
function evalExprSafe(expr, x){
  let code = String(expr || '')
    // 0) Nettoyages défensifs
    .replace(/\ufeff/g, '')                       // BOM
    .replace(/<\/?[^>]+>/g, '')                   // tags HTML
    .replace(/[\u00A0\u202F\u2009\u200A\u2005\u2006\u2007\u2008\u2002\u2003\u2004]/g, ' ') // espaces spéciaux
    // 1) Normalisations Unicode → ASCII
    .replace(/−/g, '-')                           // grand moins
    .replace(/[–—]/g, '-')                        // en/em dash
    .replace(/[×·•]/g, '*')                       // multiplications
    .replace(/[⁄∕]/g, '/')                        // slashs fraction
    .replace(/,/g, '.')                           // virgule décimale
    // 2) Racines
    .replace(/sqrt\(/gi, 'Math.sqrt(')
    .replace(/√\s*\(\s*/g, 'Math.sqrt(')
    .replace(/√\s*x/gi, 'Math.sqrt(x)');

  // 3) Puissances '^' → opérateur JS '**'
  code = code
    .replace(/x\^(\d+)/gi, 'x**$1')                     // x^n
    .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)**$2')  // (...)^n
    .replace(/(\d+(?:\.\d+)?)\s*\^\s*(\d+)/g, '($1**$2)'); // nombre^n

  // 4) Multiplications implicites (y compris avant Math.sqrt)
  code = code
    .replace(/(\d)\s*x\b/g, '$1*x')       // 2x → 2*x
    .replace(/\)\s*x\b/g, ')*x')          // )x → )*x
    .replace(/\bx\s*\(/g, 'x*(')          // x( → x*(
    .replace(/(\d)\s*\(/g, '$1*(')        // 2( → 2*(
    .replace(/\)\s*\(/g, ')*(')           // )( → )*(
    .replace(/(\d)\s*(?=Math\.)/g, '$1*') // 2Math.sqrt → 2*Math.sqrt
    .replace(/\)\s*(?=Math\.)/g, ')*');   // )Math.sqrt → )*Math.sqrt

  // 5) Dernier filtre : garde caractères autorisés
  code = code.replace(/[^0-9eE+\-*/().x\sA-Za-z_]/g, '');

  // 6) JS n’aime pas "-x**2" → parenthèse
  code = code.replace(/(^|[^\w\)])-\s*(x\s*\*\*\s*\d+)/g, '$1-($2)');

  const f = new Function('x', 'return (' + code + ');');
  return f(x);
}


// Convertit un bout de TeX simple en expression JS évaluable pour evalExprSafe
function asEvalExpr(expr){
  let s = String(expr || '');

  // — Unicode supercripts → ^n — (x², x³, 5², (x+1)², etc.)
  s = s
    .replace(/([A-Za-z0-9)\]])\s*²/g, '$1^2')
    .replace(/([A-Za-z0-9)\]])\s*³/g, '$1^3');

  // \dfrac{A}{B} ou \frac{A}{B} -> (A)/(B)
  s = s.replace(/\\(?:d)?frac\{([^{}]+)\}\{([^{}]+)\}/g, '($1)/($2)');

  // \sqrt{...} -> sqrt(...)
  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)');

  // x^{n} -> x^n
  s = s.replace(/x\^\{(\d+)\}/gi, 'x^$1');

  // \cdot, \times -> *
  s = s.replace(/\\cdot|\\times/g, '*');

  // Accolades simples -> parenthèses
  s = s.replace(/\{/g, '(').replace(/\}/g, ')');

  // Espaces
  s = s.replace(/\s+/g, ' ');

  return s;
}



// Remplace x par la valeur en insérant * si un nombre ou ')' précède x
function substXWithMul(str, X){
  const sub = (X < 0 ? `(${X})` : String(X));  // parenthèses seulement si X<0
  return str
    .replace(/(\d|\))\s*x\b/g, '$1*' + sub)    // a x^n → a*X^n  (ou )x → )*X)
    .replace(/x\b/g, sub);                     // le reste : x → X
}

// f(x) évaluée en x=a — insère \times correctement (pas "times")
function texFxEvalLine(expr, a){
  const pr = v => fmtNum(v);
  const A  = (a < 0) ? `(${pr(a)})` : `${pr(a)}`;
  let t = String(expr||'').trim().replace(/,/g,'.');

  // 1) TeX-ification de l’expression
  t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}')
       .replace(/x\^(\d+)/gi, 'x^{\$1}')
       .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{\$2}')
       .replace(/(\d+(?:\.\d+)?)\s*\^\s*(\d+)/g, '{$1}^{\$2}')
       .replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{\$1}}')
       .replace(/\b1\s*\/\s*x\^(\d+)/gi,  '\\dfrac{1}{x^{\$1}}')
       .replace(/-\s*1\s*\/\s*x\b/gi,     '-\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*x\b/gi,       '\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}');

  // 2) Substitution x -> a (avec parenthèses si a<0)
  t = t.replace(/x\^{(\d+)}/gi,  `${A}^{\$1}`)
       .replace(/\\sqrt\{x\}/gi, `\\sqrt{${A}}`)
       .replace(/x\b/gi,         A);

  // 3) Insertion des \times entre nombre et (a)^p, a, √(...), (...)
  const escA = A.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');

  // n (a)^p  → n \times (a)^p
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}\\^\\{(\\d+)\\}`,'g'),
                '$1 \\\\times ' + A + '^{\$2}');
  // n a      → n \times a
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}(?![\\w])`,'g'),
                '$1 \\\\times ' + A);
  // n √(...) → n \times √(...)
  t = t.replace(/([+\-]?\d+)\s*\\sqrt\{/g, '$1 \\\\times \\\\sqrt{');
  // n (...)  → n \times (...)
  t = t.replace(/([+\-]?\d+)\s*\(/g,        '$1 \\\\times (');

  // 4) Filet de sécurité si un "times" nu subsistait
  t = t.replace(/\btimes\b/g, '\\times');

  return t;
}




/* ===== Ex. 6 — Équation de la tangente (f et f' donnés) + SÉLECTEUR ===== */
L.push({
  id:'ex6_eq_tangente_f_fx',
  title:"Ex. 6 — Équation de la tangente (f et f' donnés)",
  gen(forcedKind){
    // → on conserve 'poly' (exclut affine), et on ajoute 'affine' & 'linear'
    const kinds = ['square','cube','inverse','sqrt','affine','linear','poly'];
    const kind  = (forcedKind && forcedKind!=='random') ? forcedKind : rchoice(kinds);

    // Fabrique un polynôme de degré 2 ou 3 (≠ affine)
    // … à l’intérieur de gen(forcedKind) …
// dans gen(forcedKind) de l'exo 6
// Dans gen() de l'Ex.6
// --- PATCH polyGen (corrige l'affichage de dfx) ---
function polyGen(){
  const UMINUS = '−';
  const deg = rchoice([2,3]);                 // jamais affine
  const a = rchoice([-3,-2,-1,1,2,3]);
  const b = rchoice([-3,-2,-1,0,1,2,3]);
  const c = rchoice([-3,-2,-1,0,1,2,3]);
  const d = rchoice([-3,-2,-1,0,1,2,3]);

  // Monôme intérieur " ± A x^p " (cache A si A=1 et p>=1)
  const term = (K, p) => {
    if (K === 0) return '';
    const s = K > 0 ? ' + ' : ` ${UMINUS} `;
    const A = Math.abs(K);
    if (p === 0) return s + A;
    if (p === 1) return s + (A === 1 ? '' : A) + 'x';
    return s + (A === 1 ? '' : A) + `x^${p}`;
  };

  // Monôme de tête (sans " + " devant)
  const lead = (K, p) => {
    const S = K < 0 ? UMINUS : '';
    const A = Math.abs(K);
    if (p === 1) return S + (A === 1 ? '' : A) + 'x';
    return S + (A === 1 ? '' : A) + `x^${p}`;
  };

  let fx = '', dfx = '';

  if (deg === 3) {
    // f(x) = ax^3 + bx^2 + cx + d
    fx  = lead(a,3) + term(b,2) + term(c,1) + term(d,0);

    // f'(x) = 3ax^2 + 2bx + c
    const A3 = 3*a, B2 = 2*b;
    dfx = lead(A3,2) + term(B2,1) + term(c,0);
  } else {
    // f(x) = ax^2 + bx + c
    fx  = lead(a,2) + term(b,1) + term(c,0);

    // f'(x) = 2ax + b
    const A2 = 2*a;
    dfx = lead(A2,1) + term(b,0);
  }

  return {
    fx:  String(fx).replace(/^\+\s*/,'').trim(),
    dfx: String(dfx).replace(/^\+\s*/,'').trim()
  };
}



    let fx, dfx, xA;

    if(kind==='square'){    fx='x^2';             dfx='2x';            xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='cube'){ fx='x^3';             dfx='3x^2';          xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='inverse'){ fx='1/x';          dfx='-\\dfrac{1}{x^2}';        xA=rchoice([-3,-2,-1,1,2,3]);   } // ≠0
    else if(kind==='sqrt'){    fx='sqrt(x)';      dfx='\\dfrac{1}{2sqrt(x)}'; xA=rchoice([1,4,9]);   } // simple
    else if(kind==='affine'){
      const m = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // pente ≠0
      const b = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // b ≠0 pour éviter linéaire
      fx  = `${m}x ${b>=0?'+':''}${b}`;
      dfx = `${m}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else if(kind==='linear'){
      const k = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      fx  = `${k}x`;                                          // pas de “+ 0”
      dfx = `${k}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else{ // 'poly' (degré 2 ou 3 uniquement)
      const P = polyGen();
      fx=P.fx; dfx=P.dfx;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }

    return {kind, fx, dfx, xA};
  },

  render(host, st){
  const chosen = (window.__EXO6_KIND__ || 'random');
  const s = st.params || this.gen(chosen);
  host.dataset.state = JSON.stringify({params:s});
  const ui = renderNoRepere(host);

  // -- Helpers LaTeX très simples (suffisants pour nos formes) --
  const toTeX = (expr)=>{
    let t = String(expr||'').trim();

    // racines
    t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
         .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}');

    // puissances
    t = t.replace(/x\^(\d+)/gi, 'x^{\$1}')
         .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{\$2}')
         .replace(/(\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, '{$1}^{\$2}');

    // cas fraction simples
    t = t.replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{\$1}}')
         .replace(/-\s*1\s*\/\s*x\b/gi, '-\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*x\^(\d+)/gi, '\\dfrac{1}{x^{\$1}}')
         .replace(/\b1\s*\/\s*x\b/gi, '\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}');

    // décimale française → point (au cas où)
    t = t.replace(/,/g,'.');

    // multiplications : on laisse implicites (3x, 2x, …)
    return t;
  };

  // — Sélecteur textuel + bouton (inchangés) —
  const selectorHTML = `
    <div class="optionline small" style="margin-bottom:.4rem">
      <label for="kind6"><b>Type de fonction :</b></label>
      <select id="kind6">
        <option value="random">Aléatoire</option>
        <option value="square">Carré (x^2)</option>
        <option value="cube">Cube (x^3)</option>
        <option value="inverse">Inverse (1/x)</option>
        <option value="sqrt">Racine carrée (√x)</option>
        <option value="affine">Affine (mx + b)</option>
        <option value="linear">Linéaire (kx)</option>
        <option value="poly">Polynôme (deg 2–3)</option>
      </select>
      <button id="regen6" class="btn">↻ Tirer</button>
    </div>
  `;

  // — ÉNONCÉ : formules et points en LaTeX —
  ui.equ.innerHTML = `
    ${selectorHTML}
    <p>Donner une équation de la tangente \\(T\\) au point \\(A\\) de \\(C_f\\) d’abscisse \\(x_A\\).</p>
    <p>\\( f(x) = ${toTeX(s.fx)} \\) &nbsp; et &nbsp; \\( f'(x) = ${toTeX(s.dfx)} \\) &nbsp; en \\( x_A = ${fmtNum(s.xA)} \\).</p>
    ${mkInput('r1',260,'y = ...')} <span id="tr1" class="tick">—</span>
    <div id="steps6" class="steps"></div>
  `;

  host._state = s; host._ui = ui;

  // sélectionner l’option active et callbacks
  $('#kind6',host).value = chosen;
  const regenerate = (kind)=>{ window.__EXO6_KIND__ = kind; this.render(host,{params:this.gen(kind)}); };
  $('#kind6',host).addEventListener('change', e=>regenerate(e.target.value));
  $('#regen6',host).addEventListener('click', ()=>regenerate($('#kind6',host).value));

  // Typeset LaTeX de l’énoncé (incluant l’aperçu des formules)
  if (window.retypeMath) retypeMath(host);
},

  verify(host){
    const s=host._state;
    const m = evalExprSafe(s.dfx, s.xA);
    const y = evalExprSafe(s.fx , s.xA);
    const p = y - m*s.xA;
    const ok = isSameLine(getVal(host,'r1'), m, p);
    setTick($('#tr1',host), ok);
    return ok;
  },


  /* ===== Ex.6 — PATCH : only show \times on the f'(a) line ===== */
solution(host){
  const s  = host._state;
  const ui = host._ui;

  const pr = v => fmtNum(v);
function pushUnique(L, s){ if(!L.length || L[L.length-1]!==s) L.push(s); }

  // ------- LaTeX helpers (sans \times sauf pour la ligne d’évaluation de f') -------
  const texRat = (val)=>{                   // entier ou fraction
    const [V,H] = slopeVH(val);
    if(H===1) return String(V);
    const sgn = V<0 ? '-' : '';
    return `${sgn}\\dfrac{${Math.abs(V)}}{${H}}`;
  };
  /* === 1) mx sans \times (corrigé : gère m = 0) === */
const texMxNoTimes = (m)=>{
  const [V,H] = slopeVH(m);
  if (V === 0) return '0';                 // <- empêche "0x"
  if (H===1 && V=== 1) return 'x';
  if (H===1 && V===-1) return '-x';
  return `${texRat(m)}x`;
};

  // + a  /  - a  / rien si 0 — a est formaté en fraction exacte
const signAbsTex = (val)=>{
  const [V,H] = slopeVH(val);          // rationnalise val -> V/H
  if (V === 0) return '';
  const A = Math.abs(V);
  const chunk = (H === 1) ? String(A) : `\\dfrac{${A}}{${H}}`;
  return (V > 0 ? ' + ' : ' - ') + chunk;
};

  // Mise en TeX simple (pas de \times)
  const toTeX = (expr)=>{
    let t = String(expr||'').trim();
    t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\\\sqrt{x}')
         .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\\\sqrt{$1}')
         .replace(/x\^(\d+)/gi, 'x^{\$1}')
         .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{\$2}')
         .replace(/(\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, '{$1}^{\$2}')
         .replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\\\dfrac{1}{x^{\$1}}')
         .replace(/-\s*1\s*\/\s*x\b/gi,       '-\\\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*x\^(\d+)/gi,    '\\\\dfrac{1}{x^{\$1}}')
         .replace(/\b1\s*\/\s*x\b/gi,         '\\\\dfrac{1}{x}')
         .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\\\dfrac{1}{2\\\\sqrt{x}}')
         .replace(/,/g,'.');
    return t;
  };

  // >>> LIGNE 2 : f'(a) avec \times UNIQUEMENT ici <<<
 // ——— Ex.6 : f'(a) avec × UNIQUEMENT sur cette ligne ———
function texDerivEvalLine(expr, a){
  const pr = v => fmtNum(v);
  const aTex = (a < 0) ? `(${pr(a)})` : `${pr(a)}`;

  // TeX propre de f'(x), puis substitution x -> a
  let t = String(expr||'').trim();
  t = t.replace(/sqrt\(\s*x\s*\)/gi, '\\sqrt{x}')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '\\sqrt{$1}')
       .replace(/x\^(\d+)/gi, 'x^{\$1}')
       .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)^{\$2}')
       .replace(/(\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, '{$1}^{\$2}')
       .replace(/-\s*1\s*\/\s*x\^(\d+)/gi, '-\\dfrac{1}{x^{\$1}}')
       .replace(/-\s*1\s*\/\s*x\b/gi,       '-\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*x\^(\d+)/gi,    '\\dfrac{1}{x^{\$1}}')
       .replace(/\b1\s*\/\s*x\b/gi,         '\\dfrac{1}{x}')
       .replace(/\b1\s*\/\s*\(\s*2\s*sqrt\(\s*x\s*\)\s*\)/gi, '\\dfrac{1}{2\\sqrt{x}}')
       .replace(/,/g,'.');

  // Substitution x -> a (brackets si négatif)
  t = t.replace(/x\^{(\d+)}/gi, `${aTex}^{$1}`)
       .replace(/\\sqrt\{x\}/gi, `\\sqrt{${aTex}}`)
       .replace(/x\b/gi, aTex);

  // — Insertion du symbole × (Unicode) entre coefficient numérique et a/√a/(a)^n/(...)
  const escA = aTex.replace(/[-()]/g,'\\$&');
  // n (a)^n
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}\\^\\{(\\d+)\\}`,'g'),
                '$1 × ' + aTex + '^{\$2}');
  // n a
  t = t.replace(new RegExp(`([+\\-]?\\d+)\\s*${escA}(?![\\w])`,'g'),
                '$1 × ' + aTex);
  // n √(...)
  t = t.replace(/([+\-]?\d+)\s*\\sqrt\{/g, '$1 × \\sqrt{');
  // n ( ... )
  t = t.replace(/([+\-]?\d+)\s*\(/g,        '$1 × (');

  return t;
}
// --- utilitaire : comparaison "visuelle" de deux lignes LaTeX ---
function sameLatexLine(a, b){
  const norm = s => String(s)
    .replace(/<\/?[^>]+>/g, '')            // enlève HTML
    .replace(/\\\\\(|\\\\\)/g, '')         // enlève \( \)
    .replace(/\\,|\\;|\\!|\\:|~|\\ /g, '') // espaces LaTeX
    .replace(/\s+/g, '')                   // plus aucun espace
    .replace(/\\frac/g, '\\dfrac')         // unifie frac/dfrac
    .replace(/−/g, '-')                    // moins unicode
    .replace(/\+\-/g, '-')                 // "+ -" -> "-"
    .replace(/\-\+/g, '-')                 // "- +" -> "-"
    .replace(/\-\-/g, '+');                // "--" -> "+"
  return norm(a) === norm(b);
}


  // --- Évaluations robustes (même si s.fx/s.dfx avaient déjà du TeX) ---
  const a  = s.xA;
  const m  = evalExprSafe( asEvalExpr(s.dfx), a );
  const yA = evalExprSafe( asEvalExpr(s.fx) , a );

  const mVH = slopeVH(m);
  const pVH = pFromPoint(...mVH, a, yA);

  // --- Pré-remplissage ASCII (oblige "y =", * explicites, pas de 1x/-1x) ---
 /* === 2) Pré-remplissage ASCII (corrigé : pas de 0x) === */
(function prefillASCII(){
  // m = V/H ; p = pVH[0]/pVH[1]
  const [mV,mH] = mVH, [pV,pH] = pVH;
  let rhs = 'y = ';
  if (mV === 0) {
    // y = p
    rhs += (pH===1) ? String(pV) : '('+pV+'/'+pH+')';
  } else {
    // y = (V/H)*x [+/- p]
    let mTerm;
    if (mH===1 && mV=== 1) mTerm = 'x';
    else if (mH===1 && mV===-1) mTerm = '-x';
    else mTerm = '('+mV+'/'+mH+')*x';
    rhs += mTerm;
    if (pV !== 0){
      const pAbs = (pH===1) ? String(Math.abs(pV))
                            : '('+Math.abs(pV)+'/'+pH+')';
      rhs += (pV > 0 ? ' + ' : ' - ') + pAbs;
    }
  }
  setVal(host,'r1', rhs);
})();


  // Pas de .steps (prime) -> on enlève si présent
  const old = $('#steps6', host);
  if (old) old.remove();

  // Boîte grisée LaTeX
  let sol = ui.right.querySelector('#sol-ex6');
  if(!sol){
    sol = document.createElement('div');
    sol.id = 'sol-ex6';
    sol.className = 'solution solbox';
    ui.right.appendChild(sol);
  }else{
    sol.classList.add('solution','solbox');
    sol.innerHTML = '';
  }

 function fixSigns(s){
  return String(s)
    .replace(/\+\s*-\s*/g, ' - ')
    .replace(/-\s*\+\s*/g, ' - ')
    .replace(/-\s*-\s*/g, ' + ');
}
// Normalisation d’un fragment TeX en ligne (pas une ligne entière)
function normTexInline(t){
  return String(t)
    .replace(/\s+/g,'')          // espaces
    .replace(/\\frac/g,'\\dfrac')// unifie frac/dfrac
    .replace(/−/g,'-')           // moins unicode
    .replace(/\+\-/g,'-')        // +-
    .replace(/\-\+/g,'-')        // -+
    .replace(/\-\-/g,'+');       // --
}

// "lhs [= rhs]" mais on supprime rhs si identique à lhs
function eqOnce(lhs, rhs){
  return (normTexInline(lhs) === normTexInline(rhs)) ? lhs : `${lhs} = ${rhs}`;
}

  /* === 3) Lignes de solution : pas de "0x" ni doublons === */
const L = [];

// L1 : f(a)
const fEval = texFxEvalLine(s.fx, a); // ex: \dfrac{1}{3} ou \sqrt{9}
const fVal  = texRat(yA);             // ex: \dfrac{1}{3} ou 3
L.push(`<p>\\(f(${fmtNum(a)}) = ${eqOnce(fEval, fVal)}\\)</p>`);

// L2 : f'(a) (c’est la seule ligne avec le symbole ×)
const dEval = texDerivEvalLine(s.dfx, a); // ex: 3, \dfrac{1}{2}\sqrt{...}, ...
const dVal  = texRat(m);                  // valeur numérique en fraction
L.push(`<p>\\(f'(${pr(a)}) = ${eqOnce(dEval, dVal)}\\)</p>`);
L.push(`<p>\\(y = f'(${pr(a)})(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))}) + f(${pr(a)})\\)</p>`);

// L3 : équation point-pente
// L3 : équation point-pente (jamais '+ -', jamais décimal)
L.push(`<p>\\(y = ${texRat(m)}(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))})${signAbsTex(yA)}\\)</p>`);

// L4 : remplacement m,f(a) — simplifie le cas m=0
if (m === 0) {
  L.push(`<p>\\(y = ${texRat(yA)}\\)</p>`);
} else {
  L.push(`<p>\\(y = ${texRat(m)}(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))}) + ${texRat(yA)}\\)</p>`);
}


// L5 : développement — n’affiche pas "0x" et jamais de décimal
const t1 = m * (-a);
if (m !== 0) {
  L.push(`<p>\\(y = ${texMxNoTimes(m)}${signAbsTex(t1)}${signAbsTex(yA)}\\)</p>`);
}


// L6 : forme finale — compacte (m=0 -> y=p ; p=0 -> y=mx)
// ...après avoir rempli L avec les étapes précédentes...
const finalLine = (()=>{
  const pTex = (pVH[0]===0) ? '0'
           : (pVH[1]===1) ? String(Math.abs(pVH[0]))
                           : `\\dfrac{${Math.abs(pVH[0])}}{${pVH[1]}}`;
  if (m === 0)           return `y = ${(pVH[0]===0)?'0':(pVH[0]<0?'- ':'')+pTex}`;
  if (pVH[0]===0)        return `y = ${texMxNoTimes(m)}`;
  return `y = ${texMxNoTimes(m)} ${pVH[0]>0?'+':'-'} ${pTex}`;
})();

const finalHTML = `<p><b>\\(${finalLine}\\)</b></p>`;
if (!sameLatexLine(L[L.length-1], finalHTML)) {
  L.push(finalHTML);   // on n’ajoute la dernière ligne que si elle apporte quelque chose
}


/* --- 4) Anti-doublon (consécutif) avant rendu --- */
function dedupConsecutive(htmlLines){
  const out=[]; let prev='';
  for(const s of htmlLines){
    const n = s.replace(/<\/?[^>]+>/g,'').replace(/\\\\\(|\\\\\)/g,'').replace(/\s+/g,' ').trim();
    if(n!==prev){ out.push(s); prev=n; }
  }
  return out;
}
const Lfixed = L.map(fixSigns);
sol.innerHTML = dedupConsecutive(Lfixed).join('');
if (window.retypeMath) retypeMath(sol);

}


});


/* ===== Ex. 7 — Tracer T avec f′(a) (2 clics : 1er clic affiche A/B/C) ===== */
L.push({
  id:'ex7_graph_mix',
  title:"Ex. 7 — Tangentes à partir du nombre dérivé (2 clics, A/B/C au 1er clic)",

  gen(){
    // Courbe C¹ lisible issue de ton générateur (A: f'(x)=0 ; B: pente entière ; C: pente rationnelle)
    const RVIS = {xmin:-8,xmax:8,ymin:-8,ymax:8};
    const g = HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
    const items = [
      { kind: (Math.abs(g.A.m)<1e-12?'horiz':'gen'), x:g.A.x, y:g.A.y, m:g.A.m },
      { kind: (Math.abs(g.B.m)<1e-12?'horiz':'gen'), x:g.B.x, y:g.B.y, m:g.B.m },
      { kind: (Math.abs(g.C.m)<1e-12?'horiz':'gen'), x:g.C.x, y:g.C.y, m:g.C.m }
    ];
    items.forEach(t => t.VH = slopeVH(t.m));               // pente attendue sous forme [V,H] réduite
    const order = [0,1,2].sort(()=>Math.random()-0.5);     // ordre aléatoire des 3 tâches
    const tasks = order.map(i => items[i]);
    // libellés affichés A,B,C dans l'ordre des questions (et pas des points internes)
    const labels = ['A','B','C'];
    return { R:RVIS, f:g.f, df:g.df, tasks, labels };
  },

  render(host, st){
    const s = st.params || this.gen();
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderWithRepere(host, s.R);

    // Courbe seule au départ
    ui.rep.drawCurve(s.f,'#212121',2.5);
function setTickPending(el){
  if(!el) return;
  el.textContent = '—';
  el.classList.remove('ok','ko'); // enlève couleurs V/X
}
[0,1,2].forEach(i=>{
  setTickPending($('#tbuild'+i,host));
  setTickPending($('#teq'+i,host));
});

    // Texte d'énoncé + champ d'équation à côté de Tᵢ
    // helper LaTeX pour une pente [V,H]
const mTeX = ([V,H]) => (H===1 ? String(V) : `\\dfrac{${V}}{${H}}`);

const bloc = s.tasks.map((t,i)=>{
  const SUB = ['₁','₂','₃'];
  const a = fmtNum(t.x), lab = s.labels[i];
  return `
    <li style="margin:.6rem 0">
      On admet que \\(\\,f'(${a}) = ${mTeX(t.VH)}\\,\\).<br>
      Tracer la tangente \\(T_{${i+1}}\\) à la courbe \\(C_f\\) au point d’abscisse \\( ${a} \\).
      On appellera ce point \\(\\mathbf{${lab}}\\).<br>
      <span class="small">Clic 1 : sur le point d’abscisse ${a} (affiche « ${lab} »). Clic 2 : autre point pour fixer \\(T_{${i+1}}\\).</span><br>
      <button class="btn" data-start="${i}">🎯 Activer T${SUB[i]}</button>
      &nbsp; \\(T_{${i+1}}:\\) <input id="eq${i}" style="width:240px" placeholder="y = ..." autocomplete="off"> <span id="teq${i}" class="tick"></span>
      <span id="tbuild${i}" class="tick" style="margin-left:.4rem"></span>
    </li>`;
}).join('');

ui.equ.innerHTML = `
  <p><b>Consigne.</b> Pour chaque tangente \\(T_i\\) : <b>cliquez d’abord</b> sur le point d’abscisse demandée (le point \\(\\mathbf{A/B/C}\\) apparaît), puis <b>cliquez un second point</b> pour tracer \\(T_i\\). Écrivez ensuite l’<b>équation</b> de \\(T_i\\) dans la barre à côté.</p>
  <ol>${bloc}</ol>
`;
if (window.retypeMath) retypeMath(ui.equ);


    // État d’interaction
    host._state = {
      ...s,
      active: null,                      // indice de la question activée (0..2)
      anchors: [null,null,null],         // 1er clic (point A/B/C)
      secondPts: [null,null,null]        // 2e clic (point sans étiquette)
    };
    host._ui = ui;

    // Helpers de dessin
    function drawDot(rep,x,y,color){
      const c = document.createElementNS(rep.el.namespaceURI,'circle');
      const p = rep.coordToScreen(x,y);
      c.setAttribute('cx',p.x); c.setAttribute('cy',p.y);
      c.setAttribute('r',4); c.setAttribute('fill',color);
      rep.gUser.appendChild(c);
    }
    function drawLabel(rep, x,y, txt, color='#f57c00'){
      const t = document.createElementNS(rep.el.namespaceURI,'text');
      const p = rep.coordToScreen(x,y);
      t.setAttribute('x',p.x); t.setAttribute('y',p.y);
      t.setAttribute('font-size','12'); t.setAttribute('fill',color); t.setAttribute('font-weight','700');
      t.textContent = txt;
      rep.gUser.appendChild(t);
      rep._placeLabel(t, p.x, p.y);
    }
    function drawLine(rep, x0,y0, x1,y1, color='#2e7d32'){
      if(x0===x1) return; // on évite la verticale (non demandée ici)
      const m = (y1-y0)/(x1-x0);
      const xa=rep.R.xmin, xb=rep.R.xmax;
      const ya = m*(xa-x0)+y0, yb = m*(xb-x0)+y0;
      const A=rep.coordToScreen(xa,ya), B=rep.coordToScreen(xb,yb);
      const L=document.createElementNS(rep.el.namespaceURI,'line');
      L.setAttribute('x1',A.x); L.setAttribute('y1',A.y);
      L.setAttribute('x2',B.x); L.setAttribute('y2',B.y);
      L.setAttribute('stroke',color); L.setAttribute('stroke-width','2'); L.setAttribute('stroke-dasharray','6 6');
      rep.gUser.appendChild(L);
    }
    function redrawUser(){
      ui.rep.gUser.innerHTML='';
      for(let i=0;i<3;i++){
        const A = host._state.anchors[i], E = host._state.secondPts[i];
        if(A){ drawDot(ui.rep, A.x, A.y, '#f57c00'); drawLabel(ui.rep, A.x, A.y, s.labels[i], '#f57c00'); }
        if(A && E){ drawDot(ui.rep, E.x, E.y, '#2e7d32'); drawLine(ui.rep, A.x, A.y, E.x, E.y, '#2e7d32'); }
      }
    }

    // Activation par bouton
    ui.right.querySelectorAll('button[data-start]').forEach(btn=>{
      btn.addEventListener('click', e=>{
  host._state.active = parseInt(e.currentTarget.dataset.start,10);
  const i = host._state.active;
  setTickPending($('#tbuild'+i,host));
  setTickPending($('#teq'+i,host));
});

    });

    // --- helper : coordonnées SVG (viewBox) depuis un event pointeur ---
function toSvgCoords(svg, ev){
  const cx = ('clientX' in ev) ? ev.clientX : ev.touches?.[0]?.clientX;
  const cy = ('clientY' in ev) ? ev.clientY : ev.touches?.[0]?.clientY;
  const ctm = svg.getScreenCTM && svg.getScreenCTM();
  if (ctm && ctm.inverse){
    const pt = svg.createSVGPoint();
    pt.x = cx; pt.y = cy;
    const p = pt.matrixTransform(ctm.inverse());
    return {x:p.x, y:p.y}; // unités du viewBox (0..420)
  }
  // Fallback rect/ratio
  const r  = svg.getBoundingClientRect();
  const vb = svg.viewBox?.baseVal || {x:0,y:0,width:420,height:420};
  return {
    x: (cx - r.left) * (vb.width  / r.width),
    y: (cy - r.top)  * (vb.height / r.height)
  };
}

// --- gestion du tap/clic (pointer + click fallback) ---
const handleTap = (ev) => {
  if (host._state.active === null) return;
  if (ev.pointerType === 'touch') ev.preventDefault();

  // 1) écran → viewBox → repère
  const Pvb = toSvgCoords(ui.rep.el, ev);
  const P   = ui.rep.screenToCoord(Pvb.x, Pvb.y);
  const xi  = Math.round(P.x);
  const yi  = Math.round(P.y);

  const i    = host._state.active;
  const task = host._state.tasks[i];



  // ---- Vérification (même logique qu’avant) ----
  const A = host._state.anchors[i], E = host._state.secondPts[i];
  let ok = false;
  if (E && !(E.x===A.x && E.y===A.y)){
    if (Math.abs(task.m) < 1e-12){
      ok = (E.y === A.y) && (E.x !== A.x);
    } else if (E.x !== A.x){
      const r1 = reduce(E.y - A.y, E.x - A.x), r2 = reduce(...task.VH);
      ok = (r1[0]*r2[1] === r2[0]*r1[1]);
    }
  }
  setTick($('#tbuild'+i,host), ok);
    // ---- 1er clic : uniquement l’abscisse (on "snappe" à A=(a,f(a)) ) ----
  if (!host._state.anchors[i]){
    const tol = 0.6; // tolérance sur x en unités du repère
    if (Math.abs(P.x - task.x) <= tol){
      host._state.anchors[i] = { x: task.x, y: task.y }; // y forcé à f(a)
      redrawUser();
	  	  setTickPending($('#tbuild'+i,host)); // pas de X rouge après le 1er clic

    }
    return;
  }

  // ---- 2e clic : second point (arrondi à la grille entière) ----
  host._state.secondPts[i] = { x: xi, y: yi };
  redrawUser();
    setTick($('#tbuild'+i,host), ok);   // V/X uniquement après le 2e clic

};

ui.rep.el.addEventListener('pointerdown', handleTap, {passive:false});
ui.rep.el.addEventListener('click',       handleTap, {passive:true}); // fallback desktop


    redrawUser();
  },

  verify(host){
    // Valide si : construction correcte + équation correcte, pour chaque question
    const s = host._state;
    const allOK = [0,1,2].map(i=>{
      const t = s.tasks[i], A = s.anchors[i], E = s.secondPts[i];
if(!A || !E){
  setTickPending($('#tbuild'+i,host)); // au lieu de setTick(..., null/false)
  return false;
}

      // construction
      let okBuild=false;
      if(Math.abs(t.m)<1e-12){ okBuild = (E.y===A.y) && (E.x!==A.x); }
      else if(E.x!==A.x){
        const r1 = reduce(E.y-A.y, E.x-A.x), r2 = reduce(...t.VH);
        okBuild = (r1[0]*r2[1] === r2[0]*r1[1]);
      }
      setTick($('#tbuild'+i,host), okBuild);

      // équation attendue : y = (V/H)x + p  avec p = yA - (V/H)a
      const mVH = t.VH;
      const pVH = pFromPoint(...mVH, t.x, t.y);
      const ans = getVal(host,'eq'+i).trim();
if (!ans){
  setTickPending($('#teq'+i,host));    // rien saisi → “—”
  return false;
}

// APRÈS
const okEq =
  lineOKStrict(ans, mVH, pVH) ||
  isSameLine(ans, t.VH[0]/t.VH[1], pVH[0]/pVH[1]); // accepte y=2x et y=2x+0
setTick($('#teq'+i,host), okEq);


      return okBuild && okEq;
    });
    return allOK.every(Boolean);
  },

  solution(host){
  const s  = host._state;
  const ui = host._ui;

  // — helpers LaTeX (mêmes esprits que Ex.6) —
  const texRat = (val)=>{           // entier ou fraction (via slopeVH)
    const [V,H] = slopeVH(val);
    if (H===1) return String(V);
    const sgn = V<0 ? '-' : '';
    return `${sgn}\\dfrac{${Math.abs(V)}}{${H}}`;
  };
  const texMx = (m)=>{              // mx sans \times
    const [V,H] = slopeVH(m);
    if (V===0) return '0';
    if (H===1 && V=== 1) return 'x';
    if (H===1 && V===-1) return '-x';
    return `${texRat(m)}x`;
  };
  const signAbsTex = (val)=>{       // " + a" / " - a" / ""
    const [V,H] = slopeVH(val);
    if (V===0) return '';
    const A = Math.abs(V);
    const chunk = (H===1) ? String(A) : `\\dfrac{${A}}{${H}}`;
    return (V>0 ? ' + ' : ' - ') + chunk;
  };
  const normTexInline = t => String(t)
    .replace(/\s+/g,'').replace(/\\frac/g,'\\dfrac')
    .replace(/−/g,'-').replace(/\+\-/g,'-').replace(/\-\+/g,'-').replace(/\-\-/g,'+');
  const eqOnce = (lhs, rhs) => (normTexInline(lhs)===normTexInline(rhs)) ? lhs : `${lhs} = ${rhs}`;
  const sameLatexLine = (a,b)=>{
    const n = s => String(s).replace(/<\/?[^>]+>/g,'').replace(/\\\\\(|\\\\\)/g,'').replace(/\s+/g,' ').trim();
    return n(a)===n(b);
  };
  const fixSigns = s => String(s).replace(/\+\s*-\s*/g,' - ').replace(/-\s*\+\s*/g,' - ').replace(/-\s*-\s*/g,' + ');
  const dedupConsecutive = lines=>{
    const out=[]; let prev='';
    for(const L of lines){
      const n = L.replace(/<\/?[^>]+>/g,'').replace(/\\\\\(|\\\\\)/g,'').replace(/\s+/g,' ').trim();
      if(n!==prev){ out.push(L); prev=n; }
    }
    return out;
  };

  // — conteneur : boîte grisée unique —
  let sol = ui.right.querySelector('#sol-ex7');
  if(!sol){
    sol = document.createElement('div');
    sol.id = 'sol-ex7';
    sol.className = 'solution solbox';
    ui.right.appendChild(sol);
  }else{
    sol.className = 'solution solbox';
    sol.innerHTML = '';
  }

  const L = [];

  // Pour chaque tangente
  s.tasks.forEach((t,i)=>{
    const a   = t.x;
    const yA  = t.y;
    const [V,H] = t.VH;         // pente réduite
    const m   = (Math.abs(t.m) < 1e-12) ? 0 : (V/H);

    // Pré-remplissage simple ASCII côté input (utile pour l’utilisateur)
    const pVH = pFromPoint(V,H,a,yA);
    (function prefill(){
      let rhs = 'y = ';
      if (V===0) rhs += (pVH[1]===1) ? String(pVH[0]) : '('+pVH[0]+'/'+pVH[1]+')';
      else{
        if (H===1 && V=== 1) rhs += 'x';
        else if (H===1 && V===-1) rhs += '-x';
        else rhs += '('+V+'/'+H+')*x';
        if (pVH[0]!==0){
          const pAbs = (pVH[1]===1) ? String(Math.abs(pVH[0])) : '('+Math.abs(pVH[0])+'/'+pVH[1]+')';
          rhs += (pVH[0]>0 ? ' + ' : ' - ') + pAbs;
        }
      }
      setVal(host,'eq'+i, rhs);
    })();
// En-tête de section (LaTeX) — pas de <div>
L.push(`<p><b>Pour \\(T_{${i+1}}\\) :</b></p>`);

    // — Lignes LaTeX (fractions only) —
    // L1 : f(a)
    const fEval = `f(${fmtNum(a)})`;
    const fVal  = texRat(yA);
    L.push(`<p>\\(${eqOnce(fEval, fVal)}\\)</p>`);

    // L2 : f'(a)
    const mTeX = (H===1) ? String(V) : `\\dfrac{${V}}{${H}}`;
    L.push(`<p>\\(f'(${fmtNum(a)}) = ${mTeX}\\)</p>`);

    // L3 : point-pente
    L.push(`<p>\\(y = f'(${fmtNum(a)})(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))}) + f(${fmtNum(a)})\\)</p>`);

    // L4 : substitution numérique (fractions, pas de "+-")
    L.push(`<p>\\(y = ${mTeX}(x ${a<0?'+':'-'} ${fmtNum(Math.abs(a))}) + ${texRat(yA)}\\)</p>`);

   // L5 — développement (pas "0x")
if (m !== 0) {
  const t1 = m * (-a);
  L.push(`<p>\\(y = ${texMx(m)}${signAbsTex(t1)}${signAbsTex(yA)}\\)</p>`);
}
// (sinon, on ne met rien ici : la ligne finale suffira)

    // L6 : forme finale compacte
    const pAbs = (pVH[1]===1) ? String(Math.abs(pVH[0])) : `\\dfrac{${Math.abs(pVH[0])}}{${pVH[1]}}`;
    let final;
    if (V===0)           final = `y = ${(pVH[0]===0)?'0':(pVH[0]<0?'- ':'')+pAbs}`;
    else if (pVH[0]===0) final = `y = ${texMx(m)}`;
    else                 final = `y = ${texMx(m)} ${pVH[0]>0?'+':'-'} ${pAbs}`;

    const last = `<p><b>\\(${final}\\)</b></p>`;
    if (!sameLatexLine(L[L.length-1], last)) L.push(last);
	if (i < s.tasks.length - 1) {
  // Espace vertical entre T1 / T2 / T3 (sans <div>)
  L.push(`<p style="margin:.7rem 0"></p>`);
}

  });

  sol.innerHTML = dedupConsecutive(L.map(fixSigns)).join('');
  // === Remplacer le repère de GAUCHE par un clone avec tangentes + labels ===
(function replaceLeftWithSolvedSVG(){
  const ui = host._ui;
  const s  = host._state;
  const NS = ui.rep.el.namespaceURI;

  // Intersections tangente / fenêtre (coords du repère)
  function segmentInBox_throughPointSlope(x0,y0,m,R){
    const cand = [];
    const yL = m*(R.xmin - x0) + y0; if (yL >= R.ymin && yL <= R.ymax) cand.push({x:R.xmin, y:yL});
    const yR = m*(R.xmax - x0) + y0; if (yR >= R.ymin && yR <= R.ymax) cand.push({x:R.xmax, y:yR});
    if (Math.abs(m) > 1e-12){
      const xB = x0 + (R.ymin - y0)/m; if (xB >= R.xmin && xB <= R.xmax) cand.push({x:xB, y:R.ymin});
      const xT = x0 + (R.ymax - y0)/m; if (xT >= R.xmin && xT <= R.xmax) cand.push({x:xT, y:R.ymax});
    } else {
      cand.push({x:R.xmin, y:y0}, {x:R.xmax, y:y0});
    }
    const uniq=[]; for (const p of cand)
      if (!uniq.some(q => Math.abs(q.x-p.x)<1e-9 && Math.abs(q.y-p.y)<1e-9)) uniq.push(p);
    while (uniq.length < 2) uniq.push({x:s.R.xmin, y:y0}, {x:s.R.xmax, y:y0});
    return uniq.slice(0,2);
  }

  // 1) Clone le SVG existant (même grid/styles), sans handlers
  const repEl = ui.rep.el;
  const clone = repEl.cloneNode(true);
  clone.style.pointerEvents = 'none';         // fig. statique pour le corrigé
  // éviter des IDs dupliqués
  clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));

  // 2) Calque utilisateur dans le clone (ou crée-le)
  let gUser = clone.querySelector('g.gUser') || clone.querySelector('g[data-layer="user"]');
  if (!gUser){
    gUser = document.createElementNS(NS, 'g');
    gUser.setAttribute('class', 'gUser');
    clone.appendChild(gUser);
  } else {
    gUser.innerHTML = ''; // nettoie ce calque dans le clone
  }

  // 3) Ajoute T1/T2/T3 + points + labels A/B/C …
const DASH    = ['6 6', '0', '10 4 2 4'];             // motifs inchangés
const COLORS  = ['#1e40af', '#16a34a', '#dc2626'];     // bleu, vert, rouge

s.tasks.forEach((t,i)=>{
  const color = COLORS[i];                             // <- couleur de la tangente i
  const m = (Math.abs(t.m) < 1e-12) ? 0 : (t.VH[0] / t.VH[1]);
  const [P1, P2] = segmentInBox_throughPointSlope(t.x, t.y, m, s.R);
  const A = ui.rep.coordToScreen(P1.x, P1.y);
  const B = ui.rep.coordToScreen(P2.x, P2.y);
  const C = ui.rep.coordToScreen(t.x,  t.y);

  // ligne de tangente (couleur dédiée)
  const L = document.createElementNS(NS, 'line');
  L.setAttribute('x1', A.x); L.setAttribute('y1', A.y);
  L.setAttribute('x2', B.x); L.setAttribute('y2', B.y);
  L.setAttribute('stroke', color);                     // <-- ici
  L.setAttribute('stroke-width', '2.4');
  L.setAttribute('vector-effect', 'non-scaling-stroke');
  if (DASH[i] !== '0') L.setAttribute('stroke-dasharray', DASH[i]);
  gUser.appendChild(L);

  // point A/B/C : (on garde l’orange)
  const dot = document.createElementNS(NS, 'circle');
  dot.setAttribute('cx', C.x); dot.setAttribute('cy', C.y);
  dot.setAttribute('r', '4.2');
  dot.setAttribute('fill', '#f57c00');
  gUser.appendChild(dot);

  // label A/B/C (orange, inchangé)
  const T = document.createElementNS(NS, 'text');
  T.textContent = s.labels[i];
  T.setAttribute('x', C.x + 6);
  T.setAttribute('y', C.y - 6);
  T.setAttribute('font-size', '12');
  T.setAttribute('font-weight', '700');
  T.setAttribute('fill', '#f57c00');
  T.setAttribute('paint-order','stroke');
  T.setAttribute('stroke','#fff');
  T.setAttribute('stroke-width','3');
  gUser.appendChild(T);

  // nom de la tangente Tᵢ avec la même couleur que la ligne
  const SUB = ['₁','₂','₃'];
  const xm = (A.x + B.x) / 2, ym = (A.y + B.y) / 2;
  const TT = document.createElementNS(NS,'text');
  TT.textContent = 'T' + SUB[i];
  TT.setAttribute('x', xm + 6);
  TT.setAttribute('y', ym - 6);
  TT.setAttribute('font-size', '12');
  TT.setAttribute('font-weight', '700');
  TT.setAttribute('fill', color);                     // <-- ici
  TT.setAttribute('paint-order','stroke');
  TT.setAttribute('stroke','#fff');
  TT.setAttribute('stroke-width','3');
  gUser.appendChild(TT);
});

  // 4) Remplace le repère de GAUCHE par le clone enrichi
  repEl.replaceWith(clone);
  ui.rep.el = clone; // met à jour la référence interne si nécessaire
})();

  if (window.retypeMath) retypeMath(sol);

  // (Optionnel) laisser ton dessin des tangentes de solution si tu le souhaites
  // drawSolutionTangents();  // <- si tu gardes ta fonction utilitaire
}

});



  return L;
}


/* ===== REGISTRY & UI glue — VERSION FINALE ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, {});
	// -- PATCH: mémorise les paramètres tirés pour cet exo --
try {
  const st = JSON.parse(host.dataset.state || '{}');
  if (def.id && st && st.params) {
    window.__EXO_PARAMS_CACHE[def.id] = st; // ex: {params: ...}
  }
} catch(e){ /* no-op */ }

  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d’affichage :</b> ${e.message}<br>Ouvre la console pour le détail.
    </div>`;
  }
}

function scoreSet(a,b){ const s=document.querySelector('#score'); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  // init UI exercices
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    host._noFillSolution = true;
    try{ def.solution(host); }catch(e){ console.error(e); }
    canonizeAllSteps(host);
    host._noFillSolution = false;
  });

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    const inputs = Array.from(host.querySelectorAll('input'));
    const allFilled = inputs.every(i => String(i.value||'').trim()!=='');
    let ok=false;
    try{ ok = def.verify(host); }catch(e){ console.error(e); }
    if(allFilled){
      if(ok){ SCORE[0]++; SCORE[1]++; } else { SCORE[1]++; }
      scoreSet(...SCORE);
    }
  });
});


</script>

<script>
window.addEventListener('load', function () {
  if (!(window.ExoPDF && ExoPDF.init)) return;

  ExoPDF.init({
    title: 'Première — Nombres dérivés & tangentes',
    max: 50,
    mountAfterSelector: '#info-saisie',
    leadByDefId: {
      ex1_deriv_graph: "Lire sur la courbe la valeur du nombre dérivé f'(a).",
      ex2_tangentes_triple: "Lecture de valeurs et d’équations de tangentes.",
      ex3_derivee_lineaire: "Calculer f'(a) et les pentes des tangentes.",
      ex4_tangent_par_deux_points: "Retrouver f'(a) à partir d’une tangente donnée par deux points.",
      ex5_eq_tangente_point_pente: "Donner l’équation de la tangente connaissant le point et la pente.",
      ex6_eq_tangente_f_fx: "Donner l’équation de la tangente à partir de f et f'.",
      ex7_graph_mix: "Lecture graphique : valeurs, pentes et tangentes."
    },

    beforeRender(def, st, withSolutions){
      // Exos "à courbe" : 2 colonnes (gauche: repère | droite: texte)
      const TWO_COL = new Set(['ex1_deriv_graph','ex2_tangentes_triple','ex7_graph_mix']);

      // Renforce la barre de fraction pour le PDF
      const FRAC_FIX = `<style>
        .frac>.num{ border-bottom:0!important; position:relative; }
        .frac>.num::after{ content:""; position:absolute; left:0; right:0; bottom:-1px; height:2px; background:currentColor; }
      .pdf-blank{ line-height:1.2 }
@media print { .pdf-blank{ border-bottom-width:2px !important } }
.pdf-blank{ font-family: ui-monospace, Menlo, Consolas, monospace; }
	  </style>`;

      // Table 2 colonnes
      const twoCol = (L,R)=>`
        <table style="width:100%;border-collapse:collapse;table-layout:fixed">
          <tr>
            <td style="width:54%;vertical-align:top;padding:0 12px 0 0">${L||''}</td>
            <td style="width:46%;vertical-align:top;padding:0">${R||''}</td>
          </tr>
        </table>`;

      // Nettoyage des éléments interactifs (inputs, boutons, ticks…)
      function stripInteractive(root){
  const $$ = sel => Array.from(root.querySelectorAll(sel));
  const pxPerCh = 9;

  $$('input, textarea').forEach(el=>{
  const id  = (el.id||'').toLowerCase();
  const ph  = (el.getAttribute('placeholder')||'').toLowerCase();

  const isEq  = /^t\d/.test(id) || /^eq/.test(id) || /y\s*=|tangente|droite/.test(ph);
  const isVal = /^f[a-z]/i.test(el.id||'');   // fA, fB, fD…
  const isDer = /^df[a-z]/i.test(el.id||'');  // dfA, dfB, dfD…

  const pxPerCh = 9;
  const sw    = parseInt((el.style.width||'').replace('px','')) || 0;
  const sz    = el.getAttribute('size') ? parseInt(el.getAttribute('size'),10)*pxPerCh : 0;
  const phw   = ph.length * pxPerCh;
  const force = parseInt(el.dataset.pdfw || el.dataset.printWidth || '') || 0;

  // Si l'input est dans un wrapper .blank-wrap, on récupère sa largeur déclarée
  const wrapper = el.parentElement && el.parentElement.classList.contains('blank-wrap') ? el.parentElement : null;
  const wrapW   = wrapper ? parseInt(wrapper.dataset.w||'0',10) : 0;

  const W = force || (isEq ? 320 : (isVal||isDer ? 140 : 180));
  const width = Math.max(W, sw, sz, phw, 80, wrapW);

  const span = document.createElement('span');
span.className = 'pdf-blank';

// largeur “typographique” ≈ 8 px par underscore en police monospace
const nUnders = Math.max(10, Math.round(width / 8));
span.textContent = '_'.repeat(nUnders);

// style (monospace, hauteur correcte). On garde aussi une bordure au cas où.
span.style.cssText =
  'display:inline-block;vertical-align:baseline;' +
  'font-family: ui-monospace, Menlo, Consolas, monospace;' +
  'line-height:1.2; height:1.4em;' +
  `min-width:${width}px;` +                  // garantit la largeur
  'border-bottom:2px solid #000;';           // si les _ ne plaisent pas au moteur


  // Si on a un jumeau .blank déjà présent, on l'enlève pour éviter le double-trait
  if(wrapper){
    const b = wrapper.querySelector('.blank'); if(b) b.remove();
    wrapper.replaceWith(span);
  }else{
    el.replaceWith(span);
  }
});


  // Nettoyage UI
  $$('button, select, option, .tick, .optionline, [data-math-kbd], .kbd-host').forEach(n=>n.remove());
  $$('[contenteditable]').forEach(n=>n.removeAttribute('contenteditable'));
  return root;
}


      // Clone inline du premier <svg> pour une impression fiable
      function svgInline(root, opts={}){
        const svg = root.querySelector('svg');
        if(!svg) return '';
        const c = svg.cloneNode(true);
        if(!c.getAttribute('viewBox')){
          const vb = svg.viewBox && svg.viewBox.baseVal
            ? svg.viewBox.baseVal
            : {x:0,y:0,width:(svg.width?.baseVal?.value||420),height:(svg.height?.baseVal?.value||420)};
          c.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
        }
        c.setAttribute('xmlns','http://www.w3.org/2000/svg');
        c.setAttribute('preserveAspectRatio','xMidYMid meet');
        c.setAttribute('width',  String(opts.widthPx || 360));
        c.setAttribute('height', String(opts.heightPx || 360));
        // petits allégements
        c.querySelectorAll('path, polyline, line').forEach(el=>{
          const sw = parseFloat(el.getAttribute('stroke-width')||'2');
          el.setAttribute('stroke-width', String(Math.max(0.9, sw*0.85)));
        });
        return `<div style="display:block;width:${opts.blockWidth||'100%'}">${c.outerHTML}</div>`;
      }

      // Rendu hors-écran à taille non nulle (sinon getBBox flanche)
      const tmp = document.createElement('div');
      Object.assign(tmp.style, {
        position:'fixed', left:'-10000px', top:'-10000px',
        width:'420px', height:'420px', overflow:'hidden'
      });
      document.body.appendChild(tmp);

      try{
        // >>>>>>>>>>>> CLÉ : toujours passer {params: …} à render/solution <<<<<<<<<<<<
        const stForRender = (st && st.params) ? st : { params: st || {} };

        // 1) Rendu de l’énoncé
        def.render(tmp, stForRender);

        // Mémoriser le tirage pour que la solution retombe sur le même état
        try{
          const just = JSON.parse(tmp.dataset.state || '{}');
          if (def.id && just && just.params) window.__EXO_PARAMS_CACHE[def.id] = just;
        }catch(e){/* no-op */ }

        // Pas d’artefacts interactifs/clics sur le PDF
        const userLayer = tmp.querySelector('g[data-layer="user"]');
        if (userLayer) userLayer.innerHTML = '';

        if(!withSolutions){
          const equ = tmp.querySelector('.equ');
          const right = equ ? equ.cloneNode(true) : tmp.cloneNode(true);
          stripInteractive(right);
          try{ if (window.canonMathHTML) right.innerHTML = canonMathHTML(right.innerHTML); }catch(e){}
          const left = TWO_COL.has(def.id) ? svgInline(tmp, {widthPx:360, heightPx:360}) : '';
          // On renvoie UNIQUEMENT l’énoncé ; le kit s’occupe du cartouche
          return FRAC_FIX + (TWO_COL.has(def.id) ? twoCol(left, right.innerHTML)
                                                 : `<div>${right.innerHTML}</div>`);
        }

        // 2) Rendu du corrigé (sur le même état)
        const saved = (window.__EXO_PARAMS_CACHE && window.__EXO_PARAMS_CACHE[def.id]) || stForRender;
        try { def.solution(tmp, saved); } catch(e){}
        try { if (window.canonizeAllSteps) canonizeAllSteps(tmp); } catch(e){}
        stripInteractive(tmp);

        const steps = tmp.querySelector('.steps') || tmp.querySelector('.solution');
        const right = steps ? (steps.outerHTML || steps.innerHTML) : '';
        const left  = TWO_COL.has(def.id) ? svgInline(tmp, {widthPx:360, heightPx:360}) : '';
        // On renvoie le contenu du corrigé SANS l’en-tête (le kit l’ajoute)
        return FRAC_FIX + (TWO_COL.has(def.id) ? twoCol(left, right) : right);

      }catch(e){
        // Laisse le kit faire son fallback (évite "indisponible" en double)
        return '';
      }finally{
        tmp.remove();
      }
    }
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d’actions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on déclenche .click() sur eux)
[['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l’original est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si présent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s’ouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>