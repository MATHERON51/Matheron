<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1STI2D ‚Äî Nombres d√©riv√©s & tangentes</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.code{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
/* Ticks de validation */
.tick{margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}
/* Ticks de validation */
.tick{
  display:none;           /* ‚Üê cach√© au d√©part */
  margin-left:.35rem;
  font-weight:700;
}
.tick.ok{ color:#11823b }
.tick.ko{ color:#b00020 }
/* Cache les ticks tant qu'ils ne sont ni ok ni ko */
.tick:not(.ok):not(.ko){ display:none !important; }

.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.frac{display:inline-flex;flex-direction:column;vertical-align:middle;line-height:1}
.frac>.num{border-bottom:1px solid #000;padding:0 .15em;text-align:center}
.frac>.den{padding:0 .15em;text-align:center}
/* PDF/print : √©viter la disparition des barres de fraction */
@media print {
  .frac>.num{ border-bottom-width: 2px !important; }
}

/* Bonus : un peu plus visible aussi √† l'√©cran sans √™tre agressif */
.frac>.num{ border-bottom-width: 1.5px; }
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
/* Fraction plus robuste (ligne sous le num√©rateur) */
.frac{ display:inline-flex; flex-direction:column; align-items:stretch; line-height:1; }
.frac>.num,
.frac>.den{ display:block; text-align:center; padding:0 .2em; position:relative; }
.frac>.num{ border-bottom:1.5px solid currentColor; } /* √©cran : plus lisible */

/* Impression/PDF : certaines pipelines "mangent" les hairlines -> pseudo-ligne solide */
@media print{
  .frac>.num{ border-bottom:0 !important; }
  .frac>.num::after{
    content:"";
    position:absolute;
    left:0; right:0; bottom:-1px;
    height:2px;                    /* trait √©pais et visible */
    background:currentColor;
  }
}
@media print{
  /* transforme les champs en grands traits (si jamais ExoPDF n'est pas utilis√©) */
  input, textarea, select{
    background: transparent !important;
    border: none !important;
    border-bottom: 2px solid #000 !important;  /* ‚Üê grand trait */
    color: transparent !important;             /* cache le texte/placeholder */
    caret-color: transparent !important;
    outline: none !important;
    height: 1.4em !important;
  }
  input::placeholder, textarea::placeholder{ color: transparent !important; }

  /* nettoie l'UI */
  .tick, .optionline, button, select, .kbd-host, .header, .controls{ 
    display: none !important; 
  }
}
/* Fallback universel : si l'input existe encore au moment du rendu PDF,
   on le masque et on montre un "grand trait" de m√™me largeur. */
.blank-wrap{ display:inline-block; vertical-align:baseline }
.blank-wrap .blank{
  display:none; height:1.4em; border-bottom:2px solid #000; vertical-align:baseline;
}

/* Impression / PDF (html2canvas, etc.) */
@media print{
  .blank-wrap input{ display:none !important; }
  .blank-wrap .blank{ display:inline-block !important; }
}
@media print{ .controls{display:none !important;} }

.svgbox{
  touch-action: manipulation;
  user-select: none;
}

</style>

<!-- Librairies communes MatHeron -->
<script src='../../../../js/math-kbd.js' defer></script>
<script>
/* ====== HERMITE5 ‚Äì G√©n√©rateur quintique Hermite sur rep√®re interne [-6,6] ====== */
(function(global){
  "use strict";
  const UMINUS = '‚àí';
  const RDEF = {xmin:-6,xmax:6,ymin:-6,ymax:6};
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rchoice(a){ return a[Math.floor(Math.random()*a.length)] }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
  function pickDistinctInt(a,b, forbid=new Set()){
    const pool=[]; for(let x=a;x<=b;x++) if(!forbid.has(x)) pool.push(x);
    return pool.length? rchoice(pool) : a;
  }
  const ZERO = {n:0n, d:1n}; const ONE  = {n:1n, d:1n};
  function rat(n, d=1n){ n=BigInt(n); d=BigInt(d); if(d===0n) throw Error('den=0'); if(d<0n){n=-n; d=-d;}
    const g=(a,b)=>{ a=a<0n?-a:a; b=b<0n?-b:b; while(b){ const t=a%b; a=b; b=t; } return a; };
    const gg=g(n<0n?-n:n, d); return {n:n/gg, d:d/gg};
  }
  function add(a,b){ return rat(a.n*b.d + b.n*a.d, a.d*b.d); }
  function mul(a,b){ return rat(a.n*b.n, a.d*b.d); }
  function div(a,b){ return rat(a.n*b.d, a.d*b.n); }
  function pConst(c){ return [c]; }
  function pAdd(a,b){ const n=Math.max(a.length,b.length); const out=Array.from({length:n},(_,i)=> add(a[i]||ZERO,b[i]||ZERO)); return out; }
  function pScale(a, s){ return a.map(c => mul(c,s)); }
  function pMul(a,b){ const out=Array.from({length:a.length+b.length-1},()=>ZERO);
    for(let i=0;i<a.length;i++) for(let j=0;j<b.length;j++) out[i+j]=add(out[i+j], mul(a[i],b[j]));
    return out;
  }
  function pEval(a, x){ let acc=rat(0n), X=rat(1n); for(let i=0;i<a.length;i++){ acc=add(acc, mul(a[i],X)); X=mul(X,x);} return acc; }
  function pDer(a){ if(a.length<=1) return [rat(0n)]; const out=[]; for(let i=1;i<a.length;i++) out.push( mul(a[i], rat(i,1n)) ); return out; }
  function xMinus(t){ return [rat(-BigInt(t),1n), rat(1n,1n)]; }
  function lagrangeBasis(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    let num = pMul( xMinus(others[0]), xMinus(others[1]) );
    const den = rat( (BigInt(xi)-BigInt(others[0])) * (BigInt(xi)-BigInt(others[1])) , 1n);
    return pScale(num, div(ONE, den));
  }
  function sumInv(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    const t1 = div(ONE, rat(BigInt(xi)-BigInt(others[0]),1n));
    const t2 = div(ONE, rat(BigInt(xi)-BigInt(others[1]),1n));
    return add(t1,t2);
  }
  function hermiteCardinals(xi, nodes){
    const L = lagrangeBasis(xi, nodes);
    const L2 = pMul(L,L);
    const Si = sumInv(xi, nodes);
    const P = pAdd( pConst(ONE), pScale( xMinus(xi), mul(rat(-2n), Si)) );
    const Hi0 = pMul(P, L2);
    const Hi1 = pMul( xMinus(xi), L2 );
    return {Hi0, Hi1};
  }
  function toVH(m){
    if(Number.isInteger(m)) return [m,1];
    const maxH = 7;
    for(let H=1; H<=maxH; H++){
      const V = Math.round(m*H);
      if(Math.abs(m - V/H) < 1e-6) return [V,H];
    }
    return null;
  }
  function buildPoly(a,b,c, m,k,l, n, q_num, q_den){
    const nodes=[a,b,c];
    const H0 = hermiteCardinals(a, nodes);
    const H1 = hermiteCardinals(b, nodes);
    const H2 = hermiteCardinals(c, nodes);
    const term0 = pScale(H0.Hi0, rat(BigInt(m),1n));
    const term1 = pScale(H0.Hi1, rat(0n,1n)); // f'(a)=0
    const term2 = pScale(H1.Hi0, rat(BigInt(k),1n));
    const term3 = pScale(H1.Hi1, rat(BigInt(n),1n));
    const term4 = pScale(H2.Hi0, rat(BigInt(l),1n));
    const term5 = pScale(H2.Hi1, rat(BigInt(q_num), BigInt(q_den)));
    let P = pConst(rat(0n)); [term0,term1,term2,term3,term4,term5].forEach(t => P=pAdd(P,t));
    return P;
  }
  function evalPolyNum(P, x){ let y=0; for(let i=P.length-1;i>=0;i--) y = y*x + (Number(P[i].n)/Number(P[i].d)); return y; }
  function okInView(P, R){
    const steps = Math.round((R.xmax-R.xmin)*50);
    for(let i=0;i<=steps;i++){
      const x = R.xmin + i*(R.xmax-R.xmin)/steps;
      let y=0; for(let j=P.length-1;j>=0;j--) y = y*x + (Number(P[j].n)/Number(P[j].d));
      if(!Number.isFinite(y)) return false;
      if(y<R.ymin-1e-9 || y>R.ymax+1e-9) return false;
    }
    return true;
  }
  function generate(opts={}){
    const R = opts.R || RDEF;             // g√©n√©ration sur [-6,6]
    const MAG  = opts.mag ?? 5;
    const DENM = Math.max(2, opts.denMax ?? 4);
    let tries=0;
    while(tries++<1200){
      let a = pickDistinctInt(R.xmin+1, R.xmax-1);
      let b = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a]));
      let c = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a,b]));
      [a,b,c] = [a,b,c].sort((u,v)=>u-v);
      let m = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1);
      let k = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1);
      let l = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1);
      if(m===k && k===l) continue;
      const spread = Math.max(Math.abs(m-k), Math.abs(k-l), Math.abs(l-m));
      if(spread < 2) continue;
      let n = rchoice([-3,-2,-1,1,2,3]);
      let H = rchoice([2,3,4,5].filter(h=>h<=DENM));
      let Vcands = [-5,-4,-3,-2,-1,1,2,3,4,5].filter(v=> (v%H)!==0 );
      let V = rchoice(Vcands);
      if(!(c+H<=R.xmax && l+V>=R.ymin && l+V<=R.ymax)) continue;
      const P = buildPoly(a,b,c, m,k,l, n, V, H);
      if(!okInView(P,R)) continue;
      const dP = pDer(P);
      const f  = x => evalPolyNum(P,x);
      const df = x => evalPolyNum(dP,x);
      const A = {x:a, y:m, m:0};
      const B = {x:b, y:k, m:n};
      const C = {x:c, y:l, m:V/H};
      const xs=[];
      const grid=[5,4,4,5];
      const segments=[ [R.xmin, A.x], [A.x, B.x], [B.x, C.x], [C.x, R.xmax] ];
      for(let s=0;s<4;s++){
        const [x0,x1]=segments[s];
        const npts=grid[s];
        for(let i=0;i<npts;i++){
          const t=(i+1)/(npts+1); const x = x0 + t*(x1-x0); const y=f(x);
          xs.push([Math.round(x*1000)/1000, Math.round(y*1000)/1000]);
        }
      }
      return {R, f, df, A, B, C, VH:[V,H], pts20: xs};
    }
    const f=x=>0, df=x=>0;
    return {R:RDEF, f, df, A:{x:-2,y:1,m:0}, B:{x:0,y:0,m:1}, C:{x:3,y:1,m:0.5}, VH:[1,2], pts20:[]};
  }
  global.HERMITE5 = { generate, toVH, RDEF };
})(window);
</script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D ‚Äî <strong>Nombres d√©riv√©s & tangentes</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <div id="host" class="card" data-active="" data-state=""></div>

<div class="card small" id="info-saisie">
  <strong>Saisie & r√©ponses accept√©es :</strong>

	    <li>Attention : Si vous voyez une ligne horizontale rouge : Cliquez sur nouvel √©nonc√©</li>
        <li>Division : saisir en <span class="code">a/b</span> ; puissances : <span class="code">x^2</span> (affichage en <span class="code">x¬≤</span>).</li>
        <li>√âquations de droites : vous pouvez √©crire <span class="code">y = mx + p</span> ou <span class="code">y - y_A = m(x - x_A)</span>. Les formes alg√©briquement √©quivalentes sont accept√©es.</li>
        <li>Le signe <b>‚àí</b> affich√© est le ¬´ grand moins ¬ª (Unicode). La saisie accepte <span class="code">-</span> classique.</li>
        </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>


   
  </div>

<script>
/* =========== Outils g√©n√©riques =========== */

/* ==== Canonisation d'affichage (signes, √ó, doublons) ==== */
const UMINUS = '‚àí'; // (d√©j√† d√©fini chez toi, laiss√© ici pour clart√©)

/* 1) Normalise les suites de signes */
/* 1) Normalise les suites de signes (sans --, -+, +- etc.) */
function normalizeSignsStr(s){
  const U = UMINUS; // '‚àí'
  s = String(s)
    // 0) Unifie tous les tirets en ¬´ grand moins ¬ª
    .replace(/[‚Äì‚Äî\-]/g, U)

    // 1) R√©duit les doubles signes (ind√©pendant des espaces)
    .replace(/\+\s*\+/g, ' + ')
    .replace(/‚àí\s*‚àí/g, ' + ')
    .replace(/\+\s*‚àí/g, ` ${U} `)
    .replace(/‚àí\s*\+/g, ` ${U} `)

    // 2) Nettoyage autour de "=" et parenth√®ses (√©vite "= +", "( +", etc.)
    .replace(/=\s*\+/g, '= ')
    .replace(/\(\s*\+/g, '(')

    // 3) Espaces propres
    .replace(/\s+/g, ' ')
    .replace(/\s+([\)\],;:])/g,'$1')
    .replace(/([\(\[])\s+/g,'$1');

  return s;
}

/* 2) For√ßage des multiplications explicites "√ó" l√† o√π n√©cessaire */

// Remplace TOUTE ancienne version de forceTimesStr par ceci :
function timesNumbersOnly(s){
  s = String(s);

  // 0) Nettoyage : on enl√®ve toute * ou √ó ind√©sirable devant x, ( ... ) non num√©rique, ou ‚àö
  s = s.replace(/(\d)\s*[\*√ó]\s*x\b/g, '$1x');  // 3*x ‚Üí 3x ; 3√óx ‚Üí 3x
  s = s.replace(/(\d)\s*[\*√ó]\s*‚àö/g, '$1‚àö');    // 3*‚àöx ‚Üí 3‚àöx ; 3√ó‚àöx ‚Üí 3‚àöx
  s = s.replace(/(\d)\s*[\*√ó]\s*\(/g, '$1(');   // 3*( ‚Ä¶ ) ‚Üí 3( ‚Ä¶ ) (on r√©-ins√®rera √ó si ( ‚Ä¶ ) est num√©rique)

  // 1) √ó entre nombres s√©par√©s par un espace : "3 4" ‚Üí "3 √ó 4"
  s = s.replace(/(\d)\s+(?=\d)/g, '$1 √ó ');

  // 2) √ó entre nombre et ( ‚Ä¶ ) si le contenu est PUREMENT NUM√âRIQUE
  //    (signes + d√©cimales autoris√©s) : "5(2)" ‚Üí "5 √ó (2)", "3(‚àí3)" ‚Üí "3 √ó (‚àí3)"
  s = s.replace(/(\d)\s*(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))/g, '$1 √ó $2');

  // 3) √ó entre ( ‚Ä¶ ) num√©rique et nombre : "(2)3" ‚Üí "(2) √ó 3"
  s = s.replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*(\d)/g, '$1 √ó $2');

  return s;
}



/* 3) Supprime les r√©p√©titions du type "= 3 = 3" ou "= ‚àí5 = ‚àí5" (anti-doublon inline) */
function dedupInlineEquals(s){
  // nombres entiers/d√©cimaux
  s = s.replace(/=\s*([‚àí\-]?\d+(?:[.,]\d+)?)\s*=\s*\1\b/g, '= $1');
  // cas tr√®s courant : fraction "a/b = a/b" (quand elle n'est pas encore mise en pile)
  s = s.replace(/=\s*([‚àí\-]?\d+\/\d+)\s*=\s*\1\b/g, '= $1');
  return s;
}

/* 4) Post-traitement HTML des blocs d'√©tapes .steps */
function canonMathHTML(html){
  let s = String(html);
  s = timesNumbersOnly(s); // ‚Üê important : ne pas utiliser d'autres "forceTimes"
  s = normalizeSignsStr(s);
  s = dedupInlineEquals(s);
  s = s.replace(/(\d)\s*\*\s*(\d)/g, '$1 √ó $2') // * entre nombres -> √ó
     .replace(/(\d)\s*\*\s*x\b/g, '$1x')
     .replace(/(\d)\s*\*\s*‚àö/g, '$1‚àö')
     .replace(/(\d)\s*\*\s*\(/g, '$1(');

  return s;
}

/* 5) Passe le peigne sur tous les blocs .steps d'un host */
function canonizeAllSteps(host){
  $$('.steps', host).forEach(el => {
    el.innerHTML = canonMathHTML(el.innerHTML);
  });
}


const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const rnd   = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const rchoice = L => L[rnd(0,L.length-1)];
const fmtNum = v => (Math.abs(v)===Infinity? '‚àû' : (Number.isInteger(v)? String(v) : String(Math.round(v*1000)/1000).replace('.',',')));
const normMinus = s => String(s||'').replace(/‚àí/g,'-').trim();

function parseNum(s){
  s = normMinus(String(s).replace(',','.'));
  if(!s) return NaN;
  if(/^\s*ND\s*$/i.test(s)) return NaN;
  if(s.includes('/')){
    const [a,b] = s.split('/').map(x=>parseFloat(x));
    if(!isFinite(a) || !isFinite(b) || b===0) return NaN;
    return a/b;
  }
  return parseFloat(s);
}

function eqNum(a,b,tol=1e-6){
  if(!Number.isFinite(a) || !Number.isFinite(b)) return null; // neutre
  return Math.abs(a-b)<=tol;
}

/* ===== Ticks (neutre cach√©) ===== */
function setTick(el,val){
  if(!el) return;
  if(val===true){  el.textContent='‚úì'; el.classList.add('ok'); el.classList.remove('ko'); el.style.display='inline'; }
  else if(val===false){ el.textContent='‚úï'; el.classList.add('ko'); el.classList.remove('ok'); el.style.display='inline'; }
  else { el.textContent=''; el.classList.remove('ok','ko'); el.style.display='none'; } // neutre cach√©
}

/* =========== Fractions & formats (pile partout) =========== */
function fracHTML(V,H){
  return `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`;
}

// -> [V,H] r√©duit si possible via HERMITE5.toVH ; sinon entier
// -> [V,H] r√©duit si possible via HERMITE5.toVH ; sinon approx rationnelle (den ‚â§ 24)
function slopeVH(m){
  const vh = (window.HERMITE5 && HERMITE5.toVH) ? HERMITE5.toVH(m) : null;
  if (vh) return vh;                       // cas "classique"
  for (let H = 1; H <= 24; H++){           // fallback : fraction simple
    const V = Math.round(m * H);
    if (Math.abs(m - V/H) < 1e-12) return reduce(V, H);
  }
  return [Math.round(m), 1];               // dernier recours (entier)
}


// V/H en pile (m√™me si 2/1)
function vhHTML(m){ const [V,H]=slopeVH(m); return fracHTML(V,H); }

// f'(a) : entier si H=1, sinon fraction en pile (jamais ‚Äú/1‚Äù)
function fprimeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }
// R√©tro-compat : certains blocs appellent encore fprimeHTML_strict
const fprimeHTML_strict = fprimeHTML;

// Phrase ‚Äúpentes‚Äù : 0 ‚Üí ‚Äú0 (tangente horizontale)‚Äù, entier ‚â†0 ‚Üí ‚Äú(‚àí1/1) = ‚àí1‚Äù, sinon fraction pile
// --- PATCH fprimeForSentence (z√©ro doublon ; entier si /1) ---
function fprimeForSentence(m){
  const [V,H]=slopeVH(m);
  if(V===0) return '0 (tangente horizontale)';
  return (H===1) ? String(V) : fracHTML(V,H);
}


// Affichage g√©n√©rique d‚Äôune pente (pile ou entier)
function fmtSlopeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }

/* =========== Parsers stricts (pas de d√©cimales) =========== */
// ‚Äúa/b‚Äù uniquement (existante, conserv√©e)
function parseFracStrict(s){
  s = normMinus(String(s).replace(',','.')).trim();
  if(!/^[+-]?\d+\s*\/\s*[1-9]\d*$/.test(s)) return null;
  const [A,B] = s.split('/').map(t=>parseInt(t.replace(/\s+/g,''),10));
  if(!Number.isFinite(A) || !Number.isFinite(B) || B===0) return null;
  return {a:A, b:B, val:A/B};
}

// entier strict (pas de fraction, pas de d√©cimal)
function parseIntStrict(s){
  s = normMinus(String(s||'').trim());
  if(!/^[+-]?\d+$/.test(s)) return null;
  return parseInt(s,10);
}

// PGCD + r√©duction
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function reduce(n,d){ if(d<0){ n=-n; d=-d; } const g=gcd(n,d); return [n/g,d/g]; }

// entier OU fraction ‚Äúa/b‚Äù ‚Üí [N,D] r√©duit (null sinon)
function parseRatStrict(s){
  s = normMinus(String(s||'').trim());
  if(/^[+-]?\d+$/.test(s)) return [parseInt(s,10),1];
  const fr=parseFracStrict(s);
  return fr ? reduce(fr.a, fr.b) : null;
}
// d√©cimal exact / entier / fraction -> [N,D] r√©duit, sinon null
function parseRatOrDecStrict(s){
  s = normMinus(String(s||'').trim());
  if(!s) return null;

  // entier
  if(/^[+\-]?\d+$/.test(s)) return [parseInt(s,10), 1];

  // fraction a/b
  const fr = parseFracStrict(s);
  if(fr) return reduce(fr.a, fr.b);

  // d√©cimal fini (.,)
  if(/^[+\-]?\d+[.,]\d+$/.test(s)){
    const neg = s.startsWith('-');
    const t = s.replace('+','').replace('-','').replace(',','.');
    const [A,B] = t.split('.');
    const num = parseInt(A + B, 10);
    const den = 10 ** B.length;
    return reduce(neg ? -num : num, den);
  }
  return null;
}

// pour les coefficients devant x : '', '+', '-', '(‚Ä¶)','-(‚Ä¶)', nombres‚Ä¶
function parseCoeff(tok){
  tok = String(tok||'');
  if(tok==='' || tok==='+') return [ 1,1 ];
  if(tok==='-')             return [-1,1 ];

  // signe ext√©rieur possible : '-(1/2)'
  let sign = 1;
  if(tok.startsWith('+(') && tok.endsWith(')')) tok = tok.slice(2,-1);
  else if(tok.startsWith('-(') && tok.endsWith(')')){ sign=-1; tok = tok.slice(2,-1); }

  // enl√®ve des paires de parenth√®ses externes : '(1/2)' -> '1/2'
  while(tok.startsWith('(') && tok.endsWith(')')) tok = tok.slice(1,-1);

  const r = parseRatOrDecStrict(tok);
  return r ? reduce(sign*r[0], r[1]) : null;
}

// remplace l‚Äôancienne slopeOKStrict
function slopeOKStrict(input, expected){
  input = String(input||'').trim();
  if(input==='') return null;                  // champ vide ‚Üí tick neutre

  const rat = parseRatOrDecStrict(input);      // entier, fraction ou d√©cimal exact
  if(!rat) return false;

  const [V,H] = slopeVH(expected);             // valeur attendue (r√©duite)
  const R = reduce(rat[0], rat[1]);            // valeur saisie (r√©duite)
  return (R[0] === V && R[1] === H);
}


/* ====== √âquations de droites ====== */
// parties d‚Äôaffichage : m¬∑x et +p en pile
function mxHTML([V,H]){
  const sgn = V<0 ? '‚àí' : '';
  const A = Math.abs(V);
  if(H===1 && A===1) return `${sgn}x`;
  return `${(H===1)? String(V) : fracHTML(V,H)}x`;
}
function signedRatHTML([N,D]){
  if(N===0) return ' + 0';
  const s = (N<0) ? ' ‚àí ' : ' + ';
  const A = Math.abs(N);
  return s + ((D===1)? String(A) : fracHTML(A,D));
}
// Affiche une rationnelle [N,D] en entier ou fraction pile
function ratHTML([N,D]){
  const R = reduce(N,D);
  return (R[1] === 1) ? String(R[0]) : fracHTML(R[0], R[1]);
}

// √âquation joliment format√©e : pas de ‚Äú+ 0‚Äù / ‚Äú‚àí 0‚Äù, g√®re m = 0 et ¬±x
function eqHTML(mVH, pVH){
  const M = reduce(mVH[0], mVH[1]);
  const P = reduce(pVH[0], pVH[1]);

  // y = p si m = 0
  if (M[0] === 0) return `y = ${ratHTML(P)}`;

  // y = mx (+ p) sinon (sans afficher +0)
  const mx = mxHTML(M);                  // d√©j√† ‚Äú‚àíx‚Äù quand ¬±1
  if (P[0] === 0) return `y = ${mx}`;    // pas de +0

  const sign = (P[0] < 0) ? ' ‚àí ' : ' + ';
  const pAbs = [Math.abs(P[0]), P[1]];
  return `y = ${mx}${sign}${ratHTML(pAbs)}`;
}

// p = y - (V/H) x  en fraction r√©duite
function pFromPoint(V,H,x,y){ return reduce(y*H - V*x, H); }

// outils d‚Äôaffichage/ratios d√©j√† pr√©sents :
/* gcd, reduce, slopeVH, parseRatOrDecStrict, mxHTML, signedRatHTML, pFromPoint */

// remplace l‚Äôancienne lineOKStrict
function lineOKStrict(expr, mVH, pVH){
  expr = normMinus(String(expr||'')).replace(/\s+/g,'');
  if(!expr || !expr.startsWith('y=')) return false;
  const rhs = expr.slice(2);

  // motif commun pour un coefficient devant x : vide / signe / nombre (avec () possibles)
  const COEF_RE = '([+\\-]?(?:\\(?\\d+(?:\\/[1-9]\\d*)?\\)?|\\(?\\d+(?:[.,]\\d+)?\\)?)*?)';
  const RAT_RE  = '([+\\-]?(?:\\d+(?:\\/[1-9]\\d*)?|\\d+(?:[.,]\\d+)?))';

  let m=null, p=null;

  // 0) y = p (constante)
  let m0 = rhs.match(new RegExp('^'+RAT_RE+'$'));
  if(m0){ m=[0,1]; p=parseRatOrDecStrict(m0[1]); }

  // 1) y = m x + p    (m peut √™tre '', '+', '-', '1/2', '(1/2)', '-(1/2)', etc.)
  if(!m || !p){
    let m1 = rhs.match(new RegExp('^'+COEF_RE+'x([+\\-])'+RAT_RE+'$'));
    if(m1){
      const mTok=m1[1], sign=m1[2], pTok=m1[3];
      m = parseCoeff(mTok);
      p = parseRatOrDecStrict((sign==='-'?'-':'')+pTok);
    }
  }

  // 2) y = p + m x
  if(!m || !p){
    let m2 = rhs.match(new RegExp('^'+RAT_RE+'([+\\-])'+COEF_RE+'x$'));
    if(m2){
      const pTok=m2[1], sign=m2[2], mTok=m2[3];
      p = parseRatOrDecStrict(pTok);
      m = parseCoeff((sign==='-'?'-':'')+mTok);
    }
  }

  // 3) y = m(x ¬± a) ¬± yA  (a,yA entiers ; m rationnel/entier/d√©cimal exact)
  if(!m || !p){
    let m3 = rhs.match(new RegExp('^'+COEF_RE+'\\((?:x)([+\\-])(\\d+)\\)([+\\-])(\\d+)$'));
    if(m3){
      const mTok=m3[1], s1=m3[2], aTok=m3[3], s2=m3[4], yATok=m3[5];
      const mRat = parseCoeff(mTok); if(!mRat) return false;
      const a = parseInt(aTok,10), yA = parseInt(yATok,10);
      if(!Number.isInteger(a) || !Number.isInteger(yA)) return false;
      const aEff  = (s1==='-') ? a : -a;           // x - a  / x + a
      const yEff  = (s2==='-') ? -yA :  yA;        // + yA / - yA
      // y = m x + (yEff - m*aEff)
      const pRat = reduce(yEff*mRat[1] - mRat[0]*aEff, mRat[1]);
      m = mRat; p = pRat;
    }
  }

  if(!m || !p) return false;

  // comparaison rationnelle exacte
  const M   = reduce(m[0], m[1]);
  const P   = reduce(p[0], p[1]);
  const Mxp = reduce(mVH[0], mVH[1]);
  const Pxp = reduce(pVH[0], pVH[1]);
  return (M[0]===Mxp[0] && M[1]===Mxp[1] && P[0]===Pxp[0] && P[1]===Pxp[1]);
}



/* ====== V√©rif ‚Äúsouple‚Äù (utile pour d‚Äôautres exos si tu veux la garder) ====== */
function parseUserLine(expr){
  expr = normMinus(expr).replace(/\s+/g,'');
  if(!expr) return null;
  let rhs = expr.startsWith('y=') ? expr.slice(2) : expr;
  rhs = rhs.replace(/\^/g,'**');
  try{
    const f = new Function('x','return ('+rhs+');');
    return (x)=> f(x);
  }catch(e){ return null; }
}
function isSameLine(userExpr, m, p){
  const f=parseUserLine(userExpr); if(!f) return false;
  const xs=[-5,-3,-1,0,2,4];
  try{
    return xs.every(x=>{
      const yu=f(x);
      const y=m*x+p;
      return isFinite(yu) && Math.abs(yu - y) <= 1e-3;
    });
  }catch(e){ return false; }
}

/* =========== Rep√®re (SVG) =========== */
/* =========== Rep√®re (SVG) =========== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.el=this._makeSVG();
    this.gGrid=this.el.querySelector('g[data-layer="grid"]');
    this.gAxes=this.el.querySelector('g[data-layer="axes"]');
    this.gGeom=this.el.querySelector('g[data-layer="geom"]');
    this.gUser=this.el.querySelector('g[data-layer="user"]');
    this._labelRects = [];               // m√©moires des bbox des labels pos√©s
    this.redraw();
  }
  _makeSVG(){
    const s=document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
	s.setAttribute('preserveAspectRatio','xMidYMid meet');
    const layers=['grid','axes','geom','user'];
    layers.forEach(L=>{
      const g=document.createElementNS(s.namespaceURI,'g'); g.dataset.layer=L; s.appendChild(g);
    });
    return s;
  }
  coordToScreen(x,y){
    const R=this.R, w=420, h=420;
    const X=(x-R.xmin)/(R.xmax-R.xmin)*w;
    const Y=h-(y-R.ymin)/(R.ymax-R.ymin)*h;
    return {x:X,y:Y};
  }
  screenToCoord(X,Y){
    const R=this.R, w=420, h=420;
    const x=R.xmin + X/w*(R.xmax-R.xmin);
    const y=R.ymin + (h-Y)/h*(R.ymax-R.ymin);
    return {x,y};
  }
  redraw(){
    const R=this.R;
    const w=420,h=420;
    this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gGeom.innerHTML=''; this.gUser.innerHTML='';
    this._labelRects = []; // reset anti-collisions

    // grille
    const mkLine=(x1,y1,x2,y2,thick=false)=>{
      const L=document.createElementNS(this.el.namespaceURI,'line');
      L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2);
      L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); L.setAttribute('opacity',thick?1:.35);
      return L;
    };
    for(let t=R.xmin;t<=R.xmax;t++){
      const P1=this.coordToScreen(t,R.ymin), P2=this.coordToScreen(t,R.ymax);
      this.gGrid.appendChild(mkLine(P1.x,P1.y,P2.x,P2.y));
    }
    for(let t=R.ymin;t<=R.ymax;t++){
      const P1=this.coordToScreen(R.xmin,t), P2=this.coordToScreen(R.xmax,t);
      this.gGrid.appendChild(mkLine(P1.x,P1.y,P2.x,P2.y));
    }
    // axes
    const A1=this.coordToScreen(R.xmin,0), A2=this.coordToScreen(R.xmax,0);
    const B1=this.coordToScreen(0,R.ymin), B2=this.coordToScreen(0,R.ymax);
    this.gAxes.appendChild(mkLine(A1.x,A1.y,A2.x,A2.y,true));
    this.gAxes.appendChild(mkLine(B1.x,B1.y,B2.x,B2.y,true));

    // O, I, J
    const mkPt=(x,y)=>{
      const g=document.createElementNS(this.el.namespaceURI,'g');
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','4'); c.setAttribute('fill','#000');
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','12'); t.setAttribute('fill','#000'); t.setAttribute('dominant-baseline','central');
      const P=this.coordToScreen(x,y); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
      g.appendChild(c); g.appendChild(t);
      return {g,c,t,P};
    };
    const O=mkPt(0,0);  O.t.textContent='O'; this.gAxes.appendChild(O.g);
    const I=mkPt(1,0);  I.t.textContent='I'; this.gAxes.appendChild(I.g);
    const J=mkPt(0,1);  J.t.textContent='J'; this.gAxes.appendChild(J.g);

    // placement O/I/J avec anti-collision
    this._placeLabel(O.t, O.P.x, O.P.y);
    this._placeLabel(I.t, I.P.x, I.P.y);
    this._placeLabel(J.t, J.P.x, J.P.y);

    /* === Graduations === */
    const TICK=6, u = s=>String(s).replace(/-/g,UMINUS);
    const P0=this.coordToScreen(0,0);

    // graduations axe X
    if (R.ymin <= 0 && 0 <= R.ymax){
      const Y0 = P0.y;
      for (let t=Math.ceil(R.xmin); t<=Math.floor(R.xmax); t++){
        const Px = this.coordToScreen(t,0).x;
        const tick=document.createElementNS(this.el.namespaceURI,'line');
        tick.setAttribute('x1',Px); tick.setAttribute('x2',Px);
        tick.setAttribute('y1',Y0-TICK); tick.setAttribute('y2',Y0+TICK);
        tick.setAttribute('stroke','#000'); tick.setAttribute('stroke-width','1.2');
        this.gAxes.appendChild(tick);
        if(t!==0){
          const lab=document.createElementNS(this.el.namespaceURI,'text');
          lab.setAttribute('x',Px);
          const yOff = (Y0 > h - 18) ? -12 : 10;
          lab.setAttribute('y',Y0 + yOff);
          lab.setAttribute('font-size','12'); lab.setAttribute('fill','#333');
          lab.setAttribute('text-anchor','middle');
          if(yOff>0) lab.setAttribute('dominant-baseline','hanging');
          lab.textContent = u(t);
          this.gAxes.appendChild(lab);
          this._registerLabel(lab);
        }
      }
    }
    // graduations axe Y
    if (R.xmin <= 0 && 0 <= R.xmax){
      const X0 = P0.x;
      for (let t=Math.ceil(R.ymin); t<=Math.floor(R.ymax); t++){
        const Py = this.coordToScreen(0,t).y;
        const tick=document.createElementNS(this.el.namespaceURI,'line');
        tick.setAttribute('y1',Py); tick.setAttribute('y2',Py);
        tick.setAttribute('x1',X0-TICK); tick.setAttribute('x2',X0+TICK);
        tick.setAttribute('stroke','#000'); tick.setAttribute('stroke-width','1.2');
        this.gAxes.appendChild(tick);
        if(t!==0){
          const lab=document.createElementNS(this.el.namespaceURI,'text');
          const xOff = (X0 < 18) ? 10 : -8;
          lab.setAttribute('x',X0 + xOff);
          lab.setAttribute('y',Py);
          lab.setAttribute('font-size','12'); lab.setAttribute('fill','#333');
          lab.setAttribute('text-anchor', xOff < 0 ? 'end' : 'start');
          lab.setAttribute('dominant-baseline','central');
          lab.textContent = u(t);
          this.gAxes.appendChild(lab);
          this._registerLabel(lab);
        }
      }
    }
  }
  drawCurve(fn,color='#c62828',thick=2){
    const path=document.createElementNS(this.el.namespaceURI,'path');
    const N=300; const R=this.R; let d='M';
    for(let i=0;i<=N;i++){
      const x=R.xmin + i/N*(R.xmax-R.xmin);
      const y=fn(x);
      const P=this.coordToScreen(x,y);
      d += (i===0? '':' L') + P.x.toFixed(2)+','+P.y.toFixed(2);
    }
    path.setAttribute('d',d); path.setAttribute('fill','none'); path.setAttribute('stroke',color); path.setAttribute('stroke-width',thick);
    this.gGeom.appendChild(path);
  }
  drawPoint(label,x,y,color='#c62828'){
    const g=document.createElementNS(this.el.namespaceURI,'g');
    const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
    const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','12'); t.setAttribute('fill',color); t.setAttribute('font-weight','700');
    const P=this.coordToScreen(x,y); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
    t.textContent=label;
    g.appendChild(c); g.appendChild(t); this.gGeom.appendChild(g);
    this._placeLabel(t, P.x, P.y); // anti-collision pour le label
  }
  drawLineThroughPointSlope(x0,y0,m,color='#1565c0',dash=true){
    const x1=this.R.xmin, y1=m*(x1-x0)+y0;
    const x2=this.R.xmax, y2=m*(x2-x0)+y0;
    const a=this.coordToScreen(x1,y1), b=this.coordToScreen(x2,y2);
    const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','2');
    if(dash) L.setAttribute('stroke-dasharray','6 6');
    this.gGeom.appendChild(L);
  }

  // ----- anti-collision labels -----
  _registerLabel(textEl){
    try{
      const bb = textEl.getBBox();
      this._labelRects.push({x:bb.x, y:bb.y, w:bb.width, h:bb.height});
    }catch(e){}
  }
  _rectsIntersect(a,b){
    return !( b.x > a.x+a.w || b.x+b.w < a.x || b.y > a.y+a.h || b.y+b.h < a.y );
  }
  _placeLabel(textEl, px, py){
    const W=420, H=420;
    const cand = [
      {dx:  6, dy:-10, anchor:'start', baseline:'auto'},     // NE
      {dx: -6, dy:-10, anchor:'end',   baseline:'auto'},     // NO
      {dx: -8, dy: 12, anchor:'end',   baseline:'hanging'},  // SO
      {dx:  8, dy: 12, anchor:'start', baseline:'hanging'},  // SE
      {dx: 12, dy:  0, anchor:'start', baseline:'central'},  // Est
      {dx:-12, dy:  0, anchor:'end',   baseline:'central'}   // Ouest
    ];
    for(let s=1; s<=3; s++){
      for(const c of cand){
        textEl.setAttribute('text-anchor', c.anchor);
        textEl.setAttribute('dominant-baseline', c.baseline);
        textEl.setAttribute('x', px + c.dx*s);
        textEl.setAttribute('y', py + c.dy*s);
        let bb;
        try{ bb = textEl.getBBox(); }catch(e){ continue; }
        const rect = {x:bb.x, y:bb.y, w:bb.width, h:bb.height};
        if(rect.x<0 || rect.y<0 || rect.x+rect.w>W || rect.y+rect.h>H) continue;
        const collide = this._labelRects.some(r => this._rectsIntersect(r, rect));
        if(!collide){ this._labelRects.push(rect); return; }
      }
    }
    // fallback
    textEl.setAttribute('text-anchor','start');
    textEl.setAttribute('dominant-baseline','auto');
    textEl.setAttribute('x', px + 6);
    textEl.setAttribute('y', py - 10);
    this._registerLabel(textEl);
  }
}


/* ================== Courbe C¬π par Hermite + utilitaires ================== */
function hermiteSeg(x0,y0,m0,x1,y1,m1){
  const dx = x1 - x0;
  return {
    f(x){
      const t = (x - x0)/dx;
      const h00 =  2*t*t*t - 3*t*t + 1;
      const h10 =    t*t*t - 2*t*t + t;
      const h01 = -2*t*t*t + 3*t*t;
      const h11 =    t*t*t -   t*t;
      return h00*y0 + h10*dx*m0 + h01*y1 + h11*dx*m1;
    },
    df(x){
      const t = (x - x0)/dx;
      const dh00 =  6*t*t - 6*t;
      const dh10 =  3*t*t - 4*t + 1;
      const dh01 = -6*t*t + 6*t;
      const dh11 =  3*t*t - 2*t;
      return (dh00*y0 + dh10*dx*m0 + dh01*y1 + dh11*dx*m1)/dx;
    }
  };
}

/* Courbe C¬π par morceaux avec ‚Äúcaps‚Äù doux aux extr√©mit√©s */
function makePiecewiseHermite(P){
  P=[...P].sort((a,b)=>a.x-b.x);
  const segsCore=[];
  for(let i=0;i<P.length-1;i++){
    const s=hermiteSeg(P[i].x,P[i].y,P[i].m, P[i+1].x,P[i+1].y,P[i+1].m);
    segsCore.push({x0:P[i].x,x1:P[i+1].x, f:s.f, df:s.df});
  }
  function evalHerm(x){
    for(const s of segsCore) if(x>=s.x0 && x<=s.x1) return s.f(x);
    if(x<=P[0].x)    return P[0].y  + P[0].m  * (x-P[0].x);
    if(x>=P.at(-1).x) return P.at(-1).y + P.at(-1).m * (x-P.at(-1).x);
  }

  const left=P[0], next=P[1], right=P.at(-1), prev=P.at(-2);
  const wL = Math.min(1.4, Math.max(0.6, 0.45*Math.abs(next.x-left.x)));
  const wR = Math.min(1.4, Math.max(0.6, 0.45*Math.abs(right.x-prev.x)));
  const xL = left.x+wL, xR = right.x-wR;

  const bump    = t => { const t2=t*t, u=1-t2; return t2*u*u; };
  const dbumpdt = t => { const t2=t*t; return 2*t*(1-t2)*(1-3*t2); };

  const epsL = Math.min(0.2, 0.2*wL), epsR = Math.min(0.2, 0.2*wR);
  const yLineL = x => left.y  + left.m  * (x-left.x);
  const yLineR = x => right.y + right.m * (x-right.x);
  const signL = Math.sign( evalHerm(xL+epsL) - yLineL(xL+epsL) ) || (left.m>=0?1:-1);
  const signR = Math.sign( evalHerm(xR-epsR) - yLineR(xR-epsR) ) || (right.m>=0?1:-1);
  const AL = 3.4*wL*wL, AR = 3.4*wR*wR;

  function fCapLeft(x){  const t=(x-left.x)/wL;  return yLineL(x) + signL*AL*bump(t); }
  function dfCapLeft(x){ const t=(x-left.x)/wL;  return left.m + signL*AL*dbumpdt(t)*(1/wL); }
  function fCapRight(x){ const t=(right.x-x)/wR; return yLineR(x) + signR*AR*bump(t); }
  function dfCapRight(x){const t=(right.x-x)/wR; return right.m - signR*AR*dbumpdt(t)*(1/wR); }

  const guardL = {x:xL, y:yLineL(xL), m:left.m};
  const guardR = {x:xR, y:yLineR(xR), m:right.m};
  const Q=[guardL, ...P.slice(1,-1), guardR];
  const segs=[];
  for(let i=0;i<Q.length-1;i++){
    const s=hermiteSeg(Q[i].x,Q[i].y,Q[i].m, Q[i+1].x,Q[i+1].y,Q[i+1].m);
    segs.push({x0:Q[i].x,x1:Q[i+1].x, f:s.f, df:s.df});
  }

  const f=(x)=>{
    if(x<=left.x) return yLineL(x);
    if(x<xL) return fCapLeft(x);
    if(x>xR && x<right.x) return fCapRight(x);
    if(x>=right.x) return yLineR(x);
    for(const s of segs) if(x>=s.x0 && x<=s.x1) return s.f(x);
  };
  const df=(x)=>{
    if(x<=left.x) return left.m;
    if(x<xL) return dfCapLeft(x);
    if(x>xR && x<right.x) return dfCapRight(x);
    if(x>=right.x) return right.m;
    for(const s of segs) if(x>=s.x0 && x<=s.x1) return s.df(x);
  };
  return {f,df};
}
/* === UI helpers : conteneur avec/sans rep√®re √† droite pour l‚Äô√©nonc√© === */
function renderWithRepere(host, R){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row';
  const left  = document.createElement('div');
  const right = document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);

  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  left.appendChild(rep.el);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {rep,left,right,equ,actions,res};
}

function renderNoRepere(host){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row norepere';
  const right = document.createElement('div');
  row.appendChild(right); host.appendChild(row);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {left:null,right,equ,actions,res};
}



/* ======= BANQUE DE COURBES "PROPRES" =======
   - 3 points cl√©s P=[A,B,C] avec pentes impos√©es (B = extremum : m=0).
   - pentes: une enti√®re, une fraction simple (1/2, 2/3, ‚àí1/2, ...).
   - Abscisses et ordonn√©es enti√®res (lisibles), abscisse du point "fraction"
     multiple du d√©nominateur ‚Üí p entiers si besoin.
   - La forme finale est obtenue par makePiecewiseHermite (douce). */
const CURVE_BANK = [
  //        A(x,y,m)            B(x,y,0)             C(x,y,m)
  { id:'K1', P:[{x:-4,y: 0,m: 1   }, {x:-1,y: 2,m:0}, {x: 2,y:-1,m: 1/2 }]},
  { id:'K2', P:[{x:-3,y: 2,m:-1   }, {x: 0,y:-1,m:0}, {x: 3,y:  2,m: 2/3 }]},
  { id:'K3', P:[{x:-5,y: 2,m: 2   }, {x:-2,y: 4,m:0}, {x: 2,y:  1,m:-1/2 }]},
  { id:'K4', P:[{x:-4,y: 1,m: 1   }, {x: 0,y: 3,m:0}, {x: 3,y:  1,m:-2/3 }]},
  { id:'K5', P:[{x:-6,y: 0,m: 2/3 }, {x:-3,y: 2,m:0}, {x: 3,y:  1,m:-1   }]},
  { id:'K6', P:[{x:-4,y: 2,m:-2   }, {x:-1,y: 3,m:0}, {x: 2,y:  0,m: 1/2 }]},
];

/* sym√©tries / translations enti√®res (sx,sy ‚àà {+1,‚àí1}) */
function transformPoints(P, {tx=0, ty=0, sx=1, sy=1}={}){
  return P.map(p=>({x:sx*(p.x)+tx, y:sy*(p.y)+ty, m:sy/sx * p.m}));
}

/* points int√©rieurs d'un intervalle ouvert (sans extr√©mit√©s) */
function sampleOpen(a,b,n){
  const out=[]; if(n<=0) return out;
  for(let i=1;i<=n;i++){ const t=i/(n+1); out.push(a*(1-t)+b*t); }
  return out;
}

/* 5 points avant A, puis A, points, B, points, C, puis 5 points apr√®s C */
function samplePointsABC(f, A, B, C, R, cfg={left:5, mAB:4, mBC:4, right:5}){
  const L=[];
  // avant A (sans inclure A)
  for(const x of sampleOpen(R.xmin, A.x, cfg.left)) L.push({x, y:f(x)});
  // A
  L.push({x:A.x, y:f(A.x)});
  // entre A et B (ouvert)
  for(const x of sampleOpen(A.x, B.x, cfg.mAB)) L.push({x, y:f(x)});
  // B
  L.push({x:B.x, y:f(B.x)});
  // entre B et C (ouvert)
  for(const x of sampleOpen(B.x, C.x, cfg.mBC)) L.push({x, y:f(x)});
  // C
  L.push({x:C.x, y:f(C.x)});
  // apr√®s C (sans inclure C)
  for(const x of sampleOpen(C.x, R.xmax, cfg.right)) L.push({x, y:f(x)});
  return L;
}


function instantiateBankCurve(bankItem, R, opt={}){
  const P = transformPoints(bankItem.P, opt).sort((a,b)=>a.x-b.x);
  const {f,df} = makePiecewiseHermite(P);
  // 5 ‚Äì A ‚Äì (AB) ‚Äì B ‚Äì (BC) ‚Äì C ‚Äì 5
  const pts20 = samplePointsABC(f, P[0], P[1], P[2], R, {left:5, mAB:4, mBC:4, right:5});
  return {P,f,df,pts20};
}


/* contr√¥le "lecture depuis le point" + points dans le cadre */
function slopesReadableInFrame(P, R){
  const okInt=(x,y,k)=> (x+1<=R.xmax && y+k>=R.ymin && y+k<=R.ymax);
  const okFrac=(x,y,q)=>{ const vh=toVH(q); if(!vh) return false; const [V,H]=vh;
                          return (x+H<=R.xmax && y+V>=R.ymin && y+V<=R.ymax); };
  const inBox = P.every(p=>p.x>=R.xmin && p.x<=R.xmax && p.y>=R.ymin && p.y<=R.ymax);
  const A=P[0], B=P[1], C=P[2];
  const okA = toVH(A.m)? okFrac(A.x,A.y,A.m) : okInt(A.x,A.y,A.m);
  const okC = toVH(C.m)? okFrac(C.x,C.y,C.m) : okInt(C.x,C.y,C.m);
  return inBox && okA && okC && (B.m===0);
}

/* petite v√©rification "vraie tangence" : pas de recoupement imm√©diat */
function tangentDoesNotCrossNear(f, P, R, side='both'){
  const h=0.6; const line=x=>P.y + P.m*(x-P.x);
  let arr=[];
  if(side!=='right' && P.x-h>=R.xmin) arr.push( Math.sign(f(P.x-h)-line(P.x-h)) );
  if(side!=='left'  && P.x+h<=R.xmax) arr.push( Math.sign(f(P.x+h)-line(P.x+h)) );
  arr=arr.filter(s=>s!==0);
  return arr.length>=1 && arr.every(s=>s===arr[0]);
}




/* tirage de 3 entiers distincts lisibles */
function pick3DistinctInts(pool=[-5,-4,-3,-2,-1,0,1,2,3,4,5]){
  const P=[...pool], xs=[];
  while(xs.length<3) xs.push(P.splice(rnd(0,P.length-1),1)[0]);
  return xs.sort((a,b)=>a-b);
}



function fmtSlopeHTML(m){ const vh=toVH(m); return vh? fracHTML(vh[0],vh[1]) : fmtNum(m); }

/* === Inputs & ticks helpers (globaux) === */
function mkInput(id, w=120, ph='', pdfw=null){
  const W = Number(pdfw ?? w); // largeur du trait en PDF
  return `
    <span class="blank-wrap" data-w="${W}">
      <input id="${id}" style="width:${w}px" autocomplete="off" inputmode="text" placeholder="${ph}">
      <span class="blank" aria-hidden="true" style="width:${W}px">&nbsp;</span>
    </span>
  `.trim();
}


function setVal(host,id,val){
  // ne pas auto-remplir pendant l'affichage de la solution
  if(host && host._noFillSolution) return;
  const el = host.querySelector('#'+id);
  if(el) el.value = val;
}
function getVal(host,id){
  const el = host.querySelector('#'+id);
  return el ? String(el.value||'').trim() : '';
}


  // Cache des derniers param√®tres g√©n√©r√©s par exercice
  window.__EXO_PARAMS_CACHE = window.__EXO_PARAMS_CACHE || {};


/* ================== Exercices ================== */
function makeExos(){
  const L=[];

  /* ===== Ex. 1 ‚Äî Lire f'(a) sur la courbe ===== */
  L.push({
    id:'ex1_deriv_graph',
    title:"Ex. 1 ‚Äî Lire f'(a) sur la courbe",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  return {R:RVIS, f:g.f, df:g.df, pts:[g.A,g.B,g.C], pts20:g.pts20};
},

    render(host, st){
      const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
      const ui=renderWithRepere(host, s.R);
      ui.rep.drawCurve(s.f,'#e53935',2.5);
      const labels=['A','B','C'];
      s.pts.forEach((P,i)=>{
        ui.rep.drawPoint(labels[i], P.x, P.y, '#1565c0');
        ui.rep.drawLineThroughPointSlope(P.x, P.y, P.m, '#1565c0', true);
      });
      // ordre al√©atoire des trois demandes
const idx=[0,1,2]; idx.sort(()=>Math.random()-0.5);
ui.equ.innerHTML = `
  <p>La courbe de la fonction <b>f</b> est trac√©e en rouge.</p>
  <p>Les droites bleues sont les tangentes en <b>A</b>, <b>B</b> et <b>C</b>.</p>
  <p>f'(${fmtNum(s.pts[idx[0]].x)}) = ${mkInput('d1',80)} <span id="t1" class="tick">‚Äî</span></p>
  <p>f'(${fmtNum(s.pts[idx[1]].x)}) = ${mkInput('d2',80)} <span id="t2" class="tick">‚Äî</span></p>
  <p>f'(${fmtNum(s.pts[idx[2]].x)}) = ${mkInput('d3',80)} <span id="t3" class="tick">‚Äî</span></p>
  <div class="steps" id="steps"></div>
`;
// stocke l'ordre pour la v√©rif
s._order = idx;

      ui.actions.innerHTML='';
      host._state=s; host._ui=ui;
    },
verify(host){
  const s=host._state;
  const idx = s._order || [0,1,2];

  const a1 = slopeOKStrict(getVal(host,'d1'), s.pts[idx[0]].m);
  const a2 = slopeOKStrict(getVal(host,'d2'), s.pts[idx[1]].m);
  const a3 = slopeOKStrict(getVal(host,'d3'), s.pts[idx[2]].m);

  setTick($('#t1',host), a1); setTick($('#t2',host), a2); setTick($('#t3',host), a3);

  const allFilled = [a1,a2,a3].every(x => x !== null);
  return allFilled && (a1===true && a2===true && a3===true);
},

    solution(host){
  const {pts} = host._state;                 // A,B,C
  const steps = $('#steps', host);
  const order = (host._state._order && Array.isArray(host._state._order))
                ? host._state._order : [0,1,2];    // m√™me ordre que les questions
  const labs = ['A','B','C'];
  const VHlabel = `<span class="frac"><span class="num">V</span><span class="den">H</span></span>`;

  const html = order.map(k=>{
    const P = pts[k];
    const horiz = Math.abs(P.m) < 1e-12;
    const xTxt = fmtNum(P.x);
    const pente = horiz ? '0' : `${VHlabel} = ${vhHTML(P.m)}`;   // V/H en pile
    const fp = horiz ? '0' : fprimeHTML(P.m);                    // entier si H=1

    return `<div class="step">
      <b>${labs[k]}(${xTxt}; f(${xTxt}))</b> et pente : ${pente}
      donc f'(${xTxt}) = ${fp}${horiz ? ' (tangente horizontale)' : ''}
    </div>`;
  }).join('');

  steps.innerHTML = html;
}




  });

  /* ===== Ex. 2 ‚Äî Tangentes & lectures ===== */
  L.push({
    id:'ex2_tangentes_triple',
    title:"Ex. 2 ‚Äî Nombre d√©riv√© et tangentes (A, B, D)",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  const A=g.A, B=g.B, D=g.C;
  const T1={m:A.m, p:A.y - A.m*A.x};
  const T2={m:B.m, p:B.y - B.m*B.x};
  const T3={m:D.m, p:D.y - D.m*D.x};
  const vh = HERMITE5.toVH(D.m) || [Math.round(D.m),1];
  let E = { x: D.x + vh[1], y: D.y + vh[0] };
  if(E.x>RVIS.xmax || E.x<RVIS.xmin || E.y>RVIS.ymax || E.y<RVIS.ymin){ 
    E = { x: D.x - vh[1], y: D.y - vh[0] }; 
  }
  return {R:RVIS, f:g.f, A,B,D, T1,T2,T3, E, pts20:g.pts20};
},
    render(host, st){
  const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
  const ui=renderWithRepere(host, s.R);
  // Segment visible de la tangente dans [xmin,xmax]√ó[ymin,ymax]
function segmentInBox_throughPointSlope(x0,y0,m,R){
  const cand=[];
  const yL = m*(R.xmin - x0) + y0; if (yL>=R.ymin && yL<=R.ymax) cand.push({x:R.xmin,y:yL});
  const yR = m*(R.xmax - x0) + y0; if (yR>=R.ymin && yR<=R.ymax) cand.push({x:R.xmax,y:yR});
  if (Math.abs(m)>1e-12){
    const xB = x0 + (R.ymin - y0)/m; if (xB>=R.xmin && xB<=R.xmax) cand.push({x:xB,y:R.ymin});
    const xT = x0 + (R.ymax - y0)/m; if (xT>=R.xmin && xT<=R.xmax) cand.push({x:xT,y:R.ymax});
  } else { cand.push({x:ui.rep.R.xmin,y:y0},{x:ui.rep.R.xmax,y:y0}); }
  const u=[]; for(const p of cand){ if(!u.some(q=>Math.abs(q.x-p.x)<1e-9&&Math.abs(q.y-p.y)<1e-9)) u.push(p); }
  while(u.length<2) u.push({x:ui.rep.R.xmin,y:y0},{x:ui.rep.R.xmax,y:y0});
  return u.slice(0,2);
}

// Duplique une tangente en "PDF-safe" (un simple <line> en PIXELS, dans un groupe d√©di√©)
function addPdfSafeLine(rep, Q1, Q2, color){
  const NS = rep.el.namespaceURI;
  let g = rep.el.querySelector('g.tangent-pdf-safe');
  if(!g){ g = document.createElementNS(NS,'g'); g.setAttribute('class','tangent-pdf-safe'); rep.el.appendChild(g); }
  // on dessine en coordonn√©es √©cran (pixels)
  const A = rep.coordToScreen(Q1.x, Q1.y);
  const B = rep.coordToScreen(Q2.x, Q2.y);
  const L = document.createElementNS(NS,'line');
  L.setAttribute('x1', A.x); L.setAttribute('y1', A.y);
  L.setAttribute('x2', B.x); L.setAttribute('y2', B.y);
  L.setAttribute('stroke', color);
  L.setAttribute('stroke-width', '2.5');
  L.setAttribute('stroke-dasharray', '6 6');     // pointill√©s
  L.setAttribute('stroke-linecap', 'round');
  // IMPORTANT: pas de "vector-effect", √ßa passe mieux en PDF
  g.appendChild(L);
}

// Supprime le cercle d‚Äôun point nomm√© (pour ne garder QUE le texte)
function stripDotForLabel(rep, labelText){
  const texts = Array.from(rep.el.querySelectorAll('text')).filter(t=>t.textContent===labelText);
  texts.forEach(t=>{
    const g = t.closest('g');
    if(!g) return;
    const c = g.querySelector('circle');
    if(c) c.remove();
  });
}

     // --- Tangentes color√©es + labels visibles
const COLORS = ['#1e40af', '#7c3aed', '#16a34a']; // bleu, violet, vert
  const SUB    = ['‚ÇÅ','‚ÇÇ','‚ÇÉ'];

  ui.rep.drawCurve(s.f,'#e53935',2.5);
  ui.rep.drawLineThroughPointSlope(s.A.x, s.A.y, s.A.m, COLORS[0], true);
{ const m = Math.abs(s.A.m)<1e-12?0:s.A.m;
  const [Q1,Q2] = segmentInBox_throughPointSlope(s.A.x,s.A.y,m,s.R);
  addPdfSafeLine(ui.rep, Q1, Q2, COLORS[0]);
  // ton label √©cran (SVG) reste comme tu l‚Äôavais (pas n√©cessaire pour le PDF)
}
// B
ui.rep.drawLineThroughPointSlope(s.B.x, s.B.y, s.B.m, COLORS[1], true);
{ const m = Math.abs(s.B.m)<1e-12?0:s.B.m;
  const [Q1,Q2] = segmentInBox_throughPointSlope(s.B.x,s.B.y,m,s.R);
  addPdfSafeLine(ui.rep, Q1, Q2, COLORS[1]);
}
// D
ui.rep.drawLineThroughPointSlope(s.D.x, s.D.y, s.D.m, COLORS[2], true);
{ const m = Math.abs(s.D.m)<1e-12?0:s.D.m;
  const [Q1,Q2] = segmentInBox_throughPointSlope(s.D.x,s.D.y,m,s.R);
  addPdfSafeLine(ui.rep, Q1, Q2, COLORS[2]);
}
    drawTangentWithLabel(s.A, COLORS[0], 'T'+SUB[0]);
drawTangentWithLabel(s.B, COLORS[1], 'T'+SUB[1]);
drawTangentWithLabel(s.D, COLORS[2], 'T'+SUB[2]);

  ui.rep.drawPoint('E',s.E.x,s.E.y,'#1565c0');
 
  function segmentInBox_throughPointSlope(x0,y0,m,R){
  const cand=[];
  const yL = m*(R.xmin - x0) + y0; if (yL>=R.ymin && yL<=R.ymax) cand.push({x:R.xmin,y:yL});
  const yR = m*(R.xmax - x0) + y0; if (yR>=R.ymin && yR<=R.ymax) cand.push({x:R.xmax,y:yR});
  if (Math.abs(m)>1e-12){
    const xB = x0 + (R.ymin - y0)/m; if (xB>=R.xmin && xB<=R.xmax) cand.push({x:xB,y:R.ymin});
    const xT = x0 + (R.ymax - y0)/m; if (xT>=R.xmin && xT<=R.xmax) cand.push({x:xT,y:R.ymax});
  } else { cand.push({x:s.R.xmin,y:y0}, {x:s.R.xmax,y:y0}); }
  const uniq=[]; for(const p of cand){ if(!uniq.some(q=>Math.abs(q.x-p.x)<1e-9 && Math.abs(q.y-p.y)<1e-9)) uniq.push(p); }
  while(uniq.length<2) uniq.push({x:s.R.xmin,y:y0},{x:s.R.xmax,y:y0});
  return uniq.slice(0,2);
}
// Place le label pr√®s d'une extr√©mit√© visible du segment, en restant dans la vue.
// Retourne des coordonn√©es √âCRAN [sx, sy] avec d√©calage le long de la tangente et perpendiculaire.
function placeLabelAtSegmentEnd(rep, Q1, Q2, anchor /* {x,y} */, opts = {}){
  const insetPx = opts.insetPx ?? 22;   // recul depuis l'extr√©mit√© (px)
  const normalPx = opts.normalPx ?? 9;  // d√©calage perpendiculaire (px)

  // √âcran
  const A = rep.coordToScreen(Q1.x, Q1.y);
  const B = rep.coordToScreen(Q2.x, Q2.y);
  const C = rep.coordToScreen(anchor.x, anchor.y);

  // Choisir l'extr√©mit√© la PLUS √âLOIGN√âE du point de tangence
  const dA = Math.hypot(A.x - C.x, A.y - C.y);
  const dB = Math.hypot(B.x - C.x, B.y - C.y);
  const E  = (dA >= dB) ? A : B;              // extr√©mit√© cible
  const O  = (E === A) ? B : A;               // l'autre point

  // Vecteur unitaire le long du segment, orient√© vers l'int√©rieur du segment
  let ux = E.x - O.x, uy = E.y - O.y;
  const len = Math.hypot(ux, uy) || 1;
  ux /= len; uy /= len;

  // Recul vers l'int√©rieur (on s'√©loigne du bord)
  let sx = E.x - insetPx * ux;
  let sy = E.y - insetPx * uy;

  // D√©calage perpendiculaire (choisir le c√¥t√© "vers le centre" pour la lisibilit√©)
  // Perpendiculaire en √©cran : n = (-uy, ux)
  let nx = -uy, ny = ux;
  const center = { x: (rep.R.xmin + rep.R.xmax)/2, y: (rep.R.ymin + rep.R.ymax)/2 };
  const Scoord = rep.screenToCoord(sx, sy);
  // signe pour pousser le label vers le centre du rep√®re
  const toCenter = { x: center.x - Scoord.x, y: center.y - Scoord.y };
  // passer toCenter en √©cran pour coh√©rence du signe
  const TC = rep.coordToScreen(Scoord.x + toCenter.x, Scoord.y + toCenter.y);
  const vCenter = { x: TC.x - sx, y: TC.y - sy };
  const sign = (nx * vCenter.x + ny * vCenter.y) >= 0 ? 1 : -1;

  sx += sign * normalPx * nx;
  sy += sign * normalPx * ny;

  return [sx, sy];
}

  function drawTangentWithLabel(P, color, labelText){
  // 1) LIGNE ‚Üí confi√©e au rep√®re (compatible PDF, pointill√©s natifs)
  ui.rep.drawLineThroughPointSlope(P.x, P.y, P.m, color, true);

  // 2) LABEL ‚Üí SVG, plac√© √† l‚Äôextr√©mit√© visible
  const NS = ui.rep.el.namespaceURI;
  let g = ui.rep.gUser.querySelector('g.initial-tangent-labels');
  if(!g){ g = document.createElementNS(NS,'g'); g.setAttribute('class','initial-tangent-labels'); ui.rep.gUser.appendChild(g); }

  const m = (Math.abs(P.m)<1e-12)? 0 : P.m;
  const [Q1,Q2] = segmentInBox_throughPointSlope(P.x,P.y,m,s.R);

  const [sx, sy] = placeLabelAtSegmentEnd(ui.rep, Q1, Q2, {x:P.x, y:P.y}, {insetPx:22, normalPx:9});
  const T = document.createElementNS(NS,'text');
  T.textContent = labelText;
  T.setAttribute('x', sx); T.setAttribute('y', sy);
  T.setAttribute('font-size','12'); T.setAttribute('font-weight','700');
  T.setAttribute('fill', color);
  T.setAttribute('stroke', '#fff'); T.setAttribute('stroke-width', '3');
  T.setAttribute('paint-order', 'stroke'); T.setAttribute('pointer-events','none');
  g.appendChild(T);
  if (typeof ui.rep._placeLabel === 'function') ui.rep._placeLabel(T, sx, sy);
}

   
  


  // ordre al√©atoire pour images & d√©riv√©es (A,B,D ~ 0,1,2)
  const orderVals=[0,1,2].sort(()=>Math.random()-0.5);
  const orderDer =[0,1,2].sort(()=>Math.random()-0.5);
  const P=[s.A,s.B,s.D], LAB=['A','B','D'];
  // valeurs : grands blancs ~140 px
const valRow = orderVals.map(k =>
  `f(${fmtNum(P[k].x)}) = ${mkInput('f'+LAB[k], 80, '', 140)} <span id="tf${LAB[k]}" class="tick"></span>`
).join(' ; ');

// d√©riv√©es : idem ~140 px
const derRow = orderDer.map(k =>
  `f'(${fmtNum(P[k].x)}) = ${mkInput('df'+LAB[k], 80, '', 140)} <span id="tdf${LAB[k]}" class="tick"></span>`
).join(' ; ');
  ui.equ.innerHTML = `
    <p>Soit une fonction <b>f</b>. Les droites
      <b style="color:${COLORS[0]}">T${SUB[0]}</b>, <b style="color:${COLORS[1]}">T${SUB[1]}</b> et
      <b style="color:${COLORS[2]}">T${SUB[2]}</b> sont les tangentes √† <b>C<sub>f</sub></b> aux points <b>A</b>, <b>B</b> et <b>D</b>.
    </p>
    <p>Le point <b>E(${fmtNum(s.E.x)} ; ${fmtNum(s.E.y)})</b> est choisi de sorte que <b>(DE)</b> soit la tangente √† <b>C<sub>f</sub></b> au point <b>D</b>.</p>
    <ol>
      <li>D√©terminer : ${valRow}.</li>
      <li>D√©terminer : ${derRow}.</li>
            <li>Donner une √©quation des tangentes :<br>
        <span style="font-weight:700;color:${COLORS[0]}">T${SUB[0]}</span> :
        ${mkInput('t1', 220, 'y = ...', 320)} <span id="tt1" class="tick"></span><br>
        <span style="font-weight:700;color:${COLORS[1]}">T${SUB[1]}</span> :
        ${mkInput('t2', 220, 'y = ...', 320)} <span id="tt2" class="tick"></span><br>
        <span style="font-weight:700;color:${COLORS[2]}">T${SUB[2]}</span> :
        ${mkInput('t3', 220, 'y = ...', 320)} <span id="tt3" class="tick"></span>
      </li>

    </ol>
    <div class="steps" id="steps2"></div>
  `;

  // m√©morise l‚Äôordre pour la solution
  host._state = {...s, _orderVals:orderVals, _orderDer:orderDer};
  host._ui=ui;
},

    // --- Exercice 2 : remplace la m√©thode verify(host) par ceci
verify(host){
  const s = host._state;
  const P = { A: s.A, B: s.B, D: s.D };

  // helpers locaux : renvoient true / false / null (si vide)
  const checkInt = (id, expected, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const v = parseIntStrict(raw);
    const ok = (v !== null && v === expected);
    setTick($(tickSel,host), ok);
    return ok;
    };

  const checkSlope = (id, expected, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const ok = slopeOKStrict(raw, expected);  // d√©j√† strict + neutre g√©r√© dedans si besoin
    setTick($(tickSel,host), ok);
    return ok;
  };

  const checkLine = (id, mVH, pVH, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const ok = lineOKStrict(raw, mVH, pVH);   // strict : pas de d√©cimales
    setTick($(tickSel,host), ok);
    return ok;
  };

  // --- Valeurs (entiers stricts)
  const r = [];
  r.push( checkInt('fA', P.A.y, '#tfA') );
  r.push( checkInt('fB', P.B.y, '#tfB') );
  r.push( checkInt('fD', P.D.y, '#tfD') );

  // --- D√©riv√©es (entier ou fraction pile r√©duite ; jamais de d√©cimal)
  r.push( checkSlope('dfA', P.A.m, '#tdfA') );
  r.push( checkSlope('dfB', P.B.m, '#tdfB') );
  r.push( checkSlope('dfD', P.D.m, '#tdfD') );

  // --- √âquations (strictes, en forme exacte)
  const mA = slopeVH(P.A.m), pA = pFromPoint(...mA, P.A.x, P.A.y);
  const mB = slopeVH(P.B.m), pB = pFromPoint(...mB, P.B.x, P.B.y);
  const mD = slopeVH(P.D.m), pD = pFromPoint(...mD, P.D.x, P.D.y);

  r.push( checkLine('t1', mA, pA, '#tt1') );
  r.push( checkLine('t2', mB, pB, '#tt2') );
  r.push( checkLine('t3', mD, pD, '#tt3') );

  // true seulement si TOUT est rempli et correct
  return r.every(v => v === true);
},


    solution(host){
  const s=host._state, st=$('#steps2',host);
  const P=[s.A,s.B,s.D], LAB=['A','B','D'];

  // 1) Pr√©-remplissage des inputs (en forme exacte)
  setVal(host,'fA',s.A.y); setVal(host,'fB',s.B.y); setVal(host,'fD',s.D.y);
  setVal(host,'dfA', fprimeHTML_strict(s.A.m));
  setVal(host,'dfB', fprimeHTML_strict(s.B.m));
  setVal(host,'dfD', fprimeHTML_strict(s.D.m));

  const mA=slopeVH(s.A.m), pA=pFromPoint(...mA, s.A.x, s.A.y);
const mB=slopeVH(s.B.m), pB=pFromPoint(...mB, s.B.x, s.B.y);
const mD=slopeVH(s.D.m), pD=pFromPoint(...mD, s.D.x, s.D.y);

const eq1 = eqHTML(mA, pA);
const eq2 = eqHTML(mB, pB);
const eq3 = eqHTML(mD, pD);

setVal(host,'t1', eq1);
setVal(host,'t2', eq2);
setVal(host,'t3', eq3);


  // 2) Texte de correction qui respecte exactement l'ordre pos√© dans l'√©nonc√©
  const ordV = s._orderVals || [0,1,2];
  const ordD = s._orderDer  || [0,1,2];

  const valeurs = ordV.map(k=>`f(${fmtNum(P[k].x)})=${P[k].y}`).join(', ');
  const pentes  = ordD.map(k=>`f'(${fmtNum(P[k].x)})=${fprimeForSentence(P[k].m)}`).join(', ');

  const L=[];
  L.push(`<div class="step"><b>Valeurs</b> : ${valeurs}.</div>`);
  L.push(`<div class="step"><b>Pentes</b> : ${pentes}.</div>`);
  L.push(`<div class="step"><b>√âquations</b> : <code>y = f'(a)(x‚àía) + f(a)</code> ou par lecture graphique</div>`);
  L.push(`<div class="step">T‚ÇÅ : ${eq1}</div>`);
  L.push(`<div class="step">T‚ÇÇ : ${eq2}</div>`);
  L.push(`<div class="step">T‚ÇÉ : ${eq3}</div>`);

  st.innerHTML = L.join('');
    // --- Colorer les lignes "T" dans le texte de correction
  (function colorTextBadges(){
const COLORS = ['#1e40af', '#7c3aed', '#16a34a']; // bleu, violet, vert
  const SUB    = ['‚ÇÅ','‚ÇÇ','‚ÇÉ'];
  const steps = $('#steps2', host);
  if(!steps) return;
  steps.innerHTML = steps.innerHTML
    .replace(/T‚ÇÅ/g, `<span style="font-weight:700;color:${COLORS[0]}">T${SUB[0]}</span>`)
    .replace(/T‚ÇÇ/g, `<span style="font-weight:700;color:${COLORS[1]}">T${SUB[1]}</span>`)
    .replace(/T‚ÇÉ/g, `<span style="font-weight:700;color:${COLORS[2]}">T${SUB[2]}</span>`);
})();


// === Helper coordonn√© : position "extr√©mit√© visible" en COORDONN√âES (robuste PDF) ===
function placeLabelAtSegmentEndCoord(R, Q1, Q2, anchor /* {x,y} */, opts = {}){
  const insetFrac  = opts.insetFrac  ?? 0.06; // recul depuis le bord (6% de la longueur visible)
  const normalFrac = opts.normalFrac ?? 0.03; // d√©calage perpendiculaire (3% de l‚Äô√©chelle)

  // choisir l‚Äôextr√©mit√© la plus √©loign√©e du point de tangence
  const d1 = Math.hypot(Q1.x - anchor.x, Q1.y - anchor.y);
  const d2 = Math.hypot(Q2.x - anchor.x, Q2.y - anchor.y);
  const E  = (d1 >= d2 ? Q1 : Q2);
  const O  = (E === Q1 ? Q2 : Q1);

  // vecteur le long du segment (coord)
  let vx = E.x - O.x, vy = E.y - O.y;
  const L = Math.hypot(vx, vy) || 1;
  // reculer vers l‚Äôint√©rieur
  let x = E.x - insetFrac * vx;
  let y = E.y - insetFrac * vy;

  // d√©calage perpendiculaire vers le centre du rep√®re
  let nx = -vy / L, ny = vx / L;                       // normal unitaire
  const cx = (R.xmin + R.xmax)/2, cy = (R.ymin + R.ymax)/2;
  const toCdot = nx*(cx - x) + ny*(cy - y);            // signe pour pousser vers le centre
  if (toCdot < 0){ nx = -nx; ny = -ny; }
  const scale = normalFrac * Math.min(R.xmax - R.xmin, R.ymax - R.ymin);
  x += scale * nx; y += scale * ny;

  return [x, y];
}

// === Tangentes "solution" 100% compatibles PDF : lignes via rep√®re + labels via drawPoint ===
(function drawSolutionTangents(){
  const ui = host._ui, R = ui.rep.R;
  const COLORS = ['#1e40af', '#7c3aed', '#16a34a'];
  const SUB    = ['‚ÇÅ','‚ÇÇ','‚ÇÉ'];
  const Ps     = [s.A, s.B, s.D];

  // Nettoyage anti-doublons
  ui.rep.gUser.querySelectorAll('g.initial-tangent-labels, g.solution-tangent-labels').forEach(n => n.remove());
  const svgTexts = ui.rep.el.querySelectorAll('g.tangent-pdf-safe text');
  svgTexts.forEach(n => n.remove());

  // Groupe (facultatif) si tu veux des labels SVG d‚Äô√©cran en plus
  const NS = ui.rep.el.namespaceURI;
  let gLab = ui.rep.gUser.querySelector('g.solution-tangent-labels');
  if(!gLab){ gLab = document.createElementNS(NS,'g'); gLab.setAttribute('class','solution-tangent-labels'); ui.rep.gUser.appendChild(gLab); }

  Ps.forEach((P,i)=>{
    const color = COLORS[i];
    const m = (Math.abs(P.m)<1e-12)? 0 : P.m;

    // 1) Lignes (√©cran) + copie PDF-safe
    ui.rep.drawLineThroughPointSlope(P.x, P.y, m, color, true);
    const [Q1,Q2] = segmentInBox_throughPointSlope(P.x,P.y,m,R);
    addPdfSafeLine(ui.rep, Q1, Q2, color);

    // 2) Nom en PDF : drawPoint + suppression du cercle ‚áí il ne reste que le texte
    ui.rep.drawPoint('T'+SUB[i], ... (function(){  // position pr√®s d'une extr√©mit√© visible
      // petit placement c√¥t√© extr√©mit√© la plus √©loign√©e de P, avec un l√©ger recul
      const d1 = Math.hypot(Q1.x - P.x, Q1.y - P.y);
      const d2 = Math.hypot(Q2.x - P.x, Q2.y - P.y);
      const E  = (d1>=d2)? Q1 : Q2;
      // recul de 6% du segment + l√©ger d√©calage perpendiculaire (coordonn√©es)
      const O  = (E===Q1)? Q2 : Q1;
      const vx = E.x - O.x, vy = E.y - O.y, L = Math.hypot(vx,vy)||1;
      let x = E.x - 0.06*vx, y = E.y - 0.06*vy;   // recul
      let nx = -vy/L, ny = vx/L;
      const cx=(R.xmin+R.xmax)/2, cy=(R.ymin+R.ymax)/2;
      if (nx*(cx-x)+ny*(cy-y) < 0){ nx=-nx; ny=-ny; }
      const s=0.03*Math.min(R.xmax-R.xmin, R.ymax-R.ymin);
      x += s*nx; y += s*ny;
      return [x,y];
    })(), color);

    // supprimer le disque ‚Üí label texte seul (captur√© en PDF)
    stripDotForLabel(ui.rep, 'T'+SUB[i]);
  });
})();






}

  });

/* ===== Ex. 3 ‚Äî f'(x) lin√©aire ===== */
L.push({
  id:'ex3_derivee_lineaire',
  title:"Ex. 3 ‚Äî f'(x) = ax + b",
  gen(){
    const a = rchoice([-6,-4,-2,2,3,5]);
    const b = rchoice([-4,-2,0,2,4,11]);
    const poolN = [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1, 1,2,3,4,5,6,7,8,9,10];
    const n = rchoice(poolN);                 // n ‚â† 0
    return {a,b,n};
  },
  render(host, st){
    const s = st.params || this.gen();
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderNoRepere(host);
    ui.equ.innerHTML = `
      <p>On donne pour tout r√©el x : <b>f'(x) = ${s.a}x ${s.b>=0?'+':''}${s.b}</b>.</p>
      <ol>
        <li>Calculer f'(0) = ${mkInput('v1',80)} <span id="tv1" class="tick">‚Äî</span> et f'(${fmtNum(s.n)}) = ${mkInput('v2',80)} <span id="tv2" class="tick">‚Äî</span>.</li>
        <li>En d√©duire les coefficients directeurs des tangentes √† C<sub>f</sub> aux points A et B d‚Äôabscisses resp√©ctives 0 et ${fmtNum(s.n)} :
          m<sub>A</sub> = ${mkInput('mA',80)} <span id="tmA" class="tick">‚Äî</span>, m<sub>B</sub> = ${mkInput('mB',80)} <span id="tmB" class="tick">‚Äî</span>.
        </li>
      </ol>
      <div class="steps" id="steps3"></div>
    `;
    host._state = s; host._ui = ui;
  },
  verify(host){
    const s = host._state;
    const A = s.a*0   + s.b;          // f'(0)
    const B = s.a*s.n + s.b;          // f'(n)
    const v1 = parseNum(getVal(host,'v1'));
    const v2 = parseNum(getVal(host,'v2'));
    const ok1 = eqNum(v1, A);
    const ok2 = eqNum(v2, B);
    setTick($('#tv1',host), ok1);
    setTick($('#tv2',host), ok2);

    const okA = eqNum(parseNum(getVal(host,'mA')), A);
    const okB = eqNum(parseNum(getVal(host,'mB')), B);
    setTick($('#tmA',host), okA);
    setTick($('#tmB',host), okB);

    return ok1 && ok2 && okA && okB;
  },
  solution(host){
    const s = host._state;
    const A = s.a*0   + s.b;
    const B = s.a*s.n + s.b;
    setVal(host,'v1', A);
    setVal(host,'v2', B);
    setVal(host,'mA', A);
    setVal(host,'mB', B);
	const nDisp = (s.n < 0) ? `(${fmtNum(s.n)})` : fmtNum(s.n);
    $('#steps3',host).innerHTML = `
      <div class="step"><b>f'(0) = ${s.a}√ó0 ${s.b>=0?'+':''}${s.b} = ${A}</b>.</div>
<div class="step"><b>f'(${fmtNum(s.n)}) = ${s.a}√ó${nDisp} ${s.b>=0?'+':''}${s.b} = ${B}</b>.</div>
      <div class="step">Le coefficient directeur de la tangente en x=a vaut <code>f'(a)</code> :
        m<sub>A</sub> = f'(0) = ${A}, m<sub>B</sub> = f'(${fmtNum(s.n)}) = ${B}.
      </div>
    `;
  }
});


  /* ===== Ex. 4 ‚Äî f'(x_A) avec la tangente passant par B ===== */
L.push({
  id:'ex4_tangent_par_deux_points',
  title:"Ex. 4 ‚Äî f'(x_A) avec la tangente passant par B",
  gen(){
    // A et B entiers lisibles dans [-6,6], x_B ‚â† x_A
    const R = {xmin:-6,xmax:6,ymin:-6,ymax:6};
    let tries = 0;
    while(tries++ < 500){
      const xA = rnd(R.xmin+1, R.xmax-1);
      const yA = rnd(R.ymin+1, R.ymax-1);
      const dx = rchoice([-5,-4,-3,-2,-1, 1,2,3,4,5]); // pas de verticale
      const V  = rnd(-5,5);                             // d√©calage en y
      const xB = xA + dx, yB = yA + V;
      if(xB<R.xmin || xB>R.xmax || yB<R.ymin || yB>R.ymax) continue;
      return {A:{x:xA,y:yA}, B:{x:xB,y:yB}};
    }
    // fallback
    return {A:{x:-3,y:1}, B:{x:2,y:-1}};
  },
  render(host, st){
    const s = st.params || this.gen();
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderNoRepere(host);
    ui.equ.innerHTML = `
      <p>Dans le plan muni du rep√®re (O,I,J), la tangente √† C<sub>f</sub> au point
      <b>A(${fmtNum(s.A.x)}; ${fmtNum(s.A.y)})</b> passe par le point
      <b>B(${fmtNum(s.B.x)}; ${fmtNum(s.B.y)})</b>.</p>
      <p>D√©terminer le nombre d√©riv√© <b>f'(${fmtNum(s.A.x)})</b> :
      ${mkInput('m',100)} <span id="tm" class="tick">‚Äî</span></p>
      <div class="steps" id="steps4"></div>`;
    host._state = s; host._ui = ui;
  },
  verify(host){
    const s = host._state;
    const m = (s.B.y - s.A.y) / (s.B.x - s.A.x);              // pente (AB)
    const ok = eqNum(parseNum(getVal(host,'m')), m, 1e-6);    // accepte entier, a/b, d√©cimal exact
    setTick($('#tm',host), ok);
    return ok;
  },
  solution(host){
  const s  = host._state;
  const UMINUS = '‚àí';
  const u = t => String(t).replace(/-/g, UMINUS);   // affichage grand ‚Äú‚àí‚Äù

  const dy = s.B.y - s.A.y;           // y_B ‚àí y_A
  const dx = s.B.x - s.A.x;           // x_B ‚àí x_A

  // √âcriture d√©velopp√©e avec gestion des signes : -(-k) ‚Üí +k ; +(-k) ‚Üí ‚àík
  const numExpr = `${u(s.B.y)} ${s.A.y < 0 ? '+' : '‚àí'} ${u(Math.abs(s.A.y))}`;
  const denExpr = `${u(s.B.x)} ${s.A.x < 0 ? '+' : '‚àí'} ${u(Math.abs(s.A.x))}`;

  // Fraction symbolique et num√©rique (en ‚Äúpile‚Äù)
  const fracHTMLsym  = `<span class="frac"><span class="num">y<sub>B</sub> ‚àí y<sub>A</sub></span><span class="den">x<sub>B</sub> ‚àí x<sub>A</sub></span></span>`;
  const fracHTMLnums = `<span class="frac"><span class="num">${numExpr}</span><span class="den">${denExpr}</span></span>`;

  // R√©duction et signe global extrait devant la fraction
  const [Nred, Dred] = reduce(Math.abs(dy), Math.abs(dx));   // >0
  const isNeg = (dy < 0) !== (dx < 0);                       // signe global

  // Affichage final ‚Äúpile‚Äù avec signe devant (ou entier)
  const finalPile = (Nred===0) ? '0'
    : (Dred===1
        ? (isNeg ? `${UMINUS} ${u(Nred)}` : `${u(Nred)}`)
        : (isNeg ? `${UMINUS} <span class="frac"><span class="num">${Nred}</span><span class="den">${Dred}</span></span>`
                  : `<span class="frac"><span class="num">${Nred}</span><span class="den">${Dred}</span></span>`));

  // Valeur √† pr√©-remplir dans l‚Äôinput (ASCII pour le parseur : entier ou "a/b")
  const inputVal = (Dred===1) ? (isNeg ? -Nred : Nred) : `${isNeg?'-':''}${Nred}/${Dred}`;
  setVal(host,'m', inputVal);

  // Rendu au format de ton exemple
  const steps = host.querySelector('#steps4');
  steps.innerHTML = `
    <div class="step">
      f'(${u(s.A.x)}) = m<sub>(AB)</sub> = ${fracHTMLsym}= ${fracHTMLnums} = <b>${finalPile}</b>
    </div>
  `;
}


});


  /* ===== Ex. 5 ‚Äî √âquation de tangentes (A et B varient) ===== */
L.push({
  id:'ex5_eq_tangente_point_pente',
  title:"Ex. 5 ‚Äî √âquation de tangentes (points A et B)",
  gen(){
    // Tirages lisibles (entiers)
    const pick = () => ({
      x: rnd(-5,5),
      y: rnd(-5,5),
      m: rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]) // pente non nulle
    });
    let A = pick(), B = pick();
    // √©vite A=B trop souvent
    let guard=0; 
    while(guard++<50 && (A.x===B.x && A.y===B.y)) B = pick();
    return {A,B};
  },
  render(host, st){
    const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
    const ui=renderNoRepere(host);
    ui.equ.innerHTML = `
  <ol>
    <li>
      D√©terminer une √©quation de la tangente <b>T</b> au point 
      <b>A(${fmtNum(s.A.x)} ; ${fmtNum(s.A.y)})</b> √† C<sub>f</sub> 
      sachant que : <b>f'(${fmtNum(s.A.x)}) = ${fmtNum(s.A.m)}</b>.<br>
      ${mkInput('eq1',260,'y = ...')} <span id="te1" class="tick">‚Äî</span>
    </li>
    <li>
      D√©terminer une √©quation de la tangente <b>T</b> au point 
      <b>B(${fmtNum(s.B.x)} ; ${fmtNum(s.B.y)})</b> √† C<sub>f</sub> 
      sachant que <b>le coefficient directeur de T est ${fmtNum(s.B.m)}</b>.<br>
      ${mkInput('eq2',260,'y = ...')} <span id="te2" class="tick">‚Äî</span>
    </li>
  </ol>
  <div class="steps" id="steps5"></div>
`;
    host._state=s; host._ui=ui;
  },
  verify(host){
    const s=host._state;
    const pA = s.A.y - s.A.m*s.A.x;
    const pB = s.B.y - s.B.m*s.B.x;
    const ok1 = isSameLine(getVal(host,'eq1'), s.A.m, pA);
    const ok2 = isSameLine(getVal(host,'eq2'), s.B.m, pB);
    setTick($('#te1',host), ok1); setTick($('#te2',host), ok2);
    return ok1 && ok2;
  },
  solution(host){
    const s=host._state;
    const UMINUS='‚àí', u=t=>String(t).replace(/-/g,UMINUS);
    const pm = k => k<0 ? ` ${UMINUS} ${u(Math.abs(k))}` : ` + ${u(k)}`;
    const bracket = x => x===0 ? `(x)` : `(x ${x<0?'+':'‚àí'} ${u(Math.abs(x))})`;

    function solveBlock(P, label){ // P = {x,y,m}
      const p = P.y - P.m*P.x;           // y = m x + p
      const lineFinal = `y = ${u(P.m)}x${p===0?'':pm(p)}`;
      // Remplit l'input correspondant
      setVal(host, label==='A'?'eq1':'eq2', lineFinal);

      // √âtapes au format demand√©
      return `
        <div class="step"><b>${label}(${u(P.x)} ; ${u(P.y)})</b> donc <b>f(${u(P.x)}) = ${u(P.y)}</b> et on sait que <b>f'(${u(P.x)}) = ${u(P.m)}</b> donc :</div>
        <div class="step"><i>L‚Äô√©quation de la tangente</i> <b>T<sub>${label}</sub></b> est :</div>
        <div class="step">y = f'(${u(P.x)})${bracket(P.x)} + f(${u(P.x)})</div>
        <div class="step">y = ${u(P.m)}${bracket(P.x)} + ${u(P.y)}</div>
        <div class="step">y = ${u(P.m)}x${(P.x===0)?'':pm(P.m*(-P.x))}${pm(P.y)}</div>
        <div class="step"><b>${lineFinal}</b></div>
      `;
    }

    $('#steps5',host).innerHTML = `
      ${solveBlock(s.A,'A')}
      <br>
      ${solveBlock(s.B,'B')}
    `;
  }
});


// Affichage propre (‚àö, ¬≤/¬≥, √ó, fraction 1/(2‚àöx) en pile)
// Affichage propre (‚àö, ¬≤/¬≥, √ó, fractions‚Ä¶)
function prettyExprHTML(expr){
  const U = '‚àí';
  const frac = (N,D)=>`<span class="frac"><span class="num">${N}</span><span class="den">${D}</span></span>`;
  let s = String(expr||'').trim();

  // Signes + espaces
  s = s.replace(/-/g, U).replace(/\s+/g, ' ');

  // ‚àöx / ‚àö(...)
  s = s.replace(/sqrt\(\s*x\s*\)/gi, '‚àöx')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '‚àö($1)');

  // 1/(2*sqrt(x)) ‚Üí 1/(2‚àöx)
  s = s.replace(/1\s*\/\s*\(\s*2\s*[*√ó¬∑]?\s*sqrt\(\s*x\s*\)\s*\)/gi, ()=> frac('1','2‚àöx'));

  // ---- Puissances ‚Üí affichage HTML (tous les cas) ----
  // x^n
  s = s.replace(/x\^2\b/gi, 'x¬≤')
       .replace(/x\^3\b/gi, 'x¬≥')
       .replace(/x\^(\d+)/gi, (_,$1)=>`x<sup>${$1}</sup>`);

  // (¬±nombre)^n
  s = s.replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*2/g, '$1¬≤')
       .replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*3/g, '$1¬≥')
       .replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*(\d+)/g, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // nombre^n
  s = s.replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*2/g, '$1¬≤')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*3/g, '$1¬≥')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // Fallback : toute occurrence r√©siduelle ")^n" ou "x^n"
  s = s.replace(/(\)|x)\s*\^\s*(\d+)/gi, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // √ó uniquement entre nombres (pas avant x, ‚àö, ()
  s = timesNumbersOnly(s);

  // Signes nettoy√©s
  s = s.replace(/\+\s*‚àí/g, ` ${U} `)
       .replace(/‚àí\s*\+/g, ` ${U} `)
       .replace(/‚àí\s*‚àí/g, ' + ')
       .replace(/\s+/g, ' ');

  return s;
}



// √âvaluation s√ªre : ajoute les * implicites et parenth√®se "-x**2"
// √âvaluation s√ªre : caret ^ ‚Üí **, multiplications implicites, etc.
function evalExprSafe(expr, x){
  let code = String(expr || '')
    // 0) Nettoyages d√©fensifs
    .replace(/\ufeff/g, '')                       // BOM
    .replace(/<\/?[^>]+>/g, '')                   // tags HTML
    .replace(/[\u00A0\u202F\u2009\u200A\u2005\u2006\u2007\u2008\u2002\u2003\u2004]/g, ' ') // espaces sp√©ciaux
    // 1) Normalisations Unicode ‚Üí ASCII
    .replace(/‚àí/g, '-')                           // grand moins
    .replace(/[‚Äì‚Äî]/g, '-')                        // en/em dash
    .replace(/[√ó¬∑‚Ä¢]/g, '*')                       // multiplications
    .replace(/[‚ÅÑ‚àï]/g, '/')                        // slashs fraction
    .replace(/,/g, '.')                           // virgule d√©cimale
    // 2) Racines
    .replace(/sqrt\(/gi, 'Math.sqrt(')
    .replace(/‚àö\s*\(\s*/g, 'Math.sqrt(')
    .replace(/‚àö\s*x/gi, 'Math.sqrt(x)');

  // 3) Puissances '^' ‚Üí op√©rateur JS '**'
  code = code
    .replace(/x\^(\d+)/gi, 'x**$1')                     // x^n
    .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)**$2')  // (...)^n
    .replace(/(\d+(?:\.\d+)?)\s*\^\s*(\d+)/g, '($1**$2)'); // nombre^n

  // 4) Multiplications implicites (y compris avant Math.sqrt)
  code = code
    .replace(/(\d)\s*x\b/g, '$1*x')       // 2x ‚Üí 2*x
    .replace(/\)\s*x\b/g, ')*x')          // )x ‚Üí )*x
    .replace(/\bx\s*\(/g, 'x*(')          // x( ‚Üí x*(
    .replace(/(\d)\s*\(/g, '$1*(')        // 2( ‚Üí 2*(
    .replace(/\)\s*\(/g, ')*(')           // )( ‚Üí )*(
    .replace(/(\d)\s*(?=Math\.)/g, '$1*') // 2Math.sqrt ‚Üí 2*Math.sqrt
    .replace(/\)\s*(?=Math\.)/g, ')*');   // )Math.sqrt ‚Üí )*Math.sqrt

  // 5) Dernier filtre : garde caract√®res autoris√©s
  code = code.replace(/[^0-9eE+\-*/().x\sA-Za-z_]/g, '');

  // 6) JS n‚Äôaime pas "-x**2" ‚Üí parenth√®se
  code = code.replace(/(^|[^\w\)])-\s*(x\s*\*\*\s*\d+)/g, '$1-($2)');

  const f = new Function('x', 'return (' + code + ');');
  return f(x);
}




// Remplace x par la valeur en ins√©rant * si un nombre ou ')' pr√©c√®de x
function substXWithMul(str, X){
  const sub = (X < 0 ? `(${X})` : String(X));  // parenth√®ses seulement si X<0
  return str
    .replace(/(\d|\))\s*x\b/g, '$1*' + sub)    // a x^n ‚Üí a*X^n  (ou )x ‚Üí )*X)
    .replace(/x\b/g, sub);                     // le reste : x ‚Üí X
}



/* ===== Ex. 6 ‚Äî √âquation de la tangente (f et f' donn√©s) + S√âLECTEUR ===== */
L.push({
  id:'ex6_eq_tangente_f_fx',
  title:"Ex. 6 ‚Äî √âquation de la tangente (f et f' donn√©s)",
  gen(forcedKind){
    // ‚Üí on conserve 'poly' (exclut affine), et on ajoute 'affine' & 'linear'
    const kinds = ['square','cube','inverse','sqrt','affine','linear','poly'];
    const kind  = (forcedKind && forcedKind!=='random') ? forcedKind : rchoice(kinds);

    // Fabrique un polyn√¥me de degr√© 2 ou 3 (‚â† affine)
    // ‚Ä¶ √† l‚Äôint√©rieur de gen(forcedKind) ‚Ä¶
// dans gen(forcedKind) de l'exo 6
// Dans gen() de l'Ex.6
// --- PATCH polyGen (corrige l'affichage de dfx) ---
function polyGen(){
  const UMINUS = '‚àí';
  const deg = rchoice([2,3]);                 // jamais affine
  const a = rchoice([-3,-2,-1,1,2,3]);
  const b = rchoice([-3,-2,-1,0,1,2,3]);
  const c = rchoice([-3,-2,-1,0,1,2,3]);
  const d = rchoice([-3,-2,-1,0,1,2,3]);

  // Mon√¥me int√©rieur " ¬± A x^p " (cache A si A=1 et p>=1)
  const term = (K, p) => {
    if (K === 0) return '';
    const s = K > 0 ? ' + ' : ` ${UMINUS} `;
    const A = Math.abs(K);
    if (p === 0) return s + A;
    if (p === 1) return s + (A === 1 ? '' : A) + 'x';
    return s + (A === 1 ? '' : A) + `x^${p}`;
  };

  // Mon√¥me de t√™te (sans " + " devant)
  const lead = (K, p) => {
    const S = K < 0 ? UMINUS : '';
    const A = Math.abs(K);
    if (p === 1) return S + (A === 1 ? '' : A) + 'x';
    return S + (A === 1 ? '' : A) + `x^${p}`;
  };

  let fx = '', dfx = '';

  if (deg === 3) {
    // f(x) = ax^3 + bx^2 + cx + d
    fx  = lead(a,3) + term(b,2) + term(c,1) + term(d,0);

    // f'(x) = 3ax^2 + 2bx + c
    const A3 = 3*a, B2 = 2*b;
    dfx = lead(A3,2) + term(B2,1) + term(c,0);
  } else {
    // f(x) = ax^2 + bx + c
    fx  = lead(a,2) + term(b,1) + term(c,0);

    // f'(x) = 2ax + b
    const A2 = 2*a;
    dfx = lead(A2,1) + term(b,0);
  }

  return {
    fx:  String(fx).replace(/^\+\s*/,'').trim(),
    dfx: String(dfx).replace(/^\+\s*/,'').trim()
  };
}



    let fx, dfx, xA;

    if(kind==='square'){    fx='x^2';             dfx='2x';            xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='cube'){ fx='x^3';             dfx='3x^2';          xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='inverse'){ fx='1/x';          dfx='-1/x^2';        xA=rchoice([-3,-2,-1,1,2,3]);   } // ‚â†0
    else if(kind==='sqrt'){    fx='sqrt(x)';      dfx='1/(2sqrt(x))'; xA=rchoice([1,4,9]);   } // simple
    else if(kind==='affine'){
      const m = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // pente ‚â†0
      const b = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // b ‚â†0 pour √©viter lin√©aire
      fx  = `${m}x ${b>=0?'+':''}${b}`;
      dfx = `${m}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else if(kind==='linear'){
      const k = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      fx  = `${k}x`;                                          // pas de ‚Äú+ 0‚Äù
      dfx = `${k}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else{ // 'poly' (degr√© 2 ou 3 uniquement)
      const P = polyGen();
      fx=P.fx; dfx=P.dfx;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }

    return {kind, fx, dfx, xA};
  },

  render(host, st){
    const chosen = (window.__EXO6_KIND__ || 'random');
    const s = st.params || this.gen(chosen);
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderNoRepere(host);

    const selectorHTML = `
      <div class="optionline small" style="margin-bottom:.4rem">
        <label for="kind6"><b>Type de fonction :</b></label>
        <select id="kind6">
          <option value="random">Al√©atoire</option>
          <option value="square">Carr√© (x¬≤)</option>
          <option value="cube">Cube (x¬≥)</option>
          <option value="inverse">Inverse (1/x)</option>
          <option value="sqrt">Racine carr√©e (‚àöx)</option>
          <option value="affine">Affine (mx + b)</option>
          <option value="linear">Lin√©aire (kx)</option>
          <option value="poly">Polyn√¥me (deg 2‚Äì3)</option>
        </select>
        <button id="regen6" class="btn">‚Üª Tirer</button>
      </div>
    `;
    // (dans Ex.6 render)
const fxH  = prettyExprHTML(s.fx);
const dfxH = prettyExprHTML(s.dfx);
ui.equ.innerHTML = `
${selectorHTML}
  <p>Donner une √©quation de la tangente <b>T</b> au point <b>A</b> de <b>C<sub>f</sub></b> d‚Äôabscisse <b>x<sub>A</sub></b>.</p>
  <p><code>f(x) = ${fxH}</code> &nbsp; et &nbsp; <code>f'(x) = ${dfxH}</code> &nbsp; en <b>x<sub>A</sub> = ${s.xA}</b>.</p>
  ${mkInput('r1',260,'y = ...')} <span id="tr1" class="tick">‚Äî</span>
  <div class="steps" id="steps6"></div>
`;

    host._state=s; host._ui=ui;

    $('#kind6',host).value = chosen;
    const regenerate = (kind)=>{ window.__EXO6_KIND__ = kind; this.render(host,{params:this.gen(kind)}); };
    $('#kind6',host).addEventListener('change', e=>regenerate(e.target.value));
    $('#regen6',host).addEventListener('click', ()=>regenerate($('#kind6',host).value));
  },

  verify(host){
    const s=host._state;
    const m = evalExprSafe(s.dfx, s.xA);
    const y = evalExprSafe(s.fx , s.xA);
    const p = y - m*s.xA;
    const ok = isSameLine(getVal(host,'r1'), m, p);
    setTick($('#tr1',host), ok);
    return ok;
  },


  solution(host){
  const s = host._state;
  const U='‚àí', u=t=>String(t).replace(/-/g,U);
  const frac = (N,D)=>`<span class="frac"><span class="num">${N}</span><span class="den">${D}</span></span>`;
  const supPow = k => k===2?'¬≤':k===3?'¬≥':`<sup>${k}</sup>`;
  const showVal = x => u(x);
  const showPar = x => x<0 ? `(${u(x)})` : u(x);
  const powShow = (x,k)=>`${showPar(x)}${supPow(k)}`;
  const multShow= (a,b)=>`${u(a)} √ó ${showPar(b)}`;

  // valeurs exactes
  const m = evalExprSafe(s.dfx, s.xA);
  const y = evalExprSafe(s.fx , s.xA);
  const X  = s.xA, Xs = showVal(X);

  // ‚Äî Puces : z√©ro doublon, √ó obligatoires, parenth√®ses seulement si n√©gatif ‚Äî
  let fLine='', dLine='';
  if(/^\s*x\^2\s*$/i.test(s.fx)){                     // carr√©
    fLine = `<b>f(${Xs}) = ${powShow(X,2)} = ${showVal(X*X)}</b>`;
    dLine = `<b>f'(${Xs}) = ${multShow(2,X)} = ${showVal(2*X)}</b>`;
  }else if(/^\s*x\^3\s*$/i.test(s.fx)){               // cube
    fLine = `<b>f(${Xs}) = ${powShow(X,3)} = ${showVal(X*X*X)}</b>`;
    dLine = `<b>f'(${Xs}) = 3 √ó ${powShow(X,2)} = ${multShow(3,X*X)} = ${showVal(3*X*X)}</b>`;
  }else if(/^\s*1\s*\/\s*x\s*$/i.test(s.fx)){         // inverse
    if(Math.abs(X)===1){
      fLine = `<b>f(${Xs}) = ${showVal(X<0?-1:1)}</b>`;
      dLine = `<b>f'(${Xs}) = ${U}${showVal(1)}</b>`;
    }else{
      const [ny,dy]=reduce(1,Math.abs(X));
      const [nm,dm]=reduce(1,Math.abs(X*X));
      fLine = `<b>f(${Xs}) = ${frac(1, X<0?`(${Xs})`:Xs)} = ${(X<0?U:'')}${frac(ny,dy)}</b>`;
      dLine = `<b>f'(${Xs}) = ${U}${frac(1, `${showPar(X)}${supPow(2)}`)} = ${U}${frac(nm,dm)}</b>`;
    }
  }else if(/sqrt\(\s*x\s*\)/i.test(s.fx)){            // racine
    fLine = `<b>f(${Xs}) = ‚àö${X<0?`(${Xs})`:Xs} = ${showVal(Math.sqrt(X))}</b>`;
    dLine = `<b>f'(${Xs}) = ${frac(1, `2‚àö${X<0?`(${Xs})`:Xs}`)} = ${frac(1, 2*showVal(Math.sqrt(X)))}</b>`;
  }else{                                              // affine / lin√©aire / polyn√¥me
    const subX = X<0 ? `(${Xs})` : Xs;
const fSub = prettyExprHTML( substXWithMul(s.fx , X) );
const dSub = prettyExprHTML( substXWithMul(s.dfx, X) );

    fLine = `<b>f(${Xs})</b> = ${fSub} = <b>${showVal(y)}</b>`;
    dLine = `<b>f'(${Xs})</b> = ${dSub} = <b>${showVal(m)}</b>`;
  }

  // ‚Äî Tangente : y = m(x ‚àí xA) + f(xA) ‚Üí y = mx + p (sans +- / --) ‚Äî
  const mVH = slopeVH(m);
  const mHTML = (mVH[1]===1)? showVal(mVH[0]) : frac(mVH[0],mVH[1]);
  const xShift = X===0 ? '(x)' : `(x ${X<0?'+':'‚àí'} ${showVal(Math.abs(X))})`;

  const termRat = reduce(-mVH[0]*X, mVH[1]);                          // ‚àím xA
  const termSign = termRat[0] < 0 ? ` ${U} ` : ' + ';
  const termAbsHTML = (termRat[1]===1)? showVal(Math.abs(termRat[0])) : frac(Math.abs(termRat[0]), Math.abs(termRat[1]));

  let yRat;
  if(/^\s*1\s*\/\s*x\s*$/i.test(s.fx)){ yRat = reduce((X<0?-1:1)*1, Math.abs(X)); }
  else { yRat = [y,1]; }
  const ySign    = yRat[0] < 0 ? ` ${U} ` : ' + ';
  const yAbsHTML = (yRat[1]===1)? showVal(Math.abs(yRat[0])) : frac(Math.abs(yRat[0]), Math.abs(yRat[1]));

  const pVH = pFromPoint(...mVH, X, y);
  const eq  = eqHTML(mVH, pVH);
  setVal(host,'r1', eq);

  $('#steps6',host).innerHTML = `
    <div class="step">‚Ä¢ ${fLine}</div>
    <div class="step">‚Ä¢ ${dLine}</div>
    <div class="step" style="margin-top:.5rem"><i>L‚Äô√©quation de la tangente</i> <b>T<sub>A</sub></b> est :</div>
    <div class="step">y = f'(${Xs})${xShift} + f(${Xs})</div>
    <div class="step">y = ${mHTML}${xShift} + ${(yRat[1]===1)? showVal(yRat[0]) : frac(yRat[0],yRat[1])}</div>
    <div class="step">y = ${mHTML}x${termSign}${termAbsHTML}${ySign}${yAbsHTML}</div>
    <div class="step"><b>${eq}</b></div>
  `;
}

});


/* ===== Ex. 7 ‚Äî Tracer T avec f‚Ä≤(a) (2 clics : 1er clic affiche A/B/C) ===== */
L.push({
  id:'ex7_graph_mix',
  title:"Ex. 7 ‚Äî Tangentes √† partir du nombre d√©riv√© (2 clics, A/B/C au 1er clic)",

  gen(){
    // Courbe C¬π lisible issue de ton g√©n√©rateur (A: f'(x)=0 ; B: pente enti√®re ; C: pente rationnelle)
    const RVIS = {xmin:-8,xmax:8,ymin:-8,ymax:8};
    const g = HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
    const items = [
      { kind: (Math.abs(g.A.m)<1e-12?'horiz':'gen'), x:g.A.x, y:g.A.y, m:g.A.m },
      { kind: (Math.abs(g.B.m)<1e-12?'horiz':'gen'), x:g.B.x, y:g.B.y, m:g.B.m },
      { kind: (Math.abs(g.C.m)<1e-12?'horiz':'gen'), x:g.C.x, y:g.C.y, m:g.C.m }
    ];
    items.forEach(t => t.VH = slopeVH(t.m));               // pente attendue sous forme [V,H] r√©duite
    const order = [0,1,2].sort(()=>Math.random()-0.5);     // ordre al√©atoire des 3 t√¢ches
    const tasks = order.map(i => items[i]);
    // libell√©s affich√©s A,B,C dans l'ordre des questions (et pas des points internes)
    const labels = ['A','B','C'];
    return { R:RVIS, f:g.f, df:g.df, tasks, labels };
  },

  render(host, st){
    const s = st.params || this.gen();
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderWithRepere(host, s.R);

    // Courbe seule au d√©part
    ui.rep.drawCurve(s.f,'#212121',2.5);

    // Texte d'√©nonc√© + champ d'√©quation √† c√¥t√© de T·µ¢
    const mHTML = ([V,H]) => (H===1 ? fmtNum(V) : `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`);
    const bloc = s.tasks.map((t,i)=>{
	const SUB = ['‚ÇÅ','‚ÇÇ','‚ÇÉ']; // juste au-dessus du template map si besoin
      const a = fmtNum(t.x), lab = s.labels[i];
      return `
        <li style="margin:.6rem 0">
          On admet que <b>f‚Äô(${a}) = ${mHTML(t.VH)}</b>.
          Tracer sur la courbe la tangente <b>T<sub>${i+1}</sub></b> √† la courbe C<sub>f</sub> au point d‚Äôabscisse <b>${a}</b>.
          <i>On appellera ce point ${lab}.</i><br>
          <span class="small">Clic 1 : sur le point de la courbe d‚Äôabscisse ${a} (affiche ¬´&nbsp;${lab}&nbsp;¬ª). Clic 2 : second point (sans √©tiquette) pour fixer la tangente.</span><br>
<button class="btn" data-start="${i}">üéØ Activer T${SUB[i]}</button>
          &nbsp; T<sub>${i+1}</sub> : <input id="eq${i}" style="width:240px" placeholder="y = ..." autocomplete="off"> <span id="teq${i}" class="tick"></span>
          <span id="tbuild${i}" class="tick" style="margin-left:.4rem"></span>
        </li>`;
    }).join('');

    ui.equ.innerHTML = `
      <p><b>Consigne.</b> Pour chaque tangente T<sub>i</sub> : <b>cliquez d‚Äôabord</b> sur le point de la courbe d‚Äôabscisse demand√©e (le point <b>A/B/C</b> appara√Æt), puis <b>cliquez un second point</b> pour tracer T<sub>i</sub>. √âcrivez ensuite l‚Äô<b>√©quation de T<sub>i</sub></b> dans la barre √† c√¥t√©.</p>
      <ol>${bloc}</ol>
      <div class="steps" id="steps7"></div>
    `;

    // √âtat d‚Äôinteraction
    host._state = {
      ...s,
      active: null,                      // indice de la question activ√©e (0..2)
      anchors: [null,null,null],         // 1er clic (point A/B/C)
      secondPts: [null,null,null]        // 2e clic (point sans √©tiquette)
    };
    host._ui = ui;

    // Helpers de dessin
    function drawDot(rep,x,y,color){
      const c = document.createElementNS(rep.el.namespaceURI,'circle');
      const p = rep.coordToScreen(x,y);
      c.setAttribute('cx',p.x); c.setAttribute('cy',p.y);
      c.setAttribute('r',4); c.setAttribute('fill',color);
      rep.gUser.appendChild(c);
    }
    function drawLabel(rep, x,y, txt, color='#f57c00'){
      const t = document.createElementNS(rep.el.namespaceURI,'text');
      const p = rep.coordToScreen(x,y);
      t.setAttribute('x',p.x); t.setAttribute('y',p.y);
      t.setAttribute('font-size','12'); t.setAttribute('fill',color); t.setAttribute('font-weight','700');
      t.textContent = txt;
      rep.gUser.appendChild(t);
      rep._placeLabel(t, p.x, p.y);
    }
    function drawLine(rep, x0,y0, x1,y1, color='#2e7d32'){
      if(x0===x1) return; // on √©vite la verticale (non demand√©e ici)
      const m = (y1-y0)/(x1-x0);
      const xa=rep.R.xmin, xb=rep.R.xmax;
      const ya = m*(xa-x0)+y0, yb = m*(xb-x0)+y0;
      const A=rep.coordToScreen(xa,ya), B=rep.coordToScreen(xb,yb);
      const L=document.createElementNS(rep.el.namespaceURI,'line');
      L.setAttribute('x1',A.x); L.setAttribute('y1',A.y);
      L.setAttribute('x2',B.x); L.setAttribute('y2',B.y);
      L.setAttribute('stroke',color); L.setAttribute('stroke-width','2'); L.setAttribute('stroke-dasharray','6 6');
      rep.gUser.appendChild(L);
    }
    function redrawUser(){
      ui.rep.gUser.innerHTML='';
      for(let i=0;i<3;i++){
        const A = host._state.anchors[i], E = host._state.secondPts[i];
        if(A){ drawDot(ui.rep, A.x, A.y, '#f57c00'); drawLabel(ui.rep, A.x, A.y, s.labels[i], '#f57c00'); }
        if(A && E){ drawDot(ui.rep, E.x, E.y, '#2e7d32'); drawLine(ui.rep, A.x, A.y, E.x, E.y, '#2e7d32'); }
      }
    }

    // Activation par bouton
    ui.right.querySelectorAll('button[data-start]').forEach(btn=>{
      btn.addEventListener('click', e=>{
        host._state.active = parseInt(e.currentTarget.dataset.start,10);
      });
    });

    // --- helper : coordonn√©es SVG (viewBox) depuis un event pointeur ---
function toSvgCoords(svg, ev){
  const cx = ('clientX' in ev) ? ev.clientX : ev.touches?.[0]?.clientX;
  const cy = ('clientY' in ev) ? ev.clientY : ev.touches?.[0]?.clientY;
  const ctm = svg.getScreenCTM && svg.getScreenCTM();
  if (ctm && ctm.inverse){
    const pt = svg.createSVGPoint();
    pt.x = cx; pt.y = cy;
    const p = pt.matrixTransform(ctm.inverse());
    return {x:p.x, y:p.y}; // unit√©s du viewBox (0..420)
  }
  // Fallback rect/ratio
  const r  = svg.getBoundingClientRect();
  const vb = svg.viewBox?.baseVal || {x:0,y:0,width:420,height:420};
  return {
    x: (cx - r.left) * (vb.width  / r.width),
    y: (cy - r.top)  * (vb.height / r.height)
  };
}

// --- gestion du tap/clic (pointer + click fallback) ---
const handleTap = (ev) => {
  if (host._state.active === null) return;
  if (ev.pointerType === 'touch') ev.preventDefault();

  // 1) √©cran ‚Üí viewBox ‚Üí rep√®re
  const Pvb = toSvgCoords(ui.rep.el, ev);
  const P   = ui.rep.screenToCoord(Pvb.x, Pvb.y);
  const xi  = Math.round(P.x);
  const yi  = Math.round(P.y);

  const i    = host._state.active;
  const task = host._state.tasks[i];

  // ---- 1er clic : uniquement l‚Äôabscisse (on "snappe" √† A=(a,f(a)) ) ----
  if (!host._state.anchors[i]){
    const tol = 0.6; // tol√©rance sur x en unit√©s du rep√®re
    if (Math.abs(P.x - task.x) <= tol){
      host._state.anchors[i] = { x: task.x, y: task.y }; // y forc√© √† f(a)
      redrawUser();
    }
    return;
  }

  // ---- 2e clic : second point (arrondi √† la grille enti√®re) ----
  host._state.secondPts[i] = { x: xi, y: yi };
  redrawUser();

  // ---- V√©rification (m√™me logique qu‚Äôavant) ----
  const A = host._state.anchors[i], E = host._state.secondPts[i];
  let ok = false;
  if (E && !(E.x===A.x && E.y===A.y)){
    if (Math.abs(task.m) < 1e-12){
      ok = (E.y === A.y) && (E.x !== A.x);
    } else if (E.x !== A.x){
      const r1 = reduce(E.y - A.y, E.x - A.x), r2 = reduce(...task.VH);
      ok = (r1[0]*r2[1] === r2[0]*r1[1]);
    }
  }
  setTick($('#tbuild'+i,host), ok);
};

ui.rep.el.addEventListener('pointerdown', handleTap, {passive:false});
ui.rep.el.addEventListener('click',       handleTap, {passive:true}); // fallback desktop


    redrawUser();
  },

  verify(host){
    // Valide si : construction correcte + √©quation correcte, pour chaque question
    const s = host._state;
    const allOK = [0,1,2].map(i=>{
      const t = s.tasks[i], A = s.anchors[i], E = s.secondPts[i];
      if(!A || !E){ setTick($('#tbuild'+i,host), null); return false; }

      // construction
      let okBuild=false;
      if(Math.abs(t.m)<1e-12){ okBuild = (E.y===A.y) && (E.x!==A.x); }
      else if(E.x!==A.x){
        const r1 = reduce(E.y-A.y, E.x-A.x), r2 = reduce(...t.VH);
        okBuild = (r1[0]*r2[1] === r2[0]*r1[1]);
      }
      setTick($('#tbuild'+i,host), okBuild);

      // √©quation attendue : y = (V/H)x + p  avec p = yA - (V/H)a
      const mVH = t.VH;
      const pVH = pFromPoint(...mVH, t.x, t.y);
      const okEq = lineOKStrict(getVal(host, 'eq'+i), mVH, pVH);
      setTick($('#teq'+i,host), okEq);

      return okBuild && okEq;
    });
    return allOK.every(Boolean);
  },

  solution(host){
    const s = host._state;
    const steps = $('#steps7',host);
    let html = '';

    s.tasks.forEach((t,i)=>{
      const lab = s.labels[i];
      const [V,H] = t.VH;
      const a = fmtNum(t.x), ya = fmtNum(t.y);
      const mText = (H===1)? fmtNum(V) : `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`;
      const eq = eqHTML([V,H], pFromPoint(V,H, t.x, t.y));
      setVal(host,'eq'+i, eq); // on pr√©-remplit la barre d‚Äô√©quation

      if(Math.abs(t.m)<1e-12){
        // ‚Äî mod√®le "tangente horizontale" ‚Äî
        html += `
          <div class="step">
            <b>T<sub>${i+1}</sub></b> ‚Äî f'(${a}) = 0 donc la tangente est <b>horizontale</b>.<br>
            Elle passe par le point <b>${lab}(${a} ; ${ya})</b> donc l'√©quation de la tangente <b>T<sub>${i+1}</sub></b> est :<br>
            <b>y = ${ya}</b>
          </div>
        `;
          }else{
  // ‚Äî cas g√©n√©ral : m ‚â† 0 ‚Äî
  const [V,H] = t.VH;
  const aNum = t.x;
  const yA   = t.y;

  // m en joli (entier ou fraction)
  const mText = (H===1)
    ? fmtNum(V)
    : `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`;

  // terme (‚àím¬∑a) = (‚àíV¬∑a)/H en fraction r√©duite
  const [TN, TD] = reduce(-V * aNum, H);
  const termAbsHTML = (TD===1)
    ? fmtNum(Math.abs(TN))
    : `<span class="frac"><span class="num">${Math.abs(TN)}</span><span class="den">${TD}</span></span>`;
  const termSign = (TN < 0) ? ' ‚àí ' : ' + ';

  // p pour la ligne finale
  const pVH = pFromPoint(V, H, aNum, yA);
  const eq  = eqHTML([V,H], pVH);

  // pr√©-remplissage du champ √©quation
  setVal(host, 'eq'+i, eq);

  html += `
    <div class="step">
      <b>T<sub>${i+1}</sub></b><br>
      f' (${fmtNum(aNum)}) = ${mText}<br>
      Par lecture graphique on a : f(${fmtNum(aNum)}) = ${fmtNum(yA)} car <b>${lab}(${fmtNum(aNum)} ; ${fmtNum(yA)})</b><br>
      L‚Äô√©quation de la tangente <b>T<sub>${i+1}</sub></b> est :<br><br>
      y = f' (${fmtNum(aNum)})(x ‚àí ${fmtNum(aNum)}) + f(${fmtNum(aNum)})<br>
      y = ${mText}(x ‚àí ${fmtNum(aNum)}) + ${fmtNum(yA)}<br>
      y = ${mText}x${termSign}${termAbsHTML} ${yA>=0 ? '+ ' : ''}${fmtNum(yA)}<br>
      <b>${eq}</b>
    </div>
  `;
}

    });

    steps.innerHTML = html;
	// --- Am√©lioration : couleurs distinctes + labels toujours visibles ---
(function drawSolutionTangents(){
  const ui = host._ui;
  const rep = ui.rep, R = rep.R;
  const NS = rep.el.namespaceURI;

  // Nettoyage d'une ancienne couche
  const old = rep.gUser.querySelector('g.solution-tangents');
  if (old) old.remove();

  const g = document.createElementNS(NS,'g');
  g.setAttribute('class','solution-tangents');
  rep.gUser.appendChild(g);

  // Couleurs distinctes pour T1, T2, T3 (tu peux changer si besoin)
const COLORS = ['#1e40af', '#7c3aed', '#16a34a']; // bleu, violet, vert
  const SUB    = ['‚ÇÅ','‚ÇÇ','‚ÇÉ'];

  // Renvoie les deux points d'intersection de la tangente avec la fen√™tre [xmin,xmax]√ó[ymin,ymax]
  function segmentInBox_throughPointSlope(x0,y0,m,R){
    const cand = [];

    // x = xmin / xmax
    const yL = m*(R.xmin - x0) + y0;
    if (yL >= R.ymin && yL <= R.ymax) cand.push({x:R.xmin, y:yL});
    const yR = m*(R.xmax - x0) + y0;
    if (yR >= R.ymin && yR <= R.ymax) cand.push({x:R.xmax, y:yR});

    // y = ymin / ymax
    if (Math.abs(m) > 1e-12){
      const xB = x0 + (R.ymin - y0)/m;
      if (xB >= R.xmin && xB <= R.xmax) cand.push({x:xB, y:R.ymin});
      const xT = x0 + (R.ymax - y0)/m;
      if (xT >= R.xmin && xT <= R.xmax) cand.push({x:xT, y:R.ymax});
    } else {
      // horizontale
      cand.push({x:R.xmin, y:y0}, {x:R.xmax, y:y0});
    }

    // D√©dupliquer et ne garder que 2 points
    const uniq = [];
    for (const p of cand){
      if (!uniq.some(q => Math.abs(q.x - p.x) < 1e-9 && Math.abs(q.y - p.y) < 1e-9)) uniq.push(p);
    }
    // Au pire, compl√©ter avec les bords horizontaux
    while (uniq.length < 2){
      uniq.push({x:R.xmin, y:y0}, {x:R.xmax, y:y0});
    }
    return uniq.slice(0,2);
  }

  s.tasks.forEach((t,i)=>{
    const x0 = t.x, y0 = t.y;
    const m  = (Math.abs(t.m) < 1e-12) ? 0 : (t.VH[0] / t.VH[1]);
    const color = COLORS[i % COLORS.length];

    // Segment visible dans la fen√™tre
    const [P1, P2] = segmentInBox_throughPointSlope(x0, y0, m, R);

    // Dessin de la tangente "solution"
    const A = rep.coordToScreen(P1.x, P1.y);
    const B = rep.coordToScreen(P2.x, P2.y);

    const L = document.createElementNS(NS,'line');
    L.setAttribute('x1', A.x); L.setAttribute('y1', A.y);
    L.setAttribute('x2', B.x); L.setAttribute('y2', B.y);
    L.setAttribute('stroke', color);
    L.setAttribute('stroke-width', '2.5');
    L.setAttribute('vector-effect','non-scaling-stroke');
    g.appendChild(L);

    // Position du label : au milieu du segment visible (l√©ger d√©calage),
    // puis "clamp" dans la vue via _placeLabel ; halo blanc pour la lisibilit√©
    const tMid = 0.55; // 55% du segment, √©vite souvent le point A
    const xL = P1.x + tMid*(P2.x - P1.x);
    const yL = P1.y + tMid*(P2.y - P1.y);
    const S  = rep.coordToScreen(xL, yL);

    const T = document.createElementNS(NS,'text');
    T.textContent = 'T' + SUB[i];
    T.setAttribute('x', S.x + 6);
    T.setAttribute('y', S.y - 6);
    T.setAttribute('font-size', '12');
    T.setAttribute('font-weight', '700');
    T.setAttribute('fill', color);
    T.setAttribute('stroke', '#fff');              // halo blanc pour contraste
    T.setAttribute('stroke-width', '3');
    T.setAttribute('paint-order', 'stroke');       // dessine d'abord le halo
    T.setAttribute('pointer-events', 'none');      // n'intercepte pas les clics
    g.appendChild(T);

    // Place intelligemment le label pour rester visible dans le rep√®re
    if (typeof rep._placeLabel === 'function'){
      rep._placeLabel(T, S.x + 6, S.y - 6);
    }
  });
})();

    canonizeAllSteps(host);  // nettoyage affichage (√ó, grands moins, etc.)
  }
});



  return L;
}


/* ===== REGISTRY & UI glue ‚Äî VERSION FINALE ===== */
const REGISTRY = makeExos();
window.REGISTRY = REGISTRY; // requis par le kit PDF

function populateSelectSafe(){
  const sel = document.querySelector('#exo-select');
  if(!sel || !window.REGISTRY) return;
  const current = sel.value;
  sel.innerHTML = '';
  for(const e of window.REGISTRY){
    const opt = document.createElement('option');
    opt.value = e.id;
    opt.textContent = e.title;
    sel.appendChild(opt);
  }
  if (current && Array.from(sel.options).some(o => o.value === current)){
    sel.value = current;
  } else {
    sel.selectedIndex = 0;
  }
}

function renderActiveSafe(source=''){
  const host = document.querySelector('#host');
  const sel  = document.querySelector('#exo-select');
  try{
    const def = window.REGISTRY.find(e => e.id === sel.value);
    if(!def) throw new Error('Exercice introuvable: ' + sel.value);
    host.dataset.active = def.id;
    def.render(host, {});
	// -- PATCH: m√©morise les param√®tres tir√©s pour cet exo --
try {
  const st = JSON.parse(host.dataset.state || '{}');
  if (def.id && st && st.params) {
    window.__EXO_PARAMS_CACHE[def.id] = st; // ex: {params: ...}
  }
} catch(e){ /* no-op */ }

  }catch(e){
    console.error('renderActive failed from', source, e);
    host.innerHTML = `<div class="steps" style="color:#b00020">
      <b>Erreur d‚Äôaffichage :</b> ${e.message}<br>Ouvre la console pour le d√©tail.
    </div>`;
  }
}

function scoreSet(a,b){ const s=document.querySelector('#score'); if(s) s.textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];

function attachSelectHandlers(){
  const sel = document.querySelector('#exo-select');
  if(!sel || sel.__BOUND__) return;
  const rerender = (src)=>{ SCORE=[0,0]; scoreSet(0,0); renderActiveSafe(src); };
  sel.addEventListener('change', ()=>rerender('select.change'));
  sel.addEventListener('input',  ()=>rerender('select.input'));
  sel.__BOUND__ = true;
}

window.addEventListener('load', ()=>{
  // init UI exercices
  populateSelectSafe();
  attachSelectHandlers();
  renderActiveSafe('boot');
  scoreSet(0,0);

  // boutons
  document.querySelector('#btn-new')  ?.addEventListener('click', ()=>renderActiveSafe('btn-new'));
  document.querySelector('#btn-reset')?.addEventListener('click', ()=>renderActiveSafe('btn-reset'));

  document.querySelector('#btn-sol')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    host._noFillSolution = true;
    try{ def.solution(host); }catch(e){ console.error(e); }
    canonizeAllSteps(host);
    host._noFillSolution = false;
  });

  document.querySelector('#btn-check')?.addEventListener('click', ()=>{
    const host=document.querySelector('#host');
    const def = window.REGISTRY.find(e => e.id === host.dataset.active);
    const inputs = Array.from(host.querySelectorAll('input'));
    const allFilled = inputs.every(i => String(i.value||'').trim()!=='');
    let ok=false;
    try{ ok = def.verify(host); }catch(e){ console.error(e); }
    if(allFilled){
      if(ok){ SCORE[0]++; SCORE[1]++; } else { SCORE[1]++; }
      scoreSet(...SCORE);
    }
  });
});


</script>

<script>
window.addEventListener('load', function () {
  if (!(window.ExoPDF && ExoPDF.init)) return;

  ExoPDF.init({
    title: 'Premi√®re ‚Äî Nombres d√©riv√©s & tangentes',
    max: 50,
    mountAfterSelector: '#info-saisie',
    leadByDefId: {
      ex1_deriv_graph: "Lire sur la courbe la valeur du nombre d√©riv√© f'(a).",
      ex2_tangentes_triple: "Lecture de valeurs et d‚Äô√©quations de tangentes.",
      ex3_derivee_lineaire: "Calculer f'(a) et les pentes des tangentes.",
      ex4_tangent_par_deux_points: "Retrouver f'(a) √† partir d‚Äôune tangente donn√©e par deux points.",
      ex5_eq_tangente_point_pente: "Donner l‚Äô√©quation de la tangente connaissant le point et la pente.",
      ex6_eq_tangente_f_fx: "Donner l‚Äô√©quation de la tangente √† partir de f et f'.",
      ex7_graph_mix: "Lecture graphique : valeurs, pentes et tangentes."
    },

    beforeRender(def, st, withSolutions){
      // Exos "√† courbe" : 2 colonnes (gauche: rep√®re | droite: texte)
      const TWO_COL = new Set(['ex1_deriv_graph','ex2_tangentes_triple','ex7_graph_mix']);

      // Renforce la barre de fraction pour le PDF
      const FRAC_FIX = `<style>
        .frac>.num{ border-bottom:0!important; position:relative; }
        .frac>.num::after{ content:""; position:absolute; left:0; right:0; bottom:-1px; height:2px; background:currentColor; }
      .pdf-blank{ line-height:1.2 }
@media print { .pdf-blank{ border-bottom-width:2px !important } }
.pdf-blank{ font-family: ui-monospace, Menlo, Consolas, monospace; }
	  </style>`;

      // Table 2 colonnes
      const twoCol = (L,R)=>`
        <table style="width:100%;border-collapse:collapse;table-layout:fixed">
          <tr>
            <td style="width:54%;vertical-align:top;padding:0 12px 0 0">${L||''}</td>
            <td style="width:46%;vertical-align:top;padding:0">${R||''}</td>
          </tr>
        </table>`;

      // Nettoyage des √©l√©ments interactifs (inputs, boutons, ticks‚Ä¶)
      function stripInteractive(root){
  const $$ = sel => Array.from(root.querySelectorAll(sel));
  const pxPerCh = 9;

  $$('input, textarea').forEach(el=>{
  const id  = (el.id||'').toLowerCase();
  const ph  = (el.getAttribute('placeholder')||'').toLowerCase();

  const isEq  = /^t\d/.test(id) || /^eq/.test(id) || /y\s*=|tangente|droite/.test(ph);
  const isVal = /^f[a-z]/i.test(el.id||'');   // fA, fB, fD‚Ä¶
  const isDer = /^df[a-z]/i.test(el.id||'');  // dfA, dfB, dfD‚Ä¶

  const pxPerCh = 9;
  const sw    = parseInt((el.style.width||'').replace('px','')) || 0;
  const sz    = el.getAttribute('size') ? parseInt(el.getAttribute('size'),10)*pxPerCh : 0;
  const phw   = ph.length * pxPerCh;
  const force = parseInt(el.dataset.pdfw || el.dataset.printWidth || '') || 0;

  // Si l'input est dans un wrapper .blank-wrap, on r√©cup√®re sa largeur d√©clar√©e
  const wrapper = el.parentElement && el.parentElement.classList.contains('blank-wrap') ? el.parentElement : null;
  const wrapW   = wrapper ? parseInt(wrapper.dataset.w||'0',10) : 0;

  const W = force || (isEq ? 320 : (isVal||isDer ? 140 : 180));
  const width = Math.max(W, sw, sz, phw, 80, wrapW);

  const span = document.createElement('span');
span.className = 'pdf-blank';

// largeur ‚Äútypographique‚Äù ‚âà 8 px par underscore en police monospace
const nUnders = Math.max(10, Math.round(width / 8));
span.textContent = '_'.repeat(nUnders);

// style (monospace, hauteur correcte). On garde aussi une bordure au cas o√π.
span.style.cssText =
  'display:inline-block;vertical-align:baseline;' +
  'font-family: ui-monospace, Menlo, Consolas, monospace;' +
  'line-height:1.2; height:1.4em;' +
  `min-width:${width}px;` +                  // garantit la largeur
  'border-bottom:2px solid #000;';           // si les _ ne plaisent pas au moteur


  // Si on a un jumeau .blank d√©j√† pr√©sent, on l'enl√®ve pour √©viter le double-trait
  if(wrapper){
    const b = wrapper.querySelector('.blank'); if(b) b.remove();
    wrapper.replaceWith(span);
  }else{
    el.replaceWith(span);
  }
});


  // Nettoyage UI
  $$('button, select, option, .tick, .optionline, [data-math-kbd], .kbd-host').forEach(n=>n.remove());
  $$('[contenteditable]').forEach(n=>n.removeAttribute('contenteditable'));
  return root;
}


      // Clone inline du premier <svg> pour une impression fiable
      function svgInline(root, opts={}){
        const svg = root.querySelector('svg');
        if(!svg) return '';
        const c = svg.cloneNode(true);
        if(!c.getAttribute('viewBox')){
          const vb = svg.viewBox && svg.viewBox.baseVal
            ? svg.viewBox.baseVal
            : {x:0,y:0,width:(svg.width?.baseVal?.value||420),height:(svg.height?.baseVal?.value||420)};
          c.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
        }
        c.setAttribute('xmlns','http://www.w3.org/2000/svg');
        c.setAttribute('preserveAspectRatio','xMidYMid meet');
        c.setAttribute('width',  String(opts.widthPx || 360));
        c.setAttribute('height', String(opts.heightPx || 360));
        // petits all√©gements
        c.querySelectorAll('path, polyline, line').forEach(el=>{
          const sw = parseFloat(el.getAttribute('stroke-width')||'2');
          el.setAttribute('stroke-width', String(Math.max(0.9, sw*0.85)));
        });
        return `<div style="display:block;width:${opts.blockWidth||'100%'}">${c.outerHTML}</div>`;
      }

      // Rendu hors-√©cran √† taille non nulle (sinon getBBox flanche)
      const tmp = document.createElement('div');
      Object.assign(tmp.style, {
        position:'fixed', left:'-10000px', top:'-10000px',
        width:'420px', height:'420px', overflow:'hidden'
      });
      document.body.appendChild(tmp);

      try{
        // >>>>>>>>>>>> CL√â : toujours passer {params: ‚Ä¶} √† render/solution <<<<<<<<<<<<
        const stForRender = (st && st.params) ? st : { params: st || {} };

        // 1) Rendu de l‚Äô√©nonc√©
        def.render(tmp, stForRender);

        // M√©moriser le tirage pour que la solution retombe sur le m√™me √©tat
        try{
          const just = JSON.parse(tmp.dataset.state || '{}');
          if (def.id && just && just.params) window.__EXO_PARAMS_CACHE[def.id] = just;
        }catch(e){/* no-op */ }

        // Pas d‚Äôartefacts interactifs/clics sur le PDF
        const userLayer = tmp.querySelector('g[data-layer="user"]');
        if (userLayer) userLayer.innerHTML = '';

        if(!withSolutions){
          const equ = tmp.querySelector('.equ');
          const right = equ ? equ.cloneNode(true) : tmp.cloneNode(true);
          stripInteractive(right);
          try{ if (window.canonMathHTML) right.innerHTML = canonMathHTML(right.innerHTML); }catch(e){}
          const left = TWO_COL.has(def.id) ? svgInline(tmp, {widthPx:360, heightPx:360}) : '';
          // On renvoie UNIQUEMENT l‚Äô√©nonc√© ; le kit s‚Äôoccupe du cartouche
          return FRAC_FIX + (TWO_COL.has(def.id) ? twoCol(left, right.innerHTML)
                                                 : `<div>${right.innerHTML}</div>`);
        }

        // 2) Rendu du corrig√© (sur le m√™me √©tat)
        const saved = (window.__EXO_PARAMS_CACHE && window.__EXO_PARAMS_CACHE[def.id]) || stForRender;
        try { def.solution(tmp, saved); } catch(e){}
        try { if (window.canonizeAllSteps) canonizeAllSteps(tmp); } catch(e){}
        stripInteractive(tmp);

        const steps = tmp.querySelector('.steps') || tmp.querySelector('.solution');
        const right = steps ? (steps.outerHTML || steps.innerHTML) : '';
        const left  = TWO_COL.has(def.id) ? svgInline(tmp, {widthPx:360, heightPx:360}) : '';
        // On renvoie le contenu du corrig√© SANS l‚Äôen-t√™te (le kit l‚Äôajoute)
        return FRAC_FIX + (TWO_COL.has(def.id) ? twoCol(left, right) : right);

      }catch(e){
        // Laisse le kit faire son fallback (√©vite "indisponible" en double)
        return '';
      }finally{
        tmp.remove();
      }
    }
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on d√©clenche .click() sur eux)
[['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l‚Äôoriginal est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s‚Äôouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>