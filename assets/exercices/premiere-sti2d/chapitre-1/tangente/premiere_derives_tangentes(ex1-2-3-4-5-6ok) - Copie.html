<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Premi√®re ‚Äî Nombres d√©riv√©s & tangentes</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls .btn{border:1px solid #ccc;background:#fff;border-radius:8px;padding:.45rem .7rem;cursor:pointer}
.controls select{border:1px solid #ccc;border-radius:8px;padding:.45rem .55rem}
.controls .btn:active{transform:translateY(1px)}
.controls .score{margin-left:auto;font-weight:700}
.small{font-size:.92rem;color:#555}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.code{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
/* Ticks de validation */
.tick{margin-left:.35rem;font-weight:700}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}
/* Ticks de validation */
.tick{
  display:none;           /* ‚Üê cach√© au d√©part */
  margin-left:.35rem;
  font-weight:700;
}
.tick.ok{ color:#11823b }
.tick.ko{ color:#b00020 }
/* Cache les ticks tant qu'ils ne sont ni ok ni ko */
.tick:not(.ok):not(.ko){ display:none !important; }

.hint{color:#444;font-style:italic;margin:.25rem 0}
.steps{margin:.45rem 0 0 .15rem;padding:.6rem .7rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.frac{display:inline-flex;flex-direction:column;vertical-align:middle;line-height:1}
.frac>.num{border-bottom:1px solid #000;padding:0 .15em;text-align:center}
.frac>.den{padding:0 .15em;text-align:center}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
</style>

<!-- Librairies communes MatHeron -->
<script src='../../../../js/math-kbd.js' defer></script>
<script>
/* ====== HERMITE5 ‚Äì G√©n√©rateur quintique Hermite sur rep√®re interne [-6,6] ====== */
(function(global){
  "use strict";
  const UMINUS = '‚àí';
  const RDEF = {xmin:-6,xmax:6,ymin:-6,ymax:6};
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rchoice(a){ return a[Math.floor(Math.random()*a.length)] }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
  function pickDistinctInt(a,b, forbid=new Set()){
    const pool=[]; for(let x=a;x<=b;x++) if(!forbid.has(x)) pool.push(x);
    return pool.length? rchoice(pool) : a;
  }
  const ZERO = {n:0n, d:1n}; const ONE  = {n:1n, d:1n};
  function rat(n, d=1n){ n=BigInt(n); d=BigInt(d); if(d===0n) throw Error('den=0'); if(d<0n){n=-n; d=-d;}
    const g=(a,b)=>{ a=a<0n?-a:a; b=b<0n?-b:b; while(b){ const t=a%b; a=b; b=t; } return a; };
    const gg=g(n<0n?-n:n, d); return {n:n/gg, d:d/gg};
  }
  function add(a,b){ return rat(a.n*b.d + b.n*a.d, a.d*b.d); }
  function mul(a,b){ return rat(a.n*b.n, a.d*b.d); }
  function div(a,b){ return rat(a.n*b.d, a.d*b.n); }
  function pConst(c){ return [c]; }
  function pAdd(a,b){ const n=Math.max(a.length,b.length); const out=Array.from({length:n},(_,i)=> add(a[i]||ZERO,b[i]||ZERO)); return out; }
  function pScale(a, s){ return a.map(c => mul(c,s)); }
  function pMul(a,b){ const out=Array.from({length:a.length+b.length-1},()=>ZERO);
    for(let i=0;i<a.length;i++) for(let j=0;j<b.length;j++) out[i+j]=add(out[i+j], mul(a[i],b[j]));
    return out;
  }
  function pEval(a, x){ let acc=rat(0n), X=rat(1n); for(let i=0;i<a.length;i++){ acc=add(acc, mul(a[i],X)); X=mul(X,x);} return acc; }
  function pDer(a){ if(a.length<=1) return [rat(0n)]; const out=[]; for(let i=1;i<a.length;i++) out.push( mul(a[i], rat(i,1n)) ); return out; }
  function xMinus(t){ return [rat(-BigInt(t),1n), rat(1n,1n)]; }
  function lagrangeBasis(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    let num = pMul( xMinus(others[0]), xMinus(others[1]) );
    const den = rat( (BigInt(xi)-BigInt(others[0])) * (BigInt(xi)-BigInt(others[1])) , 1n);
    return pScale(num, div(ONE, den));
  }
  function sumInv(xi, nodes){
    const others = nodes.filter(x => x!==xi);
    const t1 = div(ONE, rat(BigInt(xi)-BigInt(others[0]),1n));
    const t2 = div(ONE, rat(BigInt(xi)-BigInt(others[1]),1n));
    return add(t1,t2);
  }
  function hermiteCardinals(xi, nodes){
    const L = lagrangeBasis(xi, nodes);
    const L2 = pMul(L,L);
    const Si = sumInv(xi, nodes);
    const P = pAdd( pConst(ONE), pScale( xMinus(xi), mul(rat(-2n), Si)) );
    const Hi0 = pMul(P, L2);
    const Hi1 = pMul( xMinus(xi), L2 );
    return {Hi0, Hi1};
  }
  function toVH(m){
    if(Number.isInteger(m)) return [m,1];
    const maxH = 7;
    for(let H=1; H<=maxH; H++){
      const V = Math.round(m*H);
      if(Math.abs(m - V/H) < 1e-6) return [V,H];
    }
    return null;
  }
  function buildPoly(a,b,c, m,k,l, n, q_num, q_den){
    const nodes=[a,b,c];
    const H0 = hermiteCardinals(a, nodes);
    const H1 = hermiteCardinals(b, nodes);
    const H2 = hermiteCardinals(c, nodes);
    const term0 = pScale(H0.Hi0, rat(BigInt(m),1n));
    const term1 = pScale(H0.Hi1, rat(0n,1n)); // f'(a)=0
    const term2 = pScale(H1.Hi0, rat(BigInt(k),1n));
    const term3 = pScale(H1.Hi1, rat(BigInt(n),1n));
    const term4 = pScale(H2.Hi0, rat(BigInt(l),1n));
    const term5 = pScale(H2.Hi1, rat(BigInt(q_num), BigInt(q_den)));
    let P = pConst(rat(0n)); [term0,term1,term2,term3,term4,term5].forEach(t => P=pAdd(P,t));
    return P;
  }
  function evalPolyNum(P, x){ let y=0; for(let i=P.length-1;i>=0;i--) y = y*x + (Number(P[i].n)/Number(P[i].d)); return y; }
  function okInView(P, R){
    const steps = Math.round((R.xmax-R.xmin)*50);
    for(let i=0;i<=steps;i++){
      const x = R.xmin + i*(R.xmax-R.xmin)/steps;
      let y=0; for(let j=P.length-1;j>=0;j--) y = y*x + (Number(P[j].n)/Number(P[j].d));
      if(!Number.isFinite(y)) return false;
      if(y<R.ymin-1e-9 || y>R.ymax+1e-9) return false;
    }
    return true;
  }
  function generate(opts={}){
    const R = opts.R || RDEF;             // g√©n√©ration sur [-6,6]
    const MAG  = opts.mag ?? 5;
    const DENM = Math.max(2, opts.denMax ?? 4);
    let tries=0;
    while(tries++<1200){
      let a = pickDistinctInt(R.xmin+1, R.xmax-1);
      let b = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a]));
      let c = pickDistinctInt(R.xmin+1, R.xmax-1, new Set([a,b]));
      [a,b,c] = [a,b,c].sort((u,v)=>u-v);
      let m = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1);
      let k = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1);
      let l = clamp(randInt(-MAG,MAG), R.ymin+1, R.ymax-1);
      if(m===k && k===l) continue;
      const spread = Math.max(Math.abs(m-k), Math.abs(k-l), Math.abs(l-m));
      if(spread < 2) continue;
      let n = rchoice([-3,-2,-1,1,2,3]);
      let H = rchoice([2,3,4,5].filter(h=>h<=DENM));
      let Vcands = [-5,-4,-3,-2,-1,1,2,3,4,5].filter(v=> (v%H)!==0 );
      let V = rchoice(Vcands);
      if(!(c+H<=R.xmax && l+V>=R.ymin && l+V<=R.ymax)) continue;
      const P = buildPoly(a,b,c, m,k,l, n, V, H);
      if(!okInView(P,R)) continue;
      const dP = pDer(P);
      const f  = x => evalPolyNum(P,x);
      const df = x => evalPolyNum(dP,x);
      const A = {x:a, y:m, m:0};
      const B = {x:b, y:k, m:n};
      const C = {x:c, y:l, m:V/H};
      const xs=[];
      const grid=[5,4,4,5];
      const segments=[ [R.xmin, A.x], [A.x, B.x], [B.x, C.x], [C.x, R.xmax] ];
      for(let s=0;s<4;s++){
        const [x0,x1]=segments[s];
        const npts=grid[s];
        for(let i=0;i<npts;i++){
          const t=(i+1)/(npts+1); const x = x0 + t*(x1-x0); const y=f(x);
          xs.push([Math.round(x*1000)/1000, Math.round(y*1000)/1000]);
        }
      }
      return {R, f, df, A, B, C, VH:[V,H], pts20: xs};
    }
    const f=x=>0, df=x=>0;
    return {R:RDEF, f, df, A:{x:-2,y:1,m:0}, B:{x:0,y:0,m:1}, C:{x:3,y:1,m:0.5}, VH:[1,2], pts20:[]};
  }
  global.HERMITE5 = { generate, toVH, RDEF };
})(window);
</script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Premi√®re ‚Äî <strong>Nombres d√©riv√©s & tangentes</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-sol" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <div class="score" id="score">Score : 0 / 0</div>
    </div>

    <div id="host" class="card" data-active="" data-state=""></div>

    <div class="card">
      <h3>Saisie & r√©ponses accept√©es</h3>
      <ul class="small">
	    <li>Attention : Si vous voyez une ligne horizontale rouge : Cliquez sur nouvel √©nonc√©</li>
        <li>Division : saisir en <span class="code">a/b</span> ; puissances : <span class="code">x^2</span> (affichage en <span class="code">x¬≤</span>).</li>
        <li>√âquations de droites : vous pouvez √©crire <span class="code">y = mx + p</span> ou <span class="code">y - y_A = m(x - x_A)</span>. Les formes alg√©briquement √©quivalentes sont accept√©es.</li>
        <li>Le signe <b>‚àí</b> affich√© est le ¬´ grand moins ¬ª (Unicode). La saisie accepte <span class="code">-</span> classique.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>


   
  </div>

<script>
/* =========== Outils g√©n√©riques =========== */

/* ==== Canonisation d'affichage (signes, √ó, doublons) ==== */
const UMINUS = '‚àí'; // (d√©j√† d√©fini chez toi, laiss√© ici pour clart√©)

/* 1) Normalise les suites de signes */
function normalizeSignsStr(s){
  return String(s)
    .replace(/\+\s*‚àí/g, ` ${UMINUS} `)   // "+ ‚àí" -> " ‚àí "
    .replace(/‚àí\s*\+/g, ` ${UMINUS} `)   // "‚àí +" -> " ‚àí "
    .replace(/‚àí\s*‚àí/g, ' + ')            // "‚àí ‚àí" -> " + "
    .replace(/\s+/g, ' ');
}

/* 2) For√ßage des multiplications explicites "√ó" l√† o√π n√©cessaire */

// Remplace TOUTE ancienne version de forceTimesStr par ceci :
function timesNumbersOnly(s){
  s = String(s);

  // 0) Nettoyage : on enl√®ve toute * ou √ó ind√©sirable devant x, ( ... ) non num√©rique, ou ‚àö
  s = s.replace(/(\d)\s*[\*√ó]\s*x\b/g, '$1x');  // 3*x ‚Üí 3x ; 3√óx ‚Üí 3x
  s = s.replace(/(\d)\s*[\*√ó]\s*‚àö/g, '$1‚àö');    // 3*‚àöx ‚Üí 3‚àöx ; 3√ó‚àöx ‚Üí 3‚àöx
  s = s.replace(/(\d)\s*[\*√ó]\s*\(/g, '$1(');   // 3*( ‚Ä¶ ) ‚Üí 3( ‚Ä¶ ) (on r√©-ins√®rera √ó si ( ‚Ä¶ ) est num√©rique)

  // 1) √ó entre nombres s√©par√©s par un espace : "3 4" ‚Üí "3 √ó 4"
  s = s.replace(/(\d)\s+(?=\d)/g, '$1 √ó ');

  // 2) √ó entre nombre et ( ‚Ä¶ ) si le contenu est PUREMENT NUM√âRIQUE
  //    (signes + d√©cimales autoris√©s) : "5(2)" ‚Üí "5 √ó (2)", "3(‚àí3)" ‚Üí "3 √ó (‚àí3)"
  s = s.replace(/(\d)\s*(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))/g, '$1 √ó $2');

  // 3) √ó entre ( ‚Ä¶ ) num√©rique et nombre : "(2)3" ‚Üí "(2) √ó 3"
  s = s.replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*(\d)/g, '$1 √ó $2');

  return s;
}



/* 3) Supprime les r√©p√©titions du type "= 3 = 3" ou "= ‚àí5 = ‚àí5" (anti-doublon inline) */
function dedupInlineEquals(s){
  // nombres entiers/d√©cimaux
  s = s.replace(/=\s*([‚àí\-]?\d+(?:[.,]\d+)?)\s*=\s*\1\b/g, '= $1');
  // cas tr√®s courant : fraction "a/b = a/b" (quand elle n'est pas encore mise en pile)
  s = s.replace(/=\s*([‚àí\-]?\d+\/\d+)\s*=\s*\1\b/g, '= $1');
  return s;
}

/* 4) Post-traitement HTML des blocs d'√©tapes .steps */
function canonMathHTML(html){
  let s = String(html);
  s = timesNumbersOnly(s); // ‚Üê important : ne pas utiliser d'autres "forceTimes"
  s = normalizeSignsStr(s);
  s = dedupInlineEquals(s);
  s = s.replace(/(\d)\s*\*\s*(\d)/g, '$1 √ó $2') // * entre nombres -> √ó
     .replace(/(\d)\s*\*\s*x\b/g, '$1x')
     .replace(/(\d)\s*\*\s*‚àö/g, '$1‚àö')
     .replace(/(\d)\s*\*\s*\(/g, '$1(');

  return s;
}

/* 5) Passe le peigne sur tous les blocs .steps d'un host */
function canonizeAllSteps(host){
  $$('.steps', host).forEach(el => {
    el.innerHTML = canonMathHTML(el.innerHTML);
  });
}


const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const rnd   = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const rchoice = L => L[rnd(0,L.length-1)];
const fmtNum = v => (Math.abs(v)===Infinity? '‚àû' : (Number.isInteger(v)? String(v) : String(Math.round(v*1000)/1000).replace('.',',')));
const normMinus = s => String(s||'').replace(/‚àí/g,'-').trim();

function parseNum(s){
  s = normMinus(String(s).replace(',','.'));
  if(!s) return NaN;
  if(/^\s*ND\s*$/i.test(s)) return NaN;
  if(s.includes('/')){
    const [a,b] = s.split('/').map(x=>parseFloat(x));
    if(!isFinite(a) || !isFinite(b) || b===0) return NaN;
    return a/b;
  }
  return parseFloat(s);
}

function eqNum(a,b,tol=1e-6){
  if(!Number.isFinite(a) || !Number.isFinite(b)) return null; // neutre
  return Math.abs(a-b)<=tol;
}

/* ===== Ticks (neutre cach√©) ===== */
function setTick(el,val){
  if(!el) return;
  if(val===true){  el.textContent='‚úì'; el.classList.add('ok'); el.classList.remove('ko'); el.style.display='inline'; }
  else if(val===false){ el.textContent='‚úï'; el.classList.add('ko'); el.classList.remove('ok'); el.style.display='inline'; }
  else { el.textContent=''; el.classList.remove('ok','ko'); el.style.display='none'; } // neutre cach√©
}

/* =========== Fractions & formats (pile partout) =========== */
function fracHTML(V,H){
  return `<span class="frac"><span class="num">${V}</span><span class="den">${H}</span></span>`;
}

// -> [V,H] r√©duit si possible via HERMITE5.toVH ; sinon entier
// -> [V,H] r√©duit si possible via HERMITE5.toVH ; sinon approx rationnelle (den ‚â§ 24)
function slopeVH(m){
  const vh = (window.HERMITE5 && HERMITE5.toVH) ? HERMITE5.toVH(m) : null;
  if (vh) return vh;                       // cas "classique"
  for (let H = 1; H <= 24; H++){           // fallback : fraction simple
    const V = Math.round(m * H);
    if (Math.abs(m - V/H) < 1e-12) return reduce(V, H);
  }
  return [Math.round(m), 1];               // dernier recours (entier)
}


// V/H en pile (m√™me si 2/1)
function vhHTML(m){ const [V,H]=slopeVH(m); return fracHTML(V,H); }

// f'(a) : entier si H=1, sinon fraction en pile (jamais ‚Äú/1‚Äù)
function fprimeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }
// R√©tro-compat : certains blocs appellent encore fprimeHTML_strict
const fprimeHTML_strict = fprimeHTML;

// Phrase ‚Äúpentes‚Äù : 0 ‚Üí ‚Äú0 (tangente horizontale)‚Äù, entier ‚â†0 ‚Üí ‚Äú(‚àí1/1) = ‚àí1‚Äù, sinon fraction pile
// --- PATCH fprimeForSentence (z√©ro doublon ; entier si /1) ---
function fprimeForSentence(m){
  const [V,H]=slopeVH(m);
  if(V===0) return '0 (tangente horizontale)';
  return (H===1) ? String(V) : fracHTML(V,H);
}


// Affichage g√©n√©rique d‚Äôune pente (pile ou entier)
function fmtSlopeHTML(m){ const [V,H]=slopeVH(m); return (H===1) ? String(V) : fracHTML(V,H); }

/* =========== Parsers stricts (pas de d√©cimales) =========== */
// ‚Äúa/b‚Äù uniquement (existante, conserv√©e)
function parseFracStrict(s){
  s = normMinus(String(s).replace(',','.')).trim();
  if(!/^[+-]?\d+\s*\/\s*[1-9]\d*$/.test(s)) return null;
  const [A,B] = s.split('/').map(t=>parseInt(t.replace(/\s+/g,''),10));
  if(!Number.isFinite(A) || !Number.isFinite(B) || B===0) return null;
  return {a:A, b:B, val:A/B};
}

// entier strict (pas de fraction, pas de d√©cimal)
function parseIntStrict(s){
  s = normMinus(String(s||'').trim());
  if(!/^[+-]?\d+$/.test(s)) return null;
  return parseInt(s,10);
}

// PGCD + r√©duction
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function reduce(n,d){ if(d<0){ n=-n; d=-d; } const g=gcd(n,d); return [n/g,d/g]; }

// entier OU fraction ‚Äúa/b‚Äù ‚Üí [N,D] r√©duit (null sinon)
function parseRatStrict(s){
  s = normMinus(String(s||'').trim());
  if(/^[+-]?\d+$/.test(s)) return [parseInt(s,10),1];
  const fr=parseFracStrict(s);
  return fr ? reduce(fr.a, fr.b) : null;
}
// d√©cimal exact / entier / fraction -> [N,D] r√©duit, sinon null
function parseRatOrDecStrict(s){
  s = normMinus(String(s||'').trim());
  if(!s) return null;

  // entier
  if(/^[+\-]?\d+$/.test(s)) return [parseInt(s,10), 1];

  // fraction a/b
  const fr = parseFracStrict(s);
  if(fr) return reduce(fr.a, fr.b);

  // d√©cimal fini (.,)
  if(/^[+\-]?\d+[.,]\d+$/.test(s)){
    const neg = s.startsWith('-');
    const t = s.replace('+','').replace('-','').replace(',','.');
    const [A,B] = t.split('.');
    const num = parseInt(A + B, 10);
    const den = 10 ** B.length;
    return reduce(neg ? -num : num, den);
  }
  return null;
}

// pour les coefficients devant x : '', '+', '-', '(‚Ä¶)','-(‚Ä¶)', nombres‚Ä¶
function parseCoeff(tok){
  tok = String(tok||'');
  if(tok==='' || tok==='+') return [ 1,1 ];
  if(tok==='-')             return [-1,1 ];

  // signe ext√©rieur possible : '-(1/2)'
  let sign = 1;
  if(tok.startsWith('+(') && tok.endsWith(')')) tok = tok.slice(2,-1);
  else if(tok.startsWith('-(') && tok.endsWith(')')){ sign=-1; tok = tok.slice(2,-1); }

  // enl√®ve des paires de parenth√®ses externes : '(1/2)' -> '1/2'
  while(tok.startsWith('(') && tok.endsWith(')')) tok = tok.slice(1,-1);

  const r = parseRatOrDecStrict(tok);
  return r ? reduce(sign*r[0], r[1]) : null;
}

// remplace l‚Äôancienne slopeOKStrict
function slopeOKStrict(input, expected){
  input = String(input||'').trim();
  if(input==='') return null;                  // champ vide ‚Üí tick neutre

  const rat = parseRatOrDecStrict(input);      // entier, fraction ou d√©cimal exact
  if(!rat) return false;

  const [V,H] = slopeVH(expected);             // valeur attendue (r√©duite)
  const R = reduce(rat[0], rat[1]);            // valeur saisie (r√©duite)
  return (R[0] === V && R[1] === H);
}


/* ====== √âquations de droites ====== */
// parties d‚Äôaffichage : m¬∑x et +p en pile
function mxHTML([V,H]){
  const sgn = V<0 ? '‚àí' : '';
  const A = Math.abs(V);
  if(H===1 && A===1) return `${sgn}x`;
  return `${(H===1)? String(V) : fracHTML(V,H)}x`;
}
function signedRatHTML([N,D]){
  if(N===0) return ' + 0';
  const s = (N<0) ? ' ‚àí ' : ' + ';
  const A = Math.abs(N);
  return s + ((D===1)? String(A) : fracHTML(A,D));
}
// Affiche une rationnelle [N,D] en entier ou fraction pile
function ratHTML([N,D]){
  const R = reduce(N,D);
  return (R[1] === 1) ? String(R[0]) : fracHTML(R[0], R[1]);
}

// √âquation joliment format√©e : pas de ‚Äú+ 0‚Äù / ‚Äú‚àí 0‚Äù, g√®re m = 0 et ¬±x
function eqHTML(mVH, pVH){
  const M = reduce(mVH[0], mVH[1]);
  const P = reduce(pVH[0], pVH[1]);

  // y = p si m = 0
  if (M[0] === 0) return `y = ${ratHTML(P)}`;

  // y = mx (+ p) sinon (sans afficher +0)
  const mx = mxHTML(M);                  // d√©j√† ‚Äú‚àíx‚Äù quand ¬±1
  if (P[0] === 0) return `y = ${mx}`;    // pas de +0

  const sign = (P[0] < 0) ? ' ‚àí ' : ' + ';
  const pAbs = [Math.abs(P[0]), P[1]];
  return `y = ${mx}${sign}${ratHTML(pAbs)}`;
}

// p = y - (V/H) x  en fraction r√©duite
function pFromPoint(V,H,x,y){ return reduce(y*H - V*x, H); }

// outils d‚Äôaffichage/ratios d√©j√† pr√©sents :
/* gcd, reduce, slopeVH, parseRatOrDecStrict, mxHTML, signedRatHTML, pFromPoint */

// remplace l‚Äôancienne lineOKStrict
function lineOKStrict(expr, mVH, pVH){
  expr = normMinus(String(expr||'')).replace(/\s+/g,'');
  if(!expr || !expr.startsWith('y=')) return false;
  const rhs = expr.slice(2);

  // motif commun pour un coefficient devant x : vide / signe / nombre (avec () possibles)
  const COEF_RE = '([+\\-]?(?:\\(?\\d+(?:\\/[1-9]\\d*)?\\)?|\\(?\\d+(?:[.,]\\d+)?\\)?)*?)';
  const RAT_RE  = '([+\\-]?(?:\\d+(?:\\/[1-9]\\d*)?|\\d+(?:[.,]\\d+)?))';

  let m=null, p=null;

  // 0) y = p (constante)
  let m0 = rhs.match(new RegExp('^'+RAT_RE+'$'));
  if(m0){ m=[0,1]; p=parseRatOrDecStrict(m0[1]); }

  // 1) y = m x + p    (m peut √™tre '', '+', '-', '1/2', '(1/2)', '-(1/2)', etc.)
  if(!m || !p){
    let m1 = rhs.match(new RegExp('^'+COEF_RE+'x([+\\-])'+RAT_RE+'$'));
    if(m1){
      const mTok=m1[1], sign=m1[2], pTok=m1[3];
      m = parseCoeff(mTok);
      p = parseRatOrDecStrict((sign==='-'?'-':'')+pTok);
    }
  }

  // 2) y = p + m x
  if(!m || !p){
    let m2 = rhs.match(new RegExp('^'+RAT_RE+'([+\\-])'+COEF_RE+'x$'));
    if(m2){
      const pTok=m2[1], sign=m2[2], mTok=m2[3];
      p = parseRatOrDecStrict(pTok);
      m = parseCoeff((sign==='-'?'-':'')+mTok);
    }
  }

  // 3) y = m(x ¬± a) ¬± yA  (a,yA entiers ; m rationnel/entier/d√©cimal exact)
  if(!m || !p){
    let m3 = rhs.match(new RegExp('^'+COEF_RE+'\\((?:x)([+\\-])(\\d+)\\)([+\\-])(\\d+)$'));
    if(m3){
      const mTok=m3[1], s1=m3[2], aTok=m3[3], s2=m3[4], yATok=m3[5];
      const mRat = parseCoeff(mTok); if(!mRat) return false;
      const a = parseInt(aTok,10), yA = parseInt(yATok,10);
      if(!Number.isInteger(a) || !Number.isInteger(yA)) return false;
      const aEff  = (s1==='-') ? a : -a;           // x - a  / x + a
      const yEff  = (s2==='-') ? -yA :  yA;        // + yA / - yA
      // y = m x + (yEff - m*aEff)
      const pRat = reduce(yEff*mRat[1] - mRat[0]*aEff, mRat[1]);
      m = mRat; p = pRat;
    }
  }

  if(!m || !p) return false;

  // comparaison rationnelle exacte
  const M   = reduce(m[0], m[1]);
  const P   = reduce(p[0], p[1]);
  const Mxp = reduce(mVH[0], mVH[1]);
  const Pxp = reduce(pVH[0], pVH[1]);
  return (M[0]===Mxp[0] && M[1]===Mxp[1] && P[0]===Pxp[0] && P[1]===Pxp[1]);
}



/* ====== V√©rif ‚Äúsouple‚Äù (utile pour d‚Äôautres exos si tu veux la garder) ====== */
function parseUserLine(expr){
  expr = normMinus(expr).replace(/\s+/g,'');
  if(!expr) return null;
  let rhs = expr.startsWith('y=') ? expr.slice(2) : expr;
  rhs = rhs.replace(/\^/g,'**');
  try{
    const f = new Function('x','return ('+rhs+');');
    return (x)=> f(x);
  }catch(e){ return null; }
}
function isSameLine(userExpr, m, p){
  const f=parseUserLine(userExpr); if(!f) return false;
  const xs=[-5,-3,-1,0,2,4];
  try{
    return xs.every(x=>{
      const yu=f(x);
      const y=m*x+p;
      return isFinite(yu) && Math.abs(yu - y) <= 1e-3;
    });
  }catch(e){ return false; }
}

/* =========== Rep√®re (SVG) =========== */
/* =========== Rep√®re (SVG) =========== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.el=this._makeSVG();
    this.gGrid=this.el.querySelector('g[data-layer="grid"]');
    this.gAxes=this.el.querySelector('g[data-layer="axes"]');
    this.gGeom=this.el.querySelector('g[data-layer="geom"]');
    this.gUser=this.el.querySelector('g[data-layer="user"]');
    this._labelRects = [];               // m√©moires des bbox des labels pos√©s
    this.redraw();
  }
  _makeSVG(){
    const s=document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
    const layers=['grid','axes','geom','user'];
    layers.forEach(L=>{
      const g=document.createElementNS(s.namespaceURI,'g'); g.dataset.layer=L; s.appendChild(g);
    });
    return s;
  }
  coordToScreen(x,y){
    const R=this.R, w=420, h=420;
    const X=(x-R.xmin)/(R.xmax-R.xmin)*w;
    const Y=h-(y-R.ymin)/(R.ymax-R.ymin)*h;
    return {x:X,y:Y};
  }
  screenToCoord(X,Y){
    const R=this.R, w=420, h=420;
    const x=R.xmin + X/w*(R.xmax-R.xmin);
    const y=R.ymin + (h-Y)/h*(R.ymax-R.ymin);
    return {x,y};
  }
  redraw(){
    const R=this.R;
    const w=420,h=420;
    this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gGeom.innerHTML=''; this.gUser.innerHTML='';
    this._labelRects = []; // reset anti-collisions

    // grille
    const mkLine=(x1,y1,x2,y2,thick=false)=>{
      const L=document.createElementNS(this.el.namespaceURI,'line');
      L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2);
      L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); L.setAttribute('opacity',thick?1:.35);
      return L;
    };
    for(let t=R.xmin;t<=R.xmax;t++){
      const P1=this.coordToScreen(t,R.ymin), P2=this.coordToScreen(t,R.ymax);
      this.gGrid.appendChild(mkLine(P1.x,P1.y,P2.x,P2.y));
    }
    for(let t=R.ymin;t<=R.ymax;t++){
      const P1=this.coordToScreen(R.xmin,t), P2=this.coordToScreen(R.xmax,t);
      this.gGrid.appendChild(mkLine(P1.x,P1.y,P2.x,P2.y));
    }
    // axes
    const A1=this.coordToScreen(R.xmin,0), A2=this.coordToScreen(R.xmax,0);
    const B1=this.coordToScreen(0,R.ymin), B2=this.coordToScreen(0,R.ymax);
    this.gAxes.appendChild(mkLine(A1.x,A1.y,A2.x,A2.y,true));
    this.gAxes.appendChild(mkLine(B1.x,B1.y,B2.x,B2.y,true));

    // O, I, J
    const mkPt=(x,y)=>{
      const g=document.createElementNS(this.el.namespaceURI,'g');
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','4'); c.setAttribute('fill','#000');
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','12'); t.setAttribute('fill','#000'); t.setAttribute('dominant-baseline','central');
      const P=this.coordToScreen(x,y); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
      g.appendChild(c); g.appendChild(t);
      return {g,c,t,P};
    };
    const O=mkPt(0,0);  O.t.textContent='O'; this.gAxes.appendChild(O.g);
    const I=mkPt(1,0);  I.t.textContent='I'; this.gAxes.appendChild(I.g);
    const J=mkPt(0,1);  J.t.textContent='J'; this.gAxes.appendChild(J.g);

    // placement O/I/J avec anti-collision
    this._placeLabel(O.t, O.P.x, O.P.y);
    this._placeLabel(I.t, I.P.x, I.P.y);
    this._placeLabel(J.t, J.P.x, J.P.y);

    /* === Graduations === */
    const TICK=6, u = s=>String(s).replace(/-/g,UMINUS);
    const P0=this.coordToScreen(0,0);

    // graduations axe X
    if (R.ymin <= 0 && 0 <= R.ymax){
      const Y0 = P0.y;
      for (let t=Math.ceil(R.xmin); t<=Math.floor(R.xmax); t++){
        const Px = this.coordToScreen(t,0).x;
        const tick=document.createElementNS(this.el.namespaceURI,'line');
        tick.setAttribute('x1',Px); tick.setAttribute('x2',Px);
        tick.setAttribute('y1',Y0-TICK); tick.setAttribute('y2',Y0+TICK);
        tick.setAttribute('stroke','#000'); tick.setAttribute('stroke-width','1.2');
        this.gAxes.appendChild(tick);
        if(t!==0){
          const lab=document.createElementNS(this.el.namespaceURI,'text');
          lab.setAttribute('x',Px);
          const yOff = (Y0 > h - 18) ? -12 : 10;
          lab.setAttribute('y',Y0 + yOff);
          lab.setAttribute('font-size','12'); lab.setAttribute('fill','#333');
          lab.setAttribute('text-anchor','middle');
          if(yOff>0) lab.setAttribute('dominant-baseline','hanging');
          lab.textContent = u(t);
          this.gAxes.appendChild(lab);
          this._registerLabel(lab);
        }
      }
    }
    // graduations axe Y
    if (R.xmin <= 0 && 0 <= R.xmax){
      const X0 = P0.x;
      for (let t=Math.ceil(R.ymin); t<=Math.floor(R.ymax); t++){
        const Py = this.coordToScreen(0,t).y;
        const tick=document.createElementNS(this.el.namespaceURI,'line');
        tick.setAttribute('y1',Py); tick.setAttribute('y2',Py);
        tick.setAttribute('x1',X0-TICK); tick.setAttribute('x2',X0+TICK);
        tick.setAttribute('stroke','#000'); tick.setAttribute('stroke-width','1.2');
        this.gAxes.appendChild(tick);
        if(t!==0){
          const lab=document.createElementNS(this.el.namespaceURI,'text');
          const xOff = (X0 < 18) ? 10 : -8;
          lab.setAttribute('x',X0 + xOff);
          lab.setAttribute('y',Py);
          lab.setAttribute('font-size','12'); lab.setAttribute('fill','#333');
          lab.setAttribute('text-anchor', xOff < 0 ? 'end' : 'start');
          lab.setAttribute('dominant-baseline','central');
          lab.textContent = u(t);
          this.gAxes.appendChild(lab);
          this._registerLabel(lab);
        }
      }
    }
  }
  drawCurve(fn,color='#c62828',thick=2){
    const path=document.createElementNS(this.el.namespaceURI,'path');
    const N=300; const R=this.R; let d='M';
    for(let i=0;i<=N;i++){
      const x=R.xmin + i/N*(R.xmax-R.xmin);
      const y=fn(x);
      const P=this.coordToScreen(x,y);
      d += (i===0? '':' L') + P.x.toFixed(2)+','+P.y.toFixed(2);
    }
    path.setAttribute('d',d); path.setAttribute('fill','none'); path.setAttribute('stroke',color); path.setAttribute('stroke-width',thick);
    this.gGeom.appendChild(path);
  }
  drawPoint(label,x,y,color='#c62828'){
    const g=document.createElementNS(this.el.namespaceURI,'g');
    const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
    const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','12'); t.setAttribute('fill',color); t.setAttribute('font-weight','700');
    const P=this.coordToScreen(x,y); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y);
    t.textContent=label;
    g.appendChild(c); g.appendChild(t); this.gGeom.appendChild(g);
    this._placeLabel(t, P.x, P.y); // anti-collision pour le label
  }
  drawLineThroughPointSlope(x0,y0,m,color='#1565c0',dash=true){
    const x1=this.R.xmin, y1=m*(x1-x0)+y0;
    const x2=this.R.xmax, y2=m*(x2-x0)+y0;
    const a=this.coordToScreen(x1,y1), b=this.coordToScreen(x2,y2);
    const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','2');
    if(dash) L.setAttribute('stroke-dasharray','6 6');
    this.gGeom.appendChild(L);
  }

  // ----- anti-collision labels -----
  _registerLabel(textEl){
    try{
      const bb = textEl.getBBox();
      this._labelRects.push({x:bb.x, y:bb.y, w:bb.width, h:bb.height});
    }catch(e){}
  }
  _rectsIntersect(a,b){
    return !( b.x > a.x+a.w || b.x+b.w < a.x || b.y > a.y+a.h || b.y+b.h < a.y );
  }
  _placeLabel(textEl, px, py){
    const W=420, H=420;
    const cand = [
      {dx:  6, dy:-10, anchor:'start', baseline:'auto'},     // NE
      {dx: -6, dy:-10, anchor:'end',   baseline:'auto'},     // NO
      {dx: -8, dy: 12, anchor:'end',   baseline:'hanging'},  // SO
      {dx:  8, dy: 12, anchor:'start', baseline:'hanging'},  // SE
      {dx: 12, dy:  0, anchor:'start', baseline:'central'},  // Est
      {dx:-12, dy:  0, anchor:'end',   baseline:'central'}   // Ouest
    ];
    for(let s=1; s<=3; s++){
      for(const c of cand){
        textEl.setAttribute('text-anchor', c.anchor);
        textEl.setAttribute('dominant-baseline', c.baseline);
        textEl.setAttribute('x', px + c.dx*s);
        textEl.setAttribute('y', py + c.dy*s);
        let bb;
        try{ bb = textEl.getBBox(); }catch(e){ continue; }
        const rect = {x:bb.x, y:bb.y, w:bb.width, h:bb.height};
        if(rect.x<0 || rect.y<0 || rect.x+rect.w>W || rect.y+rect.h>H) continue;
        const collide = this._labelRects.some(r => this._rectsIntersect(r, rect));
        if(!collide){ this._labelRects.push(rect); return; }
      }
    }
    // fallback
    textEl.setAttribute('text-anchor','start');
    textEl.setAttribute('dominant-baseline','auto');
    textEl.setAttribute('x', px + 6);
    textEl.setAttribute('y', py - 10);
    this._registerLabel(textEl);
  }
}


/* ================== Courbe C¬π par Hermite + utilitaires ================== */
function hermiteSeg(x0,y0,m0,x1,y1,m1){
  const dx = x1 - x0;
  return {
    f(x){
      const t = (x - x0)/dx;
      const h00 =  2*t*t*t - 3*t*t + 1;
      const h10 =    t*t*t - 2*t*t + t;
      const h01 = -2*t*t*t + 3*t*t;
      const h11 =    t*t*t -   t*t;
      return h00*y0 + h10*dx*m0 + h01*y1 + h11*dx*m1;
    },
    df(x){
      const t = (x - x0)/dx;
      const dh00 =  6*t*t - 6*t;
      const dh10 =  3*t*t - 4*t + 1;
      const dh01 = -6*t*t + 6*t;
      const dh11 =  3*t*t - 2*t;
      return (dh00*y0 + dh10*dx*m0 + dh01*y1 + dh11*dx*m1)/dx;
    }
  };
}

/* Courbe C¬π par morceaux avec ‚Äúcaps‚Äù doux aux extr√©mit√©s */
function makePiecewiseHermite(P){
  P=[...P].sort((a,b)=>a.x-b.x);
  const segsCore=[];
  for(let i=0;i<P.length-1;i++){
    const s=hermiteSeg(P[i].x,P[i].y,P[i].m, P[i+1].x,P[i+1].y,P[i+1].m);
    segsCore.push({x0:P[i].x,x1:P[i+1].x, f:s.f, df:s.df});
  }
  function evalHerm(x){
    for(const s of segsCore) if(x>=s.x0 && x<=s.x1) return s.f(x);
    if(x<=P[0].x)    return P[0].y  + P[0].m  * (x-P[0].x);
    if(x>=P.at(-1).x) return P.at(-1).y + P.at(-1).m * (x-P.at(-1).x);
  }

  const left=P[0], next=P[1], right=P.at(-1), prev=P.at(-2);
  const wL = Math.min(1.4, Math.max(0.6, 0.45*Math.abs(next.x-left.x)));
  const wR = Math.min(1.4, Math.max(0.6, 0.45*Math.abs(right.x-prev.x)));
  const xL = left.x+wL, xR = right.x-wR;

  const bump    = t => { const t2=t*t, u=1-t2; return t2*u*u; };
  const dbumpdt = t => { const t2=t*t; return 2*t*(1-t2)*(1-3*t2); };

  const epsL = Math.min(0.2, 0.2*wL), epsR = Math.min(0.2, 0.2*wR);
  const yLineL = x => left.y  + left.m  * (x-left.x);
  const yLineR = x => right.y + right.m * (x-right.x);
  const signL = Math.sign( evalHerm(xL+epsL) - yLineL(xL+epsL) ) || (left.m>=0?1:-1);
  const signR = Math.sign( evalHerm(xR-epsR) - yLineR(xR-epsR) ) || (right.m>=0?1:-1);
  const AL = 3.4*wL*wL, AR = 3.4*wR*wR;

  function fCapLeft(x){  const t=(x-left.x)/wL;  return yLineL(x) + signL*AL*bump(t); }
  function dfCapLeft(x){ const t=(x-left.x)/wL;  return left.m + signL*AL*dbumpdt(t)*(1/wL); }
  function fCapRight(x){ const t=(right.x-x)/wR; return yLineR(x) + signR*AR*bump(t); }
  function dfCapRight(x){const t=(right.x-x)/wR; return right.m - signR*AR*dbumpdt(t)*(1/wR); }

  const guardL = {x:xL, y:yLineL(xL), m:left.m};
  const guardR = {x:xR, y:yLineR(xR), m:right.m};
  const Q=[guardL, ...P.slice(1,-1), guardR];
  const segs=[];
  for(let i=0;i<Q.length-1;i++){
    const s=hermiteSeg(Q[i].x,Q[i].y,Q[i].m, Q[i+1].x,Q[i+1].y,Q[i+1].m);
    segs.push({x0:Q[i].x,x1:Q[i+1].x, f:s.f, df:s.df});
  }

  const f=(x)=>{
    if(x<=left.x) return yLineL(x);
    if(x<xL) return fCapLeft(x);
    if(x>xR && x<right.x) return fCapRight(x);
    if(x>=right.x) return yLineR(x);
    for(const s of segs) if(x>=s.x0 && x<=s.x1) return s.f(x);
  };
  const df=(x)=>{
    if(x<=left.x) return left.m;
    if(x<xL) return dfCapLeft(x);
    if(x>xR && x<right.x) return dfCapRight(x);
    if(x>=right.x) return right.m;
    for(const s of segs) if(x>=s.x0 && x<=s.x1) return s.df(x);
  };
  return {f,df};
}
/* === UI helpers : conteneur avec/sans rep√®re √† droite pour l‚Äô√©nonc√© === */
function renderWithRepere(host, R){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row';
  const left  = document.createElement('div');
  const right = document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);

  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  left.appendChild(rep.el);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {rep,left,right,equ,actions,res};
}

function renderNoRepere(host){
  host.innerHTML = '';
  const row   = document.createElement('div'); row.className = 'row norepere';
  const right = document.createElement('div');
  row.appendChild(right); host.appendChild(row);

  const equ     = document.createElement('div'); equ.className = 'equ'; right.appendChild(equ);
  const actions = document.createElement('div'); actions.className = 'optionline'; right.appendChild(actions);
  const res     = document.createElement('div'); res.id = 'res'; right.appendChild(res);

  return {left:null,right,equ,actions,res};
}



/* ======= BANQUE DE COURBES "PROPRES" =======
   - 3 points cl√©s P=[A,B,C] avec pentes impos√©es (B = extremum : m=0).
   - pentes: une enti√®re, une fraction simple (1/2, 2/3, ‚àí1/2, ...).
   - Abscisses et ordonn√©es enti√®res (lisibles), abscisse du point "fraction"
     multiple du d√©nominateur ‚Üí p entiers si besoin.
   - La forme finale est obtenue par makePiecewiseHermite (douce). */
const CURVE_BANK = [
  //        A(x,y,m)            B(x,y,0)             C(x,y,m)
  { id:'K1', P:[{x:-4,y: 0,m: 1   }, {x:-1,y: 2,m:0}, {x: 2,y:-1,m: 1/2 }]},
  { id:'K2', P:[{x:-3,y: 2,m:-1   }, {x: 0,y:-1,m:0}, {x: 3,y:  2,m: 2/3 }]},
  { id:'K3', P:[{x:-5,y: 2,m: 2   }, {x:-2,y: 4,m:0}, {x: 2,y:  1,m:-1/2 }]},
  { id:'K4', P:[{x:-4,y: 1,m: 1   }, {x: 0,y: 3,m:0}, {x: 3,y:  1,m:-2/3 }]},
  { id:'K5', P:[{x:-6,y: 0,m: 2/3 }, {x:-3,y: 2,m:0}, {x: 3,y:  1,m:-1   }]},
  { id:'K6', P:[{x:-4,y: 2,m:-2   }, {x:-1,y: 3,m:0}, {x: 2,y:  0,m: 1/2 }]},
];

/* sym√©tries / translations enti√®res (sx,sy ‚àà {+1,‚àí1}) */
function transformPoints(P, {tx=0, ty=0, sx=1, sy=1}={}){
  return P.map(p=>({x:sx*(p.x)+tx, y:sy*(p.y)+ty, m:sy/sx * p.m}));
}

/* points int√©rieurs d'un intervalle ouvert (sans extr√©mit√©s) */
function sampleOpen(a,b,n){
  const out=[]; if(n<=0) return out;
  for(let i=1;i<=n;i++){ const t=i/(n+1); out.push(a*(1-t)+b*t); }
  return out;
}

/* 5 points avant A, puis A, points, B, points, C, puis 5 points apr√®s C */
function samplePointsABC(f, A, B, C, R, cfg={left:5, mAB:4, mBC:4, right:5}){
  const L=[];
  // avant A (sans inclure A)
  for(const x of sampleOpen(R.xmin, A.x, cfg.left)) L.push({x, y:f(x)});
  // A
  L.push({x:A.x, y:f(A.x)});
  // entre A et B (ouvert)
  for(const x of sampleOpen(A.x, B.x, cfg.mAB)) L.push({x, y:f(x)});
  // B
  L.push({x:B.x, y:f(B.x)});
  // entre B et C (ouvert)
  for(const x of sampleOpen(B.x, C.x, cfg.mBC)) L.push({x, y:f(x)});
  // C
  L.push({x:C.x, y:f(C.x)});
  // apr√®s C (sans inclure C)
  for(const x of sampleOpen(C.x, R.xmax, cfg.right)) L.push({x, y:f(x)});
  return L;
}


function instantiateBankCurve(bankItem, R, opt={}){
  const P = transformPoints(bankItem.P, opt).sort((a,b)=>a.x-b.x);
  const {f,df} = makePiecewiseHermite(P);
  // 5 ‚Äì A ‚Äì (AB) ‚Äì B ‚Äì (BC) ‚Äì C ‚Äì 5
  const pts20 = samplePointsABC(f, P[0], P[1], P[2], R, {left:5, mAB:4, mBC:4, right:5});
  return {P,f,df,pts20};
}


/* contr√¥le "lecture depuis le point" + points dans le cadre */
function slopesReadableInFrame(P, R){
  const okInt=(x,y,k)=> (x+1<=R.xmax && y+k>=R.ymin && y+k<=R.ymax);
  const okFrac=(x,y,q)=>{ const vh=toVH(q); if(!vh) return false; const [V,H]=vh;
                          return (x+H<=R.xmax && y+V>=R.ymin && y+V<=R.ymax); };
  const inBox = P.every(p=>p.x>=R.xmin && p.x<=R.xmax && p.y>=R.ymin && p.y<=R.ymax);
  const A=P[0], B=P[1], C=P[2];
  const okA = toVH(A.m)? okFrac(A.x,A.y,A.m) : okInt(A.x,A.y,A.m);
  const okC = toVH(C.m)? okFrac(C.x,C.y,C.m) : okInt(C.x,C.y,C.m);
  return inBox && okA && okC && (B.m===0);
}

/* petite v√©rification "vraie tangence" : pas de recoupement imm√©diat */
function tangentDoesNotCrossNear(f, P, R, side='both'){
  const h=0.6; const line=x=>P.y + P.m*(x-P.x);
  let arr=[];
  if(side!=='right' && P.x-h>=R.xmin) arr.push( Math.sign(f(P.x-h)-line(P.x-h)) );
  if(side!=='left'  && P.x+h<=R.xmax) arr.push( Math.sign(f(P.x+h)-line(P.x+h)) );
  arr=arr.filter(s=>s!==0);
  return arr.length>=1 && arr.every(s=>s===arr[0]);
}




/* tirage de 3 entiers distincts lisibles */
function pick3DistinctInts(pool=[-5,-4,-3,-2,-1,0,1,2,3,4,5]){
  const P=[...pool], xs=[];
  while(xs.length<3) xs.push(P.splice(rnd(0,P.length-1),1)[0]);
  return xs.sort((a,b)=>a-b);
}



function fmtSlopeHTML(m){ const vh=toVH(m); return vh? fracHTML(vh[0],vh[1]) : fmtNum(m); }

/* === Inputs & ticks helpers (globaux) === */
function mkInput(id, w=120, ph=''){
  return `<input id="${id}" style="width:${w}px" autocomplete="off" inputmode="text" placeholder="${ph}">`;
}
function setVal(host,id,val){
  // ne pas auto-remplir pendant l'affichage de la solution
  if(host && host._noFillSolution) return;
  const el = host.querySelector('#'+id);
  if(el) el.value = val;
}
function getVal(host,id){
  const el = host.querySelector('#'+id);
  return el ? String(el.value||'').trim() : '';
}


/* ================== Exercices ================== */
function makeExos(){
  const L=[];

  /* ===== Ex. 1 ‚Äî Lire f'(a) sur la courbe ===== */
  L.push({
    id:'ex1_deriv_graph',
    title:"Ex. 1 ‚Äî Lire f'(a) sur la courbe",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  return {R:RVIS, f:g.f, df:g.df, pts:[g.A,g.B,g.C], pts20:g.pts20};
},

    render(host, st){
      const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
      const ui=renderWithRepere(host, s.R);
      ui.rep.drawCurve(s.f,'#e53935',2.5);
      const labels=['A','B','C'];
      s.pts.forEach((P,i)=>{
        ui.rep.drawPoint(labels[i], P.x, P.y, '#1565c0');
        ui.rep.drawLineThroughPointSlope(P.x, P.y, P.m, '#1565c0', true);
      });
      // ordre al√©atoire des trois demandes
const idx=[0,1,2]; idx.sort(()=>Math.random()-0.5);
ui.equ.innerHTML = `
  <p>La courbe de la fonction <b>f</b> est trac√©e en rouge.</p>
  <p>Les droites bleues sont les tangentes en <b>A</b>, <b>B</b> et <b>C</b>.</p>
  <p>f'(${fmtNum(s.pts[idx[0]].x)}) = ${mkInput('d1',80)} <span id="t1" class="tick">‚Äî</span></p>
  <p>f'(${fmtNum(s.pts[idx[1]].x)}) = ${mkInput('d2',80)} <span id="t2" class="tick">‚Äî</span></p>
  <p>f'(${fmtNum(s.pts[idx[2]].x)}) = ${mkInput('d3',80)} <span id="t3" class="tick">‚Äî</span></p>
  <div class="steps" id="steps"></div>
`;
// stocke l'ordre pour la v√©rif
s._order = idx;

      ui.actions.innerHTML='';
      host._state=s; host._ui=ui;
    },
verify(host){
  const s=host._state;
  const idx = s._order || [0,1,2];

  const a1 = slopeOKStrict(getVal(host,'d1'), s.pts[idx[0]].m);
  const a2 = slopeOKStrict(getVal(host,'d2'), s.pts[idx[1]].m);
  const a3 = slopeOKStrict(getVal(host,'d3'), s.pts[idx[2]].m);

  setTick($('#t1',host), a1); setTick($('#t2',host), a2); setTick($('#t3',host), a3);

  const allFilled = [a1,a2,a3].every(x => x !== null);
  return allFilled && (a1===true && a2===true && a3===true);
},

    solution(host){
  const {pts} = host._state;                 // A,B,C
  const steps = $('#steps', host);
  const order = (host._state._order && Array.isArray(host._state._order))
                ? host._state._order : [0,1,2];    // m√™me ordre que les questions
  const labs = ['A','B','C'];
  const VHlabel = `<span class="frac"><span class="num">V</span><span class="den">H</span></span>`;

  const html = order.map(k=>{
    const P = pts[k];
    const horiz = Math.abs(P.m) < 1e-12;
    const xTxt = fmtNum(P.x);
    const pente = horiz ? '0' : `${VHlabel} = ${vhHTML(P.m)}`;   // V/H en pile
    const fp = horiz ? '0' : fprimeHTML(P.m);                    // entier si H=1

    return `<div class="step">
      <b>${labs[k]}(${xTxt}; f(${xTxt}))</b> et pente : ${pente}
      donc f'(${xTxt}) = ${fp}${horiz ? ' (tangente horizontale)' : ''}
    </div>`;
  }).join('');

  steps.innerHTML = html;
}




  });

  /* ===== Ex. 2 ‚Äî Tangentes & lectures ===== */
  L.push({
    id:'ex2_tangentes_triple',
    title:"Ex. 2 ‚Äî Nombre d√©riv√© et tangentes (A, B, D)",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  const A=g.A, B=g.B, D=g.C;
  const T1={m:A.m, p:A.y - A.m*A.x};
  const T2={m:B.m, p:B.y - B.m*B.x};
  const T3={m:D.m, p:D.y - D.m*D.x};
  const vh = HERMITE5.toVH(D.m) || [Math.round(D.m),1];
  let E = { x: D.x + vh[1], y: D.y + vh[0] };
  if(E.x>RVIS.xmax || E.x<RVIS.xmin || E.y>RVIS.ymax || E.y<RVIS.ymin){ 
    E = { x: D.x - vh[1], y: D.y - vh[0] }; 
  }
  return {R:RVIS, f:g.f, A,B,D, T1,T2,T3, E, pts20:g.pts20};
},
    render(host, st){
  const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
  const ui=renderWithRepere(host, s.R);
  ui.rep.drawCurve(s.f,'#e53935',2.5);
  ui.rep.drawPoint('A',s.A.x,s.A.y,'#e53935');
  ui.rep.drawPoint('B',s.B.x,s.B.y,'#e53935');
  ui.rep.drawPoint('D',s.D.x,s.D.y,'#e53935');
  ui.rep.drawLineThroughPointSlope(s.A.x,s.A.y,s.A.m,'#2e7d32',true);
  ui.rep.drawLineThroughPointSlope(s.B.x,s.B.y,s.B.m,'#2e7d32',true);
  ui.rep.drawLineThroughPointSlope(s.D.x,s.D.y,s.D.m,'#2e7d32',true);
  ui.rep.drawPoint('E',s.E.x,s.E.y,'#1565c0');

  // ordre al√©atoire pour images & d√©riv√©es (A,B,D ~ 0,1,2)
  const orderVals=[0,1,2].sort(()=>Math.random()-0.5);
  const orderDer =[0,1,2].sort(()=>Math.random()-0.5);
  const P=[s.A,s.B,s.D], LAB=['A','B','D'];
  const valRow = orderVals.map(k=>`f(${fmtNum(P[k].x)}) = ${mkInput('f'+LAB[k],80)} <span id="tf${LAB[k]}" class="tick"></span>`).join(' ; ');
  const derRow = orderDer .map(k=>`f'(${fmtNum(P[k].x)}) = ${mkInput('df'+LAB[k],80)} <span id="tdf${LAB[k]}" class="tick"></span>`).join(' ; ');

  ui.equ.innerHTML = `
    <p>Soit une fonction <b>f</b>. Les droites <b>T‚ÇÅ</b>, <b>T‚ÇÇ</b> et <b>T‚ÇÉ</b> (en vert) sont les tangentes √† <b>C<sub>f</sub></b> aux points <b>A</b>, <b>B</b> et <b>D</b>.</p>
    <p>Le point <b>E(${fmtNum(s.E.x)} ; ${fmtNum(s.E.y)})</b> est choisi de sorte que <b>(DE)</b> soit la tangente √† <b>C<sub>f</sub></b> au point <b>D</b>.</p>
    <ol>
      <li>D√©terminer : ${valRow}.</li>
      <li>D√©terminer : ${derRow}.</li>
      <li>Donner une √©quation des tangentes :<br>
        T‚ÇÅ : ${mkInput('t1',220,'y = ...')} <span id="tt1" class="tick"></span><br>
        T‚ÇÇ : ${mkInput('t2',220,'y = ...')} <span id="tt2" class="tick"></span><br>
        T‚ÇÉ : ${mkInput('t3',220,'y = ...')} <span id="tt3" class="tick"></span>
      </li>
    </ol>
    <div class="steps" id="steps2"></div>
  `;

  // m√©morise l‚Äôordre pour la solution
  host._state = {...s, _orderVals:orderVals, _orderDer:orderDer};
  host._ui=ui;
},

    // --- Exercice 2 : remplace la m√©thode verify(host) par ceci
verify(host){
  const s = host._state;
  const P = { A: s.A, B: s.B, D: s.D };

  // helpers locaux : renvoient true / false / null (si vide)
  const checkInt = (id, expected, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const v = parseIntStrict(raw);
    const ok = (v !== null && v === expected);
    setTick($(tickSel,host), ok);
    return ok;
    };

  const checkSlope = (id, expected, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const ok = slopeOKStrict(raw, expected);  // d√©j√† strict + neutre g√©r√© dedans si besoin
    setTick($(tickSel,host), ok);
    return ok;
  };

  const checkLine = (id, mVH, pVH, tickSel) => {
    const raw = getVal(host, id);
    if(raw.trim()===''){ setTick($(tickSel,host), null); return null; }
    const ok = lineOKStrict(raw, mVH, pVH);   // strict : pas de d√©cimales
    setTick($(tickSel,host), ok);
    return ok;
  };

  // --- Valeurs (entiers stricts)
  const r = [];
  r.push( checkInt('fA', P.A.y, '#tfA') );
  r.push( checkInt('fB', P.B.y, '#tfB') );
  r.push( checkInt('fD', P.D.y, '#tfD') );

  // --- D√©riv√©es (entier ou fraction pile r√©duite ; jamais de d√©cimal)
  r.push( checkSlope('dfA', P.A.m, '#tdfA') );
  r.push( checkSlope('dfB', P.B.m, '#tdfB') );
  r.push( checkSlope('dfD', P.D.m, '#tdfD') );

  // --- √âquations (strictes, en forme exacte)
  const mA = slopeVH(P.A.m), pA = pFromPoint(...mA, P.A.x, P.A.y);
  const mB = slopeVH(P.B.m), pB = pFromPoint(...mB, P.B.x, P.B.y);
  const mD = slopeVH(P.D.m), pD = pFromPoint(...mD, P.D.x, P.D.y);

  r.push( checkLine('t1', mA, pA, '#tt1') );
  r.push( checkLine('t2', mB, pB, '#tt2') );
  r.push( checkLine('t3', mD, pD, '#tt3') );

  // true seulement si TOUT est rempli et correct
  return r.every(v => v === true);
},


    solution(host){
  const s=host._state, st=$('#steps2',host);
  const P=[s.A,s.B,s.D], LAB=['A','B','D'];

  // 1) Pr√©-remplissage des inputs (en forme exacte)
  setVal(host,'fA',s.A.y); setVal(host,'fB',s.B.y); setVal(host,'fD',s.D.y);
  setVal(host,'dfA', fprimeHTML_strict(s.A.m));
  setVal(host,'dfB', fprimeHTML_strict(s.B.m));
  setVal(host,'dfD', fprimeHTML_strict(s.D.m));

  const mA=slopeVH(s.A.m), pA=pFromPoint(...mA, s.A.x, s.A.y);
const mB=slopeVH(s.B.m), pB=pFromPoint(...mB, s.B.x, s.B.y);
const mD=slopeVH(s.D.m), pD=pFromPoint(...mD, s.D.x, s.D.y);

const eq1 = eqHTML(mA, pA);
const eq2 = eqHTML(mB, pB);
const eq3 = eqHTML(mD, pD);

setVal(host,'t1', eq1);
setVal(host,'t2', eq2);
setVal(host,'t3', eq3);


  // 2) Texte de correction qui respecte exactement l'ordre pos√© dans l'√©nonc√©
  const ordV = s._orderVals || [0,1,2];
  const ordD = s._orderDer  || [0,1,2];

  const valeurs = ordV.map(k=>`f(${fmtNum(P[k].x)})=${P[k].y}`).join(', ');
  const pentes  = ordD.map(k=>`f'(${fmtNum(P[k].x)})=${fprimeForSentence(P[k].m)}`).join(', ');

  const L=[];
  L.push(`<div class="step"><b>Valeurs</b> : ${valeurs}.</div>`);
  L.push(`<div class="step"><b>Pentes</b> : ${pentes}.</div>`);
  L.push(`<div class="step"><b>√âquations</b> : <code>y = f'(a)(x‚àía) + f(a)</code> ou par lecture graphique</div>`);
  L.push(`<div class="step">T‚ÇÅ : ${eq1}</div>`);
  L.push(`<div class="step">T‚ÇÇ : ${eq2}</div>`);
  L.push(`<div class="step">T‚ÇÉ : ${eq3}</div>`);

  st.innerHTML = L.join('');
}

  });

/* ===== Ex. 3 ‚Äî f'(x) lin√©aire ===== */
L.push({
  id:'ex3_derivee_lineaire',
  title:"Ex. 3 ‚Äî f'(x) = ax + b",
  gen(){
    const a = rchoice([-6,-4,-2,2,3,5]);
    const b = rchoice([-4,-2,0,2,4,11]);
    const poolN = [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1, 1,2,3,4,5,6,7,8,9,10];
    const n = rchoice(poolN);                 // n ‚â† 0
    return {a,b,n};
  },
  render(host, st){
    const s = st.params || this.gen();
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderNoRepere(host);
    ui.equ.innerHTML = `
      <p>On donne pour tout r√©el x : <b>f'(x) = ${s.a}x ${s.b>=0?'+':''}${s.b}</b>.</p>
      <ol>
        <li>Calculer f'(0) = ${mkInput('v1',80)} <span id="tv1" class="tick">‚Äî</span> et f'(${fmtNum(s.n)}) = ${mkInput('v2',80)} <span id="tv2" class="tick">‚Äî</span>.</li>
        <li>En d√©duire les coefficients directeurs des tangentes √† C<sub>f</sub> aux points A et B d‚Äôabscisses resp√©ctives 0 et ${fmtNum(s.n)} :
          m<sub>A</sub> = ${mkInput('mA',80)} <span id="tmA" class="tick">‚Äî</span>, m<sub>B</sub> = ${mkInput('mB',80)} <span id="tmB" class="tick">‚Äî</span>.
        </li>
      </ol>
      <div class="steps" id="steps3"></div>
    `;
    host._state = s; host._ui = ui;
  },
  verify(host){
    const s = host._state;
    const A = s.a*0   + s.b;          // f'(0)
    const B = s.a*s.n + s.b;          // f'(n)
    const v1 = parseNum(getVal(host,'v1'));
    const v2 = parseNum(getVal(host,'v2'));
    const ok1 = eqNum(v1, A);
    const ok2 = eqNum(v2, B);
    setTick($('#tv1',host), ok1);
    setTick($('#tv2',host), ok2);

    const okA = eqNum(parseNum(getVal(host,'mA')), A);
    const okB = eqNum(parseNum(getVal(host,'mB')), B);
    setTick($('#tmA',host), okA);
    setTick($('#tmB',host), okB);

    return ok1 && ok2 && okA && okB;
  },
  solution(host){
    const s = host._state;
    const A = s.a*0   + s.b;
    const B = s.a*s.n + s.b;
    setVal(host,'v1', A);
    setVal(host,'v2', B);
    setVal(host,'mA', A);
    setVal(host,'mB', B);
	const nDisp = (s.n < 0) ? `(${fmtNum(s.n)})` : fmtNum(s.n);
    $('#steps3',host).innerHTML = `
      <div class="step">Par d√©finition, <b>f'(0) = ${s.a}√ó0 ${s.b>=0?'+':''}${s.b} = ${A}</b>.</div>
<div class="step"><b>f'(${fmtNum(s.n)}) = ${s.a}√ó${nDisp} ${s.b>=0?'+':''}${s.b} = ${B}</b>.</div>
      <div class="step">Le coefficient directeur de la tangente en x=a vaut <code>f'(a)</code> :
        m<sub>A</sub> = f'(0) = ${A}, m<sub>B</sub> = f'(${fmtNum(s.n)}) = ${B}.
      </div>
    `;
  }
});


  /* ===== Ex. 4 ‚Äî f'(x_A) avec la tangente passant par B ===== */
L.push({
  id:'ex4_tangent_par_deux_points',
  title:"Ex. 4 ‚Äî f'(x_A) avec la tangente passant par B",
  gen(){
    // A et B entiers lisibles dans [-6,6], x_B ‚â† x_A
    const R = {xmin:-6,xmax:6,ymin:-6,ymax:6};
    let tries = 0;
    while(tries++ < 500){
      const xA = rnd(R.xmin+1, R.xmax-1);
      const yA = rnd(R.ymin+1, R.ymax-1);
      const dx = rchoice([-5,-4,-3,-2,-1, 1,2,3,4,5]); // pas de verticale
      const V  = rnd(-5,5);                             // d√©calage en y
      const xB = xA + dx, yB = yA + V;
      if(xB<R.xmin || xB>R.xmax || yB<R.ymin || yB>R.ymax) continue;
      return {A:{x:xA,y:yA}, B:{x:xB,y:yB}};
    }
    // fallback
    return {A:{x:-3,y:1}, B:{x:2,y:-1}};
  },
  render(host, st){
    const s = st.params || this.gen();
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderNoRepere(host);
    ui.equ.innerHTML = `
      <p>Dans le plan muni du rep√®re (O,I,J), la tangente √† C<sub>f</sub> au point
      <b>A(${fmtNum(s.A.x)}; ${fmtNum(s.A.y)})</b> passe par le point
      <b>B(${fmtNum(s.B.x)}; ${fmtNum(s.B.y)})</b>.</p>
      <p>D√©terminer le nombre d√©riv√© <b>f'(${fmtNum(s.A.x)})</b> :
      ${mkInput('m',100)} <span id="tm" class="tick">‚Äî</span></p>
      <div class="steps" id="steps4"></div>`;
    host._state = s; host._ui = ui;
  },
  verify(host){
    const s = host._state;
    const m = (s.B.y - s.A.y) / (s.B.x - s.A.x);              // pente (AB)
    const ok = eqNum(parseNum(getVal(host,'m')), m, 1e-6);    // accepte entier, a/b, d√©cimal exact
    setTick($('#tm',host), ok);
    return ok;
  },
  solution(host){
  const s  = host._state;
  const UMINUS = '‚àí';
  const u = t => String(t).replace(/-/g, UMINUS);   // affichage grand ‚Äú‚àí‚Äù

  const dy = s.B.y - s.A.y;           // y_B ‚àí y_A
  const dx = s.B.x - s.A.x;           // x_B ‚àí x_A

  // √âcriture d√©velopp√©e avec gestion des signes : -(-k) ‚Üí +k ; +(-k) ‚Üí ‚àík
  const numExpr = `${u(s.B.y)} ${s.A.y < 0 ? '+' : '‚àí'} ${u(Math.abs(s.A.y))}`;
  const denExpr = `${u(s.B.x)} ${s.A.x < 0 ? '+' : '‚àí'} ${u(Math.abs(s.A.x))}`;

  // Fraction symbolique et num√©rique (en ‚Äúpile‚Äù)
  const fracHTMLsym  = `<span class="frac"><span class="num">y<sub>B</sub> ‚àí y<sub>A</sub></span><span class="den">x<sub>B</sub> ‚àí x<sub>A</sub></span></span>`;
  const fracHTMLnums = `<span class="frac"><span class="num">${numExpr}</span><span class="den">${denExpr}</span></span>`;

  // R√©duction et signe global extrait devant la fraction
  const [Nred, Dred] = reduce(Math.abs(dy), Math.abs(dx));   // >0
  const isNeg = (dy < 0) !== (dx < 0);                       // signe global

  // Affichage final ‚Äúpile‚Äù avec signe devant (ou entier)
  const finalPile = (Nred===0) ? '0'
    : (Dred===1
        ? (isNeg ? `${UMINUS} ${u(Nred)}` : `${u(Nred)}`)
        : (isNeg ? `${UMINUS} <span class="frac"><span class="num">${Nred}</span><span class="den">${Dred}</span></span>`
                  : `<span class="frac"><span class="num">${Nred}</span><span class="den">${Dred}</span></span>`));

  // Valeur √† pr√©-remplir dans l‚Äôinput (ASCII pour le parseur : entier ou "a/b")
  const inputVal = (Dred===1) ? (isNeg ? -Nred : Nred) : `${isNeg?'-':''}${Nred}/${Dred}`;
  setVal(host,'m', inputVal);

  // Rendu au format de ton exemple
  const steps = host.querySelector('#steps4');
  steps.innerHTML = `
    <div class="step">
      f'(${u(s.A.x)}) = m<sub>(AB)</sub> = ${fracHTMLsym}= ${fracHTMLnums} = <b>${finalPile}</b>
    </div>
  `;
}


});


  /* ===== Ex. 5 ‚Äî √âquation de tangentes (A et B varient) ===== */
L.push({
  id:'ex5_eq_tangente_point_pente',
  title:"Ex. 5 ‚Äî √âquation de tangentes (points A et B)",
  gen(){
    // Tirages lisibles (entiers)
    const pick = () => ({
      x: rnd(-5,5),
      y: rnd(-5,5),
      m: rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]) // pente non nulle
    });
    let A = pick(), B = pick();
    // √©vite A=B trop souvent
    let guard=0; 
    while(guard++<50 && (A.x===B.x && A.y===B.y)) B = pick();
    return {A,B};
  },
  render(host, st){
    const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
    const ui=renderNoRepere(host);
    ui.equ.innerHTML = `
  <ol>
    <li>
      D√©terminer une √©quation de la tangente <b>T</b> au point 
      <b>A(${fmtNum(s.A.x)} ; ${fmtNum(s.A.y)})</b> √† C<sub>f</sub> 
      sachant que : <b>f'(${fmtNum(s.A.x)}) = ${fmtNum(s.A.m)}</b>.<br>
      ${mkInput('eq1',260,'y = ...')} <span id="te1" class="tick">‚Äî</span>
    </li>
    <li>
      D√©terminer une √©quation de la tangente <b>T</b> au point 
      <b>B(${fmtNum(s.B.x)} ; ${fmtNum(s.B.y)})</b> √† C<sub>f</sub> 
      sachant que <b>le coefficient directeur de T est ${fmtNum(s.B.m)}</b>.<br>
      ${mkInput('eq2',260,'y = ...')} <span id="te2" class="tick">‚Äî</span>
    </li>
  </ol>
  <div class="steps" id="steps5"></div>
`;
    host._state=s; host._ui=ui;
  },
  verify(host){
    const s=host._state;
    const pA = s.A.y - s.A.m*s.A.x;
    const pB = s.B.y - s.B.m*s.B.x;
    const ok1 = isSameLine(getVal(host,'eq1'), s.A.m, pA);
    const ok2 = isSameLine(getVal(host,'eq2'), s.B.m, pB);
    setTick($('#te1',host), ok1); setTick($('#te2',host), ok2);
    return ok1 && ok2;
  },
  solution(host){
    const s=host._state;
    const UMINUS='‚àí', u=t=>String(t).replace(/-/g,UMINUS);
    const pm = k => k<0 ? ` ${UMINUS} ${u(Math.abs(k))}` : ` + ${u(k)}`;
    const bracket = x => x===0 ? `(x)` : `(x ${x<0?'+':'‚àí'} ${u(Math.abs(x))})`;

    function solveBlock(P, label){ // P = {x,y,m}
      const p = P.y - P.m*P.x;           // y = m x + p
      const lineFinal = `y = ${u(P.m)}x${p===0?'':pm(p)}`;
      // Remplit l'input correspondant
      setVal(host, label==='A'?'eq1':'eq2', lineFinal);

      // √âtapes au format demand√©
      return `
        <div class="step"><b>${label}(${u(P.x)} ; ${u(P.y)})</b> donc <b>f(${u(P.x)}) = ${u(P.y)}</b> et on sait que <b>f'(${u(P.x)}) = ${u(P.m)}</b> donc :</div>
        <div class="step"><i>L‚Äô√©quation de la tangente</i> <b>T<sub>${label}</sub></b> est :</div>
        <div class="step">y = f'(${u(P.x)})${bracket(P.x)} + f(${u(P.x)})</div>
        <div class="step">y = ${u(P.m)}${bracket(P.x)} + ${u(P.y)}</div>
        <div class="step">y = ${u(P.m)}x${(P.x===0)?'':pm(P.m*(-P.x))}${pm(P.y)}</div>
        <div class="step"><b>${lineFinal}</b></div>
      `;
    }

    $('#steps5',host).innerHTML = `
      ${solveBlock(s.A,'A')}
      <br>
      ${solveBlock(s.B,'B')}
    `;
  }
});


// Affichage propre (‚àö, ¬≤/¬≥, √ó, fraction 1/(2‚àöx) en pile)
// Affichage propre (‚àö, ¬≤/¬≥, √ó, fractions‚Ä¶)
function prettyExprHTML(expr){
  const U = '‚àí';
  const frac = (N,D)=>`<span class="frac"><span class="num">${N}</span><span class="den">${D}</span></span>`;
  let s = String(expr||'').trim();

  // Signes + espaces
  s = s.replace(/-/g, U).replace(/\s+/g, ' ');

  // ‚àöx / ‚àö(...)
  s = s.replace(/sqrt\(\s*x\s*\)/gi, '‚àöx')
       .replace(/sqrt\(\s*([^()]+)\s*\)/gi, '‚àö($1)');

  // 1/(2*sqrt(x)) ‚Üí 1/(2‚àöx)
  s = s.replace(/1\s*\/\s*\(\s*2\s*[*√ó¬∑]?\s*sqrt\(\s*x\s*\)\s*\)/gi, ()=> frac('1','2‚àöx'));

  // ---- Puissances ‚Üí affichage HTML (tous les cas) ----
  // x^n
  s = s.replace(/x\^2\b/gi, 'x¬≤')
       .replace(/x\^3\b/gi, 'x¬≥')
       .replace(/x\^(\d+)/gi, (_,$1)=>`x<sup>${$1}</sup>`);

  // (¬±nombre)^n
  s = s.replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*2/g, '$1¬≤')
       .replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*3/g, '$1¬≥')
       .replace(/(\(\s*[‚àí\-]?\d+(?:[.,]\d+)?\s*\))\s*\^\s*(\d+)/g, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // nombre^n
  s = s.replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*2/g, '$1¬≤')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*3/g, '$1¬≥')
       .replace(/(\b\d+(?:[.,]\d+)?)\s*\^\s*(\d+)/g, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // Fallback : toute occurrence r√©siduelle ")^n" ou "x^n"
  s = s.replace(/(\)|x)\s*\^\s*(\d+)/gi, (_,$1,$2)=>`${$1}<sup>${$2}</sup>`);

  // √ó uniquement entre nombres (pas avant x, ‚àö, ()
  s = timesNumbersOnly(s);

  // Signes nettoy√©s
  s = s.replace(/\+\s*‚àí/g, ` ${U} `)
       .replace(/‚àí\s*\+/g, ` ${U} `)
       .replace(/‚àí\s*‚àí/g, ' + ')
       .replace(/\s+/g, ' ');

  return s;
}



// √âvaluation s√ªre : ajoute les * implicites et parenth√®se "-x**2"
// √âvaluation s√ªre : caret ^ ‚Üí **, multiplications implicites, etc.
function evalExprSafe(expr, x){
  let code = String(expr || '')
    // 0) Nettoyages d√©fensifs
    .replace(/\ufeff/g, '')                       // BOM
    .replace(/<\/?[^>]+>/g, '')                   // tags HTML
    .replace(/[\u00A0\u202F\u2009\u200A\u2005\u2006\u2007\u2008\u2002\u2003\u2004]/g, ' ') // espaces sp√©ciaux
    // 1) Normalisations Unicode ‚Üí ASCII
    .replace(/‚àí/g, '-')                           // grand moins
    .replace(/[‚Äì‚Äî]/g, '-')                        // en/em dash
    .replace(/[√ó¬∑‚Ä¢]/g, '*')                       // multiplications
    .replace(/[‚ÅÑ‚àï]/g, '/')                        // slashs fraction
    .replace(/,/g, '.')                           // virgule d√©cimale
    // 2) Racines
    .replace(/sqrt\(/gi, 'Math.sqrt(')
    .replace(/‚àö\s*\(\s*/g, 'Math.sqrt(')
    .replace(/‚àö\s*x/gi, 'Math.sqrt(x)');

  // 3) Puissances '^' ‚Üí op√©rateur JS '**'
  code = code
    .replace(/x\^(\d+)/gi, 'x**$1')                     // x^n
    .replace(/\(([^()]+)\)\s*\^\s*(\d+)/g, '($1)**$2')  // (...)^n
    .replace(/(\d+(?:\.\d+)?)\s*\^\s*(\d+)/g, '($1**$2)'); // nombre^n

  // 4) Multiplications implicites (y compris avant Math.sqrt)
  code = code
    .replace(/(\d)\s*x\b/g, '$1*x')       // 2x ‚Üí 2*x
    .replace(/\)\s*x\b/g, ')*x')          // )x ‚Üí )*x
    .replace(/\bx\s*\(/g, 'x*(')          // x( ‚Üí x*(
    .replace(/(\d)\s*\(/g, '$1*(')        // 2( ‚Üí 2*(
    .replace(/\)\s*\(/g, ')*(')           // )( ‚Üí )*(
    .replace(/(\d)\s*(?=Math\.)/g, '$1*') // 2Math.sqrt ‚Üí 2*Math.sqrt
    .replace(/\)\s*(?=Math\.)/g, ')*');   // )Math.sqrt ‚Üí )*Math.sqrt

  // 5) Dernier filtre : garde caract√®res autoris√©s
  code = code.replace(/[^0-9eE+\-*/().x\sA-Za-z_]/g, '');

  // 6) JS n‚Äôaime pas "-x**2" ‚Üí parenth√®se
  code = code.replace(/(^|[^\w\)])-\s*(x\s*\*\*\s*\d+)/g, '$1-($2)');

  const f = new Function('x', 'return (' + code + ');');
  return f(x);
}




// Remplace x par la valeur en ins√©rant * si un nombre ou ')' pr√©c√®de x
function substXWithMul(str, X){
  const sub = (X < 0 ? `(${X})` : String(X));  // parenth√®ses seulement si X<0
  return str
    .replace(/(\d|\))\s*x\b/g, '$1*' + sub)    // a x^n ‚Üí a*X^n  (ou )x ‚Üí )*X)
    .replace(/x\b/g, sub);                     // le reste : x ‚Üí X
}



/* ===== Ex. 6 ‚Äî √âquation de la tangente (f et f' donn√©s) + S√âLECTEUR ===== */
L.push({
  id:'ex6_eq_tangente_f_fx',
  title:"Ex. 6 ‚Äî √âquation de la tangente (f et f' donn√©s)",
  gen(forcedKind){
    // ‚Üí on conserve 'poly' (exclut affine), et on ajoute 'affine' & 'linear'
    const kinds = ['square','cube','inverse','sqrt','affine','linear','poly'];
    const kind  = (forcedKind && forcedKind!=='random') ? forcedKind : rchoice(kinds);

    // Fabrique un polyn√¥me de degr√© 2 ou 3 (‚â† affine)
    // ‚Ä¶ √† l‚Äôint√©rieur de gen(forcedKind) ‚Ä¶
// dans gen(forcedKind) de l'exo 6
// Dans gen() de l'Ex.6
// --- PATCH polyGen (corrige l'affichage de dfx) ---
function polyGen(){
  const UMINUS = '‚àí';
  const deg = rchoice([2,3]);                 // jamais affine
  const a = rchoice([-3,-2,-1,1,2,3]);
  const b = rchoice([-3,-2,-1,0,1,2,3]);
  const c = rchoice([-3,-2,-1,0,1,2,3]);
  const d = rchoice([-3,-2,-1,0,1,2,3]);

  // Mon√¥me int√©rieur " ¬± A x^p " (cache A si A=1 et p>=1)
  const term = (K, p) => {
    if (K === 0) return '';
    const s = K > 0 ? ' + ' : ` ${UMINUS} `;
    const A = Math.abs(K);
    if (p === 0) return s + A;
    if (p === 1) return s + (A === 1 ? '' : A) + 'x';
    return s + (A === 1 ? '' : A) + `x^${p}`;
  };

  // Mon√¥me de t√™te (sans " + " devant)
  const lead = (K, p) => {
    const S = K < 0 ? UMINUS : '';
    const A = Math.abs(K);
    if (p === 1) return S + (A === 1 ? '' : A) + 'x';
    return S + (A === 1 ? '' : A) + `x^${p}`;
  };

  let fx = '', dfx = '';

  if (deg === 3) {
    // f(x) = ax^3 + bx^2 + cx + d
    fx  = lead(a,3) + term(b,2) + term(c,1) + term(d,0);

    // f'(x) = 3ax^2 + 2bx + c
    const A3 = 3*a, B2 = 2*b;
    dfx = lead(A3,2) + term(B2,1) + term(c,0);
  } else {
    // f(x) = ax^2 + bx + c
    fx  = lead(a,2) + term(b,1) + term(c,0);

    // f'(x) = 2ax + b
    const A2 = 2*a;
    dfx = lead(A2,1) + term(b,0);
  }

  return {
    fx:  String(fx).replace(/^\+\s*/,'').trim(),
    dfx: String(dfx).replace(/^\+\s*/,'').trim()
  };
}



    let fx, dfx, xA;

    if(kind==='square'){    fx='x^2';             dfx='2x';            xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='cube'){ fx='x^3';             dfx='3x^2';          xA=rchoice([-3,-2,-1,0,1,2,3]); }
    else if(kind==='inverse'){ fx='1/x';          dfx='-1/x^2';        xA=rchoice([-3,-2,-1,1,2,3]);   } // ‚â†0
    else if(kind==='sqrt'){    fx='sqrt(x)';      dfx='1/(2sqrt(x))'; xA=rchoice([1,4,9]);   } // simple
    else if(kind==='affine'){
      const m = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // pente ‚â†0
      const b = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);         // b ‚â†0 pour √©viter lin√©aire
      fx  = `${m}x ${b>=0?'+':''}${b}`;
      dfx = `${m}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else if(kind==='linear'){
      const k = rchoice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      fx  = `${k}x`;                                          // pas de ‚Äú+ 0‚Äù
      dfx = `${k}`;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }else{ // 'poly' (degr√© 2 ou 3 uniquement)
      const P = polyGen();
      fx=P.fx; dfx=P.dfx;
      xA=rchoice([-3,-2,-1,0,1,2,3]);
    }

    return {kind, fx, dfx, xA};
  },

  render(host, st){
    const chosen = (window.__EXO6_KIND__ || 'random');
    const s = st.params || this.gen(chosen);
    host.dataset.state = JSON.stringify({params:s});
    const ui = renderNoRepere(host);

    const selectorHTML = `
      <div class="optionline small" style="margin-bottom:.4rem">
        <label for="kind6"><b>Type de fonction :</b></label>
        <select id="kind6">
          <option value="random">Al√©atoire</option>
          <option value="square">Carr√© (x¬≤)</option>
          <option value="cube">Cube (x¬≥)</option>
          <option value="inverse">Inverse (1/x)</option>
          <option value="sqrt">Racine carr√©e (‚àöx)</option>
          <option value="affine">Affine (mx + b)</option>
          <option value="linear">Lin√©aire (kx)</option>
          <option value="poly">Polyn√¥me (deg 2‚Äì3)</option>
        </select>
        <button id="regen6" class="btn">‚Üª Tirer</button>
      </div>
    `;
    // (dans Ex.6 render)
const fxH  = prettyExprHTML(s.fx);
const dfxH = prettyExprHTML(s.dfx);
ui.equ.innerHTML = `
${selectorHTML}
  <p>Donner une √©quation de la tangente <b>T</b> au point <b>A</b> de <b>C<sub>f</sub></b> d‚Äôabscisse <b>x<sub>A</sub></b>.</p>
  <p><code>f(x) = ${fxH}</code> &nbsp; et &nbsp; <code>f'(x) = ${dfxH}</code> &nbsp; en <b>x<sub>A</sub> = ${s.xA}</b>.</p>
  ${mkInput('r1',260,'y = ...')} <span id="tr1" class="tick">‚Äî</span>
  <div class="steps" id="steps6"></div>
`;

    host._state=s; host._ui=ui;

    $('#kind6',host).value = chosen;
    const regenerate = (kind)=>{ window.__EXO6_KIND__ = kind; this.render(host,{params:this.gen(kind)}); };
    $('#kind6',host).addEventListener('change', e=>regenerate(e.target.value));
    $('#regen6',host).addEventListener('click', ()=>regenerate($('#kind6',host).value));
  },

  verify(host){
    const s=host._state;
    const m = evalExprSafe(s.dfx, s.xA);
    const y = evalExprSafe(s.fx , s.xA);
    const p = y - m*s.xA;
    const ok = isSameLine(getVal(host,'r1'), m, p);
    setTick($('#tr1',host), ok);
    return ok;
  },


  solution(host){
  const s = host._state;
  const U='‚àí', u=t=>String(t).replace(/-/g,U);
  const frac = (N,D)=>`<span class="frac"><span class="num">${N}</span><span class="den">${D}</span></span>`;
  const supPow = k => k===2?'¬≤':k===3?'¬≥':`<sup>${k}</sup>`;
  const showVal = x => u(x);
  const showPar = x => x<0 ? `(${u(x)})` : u(x);
  const powShow = (x,k)=>`${showPar(x)}${supPow(k)}`;
  const multShow= (a,b)=>`${u(a)} √ó ${showPar(b)}`;

  // valeurs exactes
  const m = evalExprSafe(s.dfx, s.xA);
  const y = evalExprSafe(s.fx , s.xA);
  const X  = s.xA, Xs = showVal(X);

  // ‚Äî Puces : z√©ro doublon, √ó obligatoires, parenth√®ses seulement si n√©gatif ‚Äî
  let fLine='', dLine='';
  if(/^\s*x\^2\s*$/i.test(s.fx)){                     // carr√©
    fLine = `<b>f(${Xs}) = ${powShow(X,2)} = ${showVal(X*X)}</b>`;
    dLine = `<b>f'(${Xs}) = ${multShow(2,X)} = ${showVal(2*X)}</b>`;
  }else if(/^\s*x\^3\s*$/i.test(s.fx)){               // cube
    fLine = `<b>f(${Xs}) = ${powShow(X,3)} = ${showVal(X*X*X)}</b>`;
    dLine = `<b>f'(${Xs}) = 3 √ó ${powShow(X,2)} = ${multShow(3,X*X)} = ${showVal(3*X*X)}</b>`;
  }else if(/^\s*1\s*\/\s*x\s*$/i.test(s.fx)){         // inverse
    if(Math.abs(X)===1){
      fLine = `<b>f(${Xs}) = ${showVal(X<0?-1:1)}</b>`;
      dLine = `<b>f'(${Xs}) = ${U}${showVal(1)}</b>`;
    }else{
      const [ny,dy]=reduce(1,Math.abs(X));
      const [nm,dm]=reduce(1,Math.abs(X*X));
      fLine = `<b>f(${Xs}) = ${frac(1, X<0?`(${Xs})`:Xs)} = ${(X<0?U:'')}${frac(ny,dy)}</b>`;
      dLine = `<b>f'(${Xs}) = ${U}${frac(1, `${showPar(X)}${supPow(2)}`)} = ${U}${frac(nm,dm)}</b>`;
    }
  }else if(/sqrt\(\s*x\s*\)/i.test(s.fx)){            // racine
    fLine = `<b>f(${Xs}) = ‚àö${X<0?`(${Xs})`:Xs} = ${showVal(Math.sqrt(X))}</b>`;
    dLine = `<b>f'(${Xs}) = ${frac(1, `2‚àö${X<0?`(${Xs})`:Xs}`)} = ${frac(1, 2*showVal(Math.sqrt(X)))}</b>`;
  }else{                                              // affine / lin√©aire / polyn√¥me
    const subX = X<0 ? `(${Xs})` : Xs;
const fSub = prettyExprHTML( substXWithMul(s.fx , X) );
const dSub = prettyExprHTML( substXWithMul(s.dfx, X) );

    fLine = `<b>f(${Xs})</b> = ${fSub} = <b>${showVal(y)}</b>`;
    dLine = `<b>f'(${Xs})</b> = ${dSub} = <b>${showVal(m)}</b>`;
  }

  // ‚Äî Tangente : y = m(x ‚àí xA) + f(xA) ‚Üí y = mx + p (sans +- / --) ‚Äî
  const mVH = slopeVH(m);
  const mHTML = (mVH[1]===1)? showVal(mVH[0]) : frac(mVH[0],mVH[1]);
  const xShift = X===0 ? '(x)' : `(x ${X<0?'+':'‚àí'} ${showVal(Math.abs(X))})`;

  const termRat = reduce(-mVH[0]*X, mVH[1]);                          // ‚àím xA
  const termSign = termRat[0] < 0 ? ` ${U} ` : ' + ';
  const termAbsHTML = (termRat[1]===1)? showVal(Math.abs(termRat[0])) : frac(Math.abs(termRat[0]), Math.abs(termRat[1]));

  let yRat;
  if(/^\s*1\s*\/\s*x\s*$/i.test(s.fx)){ yRat = reduce((X<0?-1:1)*1, Math.abs(X)); }
  else { yRat = [y,1]; }
  const ySign    = yRat[0] < 0 ? ` ${U} ` : ' + ';
  const yAbsHTML = (yRat[1]===1)? showVal(Math.abs(yRat[0])) : frac(Math.abs(yRat[0]), Math.abs(yRat[1]));

  const pVH = pFromPoint(...mVH, X, y);
  const eq  = eqHTML(mVH, pVH);
  setVal(host,'r1', eq);

  $('#steps6',host).innerHTML = `
    <div class="step">‚Ä¢ ${fLine}</div>
    <div class="step">‚Ä¢ ${dLine}</div>
    <div class="step" style="margin-top:.5rem"><i>L‚Äô√©quation de la tangente</i> <b>T<sub>A</sub></b> est :</div>
    <div class="step">y = f'(${Xs})${xShift} + f(${Xs})</div>
    <div class="step">y = ${mHTML}${xShift} + ${(yRat[1]===1)? showVal(yRat[0]) : frac(yRat[0],yRat[1])}</div>
    <div class="step">y = ${mHTML}x${termSign}${termAbsHTML}${ySign}${yAbsHTML}</div>
    <div class="step"><b>${eq}</b></div>
  `;
}

});


  /* ===== Ex. 7 ‚Äî Lecture graphique mixte ===== */
  L.push({
    id:'ex7_graph_mix',
    title:"Ex. 7 ‚Äî Lecture graphique & tangentes",
    gen(){
  const RVIS={xmin:-8,xmax:8,ymin:-8,ymax:8};
  const g=HERMITE5.generate({mag:5, denMax:4, R:HERMITE5.RDEF});
  return {R:RVIS, f:g.f, df:g.df, A:g.A, B:g.B, C:g.C, pts20:g.pts20};
},
    render(host, st){
      const s=st.params||this.gen(); host.dataset.state=JSON.stringify({params:s});
      const ui=renderWithRepere(host, s.R);
      ui.rep.drawCurve(s.f,'#000',2.5);
      ui.rep.drawPoint('A',s.A.x,s.A.y,'#1565c0');
      ui.rep.drawPoint('B',s.B.x,s.B.y,'#1565c0');
      ui.rep.drawLineThroughPointSlope(s.A.x,s.A.y,s.A.m,'#1565c0',true);
      // horizontales aux x=-3 et x=0 (df=0)
      const yM1=s.f(-3), yM0=s.f(0);
      ui.rep.drawLineThroughPointSlope(-3,yM1,0,'#9e9e9e',true);
      ui.rep.drawLineThroughPointSlope(0,yM0,0,'#9e9e9e',true);

      ui.equ.innerHTML = `
        <p>La droite (AB) est la tangente √† la courbe C<sub>f</sub> au point <b>A</b> d‚Äôabscisse ‚àí2. De plus, la courbe admet des tangentes horizontales aux points d‚Äôabscisses ‚àí3 et 0.</p>
        <ol>
          <li>D√©terminer : f(‚àí2) = ${mkInput('fa',80)} <span id="tfa" class="tick">‚Äî</span> ; f(0) = ${mkInput('f0',80)} <span id="tf0" class="tick">‚Äî</span> ; f'(‚àí2) = ${mkInput('dfa',80)} <span id="tdfa" class="tick">‚Äî</span> ; f'(0) = ${mkInput('df0',80)} <span id="tdf0" class="tick">‚Äî</span>.</li>
          <li>Donner graphiquement une √©quation de la tangente au point d‚Äôabscisse ‚àí3 : ${mkInput('t-3',220,'y = ...')} <span id="ttm3" class="tick">‚Äî</span>.</li>
          <li>Donner graphiquement une √©quation de la tangente au point d‚Äôabscisse ‚àí2 : ${mkInput('t-2',220,'y = ...')} <span id="ttm2" class="tick">‚Äî</span>.</li>
          <li>On admet que f'(2)=3. Donner l‚Äô√©quation de la tangente T √† la courbe C<sub>f</sub> au point d‚Äôabscisse 2 : ${mkInput('t2',220,'y = ...')} <span id="tt2" class="tick">‚Äî</span>.</li>
        </ol>
        <div class="steps" id="steps7"></div>`;
      host._state={...s, yM1, yM0}; host._ui=ui;
    },
    verify(host){
      const s=host._state;
      const ok1=eqNum(parseNum(getVal(host,'fa')), s.A.y,1e-2);
      const ok2=eqNum(parseNum(getVal(host,'f0')), s.f(0),1e-2);
      const ok3=eqNum(parseNum(getVal(host,'dfa')), s.A.m,1e-2);
      const ok4=eqNum(parseNum(getVal(host,'df0')), 0,1e-6);
      setTick($('#tfa',host), ok1); setTick($('#tf0',host), ok2); setTick($('#tdfa',host), ok3); setTick($('#tdf0',host), ok4);
      const okm3 = isSameLine(getVal(host,'t-3'), 0, s.yM1);
      const okm2 = isSameLine(getVal(host,'t-2'), s.A.m, s.A.y - s.A.m*s.A.x);
      const m2=3, p2=s.f(2) - 3*2;
      const okm22 = isSameLine(getVal(host,'t2'), m2, p2);
      setTick($('#ttm3',host), okm3); setTick($('#ttm2',host), okm2); setTick($('#tt2',host), okm22);
      return ok1&&ok2&&ok3&&ok4&&okm3&&okm2&&okm22;
    },
    solution(host){
      const s=host._state;
      setVal(host,'fa',s.A.y); setVal(host,'f0',s.f(0)); setVal(host,'dfa',s.A.m); setVal(host,'df0',0);
      setVal(host,'t-3',`y = ${s.yM1}`);
      const pA = s.A.y - s.A.m*s.A.x; setVal(host,'t-2',`y = ${s.A.m}x ${pA>=0?'+':''}${pA}`);
      const m2=3, p2=s.f(2) - 3*2; setVal(host,'t2',`y = 3x ${p2>=0?'+':''}${p2}`);
      $('#steps7',host).innerHTML = `
        <div class="step">En x=‚àí3 et x=0, la tangente est <b>horizontale</b> : pente 0, donc <code>y = f(‚àí3)</code> et <code>y = f(0)</code>.</div>
        <div class="step">En x=‚àí2, (AB) est tangente donc <code>m=f'(‚àí2)=${fmtNum(s.A.m)}</code> et <code>p=y_A ‚àí m x_A = ${fmtNum(s.A.y)} ‚àí ${fmtNum(s.A.m)}√ó(‚àí2) = ${fmtNum(s.A.y - s.A.m*s.A.x)}</code>.</div>
        <div class="step">Si <code>f'(2)=3</code>, alors <code>T : y = 3(x‚àí2)+f(2)</code> ‚áí <code>y = 3x ${ (s.f(2)-6)>=0?'+':''}${fmtNum(s.f(2)-6)}</code>.</div>`;
    }
  });

  return L;
}

/* ======== REGISTRY & UI glue ======== */
const REGISTRY = makeExos();
function populateSelect(){
  const sel=$('#exo-select'); sel.innerHTML='';
  for(const e of REGISTRY){
    const opt=document.createElement('option'); opt.value=e.id; opt.textContent=e.title; sel.appendChild(opt);
  }
  sel.value=REGISTRY[0].id;
}
function renderActive(){
  const host=$('#host'); const sel=$('#exo-select'); const def=REGISTRY.find(e=>e.id===sel.value);
  host.dataset.active=def.id; def.render(host,{});
}
function scoreSet(a,b){ $('#score').textContent = `Score : ${a} / ${b}`; }
let SCORE=[0,0];

window.addEventListener('load', function(){
  populateSelect(); renderActive(); scoreSet(0,0);
  $('#exo-select').addEventListener('change', ()=>{ renderActive(); });
  $('#btn-new').addEventListener('click', ()=>{ renderActive(); });
  $('#btn-reset').addEventListener('click', ()=>{ renderActive(); });
  $('#btn-sol').addEventListener('click', ()=>{
    const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active);
    host._noFillSolution = true;
    def.solution(host);
    // üëâ post-traitement : √ó explicites, signes normalis√©s, anti "= v = v"
    canonizeAllSteps(host);
    host._noFillSolution = false;
  });
  $('#btn-check').addEventListener('click', ()=>{
    const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active);
    // Ne pas compter faux si des champs sont vides
    const inputs = Array.from(host.querySelectorAll('input'));
    const allFilled = inputs.every(i=>String(i.value||'').trim()!=='');
    const ok = def.verify(host);
    if(allFilled){
      if(ok){ SCORE[0]++; SCORE[1]++; } else { SCORE[1]++; }
      scoreSet(...SCORE);
    }
  });
});



/* ======== PDF (hooks) ======== */
window.addEventListener('load', function(){
  if(!(window.ExoPDF && ExoPDF.init)) return;
  ExoPDF.init({
    title: 'Premi√®re ‚Äî Nombres d√©riv√©s & tangentes',
    max: 50,
    leadByDefId: {
      ex1_deriv_graph: "Lire sur la courbe la valeur du nombre d√©riv√© f'(a).",
      ex2_tangentes_triple: "Lecture de valeurs et d‚Äô√©quations de tangentes.",
      ex3_derivee_lineaire: "Calculer f'(a) et les pentes des tangentes.",
      ex4_tangent_par_deux_points: "Retrouver f'(a) √† partir d‚Äôune tangente donn√©e par deux points.",
      ex5_eq_tangente_point_pente: "Donner l‚Äô√©quation d‚Äôune tangente connaissant le point et la pente.",
      ex6_eq_tangente_f_fx: "Donner l‚Äô√©quation de la tangente √† partir de f et f'.",
      ex7_graph_mix: "Lecture graphique : valeurs, pentes et tangentes."
    },
    mount:'#pdf-ui'
  });
});
</script>
</body>
</html>