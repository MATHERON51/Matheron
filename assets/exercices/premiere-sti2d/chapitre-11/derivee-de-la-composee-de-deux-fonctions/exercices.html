<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re STI2D ‚Äî D√©rivation : Fonction compos√©e</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc d'√©tapes / correction */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:#11823b}
.tick.ko{color:#b00020}

.answers{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem .5rem;
}
.answers .qa-row{
  flex-basis:100%;
  display:flex;
  align-items:center;
  gap:.4rem;
  margin-top:.35rem;
}
.answers .qa-row label{
  margin-right:.3rem;
}

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}

/* tableau 2 colonnes m√©thode 1 / m√©thode 2 */
.twocol-solution{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  width:auto;
}
.twocol-solution td{
  vertical-align:top;
  padding:0 16px;
  border:none;
  white-space:nowrap;
  line-height:1.75;
  font-size:0.95rem;
}
/* barre verticale SEULEMENT entre les 2 colonnes */
.twocol-solution td.col-gauche{
  border-right:2px solid #999;
  padding-right:24px;
}
.twocol-solution td.col-droite{
  padding-left:24px;
}
.twocol-solution .line{
  margin:.3rem 0;
}
.twocol-solution .line mjx-container{
  padding-bottom:.08em;
}

/* mini tableau u / u' / g / g' en colonne gauche */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{
    padding:4px 40px 4px 0;
  }
}

@media print{ .controls{display:none !important;} }

</style>

<!-- ‚≠ê MATHJAX CONFIG CHTML (PAS SVG) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<!-- FIN MathJax -->
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>1√®re STI2D ‚Äì D√©rivation : Fonction compos√©e</strong>
  </h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
    <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
    <button id="btn-solution" class="btn">üí° Solution</button>
    <button id="btn-reset" class="btn">üßπ R√©initialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; r√©ponses accept√©es :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x¬≤</code>‚Ä¶</li>
      <li>Racines : <code>sqrt(‚Ä¶)</code>, <code>rac(‚Ä¶)</code>, <code>‚àö(‚Ä¶)</code>.</li>
      <li>Fractions : <code>a/b</code>. Multiplications implicites accept√©es.</li>
          <li>Attention aux parenth√®ses pour les fractions si c'est n√©cessaire.</li>

	</ul>
  </div>

  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- D√©pendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ====== util DOM + score ====== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){
  const el=$("#score");
  if(el) el.textContent = scoreOK+" / "+scoreTot;
}
function scanFractions(root){
  try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){}
}

/* ====== random helpers ====== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
function nzChoose(list){ return choice(list.filter(x=>x!==0)); }

/* ===== normalisation / √©val saisie ===== */
function normalizeRac(s){
  s = String(s||'');

  s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
       .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

  s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
  s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

  s = s.replace(/(\d|\))\s*‚àö\s*\(/g, '$1*sqrt(');
  s = s.replace(/(\d|\))\s*‚àö\s*x\b/gi, '$1*sqrt(x)');
  s = s.replace(/‚àö\s*\(/g,   'sqrt(')
       .replace(/‚àö\s*x\b/gi, 'sqrt(x)');

  s = s.replace(/\)\s*(?=sqrt\()/g, ')*');
  s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
  return s;
}
function numEval(expr, x){
  if(expr==null) return NaN;
  let s = String(expr);

  s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');
  s = normalizeRac(s);

  // puissances unicode -> ^ -> **
  const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
  s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
        (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
      )
      .replace(/\^/g,'**');

  s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

  s = s
    .replace(/\)\s*\(/g, ')*(')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/(\d)\s*x/g, '$1*x')
    .replace(/\)\s*x/g, ')*x')
    .replace(/x\s*\(/g, 'x*(');

  s = s
    .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
    .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

  if (typeof x === 'number') {
    s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
  }

  try { return Number(Function('"use strict";return ('+s+')')()); }
  catch { return NaN; }
}
function almost(a,b,eps=1e-8){
  return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b)));
}


function pickK(){
  // 50% k = 1
  // 50% k = autre entier dans [-5..-2] U [-1] U [2..5]
  // mais tu veux garder la possibilit√© k=-1 aussi dans ce 50%.
  // On veut bien inclure -1 dans "‚â†1".
  if (Math.random() < 0.5){
    return 1;
  } else {
    const pool = [-5,-4,-3,-2,-1,2,3,4,5];
    return choice(pool);
  }
}

// affichage latex du k DEVANT quelque chose
// ex:
//   k = 1      -> ""          (rien)
//   k = -1     -> "‚àí"         (le signe moins tout seul)
//   k = 3      -> "3"
//   k = -4     -> "‚àí4"
// Attention : on ne met pas d'espace apr√®s, tu le g√©reras o√π tu l'ins√®res.
function kPrefixFromK(k){
  if (k === 1)  return "";
  if (k === -1) return "‚àí";
  if (k < 0)    return "‚àí"+Math.abs(k);
  return String(k);
}


/* ===== helpers d'affichage pour affines / polyn√¥mes courts ===== */
function affineLatex(A,B){
  const absA=Math.abs(A), absB=Math.abs(B);
  // terme en x
  let sA = (absA===1?'x':`${absA}x`);
  if(A<0) sA='-'+sA;
  // constante
  let sB='';
  if(B!==0){
    if(B>0) sB = ' + '+absB;
    else    sB = ' - '+absB;
  }
  return sA + sB;
}
function affineToJS(A,B){
  const absA=Math.abs(A);
  let tA = (absA===1?'x':`${absA}*x`);
  if(A<0) tA='-('+tA+')';
  let expr=tA;
  if(B!==0){
    if(B>0) expr += `+${B}`;
    else    expr += `${B}`;
  }
  return expr;
}
function affineDerivLatex(A){
  // u'(x)=A (constante)
  return String(A);
}

/* polyn√¥me degr√©>=2 pour exo2 */
function randPoly(minDeg,maxDeg){
  const deg = rnd(minDeg,maxDeg);
  const coeffs=[];
  for(let i=0;i<=deg;i++){
    let c=rnd(-5,5);
    if(i===deg){
      while(c===0) c=rnd(-5,5); // coef dominant ‚â†0
    }
    coeffs.push(c);
  }
  return coeffs;
}
function polyToLatex(p){
  const terms=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    const absA=Math.abs(a);
    let seg='';
    if(i===0){
      seg = String(absA);
    }else if(i===1){
      seg = (absA===1)?'x':`${absA}x`;
    }else{
      seg = (absA===1)?`x^{${i}}`:`${absA}x^{${i}}`;
    }
    seg = (a<0?'-':'+' )+' '+seg;
    terms.push(seg);
  }
  if(!terms.length) return '0';
  return terms.join(' ').replace(/^\+\s*/,'').trim();
}
function polyToJS(p){
  const parts=[];
  for(let i=p.length-1;i>=0;i--){
    const a=p[i];
    if(a===0) continue;
    let seg='';
    if(i===0){
      seg=String(Math.abs(a));
    }else if(i===1){
      seg=(Math.abs(a)===1)?'x':`${Math.abs(a)}*x`;
    }else{
      seg=(Math.abs(a)===1)?`x**${i}`:`${Math.abs(a)}*x**${i}`;
    }
    if(a<0) parts.push(`-(${seg})`);
    else parts.push(seg);
  }
  if(!parts.length) return '0';
  let expr=parts.join('+');
  expr=expr.replace(/\+\-\(/g,'-(');
  return expr;
}
function polyDeriv(p){
  if(p.length<=1) return [0];
  const d=[];
  for(let i=1;i<p.length;i++){
    d.push(p[i]*i);
  }
  return d;
}

/* petites fonctions utilitaires pour affichage propre */
function cleanSignsDisplay(str){
  // supprime "+ 0", "- 0" en fin, r√©pare "+ -" -> "-" etc.
  if(!str) return str;
  let out = String(str);

  out = out.replace(/\+\s*-\s*/g,' - ');
  out = out.replace(/-\s*-\s*/g,' + ');
  out = out.replace(/\+\s*\+\s*/g,' + ');
  out = out.replace(/-\s*\+\s*/g,' - ');
  out = out.replace(/\s+/g,' ').trim();
  out = out.replace(/^\+\s*/,''); // retire + en t√™te
  out = out.replace(/(\+|‚àí|-)\s*0($|[^0-9])/g, ' $2'); // virer "+ 0" isol√©s
  out = out.replace(/\s+/g,' ').trim();
  return out;
}

// essaie de simplifier le num√©rateur k * dU par 2
// renvoie une string LaTeX sans le /2 si possible, sinon ""
function buildAfterDivide2(k, dULatex, uLatex){
  // k : entier (coeff devant la racine, genre -2, 3, etc.)
  // dULatex : d√©riv√©e u'(x) d√©j√† substitu√©e (ex "10x-1" ou "(10x-1)" selon parenth√®ses)
  // uLatex : le u(x) explicite (ex "5x^2 - x + 3")
  //
  // On part de   (k * dU) / ( 2 sqrt(u) )
  // Si k est multiple de 2 -> (k/2 * dU) / sqrt(u)
  // Sinon pas de simplification => retourne "" (c√†d pas de ligne suppl√©mentaire)

  if(k % 2 !== 0) return "";

  const half = k/2; // peut √™tre n√©gatif
  // Cas sp√©cial : half = 1 ou -1 ‚Üí on ne veut pas "1√ó"
  let numLatex;
  if(half === 1){
    numLatex = dULatex.replace(/^\((.*)\)$/,'$1'); // enl√®ve parenth√®ses inutiles autour (10x-1)
  }else if(half === -1){
    // "-1 √ó (10x-1)" => "-(10x-1)"
    // si dULatex est d√©j√† parenth√©s√© "(10x-1)" : devient "-(10x-1)"
    // si pas parenth√©s√© "10x-1" : devient "-(10x-1)" quand m√™me pour bien montrer le bloc
    const core = dULatex.match(/^\((.*)\)$/) ? dULatex : `(${dULatex})`;
    numLatex = `-${core}`;
  }else{
    // g√©n√©ral : "c √ó (10x-1)" (si dULatex pas d√©j√† parenth√©s√© ET contient un "+"/"-", on le parenth√®se)
    let core = dULatex;
    if(!/^\(.*\)$/.test(core) && /[+\-]/.test(core)){
      core = `(${core})`;
    }
    numLatex = `${half} ${core}`;
  }

  return `\\dfrac{${numLatex}}{\\sqrt{${uLatex}}}`;
}


/* =========================================================
   EXERCICE 1
   u(x) affine ; g = puissance OU racine (avec coeff k devant possible)
   Deux m√©thodes dans la correction.
   ========================================================= */
function genEx1(mode){
  // type concret : "pow" ou "sqrt"
  let kind;
  if(mode === 'powAffine'){
    kind = 'pow';
  }else if(mode === 'sqrtAffine'){
    kind = 'sqrt';
  }else{
    kind = choice(["pow","sqrt"]);
  }

  // u(x)=ax+b avec a‚â†0
  const a = nzChoose([-5,-4,-3,-2,-1,1,2,3,4,5]);
  const b = rnd(-6,6);

  const uLatex = affineLatex(a,b);
  const uPrime = a;
  const uJS = '('+affineToJS(a,b)+')';

  let title = "Exercice 1 : D√©rivation d‚Äôune compos√©e (avec u affine)";
  let enonce = "";
  let solHTML = "";
  let latexF = "";
  let fpJS;
  let fJS;

  if(kind==="pow"){
  const n = rnd(2,7);

  // nouveau tirage k (50/50 =1 vs autre)
  const k = pickK(); // entier genre 1, -1, 4, -2...
  const kPrefix = kPrefixFromK(k); // "" / "‚àí" / "3" / "‚àí4" ...

  // u(x)=ax+b, u'(x)=a
  const uPrimeLatex = String(uPrime);
  const uPrimePar   = (uPrime<0?`(${uPrimeLatex})`:uPrimeLatex);

  // On construit g(x) = k * x^n SANS √©crire "k"
  // g(x) :
  //   k=1   -> x^n
  //   k=-1  -> ‚àíx^n
  //   k=4   -> 4x^n
  //   k=-3  -> ‚àí3x^n
  let gLatex;
  if (k === 1){
    gLatex = `x^{${n}}`;
  } else if (k === -1){
    gLatex = `-${n===1?'x':`x^{${n}}`}`; // n>=2 donc x^{n}
  } else {
    gLatex = `${kPrefix}x^{${n}}`; // kPrefix est genre "3" ou "‚àí2"
  }

  // g'(x) = k * n * x^{n-1}
  // On doit fabriquer proprement ce coefficient k*n :
  const kn = k * n; // nombre entier
  // afficher kn*x^{n-1}
  // attention au cas n-1 = 1
  let gPrimeNice;
  if (n === 2){
    // n-1 =1 => k*n * x
    // ex si k=3, n=2 => 6x
    // si k=-1, n=2 => -2x
    gPrimeNice = `${kn}x`;
  } else {
    gPrimeNice = `${kn}x^{${n-1}}`;
  }

  // g'(u(x)) = kn * (u(x))^{n-1}
  // version sans afficher puissance 1
  let gPrimeComposeLatex;
  if (n === 2){
    // kn * u(x)
    gPrimeComposeLatex = `${kn}\\,u(x)`;
  } else {
    gPrimeComposeLatex = `${kn}\\,(u(x))^{${n-1}}`;
  }

  // f'(x) = g'(u(x)) * u'(x)
  // g√©n√©rique avec u(x), u'(x) symboliques :
  //   si n=2: kn * u(x) * u'(x)
  //   sinon : kn * (u(x))^{n-1} * u'(x)
  const derivGeneric_uLatex =
    (n === 2)
      ? `${kn}\\,u(x)u'(x)`
      : `${kn}\\,(u(x))^{${n-1}}u'(x)`;

  // version substitu√©e u(x)=..., u'(x)=...
  //   n=2  -> kn * (uLatex) * uPrimePar
  //   n>2  -> kn * (uLatex)^{n-1} * uPrimePar
  const derivExpandedLatex =
    (n === 2)
      ? `${kn}\\,(${uLatex}) \\times ${uPrimePar}`
      : `${kn}\\,(${uLatex})^{${n-1}} \\times ${uPrimePar}`;

  // coefficient num√©rique final kn*uPrime
  const finalCoeff = kn * uPrime;
  // derni√®re ligne finale propre :
  const finalLatexClean2 =
    (n === 2)
      ? `${finalCoeff}\\,(${uLatex})`
      : `${finalCoeff}\\,(${uLatex})^{${n-1}}`;

  // f(x) pour l'√©nonc√© :
  //   k=1    -> (uLatex)^n
  //   k=-1   -> - (uLatex)^n
  //   k=4    -> 4(uLatex)^n
  //   k=-3   -> -3(uLatex)^n
  let fLatexForEnonce;
  if (k === 1){
    fLatexForEnonce = `(${uLatex})^{${n}}`;
  } else if (k === -1){
    fLatexForEnonce = `-${n===1?`(${uLatex})`:`(${uLatex})^{${n}}`}`;
  } else {
    fLatexForEnonce = `${kPrefix}(${uLatex})^{${n}}`;
  }
  latexF = fLatexForEnonce;

  enonce =
    `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
    `\\[ f(x)= ${fLatexForEnonce} \\]`;

  // === METHODE 1 (cha√Æne stricte : f(x)=g(u(x)))
  // Ici on affiche g(x) = [kPrefix] x^n, pas "k √ó x^n"
  // et u'(x), g'(x), g'(u(x)) avec les coeffs *num√©riques d√©j√† multipli√©s*.
  const method1HTML = `
    <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

    <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
        <td>\\(g(x)=${gLatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${uPrimeLatex}\\)</td>
        <td>\\(g'(x)=${gPrimeNice}\\)</td>
      </tr>
      <tr>
        <td></td>
        <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
    <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>

    <div class="line">\\(f'(x)= ${derivExpandedLatex}\\)</div>
    <div class="line">\\(f'(x)= ${finalLatexClean2}\\)</div>
  `;

  // === METHODE 2
  // M√©thode 2 = ta formule "connue" type (k(u(x))^n)' = k*n*(u(x))^{n-1}*u'(x)
  // √áa te convenait d√©j√†, juste on n'affiche jamais la lettre k toute seule,
  // donc on r√©utilise les m√™mes cha√Ænes num√©riques (kn, finalCoeff, etc.)
  // On affiche f(x)= [kPrefix](u(x))^n
  // et les lignes coh√©rentes avec ce coeff.
  const method2HTML = `
    <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>
      <div class="line">\\(f(x)=${kPrefix} (u(x))^{${n}}\\) \\( \\) avec :</div>
    <table class="uvtab">
      <tr>
        <td>\\(u(x)=${uLatex}\\)</td>
      </tr>
      <tr>
        <td>\\(u'(x)=${uPrimeLatex}\\)</td>
      </tr>
    </table>

    <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>

    <div class="line">\\(f'(x)= ${derivExpandedLatex}\\)</div>
    <div class="line">\\(f'(x)= ${finalLatexClean2}\\)</div>
  `;

  solHTML = `
  <div class="steps">
    <table class="twocol-solution">
      <tr>
        <td class="col-gauche">
          ${method1HTML}
        </td>
        <td class="col-droite">
          ${method2HTML}
        </td>
      </tr>
    </table>
  </div>`;

  // fonctions num√©riques pour check
  const uJS_inner = uJS;
  fJS = x => {
    const u = Function("x","return "+uJS_inner+";")(x);
    return k*Math.pow(u,n);
  };
  fpJS = x => {
    const u  = Function("x","return "+uJS_inner+";")(x);
    const du = uPrime;
    return k * n*Math.pow(u,n-1)*du;
  };



  } else {
    // kind==="sqrt"
    // ICI on change juste le tirage de k avec pickK()

    const k = pickK();
    const kPrefix = kPrefixFromK(k);

    const uPrimeLatex = String(uPrime);
    const uPrimePar   = (uPrime<0?`(${uPrimeLatex})`:uPrimeLatex);
    const uPrimePar2  = (uPrime<0?`${uPrimeLatex}`:uPrimeLatex);

    // f(x)=k‚àö(u(x))
    latexF =
      k===1
        ? `\\sqrt{${uLatex}}`
        : `${kPrefix}\\sqrt{${uLatex}}`;

    // g(x)=k‚àöx ; g'(x)=k/(2‚àöx) adapt√© d√©j√† existant
    let gPrimeLatex;
    if(k===1){
      gPrimeLatex = `\\dfrac{1}{2\\sqrt{x}}`;
    }else if(k===-1){
      gPrimeLatex = `-\\dfrac{1}{2\\sqrt{x}}`;
    }else{
      gPrimeLatex = `\\dfrac{${k}}{2\\sqrt{x}}`;
    }

    let fracGeneric_no1;
    if (k === 1) {
      fracGeneric_no1 = `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
    } else if (k === -1) {
      fracGeneric_no1 = `\\dfrac{-\\,u'(x)}{2\\sqrt{u(x)}}`;
    } else {
      fracGeneric_no1 = `\\dfrac{${k}\\,u'(x)}{2\\sqrt{u(x)}}`;
    }

    let fracExpanded_no1;
    if (k === 1) {
      fracExpanded_no1 = `\\dfrac{${uPrimePar2}}{2\\sqrt{${uLatex}}}`;
    } else if (k === -1) {
      fracExpanded_no1 = `\\dfrac{-\\,${uPrimePar}}{2\\sqrt{${uLatex}}}`;
    } else {
      fracExpanded_no1 = `\\dfrac{${k}\\times ${uPrimePar}}{2\\sqrt{${uLatex}}}`;
    }

    // fraction finale simplifi√©e avec division par 2 etc. (d√©j√† dans ta version)
    const rawNum = k*uPrime;
    function fracSimplif(n,d){
      if(n%d===0){ return [n/d,1]; }
      return [n,d];
    }
    const [simpNum,simpDen]=fracSimplif(rawNum,2);

    let finalFracLatex;
    if(simpDen===1){
      if(simpNum===1){
        finalFracLatex = `\\dfrac{1}{\\sqrt{${uLatex}}}`;
      }else if(simpNum===-1){
        finalFracLatex = `-\\dfrac{1}{\\sqrt{${uLatex}}}`;
      }else{
        finalFracLatex = `\\dfrac{${simpNum}}{\\sqrt{${uLatex}}}`;
      }
    }else{
      if(rawNum===1){
        finalFracLatex = `\\dfrac{1}{2\\sqrt{${uLatex}}}`;
      }else if(rawNum===-1){
        finalFracLatex = `-\\dfrac{1}{2\\sqrt{${uLatex}}}`;
      }else{
        finalFracLatex = `\\dfrac{${rawNum}}{2\\sqrt{${uLatex}}}`;
      }
    }

    enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)= ${latexF} \\]`;

    const method1HTML = `
      <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>

      <table class="uvtab">
        <tr>
          <td>\\(u(x)=${uLatex}\\)</td>
          <td>\\(g(x)=${kPrefix}\\sqrt{x}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=${uPrimeLatex}\\)</td>
          <td>\\(g'(x)=${gPrimeLatex}\\)</td>
        </tr>
        <tr>
          <td></td>
          <td>\\(g'(u(x))=\\dfrac{${k}}{2\\sqrt{u(x)}}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

      <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

      <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>

      <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
    `;

    let fxMethod2;
    if (k === 1) {
      fxMethod2 = `f(x)=\\sqrt{u(x)}`;
    } else if (k === -1) {
      fxMethod2 = `f(x)=-\\sqrt{u(x)}`;
    } else {
      fxMethod2 = `f(x)=${k}\\sqrt{u(x)}`;
    }

    const method2HTML = `
      <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>
      <div class="line">\\(${fxMethod2}\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr>
          <td>\\(u(x)=${uLatex}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=${uPrimeLatex}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=${fracGeneric_no1}\\)</div>

      <div class="line">\\(f'(x)=${fracExpanded_no1}\\)</div>

      <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
    `;

    solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>
          <td class="col-gauche">
            ${method1HTML}
          </td>
          <td class="col-droite">
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

    const uJS_inner = uJS;
    fJS = x => {
      const u = Function("x","return "+uJS_inner+";")(x);
      return k*Math.sqrt(u);
    };
    fpJS = x => {
      const u  = Function("x","return "+uJS_inner+";")(x);
      const du = uPrime;
      return k*du/(2*Math.sqrt(u));
    };
  }

  return {
    title,
    enonce,
    solHTML,
    latexF,
    fJS,
    fpJS,
    latexFp_raw: '',
    latexFp: ''
  };
}


/* =========================================================
   EXERCICE 2
   u(x) NON affine (polyn√¥me deg>=2 OU 1/x), g = puissance ou racine (avec coeff k)
   M√™me pr√©sentation 2 colonnes.
   ========================================================= */
function genEx2(mode){

  // fabrique A : f(x)=k*(P(x))^n, P polyn√¥me deg‚â•2
  function make_powPoly(){
    const P   = randPoly(2,3);
    const dP  = polyDeriv(P);
    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    const n = rnd(2,7);
    const k = pickK();
    const kPrefix = kPrefixFromK(k);

    // f(x) latex
    let fLatexForEnonce;
    if (k === 1){
      fLatexForEnonce = `(${Platex})^{${n}}`;
    } else if (k === -1){
      fLatexForEnonce = `-(${Platex})^{${n}}`;
    } else {
      fLatexForEnonce = `${kPrefix}(${Platex})^{${n}}`;
    }

    let fLatexForEnonce2;
    if (k === 1){
      fLatexForEnonce2 = `(u(x))^{${n}}`;
    } else if (k === -1){
      fLatexForEnonce2 = `-(u(x))^{${n}}`;
    } else {
      fLatexForEnonce2 = `${kPrefix}(u(x))^{${n}}`;
    }
	
    const title = "Exercice 2 : D√©rivation d‚Äôune compos√©e (u non affine)";
    const latexF = fLatexForEnonce;

    const enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)= ${fLatexForEnonce} \\]`;

    // M√©thode 1 avec g(x)=k x^n
    // kn = k*n
    const kn = k * n;

    // g(x)
    let gLatex;
    if (k === 1){
      gLatex = `x^{${n}}`;
    } else if (k === -1){
      gLatex = `-x^{${n}}`;
    } else {
      gLatex = `${kPrefix}x^{${n}}`;
    }

    // g'(x)
    let gPrimeNice;
    if (n === 2){
      gPrimeNice = `${kn}x`;
    } else {
      gPrimeNice = `${kn}x^{${n-1}}`;
    }

    // g'(u(x))
    let gPrimeComposeLatex;
    if (n === 2){
      gPrimeComposeLatex = `${kn}\\,u(x)`;
    } else {
      gPrimeComposeLatex = `${kn}\\,(u(x))^{${n-1}}`;
    }

    // u(x)=P(x), u'(x)=P'(x)
    // d√©riv√©e g√©n√©rique :
    const derivGeneric_uLatex =
      (n === 2)
        ? `${kn}\\,u(x)u'(x)`
        : `${kn}\\,(u(x))^{${n-1}}u'(x)`;

    // version d√©velopp√©e :
    const derivExpandedLatex =
      (n === 2)
        ? `${kn}\\,(${Platex}) (${dPlatex})`
        : `${kn}\\,(${Platex})^{${n-1}} (${dPlatex})`;

    // coeff final kn * (pas besoin de plus simple, on l'a d√©j√†)
    const finalLatexClean2 = derivExpandedLatex;

    const method1HTML = `
      <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr>
          <td>\\(u(x)=${Platex}\\)</td>
          <td>\\(g(x)=${gLatex}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=${dPlatex}\\)</td>
          <td>\\(g'(x)=${gPrimeNice}\\)</td>
        </tr>
        <tr>
          <td></td>
          <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>
      <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
      <div class="line">\\(f'(x)=${derivExpandedLatex}\\)</div>
    `;

    const method2HTML = `
      <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=${fLatexForEnonce2}\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr><td>\\(u(x)=${Platex}\\)</td></tr>
        <tr><td>\\(u'(x)=${dPlatex}\\)</td></tr>
      </table>

      <div class="line">\\(f'(x)=${derivGeneric_uLatex}\\)</div>
      <div class="line">\\(f'(x)=${derivExpandedLatex}\\)</div>
    `;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>
          <td class="col-gauche">
            ${method1HTML}
          </td>
          <td class="col-droite">
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);

    const fJS  = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      return k*Math.pow(u,n);
    };
    const fpJS = x => {
      const u  = Function("x","return ("+Pjs+");")(x);
      const du = Function("x","return ("+dPjs+");")(x);
      return k * n*Math.pow(u,n-1)*du;
    };

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // fabrique B : f(x)=k‚àö(P(x))
  function make_sqrtPoly(){
    const P   = randPoly(2,3);
    const dP  = polyDeriv(P);
    const Platex  = polyToLatex(P);
    const dPlatex = polyToLatex(dP);

    const k = pickK();
    const kPrefix = kPrefixFromK(k);

    // f(x) latex
    let fLatexForEnonce;
    if (k === 1){
      fLatexForEnonce = `\\sqrt{${Platex}}`;
    } else if (k === -1){
      fLatexForEnonce = `-\\sqrt{${Platex}}`;
    } else {
      fLatexForEnonce = `${kPrefix}\\sqrt{${Platex}}`;
    }
	
	  let fLatexForEnonce2;
    if (k === 1){
      fLatexForEnonce2 = `\\sqrt{u(x)}`;
    } else if (k === -1){
      fLatexForEnonce2 = `-\\sqrt{u(x)}`;
    } else {
      fLatexForEnonce2 = `${kPrefix}\\sqrt{u(x)}`;
    }
	
	
    const latexF = fLatexForEnonce;

    const title = "Exercice 2 : D√©rivation d‚Äôune compos√©e (u non affine)";
    const enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)= ${fLatexForEnonce} \\]`;

    // M√©thode 1 : g(x)=k‚àöx
    // On va r√©utiliser la m√™me mini-m√©canique que pour la racine affine :
    // fabriquer g(x), g'(x), g'(u(x)), et trois formes f'(x)

    // g(x)
    let gLatex;
    if (k === 1){
      gLatex = `\\sqrt{x}`;
    } else if (k === -1){
      gLatex = `-\\sqrt{x}`;
    } else {
      gLatex = `${kPrefix}\\sqrt{x}`;
    }

    // Pour la d√©riv√©e racine, on duplique le helper interne
    function derivSqrtCoeffLatex_poly(kVal, uLatexLocal){
      // Simplification du facteur k/(2‚àö(¬∑)), comme plus haut
      const rawNum = kVal;
      const rawDen = 2;
      let numAfter = rawNum;
      let denAfter = rawDen;
      if (rawNum % 2 === 0){
        numAfter = rawNum/2;
        denAfter = 1;
      }
      function fmtFrac(num, inside){
        if (denAfter===1){
          if (num===1){
            return `\\dfrac{1}{\\sqrt{${inside}}}`;
          }else if (num===-1){
            return `-\\dfrac{1}{\\sqrt{${inside}}}`;
          }else{
            return `\\dfrac{${num}}{\\sqrt{${inside}}}`;
          }
        }else{
          if (num===1){
            return `\\dfrac{1}{2\\sqrt{${inside}}}`;
          }else if (num===-1){
            return `-\\dfrac{1}{2\\sqrt{${inside}}}`;
          }else{
            return `\\dfrac{${num}}{2\\sqrt{${inside}}}`;
          }
        }
      }
      return {
        gx:        fmtFrac(numAfter,"x"),
        gu:        fmtFrac(numAfter,"u(x)"),
        gUexplicit:fmtFrac(numAfter,uLatexLocal)
      };
    }

    const dS = derivSqrtCoeffLatex_poly(k, Platex);
    const gPrimeLatex = dS.gx;
    const gPrimeOfU   = dS.gu;

    // forme symbolique f'(x)=g'(u(x))*u'(x)
    // On veut la m√™me structure en trois √©tages :
    // 1. u(x),u'(x)
    // 2. substitution P(x),P'(x)
    // 3. √©ventuellement simplification
    //
    // √âtape 1 g√©n√©rique :
    // On part de k * u'(x) / (2‚àö(u(x))) et on utilise le m√™me pattern de fraction
    function buildFracGeneric(kVal){
      const rawNum = kVal;
      const rawDen = 2;
      let numAfter = rawNum;
      let denAfter = rawDen;
      if (rawNum % 2 === 0){
        numAfter = rawNum/2;
        denAfter = 1;
      }
      if (denAfter===1){
        if (numAfter===1){
          return `\\dfrac{u'(x)}{\\sqrt{u(x)}}`;
        } else if (numAfter===-1){
          return `-\\dfrac{u'(x)}{\\sqrt{u(x)}}`;
        } else {
          return `\\dfrac{${numAfter}\\,u'(x)}{\\sqrt{u(x)}}`;
        }
      } else {
        if (numAfter===1){
          return `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
        } else if (numAfter===-1){
          return `-\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
        } else {
          return `\\dfrac{${numAfter}\\,u'(x)}{2\\sqrt{u(x)}}`;
        }
      }
    }

    const fracGeneric_u = buildFracGeneric(k);

    // √âtape 2 : substitution u'(x)=P'(x), u(x)=P(x)
    function buildFracExpanded(kVal, dPlatexLocal, PlatexLocal){
      const rawNum = kVal;
      const rawDen = 2;
      let numAfter = rawNum;
      let denAfter = rawDen;
      if (rawNum % 2 === 0){
        numAfter = rawNum/2;
        denAfter = 1;
      }
      if (denAfter===1){
        if (numAfter===1){
          return `\\dfrac{${dPlatexLocal}}{\\sqrt{${PlatexLocal}}}`;
        } else if (numAfter===-1){
          return `-\\dfrac{${dPlatexLocal}}{\\sqrt{${PlatexLocal}}}`;
        } else {
          return `\\dfrac{${numAfter}(${dPlatexLocal})}{\\sqrt{${PlatexLocal}}}`;
        }
      } else {
        if (numAfter===1){
          return `\\dfrac{${dPlatexLocal}}{2\\sqrt{${PlatexLocal}}}`;
        } else if (numAfter===-1){
          return `-\\dfrac{${dPlatexLocal}}{2\\sqrt{${PlatexLocal}}}`;
        } else {
          return `\\dfrac{${numAfter}(${dPlatexLocal})}{2\\sqrt{${PlatexLocal}}}`;
        }
      }
    }

    const fracExpanded = buildFracExpanded(k, dPlatex, Platex);
    const finalFracLatex = fracExpanded;

    const method1HTML = `
      <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr>
          <td>\\(u(x)=${Platex}\\)</td>
          <td>\\(g(x)=${gLatex}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=${dPlatex}\\)</td>
          <td>\\(g'(x)=${gPrimeLatex}\\)</td>
        </tr>
        <tr>
          <td></td>
          <td>\\(g'(u(x))=${gPrimeOfU}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

      <div class="line">\\(f'(x)=${fracGeneric_u}\\)</div>
      <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
    `;

    const method2HTML = `
      <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=${fLatexForEnonce2}\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr><td>\\(u(x)=${Platex}\\)</td></tr>
        <tr><td>\\(u'(x)=${dPlatex}\\)</td></tr>
      </table>

      <div class="line">\\(f'(x)=${fracGeneric_u}\\)</div>
      <div class="line">\\(f'(x)= ${finalFracLatex}\\)</div>
    `;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>
          <td class="col-gauche">
            ${method1HTML}
          </td>
          <td class="col-droite">
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

    const Pjs  = polyToJS(P);
    const dPjs = polyToJS(dP);

    const fJS  = x => {
      const u = Function("x","return ("+Pjs+");")(x);
      return k*Math.sqrt(u);
    };
    const fpJS = x => {
      const u  = Function("x","return ("+Pjs+");")(x);
      const du = Function("x","return ("+dPjs+");")(x);
      return k*du/(2*Math.sqrt(u));
    };

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // fabrique C : f(x)=k*(1/x)^n
  function make_powInv(){
    const n = rnd(2,6);
    const k = pickK();
    const kPrefix = kPrefixFromK(k);

    // f(x)
    let fLatexForEnonce;
    if (k === 1){
      fLatexForEnonce = `\\left(\\dfrac{1}{x}\\right)^{${n}}`;
    } else if (k === -1){
      fLatexForEnonce = `-\\left(\\dfrac{1}{x}\\right)^{${n}}`;
    } else {
      fLatexForEnonce = `${kPrefix}\\left(\\dfrac{1}{x}\\right)^{${n}}`;
    }
	
	 let fLatexForEnonce2;
    if (k === 1){
      fLatexForEnonce2 = `\\big(u(x)\\big)^{${n}}`;
    } else if (k === -1){
      fLatexForEnonce2 = `-\\big(u(x)\\big)^{${n}}`;
    } else {
      fLatexForEnonce2 = `${kPrefix}\\big(u(x)\\big)^{${n}}`;
    }
	
	
    const latexF = fLatexForEnonce;

    const title = "Exercice 2 : D√©rivation d‚Äôune compos√©e (u non affine)";
    const enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles `+
      `de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)= ${fLatexForEnonce} \\]`;

    // M√©thode 1 :
    // u(x)=1/x, u'(x)=-1/x¬≤
    // g(x)=k x^n
    // g'(x)=k n x^{n-1}
    // etc.

    // g(x)
    let gLatex;
    if (k === 1){
      gLatex = `x^{${n}}`;
    } else if (k === -1){
      gLatex = `-x^{${n}}`;
    } else {
      gLatex = `${kPrefix}x^{${n}}`;
    }

    const kn = k * n;
    let gPrimeNice;
    if (n === 2){
      gPrimeNice = `${kn}x`;
    } else {
      gPrimeNice = `${kn}x^{${n-1}}`;
    }

    let gPrimeComposeLatex;
    if (n === 2){
      gPrimeComposeLatex = `${kn}\\,u(x)`;
    } else {
      gPrimeComposeLatex = `${kn}\\,\\big(u(x)\\big)^{${n-1}}`;
    }

    // d√©riv√©e g√©n√©rique :
    // f'(x)= kn * (u(x))^{n-1} * u'(x)
    // avec u'(x)=-1/x¬≤
    const derivGeneric_uLatex =
      (n === 2)
        ? `${kn}\\,u(x)\\,u'(x)`
        : `${kn}\\,\\big(u(x)\\big)^{${n-1}}\\,u'(x)`;

    // version d√©velopp√©e :
    //  kn * (1/x)^{n-1} * (-1/x^2) = -kn / x^{n+1}
const coefFinal = -kn;       // -(k*n)  -> c'est le vrai coeff final numerique










// derni√®re ligne avec le bon signe simplifi√© :
const finalFracLatex = `\\dfrac{${coefFinal}}{x^{${n+1}}}`;

    const derivExpandedLatex =
      (n === 2)
        ? `${kn}\\,\\left(\\dfrac{1}{x}\\right) \\times \\left(-\\dfrac{1}{x^{2}}\\right)`
        : `${kn}\\,\\left(\\dfrac{1}{x}\\right)^{${n-1}} \\times \\left(-\\dfrac{1}{x^{2}}\\right)`;

    const method1HTML = `
      <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr>
          <td>\\(u(x)=\\dfrac{1}{x}\\)</td>
          <td>\\(g(x)=${gLatex}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td>
          <td>\\(g'(x)=${gPrimeNice}\\)</td>
        </tr>
        <tr>
          <td></td>
          <td>\\(g'(u(x))=${gPrimeComposeLatex}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

      <div class="line">
        \\(f'(x)= ${derivGeneric_uLatex}\\)
      </div>

      <div class="line">
        \\(f'(x)= ${derivExpandedLatex}\\)
      </div>

      <div class="line">
        \\(f'(x)= ${finalFracLatex}\\)
      </div>
    `;

    const method2HTML = `
      <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

      <div class="line">
        \\(f(x)=${fLatexForEnonce2}\\) \\( \\) avec :
      </div>
      <table class="uvtab">
        <tr><td>\\(u(x)=\\dfrac{1}{x}\\)</td></tr>
        <tr><td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td></tr>
      </table>

      <div class="line">
        \\(f'(x)= ${derivGeneric_uLatex}\\)
      </div>

      <div class="line">
        \\(f'(x)= ${derivExpandedLatex}\\)
      </div>

      <div class="line">
        \\(f'(x)= ${finalFracLatex}\\)
      </div>
    `;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>

          <td class="col-gauche">
            ${method1HTML}
          </td>

          <td class="col-droite">
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

    const fJS  = x => k*Math.pow(1/x,n);
    const fpJS = x => {
      // d√©riv√©e analytique : k * (-n) / x^(n+1)
      return -k*n*Math.pow(x,-(n+1));
    };

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // fabrique D : f(x)=k‚àö(1/x)
  function make_sqrtInv(){
    const k = pickK();
    const kPrefix = kPrefixFromK(k);

    // f(x)
    let fLatexForEnonce;
    if (k === 1){
      fLatexForEnonce = `\\sqrt{\\dfrac{1}{x}}`;
    } else if (k === -1){
      fLatexForEnonce = `-\\sqrt{\\dfrac{1}{x}}`;
    } else {
      fLatexForEnonce = `${kPrefix}\\sqrt{\\dfrac{1}{x}}`;
    }
	
	 let fLatexForEnonce2;
    if (k === 1){
      fLatexForEnonce2 = `\\sqrt{u(x)}`;
    } else if (k === -1){
      fLatexForEnonce2 = `-\\sqrt{u(x)}`;
    } else {
      fLatexForEnonce2 = `${kPrefix}\\sqrt{u(x)}`;
    }
	
	
    const latexF = fLatexForEnonce;

    const title = "Exercice 2 : D√©rivation d‚Äôune compos√©e (u non affine)";
    const enonce =
      `D√©river la fonction suivante, sans se pr√©occuper des ensembles `+
      `de d√©finition/d√©rivabilit√© :<br><br>`+
      `\\[ f(x)= ${fLatexForEnonce} \\]`;

    // M√©thode 1 :
    // u(x)=1/x
    // g(x)=k‚àöx
    // g'(x)=k/(2‚àöx) simplifi√© num√©riquement
    // u'(x)=-1/x¬≤
    //
    // m√™me logique que racine poly/affine mais avec u(x)=1/x

    // g(x)
    let gLatex;
    if (k === 1){
      gLatex = `\\sqrt{x}`;
    } else if (k === -1){
      gLatex = `-\\sqrt{x}`;
    } else {
      gLatex = `${kPrefix}\\sqrt{x}`;
    }

    // helper d√©riv√©e racine comme avant
    function derivSqrtCoeffLatex_inv(kVal){
      const rawNum = kVal;
      const rawDen = 2;
      let numAfter = rawNum;
      let denAfter = rawDen;
      if (rawNum % 2 === 0){
        numAfter = rawNum/2;
        denAfter = 1;
      }
      function fmtFrac(num, inside){
        if (denAfter===1){
          if (num===1){
            return `\\dfrac{1}{\\sqrt{${inside}}}`;
          }else if (num===-1){
            return `-\\dfrac{1}{\\sqrt{${inside}}}`;
          }else{
            return `\\dfrac{${num}}{\\sqrt{${inside}}}`;
          }
        }else{
          if (num===1){
            return `\\dfrac{1}{2\\sqrt{${inside}}}`;
          }else if (num===-1){
            return `-\\dfrac{1}{2\\sqrt{${inside}}}`;
          }else{
            return `\\dfrac{${num}}{2\\sqrt{${inside}}}`;
          }
        }
      }
      return {
        gx:  fmtFrac(numAfter,"x"),
        gu:  fmtFrac(numAfter,"u(x)"),
        gUexplicit: fmtFrac(numAfter,"\\dfrac{1}{x}")
      };
    }

    const dS = derivSqrtCoeffLatex_inv(k);
    const gPrimeLatex = dS.gx;
    const gPrimeOfU   = dS.gu;

    // f'(x)=g'(u(x))*u'(x)
    // u'(x) = -1/x¬≤
    // On reprend notre logique en trois √©tages.

    function buildFracGeneric(kVal){
      const rawNum = kVal;
      const rawDen = 2;
      let numAfter = rawNum;
      let denAfter = rawDen;
      if (rawNum % 2 === 0){
        numAfter = rawNum/2;
        denAfter = 1;
      }

      // numAfter * u'(x) / (2‚àö(u(x))) avec u'(x) symbolique
      // ici u'(x) = -1/x¬≤ mais pour la premi√®re ligne on laisse "u'(x)"
      if (denAfter===1){
        if (numAfter===1){
          return `\\dfrac{u'(x)}{\\sqrt{u(x)}}`;
        } else if (numAfter===-1){
          return `-\\dfrac{u'(x)}{\\sqrt{u(x)}}`;
        } else {
          return `\\dfrac{${numAfter}\\,u'(x)}{\\sqrt{u(x)}}`;
        }
      } else {
        if (numAfter===1){
          return `\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
        } else if (numAfter===-1){
          return `-\\dfrac{u'(x)}{2\\sqrt{u(x)}}`;
        } else {
          return `\\dfrac{${numAfter}\\,u'(x)}{2\\sqrt{u(x)}}`;
        }
      }
    }

    const fracGeneric_u = buildFracGeneric(k);

    // √âtape 2 : remplacer u'(x)=-1/x¬≤ et u(x)=1/x
    function buildFracExpanded(kVal){
      const rawNum = kVal;
      const rawDen = 2;
      let numAfter = rawNum;
      let denAfter = rawDen;
      if (rawNum % 2 === 0){
        numAfter = rawNum/2;
        denAfter = 1;
      }

      // numAfter * (-1/x¬≤)
      // -> si numAfter=1 : -(1/x¬≤)
      // -> si numAfter=-1 : +1/x¬≤
      // -> sinon : numAfter * (-1/x¬≤)

      function numTimesMinusOneOverX2(num){
        if(num===1){
          return `-\\dfrac{1}{x^{2}}`;
        }else if(num===-1){
          return `\\dfrac{1}{x^{2}}`; // (-1)*(-1)=+1
        }else{
          // ex 4 * (-1/x¬≤) = -4/x¬≤
          if(num>0){
            return `-\\dfrac{${num}}{x^{2}}`;
          }else{
            // num<0
            const absn = Math.abs(num);
            return `\\dfrac{${absn}}{x^{2}}`;
          }
        }
      }

      const numOverX2 = numTimesMinusOneOverX2(numAfter);

      if (denAfter===1){
        // numOverX2 / ‚àö(1/x)
        return `\\dfrac{${numOverX2}}{\\sqrt{\\dfrac{1}{x}}}`;
      } else {
        // numOverX2 / (2‚àö(1/x))
        return `\\dfrac{${numOverX2}}{2\\sqrt{\\dfrac{1}{x}}}`;
      }
    }

    const fracExpanded = buildFracExpanded(k);

    // √âtape 3 : forme finale simplifi√©e.  
    // Ta version finale pour sqrtInv dans l‚Äôancienne logique donnait
    //   f'(x)= [-(k‚àöx)]/(2x¬≤)
    // qu‚Äôon simplifiait en un coeff unique devant ‚àöx / x¬≤.
    //
    // On va la recalculer proprement :
    //
    // Th√©orie :
    // f(x)=k*(1/x)^{1/2}=k*x^{-1/2}
    // f'(x)=k*(-1/2)*x^{-3/2}= -(k/2) * sqrt(x)/x^2
    // => coefficient = -(k/2)
    //
    // Simplif ce coeff :
    const coef_brut = -k; // puis /2 √† g√©rer
    let finalLatex;
    if (coef_brut % 2 === 0){
      const half = coef_brut/2; // entier
      if (half === 1){
        finalLatex = `\\dfrac{\\sqrt{x}}{x^{2}}`;
      } else if (half === -1){
        finalLatex = `-\\dfrac{\\sqrt{x}}{x^{2}}`;
      } else if (half === 0){
        finalLatex = `0`;
      } else if (half > 0){
        finalLatex = `\\dfrac{${half}\\,\\sqrt{x}}{x^{2}}`;
      } else {
        const absHalf = Math.abs(half);
        finalLatex = `-\\dfrac{${absHalf}\\,\\sqrt{x}}{x^{2}}`;
      }
    } else {
      // pas divisible par 2 ‚Üí coef_brut/(2...)
      if (coef_brut === 1){
        finalLatex = `\\dfrac{\\sqrt{x}}{2x^{2}}`;
      } else if (coef_brut === -1){
        finalLatex = `-\\dfrac{\\sqrt{x}}{2x^{2}}`;
      } else if (coef_brut > 0){
        finalLatex = `\\dfrac{${coef_brut}\\,\\sqrt{x}}{2x^{2}}`;
      } else {
        const absCoef = Math.abs(coef_brut);
        finalLatex = `-\\dfrac{${absCoef}\\,\\sqrt{x}}{2x^{2}}`;
      }
    }

    const method1HTML = `
      <div class="line"><strong>1<sup>re</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=g(u(x))\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr>
          <td>\\(u(x)=\\dfrac{1}{x}\\)</td>
          <td>\\(g(x)=${gLatex}\\)</td>
        </tr>
        <tr>
          <td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td>
          <td>\\(g'(x)=${gPrimeLatex}\\)</td>
        </tr>
        <tr>
          <td></td>
          <td>\\(g'(u(x))=${gPrimeOfU}\\)</td>
        </tr>
      </table>

      <div class="line">\\(f'(x)=g'(u(x))\\times u'(x)\\)</div>

      <div class="line">\\(f'(x)=${fracGeneric_u}\\)</div>

      <div class="line">\\(f'(x)=${fracExpanded}\\)</div>

      <div class="line">\\(f'(x)= ${finalLatex}\\)</div>
    `;

    const method2HTML = `
      <div class="line"><strong>2<sup>e</sup> m√©thode :</strong></div>

      <div class="line">\\(f(x)=${fLatexForEnonce2}\\) \\( \\) avec :</div>
      <table class="uvtab">
        <tr><td>\\(u(x)=\\dfrac{1}{x}\\)</td></tr>
        <tr><td>\\(u'(x)=-\\dfrac{1}{x^{2}}\\)</td></tr>
      </table>

      <div class="line">\\(f'(x)=${fracGeneric_u}\\)</div>

      <div class="line">\\(f'(x)=${fracExpanded}\\)</div>

      <div class="line">\\(f'(x)= ${finalLatex}\\)</div>
    `;

    const solHTML = `
    <div class="steps">
      <table class="twocol-solution">
        <tr>
          <td class="col-gauche">
            ${method1HTML}
          </td>

          <td class="col-droite">
            ${method2HTML}
          </td>
        </tr>
      </table>
    </div>`;

    const fJS  = x => k * Math.sqrt(1/x);
    const fpJS = x => (-(k*Math.sqrt(x)) / (2*x*x));

    return {
      title,
      enonce,
      solHTML,
      latexF,
      fJS,
      fpJS,
      latexFp_raw:'',
      latexFp:''
    };
  }

  // ----- Choix du sc√©nario -----
  function pickScenario(){
    if(mode === 'powPoly')   return make_powPoly;
    if(mode === 'sqrtPoly')  return make_sqrtPoly;
    if(mode === 'powInv')    return make_powInv;
    if(mode === 'sqrtInv')   return make_sqrtInv;
    // mode === 'mix2' ou inconnu
    return choice([make_powPoly, make_sqrtPoly, make_powInv, make_sqrtInv]);
  }

  const scenario = pickScenario();
  return scenario();
}







/* =========================================================
   RENDU BLOC EXO + v√©rification
   ========================================================= */
function buildHostHTML(st, exoId){
  // exoId sera "exo1" ou "exo2"

  let selectorHTML = '';
  if(exoId === 'exo1'){
    selectorHTML = `
      <label style="font-weight:600;margin-right:.4rem;">Forme :</label>
      <select class="kind-select" style="padding:4px 6px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
        <option value="mix1">M√©lange</option>
        <option value="powAffine">(ax+b)^n</option>
        <option value="sqrtAffine">k‚àö(ax+b)</option>
      </select>
    `;
  } else if(exoId === 'exo2'){
    selectorHTML = `
      <label style="font-weight:600;margin-right:.4rem;">Forme :</label>
      <select class="kind-select" style="padding:4px 6px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
        <option value="mix2">M√©lange</option>
        <option value="powPoly">(P(x))^n</option>
        <option value="sqrtPoly">k‚àö(P(x))</option>
        <option value="powInv">(1/x)^n</option>
        <option value="sqrtInv">k‚àö(1/x)</option>
      </select>
    `;
  }

  return `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>

      <div style="display:flex;flex-wrap:wrap;align-items:center;gap:.5rem .75rem;margin-bottom:.6rem;">
        ${selectorHTML}
      </div>

      <div class="enonce">${st.enonce}</div>

      <div class="answers">
        <div class="qa-row">
          <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
          <input id="ansF" class="inp" style="min-width:360px">
          <span id="tickF" class="tick" style="margin-left:6px"></span>
        </div>
      </div>

      <div id="res"></div>
    </div>
  `;
}


function setTick(ok){
  const el = $('#tickF');
  if(!el) return;
  el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
  el.textContent = ok===true?'‚úì': ok===false?'‚úó':'‚Äî';
}

function pickSafeXs(st){
  // On essaie de deviner le type d'exercice √† partir de st.latexF
  // (on l'a d√©j√† dans le state qu'on stocke pour le PDF)
  const F = st.latexF || "";

  // Cas racine simple k‚àö(ax+b) ou k‚àö( ‚Ä¶ )
  // ‚Üí on veut des x pour lesquels l'int√©rieur de la racine est strictement > 0
  //   ET pas nul (car f' a ‚àö(u(x)) au d√©nominateur).
  //
  // On va essayer de d√©tecter deux patterns faciles :
  //  - k‚àö(ax+b)
  //  - k‚àö(1/x)
  //
  // Sinon, fallback : on renvoie les x par d√©faut.

  // helper s√©curis√©e : essaie d'√©valuer ref fpJS(x), si c'est un nombre fini c'est bon
  function isSafeX(x){
    try{
      const v = st.fpJS(x);
      return Number.isFinite(v);
    }catch(e){
      return false;
    }
  }

  // on part d'une "pool" de candidats assez large
  // pour couvrir n√©gatif/positif et √©viter 0 trop souvent
  const pool = [
    -5,-3,-2,-1,-0.5,-0.2,
     0.1,0.2,0.5,1,1.2,1.8,2.5,3.7,4,4.5,5.1
  ];

  const xs=[];
  for(const x of pool){
    if(isSafeX(x)) xs.push(x);
    if(xs.length>=5) break; // on en garde ~5 max
  }

  // Si jamais on n'en a trouv√© aucun (cas ultra tordu),
  // on renvoie quand m√™me quelques valeurs "classiques"
  // pour √©viter plantage.
  if(xs.length===0){
    return [1,2,3];
  }
  return xs;
}



function checkAnswer(st){
  const inp = $('#ansF');
  if(!inp){
    setTick(null);
    return {count:0,good:0};
  }

  const val = inp.value||'';
  if(!val.trim()){
    setTick(null);
    return {count:0,good:0};
  }

  // filtre anti-"lllgffffd"
  const looksMathy = /[0-9x‚àö\/\*\^\(\)]|sqrt|rac/.test(val.replace(/\s+/g,''));
  if(!looksMathy){
    setTick(false);
    return {count:1, good:0};
  }

  const xs = pickSafeXs(st);

  let ok = true;
  let compared = 0;

  for(const x of xs){
    const got = numEval(val,x);
    const ref = st.fpJS(x);

    if(!Number.isFinite(got) || !Number.isFinite(ref)){
      continue;
    }

    compared++;

    if(!almost(got,ref,1e-6)){
      ok = false;
      break;
    }
  }

  // CHANGEMENT ICI
  if (compared === 0){
    ok = false;
  }

  setTick(ok);
  return {count:1, good:(ok?1:0)};
}



/* =========================================================
   REGISTRY
   ========================================================= */
const EXO1 = {
  id:'exo1',
  title:'Exercice 1 ‚Äî u affine',
 gen(host){
  // lire le mode actuel SI l'h√¥te appartient d√©j√† √† EXO1,
  // sinon retomber sur 'mix1'
  let mode = 'mix1';
  if(host && host.dataset && host.dataset.exoId === 'exo1'){
    const sel = host.querySelector('.kind-select');
    if(sel && sel.value){
      mode = sel.value;
    }
  }

  // si mode n'est pas une option valide pour EXO1, on remet 'mix1'
  if(mode!=='mix1' && mode!=='powAffine' && mode!=='sqrtAffine'){
    mode='mix1';
  }

  const st = genEx1(mode);

  if(host){
    host.innerHTML = buildHostHTML(st, 'exo1');
    host.__state   = st;
    host.dataset.state = JSON.stringify({
      title:st.title,
      enonce:st.enonce,
      latexF:st.latexF,
      latexFp:st.latexFp||'',
      latexFp_raw:st.latexFp_raw||'',
      solHTML:st.solHTML
    });
    host.dataset.exoId = 'exo1'; // <--- IMPORTANT, pour savoir qui √©tait l√† avant

    const sel2 = host.querySelector('.kind-select');
    if(sel2){
      sel2.value = mode;
      sel2.addEventListener('change', ()=>{
        this.gen(host);
        if(window.MathJax?.typeset) MathJax.typeset();
        scanFractions(host);
      });
    }

    if(window.MathJax?.typeset) MathJax.typeset();
    scanFractions(host);
  }
  return st;
},

  correct(host,st){
    const r=checkAnswer(st);
    scoreTot+=r.count;
    scoreOK +=r.good;
    updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML=st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent='';
    setTick(null);
    const inp=$('#ansF',host);
    if(inp) inp.value='';
  }
};

const EXO2 = {
  id:'exo2',
  title:'Exercice 2 ‚Äî u non affine',
  gen(host){
  let mode = 'mix2';
  if(host && host.dataset && host.dataset.exoId === 'exo2'){
    const sel = host.querySelector('.kind-select');
    if(sel && sel.value){
      mode = sel.value;
    }
  }

  // s√©curit√© : clamp sur les valeurs autoris√©es pour exo2
  if(mode!=='mix2' && mode!=='powPoly' && mode!=='sqrtPoly' && mode!=='powInv' && mode!=='sqrtInv'){
    mode='mix2';
  }

  const st = genEx2(mode);

  if(host){
    host.innerHTML = buildHostHTML(st, 'exo2');
    host.__state   = st;
    host.dataset.state = JSON.stringify({
      title:st.title,
      enonce:st.enonce,
      latexF:st.latexF,
      latexFp:st.latexFp||'',
      latexFp_raw:st.latexFp_raw||'',
      solHTML:st.solHTML
    });
    host.dataset.exoId = 'exo2'; // marquer l'origine

    const sel2 = host.querySelector('.kind-select');
    if(sel2){
      sel2.value = mode;
      sel2.addEventListener('change', ()=>{
        this.gen(host);
        if(window.MathJax?.typeset) MathJax.typeset();
        scanFractions(host);
      });
    }

    if(window.MathJax?.typeset) MathJax.typeset();
    scanFractions(host);
  }
  return st;
},

  correct(host,st){
    const r=checkAnswer(st);
    scoreTot+=r.count;
    scoreOK +=r.good;
    updateScore();
  },
  solution(host,st){
    $('#res',host).innerHTML=st.solHTML;
    if(window.MathJax?.typeset) MathJax.typeset();
  },
  reset(host){
    $('#res',host).textContent='';
    setTick(null);
    const inp=$('#ansF',host);
    if(inp) inp.value='';
  }
};


const REG=[EXO1,EXO2];
window.REG=REG;
window.REGISTRY=REG;

/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); 
  if(!sel) return;

  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host,host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host,host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}

document.addEventListener('DOMContentLoaded', mount);

/* =========================================================
   Adaptateur PDF : version iframe SVG
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try {
          st = JSON.parse(hostTmp.dataset.state || '{}');
        } catch(_){}
        return st;
      },




      // >>>>>>>>>>>>> async PROMISE RETURN
  beforeRender(def, st, withSolutions){
  return (async () => {
    let host = null;
    try {

      // 1. Construire un host OFFSCREEN juste pour r√©cup√©rer l'√©tat (mais SANS typeset √©cran)
      host = document.createElement('div');
      host.id = 'pdf-host';
      host.style.position='fixed';
      host.style.left='-10000px';
      host.style.top='-10000px';
      document.body.appendChild(host);

      // on DOIT recr√©er l'enonc√© de base
      host.innerHTML = buildHostHTML(st);
      host.dataset.state = JSON.stringify(st);

      // üëâ‚ö† NE PAS appeler def.solution(host, st) ici,
      //    car √ßa MathJax-typeset en CHTML et flingue le LaTeX brut.

      // 2. Construire le HTML qu'on veut envoyer dans le PDF
      //    - si withSolutions === false : on prend juste l'√©nonc√© tel quel
      //    - si withSolutions === true  : on fabrique nous-m√™me un bloc
      //      qui contient st.solHTML (non encore typeset).
      let innerHTML_for_pdf;
if (withSolutions){
  innerHTML_for_pdf = `
    <div class="exo-block">
      <span class="exo-title">${st.title}</span>
      <div class="enonce">
        ${st.enonce}
        <div style="margin-top:1rem;font-weight:600">Corrig√© :</div>
      </div>
      ${st.solHTML}
    </div>
  `;
} else {
  innerHTML_for_pdf = host.innerHTML;
}


      // 3. IFRAME sandbox pour MathJax SVG ...
      // (le reste de ton code continue comme avant)


      // 2. Cr√©er l'iframe sandbox
      const iframe = document.createElement('iframe');
      iframe.style.position   = 'fixed';
      iframe.style.left       = '-10000px';
      iframe.style.top        = '-10000px';
      iframe.style.width      = '0';
      iframe.style.height     = '0';
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);

      const iwin = iframe.contentWindow;
      const idoc = iframe.contentDocument;

      // 3. √âcrire un DOM minimal dans l'iframe
      // pas de <script> ici pour √©viter de casser notre propre <script> parent
      idoc.open();
      idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
      idoc.close();
// 4. Injecter le contenu (√©nonc√©/solution) dans l'iframe
const contentDiv = idoc.getElementById('content');
contentDiv.innerHTML = innerHTML_for_pdf;

// üîß IMPORTANT : on vire toute trace d'anciens rendus MathJax CHTML
// (dans le host original il y a d√©j√† des <mjx-container jax="CHTML">...</mjx-container> )
// On veut repartir du LaTeX brut pour que MathJax SVG refasse tout proprement.

contentDiv.querySelectorAll('mjx-container').forEach(mjx => {
  // On essaie de r√©cup√©rer le tex d'origine si MathJax l'a gard√© en commentaire,
  // sinon on remplace par juste le texte rendu (fallback).
  // Mais dans notre cas, comme l'innerHTML_for_pdf vient AVANT typeset dans l'iframe,
  // il devrait d√©j√† contenir le LaTeX source (\( ... \)). Donc en pratique,
  // ce bloc servira surtout si jamais un ancien mjx traine.
  mjx.replaceWith(mjx.textContent || '');
});

// Enlever aussi l'accessibilit√© MathML pr√©-existante (au cas o√π)
contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml')
  .forEach(n => n.remove());


      // 5. Pr√©parer MathJax SVG dans l'iframe
      //    a) script config MathJax
      const cfg = idoc.createElement('script');
      cfg.type = 'text/javascript';
      cfg.text = `
        window.MathJax = {
          tex: {
            inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
            displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
            processEscapes: true,
            packages: { '[+]': ['bbox','ams'] }
          },
          svg: {
            fontCache: 'none'
          },
          options: {
            skipHtmlTags: ['script','noscript','style','textarea']
          },
          startup: { typeset: false }
        };
      `;
      idoc.head.appendChild(cfg);

      //    b) script tex-svg.js (URL absolue pour √™tre s√ªr)
      const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
      const mj = idoc.createElement('script');
      mj.type = 'text/javascript';
      mj.src  = svgScriptURL;
      idoc.head.appendChild(mj);

// 6. Attendre que tex-svg.js soit charg√© puis typer
await new Promise(resolve=>{
  mj.onload = resolve;
  mj.onerror = resolve; // on r√©sout quand m√™me m√™me si √ßa plante
});

// s√©curit√©: attendre que MathJax initialise typesetPromise
async function waitMathJaxReady(win){
  const limit = 200;
  let n = 0;
  while (
    (!win.MathJax) ||
    (!win.MathJax.typesetPromise && !win.MathJax.typeset)
  ){
    await new Promise(res=>setTimeout(res,5));
    n++;
    if(n>limit) break;
  }
}
await waitMathJaxReady(iwin);

// 7. Faire le typeset SVG dans l'iframe
if (iwin.MathJax && iwin.MathJax.typesetPromise){
  await iwin.MathJax.typesetPromise([ contentDiv ]);
} else if (iwin.MathJax && iwin.MathJax.typeset){
  iwin.MathJax.typeset([ contentDiv ]);
}

// 8. *** NETTOYAGE ANTI-DOUBLON ***
//    On enl√®ve la version CHTML h√©rit√©e de l'√©cran et on garde la version SVG.
(function purgeCHTML(){
  // 1. Supprimer les conteneurs CHTML de l'√©cran s'ils existent
  //    (dans ta page √©cran, MathJax CHTML g√©n√®re <mjx-container jax="CHTML"> ...)
  contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n => n.remove());

  // 2. Certains contenus d'origine peuvent encore contenir du texte LaTeX brut
  //    suivi d'un conteneur SVG g√©n√©r√©. Ex :
  //      "f'(x)=" <mjx-container jax="SVG">...</mjx-container>
  //    ‚Üí √ßa va, on garde.

  // 3. Option belt & suspenders :
  //    Si jamais MathJax SVG a clon√© au lieu de remplacer, on vire les doublons restants
  //    du type <mjx-container jax="CHTML"> m√™me imbriqu√©s.
  contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n => n.remove());

  // 4. On enl√®ve les aides d‚Äôaccessibilit√© inutiles pour le PDF
  contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n => n.remove());
})();

// 9. R√©cup√©rer le HTML final (ne contenant plus que le SVG)
const finalHTML = contentDiv.innerHTML;

// 10. Nettoyage DOM temporaire
iframe.remove();
if (host) host.remove();

// 11. Retourner le HTML pr√™t pour le PDF
return finalHTML;


    } catch(e){
      console.error('beforeRender SVG error:', e);

      let fallbackHTML = '';
      if (host) {
        fallbackHTML = withSolutions
          ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
          : host.innerHTML;
        host.remove();
        host = null;
      }
      return fallbackHTML;
    }
  })(); // IIFE async
}

    }); // <-- FERMETURE ExoPDF.init
  }); // <-- FERMETURE addEventListener DOMContentLoaded
})(); // <-- FERMETURE IIFE global

/* ===== tweaks mobile ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r=parseFloat(c.getAttribute('r')||'5');
      if(r<10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
},{passive:true});
</script>

</body>
</html>
