<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1Ã¨re STI2D â€“ Ã‰tude de fonctions â€¢ Lien entre le signe de la dÃ©rivÃ©e et les variations d'une fonction f</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  /* mini tableaux â€œPDF-likeâ€ (cadre extÃ©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* BÃ‚TONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  /* 1 barre centrale (vide ou avec 0) */
  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }
  /* 0 plus grand mais moins Ã©pais */
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.zbar {
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }
  table.pdf-tbl td.zbar { font-weight:400!important; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* cellule ext (max/min) dans la ligne de f */
  .ext-cell{
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
  }
  .ext-cell input[type="text"]{
    width:70px;
    max-width:100%;
    font-size:.9rem;
    padding:2px 4px;
  }

  /* Affichage conditionnel */
  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  /* Tableau QCM (Ã©cran) */
  .table-qcm-screen{
    width:100%;
    border-collapse:separate;
    border-spacing:12px 8px;
  }
  .table-qcm-screen td{ width:50%; vertical-align:top }
  .table-qcm-screen .cell{
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
  }
  .table-qcm-screen .num{ font-weight:700; margin-right:6px }
  .table-qcm-screen select{ margin-left:8px }

  /* 2 barres (||) â€” Ã©cart RESSERRÃ‰ */
  table.pdf-tbl td.dbar::before,
  table.pdf-tbl td.dbar::after{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    border-left:2px solid #000;
  }
  table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
  table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }
  
  /* mini-table u,v / u',v' (comme fiche Quotient / Inverse) */
.uvtab{
  border-collapse:collapse;
  margin:.6rem 0 .8rem 0;
  font-size:0.95rem;
}
.uvtab td{
  border:none;
  padding:4px 32px 4px 0;
  white-space:nowrap;
  vertical-align:top;
  line-height:1.6;
}
@media print{
  .uvtab td{ padding:4px 40px 4px 0; }
}
/* tableau invisible pour le dÃ©veloppement de f'(x) */
.devtab{
  border-collapse:collapse;
  margin:.4rem 0 .2rem 0;
  font-size:0.95rem;
}
.devtab td{
  border:none;
  padding:2px 6px;
  white-space:nowrap;
  vertical-align:middle;
}


  
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1Ã¨re STI2D â€“ Ã‰tude de fonctions â€¢ Lien entre le signe de la dÃ©rivÃ©e et les variations d'une fonction f</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplissez dans la saisie du haut si <b>maximum</b> et dans la saisie du bas si <b>minimum</b> (valeur de \(f(x)\)).</li>
        <li>FlÃ¨ches : choisissez â†˜ ou â†—.</li>
        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, Ã©crire une liste. Exemple : -3;2</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* â€”â€”â€”â€”â€” Utils â€”â€”â€”â€”â€” */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='âˆ’';
function cleanSigns(s){
  if(!s) return s;
  let out = String(s);

  // 1) on ramÃ¨ne tous les "âˆ’" unicode en "-"
  out = out.replace(/\u2212/g, '-');

  // 2) on nettoie les espaces
  out = out.replace(/\s+/g,' ').trim();

  // 3) on simplifie les combinaisons de signes
  out = out.replace(/\+\s*-\s*/g, ' - ');
  out = out.replace(/-\s*-\s*/g, ' + ');
  out = out.replace(/\+\s*\+\s*/g, ' + ');
  out = out.replace(/-\s*\+\s*/g, ' - ');
  out = out.replace(/^\+\s*/,'');
  out = out.replace(/\s+/g,' ').trim();

  // 4) on repasse tous les "-" en "âˆ’" pour l'affichage
  return out.replace(/-/g, UMIN);
}

function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){
  if(!el) return null;

  // 1) si le prochain Ã©lÃ©ment est dÃ©jÃ  un tick, on le rÃ©utilise
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) {
    return s;
  }

  // 2) sinon on crÃ©e TOUJOURS un nouveau tick juste aprÃ¨s el
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}

function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){
        clearInterval(t); run();
      }
    },60);
  }
}
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

/* helpers */
function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   EXERCICE â€” DÃ©rivÃ©e, signe de fâ€²(x) et variations (sÃ©lecteur de fonction)
   â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
const ex1 = {
  id: 'deriv_sign_var_types',
  title: "DÃ©rivÃ©e, signe de fâ€²(x) et variations (sÃ©lecteur de fonction)",

  _familyLabel(key){
    switch(key){
      case 'quad':          return "une fonction polynÃ´me du second degrÃ©";
      case 'cubic':         return "une fonction polynÃ´me du 3Ã¨me degrÃ©";
      case 'quot_aff':      return "un quotient d'expressions affines";
      case 'quot_aff_quad': return "un quotient ";
      default:              return key;
    }
  },

  _sgn(x){ return x>0 ? 1 : (x<0 ? -1 : 0); },

  _round(x, p=6){
    const k = Math.pow(10,p);
    return Math.round(x*k)/k;
  },

  _SX(x){
    const UMIN = 'âˆ’';
    return String(x).replace('-', UMIN);
  },

   // normalisation pour comparer la dÃ©rivÃ©e
  _normDeriv(str){
    if(!str) return '';
    let out = String(str);

    // 1) signes / exposants / espaces
    out = out
      .replace(/\u2212/g,'-')   // moins unicode â†’ "-"
      .replace(/Â²/g,'^2')
      .replace(/Â³/g,'^3')
      .replace(/â´/g,'^4')
      .replace(/âµ/g,'^5')
      .replace(/â¶/g,'^6')
      .replace(/â·/g,'^7')
      .replace(/â¸/g,'^8')
      .replace(/â¹/g,'^9')
      .replace(/Â·/g,'*')
      .replace(/Ã—/g,'*')
      .replace(/,/g,'.')
      .replace(/\s+/g,'');

  // 2) on enlÃ¨ve les parenthÃ¨ses "inutiles" autour d'un facteur simple
  //    Ã©ventuellement prÃ©cÃ©dÃ© d'un signe (+ ou -)
  //    ex : (2x) â†’ 2x, (-4x) â†’ -4x, mais (x^2+3) reste.
  out = out.replace(/\(([+-]?[^()+\-]+)\)/g, '$1');


    return out;
  },

  _factorizedInfo(st){
    const UMIN = 'âˆ’';

    const cleanTex = t => cleanSigns(t || '').replace(/-/g, UMIN);

    // coef * (expr) avec gestion spÃ©ciale de 1 et -1
    function coefTimes(A, expr){
      const absA  = Math.abs(A);
      const aTex  = String(absA).replace(/-/g, UMIN);

      if (A === 1)  return expr;
      if (A === -1) return `${UMIN}${expr}`;
      if (A < 0)    return `${UMIN}${aTex}${expr}`;
      return `${aTex}${expr}`;
    }

    // ===== CAS f polynÃ´me du 3Ã¨me degrÃ© â†’ f'(x) polynÃ´me du 2nd degrÃ© =====
    if(st.family === 'cubic' && typeof st.dA === 'number'){
      const A = st.dA;
      const B = st.dB || 0;
      const C = st.dC || 0;

      const Delta = B*B - 4*A*C;
      if(Delta < 0) return null; // pas de factorisation rÃ©elle

      const sqrtD = Math.sqrt(Delta);

      if(Delta === 0){
        const r = -B / (2*A);

        // âš ï¸ si la racine double est 0, on NE VEUT PAS de forme factorisÃ©e
        // f'(x) = k x^2 : pas de (x-0)^2
        if (Math.abs(r) < 1e-9) return null;

        const aAbs  = Math.abs(r);
        const aSig  = r >= 0 ? UMIN : '+';
        const aDisp = String(aAbs).replace(/-/g, UMIN);
        const factor = `\\bigl(x ${aSig} ${aDisp}\\bigr)^2`;

        let tex = `f'(x) = ${coefTimes(A, factor)}`;
        tex = cleanTex(tex);

        return {
          kind: 'cubic',
          form: 'double',    // A(x-r)^2
          A,
          roots: [r],
          tex
        };
      }else{
        const r1 = (-B - sqrtD)/(2*A);
        const r2 = (-B + sqrtD)/(2*A);

        const term = (r)=>{
          const aAbs  = Math.abs(r);
          const aSig  = r >= 0 ? UMIN : '+';
          const aDisp = String(aAbs).replace(/-/g, UMIN);
          return `x ${aSig} ${aDisp}`;
        };

        const t1 = term(r1);
        const t2 = term(r2);
        const prod = `\\bigl(${t1}\\bigr)\\bigl(${t2}\\bigr)`;

        let tex = `f'(x) = ${coefTimes(A, prod)}`;
        tex = cleanTex(tex);

        return {
          kind: 'cubic',
          form: 'prod',      // A(x-r1)(x-r2)
          A,
          roots: [r1, r2],
          tex
        };
      }
    }

    // ===== CAS quotient avec dÃ©nominateur du 2nd degrÃ© =====
    if(st.family === 'quot_aff_quad' && st.dNumType === 'quad'){
     
  // Cas f(x) = m x / (xÂ² âˆ’ aÂ²) :
  // âžœ on NE VEUT PAS de forme factorisÃ©e pour f'(x),
  //    on fera juste une rÃ©solution classique du numÃ©rateur.
  if(st.quotKind === 'mx_over_diffSquares') return null;
	 const A = st.dNumA2 || 0;
      const B = st.dNumB1 || 0;
      const C = st.dNumC0 || 0;
      if(!A) return null;

      // f(x) = m x / (xÂ² âˆ’ aÂ²) â†’ numÃ©rateur de f' : A(xÂ² + aÂ²)
      if(st.quotKind === 'mx_over_diffSquares' && typeof st.aParam === 'number'){
        const a   = st.aParam;
        const a2  = a*a;
        const a2T = String(a2).replace(/-/g, UMIN);

        const numFactor = `\\bigl(x^2 + ${a2T}\\bigr)`;
        const num = coefTimes(A, numFactor);

        // dÃ©nominateur : (xÂ² âˆ’ aÂ²)Â²
        const den = `\\bigl(x^2 ${UMIN} ${a2T}\\bigr)^2`;

        const quotTex = `\\dfrac{${num}}{${den}}`;

        return {
          kind: 'quot',
          numForm: 'sumSquares',  // A(xÂ² + aÂ²)
          A,
          a,
          quotTex
        };
      }

      // f(x) = (px+q)/(xÂ² + s) avec Î”>0 carrÃ© parfait â†’ numÃ©rateur factorisable
      if(st.quotKind === 'aff_over_quad_deltaPos' && typeof st.sParam === 'number'){
        const sPos  = st.sParam;
        const Delta = B*B - 4*A*C;
        if(Delta < 0) return null;
        const sqrtD = Math.sqrt(Delta);
        const r1 = (-B - sqrtD)/(2*A);
        const r2 = (-B + sqrtD)/(2*A);

        const term = (r)=>{
          const aAbs  = Math.abs(r);
          const aSig  = r >= 0 ? UMIN : '+';
          const aDisp = String(aAbs).replace(/-/g, UMIN);
          return `x ${aSig} ${aDisp}`;
        };

        const t1   = term(r1);
        const t2   = term(r2);
        const prod = `\\bigl(${t1}\\bigr)\\bigl(${t2}\\bigr)`;

        const num = coefTimes(A, prod);
        const sTex = String(sPos).replace(/-/g, UMIN);
        const den  = `\\bigl(x^2 + ${sTex}\\bigr)^2`;

        const quotTex = `\\dfrac{${num}}{${den}}`;

        return {
          kind: 'quot',
          numForm: 'roots',        // A(x-r1)(x-r2)
          A,
          roots: [r1, r2],
          quotTex
        };
      }
    }

    return null;
  },




  _parseExtList(str){
    if(!str) return [];
    const s = str.trim();
    if(!s) return [];
    const low = s.toLowerCase();
    if(low==='aucun' || low==='rien') return [];
    return s.split(';')
      .map(v=>v.trim())
      .filter(v=>v!=='')
      .map(v=>Number(v.replace(/\u2212/g,'-').replace(',','.')))
      .filter(v=>!Number.isNaN(v));
  },

  _sameSetNums(a,b){
    if(a.length!==b.length) return false;
    const A = [...a].map(x=>this._round(x,4)).sort((u,v)=>u-v);
    const B = [...b].map(x=>this._round(x,4)).sort((u,v)=>u-v);
    for(let i=0;i<A.length;i++){
      if(Math.abs(A[i]-B[i])>1e-4) return false;
    }
    return true;
  },

  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // GÃ©nÃ©ration dâ€™un Ã©noncÃ©
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  gen(familyOverride){
    const fams = ['quad','cubic','quot_aff','quot_aff_quad'];
    const fam  = familyOverride || fams[rint(0,fams.length-1)];
    const UMIN = 'âˆ’';

    // petit builder ASCII a2 x^2 + a1 x + a0
    function polyAscii(a2,a1,a0){
      let s = '';
      const add = (coef, power)=>{
        if(!coef) return;
        let part = '';
        const A = Math.abs(coef);
        if(power===0){
          part = String(A);
        }else if(power===1){
          part = (A===1 ? 'x' : A+'x');
        }else if(power===2){
          part = (A===1 ? 'x^2' : A+'x^2');
        }else if(power===3){
          part = (A===1 ? 'x^3' : A+'x^3');
        }else{
          part = (A===1 ? 'x^'+power : A+'x^'+power);
        }
        if(!s){
          s = (coef<0 ? '-' : '') + part;
        }else{
          s += (coef<0 ? '-' : '+') + part;
        }
      };
      add(a2,2); add(a1,1); add(a0,0);
      return s || '0';
    }

    // petites marges alÃ©atoires DISTINCTES pour les bornes
    function randMargins(){
      let mL = rint(2,4);
      let mR = rint(2,4);
      if(mL === mR){
        // on force une petite diffÃ©rence
        if(mR < 4) mR = mL + 1;
        else       mL = mR - 1;
      }
      return [mL, mR];
    }




    // builder TeX pour quadratique
    function polyTexQuad(a,b,c){
      const t=[];
      const add=(coef,power)=>{
        if(!coef) return;
        const A = Math.abs(coef);
        const sign = coef<0 ? UMIN : '+';
        let core='';
        if(power===2) core=(A===1?'':'${A}')+'x^2';
        if(power===1) core=(A===1?'':'${A}')+'x';
        if(power===0) core='${A}';
        t.push({sign,core:core.replace('${A}',String(A))});
      };
      add(a,2); add(b,1); add(c,0);
      if(!t.length) return '0';
      let s='';
      const first=t[0];
      if(first.sign===UMIN) s+=UMIN+first.core; else s+=first.core;
      for(let i=1;i<t.length;i++){
        const term=t[i];
        s+=(term.sign===UMIN?` ${UMIN} `:' + ')+term.core;
      }
      return s;
    }

    // builder TeX pour cubique ax^3+bx^2+cx+d
    function polyTexCubic(a,b,c,d){
      const t=[];
      const add=(coef,power)=>{
        if(!coef) return;
        const A=Math.abs(coef);
        const sign=coef<0?UMIN:'+';
        let core='';
        if(power===3) core=(A===1?'':'${A}')+'x^3';
        if(power===2) core=(A===1?'':'${A}')+'x^2';
        if(power===1) core=(A===1?'':'${A}')+'x';
        if(power===0) core='${A}';
        t.push({sign,core:core.replace('${A}',String(A))});
      };
      add(a,3); add(b,2); add(c,1); add(d,0);
      if(!t.length) return '0';
      let s='';
      const first=t[0];
      if(first.sign===UMIN) s+=UMIN+first.core; else s+=first.core;
      for(let i=1;i<t.length;i++){
        const term=t[i];
        s+=(term.sign===UMIN?` ${UMIN} `:' + ')+term.core;
      }
      return s;
    }

    // ============== CAS 1 : polynÃ´me du 2nd degrÃ© =================
    // ============== CAS 1 : polynÃ´me du 2nd degrÃ© =================
if(fam==='quad'){
  const a = choice([1,2,3,4,-1,-2,-3,-4]); // ta version avec |a| plus gros
  const x0 = choice([-2,-1,0,1,2]);
  const b = -2*a*x0;
  const c = rint(-5,5);

  const fTex = `f(x) = ${polyTexQuad(a,b,c)}`;

  const A1 = 2*a, B1 = b;
  const dfTex   = `f'(x) = ${polyTexQuad(0,A1,B1)}`;
  const dfCanon = polyAscii(0,A1,B1);

  const [mL, mR] = randMargins();
  const xL = x0 - mL;
  const xR = x0 + mR;


  const xPts = [xL, x0, xR];


  const fEval = x => a*x*x + b*x + c;
  const fVals = xPts.map(fEval);

  const mids = [ (xL+x0)/2, (x0+xR)/2 ];
  const signPattern = mids.map(m=>{
    const v = A1*m + B1;
    return v>=0 ? '+' : 'âˆ’';
  });

  const extType = a>0 ? 'min' : 'max';
  const ext = [{x:x0, y:fEval(x0), type:extType}];

  const critKind = ['', '0', ''];

  return {
    family:'quad',
    aCoeff: a,      // âœ… mÃ©morisation de a
    bCoeff: b,      // âœ… mÃ©morisation de b
    fTex, dfTex, dfCanon,
    xPts,
    fVals,
    yPts: fVals,
    signPattern,
    critKind,
    ext
  };
}


    // ============== CAS 2 : polynÃ´me du 3Ã¨me degrÃ© =================
    if(fam==='cubic'){
      // On veut plusieurs cas pour f'(x) :
      // - Î”>0 carrÃ© parfait, racines symÃ©triques
      // - Î”>0 carrÃ© parfait, racines non symÃ©triques
      // - Î”=0 (racine double)
      const mode = choice(['sym','deltaPosNonSym','delta0']);
      const aChoices = [1,2,3,-1,-2,-3];

      let a,b,c,d;
      let crit = []; // zÃ©ros de f'(x)

      if(mode==='sym'){
        // f'(x) = 3a(x^2 - k^2) â†’ racines symÃ©triques -k et k
        a = choice(aChoices);
        const k = choice([1,2]);
        b = 0;
        c = -3*a*k*k;
        d = rint(-4,4);
        crit = [-k,k];
      }else if(mode==='delta0'){
        // f'(x) = 3a(x-Î±)^2 â†’ Î”=0 (racine double)
        a = choice(aChoices);
        const alpha = choice([-2,-1,0,1,2]);
        b = -3*a*alpha;
        c =  3*a*alpha*alpha;
        d = rint(-4,4);
        crit = [alpha];
      }else{ // mode === 'deltaPosNonSym'
        // f'(x) = 3a(x-r1)(x-r2) avec r1,r2 entiers, Î”>0 et racines non symÃ©triques
        a = choice(aChoices);
        let r1,r2;
        do{
          r1 = choice([-3,-2,-1,1,2,3]);   // pas 0
          r2 = choice([-3,-2,-1,1,2,3]);
        }while(
          r1===r2 ||
          r1===-r2 ||                 // Ã©vite symÃ©trie
          ((r1+r2)&1)!==0            // somme impaire â†’ b non entier
        );
        b = -3*a*(r1+r2)/2;
        c =  3*a*r1*r2;
        d = rint(-4,4);
        crit = [r1,r2].sort((u,v)=>u-v);
      }

      const fTex = `f(x) = ${polyTexCubic(a,b,c,d)}`;

      const A2 = 3*a;
      const B1 = 2*b;
      const C0 = c;

      const dfTex   = `f'(x) = ${polyTexQuad(A2,B1,C0)}`;
      const dfTex2  = `${polyTexQuad(A2,B1,C0)}`;
      const dfCanon = polyAscii(A2,B1,C0);

      // points critiques (zÃ©ros de f') triÃ©s
      const critSorted = [...crit].sort((u,v)=>u-v);
      const minCrit = critSorted.length ? critSorted[0] : 0;
      const maxCrit = critSorted.length ? critSorted[critSorted.length-1] : 0;

      const [mL, mR] = randMargins();
      const xL = minCrit - mL;
      const xR = maxCrit + mR;

      const xPts = [xL, ...critSorted, xR];

      const fEval = x => a*x*x*x + b*x*x + c*x + d;
      const fVals = xPts.map(fEval);

      // signes de f' sur les intervalles
      const signPattern = [];
      for(let i=0;i<xPts.length-1;i++){
        const m = (xPts[i]+xPts[i+1])/2;
        const v = A2*m*m + B1*m + C0;
        signPattern.push(v>=0 ? '+' : 'âˆ’');
      }

      // type de chaque abscisse : zÃ©ro de f' ou rien
      const critKind = xPts.map(x=>{
        const isZero = critSorted.some(z=>Math.abs(z-x)<1e-8);
        return isZero ? '0' : '';
      });

      // extremums locaux
      const ext = [];
      for(let j=1;j<xPts.length-1;j++){
        const sL = this._sgn(signPattern[j-1]==='+'?1:-1);
        const sR = this._sgn(signPattern[j]==='+'?1:-1);
        if(sL>0 && sR<0){
          ext.push({x:xPts[j], y:fEval(xPts[j]), type:'max'});
        }else if(sL<0 && sR>0){
          ext.push({x:xPts[j], y:fEval(xPts[j]), type:'min'});
        }
      }

      return {
        family:'cubic',
        dA: A2,
        dB: B1,
        dC: C0,
        fTex, dfTex, dfTex2, dfCanon,
        xPts,
        fVals,
        yPts: fVals,
        signPattern,
        critKind,
        ext
      };
    }


    // ============== CAS 3 : quotient de deux affines =================
    if(fam==='quot_aff'){
      let a,b,c,d,kDet,xPole;
      do{
        c = choice([-2,-1,1,2]);
        xPole = choice([-2,-1,1,2]);
        d = -c*xPole;
        a = rint(-4,4);
        b = rint(-4,4);
        kDet = a*d - b*c;
      }while(!kDet);

      const numTex = `${a===0?'':(a===1?'x':(a===-1?`${UMIN}x`:`${a}x`))}${b===0?'':(b>0?(a?`+${b}`:`${b}`):`${b}`)}` || '0';
      const denTex = `${c===0?'':(c===1?'x':(c===-1?`${UMIN}x`:`${c}x`))}${d===0?'':(d>0?(c?`+${d}`:`${d}`):`${d}`)}` || '0';
      const fTex  = `f(x) = \\dfrac{${numTex}}{${denTex}}`;

      const kAbs  = Math.abs(kDet);
      const signK = kDet>0 ? '' : UMIN;
const dfTex = `f'(x) = \\dfrac{${signK}${kAbs}}{\\bigl(${denTex}\\bigr)^2}`;
const dfTex2 = `\\dfrac{${signK}${kAbs}}{\\bigl(${denTex}\\bigr)^2}`;

// mÃªme dÃ©nominateur que dans l'Ã©noncÃ©, mais sans espaces et avec "-" ascii
const denCanonRaw = denTex
  .replace(/\s+/g,'')
  .replace(/\u2212/g,'-');

const dfCanon  = `${kDet}/(${denCanonRaw})^2`;
const dfDenTex = `\\bigl(${denTex}\\bigr)^2`;

      const dfNumTex = `${signK}${kAbs}`;
      const [mL, mR] = randMargins();
      const xL = xPole - mL;
      const xR = xPole + mR;


      const xPts = [xL, xPole, xR];


      const fEval = x => (x===xPole ? null : (a*x + b)/(c*x + d));
      const fVals = xPts.map(fEval);

      const s = this._sgn(kDet);
      const signPattern = [s>0?'+':'âˆ’', s>0?'+':'âˆ’'];

      // dÃ©rivÃ©e non dÃ©finie en xPole â†’ double barre
      const critKind = ['', 'bar', ''];

      const ext = []; // pas dâ€™extremums locaux

             const uTex      = numTex || '0';
  const vTex      = denTex || '0';
  const uPrimeTex = String(a).replace(/-/g, UMIN);
  const vPrimeTex = String(c).replace(/-/g, UMIN);

      return {
        family:'quot_aff',
        fTex, dfTex, dfCanon,
        xPts,
        fVals,
        yPts: fVals,
        signPattern,
        critKind,
        ext,
        // on mÃ©morise les coefficients de u et v pour dÃ©velopper le numÃ©rateur
        qA: a,   // u(x) = a x + b
        qB: b,
        qC: c,   // v(x) = c x + d
        qD: d,
        // ===== info pour la dÃ©rivation du quotient (mÃªme logique que la fiche Quotient) =====
        uTex,
        vTex,
        uPrimeTex,
        vPrimeTex,
        // infos numÃ©rateur/dÃ©nominateur de f'
        dNumType: 'const',
        dNumA2: 0,
        dNumB1: 0,
        dNumC0: kDet,      // numÃ©rateur = kDet
        dNumTex: dfNumTex, // TeX du numÃ©rateur
        dDenTex: dfDenTex  // TeX du dÃ©nominateur (dÃ©jÃ  au carrÃ©)
      };

}


    

    // ============== CAS 4 : quotients avec dÃ©nominateur du 2nd degrÃ© =================
    if(fam==='quot_aff_quad'){
      // 3 formes :
      // 1) f(x) = m x / (xÂ² âˆ’ aÂ²)          -> numÃ©rateur de f' : 2nd degrÃ© (Î”<0)
      // 2) f(x) = k / (xÂ² + s)            -> numÃ©rateur affine (âˆ’2kx)
      // 3) f(x) = (px+q)/(xÂ² + s)         -> numÃ©rateur 2nd degrÃ© avec Î”>0 carrÃ© parfait
      const mode = choice(['mx_over_diffSquares','const_over_quad','aff_over_quad_deltaPos']);
      let denBaseTex = '';
      let uTex = '', vTex = '', uPrimeTex = '', vPrimeTex = '';

      let fTex, dfTex, dfCanon;
      let fEval;
      let critZeros = []; // zÃ©ros de f'
      let critBars  = []; // pÃ´les (double barre)
      let A2=0,B1=0,C0=0; // numÃ©rateur de f'(x) = (A2 xÂ² + B1 x + C0) / (â€¦ )Â²

      // on mÃ©morise aussi le type de quotient et ses paramÃ¨tres
      let quotKind = mode;
      let mCoef = null, aParam = null;
      let kConst = null, sParam = null;
      let pCoef = null, qCoef = null;

      if(mode==='mx_over_diffSquares'){
        // CAS : f(x) = m x / (xÂ² âˆ’ aÂ²)
        const m = choice([1,2,-1,-2]);
        const a  = choice([1,2]);

        const numTex = `${m===1?'x':(m===-1?`${UMIN}x`:`${m}x`)}`;
        fTex   = `f(x) = \\dfrac{${numTex}}{x^2 ${UMIN} ${a*a}}`;

        denBaseTex = `x^2 ${UMIN} ${a*a}`;

        const x1=-a,x2=a;
        critBars = [x1,x2];
        critZeros = [];

        // numÃ©rateur dÃ©veloppÃ© : âˆ’m xÂ² âˆ’ m aÂ²
        A2 = -m;
        B1 = 0;
        C0 = -m*a*a;

        fEval = x => (x===-a || x===a ? null : m*x/(x*x - a*a));

        // donnÃ©es u,v,u',v'
        uTex      = numTex;
        vTex      = denBaseTex;
        uPrimeTex = String(m).replace(/-/g, UMIN);
        vPrimeTex = '2x';

        mCoef = m;
        aParam = a;
      }else if(mode==='const_over_quad'){
        // f(x) = k / (xÂ² + s)
        const k = choice([1,2,-1,-2]);
        const sPos = choice([1,2,3]);

        fTex = `f(x) = \\dfrac{${k}}{x^2 + ${sPos}}`;

        denBaseTex = `x^2 + ${sPos}`;

        critBars = [];
        critZeros = [0];

        // numÃ©rateur : âˆ’2kx (affine)
        A2 = 0;
        B1 = -2*k;
        C0 = 0;

        fEval = x => k/(x*x + sPos);

        // donnÃ©es u,v,u',v'
        uTex      = String(k).replace(/-/g, UMIN);
        vTex      = denBaseTex;
        uPrimeTex = '0';
        vPrimeTex = '2x';

        kConst = k;
        sParam = sPos;
      }else{
        // f(x) = (px+q)/(xÂ² + s) avec numÃ©rateur de f' = A(x-Î±)(x-Î²)
        // oÃ¹ A = Â±1 ou Â±2 et Î±,Î² ENTiers.
        let p,q,sPos;       // coefficients de f
        let A;              // coefficient devant (x-Î±)(x-Î²) dans f'
        let alpha,beta;     // racines entiÃ¨res de f'
        const rootsPool = [-3,-2,-1,1,2,3];
        const Achoices  = [1,2];

        while(true){
          const magA  = choice(Achoices);   // 1 ou 2
          const signA = choice([1,-1]);     // Â±
          A = magA * signA;                 // A = Â±1 ou Â±2

          alpha = choice(rootsPool);
          beta  = choice(rootsPool);

          // on veut deux racines distinctes, de signes opposÃ©s
          if(alpha === beta) continue;
          if(alpha * beta >= 0) continue;   // produit < 0 pour avoir s>0

          const sum = alpha + beta;

          // q = (A/2)(Î±+Î²) doit Ãªtre entier
          if( (A * sum) % 2 !== 0 ) continue;
          q = (A * sum) / 2;

          // on Ã©vite des q trop gros
          if(Math.abs(q) > 6) continue;

          // s = -Î±Î² > 0, pas trop gros
          sPos = -alpha * beta;
          if(sPos <= 0 || sPos > 9) continue;

          // coefficient de x dans f : p = -A (car num f' = -p xÂ² - 2q x + p s)
          p = -A;
          break;
        }

        const numTop = (p===1 ? 'x'
                         : (p===-1 ? `${UMIN}x`
                                   : `${p}x`))
                      + (q===0 ? '' : (q>0 ? `+${q}` : `${q}`));

        fTex = `f(x) = \\dfrac{${numTop}}{x^2 + ${sPos}}`;
        denBaseTex = `x^2 + ${sPos}`;

        // numÃ©rateur dÃ©veloppÃ© de f' : A2 xÂ² + B1 x + C0
        // (on retrouve bien A(x-Î±)(x-Î²))
        A2 = -p;          // = A
        B1 = -2*q;
        C0 = p * sPos;    // = A Î± Î²

        fEval = x => (p*x + q)/(x*x + sPos);

        // donnÃ©es u,v,u',v'
        uTex      = numTop;
        vTex      = denBaseTex;
        uPrimeTex = String(p).replace(/-/g, UMIN);
        vPrimeTex = '2x';

        // zÃ©ros de f'(x) : Î± et Î², ENTiers
        const r1 = alpha;
        const r2 = beta;
        critZeros = [r1, r2].sort((u,v)=>u-v);
        critBars  = [];

        pCoef = p;
        qCoef = q;
        sParam = sPos;
      }


      // â€”â€“ forme finale de f'(x) : numÃ©rateur DÃ‰VELOPPÃ‰ axÂ²+bx+c (sans 1x, sans 1xÂ², sans +0)
      const numDfTex = polyTexQuad(A2,B1,C0);
      dfTex = `f'(x) = \\dfrac{${numDfTex}}{\\bigl(${denBaseTex}\\bigr)^2}`;

      // canon ascii pour la comparaison de saisie
      const numCanon = polyAscii(A2,B1,C0);
      const denCanonRaw = denBaseTex.replace(/\s+/g,'');
      dfCanon = `(${numCanon})/(${denCanonRaw})^2`;

      // ====================== Construction des x pour le tableau ======================
      const crit = [
        ...critZeros.map(x=>({x,kind:'0'})),
        ...critBars.map(x=>({x,kind:'bar'}))
      ].sort((u,v)=>u.x-v.x);

      let xL, xR, xPts, critKind;

      // 1) Cas "2 pÃ´les, aucun zÃ©ro" : f(x) = mx/(xÂ² - aÂ²)
      //    -> intervalle qui SE TERMINE par un seul de ces pÃ´les (plus simple pour les Ã©lÃ¨ves).
      if(critBars.length === 2 && critZeros.length === 0){
        const chosen = choice(critBars); // -a ou a
        xR = chosen;

        // borne gauche : un point du domaine (pas valeur interdite)
        let xCandidate = chosen - 2;
        while(critBars.some(z => Math.abs(z - xCandidate) < 1e-8)){
          xCandidate -= 2;
        }
        xL = xCandidate;

        xPts = [xL, xR];        // borne gauche / pÃ´le Ã  droite
        critKind = ['', 'bar']; // double barre seulement Ã  droite
      }

      // 2) Cas "numÃ©rateur 2nd degrÃ© avec Î”>0" (aff_over_quad_deltaPos)
      //    -> lâ€™intervalle DOIT contenir les 2 racines, et elles doivent apparaÃ®tre dans la ligne x.
      else if(mode === 'aff_over_quad_deltaPos' && critZeros.length === 2 && critBars.length === 0){
        const z1 = critZeros[0];
        const z2 = critZeros[1];
        const zMin = Math.min(z1,z2);
        const zMax = Math.max(z1,z2);

        const [mL, mR] = randMargins();
        xL = zMin - mL;   // une unitÃ© Ã  gauche
        xR = zMax + mR;   // une unitÃ© Ã  droite

        // ligne de x : borne gauche / racine 1 / racine 2 / borne droite
        xPts = [xL, zMin, zMax, xR];
        critKind = ['', '0', '0', ''];
      }

      // 3) Cas gÃ©nÃ©ral : on garde la logique "minCrit - 2 ; maxCrit + 2"
      else{
        const minCrit = crit.length ? crit[0].x : -1;
        const maxCrit = crit.length ? crit[crit.length-1].x : 1;

        const [mL, mR] = randMargins();
        xL = minCrit - mL;
        xR = maxCrit + mR;


        xPts = [xL, ...crit.map(c=>c.x), xR];

        critKind = xPts.map(x=>{
          const bar = critBars.some(z=>Math.abs(z-x)<1e-8);
          if(bar) return 'bar';
          const zero = critZeros.some(z=>Math.abs(z-x)<1e-8);
          return zero ? '0' : '';
        });
      }

      // valeurs de f(x) sur les points retenus
      const fVals = xPts.map(x=> fEval(x));

      // signes de f' sur chaque intervalle
      const signPattern = [];
      for(let i=0;i<xPts.length-1;i++){
        const m = (xPts[i]+xPts[i+1])/2;
        const num = A2*m*m + B1*m + C0;
        const s = num>=0 ? '+' : 'âˆ’';
        signPattern.push(s);
      }

      // extremums : uniquement sur les zÃ©ros de f' (pas sur les pÃ´les)
      const ext = [];
      for(let j=1;j<xPts.length-1;j++){
        if(critKind[j] !== '0') continue; // on ignore pÃ´les & points quelconques
        const sL = this._sgn(signPattern[j-1]==='+'?1:-1);
        const sR = this._sgn(signPattern[j]==='+'?1:-1);
        if(sL>0 && sR<0){
          ext.push({x:xPts[j], y:fVals[j], type:'max'});
        }else if(sL<0 && sR>0){
          ext.push({x:xPts[j], y:fVals[j], type:'min'});
        }
      }

      const dDenTex = denBaseTex ? `\\bigl(${denBaseTex}\\bigr)^2` : '';
      const dfTex2 = ` ${numDfTex}`;

      return {
        family:'quot_aff_quad',
        fTex, dfTex,dfTex2, dfCanon,
        xPts,
        fVals,
        yPts: fVals,
        signPattern,
        critKind,
        ext,
        // mÃ©morisation pour les Ã©tapes de calcul
        quotKind,
        mCoef,
        aParam,
        kConst,
        sParam,
        pCoef,
        qCoef,
        // donnÃ©es pour la rÃ©daction "MÃ©thode â€” RÃ¨gle du quotient"
        uTex,
        vTex,
        uPrimeTex,
        vPrimeTex,
        // infos numÃ©rateur/dÃ©nominateur de f'
        dNumType: (A2 !== 0 ? 'quad' : (B1 !== 0 ? 'lin' : 'const')),
        dNumA2: A2,
        dNumB1: B1,
        dNumC0: C0,
        dNumTex: numDfTex,
        dDenTex
      };
    }




    
  },

 // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Rendu
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
render(host, st){
  const famLabel = this._familyLabel(st.family);
  const UMIN = 'âˆ’';
  const factInfo = this._factorizedInfo(st);

  const extraQuestion = factInfo
    ? `<li>Montrer que \\(f'(x) = ${
        factInfo.kind === 'quot' ? factInfo.quotTex : factInfo.tex
      }\\).</li>`
    : '';

  // points du tableau
  const xPts = st.xPts;
  const critKind = st.critKind || [];
  const n = xPts.length;

  const signPattern = st.signPattern || [];

  // cas spÃ©cial : 3 points, un seul zÃ©ro au milieu, mÃªme signe de chaque cÃ´tÃ©
  const specialSingleArrow =
    (n === 3 &&
     signPattern.length === 2 &&
     critKind[1] === '0' &&
     (signPattern[0] === '+' || signPattern[0] === 'âˆ’') &&
     signPattern[0] === signPattern[1]);



  const SX = x => String(x).replace(/-/g, UMIN);

  const xLeft  = xPts[0];
  const xRight = xPts[n-1];

  // crochets en fonction des valeurs interdites aux bornes
  let leftDelim  = '\\left[';
  let rightDelim = '\\right]';

  if(critKind[0] === 'bar')      leftDelim  = '\\left]';
  if(critKind[n-1] === 'bar')    rightDelim = '\\right[';

  const intervalTex = `${leftDelim}${SX(xLeft)};${SX(xRight)}${rightDelim}`;



  // rÃ´les pour les colonnes : xmin, c1, c2, ..., xmax
  const roles = (()=>{
    if(n <= 2) return ['xmin','xmax'];
    const inner = Array.from({length: n-2}, (_,i)=> 'r'+(i+1));
    return ['xmin', ...inner, 'xmax'];
  })();

  function rowX(){
    let r = '<tr><th>\\(x\\)</th>';
    for(let j=0; j<roles.length; j++){
      const role = roles[j];
      r += `<td><input class="dvx" data-role="${role}" type="text" placeholder="${role}"></td>`;
      if(j < roles.length-1) r += '<td></td>'; // colonne d'intervalle
    }
    r += '</tr>';
    return r;
  }

  function rowFp(){
    let r = '<tr><th style="border-top:1.5px solid #000">\\(f\'(x)\\)</th>';
    for(let j=0; j<roles.length; j++){
      const role = roles[j];
      // cellule sous l'abscisse : 0 / ||
      r += `
        <td class="bigsel" style="border-top:1.5px solid #000">
          <select class="dvz" data-role="${role}">
            <option value=""></option>
            <option value="0">0</option>
            <option value="||">||</option>
          </select>
        </td>
      `;
      // signe sur l'intervalle suivant
      if(j < roles.length-1){
        r += `
          <td class="bigsel" style="border-top:1.5px solid #000">
            <select class="dvs" data-i="${j}">
              <option></option>
              <option>+</option>
              <option>${UMIN}</option>
            </select>
          </td>
        `;
      }
    }
    r += '</tr>';
    return r;
  }

     function rowF(){
    let r = '<tr><th style="border-top:1.5px solid #000">\\(f\\)</th>';

    for(let j=0; j<roles.length; j++){
      const role = roles[j];

      // colonne centrale sous la racine, dans le cas Î”=0 avec +0+ ou âˆ’0âˆ’
      const isCentralZero =
        specialSingleArrow &&
        roles.length === 3 &&   // xmin, c1, xmax
        j === 1 &&              // colonne du milieu
        critKind[1] === '0';

      // ----- cellule sous x -----
      if(isCentralZero){
        // pas de max/min sous la racine : juste la flÃ¨che
        r += `
          <td style="border-top:1.5px solid #000">
            <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
              <select class="dvd dvd-mid" data-i="0">
                <option></option>
                <option>â†˜</option>
                <option>â†—</option>
                <option>â†’</option>
              </select>
            </div>
          </td>
        `;
      }else{
        // cas gÃ©nÃ©ral : || + max + min comme avant
        r += `
          <td style="border-top:1.5px solid #000">
            <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
              <select class="vfmark" data-role="${role}">
                <option value=""></option>
                <option value="||">||</option>
              </select>
              <input class="dvYmax" data-role="${role}" type="text" placeholder="max">
              <input class="dvYmin" data-role="${role}" type="text" placeholder="min">
            </div>
          </td>
        `;
      }

      // ----- cellule d'intervalle Ã  droite (flÃ¨che classique) -----
      if(j < roles.length-1){
        if(specialSingleArrow){
          // dans ce cas : PAS de flÃ¨che entre les colonnes, elle est sous la racine
          r += `<td style="border-top:1.5px solid #000"></td>`;
        }else{
          r += `
            <td class="bigsel" style="border-top:1.5px solid #000">
              <select class="dvd" data-i="${j}">
                <option></option>
                <option>â†˜</option>
                <option>â†—</option>
                <option>â†’</option>
              </select>
            </td>
          `;
        }
      }
    }

    r += '</tr>';
    return r;
  }



  host.innerHTML = `
    <div style="margin-bottom:.35rem">
      <label>
        <b>Type de fonction :</b>
        <select class="fam-select" style="margin-left:.4rem">
          <option value="quad">PolynÃ´me du second degrÃ©</option>
          <option value="cubic">PolynÃ´me du 3Ã¨me degrÃ©</option>
          <option value="quot_aff">Quotient de fonctions affines</option>
          <option value="quot_aff_quad">Quotient (numÃ©rateur affine, dÃ©nominateur du 2nd degrÃ©)</option>
        </select>
      </label>
    </div>

    <div>
      On considÃ¨re une fonction \\(f\\) qui est <b>${famLabel}</b>,
      dÃ©finie par :
      <div style="margin:.35rem 0 .2rem 0">\\(${st.fTex}\\)</div>
      <ol style="margin:.35rem 0 0 1.1rem;padding-left:.2rem">
        <li>Calculer sa dÃ©rivÃ©e \\(f'(x)\\).</li>
        ${extraQuestion}
        <li>Donner le <b>tableau de signes</b> de \\(f'(x)\\)  sur l'intervalle \\(${intervalTex}\\).</li>
        <li>Donner le <b>tableau de variations</b> de \\(f\\)  sur l'intervalle \\(${intervalTex}\\).</li>
      </ol>

    </div>

    <div class="pdf-hide" style="margin-top:.45rem">
      \\(f'(x) =\\)
      <input type="text" class="df-input"
             style="width:260px;max-width:100%;text-align:left"
             placeholder="">
      <span class="tick nu"></span>
    </div>

    <div class="var-wrap pdf-hide" style="margin-top:.6rem">
      <table class="pdf-tbl">
        <tbody>
          ${rowX()}
          ${rowFp()}
          ${rowF()}
        </tbody>
      </table>
    </div>


    <div class="steps small" id="res" style="margin-top:.45rem"></div>
  `;

  // sÃ©lecteur de famille â†’ rÃ©gÃ©nÃ¨re un nouvel Ã©tat
  const famSel = host.querySelector('.fam-select');
  if(famSel){
    famSel.value = st.family;
    famSel.addEventListener('change', ()=>{
      const famKey = famSel.value;
      const newSt = this.gen(famKey);
      host.dataset.state = JSON.stringify(newSt);
      this.render(host, newSt);
    });
  }

  // tick sur la dÃ©rivÃ©e
  const dfInput = host.querySelector('.df-input');
  if(dfInput){
    ensureTickAfter(dfInput);
    dfInput.addEventListener('input', ()=>ensureTickAfter(dfInput));
  }

  // ticks pour signes / 0 / barres / flÃ¨ches du tableau
  host.querySelectorAll('.dvz, .dvs, .dvd, .vfmark').forEach(sel=>{
    ensureTickAfter(sel);
    sel.addEventListener('change', ()=>ensureTickAfter(sel));
  });

  // ticks pour les valeurs de f (max/min dans le tableau)
  host.querySelectorAll('.dvYmax, .dvYmin').forEach(inp=>{
    ensureTickAfter(inp);
    inp.addEventListener('input', ()=>ensureTickAfter(inp));
  });
  // ticks pour la ligne x
  host.querySelectorAll('.dvx').forEach(inp=>{
    ensureTickAfter(inp);
    inp.addEventListener('input', ()=>ensureTickAfter(inp));
  });

  // ticks pour les abscisses dâ€™extremums en bas
  ['.ext-max', '.ext-min'].forEach(sel=>{
    const inp = host.querySelector(sel);
    if(inp){
      ensureTickAfter(inp);
      inp.addEventListener('input', ()=>ensureTickAfter(inp));
    }
  });

  typesetAll(host);
},

  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Correction
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  correct(host, st){
    const UMIN        = 'âˆ’';
    const signPattern = st.signPattern || [];
    const critKind    = st.critKind    || [];
    const xPts        = st.xPts        || [];
    const fVals       = st.fVals || st.yPts || [];
    const extList     = st.ext  || [];
    const n           = xPts.length;

    // rÃ´les (cohÃ©rents avec render)
const roles = (()=>{
  if(n <= 2) return ['xmin','xmax'];
  const inner = Array.from({length:n-2}, (_,i)=> 'r'+(i+1)); // mÃªme logique que dans render
  return ['xmin', ...inner, 'xmax'];
})();

    const roleIndex = role => roles.indexOf(role);

    const expectedDir = signPattern.map(s => s === '+' ? 'â†—' : 'â†˜');

    const specialSingleArrow =
      (n === 3 &&
       signPattern.length === 2 &&
       critKind[1] === '0' &&
       (signPattern[0] === '+' || signPattern[0] === 'âˆ’') &&
       signPattern[0] === signPattern[1]);

    // parse nombre ou fraction "11/2"
    const parseNum = str => {
      const t = (str || '').trim();
      if(!t) return NaN;

      const norm = t
        .replace(UMIN, '-')   // moins unicode
        .replace(',', '.');   // virgule â†’ point

      const m = norm.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/);
      if(m){
        const num = parseFloat(m[1]);
        const den = parseFloat(m[2]);
        if(den === 0) return NaN;
        return num / den;
      }
      return Number(norm);
    };

    let ok        = 0;
    let tot       = 0;
    let allFilled = true;  // devient false dÃ¨s qu'une case obligatoire est vide

    // â€”â€”â€” 1) DÃ‰RIVÃ‰E f'(x) â€”â€”â€”
    const dfInput = host.querySelector('.df-input');
    if(dfInput){
      const raw = (dfInput.value || '').trim();
      if(!raw){
        allFilled = false;
        setTick(dfInput,'nu');
      }else{
        const user = this._normDeriv(raw);
        const good = this._normDeriv(st.dfCanon || '');
        tot++;
        if(user === good){
          ok++;
          setTick(dfInput,'ok');
        }else{
          setTick(dfInput,'ko');
        }
      }
    }

    // â€”â€”â€” 2) LIGNE x â€”â€”â€”
    host.querySelectorAll('.dvx').forEach(inp=>{
      const role = inp.dataset.role;
      const j    = roleIndex(role);
      const expectedX = (j >= 0 ? xPts[j] : null);
      const val  = (inp.value || '').trim();

      if(expectedX === null || expectedX === undefined){
        setTick(inp,'nu');
        return;
      }

      if(!val){
        allFilled = false;
        setTick(inp,'nu');
        return;
      }

      const u = parseNum(val);
      tot++;
      const good = Number.isFinite(u) && Math.abs(u - expectedX) < 1e-6;
      if(good){ ok++; setTick(inp,'ok'); }
      else     {       setTick(inp,'ko'); }
    });

    // â€”â€”â€” 3) f'(x) : 0 / || â€”â€”â€”
    host.querySelectorAll('.dvz').forEach(sel=>{
      const val   = (sel.value || '').trim();
      const role  = sel.dataset.role;
      const j     = roleIndex(role);
      const expected = (j >= 0 ? (critKind[j] || '') : '');

      if(!expected){
        if(!val){
          setTick(sel,'nu');   // facultatif
        }else{
          tot++;
          const good = (val === '');
          if(good){ ok++; setTick(sel,'ok'); }
          else     {       setTick(sel,'ko'); }
        }
        return;
      }

      if(!val){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      tot++;
      let good = false;
      if(expected === '0')   good = (val === '0');
      if(expected === 'bar') good = (val === '||');

      if(good){ ok++; setTick(sel,'ok'); }
      else     {       setTick(sel,'ko'); }
    });

    // â€”â€”â€” 4) f'(x) : signe â€”â€”â€”
    host.querySelectorAll('.dvs').forEach(sel=>{
      const idx = +sel.dataset.i;
      const v   = (sel.value || '').trim();

      if(idx < 0 || idx >= signPattern.length){
        setTick(sel,'nu');
        return;
      }

      if(!v){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      tot++;
      const goodSign = (signPattern[idx] === '+' ? '+' : UMIN);
      const good     = (v === goodSign);

      if(good){ ok++; setTick(sel,'ok'); }
      else     {       setTick(sel,'ko'); }
    });

    // â€”â€”â€” 5) f : barres || â€”â€”â€”
    host.querySelectorAll('.vfmark').forEach(sel=>{
      const val  = (sel.value || '').trim();
      const role = sel.dataset.role;
      const j    = roleIndex(role);
      const isBar = (j >= 0 && critKind[j] === 'bar');

      if(!isBar){
        if(!val){
          setTick(sel,'nu');
        }else{
          tot++;
          const good = (val === '');
          if(good){ ok++; setTick(sel,'ok'); }
          else     {       setTick(sel,'ko'); }
        }
        return;
      }

      if(!val){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      tot++;
      const good = (val === '||');
      if(good){ ok++; setTick(sel,'ok'); }
      else     {       setTick(sel,'ko'); }
    });

    // â€”â€”â€” 6) f : flÃ¨ches de variation â€”â€”â€”
    host.querySelectorAll('.dvd').forEach(sel=>{
      const v   = (sel.value || '').trim();
      const idx = +sel.dataset.i;

      if(!v){
        allFilled = false;
        setTick(sel,'nu');
        return;
      }

      if(!specialSingleArrow){
        if(idx < 0 || idx >= expectedDir.length){
          setTick(sel,'nu');
          return;
        }
        tot++;
        const good = (v === expectedDir[idx]);
        if(good){ ok++; setTick(sel,'ok'); }
        else     {       setTick(sel,'ko'); }
      }else{
        const wanted = (signPattern[0] === '+' ? 'â†—' : 'â†˜');
        tot++;
        const good = (v === wanted);
        if(good){ ok++; setTick(sel,'ok'); }
        else     {       setTick(sel,'ko'); }
      }
    });

    // â€”â€”â€” 7) f : valeurs (bornes + extremums) â€”â€”â€”
    const yAt = j => (fVals[j] !== undefined && fVals[j] !== null)
                      ? fVals[j]
                      : null;

    for(let j=0;j<n;j++){
      const role = roles[j];
      const kind = critKind[j] || '';
      const x0   = xPts[j];
      const y    = yAt(j);

      const inpTop = host.querySelector(`.dvYmax[data-role="${role}"]`);
      const inpBot = host.querySelector(`.dvYmin[data-role="${role}"]`);

      if(!inpTop || !inpBot){
        continue;
      }

      // cas oÃ¹ f n'est pas dÃ©finie : aucune valeur attendue
      if(kind === 'bar' || y === null){
        const vTop = (inpTop.value || '').trim();
        const vBot = (inpBot.value || '').trim();
        if(!vTop) setTick(inpTop,'nu'); else { tot++; setTick(inpTop,'ko'); }
        if(!vBot) setTick(inpBot,'nu'); else { tot++; setTick(inpBot,'ko'); }
        continue;
      }

      // extremum local ?
      const extMaxHere = extList.find(e => e.type === 'max' && e.x === x0);
      const extMinHere = extList.find(e => e.type === 'min' && e.x === x0);

      const vTop = (inpTop.value || '').trim();
      const vBot = (inpBot.value || '').trim();

      // ===== CAS EXTREMUM LOCAL =====
      if(extMaxHere || extMinHere){
        const valExpected = (extMaxHere || extMinHere).y;

        if(extMaxHere){
          // top obligatoire, bottom doit rester vide
          if(!vTop){
            allFilled = false;
            setTick(inpTop,'nu');
          }else{
            tot++;
            const u = parseNum(vTop);
            const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
            if(good){ ok++; setTick(inpTop,'ok'); }
            else     {       setTick(inpTop,'ko'); }
          }

          if(!vBot){
            setTick(inpBot,'nu');
          }else{
            tot++;
            setTick(inpBot,'ko');
          }
        }else{
          // min local : bottom obligatoire, top vide
          if(!vBot){
            allFilled = false;
            setTick(inpBot,'nu');
          }else{
            tot++;
            const u = parseNum(vBot);
            const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
            if(good){ ok++; setTick(inpBot,'ok'); }
            else     {       setTick(inpBot,'ko'); }
          }

          if(!vTop){
            setTick(inpTop,'nu');
          }else{
            tot++;
            setTick(inpTop,'ko');
          }
        }
        continue;
      }

      // ===== CAS BORNE / POINT SANS EXTREMUM =====
      // Il faut Ã©crire f(x_j) soit en haut, soit en bas (on accepte les deux).
      const valExpected = y;

      const hasTop = !!vTop;
      const hasBot = !!vBot;

      if(!hasTop && !hasBot){
        // rien Ã©crit â†’ obligatoire
        allFilled = false;
        setTick(inpTop,'nu');
        setTick(inpBot,'nu');
        continue;
      }

      if(hasTop && hasBot){
        // deux valeurs : on pÃ©nalise les deux
        tot += 2;
        setTick(inpTop,'ko');
        setTick(inpBot,'ko');
        continue;
      }

      if(hasTop){
        tot++;
        const u = parseNum(vTop);
        const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
        if(good){ ok++; setTick(inpTop,'ok'); }
        else     {       setTick(inpTop,'ko'); }
        setTick(inpBot,'nu');
      }else{ // hasBot
        tot++;
        const u = parseNum(vBot);
        const good = Number.isFinite(u) && Math.abs(u - valExpected) < 1e-6;
        if(good){ ok++; setTick(inpBot,'ok'); }
        else     {       setTick(inpBot,'ko'); }
        setTick(inpTop,'nu');
      }
    }

    // â€”â€”â€” 8) RÃ©sumÃ© â€”â€”â€”
    const res = $('#res', host);
    if(res){
      res.innerHTML = '';
      ensureTickAfter(res).className = 'tick ' + (tot > 0 && ok === tot ? 'ok' : 'nu');
    }

    // â€”â€”â€” 9) si tout rempli et tout bon â†’ ticks vertes partout â€”â€”â€”
    if(tot > 0 && ok === tot && allFilled){
      host.querySelectorAll('.tick').forEach(t=>{
        t.className = 'tick ok';
      });
    }

    return { ok, total: tot };
  },



  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Solution
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  solution(host, st){
    const famLabel   = this._familyLabel(st.family);
    const SX         = x => this._SX(x);
    const xPts       = st.xPts || [];
    const fVals      = st.fVals || [];
    const n          = xPts.length;

    const signPattern = st.signPattern || [];   // signes de f' sur les intervalles
    const critKind    = st.critKind || [];      // ['', '0', 'bar', ...]
    const dirPattern  = signPattern.map(s => s === '+' ? 'â†—' : 'â†˜');

    const UMIN = 'âˆ’';
    const isQuot = (st.family === 'quot_aff' || st.family === 'quot_aff_quad');

    const factInfo = this._factorizedInfo(st);  // infos sur la forme factorisÃ©e Ã©ventuelle
  let signExplainAfterSolve = '';   // phrase Ã  afficher APRÃˆS la rÃ©solution

    // bloc spÃ©cial Ã  insÃ©rer APRÃˆS le dÃ©veloppement pour les quotients
    let quotientSignBlock = '';

    // approxime un flottant par une fraction raisonnable
    function floatToFrac(x, maxDen = 30){
      let sign = 1;
      if(x < 0){ sign = -1; x = -x; }
      let bestN = 0, bestD = 1;
      let bestErr = Infinity;
      for(let d = 1; d <= maxDen; d++){
        const n = Math.round(x * d);
        const approx = n / d;
        const err = Math.abs(x - approx);
        if(err < bestErr - 1e-12){
          bestErr = err;
          bestN = n;
          bestD = d;
        }
      }
      return { n: sign * bestN, d: bestD };
    }

    // RÃ©solution dÃ©taillÃ©e d'une Ã©quation linÃ©aire A x + B = 0
    function linearSolveStepsTex(A, B, label){
      label = label || "f'(x)";

      const fmtFrac = (fr) => {
        if(fr.d === 1){
          return String(fr.n).replace(/-/g, UMIN);
        }
        const sign = fr.n < 0 ? UMIN : '';
        const nAbs = Math.abs(fr.n);
        return `${sign}\\dfrac{${nAbs}}{${fr.d}}`;
      };

      const lines = [];

      // CAS B = 0
      if(B === 0){
        if(Math.abs(A) === 1){
          lines.push(`${label} = 0`);
          lines.push(`x = 0`);
        }else{
          lines.push(`${label} = 0`);
          lines.push(`${A}x = 0`);
          lines.push(`x = 0`);
        }
      }else{
        const frac = floatToFrac(-B / A, 30);
        const xTex = fmtFrac(frac);

        const absB  = Math.abs(B);
        const signB = B > 0 ? '+ ' : 'âˆ’ ';

        let firstTerm;
        if(Math.abs(A) === 1){
          firstTerm = (A === 1 ? 'x' : 'âˆ’x');
        }else{
          firstTerm = `${A}x`;
        }
        const line2 = `${firstTerm} ${signB}${absB} = 0`;

        let line3;
        if(Math.abs(A) === 1){
          line3 = `x = ${(-B).toString().replace(/-/g, UMIN)}`;
        }else{
          line3 = `${A}x = ${(-B).toString().replace(/-/g, UMIN)}`;
        }
        const line4 = `x = ${xTex}`;

        lines.push(`${label} = 0`);
        lines.push(line2);
        lines.push(line3);
        lines.push(line4);
      }

      return `
        <div class="eq-steps">
          ${lines.map(t => `
            <div class="eq-line" style="text-align:left">\\(${t}\\)</div>
          `).join('')}
        </div>
      `;
    }

    // TeX pour une valeur de f(x)
    function texVal(v){
      if(v === '' || v === null || v === undefined || Number.isNaN(v)){
        return '&nbsp;';
      }

      const num = Number(v);
      if(!Number.isFinite(num)) return '&nbsp;';

      // Cas quotient : fraction si non entier
      if(isQuot){
        const intPart = Math.round(num);
        if(Math.abs(num - intPart) < 1e-9){
          const s = String(intPart).replace(/-/g, UMIN);
          return `\\(${s}\\)`;
        }
        const {n,d} = floatToFrac(num, 30);
        if(d === 1){
          const s = String(n).replace(/-/g, UMIN);
          return `\\(${s}\\)`;
        }
        const sign = n < 0 ? UMIN : '';
        const absN = Math.abs(n);
        return `\\(${sign}\\dfrac{${absN}}{${d}}\\)`;
      }

      const s = String(num).replace(/-/g, UMIN).replace('.', ',');
      return `\\(${s}\\)`;
    }

    function cellTopBottom(topVal, bottomVal, extraCls=''){
      const top = texVal(topVal);
      const bot = texVal(bottomVal);
      return `
        <td class="${extraCls}" style="border-top:1.5px solid #000">
          <div style="text-align:center">${top}</div>
          <div style="height:6px"></div>
          <div style="text-align:center">${bot}</div>
        </td>
      `;
    }

    const yAt = j => (fVals[j] !== undefined && fVals[j] !== null) ? fVals[j] : '';

    // ===== Ligne x =====
    function rowX(){
      let r = '<tr><th>\\(x\\)</th>';
      for(let i=0;i<n;i++){
        r += `<td>\\(${SX(xPts[i])}\\)</td>`;
        if(i<n-1) r += '<td></td>';
      }
      r += '</tr>';
      return r;
    }

    // ===== Ligne f'(x) =====
    function rowFpFull(){
      let r = '<tr><th style="border-top:1.5px solid #000">\\(f\'(x)\\)</th>';

      // sous x0
      r += '<td style="border-top:1.5px solid #000"></td>';

      for(let i=0;i<n-1;i++){
        const s = signPattern[i] === '+' ? '+' : UMIN;

        // intervalle
        r += `<td style="border-top:1.5px solid #000">${s}</td>`;

        // sous x_{i+1}
        const j  = i+1;
        if(i<n-1){
          const ck = critKind[j] || '';
          if(ck === '0'){
            r += `<td class="zbar" style="border-top:1.5px solid #000">0</td>`;
          }else if(ck === 'bar'){
            r += `<td class="dbar" style="border-top:1.5px solid #000"></td>`;
          }else{
            r += `<td style="border-top:1.5px solid #000"></td>`;
          }
        }
      }
      r += '</tr>';
      return r;
    }

    // ===== Ligne f : bornes + extremums (max en haut, min en bas) =====
    function rowFFull(){
      if(n === 0) return '';

      let r = '<tr><th style="border-top:1.5px solid #000">\\(f\\)</th>';

      const specialSingleArrow =
        (n === 3 &&
         signPattern.length === 2 &&
         critKind[1] === '0' &&
         (signPattern[0] === '+' || signPattern[0] === 'âˆ’') &&
         signPattern[0] === signPattern[1]);

      const yAt = j => (fVals[j] !== undefined && fVals[j] !== null)
                        ? fVals[j]
                        : '';

      // premiÃ¨re borne x0
      const y0 = yAt(0);
      if(n === 1){
        r += cellTopBottom('', '');
        r += '</tr>';
        return r;
      }else{
        const s0 = signPattern[0];
        if(s0 === '+'){
          r += cellTopBottom('', y0);
        }else if(s0 === 'âˆ’'){
          r += cellTopBottom(y0, '');
        }else{
          r += cellTopBottom('', '');
        }
      }

      const singleArrow =
        specialSingleArrow
          ? (signPattern[0] === '+' ? 'â†—' : 'â†˜')
          : '';

      // colonnes intermÃ©diaires + borne droite
      for(let i=0;i<n-1;i++){
        if(specialSingleArrow){
          r += `<td style="border-top:1.5px solid #000"></td>`;
        }else{
          r += `<td style="border-top:1.5px solid #000">${dirPattern[i]}</td>`;
        }

        const j      = i+1;
        const isLast = (j === n-1);

        if(isLast){
          const kindLast = critKind[j] || '';
          if(kindLast === 'bar'){
            r += `<td class="dbar" style="border-top:1.5px solid #000"></td>`;
          }else{
            const yR    = yAt(j);
            const sLast = signPattern[n-2];
            if(sLast === '+'){
              r += cellTopBottom(yR, '');
            }else if(sLast === 'âˆ’'){
              r += cellTopBottom('', yR);
            }else{
              r += cellTopBottom('', '');
            }
          }
        }else{
          const kind = critKind[j] || '';

          if(kind === 'bar'){
            r += `<td class="dbar" style="border-top:1.5px solid #000"></td>`;
          }else if(specialSingleArrow && j === 1){
            r += `
              <td style="border-top:1.5px solid #000;text-align:center;vertical-align:middle;font-size:1.2em">
                ${singleArrow}
              </td>
            `;
          }else{
            const yj = yAt(j);
            const sL = signPattern[j-1];
            const sR = signPattern[j];

            if(sL === '+' && sR === 'âˆ’'){
              r += cellTopBottom(yj, '');
            }else if(sL === 'âˆ’' && sR === '+'){
              r += cellTopBottom('', yj);
            }else{
              r += cellTopBottom('', '');
            }
          }
        }
      }

      r += '</tr>';
      return r;
    }

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// 2bis. Explication du signe de f'(x) quand f'(x) est du 2nd degrÃ© (cas cubique)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
let polySignExplainBlock = '';

if(st.family === 'cubic'){
  const A2 = st.dA || 0;
  const B1 = st.dB || 0;
  const C0 = st.dC || 0;

  // CAS 1 : on a une factorisation (racines non nulles)
  if(factInfo && factInfo.kind === 'cubic'){
    const A    = factInfo.A;
    const aTex = String(A).replace(/-/g, UMIN);

    if(factInfo.form === 'double'){
      const r    = factInfo.roots[0];
      const rTex = String(r).replace(/-/g, UMIN);

      polySignExplainBlock = `
        <div class="step">
          La courbe reprÃ©sentative de \\(f'\\) est une <b>parabole</b>
          (fonction polynÃ´me du second degrÃ©) de coefficient dominant
          \\(a=${aTex}\\) avec une seule racine double.<br> Elle est <b>tangente</b> Ã  l'axe des abscisses
          en \\(x=${rTex}\\) : elle ne coupe pas l'axe et reste du mÃªme cÃ´tÃ©
          de part et d'autre de ce point.
          <br>
          Ainsi, \\(f'(x)\\) garde le signe de \\(a\\) de chaque cÃ´tÃ© de \\(x=${rTex}\\)
          et s'annule seulement en \\(x=${rTex}\\). <br>On place donc le mÃªme signe
          de \\(a\\) sur les deux intervalles et \\(0\\) sur la racine dans le
          tableau de signes.
        </div>
      `;
    }else if(factInfo.form === 'prod'){
      const roots = [...factInfo.roots].sort((u,v)=>u-v);
      const r1Tex = String(roots[0]).replace(/-/g, UMIN);
      const r2Tex = String(roots[1]).replace(/-/g, UMIN);

      polySignExplainBlock = `
        <div class="step">
          La courbe reprÃ©sentative de \\(f'\\) est une <b>parabole</b>
          (fonction polynÃ´me du second degrÃ©) de coefficient dominant
          \\(a=${aTex}\\). <br>Elle coupe l'axe des abscisses en
          \\(x=${r1Tex}\\) et \\(x=${r2Tex}\\).
          <br>
          On sait qu'une parabole de coefficient \\(a\\) est
          <b>au-dessus</b> de l'axe des abscisses (signe de \\(a\\))
          Ã  l'extÃ©rieur de l'intervalle \\([${r1Tex};${r2Tex}]\\) et
          <b>en dessous</b> de l'axe (signe opposÃ©) entre les deux racines.<br>
          On place donc le signe de \\(a\\) de part et d'autre des racines
          et le signe opposÃ© entre elles dans le tableau de signes.
        </div>
      `;
    }
  }

  // CAS 2 : f'(x) = A2 x^2 (comme -9x^2) â†’ racine double en 0, mais pas de factorisation (x-0)Â²
  else if(A2 !== 0 && B1 === 0 && C0 === 0){
    const aTex = String(A2).replace(/-/g, UMIN);
    polySignExplainBlock = `
      <div class="step">
        La dÃ©rivÃ©e est une fonction polynÃ´me du second degrÃ© de la forme
        \\(f'(x) = ${aTex}x^2\\). Sa courbe reprÃ©sentative est une
        <b>parabole</b> qui est tangente Ã  l'axe des abscisses en \\(x=0\\)
        (racine double) et ne coupe pas l'axe.
        <br>
        Elle garde donc le signe de \\(a=${aTex}\\) de part et d'autre de 0 :
        on place ce signe sur les deux intervalles et \\(0\\) sur la colonne
        \\(x=0\\) dans le tableau de signes.
      </div>
    `;
  }
}



    const res = $('#res',host);
    if(!res) return;

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // 1. DÃ‰RIVÃ‰E (toujours en premier)
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    let derivBlock = '';

    
   if(st.family === 'quad'){
  const A = 2*st.aCoeff;   // coefficient directeur de f'
  const B = st.bCoeff;
  const stepsLin = linearSolveStepsTex(A,B);

  // racine de f'(x) = 0
  const x0Frac = floatToFrac(-B / A, 30);
  const fmtFrac = fr => {
    if(fr.d === 1){
      return String(fr.n).replace(/-/g, UMIN);
    }
    const sign = fr.n < 0 ? UMIN : '';
    const nAbs = Math.abs(fr.n);
    return `${sign}\\dfrac{${nAbs}}{${fr.d}}`;
  };
  const x0Tex = fmtFrac(x0Frac);
  const mTex  = String(A).replace(/-/g, UMIN);

  const signText =
    A > 0
      ? `Comme le coefficient directeur de \\(f'(x)\\) est \\(m=${mTex}>0\\),
         la droite reprÃ©sentative de \\(f'\\) est croissante : elle est
         nÃ©gative pour \\(x<${x0Tex}\\) et positive pour \\(x>${x0Tex}\\).<br>
         On place donc le signe de \\(m=${mTex}>0\\) Ã  droite du zÃ©ro dans le tableau.`
      : `Comme le coefficient directeur de \\(f'(x)\\) est \\(m=${mTex}<0\\),
         la droite reprÃ©sentative de \\(f'\\) est dÃ©croissante : elle est
         positive pour \\(x<${x0Tex}\\) et nÃ©gative pour \\(x>${x0Tex}\\).<br>
         On place donc le signe de \\(m=${mTex}<0\\) Ã  droite du zÃ©ro dans le tableau.`;

  derivBlock = `
    <div class="step">
      On calcule la dÃ©rivÃ©e :
      \\[ ${st.dfTex} \\]
    </div>
    <div class="step">
      On rÃ©sout \\(f'(x) = 0\\) :
      ${stepsLin}
    </div>
    <div class="step">
      ${signText}
    </div>
  `;
}

    else if(st.family === 'cubic'){
      derivBlock = `
        <div class="step">
          On calcule la dÃ©rivÃ©e :
          \\[ ${st.dfTex} \\]
        </div>
      `;
    }
    else if(st.family === 'quot_aff' || st.family === 'quot_aff_quad'){
      const numType = st.dNumType || 'const';
      const denTex  = st.dDenTex;
      const numTex  = st.dNumTex || '';
      const A = st.dNumA2 || 0;
      const B = st.dNumB1 || 0;
      const C = st.dNumC0 || 0;

      // pour afficher Ã©ventuellement >0 ou <0 aprÃ¨s le numÃ©rateur
      let numSignIneq = '';
      if(numType === 'const' && typeof C === 'number'){
        if(C > 0)      numSignIneq = ' > 0';
        else if(C < 0) numSignIneq = ' < 0';
        else           numSignIneq = ' = 0';
      }

      const uTex      = st.uTex      || 'u(x)';
      const vTex      = st.vTex      || 'v(x)';
      const uPrimeTex = st.uPrimeTex || "u'(x)";
      const vPrimeTex = st.vPrimeTex || "v'(x)";

      const defDomLine =
        `<strong>Ensemble de dÃ©finition :</strong>\\( \\) \\( \\mathcal{D}_f = \\{ x \\in \\mathbb{R} \\mid ${vTex} \\neq 0 \\} \\).`;

      // RÃ©solution de v(x)=0 pour le cas quotient affine (dÃ©nominateur affine)
      let domSolveBlock = '';
      if(st.family === 'quot_aff' && typeof st.qC === 'number'){
        const A = st.qC;   // coefficient de x dans v(x)
        const B = st.qD;   // terme constant de v(x)
        const stepsTexDom = linearSolveStepsTex(A, B, 'v(x)');
        domSolveBlock = `
          <div class="step">
            On rÃ©sout \\(v(x)=0\\) pour trouver la valeur interdite :
       
              ${stepsTexDom}
        
            La solution ainsi obtenue est exclue de \\(\\mathcal{D}_f\\).
          </div>
        `;
      }

      // Ã©tude du numÃ©rateur pour le signe
      let numBlock = '';
      let afterNumText = '';

      if(numType === 'const'){
        const kTex = String(C).replace(/-/g, UMIN);
        afterNumText ='';
}else if(numType === 'lin'){
  const stepsTex = linearSolveStepsTex(B, C);
  numBlock = stepsTex;

  // numÃ©rateur : Bx + C avec B â‰  0
  const mNum = B;
  const x0Frac = floatToFrac(-C / B, 30);
  const fmtFrac = fr => {
    if(fr.d === 1){
      return String(fr.n).replace(/-/g, UMIN);
    }
    const sign = fr.n < 0 ? UMIN : '';
    const nAbs = Math.abs(fr.n);
    return `${sign}\\dfrac{${nAbs}}{${fr.d}}`;
  };
  const x0Tex = fmtFrac(x0Frac);
  const mTex  = String(mNum).replace(/-/g, UMIN);

  afterNumText =
    mNum > 0
      ? `On met ensuite le signe du numÃ©rateur dans le tableau :
         comme son coefficient directeur est \\(m=${mTex}>0\\),
         le numÃ©rateur est nÃ©gatif pour \\(x<${x0Tex}\\) et positif pour \\(x>${x0Tex}\\).
        <br> Comme le dÃ©nominateur est strictement positif sur l'ensemble de dÃ©finition,
         \\(f'(x)\\) a donc le signe \\(${UMIN}\\) puis \\(+\\).`
      : `On met ensuite le signe du numÃ©rateur dans le tableau :
         comme son coefficient directeur est \\(m=${mTex}<0\\),
         le numÃ©rateur est positif pour \\(x<${x0Tex}\\) et nÃ©gatif pour \\(x>${x0Tex}\\).
        <br> Comme le dÃ©nominateur est strictement positif sur l'ensemble de dÃ©finition,
         \\(f'(x)\\) a donc le signe \\(+\\) puis \\(${UMIN}\\).`;
		 
		 
		signExplainAfterSolve = afterNumText ? `<div class="step">${afterNumText}</div>` : '';
 
		 
}else if(numType === 'quad'){
  const Delta    = B*B - 4*A*C;   // on lâ€™utilise juste pour savoir sâ€™il y a 1 ou 2 racines
  const aTex     = String(A).replace(/-/g, UMIN);

  // ==== CAS SPÃ‰CIAL : f(x) = m x / (xÂ² âˆ’ aÂ²) ====
  // (numÃ©rateur = AxÂ² + C, on tombe sur xÂ² = a < 0)
  if(st.quotKind === 'mx_over_diffSquares'){
    // formatage d'une fraction raisonnable
    const fmtFrac = (fr) => {
      if(fr.d === 1){
        return String(fr.n).replace(/-/g, UMIN);
      }
      const sign = fr.n < 0 ? UMIN : '';
      const nAbs = Math.abs(fr.n);
      return `${sign}\\dfrac{${nAbs}}{${fr.d}}`;
    };

    // a = -C/A < 0
    const frac = floatToFrac(-C / A, 30);
    const aValTex = fmtFrac(frac);

    // monÃ´me en xÂ² sans 1 ni -1 explicite
    const monomX2 = (coef) => {
      if(coef === 1)  return 'x^2';
      if(coef === -1) return `${UMIN}x^2`;
      const abs  = Math.abs(coef);
      const sign = coef < 0 ? UMIN : '';
      return `${sign}${abs}x^2`;
    };

    // premiÃ¨re ligne : AxÂ² + C = 0, propre
    let eq1Core = `${monomX2(A)} ${C>0?'+':'-'} ${Math.abs(C)}`;
    eq1Core = cleanSigns(eq1Core);

    const minusC   = -C;
    const minusCTex = String(minusC).replace(/-/g, UMIN);

    let linesHtml = '';
    // 1) AxÂ² + C = 0
    linesHtml += `<div class="eq-line" style="text-align:left">\\(${eq1Core} = 0\\)</div>`;

    if (Math.abs(A) === 1){
      // |A| = 1 â†’ 2 lignes
      // xÂ² + 8 = 0
      // xÂ² = -8
      linesHtml += `<div class="eq-line" style="text-align:left">\\(x^2 = ${aValTex}\\)</div>`;
    } else {
      // |A| â‰  1 â†’ 3 lignes :
      // 2xÂ² + 8 = 0
      // 2xÂ² = -8
      // xÂ² = -4
      linesHtml += `<div class="eq-line" style="text-align:left">\\(${monomX2(A)} = ${minusCTex}\\)</div>`;
      linesHtml += `<div class="eq-line" style="text-align:left">\\(x^2 = ${aValTex}\\)</div>`;
    }

    linesHtml += `<div class="eq-line" style="text-align:left">\\(${aValTex} < 0\\) donc l'Ã©quation n'admet <b>aucune solution rÃ©elle</b>.</div>`;

    numBlock = `
      <div class="eq-steps">
        ${linesHtml}
      </div>
    `;
    // pas de commentaire supplÃ©mentaire ici
    afterNumText = '';
  }

  // ==== AUTRES CAS : numÃ©rateur quadratique classique (avec racines rÃ©elles) ====
  else{
    if(Delta === 0){
    afterNumText =
      `Le numÃ©rateur est une fonction polynÃ´me du second degrÃ© de coefficient dominant \\(a=${aTex}\\),
       donc sa courbe reprÃ©sentative est une <b>parabole</b> tangente Ã  l'axe des abscisses
       en un unique point. <br>Cette parabole ne coupe pas l'axe : le numÃ©rateur garde le signe
       de \\(a\\) de part et d'autre de cette racine et ne s'annule qu'en ce point.
       <br>Dans le tableau de signes, on met donc le mÃªme signe de \\(a\\) de chaque cÃ´tÃ©
       et \\(0\\) sur la racine.`;
  }else{
    afterNumText =
      `Le numÃ©rateur est une fonction polynÃ´me du second degrÃ© de coefficient dominant \\(a=${aTex}\\),
       donc sa courbe reprÃ©sentative est une <b>parabole</b> qui coupe l'axe des abscisses
       en deux points (les deux racines rÃ©elles). <br>Cette parabole est au-dessus de l'axe
       (numÃ©rateur du signe de \\(a\\)) Ã  l'extÃ©rieur de l'intervalle dÃ©limitÃ© par les racines,
       et en dessous de l'axe (signe opposÃ©) entre les deux. <br>Dans le tableau de signes,
       on place donc le signe de \\(a\\) Ã  l'extÃ©rieur des racines et le signe opposÃ©
       entre elles.`;
  }
	signExplainAfterSolve = afterNumText ? `<div class="step">${afterNumText}</div>` : '';

  }
}




      // helpers pour dÃ©cider des parenthÃ¨ses
      const normalizeMinus = t => t.replace(/\u2212/g,'-');
      const hasPlusMinus   = t => /[+\-]/.test(normalizeMinus(t));

      const isPureNumber = t => {
        const s = normalizeMinus(t.trim());
        return /^-?\d+$/.test(s);
      };

      const wrapIfNeeded = t => hasPlusMinus(t) ? `(${t})` : t;

      // facteurs dans u'(x)v(x) - v'(x)u(x)
      const dispV      = wrapIfNeeded(vTex);
      const dispU      = wrapIfNeeded(uTex);

      const dispUprime = isPureNumber(uPrimeTex)
        ? uPrimeTex.trim()
        : wrapIfNeeded(uPrimeTex);

      const dispVprime = isPureNumber(vPrimeTex)
        ? vPrimeTex.trim()
        : wrapIfNeeded(vPrimeTex);

      const lineFormule =
        `f'(x)=\\dfrac{u'(x)v(x)-v'(x)u(x)}{(v(x))^{2}}`;

      let lineSub =
        `f'(x)=\\dfrac{${dispUprime}${dispV}-${dispVprime}${dispU}}{(${vTex})^{2}}`;
      lineSub = cleanSigns(lineSub);

      // ===== Ligne "numÃ©rateur dÃ©veloppÃ©" pour TOUS les quotients =====
      let lineNumExpanded = '';

      // 1) Quotient affine / affine
      if(st.family === 'quot_aff' && typeof st.qA === 'number'){
        const a = st.qA, b = st.qB, c = st.qC, d = st.qD;
        // u(x)=ax+b, v(x)=cx+d, u'(x)=a, v'(x)=c
        // u'v - v'u = a(cx+d) - c(ax+b)
        const term1x = a*c;      // a*c x
        const term10 = a*d;      // a*d
        const term2x = -c*a;     // -c*a x
        const term20 = -c*b;     // -c*b

        const pieces = [];
        if(term1x !== 0) pieces.push(`${term1x}x`);
        if(term10 !== 0) pieces.push(`${term10}`);
        if(term2x !== 0) pieces.push(`${term2x}x`);
        if(term20 !== 0) pieces.push(`${term20}`);

        let numExpanded = pieces.join(' + ');      // ex : " -6x + -6 + 6x + -2"
        numExpanded = cleanSigns(numExpanded);     // -> "âˆ’6xâˆ’6+6xâˆ’2"

        lineNumExpanded = `f'(x)=\\dfrac{${numExpanded}}{(${vTex})^{2}}`;
      }

      // 2) Quotients avec dÃ©nominateur du second degrÃ©
      if(st.family === 'quot_aff_quad' && st.quotKind){
        if(st.quotKind === 'mx_over_diffSquares' && typeof st.mCoef === 'number'){
          const m = st.mCoef;
          const a = st.aParam;
          // m(xÂ²âˆ’aÂ²) âˆ’ 2x(mx) = m xÂ² âˆ’ m aÂ² âˆ’ 2m xÂ²
          const pieces = [
            `${m}x^2`,
            `${-m*a*a}`,
            `${-2*m}x^2`
          ];
          let numExpanded = pieces.join(' + ');
          numExpanded = cleanSigns(numExpanded);
          lineNumExpanded = `f'(x)=\\dfrac{${numExpanded}}{(${vTex})^{2}}`;
        }else if(st.quotKind === 'aff_over_quad_deltaPos' && typeof st.pCoef === 'number'){
          const p = st.pCoef, q = st.qCoef, s = st.sParam;
          // p(xÂ²+s) âˆ’ 2x(px+q) = p xÂ² + ps âˆ’ 2p xÂ² âˆ’ 2q x
          const pieces = [
            `${p}x^2`,
            `${p*s}`,
            `${-2*p}x^2`,
            `${-2*q}x`
          ];
          let numExpanded = pieces.join(' + ');
          numExpanded = cleanSigns(numExpanded);
          lineNumExpanded = `f'(x)=\\dfrac{${numExpanded}}{(${vTex})^{2}}`;
        }
        // cas const_over_quad : on garde la rÃ¨gle de l'inverse, pas de u'vâˆ’v'u
      }

      // forme polynomiale "propre" du numÃ©rateur : ax^2+bx+c, mx, ou constante
      const lineNumDev =
        `f'(x)=\\dfrac{${numTex}}{(${vTex})^{2}}`;

      // version finale dÃ©jÃ  prÃªte (avec \\bigl( â€¦ \\bigr)^2, etc.)
      const finalLine = st.dfTex.replace(/^f'(x)\s*=/,"f'(x)=");

      // DÃ©cide si on utilise la rÃ¨gle de l'inverse ou du quotient
      const useInverse = (uPrimeTex.trim() === '0');

      let methodBlock = '';

      if(useInverse){
        // ======= CAS f(x)=k / v(x) : rÃ¨gle de l'inverse =======
        const kTex = uTex;
        const baseFormula =
          `f'(x)= ${kTex}\\,\\dfrac{-v'(x)}{\\big(v(x)\\big)^{2}}`;
        const subFormula =
          `f'(x)= ${kTex}\\,\\dfrac{-${wrapIfNeeded(vPrimeTex)}}{\\left(${vTex}\\right)^{2}}`;

        methodBlock = `
          <div class="step">
            <strong>MÃ©thode â€” RÃ¨gle de l'inverse d'une fonction</strong><br>
            On a \\( \\) \\(f(x)=\\dfrac{${kTex}}{v(x)}\\) \\( \\) avec :<br>
            \\(v(x)=${vTex}\\) <br> \\(v'(x)=${vPrimeTex}\\)<br><br>
           
             \\( ${baseFormula}\\)<br>
           
           
             \\( ${subFormula}\\)<br>
           
          </div>
          <div class="step">
             \\( ${finalLine}\\)<br>
          </div>
        `;
      }else{
        // ======= CAS gÃ©nÃ©ral : rÃ¨gle du quotient =======
        methodBlock = `
          <div class="step">
            <strong>MÃ©thode â€” RÃ¨gle du quotient</strong><br>
            On a  \\( \\) \\(f(x)=\\dfrac{u(x)}{v(x)}\\)  \\( \\) avec :
            <table class="uvtab">
              <tr>
                <td>\\(u(x)=${uTex}\\)</td>
                <td>\\(v(x)=${vTex}\\)</td>
              </tr>
              <tr>
                <td>\\(u'(x)=${uPrimeTex}\\)</td>
                <td>\\(v'(x)=${vPrimeTex}\\)</td>
              </tr>
            </table>
          
             \\( ${lineFormule}\\)<br>
           
           
              \\( ${lineSub}\\)<br>
          
             \\(${lineNumExpanded ? ` ${lineNumExpanded} ` : ''}\\)<br>
         
            
              \\( ${finalLine}\\)<br>
            
          </div>
        `;
      }

      // ðŸ‘‰ðŸ‘‰ ICI : bloc "Sur l'ensemble de dÃ©finition..." mis Ã  part
     quotientSignBlock = `
  <div class="step">
    Sur l'ensemble de dÃ©finition de \\(f\\),
    \\(${denTex} > 0\\) donc \\(f'(x)\\) est du
    signe de ${
      numTex
        ? `\\(${numTex}${numSignIneq}\\)`
        : `son numÃ©rateur`
    }.
    ${
      numType === 'const'
        ? ''
        : `
           <br>On Ã©tudie le signe de ce numÃ©rateur en rÃ©solvant \\(f'(x)=0\\).
           ${numBlock}
          `
    }
  </div>
`;


      // dÃ©rivÃ©e : domaine + mÃ©thode, SANS le bloc ci-dessus
      derivBlock = `
        <div class="step">
          ${defDomLine}
        </div>
        ${
          domSolveBlock ||
          `
          <div class="step">
            Remarque : Si l'Ã©noncÃ© demande clairement l'ensemble de dÃ©finition de \\(f\\),
            il faut alors rÃ©soudre : \\( ${vTex}=0 \\) et exclure les racines Ã©ventuelles.
          </div>
          `
        }
        <div class="step">
          On calcule la dÃ©rivÃ©e :
        </div>
        ${methodBlock}
      `;
    }

    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // 2. DÃ‰VELOPPEMENT DE LA FORME FACTORISÃ‰E (si elle existe)
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const factorDevelopBlock = (() => {
      if(!factInfo) return '';

      const devSteps = [];   // ce qui ira dans la 3Ã¨me colonne
      let leftExpr   = '';   // 1Ã¨re colonne : forme factorisÃ©e

      const numTex = x => String(x).replace(/-/g, UMIN);

      // k Ã— (â€¦ ) avec gestion de 1 / -1
      function coefTimes(A, expr){
        const absA = Math.abs(A);
        const aTex = String(absA).replace(/-/g, UMIN);
        if (A === 1)  return expr;
        if (A === -1) return `${UMIN}${expr}`;
        if (A < 0)    return `${UMIN}${aTex}${expr}`;
        return `${aTex}${expr}`;
      }

      // petit outil pour Ã©crire un polynÃ´me A xÂ² + B x + C sans 1x
      function polyAx2BxC(A,B,C){
        let s = '';

        if(A){
          if(A === 1)       s += 'x^2';
          else if(A === -1) s += `${UMIN}x^2`;
          else              s += `${A}x^2`;
        }

        if(B){
          const sign = B>0 ? '+' : UMIN;
          const absB = Math.abs(B);
          const core = (absB === 1) ? 'x' : `${absB}x`;
          s += ` ${sign} ${core}`;
        }

        if(C){
          const sign = C>0 ? '+' : UMIN;
          const absC = Math.abs(C);
          s += ` ${sign} ${absC}`;
        }

        return cleanSigns(s);
      }

      // monÃ´me de type kx sans 1x
      function monomX(coef){
        if(!coef) return '';
        const sign = coef>0 ? '+' : UMIN;
        const abs  = Math.abs(coef);
        const core = (abs === 1) ? 'x' : `${abs}x`;
        return ` ${sign} ${core}`;
      }

      // terme constant
      function constTerm(c){
        if(!c) return '';
        const sign = c>0 ? '+' : UMIN;
        const abs  = Math.abs(c);
        return ` ${sign} ${abs}`;
      }

      // ===== CAS f polynÃ´me du 3Ã¨me degrÃ© =====
      if(factInfo.kind === 'cubic'){
        const A = factInfo.A;

        if(factInfo.form === 'double'){
          const a    = factInfo.roots[0];
          const aAbs = Math.abs(a);
          const aSig = a >= 0 ? UMIN : '+';
          const aDisp = numTex(aAbs);

          const factor = `\\bigl(x ${aSig} ${aDisp}\\bigr)^2`;
          leftExpr = factInfo.tex.replace(/^f'\(x\)\s*=\s*/, ''); // juste la partie factorisÃ©e

          // (x-a)^2 = x^2 - 2ax + a^2
          const B1 = -2*a;
          const C1 =  a*a;
          let inner1 = `x^2${monomX(B1)}${constTerm(C1)}`;
          inner1 = cleanSigns(inner1);
          devSteps.push(leftExpr.replace(/\\bigl\(x[^)]*\\bigr\)\^2/, `\\bigl(${inner1}\\bigr)`));

          // Ax^2 + Bx + C
          const A2 = A;
          const B2 = A*B1;
          const C2 = A*C1;
          const inner2 = polyAx2BxC(A2,B2,C2);
          devSteps.push(inner2);

          devSteps.push(`f'(x)`);
        }

        if(factInfo.form === 'prod'){
          const r1 = factInfo.roots[0];
          const r2 = factInfo.roots[1];

          leftExpr = factInfo.tex.replace(/^f'\(x\)\s*=\s*/, '');

          const sym = Math.abs(r1 + r2) < 1e-9 && Math.abs(r1) > 0; // cas (x-a)(x+a)

          if(sym){
            const a  = Math.abs(r1);
            const a2 = a*a;
            let inner1 = `x^2 ${UMIN} ${numTex(a2)}`;
            inner1 = cleanSigns(inner1);

            // remplace (x-a)(x+a) par (xÂ² âˆ’ aÂ²)
            devSteps.push(leftExpr.replace(/\\bigl\(.*?\\bigr\)\\bigl\(.*?\\bigr\)/, `\\bigl(${inner1}\\bigr)`));

            const A2 = A;
            const B2 = 0;
            const C2 = A*(-a2);
            const inner2 = polyAx2BxC(A2,B2,C2);
            devSteps.push(inner2);

            devSteps.push(`f'(x)`);
          }else{
            // FOIL : xÂ² + (â€¦ )x + â€¦
            const p  = r1*r2;
            const s  = r1+r2;

            let innerFOIL = `x^2${monomX(-r2)}${monomX(-r1)}${constTerm(p)}`;
            innerFOIL = cleanSigns(innerFOIL);
            devSteps.push(leftExpr.replace(/\\bigl\(.*?\\bigr\)\\bigl\(.*?\\bigr\)/, `\\bigl(${innerFOIL}\\bigr)`));

            // puis x^2 - (r1+r2)x + r1r2
            const inner2 = polyAx2BxC(1,-s,p);
            devSteps.push(leftExpr.replace(/\\bigl\(.*?\\bigr\)\\bigl\(.*?\\bigr\)/, `\\bigl(${inner2}\\bigr)`));

            // puis polynÃ´me final (dfTex2)
            devSteps.push(st.dfTex2);

            devSteps.push(`f'(x)`);
          }
        }
      }

      // ===== CAS quotient =====
      if(factInfo.kind === 'quot'){
        const A   = factInfo.A;
        const den = st.dDenTex || '(v(x))^{2}';

        // numÃ©rateur de type A(xÂ² + aÂ²)
        if(factInfo.numForm === 'sumSquares'){
          const a   = factInfo.a;
          const a2  = a*a;
          const a2T = numTex(a2);

          const numFactor = `\\bigl(x^2 + ${a2T}\\bigr)`;
          const numFact   = coefTimes(A, numFactor);

          leftExpr = `\\dfrac{${numFact}}{${den}}`;

          // dÃ©veloppement : A xÂ² + A aÂ²
          const B1 = 0;
          const C1 = A*a2;
          const numDev = polyAx2BxC(A,B1,C1);
          devSteps.push(`\\dfrac{${numDev}}{${den}}`);

          devSteps.push(`f'(x)`);
        }

        // numÃ©rateur de type A(x-r1)(x-r2)
        if(factInfo.numForm === 'roots'){
          const [r1, r2] = factInfo.roots;
          leftExpr = factInfo.quotTex; // forme factorisÃ©e affichÃ©e en 1re colonne
          
          const p  = r1 * r2;
          const s  = r1 + r2;

          // numÃ©rateur FOIL : xÂ² - r2 x - r1 x + p
          let innerFOIL = `x^2${monomX(-r2)}${monomX(-r1)}${constTerm(p)}`;
          innerFOIL = cleanSigns(innerFOIL);

          // numÃ©rateur simplifiÃ© : xÂ² - (r1+r2)x + r1r2
          const innerSimp = polyAx2BxC(1, -s, p);

          // numÃ©rateur dÃ©veloppÃ© final : A2 xÂ² + B2 x + C2
          const A2 = st.dNumA2 || 0;
          const B2 = st.dNumB1 || 0;
          const C2 = st.dNumC0 || 0;
          const numDev = polyAx2BxC(A2, B2, C2);

          if (A === 1){
            // ===== CAS COEFF = 1 â†’ 3 lignes de dÃ©veloppement =====
            // 1) FOIL sans parenthÃ¨ses inutiles
            devSteps.push(`\\dfrac{${innerFOIL}}{${den}}`);
            // 2) numÃ©rateur simplifiÃ©
            devSteps.push(`\\dfrac{${innerSimp}}{${den}}`);
            // 3) derniÃ¨re ligne : = f'(x)
            devSteps.push(`f'(x)`);
          } else {
            // ===== CAS COEFF â‰  1 (y compris -1) â†’ 4 lignes =====

            // 1) A * FOIL entre parenthÃ¨ses
            const numFOILwithA = coefTimes(A, `\\bigl(${innerFOIL}\\bigr)`);
            devSteps.push(`\\dfrac{${numFOILwithA}}{${den}}`);

            // 2) A * numÃ©rateur simplifiÃ© entre parenthÃ¨ses
            const numSimpWithA = coefTimes(A, `\\bigl(${innerSimp}\\bigr)`);
            devSteps.push(`\\dfrac{${numSimpWithA}}{${den}}`);

            // 3) on dÃ©veloppe le A dans la parenthÃ¨se : numÃ©rateur final
            devSteps.push(`\\dfrac{${numDev}}{${den}}`);

            // 4) derniÃ¨re ligne : = f'(x)
            devSteps.push(`f'(x)`);
          }
        }

      }

      if(!leftExpr || !devSteps.length) return '';

      // On enlÃ¨ve Ã©ventuellement un "f'(x) =" au dÃ©but des Ã©tapes
      const cleanedSteps = devSteps.map(s => {
        if(!s) return s;
        return s.replace(/^f'\(x\)\s*=\s*/, '');
      });

      const rowsHtml = cleanedSteps.map((right,idx)=>`
        <tr>
          <td style="text-align:left;padding-right:8px">
            ${idx===0 ? `\\(${leftExpr}\\)` : '&nbsp;'}
          </td>
          <td style="text-align:center;padding:0 6px">=</td>
          <td style="text-align:left">\\(${right}\\)</td>
        </tr>
      `).join('');

      return `
        <div class="step">
          On dÃ©veloppe la forme factorisÃ©e de \\(f'(x)\\) :
          <table class="devtab">
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>
        </div>
      `;
    })();


    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    // 3. RÃ‰SOLUTION DE f'(x)=0 Ã€ PARTIR DE LA FORME FACTORISÃ‰E
    // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
const factorSolveBlock = (() => {
  const lines = [];

  const coefTimesSolve = (A, expr) => {
    const absA = Math.abs(A);
    const aTex = String(absA).replace(/-/g, UMIN);
    if (A === 1)  return expr;              // 1(x-3) â†’ (x-3)
    if (A === -1) return `${UMIN}${expr}`;  // -1(x-3) â†’ âˆ’(x-3)
    if (A < 0)    return `${UMIN}${aTex}${expr}`;
    return `${aTex}${expr}`;
  };

  // ===== 1) CAS AVEC forme factorisÃ©e (factInfo non nul) =====
  if(factInfo){
    if(factInfo.kind === 'cubic'){
      const A = factInfo.A;

      if(factInfo.form === 'double'){
        const a = factInfo.roots[0];
        const aAbs  = Math.abs(a);
        const aSig  = a >= 0 ? UMIN : '+';
        const aDisp = String(aAbs).replace(/-/g, UMIN);
        const t     = `x ${aSig} ${aDisp}`;
        const factor = `\\bigl(${t}\\bigr)^2`;

        lines.push(`f'(x) = 0`);
        lines.push(`${coefTimesSolve(A, factor)} = 0`);
        lines.push(`\\bigl(${t}\\bigr)^2 = 0`);
        lines.push(`${t} = 0`);
        lines.push(`x = ${String(a).replace(/-/g, UMIN)}`);
      }else if(factInfo.form === 'prod'){
        const [r1, r2] = factInfo.roots;

        const term = r => {
          const aAbs  = Math.abs(r);
          const aSig  = r >= 0 ? UMIN : '+';
          const aDisp = String(aAbs).replace(/-/g, UMIN);
          return `x ${aSig} ${aDisp}`;
        };

        const t1 = term(r1);
        const t2 = term(r2);
        const prod = `\\bigl(${t1}\\bigr)\\bigl(${t2}\\bigr)`;

        lines.push(`f'(x) = 0`);
        lines.push(`${coefTimesSolve(A, prod)} = 0`);
        lines.push(`${prod} = 0`);
        lines.push(`${t1} = 0 \\text{ ou } ${t2} = 0`);
        lines.push(`x = ${String(r1).replace(/-/g, UMIN)} \\text{ ou } x = ${String(r2).replace(/-/g, UMIN)}`);
      }
    }

    if(factInfo.kind === 'quot'){
      const A     = factInfo.A;
      const denTx = st.dDenTex || '(v(x))^{2}';

      if(factInfo.numForm === 'sumSquares'){
        const a   = factInfo.a;
        const a2  = a*a;
        const a2T = String(a2).replace(/-/g, UMIN);

        const numFactor = `\\bigl(x^2 + ${a2T}\\bigr)`;
        const numFact   = coefTimesSolve(A, numFactor);

        lines.push(`f'(x) = 0`);
        lines.push(`\\dfrac{${numFact}}{${denTx}} = 0`);
        lines.push(`${numFact} = 0`);
        lines.push(`x^2 + ${a2T} = 0`);
        lines.push(`TEXT:Comme \\(x^2 \\ge 0\\) et \\(${a2T} > 0\\), il n'y a pas de solution rÃ©elle.`);
      }else if(factInfo.numForm === 'roots'){
        const [r1, r2] = factInfo.roots;

        const term = r => {
          const aAbs  = Math.abs(r);
          const aSig  = r >= 0 ? UMIN : '+';
          const aDisp = String(aAbs).replace(/-/g, UMIN);
          return `x ${aSig} ${aDisp}`;
        };

        const t1 = term(r1);
        const t2 = term(r2);
        const prod = `\\bigl(${t1}\\bigr)\\bigl(${t2}\\bigr)`;
        const numFact = coefTimesSolve(A, prod);

        const denTx2 = st.dDenTex || '(v(x))^{2}';

        lines.push(`f'(x) = 0`);
        lines.push(`\\dfrac{${numFact}}{${denTx2}} = 0`);
        if(numFact !== prod){
          lines.push(`${numFact} = 0`);
        }
        lines.push(`${prod} = 0`);
        lines.push(`${t1} = 0 \\text{ ou } ${t2} = 0`);
        lines.push(`x = ${String(r1).replace(/-/g, UMIN)} \\text{ ou } x = ${String(r2).replace(/-/g, UMIN)}`);
      }
    }
  }

  // ===== 2) CAS SPÃ‰CIAL : f'(x) = k xÂ² (pas de forme (x-0)Â²) =====
  if(!factInfo && st.family === 'cubic'){
    const A2 = st.dA || 0;
    const B1 = st.dB || 0;
    const C0 = st.dC || 0;

    if(A2 !== 0 && B1 === 0 && C0 === 0){
      const coefTex = String(A2).replace(/-/g, UMIN);
      const monom = (A2 === 1)
        ? 'x^2'
        : (A2 === -1 ? `${UMIN}x^2` : `${coefTex}x^2`);

      lines.push(`f'(x) = 0`);
      lines.push(`${monom} = 0`);
      lines.push(`x^2 = 0`);
      lines.push(`x = 0`);
    }
  }

  if(!lines.length) return '';

  return `
    <div class="step">
      On rÃ©sout l'Ã©quation \\(f'(x) = 0\\) Ã  partir de la forme de \\(f'(x)\\) :
      ${lines.map(t => {
        if(t.startsWith('TEXT:')){
          const txt = t.slice(5);
          return `<div class="eq-line" style="text-align:left">${txt}</div>`;
        }
        return `<div class="eq-line" style="text-align:left">\\(${t}\\)</div>`;
      }).join('')}
    </div>
  `;
})();



res.innerHTML = `
  <div class="step">
    La fonction \\(f\\) est un <b>${famLabel}</b> avec
    \\[ ${st.fTex} \\]
  </div>

  ${derivBlock}
  ${factorDevelopBlock}
  ${quotientSignBlock}
  ${factorSolveBlock}
  ${polySignExplainBlock}
  ${signExplainAfterSolve}

  <div class="step">
    <div class="var-wrap" style="margin-top:.25rem">
      <table class="pdf-tbl">
        <tbody>
          ${rowX()}
          ${rowFpFull()}
          ${rowFFull()}
        </tbody>
      </table>
    </div>
  </div>
`;



    ensureTickAfter(res).className = 'tick ok';
    typesetAll(res);
  },




  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Reset
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  reset(host){
    const dfInput = host.querySelector('.df-input');
    if(dfInput){ dfInput.value=''; setTick(dfInput,'nu'); }

    host.querySelectorAll('.sign-int, .dir-int, .fp-zero-kind, .ext-max-tab, .ext-min-tab').forEach(sel=>{
      sel.value='';
      setTick(sel,'nu');
    });

    ['.ext-max','.ext-min'].forEach(sel=>{
      const inp = host.querySelector(sel);
      if(inp){ inp.value=''; setTick(inp,'nu'); }
    });

    const res = $('#res',host);
    if(res){
      res.innerHTML='';
      ensureTickAfter(res).className='tick nu';
    }
  }
};

/* â€”â€”â€”â€”â€” Registre & UI â€”â€”â€”â€”â€” */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: `1Ã¨re STI2D â€“ Ã‰tude de fonctions â€¢ Lien entre le signe de la dÃ©rivÃ©e et les variations d'une fonction f`,
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def = getDefById($("#exo-select").value);
  const host = $("#host");

  // On essaie de rÃ©cupÃ©rer la famille du dernier Ã©tat
  let famOverride;
  try{
    const prev = JSON.parse(host.dataset.state || '{}');
    if (prev && prev.family) {
      famOverride = prev.family;
    }
  }catch(e){
    famOverride = undefined;
  }

  // Si pas d'Ã©tat prÃ©cÃ©dent (premier appel), famOverride = undefined â†’ famille alÃ©atoire
  const st = def.gen(famOverride);

  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);

  try{
    if (window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}

function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>

</body>
</html>
