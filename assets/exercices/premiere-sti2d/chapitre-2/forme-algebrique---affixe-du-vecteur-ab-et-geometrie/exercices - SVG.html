<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Vecteurs - Coordonnées</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}
/* Bloc solution (UI) */
#res.steps{
  background: #f3f4f6;      /* gris clair */
  border: 1px solid #e5e7eb;
  border-left: 4px solid #9aa0a6;  /* liseré gris */
  border-radius: 8px;
  padding: 10px;
}
#res.steps p { margin: .25rem 0; }

</style>

<!-- MathJax -->
<!-- ⭐ MATHJAX CONFIG CHTML -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Vecteurs - Coordonnées</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; réponses acceptées :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Affixes au format \(a+bi\) (fractions/virgules décimales OK), ex. <code>3/2 - i</code>.</li>
        <li>Jamais <em>0+bi</em>, <em>a+0i</em> ni <em>1i</em> dans les affichages.</li>
        <li>Tous les calculs de fractions restent en fractions.</li>
      <li>
  <strong>Racine carrée :</strong>
  on accepte <code>sqrt(…)</code>, <code>rac(…)</code> et le symbole
  unicode <code>√…</code>.
  Exemples corrects : <code>sqrt(5)</code>, <code>rac(5)</code>, <code>√5</code>, <code>√(5)</code>.
</li>
<li>
  <strong>Attention à l’ambiguïté :</strong>
  <code>√25/5</code> est interprété comme <code>(√25)/5</code>.
  Pour <code>√(25/5)</code>, mettez les parenthèses.
</li>
	  </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Helpers UI ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
const HOST = $('#host');
function retypeset(host){ if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; }

/* ====== Rationnels exacts ====== */
function R(p,q=1){ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function addR(x,y){ return R(x.p*y.q + y.p*x.q, x.q*y.q); }
function subR(x,y){ return R(x.p*y.q - y.p*x.q, x.q*y.q); }
function mulR(x,y){ return R(x.p*y.p, x.q*y.q); }
function negR(x){ return R(-x.p, x.q); }
function absR(x){ return R(Math.abs(x.p), x.q); }
function isZeroR(x){ return x.p===0; }
function isOneAbsR(x){ return Math.abs(x.p)===x.q; }
function numR(x){ return x.p/x.q; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'−':''; const P=Math.abs(r.p); return s+'\\dfrac{'+P+'}{'+r.q+'}'; }
function textR(r){ return r.q===1 ? String(r.p) : `${r.p}/${r.q}`; }

/* ====== Formats (jamais 0+bi, a+0i, 1i) ====== */
function fmtILaR(k){ const a=absR(k); return isOneAbsR(a) ? 'i' : latexR(a)+'i'; }
function fmtZLaR(ax,by){
  if(isZeroR(by)) return latexR(ax);
  if(isZeroR(ax)) return (by.p<0?'−':'')+fmtILaR(by);
  return latexR(ax)+(by.p>=0?' + ':' − ')+fmtILaR(by);
}
function fmtITextR(k){ const a=absR(k); return isOneAbsR(a) ? 'i' : textR(a)+'i'; }
function fmtZTextR(ax,by){
  if(isZeroR(by)) return textR(ax);
  if(isZeroR(ax)) return (by.p<0?'-':'')+fmtITextR(by);
  return textR(ax)+(by.p>=0?' + ':' - ')+fmtITextR(by);
}

/* (entiers) */
function fmtNum(n){ return Number.isInteger(n)?String(n):String(n).replace('.',','); }
function fmtILaNum(k){ const a=Math.abs(k); return Math.abs(a-1)<1e-12?'i':fmtNum(a)+'i'; }
function fmtZLaNum(a,b){
  if(Math.abs(b)<1e-12) return fmtNum(a);
  if(Math.abs(a)<1e-12) return (b<0?'−':'')+fmtILaNum(b);
  return fmtNum(a)+(b>=0?' + ':' − ')+fmtILaNum(b);
}

/* Substitution ligne 2 sans parenthèses autour de z_B */
function subLine_BminusA(B,A){
  const left  = fmtZLaR(B.a,B.b);
  const right = fmtZLaR(A.a,A.b);
  if (isZeroR(A.a) && A.b.p > 0) return `z_{\\overrightarrow{AB}} = ${left} − ${right}`;
  return `z_{\\overrightarrow{AB}} = ${left} − (${right})`;
}
function subLine_CminusD(C,D){
  const left  = fmtZLaR(C.a,C.b);
  const right = fmtZLaR(D.a,D.b);
  if (isZeroR(D.a) && D.b.p > 0) return `z_{\\overrightarrow{DC}} = ${left} − ${right}`;
  return `z_{\\overrightarrow{DC}} = ${left} − (${right})`;
}
function coefK_R(U, V){
  if (!isZeroR(U.a)) return mulR(V.a, R(U.a.q, U.a.p));
  if (!isZeroR(U.b)) return mulR(V.b, R(U.b.q, U.b.p));
  return R(0,1);
}

/* Numérique */
function subLine_BminusA_num(B,A){
  const left  = fmtZLaNum(B.a,B.b);
  const right = fmtZLaNum(A.a,A.b);
  if (A.a===0 && A.b>0) return `z_{\\overrightarrow{AB}} = ${left} − ${right}`;
  return `z_{\\overrightarrow{AB}} = ${left} − (${right})`;
}
function subLine_DminusC_num(D,C){
  const left  = fmtZLaNum(D.a,D.b);
  const right = fmtZLaNum(C.a,C.b);
  if (C.a===0 && C.b>0) return `z_{\\overrightarrow{CD}} = ${left} − ${right}`;
  return `z_{\\overrightarrow{CD}} = ${left} − (${right})`;
}
function rhsOf(eqLine){ const m = eqLine.match(/=(.*)$/); return m ? m[1].trim() : ''; }
function mustExpand(subLine){ return rhsOf(subLine).includes('('); }
function subLine_num(label, L, R){
  const left  = fmtZLaNum(L.a,L.b), right = fmtZLaNum(R.a,R.b);
  return (R.a===0 && R.b>0) ? `${label} = ${left} − ${right}` : `${label} = ${left} − (${right})`;
}
function expandDiff(B,A){
  const terms = [];
  if (!isZeroR(B.a)) terms.push({sign: B.a.p<0?'-':'+', txt: latexR(absR(B.a))});
  if (!isZeroR(B.b)) terms.push({sign: B.b.p<0?'-':'+', txt: fmtILaR(absR(B.b))});
  const mAa = negR(A.a); if (!isZeroR(mAa)) terms.push({sign: mAa.p<0?'-':'+', txt: latexR(absR(mAa))});
  const mAb = negR(A.b); if (!isZeroR(mAb)) terms.push({sign: mAb.p<0?'-':'+', txt: fmtILaR(absR(mAb))});
  if (!terms.length) return '0';
  let out = (terms[0].sign==='-' ? '− ' : '') + terms[0].txt;
  for (let i=1;i<terms.length;i++){ out += (terms[i].sign==='-' ? ' − ' : ' + ') + terms[i].txt; }
  return out;
}
function plusJoinLatex(left, right){
  const r = (right||'').trim();
  if (/^[\u2212-]/.test(r)) {
    const stripped = r.replace(/^[\u2212-]\s*/, '');
    return `${left} − ${stripped}`;
  }
  return `${left} + ${r}`;
}

/* UI helpers */
function normalizeMinus(s){ return s.replace(/\u2212/g,'-'); }
function parseNumber(token){ token=token.replace(',','.'); if(/^[-+]?\d+\/\d+$/.test(token)){const [p,q]=token.split('/').map(Number);return p/q;} return token===''?0:Number(token); }
function parseComplex(str){
  let s=normalizeMinus(String(str)).replace(/·|×/g,'*').replace(/\s+/g,''); s=s.replace(/([+-])/g,' $1').trim();
  const parts=s.split(' ').filter(Boolean); let a=0,b=0;
  for(const t of parts){ if(t.includes('i')){ const c=t.replace('i',''); b+= (c===''||c==='+')?1:(c==='-'?-1:parseNumber(c)); } else a+=parseNumber(t); }
  return {a,b};
}
function stripAccents(s){ return (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
function evalMaybeSqrt(input){
  if(!input) return NaN;

  // Normalisations
  let s = String(input);
  s = s.replace(/\u2212/g,'-')            // − → -
       .replace(',', '.')                 // , décimale → .
       .replace(/·|×/g,'*')               // points/× → *
       .trim();

  // Unifier les marqueurs de racine en un seul symbole "√"
  // (ainsi on gère rac/sqrt/√ de la même façon)
  s = s.replace(/rac/gi, '√')
       .replace(/sqrt/gi, '√');

  // Convertir chaque "√arg" en Math.sqrt(arg)
  // - si arg est parenthésé → on récupère le bloc équilibré
  // - sinon on prend juste le nombre immédiat (optionnellement signé et décimal)
  function toMathSqrt(str){
    let out = '';
    for (let i = 0; i < str.length; i++){
      const ch = str[i];
      if (ch !== '√'){ out += ch; continue; }

      // sauter espaces après √
      let j = i + 1;
      while (j < str.length && /\s/.test(str[j])) j++;

      if (str[j] === '('){
        // capturer l'expression parenthésée équilibrée
        let k = j, depth = 0;
        while (k < str.length){
          if (str[k] === '(') depth++;
          else if (str[k] === ')'){ depth--; if (depth === 0){ k++; break; } }
          k++;
        }
        // si on n'a pas trouvé de parenthèse fermante, on abandonne proprement
        const inside = str.slice(j+1, (k>j? k-1 : j));
        out += 'Math.sqrt(' + inside + ')';
        i = (k>j ? k-1 : j-1); // repositionner le curseur
      } else {
        // nombre nu : [+/-]digits(.digits)?
        const m = str.slice(j).match(/^[+\-]?\d+(?:\.\d+)?/);
        if (m){
          out += 'Math.sqrt(' + m[0] + ')';
          i = j + m[0].length - 1;
        } else {
          // pas d’argument lisible : on met une racine de 0 pour éviter l’erreur
          out += 'Math.sqrt(0)';
        }
      }
    }
    return out;
  }
  s = toMathSqrt(s);

  // Garde-fou : uniquement chiffres, opérateurs, parenthèses et "Math.sqrt"
  const cleaned = s.replace(/Math\.sqrt/g,'');
  if (/[^0-9+\-*/().\s]/.test(cleaned)) return NaN;

  // Évaluation sûre
  try { return Function('return (' + s + ')')(); }
  catch { return NaN; }
}

function setFB(ok,msg=''){ const fb=$('#fb',HOST); fb.className = ok?'ok':'ko'; fb.textContent = (ok?'✔︎ Correct. ':'✗ Incorrect. ') + msg; }
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq"></div>
    <hr class="sep">
    <div class="controls">
      <label class="input">Réponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>
  `;
}
function setStepsHTML(html){ $('#res',HOST).innerHTML=html; retypeset(HOST); }
function setSteps(lines){ setStepsHTML(lines.map(L=>`<p>${L}</p>`).join('')); }
function isPerfectSquare(n){ if(n<0) return false; const r=Math.floor(Math.sqrt(n)); return r*r===n; }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function setEqu(html){ const box = $('#equ', HOST); if (box) box.innerHTML = html; retypeset(HOST); }
/* ==== Unicité des affixes (points tous distincts) ==== */
function asNum(x){ return (x && typeof x==='object' && 'p' in x && 'q' in x) ? x.p/x.q : +x; }
function sameAffix(P,Q){ return asNum(P.a)===asNum(Q.a) && asNum(P.b)===asNum(Q.b); }
function allDistinctPts(list){
  for(let i=0;i<list.length;i++){
    for(let j=i+1;j<list.length;j++){
      if(sameAffix(list[i],list[j])) return false;
    }
  }
  return true;
}
function randPointR(min,max, existing=[]){
  let P;
  do{ P={a:R(randInt(min,max)), b:R(randInt(min,max))}; }
  while(existing.some(E=>sameAffix(E,P)));
  return P;
}
function randPointNum(min,max, existing=[]){
  let P;
  do{ P={a:randInt(min,max), b:randInt(min,max)}; }
  while(existing.some(E=>sameAffix(E,P)));
  return P;
}
// Orchestrateur "pile ou face" : alternance en mode PDF, aléa normal en UI



// Alternateur strict par exercice (e3/e4)
const COIN = {
  state: new Map(),    // valeur validée (boolean) du dernier tirage
  pending: new Map(),  // valeur "souhaitée" pour le tirage en cours
  // renvoie la valeur voulue pour ce tour sans la valider encore
  want(tag){
    if (this.pending.has(tag)) return this.pending.get(tag);
    const last = this.state.get(tag) ?? false; // point de départ: false → premier tour sera true
    const next = !last;                        // alterne strictement
    this.pending.set(tag, next);
    return next;
  },
  // à appeler quand la génération a réussi → on valide l’alternance
  commit(tag){
    if (!this.pending.has(tag)) return;
    this.state.set(tag, this.pending.get(tag));
    this.pending.delete(tag);
  },
  // si tu abandonnes le tirage courant, tu peux annuler (pas utile ici)
  cancel(tag){ this.pending.delete(tag); }
};
function flip(tag){
  if (!COIN.pdfMode) return Math.random() < 0.5; // UI : aléatoire
  const n = COIN.count.get(tag) || 0;
  COIN.count.set(tag, n+1);
  return (n % 2 === 0); // true, false, true, false, ...
}
/* ====== Exercices ====== */
const REGISTRY_MAP = {

  /* e1 */
  e1:{ name:"Affixe d'un vecteur", 
    gen(){
  const A0 = randPointR(-8,8);
  const B0 = randPointR(-8,8, [A0]);
  const A = {a:A0.a,b:A0.b, latex:`z_A=${fmtZLaR(A0.a,A0.b)}`};
  const B = {a:B0.a,b:B0.b, latex:`z_B=${fmtZLaR(B0.a,B0.b)}`};
  this.state = {A,B};
  setEqu(`<p>On considère les points \\(A\\) et \\(B\\) d’affixes \\(${A.latex}\\) et \\(${B.latex}\\).</p> <p>Calculer l’affixe du vecteur \\(\\overrightarrow{AB}\\).</p>`);
},
    verify(){ const {A,B}=this.state; const E={a:numR(subR(B.a,A.a)),b:numR(subR(B.b,A.b))};
      const ans=parseComplex($('#ans',HOST).value); const ok=Math.abs(ans.a-E.a)<1e-9 && Math.abs(ans.b-E.b)<1e-9;
      setFB(ok, ok?``:`Attendu : \\(${fmtZLaR(subR(B.a,A.a),subR(B.b,A.b))}\\).`); return ok;
    },
    solution(){
      const {A,B}=this.state;
      const aR=subR(B.a,A.a), bR=subR(B.b,A.b);
      const L1 = `\\( z_{\\overrightarrow{AB}} = z_B − z_A \\)`;
      const L2s = subLine_BminusA(B,A);
      const L3s = `z_{\\overrightarrow{AB}} = ${expandDiff(B,A)}`;
      const lines = [`${L1}`, `\\( ${L2s} \\)`];
      if (mustExpand(L2s)) lines.push(`\\( ${L3s} \\)`);
      lines.push(`\\( z_{\\overrightarrow{AB}} = ${fmtZLaR(aR,bR)} \\)`);
      setSteps(lines);
    }
  },

  /* e2 */
  e2:{ name:"Nature du quadrilatère ABCD", 
    gen(){
  let A0,B0,C0,D;
  do{
    A0 = randPointR(-6,6);
    B0 = randPointR(-6,6, [A0]);
    C0 = randPointR(-6,6, [A0,B0]);
    D  = { a:addR(A0.a, subR(C0.a,B0.a)), b:addR(A0.b, subR(C0.b,B0.b)) };
  }while(!allDistinctPts([A0,B0,C0,D]));

  const A={a:A0.a,b:A0.b,latex:`z_A=${fmtZLaR(A0.a,A0.b)}`};
  const B={a:B0.a,b:B0.b,latex:`z_B=${fmtZLaR(B0.a,B0.b)}`};
  const C={a:C0.a,b:C0.b,latex:`z_C=${fmtZLaR(C0.a,C0.b)}`};
  this.state={A,B,C,D};
setEqu(
  `<p>On considère les points \\(A\\), \\(B\\), \\(C\\) et \\(D\\) d’affixes \\(${A.latex}\\), \\(${B.latex}\\), \\(${C.latex}\\) et \\(z_D=${fmtZLaR(D.a,D.b)}\\).</p>
   <p>Quelle est la nature du quadrilatère \\(ABCD\\) ?</p>`
);
},
    verify(){ const rep=stripAccents($('#ans',HOST).value); const ok=/parallelogramme/.test(rep); setFB(ok, ok?``:`Répondre « parallélogramme ».`); return ok; },
    // REGISTRY.e2.solution — TABLE borderless
solution(){
  const {A,B,C,D}=this.state;
  const abA=subR(B.a,A.a), abB=subR(B.b,A.b);
  const dcA=subR(C.a,D.a), dcB=subR(C.b,D.b);

  const subAB = subLine_BminusA(B,A);
  const subDC = subLine_CminusD(C,D);

  const leftLines = [
    `\\( z_{\\overrightarrow{AB}} = z_B - z_A \\)`,
    `\\( ${subAB} \\)`
  ];
  if (mustExpand(subAB)) leftLines.push(`\\( z_{\\overrightarrow{AB}} = ${expandDiff(B,A)} \\)`);
  leftLines.push(`\\( z_{\\overrightarrow{AB}} = ${fmtZLaR(abA,abB)} \\)`);

  const rightLines = [
    `\\( z_{\\overrightarrow{DC}} = z_C - z_D \\)`,
    `\\( ${subDC} \\)`
  ];
  if (mustExpand(subDC)) rightLines.push(`\\( z_{\\overrightarrow{DC}} = ${expandDiff(C,D)} \\)`);
  rightLines.push(`\\( z_{\\overrightarrow{DC}} = ${fmtZLaR(dcA,dcB)} \\)`);

  const left  = leftLines.map(L => `<p>${L}</p>`).join('');
  const right = rightLines.map(L => `<p>${L}</p>`).join('');

  setStepsHTML(
    `<table style="border-collapse:collapse;width:100%;">
       <tr>
         <td style="border:none;vertical-align:top;padding:6px;">${left}</td>
         <td style="border:none;vertical-align:top;padding:6px;">${right}</td>
       </tr>
     </table>
     <p>Ainsi \\( z_{\\overrightarrow{AB}} = z_{\\overrightarrow{DC}} \\) donc \\(ABCD\\) est un parallélogramme.</p>`
  );
}

  },

  /* e3 */
  e3:{ name:"Alignement des points A, B et C ? ", lead:"Répondre « oui » ou « non ». ",
    gen(){
  const MIN=-4, MAX=4;
  const A = randPointNum(MIN,MAX);
let aligned = COIN.want('e3');
  let B,C,k=null;

  if (aligned){
    // B ≠ A
    B = randPointNum(MIN,MAX, [A]);
    // k ∈ ℤ \ {0,1} pour éviter C=A ou C=B
    do{ k = randInt(-5,5); }while(k===0 || k===1);
    C = { a: A.a + k*(B.a-A.a), b: A.b + k*(B.b-A.b) };
    // si C sort de la fenêtre ou dupliqué, on recommence tout
    if (!allDistinctPts([A,B,C]) || Math.max(Math.abs(C.a),Math.abs(C.b))>MAX){
      return this.gen();
    }
  } else {
    B = randPointNum(MIN,MAX, [A]);
    do{
      C = randPointNum(MIN,MAX, [A,B]);
    }while( (B.a-A.a)*(C.b-A.b) - (B.b-A.b)*(C.a-A.a) === 0 ); // non alignés
  }

  this.state={A,B,C,aligned,k};
  COIN.commit('e3');

  setEqu(`<p>On considère les points \\(A\\), \\(B\\) et \\(C\\) d’affixes \\(z_A=${fmtZLaNum(A.a,A.b)}\\), \\(z_B=${fmtZLaNum(B.a,B.b)}\\), \\(z_C=${fmtZLaNum(C.a,C.b)}\\).</p> <p>Les points \\(A\\), \\(B\\) et \\(C\\) sont-ils alignés ?</p>`);
},
    verify(){ const {aligned}=this.state; const r=stripAccents($('#ans',HOST).value); const ok=(aligned&&/^o(ui)?$/.test(r))||(!aligned&&/^n(on)?$/.test(r)); setFB(ok, ok?``:`Attendu : ${aligned?'oui':'non'}.`); return ok; },
    // REGISTRY.e3.solution — TABLE borderless
solution(){
  const {A,B,C,aligned,k} = this.state;

  function subLine(label, L, R){
    const left  = fmtZLaNum(L.a, L.b);
    const right = fmtZLaNum(R.a, R.b);
    const noParens = (R.a===0 && R.b>0);
    return { text: `${label} = ${left} − ${ noParens ? right : `(${right})` }`,
             usedParens: !noParens };
  }
  function expandDiffNum(L, R){
    const parts = [];
    const push = (sign, txt)=>{
      if(parts.length===0){ parts.push(sign==='-' ? '− '+txt : txt); }
      else{ parts.push((sign==='-'?' − ':' + ')+txt); }
    };
    if(L.a!==0) push(L.a<0?'-':'+', String(Math.abs(L.a)));
    if(L.b!==0) push(L.b<0?'-':'+', Math.abs(L.b)===1 ? 'i' : String(Math.abs(L.b))+'i');
    const mAa = -R.a, mAb = -R.b;
    if(mAa!==0) push(mAa<0?'-':'+', String(Math.abs(mAa)));
    if(mAb!==0) push(mAb<0?'-':'+', Math.abs(mAb)===1 ? 'i' : String(Math.abs(mAb))+'i');
    return parts.join('') || '0';
  }
  function coefK_R(U,V){
    if(U.a!==0) return R(V.a, U.a);
    if(U.b!==0) return R(V.b, U.b);
    return R(0,1);
  }

  const AB = {a:B.a-A.a, b:B.b-A.b};
  const AC = {a:C.a-A.a, b:C.b-A.b};

  const subAB = subLine('z_{\\overrightarrow{AB}}', B, A);
  const subAC = subLine('z_{\\overrightarrow{AC}}', C, A);

  const leftLines = [
    `\\( z_{\\overrightarrow{AB}} = z_B - z_A \\)`,
    `\\( ${subAB.text} \\)`
  ];
  if(subAB.usedParens) leftLines.push(`\\( z_{\\overrightarrow{AB}} = ${expandDiffNum(B,A)} \\)`);
  leftLines.push(`\\( z_{\\overrightarrow{AB}} = ${fmtZLaNum(AB.a,AB.b)} \\)`);

  const rightLines = [
    `\\( z_{\\overrightarrow{AC}} = z_C - z_A \\)`,
    `\\( ${subAC.text} \\)`
  ];
  if(subAC.usedParens) rightLines.push(`\\( z_{\\overrightarrow{AC}} = ${expandDiffNum(C,A)} \\)`);
  rightLines.push(`\\( z_{\\overrightarrow{AC}} = ${fmtZLaNum(AC.a,AC.b)} \\)`);

  const left  = leftLines.map(L=>`<p>${L}</p>`).join('');
  const right = rightLines.map(L=>`<p>${L}</p>`).join('');
  const tail = aligned
    ? `<p>On remarque \\( z_{\\overrightarrow{AC}} = ${latexR(k==null?coefK_R(AB,AC):R(k,1))}\\,z_{\\overrightarrow{AB}} \\). Ainsi \\(A,B,C\\) sont alignés.</p>`
    : `<p>Il n’y a pas de relation entre \\( z_{\\overrightarrow{AC}} \\) et \\( z_{\\overrightarrow{AB}} \\). Ainsi \\(A,B,C\\) ne sont pas alignés.</p>`;

  setStepsHTML(
    `<table style="border-collapse:collapse;width:100%;">
       <tr>
         <td style="border:none;vertical-align:top;padding:6px;">${left}</td>
         <td style="border:none;vertical-align:top;padding:6px;">${right}</td>
       </tr>
     </table>${tail}`
  );

}

  },

  /* e4 */
 /* e4 */
e4 : {
  name:"(AB) et (CD) sont-elles parallèles ?",
  lead:"Répondre « oui » ou « non ». ",
  gen(){
    const MIN=-4, MAX=4;
    // A ≠ B
    const A = randPointNum(MIN,MAX);
    const B = randPointNum(MIN,MAX,[A]);

    // vecteur u = AB
    const u = { x: B.a - A.a, y: B.b - A.b };
    if (u.x===0 && u.y===0) return this.gen(); // ultra-sécurité

    // tirage parallèle / non-parallèle
// au lieu de: const wantParallel = Math.random() < 0.5;
const wantParallel = COIN.want('e4');
    let C, D, k = 0;

    if (wantParallel){
      // k ∈ ℤ \ {0}
      do { k = randInt(-4,4); } while (k === 0);
      // placer C puis D = C + k * u, en respectant la fenêtre & points distincts
      let tries = 0;
      do{
        C = randPointNum(MIN,MAX,[A,B]);
        D = { a: C.a + k*u.x, b: C.b + k*u.y };
        tries++;
        if (tries>200) { // garde-fou anti-boucle
          return this.gen();
        }
      } while (!allDistinctPts([A,B,C,D]) || Math.max(Math.abs(D.a),Math.abs(D.b))>MAX);
    } else {
      // non parallèles : det(AB,CD) ≠ 0
      let det = 0, tries = 0;
      do{
        C = randPointNum(MIN,MAX,[A,B]);
        D = randPointNum(MIN,MAX,[A,B,C]);
        det = (B.a-A.a)*(D.b-C.b) - (B.b-A.b)*(D.a-C.a);
        tries++;
        if (tries>300) { // garde-fou
          return this.gen();
        }
      } while (det === 0 || !allDistinctPts([A,B,C,D]));
    }

    this.state = { A,B,C,D, parallel: wantParallel, k };
	COIN.commit('e4');

    setEqu(
      `<p>On considère les points \\(A\\), \\(B\\), \\(C\\) et \\(D\\) d’affixes
       \\(z_A=${fmtZLaNum(A.a,A.b)}\\), \\(z_B=${fmtZLaNum(B.a,B.b)}\\),
       \\(z_C=${fmtZLaNum(C.a,C.b)}\\), \\(z_D=${fmtZLaNum(D.a,D.b)}\\).</p>
       <p>Les droites \\((AB)\\) et \\((CD)\\) sont-elles parallèles ?</p>`
    );
  },

  verify(){
    const rep = stripAccents($('#ans',HOST).value||'');
    if(!/^(o|oui|n|non)$/.test(rep)){
      setFB(false,'Répondez « oui » ou « non ».');
      return false;
    }
    const expect = this.state.parallel ? 'oui' : 'non';
    const ok = rep[0] === expect[0];
    setFB(ok, ok ? '' : `Attendu : ${expect}.`);
    return ok;
  },

  // === Correction robuste (sans division par 0, sans noms en collision) ===
  solution(){
    const {A,B,C,D,parallel,k} = this.state;

    // petits utilitaires locaux (noms uniques pour éviter toute collision)
    const subLine_num_e4 = (label, L, R) => {
      const left  = fmtZLaNum(L.a,L.b);
      const right = fmtZLaNum(R.a,R.b);
      const noPar = (R.a===0 && R.b>0);
      return { text: `${label} = ${left} − ${ noPar ? right : `(${right})` }`,
               usedParens: !noPar };
    };
    const expandDiffNum_e4 = (L, R) => {
      const parts = [];
      const push = (sign, txt)=>{
        if(parts.length===0){ parts.push(sign==='-' ? '− '+txt : txt); }
        else{ parts.push((sign==='-'?' − ':' + ')+txt); }
      };
      if(L.a!==0) push(L.a<0?'-':'+', String(Math.abs(L.a)));
      if(L.b!==0) push(L.b<0?'-':'+', Math.abs(L.b)===1 ? 'i' : `${Math.abs(L.b)}i`);
      const mAa = -R.a, mAb = -R.b;
      if(mAa!==0) push(mAa<0?'-':'+', String(Math.abs(mAa)));
      if(mAb!==0) push(mAb<0?'-':'+', Math.abs(mAb)===1 ? 'i' : `${Math.abs(mAb)}i`);
      return parts.join('') || '0';
    };

    // vecteurs
    const AB = {a:B.a-A.a, b:B.b-A.b};
    const CD = {a:D.a-C.a, b:D.b-C.b};

    // lignes de substitution
    const subAB = subLine_num_e4('z_{\\overrightarrow{AB}}', B, A);
    const subCD = subLine_num_e4('z_{\\overrightarrow{CD}}', D, C);

    const leftLines = [
      `\\( z_{\\overrightarrow{AB}} = z_B - z_A \\)`,
      `\\( ${subAB.text} \\)`
    ];
    if (subAB.usedParens) leftLines.push(`\\( z_{\\overrightarrow{AB}} = ${expandDiffNum_e4(B,A)} \\)`);
    leftLines.push(`\\( z_{\\overrightarrow{AB}} = ${fmtZLaNum(AB.a,AB.b)} \\)`);

    const rightLines = [
      `\\( z_{\\overrightarrow{CD}} = z_D - z_C \\)`,
      `\\( ${subCD.text} \\)`
    ];
    if (subCD.usedParens) rightLines.push(`\\( z_{\\overrightarrow{CD}} = ${expandDiffNum_e4(D,C)} \\)`);
    rightLines.push(`\\( z_{\\overrightarrow{CD}} = ${fmtZLaNum(CD.a,CD.b)} \\)`);

    // test de parallélisme purement numérique (pas de fractions)
    const det = AB.a*CD.b - AB.b*CD.a;
    const areParallel = Math.abs(det) < 1e-12;

    // texte de conclusion (sans calculer un k « exact » qui pourrait diviser par 0)
    const tail = areParallel
          ? `<p>On remarque \\( z_{\\overrightarrow{CD}} = ${latexR(k==null?coefK_R(AB,CD):R(k,1))}\\,z_{\\overrightarrow{AB}} \\). Ainsi \\((AB)\\) et \\((CD)\\) sont parallèles.</p>`
    : `<p>Il n’y a aucune relation entre \\( z_{\\overrightarrow{CD}} \\) et \\( z_{\\overrightarrow{AB}} \\). Ainsi \\((AB)\\) et \\((CD)\\) ne sont pas parallèles.</p>`;


    const left  = leftLines.map(L=>`<p>${L}</p>`).join('');
    const right = rightLines.map(L=>`<p>${L}</p>`).join('');

    setStepsHTML(
      `<table style="border-collapse:collapse;width:100%;">
         <tr>
           <td style="border:none;vertical-align:top;padding:6px;">${left}</td>
           <td style="border:none;vertical-align:top;padding:6px;">${right}</td>
         </tr>
       </table>${tail}`
    );
  }
},


  /* e5 */
  e5:{ name:"Milieu de [AB]", 
    gen(){
  const A0 = randPointR(-8,8);
  const B0 = randPointR(-8,8, [A0]);
  const A={a:A0.a,b:A0.b,latex:`z_A=${fmtZLaR(A0.a,A0.b)}`};
  const B={a:B0.a,b:B0.b,latex:`z_B=${fmtZLaR(B0.a,B0.b)}`};
  this.state={A,B};
  setEqu(`<p>On considère les points \\(A\\) et \\(B\\) d’affixes \\(${A.latex}\\) et \\(${B.latex}\\).</p><p> Déterminer l’affixe du milieu \\(M\\).</p>`);
},
    verify(){ const {A,B}=this.state; const E={a:numR(mulR(addR(A.a,B.a),R(1,2))), b:numR(mulR(addR(A.b,B.b),R(1,2)))};
      const ans=parseComplex($('#ans',HOST).value); const ok=Math.abs(ans.a-E.a)<1e-9 && Math.abs(ans.b-E.b)<1e-9;
      setFB(ok, ok?``:`Attendu : \\(${fmtZLaR(mulR(addR(A.a,B.a),R(1,2)), mulR(addR(A.b,B.b),R(1,2)))}\\).`); return ok;
    },
    solution(){
      const {A,B}=this.state;
      const Sx=addR(A.a,B.a), Sy=addR(A.b,B.b);
      const Mx=mulR(Sx,R(1,2)), My=mulR(Sy,R(1,2));
      const sumAB = plusJoinLatex(fmtZLaR(A.a,A.b), fmtZLaR(B.a,B.b));
      setSteps([
        `\\( z_M = \\dfrac{z_A+z_B}{2} \\)`,
        `\\( z_M = \\dfrac{ ${sumAB} }{2} \\)`,
        `\\( z_M = \\dfrac{ ${fmtZLaR(Sx,Sy)} }{2} \\)`,
        `\\( z_M = ${fmtZLaR(Mx,My)} \\)`
      ]);
    }
  },

  /* e6 */
  e6:{ name:"Symétrique de A par rapport à B", 
    gen(){
  const A0 = randPointR(-8,8);
  const B0 = randPointR(-8,8, [A0]);
  const A={a:A0.a,b:A0.b,latex:`z_A=${fmtZLaR(A0.a,A0.b)}`};
  const B={a:B0.a,b:B0.b,latex:`z_B=${fmtZLaR(B0.a,B0.b)}`};
  this.state={A,B};
  setEqu(`<p>On considère les points \\(A\\) et \\(B\\) d’affixes \\(${A.latex}\\) et \\(${B.latex}\\).</p><p>Déterminer l’affixe de \\(C\\), symétrique de \\(A\\) par rapport à \\(B\\).</p>`);
},
    verify(){
      const {A,B} = this.state;
      const Ex = subR(mulR(B.a, R(2,1)), A.a);
      const Ey = subR(mulR(B.b, R(2,1)), A.b);
      const expected = { a: numR(Ex), b: numR(Ey) };
      const ans = parseComplex($('#ans', HOST).value);
      const ok = Math.abs(ans.a - expected.a) < 1e-9 && Math.abs(ans.b - expected.b) < 1e-9;
      const msg = ok ? '' : `Attendu : \\(${fmtZLaR(Ex, Ey)}\\).`;
      setFB(ok, msg); retypeset(HOST); return ok;
    },
    solution(){
      const {A,B}=this.state;
      const twoB = { a: mulR(B.a, R(2,1)), b: mulR(B.b, R(2,1)) };
      const C = { a: subR(twoB.a, A.a), b: subR(twoB.b, A.b) };
      const L1 = `Le \\(C\\) symétrique de \\(A\\) par rapport à \\(B\\) signifie que \\(B\\) est le milieu de \\([AC]\\).`;
      const L2 = `\\( z_B = \\dfrac{z_A + z_C}{2} \\)`;
      const L3 = `\\( 2z_B = z_A + z_C \\)`;
      const L4 = `\\( z_C = 2z_B - z_A \\)`;
      const L5 = `\\( z_C = 2(${fmtZLaR(B.a,B.b)}) − (${fmtZLaR(A.a,A.b)}) \\)`;
      const L6 = `\\( z_C = ${expandDiff(twoB, A)} \\)`;
      const L7 = `\\( z_C = ${fmtZLaR(C.a, C.b)} \\)`;
      setSteps([L1,L2,L3,L4,L5,L6,L7]);
    }
  },

  /* e7 */
  e7:{ name:"Trouver D pour que ABCD soit un parallélogramme", 
    gen(){
  let A0,B0,C0,D;
  do{
    A0 = randPointR(-8,8);
    B0 = randPointR(-8,8, [A0]);
    C0 = randPointR(-8,8, [A0,B0]);
    D  = { a:addR(A0.a, subR(C0.a,B0.a)), b:addR(A0.b, subR(C0.b,B0.b)) };
  }while(!allDistinctPts([A0,B0,C0,D]));

  const A={a:A0.a,b:A0.b}, B={a:B0.a,b:B0.b}, C={a:C0.a,b:C0.b};
  this.state={A,B,C,D};
  setEqu(`<p>On considère les points \\(A\\), \\(B\\) et \\(C\\) d’affixes \\(z_A=${fmtZLaR(A.a,A.b)}\\), \\(z_B=${fmtZLaR(B.a,B.b)}\\) et \\(z_C=${fmtZLaR(C.a,C.b)}\\).</p><p>Déterminer l'affixe \\(z_D\\) du point \\(D\\) tel que \\(ABCD\\) soit un parallélogramme.</p>`);
},
    verify(){ const D=this.state.D; const ans=parseComplex($('#ans',HOST).value);
      const ok=Math.abs(ans.a-numR(D.a))<1e-9 && Math.abs(ans.b-numR(D.b))<1e-9;
      setFB(ok, ok?``:`Attendu : \\(${fmtZLaR(D.a,D.b)}\\).`); return ok;
    },
    solution(){
      const {A,B,C,D} = this.state;
      const CA = plusJoinLatex(fmtZLaR(C.a,C.b), fmtZLaR(A.a,A.b));
      const oppB = fmtZLaR(negR(B.a), negR(B.b));
      const L1 = `\\( \\overrightarrow{AB} = \\overrightarrow{DC} \\)`;
      const L2 = `\\( z_{\\overrightarrow{AB}} = z_{\\overrightarrow{DC}} \\)`;
      const L3 = `\\( z_B - z_A = z_C - z_D \\)`;
      const L4 = `\\( z_D = z_C + z_A - z_B \\)`;
      const L5 = `\\( z_D = ${CA} - (${fmtZLaR(B.a,B.b)}) \\)`;
      const L6 = `\\( z_D = ${plusJoinLatex(CA, oppB)} \\)`;
      const L7 = `\\( z_D = ${fmtZLaR(D.a,D.b)} \\)`;
      const rows = [
        [`<strong>ABCD est un parallélogramme</strong>`, '⇔', L1],
        ['', '⇔', L2],
        ['', '⇔', L3],
        ['', '⇔', L4],
        ['', '⇔', L5],
        ['', '⇔', L6],
        ['', '⇔', L7],
      ];
      const table = [
  '<table class="eqchain tbl" style="border-collapse:collapse;width:auto">',
  '<tbody>',
  ...rows.map(([c1,c2,c3]) =>
    `<tr>
       <td style="border:0px solid #000;padding:0 10px 4px 6px;white-space:nowrap;">${c1}</td>
       <td style="border:0px solid #000;padding:0 10px 4px 6px;white-space:nowrap;">${c2}</td>
       <td style="border:px solid #000;padding:0 6px 4px 0;">${c3}</td>
     </tr>`
  ),
  '</tbody></table>'
].join('');

      setStepsHTML(table);
    }
  },

  /* e8 */
  e8:{ name:"Distance AB", lead:"Répondre en entier ou avec une racine.",
    gen(){
      const wantPerfect = Math.random() < 0.60;
      const MIN=-4, MAX=4;
      function tryPlace(dx,dy){
        for(let t=0;t<50;t++){
          const Ax=randInt(MIN,MAX), Ay=randInt(MIN,MAX);
          const Bx=Ax+dx, By=Ay+dy;
          if(Bx>=MIN && Bx<=MAX && By>=MIN && By<=MAX) return {A:{a:Ax,b:Ay}, B:{a:Bx,b:By}};
        }
        return {A:{a:randInt(MIN,MAX),b:randInt(MIN,MAX)}, B:{a:randInt(MIN,MAX),b:randInt(MIN,MAX)}};
      }
      let A,B,dx,dy,d2;
      if(wantPerfect){
        const base = randChoice([[3,4],[4,3],[0,1],[0,2],[0,3],[0,4],[1,0],[2,0],[3,0],[4,0]]);
        dx = base[0]*(Math.random()<0.5?-1:1);
        dy = base[1]*(Math.random()<0.5?-1:1);
        const placed = tryPlace(dx,dy);
        A=placed.A; B=placed.B;
        d2 = dx*dx + dy*dy;
      }else{
        do{
          A={a:randInt(MIN,MAX),b:randInt(MIN,MAX)};
          B={a:randInt(MIN,MAX),b:randInt(MIN,MAX)};
          dx=B.a-A.a; dy=B.b-A.b; d2=dx*dx+dy*dy;
        }while(d2===0 || isPerfectSquare(d2));
      }
      this.state={A,B};
      setEqu(`<p>On considère les points \\(A\\) et \\(B\\) d’affixes \\(z_A=${fmtZLaNum(A.a,A.b)}\\) et \\(z_B=${fmtZLaNum(B.a,B.b)}\\).</p><p>Calculer la distance \\(AB\\).</p> `);
    },
    verify(){
      const {A,B}=this.state;
      const dx=B.a-A.a, dy=B.b-A.b, d2=dx*dx+dy*dy, expect=Math.sqrt(d2);
      const v=evalMaybeSqrt($('#ans',HOST).value);
      const ok=isFinite(v)&&Math.abs(v-expect)<1e-6;
      const msgBad = isPerfectSquare(d2) ? `Attendu : ${Math.sqrt(d2)}.` : `Attendu : \\(\\sqrt{${d2}}\\).`;
      setFB(ok, ok?``:msgBad); retypeset(HOST); return ok;
    },
    solution(){
      const {A,B}=this.state;
      const dx = B.a - A.a, dy = B.b - A.b;
      const d2 = dx*dx + dy*dy;
      const perfect = isPerfectSquare(d2);
      function subLine_BminusA_num(B,A){
        const left  = fmtZLaNum(B.a,B.b);
        const right = fmtZLaNum(A.a,A.b);
        const noParens = (A.a===0 && A.b>0);
        return { text: `z_B - z_A = ${left} − ${ noParens ? right : `(${right})` }`, usedParens: !noParens };
      }
      function expandDiffNum(L,R){
        const parts = []; const push=(sign, txt)=>{ parts.push(parts.length?(sign==='-'?' − ':' + ')+txt:(sign==='-'?'− '+txt:txt)); };
        if(L.a!==0) push(L.a<0?'-':'+', String(Math.abs(L.a)));
        if(L.b!==0) push(L.b<0?'-':'+', Math.abs(L.b)===1 ? 'i' : `${Math.abs(L.b)}i`);
        const mAa = -R.a, mAb = -R.b;
        if(mAa!==0) push(mAa<0?'-':'+', String(Math.abs(mAa)));
        if(mAb!==0) push(mAb<0?'-':'+', Math.abs(mAb)===1 ? 'i' : `${Math.abs(mAb)}i`);
        return parts.join('') || '0';
      }
      const sub = subLine_BminusA_num(B,A);
      const sqx = dx<0 ? `(${dx})^2` : `${dx}^2`;
      const sqy = dy<0 ? `(${dy})^2` : `${dy}^2`;
      const dx2 = dx*dx, dy2 = dy*dy;
      const lines = [
        `\\( z_B - z_A = z_B - z_A \\)`,
        `\\( ${sub.text} \\)`,
        ...(sub.usedParens ? [`\\( z_B - z_A = ${expandDiffNum(B,A)} \\)`] : []),
        `\\( z_B - z_A = ${fmtZLaNum(dx,dy)} \\)`,
        `\\( AB = |z_B - z_A| \\)`,
        `\\( AB = \\sqrt{${sqx} + ${sqy}} \\)`,
        `\\( AB = \\sqrt{${dx2} + ${dy2}} \\)`,
        perfect ? `\\( AB = ${Math.sqrt(d2)} \\)` : `\\( AB = \\sqrt{${d2}} \\)`
      ];
      setSteps(lines);
    }
  },

  /* e9 */
  e9:{ name:"Nature d’un triangle", lead:"Répondre : « quelconque », « équilatéral », « isocèle », « rectangle », « isocèle rectangle ». ",
    gen(){
      const MIN=-6, MAX=6;
      const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
      function placeFrom(dx,dy,margin=0){
        for(let t=0;t<80;t++){
          const Ax=rand(MIN+margin,MAX-margin), Ay=rand(MIN+margin,MAX-margin);
          const Bx=Ax+dx, By=Ay+dy;
          if(Bx>=MIN && Bx<=MAX && By>=MIN && By<=MAX) return {A:{a:Ax,b:Ay}, B:{a:Bx,b:By}};
        }
        return {A:{a:rand(MIN,MAX),b:rand(MIN,MAX)}, B:{a:rand(MIN,MAX),b:rand(MIN,MAX)}};
      }
      const r=Math.random(); let type,A,B,C,Clatex=null,eqScale=null;
      if(r<.20){
        do{
          A={a:rand(MIN,MAX),b:rand(MIN,MAX)};
          B={a:rand(MIN,MAX),b:rand(MIN,MAX)};
          C={a:rand(MIN,MAX),b:rand(MIN,MAX)};
        }while(
          (A.a===B.a&&A.b===B.b) || (A.a===C.a&&A.b===C.b) || (B.a===C.a&&B.b===C.b) ||
          ((B.a-A.a)*(C.b-A.b) - (B.b-A.b)*(C.a-A.a) === 0) ||
          ( (B.a-A.a)**2+(B.b-A.b)**2 === (C.a-A.a)**2+(C.b-A.b)**2 ) ||
          ( (B.a-A.a)**2+(B.b-A.b)**2 === (C.a-B.a)**2+(C.b-B.b)**2 ) ||
          ( (C.a-A.a)**2+(C.b-A.b)**2 === (C.a-B.a)**2+(C.b-B.b)**2 ) ||
          ( ((B.a-A.a)**2+(B.b-A.b)**2) + ((C.a-A.a)**2+(C.b-A.b)**2) === ((C.a-B.a)**2+(C.b-B.b)**2) ) ||
          ( ((B.a-A.a)**2+(B.b-A.b)**2) + ((C.a-B.a)**2+(C.b-B.b)**2) === ((C.a-A.a)**2+(C.b-A.b)**2) ) ||
          ( ((C.a-A.a)**2+(C.b-A.b)**2) + ((C.a-B.a)**2+(C.b-B.b)**2) === ((B.a-A.a)**2+(B.b-A.b)**2) )
        );
        type='quelconque';
      }
      else if(r<.45){
        const p = rand(1,4); eqScale=p; type='equilateral';
        A={a:-p,b:0}; B={a:p,b:0}; C={a:0,b:p*Math.sqrt(3)};
        Clatex = (p===1? '\\sqrt{3}i' : `${p}\\sqrt{3}i`);
      }
      else if(r<.70){
        const p=rand(1,5), q=rand(1,6); type='isocele';
        A={a:-p,b:0}; B={a:p,b:0}; C={a:0,b:q};
      }
      else if(r<.85){
        const m=rand(2,6), n=rand(2,6); type='rectangle';
        const placed = placeFrom(m,0,Math.max(m,n));
        A=placed.A; B=placed.B; C={a:A.a, b:A.b+n};
      }
      else{
        const p=rand(2,6); type='isocele-rectangle';
        const placed = placeFrom(p,0,p);
        A=placed.A; B=placed.B; C={a:A.a, b:A.b+p};
      }
	  if (!allDistinctPts([A,B,C])) return this.gen();

      this.state={A,B,C,type,Clatex,eqScale};
      const zA = `z_A=${fmtZLaNum(A.a,A.b)}`;
      const zB = `z_B=${fmtZLaNum(B.a,B.b)}`;
      const zC = `z_C=${Clatex ? Clatex : fmtZLaNum(C.a,C.b)}`;
      setEqu(`<p>On considère les points \\(A\\), \\(B\\) et \\(C\\) d’affixes \\(${zA}\\), \\(${zB}\\) et \\(${zC}\\).</p>
              <p>1) Calculer \\(AB\\), \\(AC\\) et \\(BC\\).</p>
              <p>2) Nature du triangle \\(ABC\\) ?</p>`);
    },
    verify(){
      const rep=stripAccents($('#ans',HOST).value);
      const {type}=this.state;
      const ok=(type==='equilateral'        && /equilateral|equilat(eral)?/.test(rep))||
               (type==='isocele-rectangle'  && /isoc(e|è)le\s*rectangle|rectangle\s*isoc(e|è)le/.test(rep))||
               (type==='isocele'            && /isoc(e|è)le(?!.*rectangle)/.test(rep) && !/rectangle/.test(rep))||
               (type==='rectangle'          && /rectangle(?!.*isoc)/.test(rep))||
               (type==='quelconque'         && /quelconque/.test(rep));
      setFB(ok, ok?``:`Attendu : ${ {'equilateral':'équilatéral','isocele':'isocèle','rectangle':'rectangle','isocele-rectangle':'isocèle rectangle','quelconque':'quelconque'}[type] }.`);
      return ok;
    },
    solution(){
      const {A,B,C,Clatex,eqScale}=this.state;
      const needPar=(a,b)=>{ if(a===0 && b===0) return false; if(a!==0 && b!==0) return true; if(a<0 && b===0) return true; if(b<0 && a===0) return true; return false; };
      const subLine=(lab,L,R)=>{ const l=fmtZLaNum(L.a,L.b), r=fmtZLaNum(R.a,R.b); const noPar = !needPar(R.a,R.b); return { text:`${lab} = ${l} − ${noPar?r:`(${r})`}`, usedParens:!noPar }; };
      const subLineTexMinusNum=(lab,Ltex,R)=>{ const r=fmtZLaNum(R.a,R.b); const noPar = !needPar(R.a,R.b); return { text:`${lab} = ${Ltex} − ${noPar?r:`(${r})`}`, usedParens:!noPar }; };
      const joinPlus=(left, rightLatex)=>{ const s=rightLatex.trim(); return s.startsWith('-') ? `${left} − ${s.replace(/^-/, '')}` : `${left} + ${s}`; };
      const expand=(L,R)=>{ const t=[],push=(sg,tx)=>{t.push(t.length?(sg==='-'?' − ':' + ')+tx:(sg==='-'?'− '+tx:tx));}; if(L.a) push(L.a<0?'-':'+', String(Math.abs(L.a))); if(L.b) push(L.b<0?'-':'+', Math.abs(L.b)===1?'i':`${Math.abs(L.b)}i`); const mA=-R.a,mB=-R.b; if(mA) push(mA<0?'-':'+', String(Math.abs(mA))); if(mB) push(mB<0?'-':'+', Math.abs(mB)===1?'i':`${Math.abs(mB)}i`); return t.join('')||'0'; };
      const sqNum=(n)=>{ const v=(Object.is(n,-0)?0:n); return v===0 ? '0^2' : (v<0 ? `(${v})^2` : `${v}^2`); };
      const sqRoot3=(k)=>{ if(Object.is(k,-0)||k===0) return '0^2'; return k===1 ? `(\\sqrt{3})^2` : `(${k}\\sqrt{3})^2`; };
      const isPerfectSquare=(n)=>{ if(n<0) return false; const r=Math.floor(Math.sqrt(n)); return r*r===n; };
      const _norm = s => (s||'').replace(/\s+/g,' ').replace(/\u2212/g,'-').replace(/\(0\)/g,'0').trim();
      const _push = (arr, line) => { if (!line) return; if (!arr.length || _norm(arr[arr.length-1])!==_norm(line)) arr.push(line); };
      const AB={a:B.a-A.a,b:B.b-A.b}, ACn={a:C.a-A.a,b:C.b-A.b}, BCn={a:C.a-B.a,b:C.b-B.b};
      let AB2=AB.a*AB.a+AB.b*AB.b, AC2=ACn.a*ACn.a+ACn.b*ACn.b, BC2=BCn.a*BCn.a+BCn.b*BCn.b;

      const sAB=subLine('z_{\\overrightarrow{AB}}',B,A);
      const colABLines=[]; _push(colABLines, `\\( z_{\\overrightarrow{AB}} = z_B - z_A \\)`); _push(colABLines, `\\( ${sAB.text} \\)`); if (sAB.usedParens) _push(colABLines, `\\( z_{\\overrightarrow{AB}} = ${expand(B,A)} \\)`); _push(colABLines, `\\( z_{\\overrightarrow{AB}} = ${fmtZLaNum(AB.a,AB.b)} \\)`); _push(colABLines, `\\( AB = \\sqrt{${sqNum(AB.a)} + ${sqNum(AB.b)}} \\)`); _push(colABLines, `\\( AB = \\sqrt{${AB2}} \\)`); if (isPerfectSquare(AB2)) _push(colABLines, `\\( AB = ${Math.sqrt(AB2)} \\)`); const colAB = colABLines.map(L=>`<p>${L}</p>`).join('');

      const equi = !!Clatex; const LtexC = Clatex ? Clatex : fmtZLaNum(C.a,C.b); const sAC = equi ? subLineTexMinusNum('z_{\\overrightarrow{AC}}',LtexC,A) : subLine('z_{\\overrightarrow{AC}}',C,A); const devAC = equi && sAC.usedParens ? joinPlus(LtexC, fmtZLaNum(-A.a,-A.b)) : expand(C,A); const AC_dx = equi ? eqScale : ACn.a;
      const colACLines=[]; _push(colACLines, `\\( z_{\\overrightarrow{AC}} = z_C - z_A \\)`); _push(colACLines, `\\( ${sAC.text} \\)`); if (sAC.usedParens) _push(colACLines, `\\( z_{\\overrightarrow{AC}} = ${devAC} \\)`); _push(colACLines, `\\( z_{\\overrightarrow{AC}} = ${equi ? `${AC_dx} + ${eqScale===1?'\\sqrt{3}':eqScale+'\\sqrt{3}'}i` : fmtZLaNum(ACn.a,ACn.b)} \\)`); if (equi){ _push(colACLines, `\\( AC = \\sqrt{${sqNum(AC_dx)} + ${sqRoot3(eqScale)} } \\)`); _push(colACLines, `\\( AC = \\sqrt{${AC_dx*AC_dx} + ${3*eqScale*eqScale}} \\)`); _push(colACLines, `\\( AC = \\sqrt{${4*eqScale*eqScale}} \\)`); _push(colACLines, `\\( AC = ${2*eqScale} \\)`);} else{ _push(colACLines, `\\( AC = \\sqrt{${sqNum(ACn.a)} + ${sqNum(ACn.b)}} \\)`); _push(colACLines, `\\( AC = \\sqrt{${AC2}} \\)`); if (isPerfectSquare(AC2)) _push(colACLines, `\\( AC = ${Math.sqrt(AC2)} \\)`);} const colAC = colACLines.map(L=>`<p>${L}</p>`).join('');

      const sBC = equi ? subLineTexMinusNum('z_{\\overrightarrow{BC}}',LtexC,B) : subLine('z_{\\overrightarrow{BC}}',C,B); const devBC = equi && sBC.usedParens ? joinPlus(LtexC, fmtZLaNum(-B.a,-B.b)) : expand(C,B); const BC_dx = equi ? -eqScale : BCn.a;
      const colBCLines=[]; _push(colBCLines, `\\( z_{\\overrightarrow{BC}} = z_C - z_B \\)`); _push(colBCLines, `\\( ${sBC.text} \\)`); if (sBC.usedParens) _push(colBCLines, `\\( z_{\\overrightarrow{BC}} = ${devBC} \\)`); _push(colBCLines, `\\( z_{\\overrightarrow{BC}} = ${equi ? `${BC_dx} + ${eqScale===1?'\\sqrt{3}':eqScale+'\\sqrt{3}'}i` : fmtZLaNum(BCn.a,BCn.b)} \\)`); if (equi){ _push(colBCLines, `\\( BC = \\sqrt{${sqNum(BC_dx)} + ${sqRoot3(eqScale)} } \\)`); _push(colBCLines, `\\( BC = \\sqrt{${BC_dx*BC_dx} + ${3*eqScale*eqScale}} \\)`); _push(colBCLines, `\\( BC = \\sqrt{${4*eqScale*eqScale}} \\)`); _push(colBCLines, `\\( BC = ${2*eqScale} \\)`);} else{ _push(colBCLines, `\\( BC = \\sqrt{${sqNum(BCn.a)} + ${sqNum(BCn.b)}} \\)`); _push(colBCLines, `\\( BC = \\sqrt{${BC2}} \\)`); if (isPerfectSquare(BC2)) _push(colBCLines, `\\( BC = ${Math.sqrt(BC2)} \\)`);} const colBC = colBCLines.map(L=>`<p>${L}</p>`).join('');
setStepsHTML(`
    <table style="border-collapse:collapse;width:100%;">
      <tr>
        <td style="border:none;vertical-align:top;padding:6px;">${colAB}</td>
        <td style="border:none;vertical-align:top;padding:6px;">${colAC}</td>
        <td style="border:none;vertical-align:top;padding:6px;">${colBC}</td>
      </tr>
    </table>
  `);
  if (Clatex){
    const p2=4*eqScale*eqScale;
    setStepsHTML($('#res',HOST).innerHTML +
      `<p>On observe \\(AB=AC=BC\\).</p>`+
      `<p><strong>Conclusion :</strong> le triangle \\(ABC\\) est <strong>équilatéral</strong>.</p>`
    );
    return;
  }
      let isoAt=null, isoLine='';
      if (AB2===AC2){ isoAt='A'; isoLine=`\\(AB=AC\\) : <strong>isocèle en \\(A\\)</strong>.`; }
      else if (AC2===BC2){ isoAt='C'; isoLine=`\\(AC=BC\\) : <strong>isocèle en \\(C\\)</strong>.`; }
      else if (AB2===BC2){ isoAt='B'; isoLine=`\\(AB=BC\\) : <strong>isocèle en \\(B\\)</strong>.`; }
      else { isoLine=`Aucune égalité de longueurs : le triangle \\(ABC\\) n’est <strong>pas isocèle</strong>.`; }
      setStepsHTML($('#res',HOST).innerHTML + `<p>${isoLine}</p>`);
      const triples=[
        {name:'AB',val:AB2,sum:AC2+BC2,sumNames:'AC^2 + BC^2',rectAt:'C',add1:AC2,add2:BC2},
        {name:'AC',val:AC2,sum:AB2+BC2,sumNames:'AB^2 + BC^2',rectAt:'B',add1:AB2,add2:BC2},
        {name:'BC',val:BC2,sum:AB2+AC2,sumNames:'AB^2 + AC^2',rectAt:'A',add1:AB2,add2:AC2},
      ];
      let idx=0; if(triples[1].val>triples[idx].val) idx=1; if(triples[2].val>triples[idx].val) idx=2;
      const BIG=triples[idx];
      const bigLine = `\\(${BIG.name}^2 = ${BIG.val}\\)`;
      const sumLine = `\\(${BIG.sumNames} = ${BIG.add1} + ${BIG.add2} = ${BIG.sum}\\)`;
      const eqPyth = (BIG.val===BIG.sum);
      const pythText = eqPyth
        ? `On remarque que \\(${BIG.name}^2 = ${BIG.sumNames}\\) donc d’après la <strong>réciproque</strong> du théorème de Pythagore, le triangle \\(ABC\\) est <strong>rectangle en \\(${BIG.rectAt}\\)</strong>.`
        : `De plus on remarque que \\(${BIG.name}^2 \\ne ${BIG.sumNames}\\) donc d’après la <strong>contraposée</strong> du théorème de Pythagore, le triangle \\(ABC\\) n’est <strong>pas rectangle</strong>.`;
      setStepsHTML($('#res',HOST).innerHTML + `<p>${bigLine}</p><p>${sumLine}</p><p>${pythText}</p>`);
      let nature;
      if (eqPyth && isoAt){ nature = `isocèle et rectangle en \\(${BIG.rectAt}\\)`; }
      else if (eqPyth){ nature = `rectangle en \\(${BIG.rectAt}\\)`; }
      else if (isoAt){ nature = `isocèle en \\(${isoAt}\\)`; }
      else { nature = 'quelconque'; }
      setStepsHTML($('#res',HOST).innerHTML + `<p><strong>Conclusion :</strong> le triangle \\(ABC\\) est <strong>${nature}</strong>.</p>`);
    }
  },

  /* e10 */
  e10:{
    name:"Cercle",
    lead:"Donner la valeur du rayon dans réponse",
    gen(){
      const BASE = [[1,0],[2,0],[3,0],[4,0],[0,1],[0,2],[0,3],[0,4],[3,4],[4,3],[2,1],[1,2]];
      const [vx,vy] = randChoice(BASE).map(t=> t * (Math.random()<.5?-1:1));
      const variants = [[ vx, -vy],[ -vx, vy],[ -vx,-vy],[ vy,  vx],[ vy,-vx],[ -vy, vx],[ -vy,-vx]].filter(([x,y])=> x!==vx || y!==vy);
      const [wx,wy] = randChoice(variants);
      function tryPlace(){
        for(let t=0;t<80;t++){
          const ox = randInt(-4,4), oy = randInt(-4,4);
          const A={a:ox+vx, b:oy+vy}, B={a:ox+wx, b:oy+wy};
          if(Math.max(Math.abs(A.a),Math.abs(A.b),Math.abs(B.a),Math.abs(B.b))<=6) return {O:{a:ox,b:oy}, A, B};
        }
        return {O:{a:0,b:0}, A:{a:vx,b:vy}, B:{a:wx,b:wy}};
      }
      const placed = tryPlace();
  // sécurité unicité
  if (!allDistinctPts([placed.O, placed.A, placed.B])) return this.gen();

  this.state = placed;
  setEqu(
    `<p>On considère les points \\(A\\), \\(B\\) et \\(\\Omega\\) d’affixes \\(z_A=${fmtZLaNum(placed.A.a,placed.A.b)}\\),\\(z_B=${fmtZLaNum(placed.B.a,placed.B.b)}\\) et \\(z_{\\Omega}=${fmtZLaNum(placed.O.a,placed.O.b)}\\).</p>
    <p>Démontrer que \\(A\\) et \\(B\\) sont sur un même cercle de centre \\(\\Omega\\) et déterminer son rayon.</p>`
  );
},
    verify(){
      const {A,B,O}=this.state;
      const rA = Math.hypot(A.a-O.a, A.b-O.b);
      const rB = Math.hypot(B.a-O.a, B.b-O.b);
      const r  = (rA+rB)/2;
      const v = evalMaybeSqrt($('#ans',HOST).value);
      const ok = isFinite(v) && Math.abs(v-r) < 1e-6;
      const dx = A.a-O.a, dy = A.b-O.b, d2 = dx*dx+dy*dy;
      const msgBad = isPerfectSquare(d2) ? `Attendu : ${Math.sqrt(d2)}.` : `Attendu : \\(\\sqrt{${d2}}\\).`;
      setFB(ok, ok?``:msgBad); retypeset(HOST);
      return ok;
    },
    // REGISTRY.e10.solution — TABLE borderless
solution(){
  const {A,B,O}=this.state;

  function expandDiffNum(L,R){
    const out=[], push=(sg,tx)=>{
      out.push(out.length?(sg==='-'?' − ':' + ')+tx:(sg==='-'?'− '+tx:tx));
    };
    if(L.a!==0) push(L.a<0?'-':'+', String(Math.abs(L.a)));
    if(L.b!==0) push(L.b<0?'-':'+', Math.abs(L.b)===1 ? 'i' : `${Math.abs(L.b)}i`);
    const mA=-R.a, mB=-R.b;
    if(mA!==0) push(mA<0?'-':'+', String(Math.abs(mA)));
    if(mB!==0) push(mB<0?'-':'+', Math.abs(mB)===1 ? 'i' : `${Math.abs(mB)}i`);
    return out.join('') || '0';
  }
  function subLine(label, L, R){
    const left  = fmtZLaNum(L.a,L.b);
    const right = fmtZLaNum(R.a,R.b);
    const noParens = (R.a===0 && (R.b>0 || R.b===0));
    return { text: `${label} = ${left} - ${ noParens ? right : `(${right})` }`,
             usedParens: !noParens };
  }
  const sq = n => n===0 ? '0^2' : (n<0 ? `(${n})^2` : `${n}^2`);
  const _norm = s => (s||'').replace(/\s+/g,' ').replace(/\u2212/g,'-').replace(/\(0\)/g,'0').trim();
  const _push = (arr, line) => { if(!line) return; if(!arr.length || _norm(arr[arr.length-1])!==_norm(line)) arr.push(line); };

  const dxA=A.a-O.a, dyA=A.b-O.b;
  const dxB=B.a-O.a, dyB=B.b-O.b;
  const d2 = dxA*dxA + dyA*dyA;
  const perfect = isPerfectSquare(d2);
  const rTex  = perfect ? String(Math.sqrt(d2)) : `\\sqrt{${d2}}`;

  const left=[];
  _push(left, `\\( z_{\\overrightarrow{\\Omega A}} = z_A - z_{\\Omega} \\)`);
  const sOA = subLine('z_{\\overrightarrow{\\Omega A}}', A, O);
  _push(left, `\\( ${sOA.text} \\)`);
  if (sOA.usedParens) _push(left, `\\( z_{\\overrightarrow{\\Omega A}} = ${expandDiffNum(A,O)} \\)`);
  _push(left, `\\( z_{\\overrightarrow{\\Omega A}} = ${fmtZLaNum(dxA,dyA)} \\)`);
  _push(left, `\\( \\Omega A = \\sqrt{${sq(dxA)} + ${sq(dyA)}} \\)`);
  _push(left, `\\( \\Omega A = \\sqrt{${dxA*dxA} + ${dyA*dyA}} \\)`);
  _push(left, `\\( \\Omega A = \\sqrt{${d2}} \\)`);
  if (perfect) _push(left, `\\( \\Omega A = ${Math.sqrt(d2)} \\)`);

  const right=[];
  _push(right, `\\( z_{\\overrightarrow{\\Omega B}} = z_B - z_{\\Omega} \\)`);
  const sOB = subLine('z_{\\overrightarrow{\\Omega B}}', B, O);
  _push(right, `\\( ${sOB.text} \\)`);
  if (sOB.usedParens) _push(right, `\\( z_{\\overrightarrow{\\Omega B}} = ${expandDiffNum(B,O)} \\)`);
  _push(right, `\\( z_{\\overrightarrow{\\Omega B}} = ${fmtZLaNum(dxB,dyB)} \\)`);
  _push(right, `\\( \\Omega B = \\sqrt{${sq(dxB)} + ${sq(dyB)}} \\)`);
  _push(right, `\\( \\Omega B = \\sqrt{${dxB*dxB} + ${dyB*dyB}} \\)`);
  _push(right, `\\( \\Omega B = \\sqrt{${d2}} \\)`);
  if (perfect) _push(right, `\\( \\Omega B = ${Math.sqrt(d2)} \\)`);

  const leftHTML  = left.map(L=>`<p class="eqonly">${L}</p>`).join('');
  const rightHTML = right.map(L=>`<p class="eqonly">${L}</p>`).join('');

  setStepsHTML(
    `<table style="border-collapse:collapse;width:100%;">
       <tr>
         <td style="border:none;vertical-align:top;padding:6px;">${leftHTML}</td>
         <td style="border:none;vertical-align:top;padding:6px;">${rightHTML}</td>
       </tr>
     </table>
     <p>\\(\\Omega A = \\Omega B = ${rTex}\\) donc \\(A\\) et \\(B\\) appartiennent au cercle de centre \\(\\Omega\\) et de rayon \\(${rTex}\\).</p>`
  );

}

  }

};

/* === ADAPTATEUR PDF ===
   - Le kit attend window.REGISTRY = tableau [{id,title,gen()}...]
   - On garde REGISTRY_MAP (objet) pour l'UI. */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; } // petite signature anti-doublon
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;

// Fabrique synchrone : produit l'HTML énoncé/solution via l'UI cachée
window.buildOneForPDFSync = function(defId){
  const cfg = REGISTRY_MAP[defId];
  if (!cfg) return { statement:'', solution:'' };
  const host = document.querySelector('#host');
  const backup = host ? host.innerHTML : '';
  if (host) mountHost();
  document.querySelector('#lead').innerHTML = cfg.lead || '';
  cfg.gen.call(cfg);
  const enonce = (document.querySelector('#equ')||{}).innerHTML || '';
  cfg.solution.call(cfg);
  const corrige = (document.querySelector('#res')||{}).innerHTML || '';
  if (host) host.innerHTML = backup;
  return { statement: enonce, solution: corrige };
};

(function(){
  'use strict';

  function whenReady(cb){
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', cb, { once:true });
    } else { cb(); }
  }

  whenReady(function init(){
    // 1) Remplir le sélecteur (avec l'objet)
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(
      ([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`
    ).join('');

    // 2) État courant
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
    let SCORE_OK = 0, SCORE_TOT = 0;

    // 3) Fonctions UI
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }

    function buildOne(){
      mountHost();
      const cfg = REGISTRY_MAP[ACTIVE];
      document.querySelector('#lead').innerHTML = cfg.lead || '';
      document.querySelector('#ans').value = '';
      document.querySelector('#fb').textContent = '';
      document.querySelector('#res').innerHTML = '';
      cfg.gen.call(cfg);
      document.querySelector('#ans').addEventListener('keydown', (e)=>{
        if(e.key==='Enter'){ e.preventDefault(); document.querySelector('#btn-check').click(); }
      });
      retypeset();
    }

    // 4) Câblage boutons
    document.querySelector('#btn-new').addEventListener('click', buildOne);
    document.querySelector('#btn-reset').addEventListener('click', ()=>{
      const ans = document.querySelector('#ans'); if(ans) ans.value='';
      const fb  = document.querySelector('#fb');  if(fb) fb.textContent='';
      const res = document.querySelector('#res'); if(res) res.innerHTML='';
    });
    document.querySelector('#btn-check').addEventListener('click', ()=>{
      SCORE_TOT++;
      const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE]) === true;
      if(ok) SCORE_OK++;
      updateScore();
    });
    document.querySelector('#btn-solution').addEventListener('click', ()=>{
      REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]);
    });
    sel.addEventListener('change', ()=>{ ACTIVE = sel.value; buildOne(); });


	
	    // 5) Premier affichage
    buildOne();
    updateScore();

  });     // ✅ fin de init + whenReady
})();     // ✅ fin de l’IIFE 'use strict'




window.__PDF_CACHE__ = new Map();


/* =========================================================
   ADAPTATEUR PDF — Fiche "2nd - Vecteurs - Coordonnées"
   -------------------------------------------------------
   - Utilise buildOneForPDFSync(def.id) pour obtenir:
     { statement: HTML, solution: HTML }
   - Convertit en SVG via MathJax (cache de police désactivé).
   - Respecte "Solution = exactement le bloc #res".
   ========================================================= */

(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(){
        if (window.COIN){ COIN.pdfMode = true; COIN.count = COIN.count || new Map(); }
        return {};
      },

      beforeRender(def, _st, withSolutions){
        return (async () => {
          // === 1) Génère l'énoncé/la solution via l’UI cachée ===
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);

          const htmlIn =
            `<div class="exo-block">
               <span class="exo-title">Exercice — ${label}</span>
               <div class="exo-statement">${statement||''}</div>
             </div>` +
            (withSolutions
              ? `<div style="margin-top:1rem;">
                   <div class="exo-block">
                     <span class="exo-title">Correction</span>
                     <div class="exo-solution">${solution||''}</div>
                   </div>
                 </div>`
              : '');

          // === 2) Iframe hors écran ===
          const iframe = document.createElement('iframe');
          Object.assign(iframe.style, {position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open();
          idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>');
          idoc.close();

          const root = idoc.getElementById('root');
          root.innerHTML = htmlIn;

          // === 3) Charger MathJax tex-svg dans l’iframe (SVG only) ===
          const cfg = idoc.createElement('script');
          cfg.type = 'text/javascript';
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: {
                inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
                displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
                processEscapes: true,
                packages: { '[+]': ['bbox','ams'] }
              },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };
          `;
          idoc.head.appendChild(cfg);

          // IMPORTANT : chemin local vers tex-svg.js (le même dossier que sur ta page)
          const mj = idoc.createElement('script');
          mj.type = 'text/javascript';
          mj.src  = new URL("../../../../es5/tex-svg.js", window.location.href).href;
          idoc.head.appendChild(mj);
          await new Promise(res => { mj.onload = res; mj.onerror = res; });

          // Vérifier présence de tex2svg
          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++){
            await new Promise(r=>setTimeout(r,10));
          }
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)) {
            console.error('MathJax.tex2svg indisponible dans l’iframe.');
            const out = root.innerHTML; iframe.remove(); return out;
          }

          // === 4) Parse & remplace TeX → SVG pur (sans mjx-container) ===

          // Regex : on gère \\( \\) , \\[ \\] , $$ $$
          const RX_INLINE = /\\\((.+?)\\\)/gs;
          const RX_DISPLAY_BR = /\\\[(.+?)\\\]/gs;
          const RX_DISPLAY_DOLLAR = /\$\$(.+?)\$\$/gs;

          // util : crée un noeud SVG *standalone* à partir d'une string TeX
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex, {display});
            // tex2svg renvoie un <mjx-container> avec un <svg> dedans
            const svg = mjx.querySelector('svg');
            if (!svg) return idoc.createTextNode(tex);

            // clone & durcir
            const out = svg.cloneNode(true);
            // namespaces & sécurité PDF
            out.setAttribute('xmlns','http://www.w3.org/2000/svg');
            out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
            out.setAttribute('overflow','visible'); // éviter clipping
            // width/height depuis la bbox si absent
            if (!out.getAttribute('width') || !out.getAttribute('height')) {
              try {
                const bb = out.getBBox();
                if (bb && isFinite(bb.width) && isFinite(bb.height) && bb.width>0 && bb.height>0) {
                  out.setAttribute('width',  String(bb.width));
                  out.setAttribute('height', String(bb.height));
                  if (!out.getAttribute('viewBox')) {
                    out.setAttribute('viewBox', `0 0 ${bb.width} ${bb.height}`);
                  }
                }
              } catch(_) {}
            }
            // doublon xlink:href/href pour compat PDF
            out.querySelectorAll('use').forEach(u=>{
              const xh = u.getAttribute('xlink:href');
              const h  = u.getAttribute('href');
              if (xh && !h) u.setAttribute('href', xh);
              if (h  && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', h);
            });
            return out;
          }

          // remplace TeX dans un noeud Element en descendant
          function replaceTeXIn(node){
            // ne pas toucher aux balises script/style/code/pre
            const SKIP = new Set(['SCRIPT','STYLE','CODE','PRE']);
            if (node.nodeType === 1 && SKIP.has(node.tagName)) return;

            // traiter les enfants d’abord
            const children = Array.from(node.childNodes);
            for (const ch of children){
              if (ch.nodeType === Node.TEXT_NODE) {
                const text = ch.nodeValue;
                if (!text || !/[\\$]/.test(text)) continue;

                // pipeline : $$...$$ → display
                let idx = 0, parent = ch.parentNode, frag;

                function flushPlain(s){
                  if (!s) return;
                  parent.insertBefore(idoc.createTextNode(s), ch);
                }
                function insertSVG(tex, display){
                  const svg = texToStandaloneSVG(tex, display);
                  parent.insertBefore(svg, ch);
                }

                // helper pour consommer via regex dans l’ordre priorité : $$ $$, \[ \], \( \)
                function consumeBy(regex, display){
                  regex.lastIndex = 0;
                  let m, last = 0, out = [];
                  while ((m = regex.exec(text)) !== null){
                    const before = text.slice(last, m.index);
                    out.push({type:'text', val:before});
                    out.push({type:'math', val:m[1], display});
                    last = regex.lastIndex;
                  }
                  if (out.length) out.push({type:'text', val:text.slice(last)});
                  return out.length ? out : null;
                }

                let parts = consumeBy(RX_DISPLAY_DOLLAR, true);
                if (!parts) parts = consumeBy(RX_DISPLAY_BR, true);
                if (!parts) parts = consumeBy(RX_INLINE, false);

                if (parts){
                  for (const p of parts){
                    if (p.type==='text') flushPlain(p.val);
                    else insertSVG(p.val, p.display);
                  }
                  parent.removeChild(ch);
                  continue;
                }

              } else if (ch.nodeType === Node.ELEMENT_NODE){
                replaceTeXIn(ch);
              }
            }
          }

          replaceTeXIn(root);

          // === 5) HTML final (uniquement du <svg> standard) ===
          const finalHTML = root.innerHTML;
          iframe.remove();
          return finalHTML;

        })().catch(err=>{
          console.error('beforeRender SVG(tex2svg) error:', err);
          // Fallback brut
          const defId = def?.id || '';
          const { statement, solution } =
            (typeof window.buildOneForPDFSync === 'function')
              ? window.buildOneForPDFSync(defId)
              : {statement:'',solution:''};
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          return `<div class="exo-block">
                    <span class="exo-title">Exercice — ${label}</span>
                    <div class="exo-statement">${statement||''}</div>
                    ${withSolutions?`<div style="margin-top:1rem;"><div class="exo-block"><span class="exo-title">Correction</span><div class="exo-solution">${solution||''}</div></div></div>`:''}
                  </div>`;
        });
      }
    });
  });
})();



</script>
</body>
</html>
