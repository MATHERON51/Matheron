<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique (sans LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.55}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .row{display:grid;grid-template-columns:1fr;gap:10px}
  .statement{font-size:18px}
  .statement .consigne{opacity:.8;margin-bottom:6px}
  .equ{font-variant-numeric:tabular-nums}
  #host .inputs{display:flex;flex-direction:column;gap:8px}
  #host .ans-row{display:flex;align-items:center;gap:6px}
  #host .ans-row .tick{min-width:1.2em;text-align:center}
  #res.small{font-size:15px}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}

  /* Espacement autour des formules inline dans les √©nonc√©s */
  .statement code, code.equ, .equ{
    padding:.05rem .35rem;
    border-radius:6px;
    margin:0 .35rem;
    display:inline-block;
    white-space:nowrap;
  }
  .statement code:first-child, .equ:first-child{ margin-left:0 }
  .statement code:last-child,  .equ:last-child{  margin-right:0 }
</style>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D ‚Äì <strong>Nombres complexes</strong> ‚Äî Forme alg√©brique</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 1.1rem">
        <li>R√©pondre en <em>forme alg√©brique</em> : <code>a + bi</code>. <em>bi + a</em>, <em>a</em> (si <code>b=0</code>) et <em>bi</em> (si <code>a=0</code>) sont accept√©es.</li>
        <li>Jamais <code>1i</code>/<code>‚àí1i</code> (√©crire <code>i</code>/<code>‚àíi</code>) ; pas de <code>0i</code>, <code>+0</code>, <code>0+</code>.</li>
        <li>D√©cimales : virgule ou point. Les √©critures <code>3*i</code>, <code>3 i</code>, <code>3√ói</code> sont normalis√©es en <code>3i</code>.</li>
        <li>Le score ne change pas tant qu‚Äôune saisie est vide. <kbd>Entr√©e</kbd> d√©clenche <em>V√©rifier</em>.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Scripts partag√©s -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){
'use strict';

/* ===== Helpers ===== */
// Souvenir du choix utilisateur pour l'exo 5 (2 par d√©faut)
window.ZPOW = window.ZPOW || 2;

function whenReady(cb){
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', cb, { once: true });
  } else {
    cb();
  }
}
function $(s,r){ return (r||document).querySelector(s); }
function rnd(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function nz(a,b){ let v=0; while(v===0) v=rnd(a,b); return v; }
const UMINUS = '‚àí';

function norm(s){
  return String(s||'')
    .replace(/\u2212/g,'-')  // ‚àí ‚Üí -
    .replace(/,/g,'.')       // virgule ‚Üí point
    .replace(/¬∑|√ó/g,'*')     // visuels ‚Üí *
    .trim();
}

/* Affichage serr√© + simplifications globales */
function fmtNum(n){
  const v = Math.abs(n);
  const s = Number.isInteger(n) ? String(v) : String(v).replace('.',',');
  return n < 0 ? UMINUS + s : s;
}
function fmtIcoef(b){
  if (b === 0) return '';
  const abs = Math.abs(b);
  const core = (abs === 1 ? 'i' : String(abs).replace('.',',') + 'i');
  if (b > 0) return ' + ' + core;
  return ' ' + UMINUS + core;
}
function fmtComplex(a, b, order/*'a+bi'|'bi+a'*/){
  if (order === 'bi+a'){
    if (b === 0) return (a === 0 ? '0' : fmtNum(a));
    if (a === 0) return (b === 1 ? 'i' : (b === -1 ? UMINUS + 'i'
                  : (b < 0 ? UMINUS + String(Math.abs(b)).replace('.',',') + 'i'
                           : String(b).replace('.',',') + 'i')));
    const left = (b > 0 ? (b === 1 ? 'i' : String(b).replace('.',',') + 'i')
                        : (b === -1 ? UMINUS + 'i' : UMINUS + String(Math.abs(b)).replace('.',',') + 'i'));
    const right = (a >= 0 ? ' + ' + fmtNum(a) : ' ' + UMINUS + String(Math.abs(a)));
    return left + right;
  } else {
    if (a === 0 && b === 0) return '0';
    if (a === 0) return (b === 1 ? 'i' : (b === -1 ? UMINUS + 'i'
                  : (b < 0 ? UMINUS + String(Math.abs(b)).replace('.',',') + 'i'
                           : String(b).replace('.',',') + 'i')));
    if (b === 0) return fmtNum(a);
    return fmtNum(a) + fmtIcoef(b);
  }
}

/* Parsing tol√©rant */
function parseComplex(str){
  if(!str) return null;
  let s = norm(str).replace(/\s+/g,'');
  s = s.replace(/^(?:z\s*=?\s*)/i,''); // retire "z =" √©ventuel
  s = s.replace(/\*/g,'');
  const parts = s.match(/[+\-]?[^+\-]+/g);
  if(!parts) return null;
  let a=0, b=0;
  for(let t of parts){
    if(!t) continue;
    const sign = t[0]==='-'? -1 : (t[0]==='+'? +1 : +1);
    if(t[0]==='+' || t[0]==='-') t = t.slice(1);
    if(/i$/i.test(t)){
      const core = t.slice(0,-1);
      if(core===''){ b += sign*1; }
      else {
        const v = parseFloat(core);
        if(!Number.isFinite(v)) return null;
        b += sign*v;
      }
    }else{
      const v = parseFloat(t);
      if(!Number.isFinite(v)) return null;
      a += sign*v;
    }
  }
  const eps=1e-9;
  if (Math.abs(a)<eps) a=0;
  if (Math.abs(b)<eps) b=0;
  return {a,b};
}
function eqComplexStr(str, A, B){
  const p = parseComplex(str);
  return !!p && Math.abs(p.a-A)<1e-9 && Math.abs(p.b-B)<1e-9;
}

/* Helpers d‚Äôaffichage pour les √©tapes ‚Äî suppriment les termes nuls et 1i */
const PM = v => v >= 0 ? ' + ' : ' ‚àí ';
const IABS = v => (Math.abs(v) === 1 ? 'i' : String(Math.abs(v)).replace('.',',') + 'i');
// juste sous: const IABS = v => ...
const IABS2 = v => (Math.abs(v) === 1 ? 'i<sup>2</sup>' : String(Math.abs(v)).replace('.',',') + 'i<sup>2</sup>');
function powResult(z, pow){
  return (pow===2)
    ? { a: z.a*z.a - z.b*z.b, b: 2*z.a*z.b }
    : { a: z.a*z.a*z.a - 3*z.a*z.b*z.b, b: 3*z.a*z.a*z.b - z.b*z.b*z.b };
}

function dispZ_steps(z){
  let out = '';
  if (z.a !== 0) out += String(z.a);
  if (z.b !== 0){
    const pref = out ? PM(z.b) : (z.b<0 ? '‚àí ' : '');
    out += pref + IABS(z.b);
  }
  if (!out) out = '0';
  return out;
}
const parenZ_steps = z => `(${dispZ_steps(z)})`;
function termR(v){ if(v===0) return ''; return PM(v) + String(Math.abs(v)); }
function termI(v){ if(v===0) return ''; return PM(v) + IABS(v); }

/* k¬∑z_j sans espace interne (‚àí3z‚ÇÅ, 5z‚ÇÇ, z‚ÇÅ, ‚àíz‚ÇÇ) */
function termC(k, label){
  if (k === 1)  return label;
  if (k === -1) return UMINUS + label;
  return (k < 0 ? UMINUS + Math.abs(k) : String(k)) + label;
}

/* ===== Rendu commun ===== */
function mkRow(host, enonceHTML, fields){
  host.innerHTML='';
  const wrap=document.createElement('div'); wrap.className='row';
  const st=document.createElement('div'); st.className='statement';
  st.innerHTML = enonceHTML || '';
  wrap.appendChild(st);

  const inputs=document.createElement('div'); inputs.className='inputs';
  fields.forEach(f=>{
    const row=document.createElement('div'); row.className='ans-row';
    row.innerHTML = (f.label? `<span class="equ" aria-hidden="true">${f.label}</span>` : '')+
      `<input type="text" id="${f.id}" placeholder="${f.placeholder||'‚Ä¶'}" style="flex:1;min-width:0">`+
      `<span class="tick" id="${f.id}-tick"></span>`;
    inputs.appendChild(row);
  });
  wrap.appendChild(inputs);

  const res=document.createElement('div'); res.id='res'; wrap.appendChild(res);
  host.appendChild(wrap);

  fields.forEach(f=>{
    $('#'+f.id,host)?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  });
}
function setTick(host, id, val){ const el = $('#'+id+'-tick',host); if(el) el.textContent = val||''; }
function anyEmpty(host, ids){ return ids.some(id => !($('#'+id,host)?.value||'').trim()); }
function showSteps(host, steps){
  const uniq=[]; for(const L of steps){ if(!uniq.length || uniq[uniq.length-1]!==L) uniq.push(L); }
  $('#res',host).innerHTML = '<div class="steps">'+uniq.map(t=>'<div class="step">'+t+'</div>').join('')+'</div>';
  $('#res',host).className='small';
}

/* ====== G√©n√©rateurs ====== */
function randZ(){ return {a:rnd(-9,9), b:rnd(-9,9)}; }
function randZnz(){ let z=randZ(); while(z.a===0 && z.b===0) z=randZ(); return z; }

/* ========== Exercices ========== */

/* Ex.1 ‚Äî Parties r√©elle & imaginaire */
const ex1 = {
  id:'cplx1', title:'Partie r√©elle & partie imaginaire',
  gen(){
    const z = randZnz();
    const order = Math.random()<0.5 ? 'a+bi' : 'bi+a';
    const enonce = `
      <div class="consigne"><strong>Exercice 1 :</strong> Identifier la partie r√©elle et la partie imaginaire du nombre complexe suivant :</div>
      <div><code class="equ">z = ${fmtComplex(z.a, z.b, order)}</code></div>
    `;
    return {z, enonce};
  },
  render(h,st){
    mkRow(h, st.enonce, [
      {id:'re', label:'Re(z) =', placeholder:'‚Ä¶'},
      {id:'im', label:'Im(z) =', placeholder:'‚Ä¶'}
    ]);
  },
  correct(h,st){
    const ids=['re','im'];
    if(anyEmpty(h,ids)) return {ok:false,total:0};
    const reStr=$('#re',h).value, imStr=$('#im',h).value;
    const re = parseFloat(norm(reStr).replace(/i$/i,''));
    const im = parseFloat(norm(imStr).replace(/i$/i,''));
    const ok1 = Number.isFinite(re) && Math.abs(re - st.z.a) < 1e-9;
    const ok2 = Number.isFinite(im) && Math.abs(im - st.z.b) < 1e-9;
    setTick(h,'re', ok1?'‚úî':'‚úò');
    setTick(h,'im', ok2?'‚úî':'‚úò');
    return {ok: ok1 && ok2, total:1};
  },
  solution(h,st){
    showSteps(h, [ `Lecture directe : Re(z) = ${st.z.a} et Im(z) = ${st.z.b}.` ]);
  },
  reset(h){ ['re','im'].forEach(id=>{ const el=$('#'+id,h); if(el) el.value=''; setTick(h,id,''); }); $('#res',h).textContent=''; }
};

/* Ex.2 ‚Äî Somme & diff√©rence (saisies sous chaque question) */
const ex2 = {
  id:'cplx2', title:'Somme et diff√©rence de deux complexes',
  gen(){
    const z1=randZnz(), z2=randZnz();
    const rA = {a:z1.a+z2.a, b:z1.b+z2.b};
    const rB = {a:z1.a-z2.a, b:z1.b-z2.b};
    const enonce = `
      <div class="consigne"><strong>Exercice 2 :</strong></div>
      <div>Soient <code class="equ">z<sub>1</sub> = ${fmtComplex(z1.a,z1.b)}</code> et
           <code class="equ">z<sub>2</sub> = ${fmtComplex(z2.a,z2.b)}</code>.</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique <code>a + bi</code>.</div>

      <div style="margin-top:.4rem"><strong>a)</strong> <code class="equ">z<sub>1</sub> + z<sub>2</sub></code></div>
      <div class="ans-row"><span class="equ">z<sub>1</sub> + z<sub>2</sub> =</span>
        <input type="text" id="ans_a" placeholder="a + bi" style="flex:1;min-width:0">
        <span class="tick" id="ans_a-tick"></span></div>

      <div style="margin-top:.4rem"><strong>b)</strong> <code class="equ">z<sub>1</sub> ‚àí z<sub>2</sub></code></div>
      <div class="ans-row"><span class="equ">z<sub>1</sub> ‚àí z<sub>2</sub> =</span>
        <input type="text" id="ans_b" placeholder="a + bi" style="flex:1;min-width:0">
        <span class="tick" id="ans_b-tick"></span></div>
    `;
    return {z1,z2,rA,rB,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;
    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);
    ['ans_a','ans_b'].forEach(id=>{
      host.querySelector('#'+id)?.addEventListener('keydown', e=>{
        if(e.key==='Enter'){ e.preventDefault(); check(); }
      });
    });
  },
  correct(host,st){
    const ids=['ans_a','ans_b'];
    if (anyEmpty(host,ids)) return {ok:false,total:0};
    const Aok = eqComplexStr(host.querySelector('#ans_a').value, st.rA.a, st.rA.b);
    const Bok = eqComplexStr(host.querySelector('#ans_b').value, st.rB.a, st.rB.b);
    host.querySelector('#ans_a-tick').textContent = Aok?'‚úî':'‚úò';
    host.querySelector('#ans_b-tick').textContent = Bok?'‚úî':'‚úò';
    return {ok:Aok && Bok, total:1};
  },
  solution(host,st){
    let sumLine = `z‚ÇÅ + z‚ÇÇ = ${dispZ_steps(st.z1)}`;
    sumLine += termR(st.z2.a) + termI(st.z2.b);
    sumLine += ` = ${fmtComplex(st.rA.a, st.rA.b,'a+bi')}`;

    const diffParen = `z‚ÇÅ ‚àí z‚ÇÇ = ${dispZ_steps(st.z1)} ‚àí ${parenZ_steps(st.z2)}`;
    const diffDistrib = dispZ_steps(st.z1) + termR(-st.z2.a) + termI(-st.z2.b);
    const diffLine = `${diffParen} = ${diffDistrib} = ${fmtComplex(st.rB.a, st.rB.b,'a+bi')}`;

    showSteps(host, [sumLine, '', diffLine]);
  },
  reset(host){
    ['ans_a','ans_b'].forEach(id=>{
      const el=host.querySelector('#'+id); if(el) el.value='';
      const tk=host.querySelector('#'+id+'-tick'); if(tk) tk.textContent='';
    });
    host.querySelector('#res').textContent='';
  }
};

/* Ex.3 ‚Äî Combinaison lin√©aire p z1 ¬± q z2 (expression devant la saisie) */
const ex3 = {
  id:'cplx3', title:'Combinaison lin√©aire de deux complexes',
  gen(){
    const z1=randZnz(), z2=randZnz();
    const p=nz(-5,5), q=nz(-5,5);
    const t1 = termC(p, 'z<sub>1</sub>');
    const expr = (q >= 0)
      ? `${t1} + ${termC(q, 'z<sub>2</sub>')}`
      : `${t1} ‚àí ${termC(-q, 'z<sub>2</sub>')}`;
    const r = {a: p*z1.a + q*z2.a, b: p*z1.b + q*z2.b};
    const enonce = `
      <div class="consigne"><strong>Exercice 3 :</strong></div>
      <div>Soient <code class="equ">z<sub>1</sub> = ${fmtComplex(z1.a,z1.b)}</code> et <code class="equ">z<sub>2</sub> = ${fmtComplex(z2.a,z2.b)}</code>.</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique <code>a + bi</code>.</div>

      <div style="margin-top:.35rem"><code class="equ" id="ex3-expr">${expr}</code></div>
      <div class="ans-row" style="margin-top:.15rem">
        <span class="equ" id="ex3-label">${expr} =</span>
        <input type="text" id="ans_ex3" placeholder="a + bi" style="flex:1;min-width:0">
        <span class="tick" id="ans_ex3-tick"></span>
      </div>
    `;
    return {z1,z2,p,q,r,expr,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;
    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);
    host.querySelector('#ans_ex3')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  },
  correct(host,st){
    const el=host.querySelector('#ans_ex3');
    if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    host.querySelector('#ans_ex3-tick').textContent = ok?'‚úî':'‚úò';
    return {ok,total:1};
  },
  solution(host,st){
    const a1=st.z1.a, b1=st.z1.b, a2=st.z2.a, b2=st.z2.b, p=st.p, q=st.q;
    const expr = st.expr; // d√©j√† bien form√© "pz1 ¬± qz2"

 // 2) p(‚Ä¶) ¬± q(‚Ä¶)  ‚Äî garder le signe de p devant le premier facteur
const fac1core = (Math.abs(p) === 1 ? '' : Math.abs(p)) + parenZ_steps(st.z1);
const fac1     = (p < 0 ? '‚àí' : '') + fac1core;   // << signe de p restaur√© (sans espace)

const op2  = (q >= 0 ? ' + ' : ' ‚àí ');            // signe entre les deux facteurs = signe de q
const fac2 = (Math.abs(q) === 1 ? '' : Math.abs(q)) + parenZ_steps(st.z2);

const line2 = `${expr} = ${fac1}${op2}${fac2}`;


    // 3) Distribution : on ne garde que les termes non nuls, sans 1i/0
    const items = [];
    if (p*a1!==0) items.push({t:'r',v:p*a1});
    if (p*b1!==0) items.push({t:'i',v:p*b1});
    if (q*a2!==0) items.push({t:'r',v:q*a2});
    if (q*b2!==0) items.push({t:'i',v:q*b2});

    let line3Expr = '';
    if (items.length===0){
      line3Expr = '0';
    }else{
      items.forEach((it,idx)=>{
        const seg = it.t==='r' ? String(Math.abs(it.v)) : IABS(it.v);
        line3Expr += (it.v>=0 ? (idx? ' + ' : '') : (idx? ' ‚àí ' : '‚àí ')) + seg;
      });
    }
    const line3 = `${expr} = ${line3Expr}`;

    // 4) R√©sultat final
    const final = `${expr} = ${fmtComplex(st.r.a, st.r.b,'a+bi')}`;

    showSteps(host, [line2, line3, final]);
  },
  reset(host){
    const el=host.querySelector('#ans_ex3'); if(el) el.value='';
    const tk=host.querySelector('#ans_ex3-tick'); if(tk) tk.textContent='';
    host.querySelector('#res').textContent='';
  }
};

/* Ex.4 ‚Äî Produit z1 √ó z2 (mise en forme style screen) */
const ex4 = {
  id:'cplx4', title:'Produit de deux nombres complexes',
  gen(){
    const z1=randZnz(), z2=randZnz();
    const r = { a: z1.a*z2.a - z1.b*z2.b, b: z1.a*z2.b + z1.b*z2.a };
    const enonce = `
      <div class="consigne"><strong>Exercice 4 :</strong></div>
      <div>Soient <code class="equ">z<sub>1</sub> = ${fmtComplex(z1.a,z1.b)}</code> et <code class="equ">z<sub>2</sub> = ${fmtComplex(z2.a,z2.b)}</code>.</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique <code>a + bi</code>.</div>
      <div><code class="equ">z<sub>1</sub> √ó z<sub>2</sub></code></div>
    `;
    return {z1,z2,r,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;

    // ‚ü∂ Label "z1 √ó z2 =" devant la saisie
    const row=document.createElement('div'); row.className='ans-row';
    row.innerHTML = `<span class="equ">z<sub>1</sub> √ó z<sub>2</sub> =</span>
      <input type="text" id="ans" placeholder="a + bi" style="flex:1;min-width:0">
      <span class="tick" id="ans-tick"></span>`;
    S.appendChild(row);

    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);

    host.querySelector('#ans')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  },
  correct(host,st){
    const el=host.querySelector('#ans'); if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    host.querySelector('#ans-tick').textContent = ok?'‚úî':'‚úò';
    return {ok,total:1};
  },
  solution(host,st){
    const a1=st.z1.a, b1=st.z1.b, a2=st.z2.a, b2=st.z2.b;
    const t1=a1*a2, t2=a1*b2, t3=b1*a2, t4=b1*b2; // 4 termes

    // util : ajoute un terme non nul avec bons signes et sans "1i"/"1i¬≤"
    const addTerm = (rhs, val, render) => {
      if(val===0) return rhs;
      const piece = render(Math.abs(val));
      if(!rhs) return (val<0 ? '‚àí ' : '') + piece;
      return rhs + (val>0 ? ' + ' : ' ‚àí ') + piece;
    };

    // L1 : (a+bi)(c+di)
    const L1 = `z‚ÇÅ √ó z‚ÇÇ = (${fmtComplex(a1,b1,'a+bi')})(${fmtComplex(a2,b2,'a+bi')})`;

    // L2 : produits d√©velopp√©s (‚Ä¶ + ‚Ä¶i + ‚Ä¶i + ‚Ä¶i¬≤) sans z√©ros ni "1i"
    let rhs2 = '';
    rhs2 = addTerm(rhs2, t1, v => String(v));
    rhs2 = addTerm(rhs2, t2, v => (v===1 ? 'i' : v + 'i'));
    rhs2 = addTerm(rhs2, t3, v => (v===1 ? 'i' : v + 'i'));
    rhs2 = addTerm(rhs2, t4, v => (v===1 ? 'i<sup>2</sup>' : v + 'i<sup>2</sup>'));
    if (!rhs2) rhs2 = '0';
    const L2 = `z‚ÇÅ √ó z‚ÇÇ = ${rhs2}`;

    // L3 : remplace i¬≤ par ‚àí1 (si le terme existe)
    const L3 = (t4!==0)
      ? (()=> {
          let rhs3 = '';
          rhs3 = addTerm(rhs3, t1, v => String(v));
          rhs3 = addTerm(rhs3, t2, v => (v===1 ? 'i' : v + 'i'));
          rhs3 = addTerm(rhs3, t3, v => (v===1 ? 'i' : v + 'i'));
          rhs3 = addTerm(rhs3, -t4, v => String(v)); // i¬≤ = ‚àí1
          return `z‚ÇÅ √ó z‚ÇÇ = ${rhs3} (car i¬≤ = ‚àí1)`;
        })()
      : null;

    // L4 : r√©sultat combin√©
    const L4 = `z‚ÇÅ √ó z‚ÇÇ = ${fmtComplex(st.r.a, st.r.b,'a+bi')}`;

    showSteps(host, L3 ? [L1, L2, L3, L4] : [L1, L2, L4]);
  },
  reset(host){
    const el=host.querySelector('#ans'); if(el) el.value='';
    const tk=host.querySelector('#ans-tick'); if(tk) tk.textContent='';
    host.querySelector('#res').textContent='';
  }
};


/* Ex.5 ‚Äî Puissance (z¬≤ ou z¬≥) avec s√©lecteur */
const ex5 = {
  id:'cplx5', title:'Puissance d‚Äôun complexe (z¬≤ ou z¬≥)',
  gen(){
    const z = randZnz();
const pow = (typeof window !== 'undefined' && window.ZPOW) ? window.ZPOW : 2;
    const r = powResult(z, pow);
    const enonce = `
      <div class="consigne"><strong>Exercice 5 :</strong></div>
      <div>Soit <code class="equ">z = ${fmtComplex(z.a,z.b)}</code>.</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique <code>a + bi</code>.</div>
      <div><code class="equ">z<sup>2</sup> ou z<sup>3</sup></code></div>
    `;
    return {z,pow,r,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;

    // S√©lecteur z¬≤ / z¬≥
    const selRow=document.createElement('div'); selRow.className='ans-row';
selRow.innerHTML = `
  <label class="equ" for="pow-select" style="margin-right:6px">Puissance :</label>
  <select id="pow-select">
    <option value="2">z\u00B2</option>  <!-- z¬≤ -->
    <option value="3">z\u00B3</option>  <!-- z¬≥ -->
  </select>`;
S.appendChild(selRow);


    // Saisie avec label dynamique "z¬≤ =" / "z¬≥ ="
    const row=document.createElement('div'); row.className='ans-row';
    row.innerHTML = `<span class="equ" id="pow-label">z<sup>${st.pow}</sup> =</span>
      <input type="text" id="ans" placeholder="a + bi" style="flex:1;min-width:0">
      <span class="tick" id="ans-tick"></span>`;
    S.appendChild(row);

    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);

    // init s√©lecteur
    const sel = host.querySelector('#pow-select');
    sel.value = String(st.pow);

    // changement de puissance ‚Üí met √† jour l'√©tat, le label, la cible corrig√©e, et vide saisie/solution
    sel.addEventListener('change', ()=>{
  st.pow = parseInt(sel.value,10);
  window.ZPOW = st.pow;                 // << m√©morise le choix
  st.r = powResult(st.z, st.pow);
  host.dataset.state = JSON.stringify(st);
  host.querySelector('#pow-label').innerHTML = `z<sup>${st.pow}</sup> =`;
  const inp = host.querySelector('#ans'); if(inp) inp.value='';
  const tk  = host.querySelector('#ans-tick'); if(tk) tk.textContent='';
  const rs  = host.querySelector('#res'); if(rs) rs.textContent='';
});


    host.querySelector('#ans')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  },
  correct(host,st){
    const el=host.querySelector('#ans'); if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    host.querySelector('#ans-tick').textContent = ok?'‚úî':'‚úò';
    return {ok,total:1};
  },
  // --- remplace UNIQUEMENT la m√©thode solution(...) de ex5 par ceci ---
solution(host, st){
  const a = st.z.a, b = st.z.b;
  const zdisp = fmtComplex(a,b,'a+bi');

  // petit util local (respecte i / ‚àíi, pas 1i, etc.)
  const addTerm = (rhs, val, render) => {
    if(val===0) return rhs;
    const piece = render(Math.abs(val));
    if(!rhs) return (val<0 ? '‚àí ' : '') + piece;
    return rhs + (val>0 ? ' + ' : ' ‚àí ') + piece;
  };
  const biStr = (b<0 ? '‚àí ' : '') + (Math.abs(b)===1 ? 'i' : Math.abs(b)+'i');

  // --- CAS PARTICULIERS ---
  // z = a (b = 0)
  if (b === 0){
    if (st.pow === 2){
      const L1 = `z<sup>2</sup> = ${a}<sup>2</sup>`;
      const L2 = `z<sup>2</sup> = ${fmtComplex(a*a, 0, 'a+bi')}`;
      showSteps(host, [L1, L2]); return;
    } else {
      const L1 = `z<sup>3</sup> = ${a}<sup>3</sup>`;
      const L2 = `z<sup>3</sup> = ${fmtComplex(a*a*a, 0, 'a+bi')}`;
      showSteps(host, [L1, L2]); return;
    }
  }

  // z = bi (a = 0)
  if (a === 0){
    if (st.pow === 2){
      const coef2 = b*b; // >= 0
      const L1 = `z<sup>2</sup> = (${biStr})<sup>2</sup>`;
      const L2 = `z<sup>2</sup> = ${coef2===1 ? 'i<sup>2</sup>' : coef2+'i<sup>2</sup>'}`;
      const L3 = `z<sup>2</sup> = ${fmtComplex(-coef2, 0, 'a+bi')}`;
      showSteps(host, [L1, L2, L3]); return;
    } else {
      const coef3 = b*b*b; // signe de b
      const term3 = (Math.abs(coef3)===1 ? 'i<sup>3</sup>' : Math.abs(coef3)+'i<sup>3</sup>');
      const L1 = `z<sup>3</sup> = (${biStr})<sup>3</sup>`;
      const L2 = `z<sup>3</sup> = ${(coef3<0?'‚àí ':'')+term3}`;
      const L3 = `z<sup>3</sup> = ${fmtComplex(0, -coef3, 'a+bi')}`;
      showSteps(host, [L1, L2, L3]); return;
    }
  }

  // --- CAS G√âN√âRAL (inchang√©, avec lignes d√©taill√©es) ---
  if(st.pow===2){
    const t1=a*a, t2=2*a*b, t3=b*b;
    const L1 = `z<sup>2</sup> = (${zdisp})<sup>2</sup>`;
    let rhs2=''; rhs2=addTerm(rhs2,t1,v=>String(v)); rhs2=addTerm(rhs2,t2,v=>v===1?'i':v+'i'); rhs2=addTerm(rhs2,t3,v=> (Math.abs(v)===1?'i<sup>2</sup>':v+'i<sup>2</sup>'));
    const L2 = `z<sup>2</sup> = ${rhs2}`;
    let rhs3=''; rhs3=addTerm(rhs3,t1,v=>String(v)); rhs3=addTerm(rhs3,t2,v=>v===1?'i':v+'i'); rhs3=addTerm(rhs3,-t3,v=>String(v));
    const L3 = `z<sup>2</sup> = ${rhs3}`;
    const L4 = `z<sup>2</sup> = ${fmtComplex(st.r.a, st.r.b,'a+bi')}`;
    showSteps(host,[L1,L2,L3,L4]); return;
  }

  // z^3 (g√©n√©ral) ‚Äî y compris la ligne manquante L3b d√©j√† int√©gr√©e
  const L1 = `z<sup>3</sup> = (${zdisp})<sup>3</sup>`;
  const L2 = `z<sup>3</sup> = (${zdisp})<sup>2</sup>(${zdisp})`;

  const s1=a*a, s2=2*a*b, s3=b*b;
  let sq=''; sq=addTerm(sq,s1,v=>String(v)); sq=addTerm(sq,s2,v=>v===1?'i':v+'i'); sq=addTerm(sq,s3,v=> (Math.abs(v)===1?'i<sup>2</sup>':v+'i<sup>2</sup>'));
  const L3  = `z<sup>3</sup> = (${sq})(${zdisp})`;

  let sqNoI2=''; sqNoI2=addTerm(sqNoI2,s1,v=>String(v)); sqNoI2=addTerm(sqNoI2,s2,v=>v===1?'i':v+'i'); sqNoI2=addTerm(sqNoI2,-s3,v=>String(v));
  const L3b = `z<sup>3</sup> = (${sqNoI2})(${zdisp})`;

  const SR=a*a-b*b, SI=2*a*b;
  const L4 = `z<sup>3</sup> = (${dispZ_steps({a:SR,b:SI})})(${zdisp}) `;

  const t1=SR*a, t2=SR*b, t3=SI*a, t4=SI*b;
  let dev1=''; dev1=addTerm(dev1,t1,v=>String(v)); dev1=addTerm(dev1,t2,v=>v===1?'i':v+'i'); dev1=addTerm(dev1,t3,v=>v===1?'i':v+'i'); dev1=addTerm(dev1,t4,v=> (Math.abs(v)===1?'i<sup>2</sup>':v+'i<sup>2</sup>'));
  const L5 = `z<sup>3</sup> = ${dev1}`;

  let dev2=''; dev2=addTerm(dev2,t1,v=>String(v)); dev2=addTerm(dev2,t2,v=>v===1?'i':v+'i'); dev2=addTerm(dev2,t3,v=>v===1?'i':v+'i'); dev2=addTerm(dev2,-t4,v=>String(v));
  const L6 = `z<sup>3</sup> = ${dev2}`;

  const L7 = `z<sup>3</sup> = ${fmtComplex(st.r.a, st.r.b,'a+bi')}`;
  showSteps(host,[L1,L2,L3,L3b,L4,L5,L6,L7]);
},
  reset(host){
    const el=host.querySelector('#ans'); if(el) el.value='';
    const tk=host.querySelector('#ans-tick'); if(tk) tk.textContent='';
    const rs=host.querySelector('#res'); if(rs) rs.textContent='';
    const sel=host.querySelector('#pow-select');
    if(sel){
      // on ne change pas la puissance courante ; si tu pr√©f√®res, force √† 2 ici :
      // sel.value='2'; const st=JSON.parse(host.dataset.state||'{}'); st.pow=2; st.r=powResult(st.z,2); host.dataset.state=JSON.stringify(st);
    }
  }
};



/* ===== Registry & m√©canique ===== */
const REGISTRY=[ex1,ex2,ex3,ex4,ex5];
window.REGISTRY=REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(state);
  def.render(host,state);
  $('#res',host).textContent='';
  host.querySelectorAll('.tick').forEach(x=>x.textContent='');
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st = JSON.parse(host.dataset.state||'{}');
  const r = def.correct(host, st);
  scoreTot += r.total; scoreOK += r.ok?1:0; updateScore();
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st = JSON.parse(host.dataset.state||'{}');
  def.solution(host, st);
}
function resetAll(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st = JSON.parse(host.dataset.state||'{}'); def.reset(host, st);
}

/* ==== Init ==== */
whenReady(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map(e=>'<option value="'+e.id+'">'+e.title+'</option>').join('');
  sel.addEventListener('change', buildOne);
  $("#btn-new").addEventListener('click', buildOne);
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  buildOne();

  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: '1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique',
      max: 50,
      lead: '',
      leadByDefId: { cplx1:'', cplx2:'', cplx3:'', cplx4:'', cplx5:'' },
      mountAfterSelector: '.card.small'
    });
  }
});
})(); // IIFE
</script>

<script>
/* Confort mobile + clavier */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        const clone = src ? src.cloneNode(true) : null;
        if (clone) {
          clone.classList.add('btn'); clone.type='button'; clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className='btn'; fallback.type='button'; fallback.textContent=label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
