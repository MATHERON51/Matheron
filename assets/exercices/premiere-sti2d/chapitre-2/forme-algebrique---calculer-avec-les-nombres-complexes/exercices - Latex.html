<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.55}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .row{display:grid;grid-template-columns:1fr;gap:10px}
  .statement{font-size:18px}
  .statement .consigne{opacity:.8;margin-bottom:6px}
  #host .inputs{display:flex;flex-direction:column;gap:8px}
  #host .ans-row{display:flex;align-items:center;gap:6px}
  #host .ans-row .tick{min-width:1.2em;text-align:center}
  #res.small{font-size:15px}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}
  @media (max-width:720px){ .controls{gap:6px} }
  .solution .mjx-container{font-size:115%}
</style>

<!-- MathJax (LaTeX) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: {
      // on n‚Äôignore pas <code>/<pre> afin de laisser MathJax traiter tout ce qui contient \\( ‚Ä¶ \\)
      skipHtmlTags: ['script','noscript','style','textarea']
    },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D ‚Äì <strong>Nombres complexes</strong> ‚Äî Forme alg√©brique</h1>
    <div class="controls">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>
  </div>

  <div class="wrap">
    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 1.1rem">
        <li>R√©pondre en <em>forme alg√©brique</em> : <code>a + bi</code>. <em>bi + a</em>, <em>a</em> (si <code>b=0</code>) et <em>bi</em> (si <code>a=0</code>) sont accept√©es.</li>
        <li>Jamais <code>1i</code>/<code>‚àí1i</code> (√©crire <code>i</code>/<code>‚àíi</code>) ; pas de <code>0i</code>, <code>+0</code>, <code>0+</code>.</li>
        <li>D√©cimales : virgule ou point. Les √©critures <code>3*i</code>, <code>3 i</code>, <code>3√ói</code> sont normalis√©es en <code>3i</code>.</li>
        <li>Le score ne change pas tant qu‚Äôune saisie est vide. <kbd>Entr√©e</kbd> d√©clenche <em>V√©rifier</em>.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Scripts partag√©s -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){
'use strict';

/* ===== Helpers ===== */
// Souvenir du choix utilisateur pour l'exo 5 (2 par d√©faut)
window.ZPOW = window.ZPOW || 2;

function whenReady(cb){
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', cb, { once: true });
  } else {
    cb();
  }
}
function $(s,r){ return (r||document).querySelector(s); }
function rnd(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function nz(a,b){ let v=0; while(v===0) v=rnd(a,b); return v; }
const UMINUS = '‚àí';
const CC = '\\(\\mathbb{C}\\)';

function norm(s){
  return String(s||'')
    .replace(/\u2212/g,'-')  // ‚àí ‚Üí - (pour parsing)
    .replace(/,/g,'.')       // virgule ‚Üí point
    .replace(/¬∑|√ó/g,'*')     // visuels ‚Üí *
    .trim();
}

/* Affichage serr√© + simplifications globales (texte √† l'int√©rieur de LaTeX) */
function fmtNum(n){
  const v = Math.abs(n);
  const s = Number.isInteger(n) ? String(v) : String(v).replace('.',',');
  return n < 0 ? UMINUS + s : s;
}
function fmtIcoef(b){
  if (b === 0) return '';
  const abs = Math.abs(b);
  const core = (abs === 1 ? 'i' : String(abs).replace('.',',') + 'i');
  if (b > 0) return ' + ' + core;
  return ' ' + UMINUS + core;
}
function fmtComplex(a, b, order/*'a+bi'|'bi+a'*/){
  if (order === 'bi+a'){
    if (b === 0) return (a === 0 ? '0' : fmtNum(a));
    if (a === 0) return (b === 1 ? 'i' : (b === -1 ? UMINUS + 'i'
                  : (b < 0 ? UMINUS + String(Math.abs(b)).replace('.',',') + 'i'
                           : String(b).replace('.',',') + 'i')));
    const left = (b > 0 ? (b === 1 ? 'i' : String(b).replace('.',',') + 'i')
                        : (b === -1 ? UMINUS + 'i' : UMINUS + String(Math.abs(b)).replace('.',',') + 'i'));
    const right = (a >= 0 ? ' + ' + fmtNum(a) : ' ' + UMINUS + String(Math.abs(a)));
    return left + right;
  } else {
    if (a === 0 && b === 0) return '0';
    if (a === 0) return (b === 1 ? 'i' : (b === -1 ? UMINUS + 'i'
                  : (b < 0 ? UMINUS + String(Math.abs(b)).replace('.',',') + 'i'
                           : String(b).replace('.',',') + 'i')));
    if (b === 0) return fmtNum(a);
    return fmtNum(a) + fmtIcoef(b);
  }
}

/* Parsing tol√©rant */
function parseComplex(str){
  if(!str) return null;
  let s = norm(str).replace(/\s+/g,'');
  s = s.replace(/^(?:z\s*=?\s*)/i,''); // retire "z =" √©ventuel
  s = s.replace(/\*/g,'');
  const parts = s.match(/[+\-]?[^+\-]+/g);
  if(!parts) return null;
  let a=0, b=0;
  for(let t of parts){
    if(!t) continue;
    const sign = t[0]==='-'? -1 : (t[0]==='+'? +1 : +1);
    if(t[0]==='+' || t[0]==='-') t = t.slice(1);
    if(/i$/i.test(t)){
      const core = t.slice(0,-1);
      if(core===''){ b += sign*1; }
      else {
        const v = parseFloat(core);
        if(!Number.isFinite(v)) return null;
        b += sign*v;
      }
    }else{
      const v = parseFloat(t);
      if(!Number.isFinite(v)) return null;
      a += sign*v;
    }
  }
  const eps=1e-9;
  if (Math.abs(a)<eps) a=0;
  if (Math.abs(b)<eps) b=0;
  return {a,b};
}
function eqComplexStr(str, A, B){
  const p = parseComplex(str);
  return !!p && Math.abs(p.a-A)<1e-9 && Math.abs(p.b-B)<1e-9;
}

/* Helpers d‚Äôaffichage pour les √©tapes ‚Äî suppriment les termes nuls et 1i */
const PM = v => v >= 0 ? ' + ' : ' ‚àí ';
const IABS = v => (Math.abs(v) === 1 ? 'i' : String(Math.abs(v)).replace('.',',') + 'i');
const IABS2 = v => (Math.abs(v) === 1 ? 'i^{2}' : String(Math.abs(v)).replace('.',',') + 'i^{2}');
function powResult(z, pow){
  return (pow===2)
    ? { a: z.a*z.a - z.b*z.b, b: 2*z.a*z.b }
    : { a: z.a*z.a*z.a - 3*z.a*z.b*z.b, b: 3*z.a*z.a*z.b - z.b*z.b*z.b };
}

function dispZ_steps(z){
  let out = '';
  if (z.a !== 0) out += String(z.a);
  if (z.b !== 0){
    const pref = out ? PM(z.b) : (z.b<0 ? '‚àí ' : '');
    out += pref + IABS(z.b);
  }
  if (!out) out = '0';
  return out;
}
const parenZ_steps = z => `(${dispZ_steps(z)})`;
function termR(v){ if(v===0) return ''; return PM(v) + String(Math.abs(v)); }
function termI(v){ if(v===0) return ''; return PM(v) + IABS(v); }

/* k¬∑z_j sans espace interne (‚àí3z‚ÇÅ, 5z‚ÇÇ, z‚ÇÅ, ‚àíz‚ÇÇ) ‚Üí version LaTeX z_{j} */
function termC(k, label/* 'z_{1}' etc. */){
  if (k === 1)  return label;
  if (k === -1) return UMINUS + label;
  return (k < 0 ? UMINUS + Math.abs(k) : String(k)) + label;
}

/* ===== MathJax helper ===== */
function typesetAll(root){
  const run = () => MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  if (window.MathJax && MathJax.startup && MathJax.startup.promise){
    MathJax.startup.promise.then(run);
  } else {
    const t = setInterval(()=>{
      if (window.MathJax && MathJax.startup && MathJax.typesetPromise){ clearInterval(t); run(); }
    }, 60);
  }
}

/* ===== Rendu commun ===== */
function mkRow(host, enonceHTML, fields){
  host.innerHTML='';
  const wrap=document.createElement('div'); wrap.className='row';
  const st=document.createElement('div'); st.className='statement';
  st.innerHTML = enonceHTML || '';
  wrap.appendChild(st);

  const inputs=document.createElement('div'); inputs.className='inputs';
  fields.forEach(f=>{
    const row=document.createElement('div'); row.className='ans-row';
    // labels : accepter labelTex (cha√Æne d√©j√† entre \\( ... \\)) ou label simple
    const lab = f.labelTex ? `\\(${f.labelTex}\\)` : (f.label ? `<span aria-hidden="true">${f.label}</span>` : '');
    row.innerHTML = lab +
      `<input type="text" id="${f.id}" placeholder="${f.placeholder||'‚Ä¶'}" style="flex:1;min-width:0">`+
      `<span class="tick" id="${f.id}-tick"></span>`;
    inputs.appendChild(row);
  });
  wrap.appendChild(inputs);

  const res=document.createElement('div'); res.id='res'; wrap.appendChild(res);
  host.appendChild(wrap);

  // Typeset LaTeX
  typesetAll(wrap);

  fields.forEach(f=>{
    $('#'+f.id,host)?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  });
}
function setTick(host, id, val){ const el = $('#'+id+'-tick',host); if(el) el.textContent = val||''; }
function anyEmpty(host, ids){ return ids.some(id => !($('#'+id,host)?.value||'').trim()); }
function showSteps(host, steps){
  const uniq=[]; for(const L of steps){ if(!uniq.length || uniq[uniq.length-1]!==L) uniq.push(L); }
  $('#res',host).innerHTML = '<div class="steps">'+uniq.map(t=>'\n<div class="step">'+t+'</div>').join('')+'</div>';
  $('#res',host).className='small';
  typesetAll($('#res',host));
}

/* ====== G√©n√©rateurs ====== */
function randZ(){ return {a:rnd(-9,9), b:rnd(-9,9)}; }
function randZnz(){ let z=randZ(); while(z.a===0 && z.b===0) z=randZ(); return z; }

/* ========== Exercices ========== */

/* Ex.1 ‚Äî Parties r√©elle & imaginaire */
const ex1 = {
  id:'cplx1', title:'Partie r√©elle & partie imaginaire',
  gen(){
    const z = randZnz();
    const order = Math.random()<0.5 ? 'a+bi' : 'bi+a';
    const enonce = `
      <div class="consigne"><strong>Exercice 1 :</strong> Identifier la partie r√©elle et la partie imaginaire du nombre complexe suivant :</div>
      <div>\\( z = ${fmtComplex(z.a, z.b, order)} \\)</div>
    `;
    return {z, enonce};
  },
  render(h,st){
    mkRow(h, st.enonce, [
      {id:'re', labelTex:'\\mathrm{Re}(z) =', placeholder:'‚Ä¶'},
      {id:'im', labelTex:'\\mathrm{Im}(z) =', placeholder:'‚Ä¶'}
    ]);
  },
  correct(h,st){
    const ids=['re','im'];
    if(anyEmpty(h,ids)) return {ok:false,total:0};
    const reStr=$('#re',h).value, imStr=$('#im',h).value;
    const re = parseFloat(norm(reStr).replace(/i$/i,''));
    const im = parseFloat(norm(imStr).replace(/i$/i,''));
    const ok1 = Number.isFinite(re) && Math.abs(re - st.z.a) < 1e-9;
    const ok2 = Number.isFinite(im) && Math.abs(im - st.z.b) < 1e-9;
    setTick(h,'re', ok1?'‚úî':'‚úò');
    setTick(h,'im', ok2?'‚úî':'‚úò');
    return {ok: ok1 && ok2, total:1};
  },
  solution(h,st){
    showSteps(h, [ `Lecture directe : \\(\\mathrm{Re}(z) = ${st.z.a}\\) et \\(\\mathrm{Im}(z) = ${st.z.b}\\).` ]);
  },
  reset(h){ ['re','im'].forEach(id=>{ const el=$('#'+id,h); if(el) el.value=''; setTick(h,id,''); }); $('#res',h).textContent=''; }
};

/* Ex.2 ‚Äî Somme & diff√©rence (saisies sous chaque question) */
const ex2 = {
  id:'cplx2', title:'Somme et diff√©rence de deux complexes',
  gen(){
    const z1=randZnz(), z2=randZnz();
    const rA = {a:z1.a+z2.a, b:z1.b+z2.b};
    const rB = {a:z1.a-z2.a, b:z1.b-z2.b};
    const enonce = `
      <div class="consigne"><strong>Exercice 2 :</strong></div>
      <div>Soient \\( z_{1} = ${fmtComplex(z1.a,z1.b)} \\) et \\( z_{2} = ${fmtComplex(z2.a,z2.b)} \\).</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique \\( a+bi \\).</div>

      <div style="margin-top:.4rem"><strong>a)</strong> \\( z_{1} + z_{2} \\)</div>
      <div class="ans-row"><span aria-hidden="true">\\( z_{1} + z_{2} = \\)</span>
        <input type="text" id="ans_a" placeholder="a + bi" style="flex:1;min-width:0">
        <span class="tick" id="ans_a-tick"></span></div>

      <div style="margin-top:.4rem"><strong>b)</strong> \\( z_{1} - z_{2} \\)</div>
      <div class="ans-row"><span aria-hidden="true">\\( z_{1} - z_{2} = \\)</span>
        <input type="text" id="ans_b" placeholder="a + bi" style="flex:1;min-width:0">
        <span class="tick" id="ans_b-tick"></span></div>
    `;
    return {z1,z2,rA,rB,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;
    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);
    typesetAll(wrap);
    ['ans_a','ans_b'].forEach(id=>{
      host.querySelector('#'+id)?.addEventListener('keydown', e=>{
        if(e.key==='Enter'){ e.preventDefault(); check(); }
      });
    });
  },
  correct(host,st){
    const ids=['ans_a','ans_b'];
    if (anyEmpty(host,ids)) return {ok:false,total:0};
    const Aok = eqComplexStr(host.querySelector('#ans_a').value, st.rA.a, st.rA.b);
    const Bok = eqComplexStr(host.querySelector('#ans_b').value, st.rB.a, st.rB.b);
    host.querySelector('#ans_a-tick').textContent = Aok?'‚úî':'‚úò';
    host.querySelector('#ans_b-tick').textContent = Bok?'‚úî':'‚úò';
    return {ok:Aok && Bok, total:1};
  },
  solution(host,st){
  const L1 = `\\( z_{1} + z_{2} =  ${dispZ_steps(st.z1)}${termR(st.z2.a)}${termI(st.z2.b)} = ${fmtComplex(st.rA.a, st.rA.b,'a+bi')} \\)`;

  const L2 = `\\( z_{1} - z_{2} = ${dispZ_steps(st.z1)} - ${parenZ_steps(st.z2)} = ${dispZ_steps(st.z1)}${termR(-st.z2.a)}${termI(-st.z2.b)} = ${fmtComplex(st.rB.a, st.rB.b,'a+bi')} \\)`;

  showSteps(host, [L1, L2]);
},

  reset(host){
    ['ans_a','ans_b'].forEach(id=>{
      const el=host.querySelector('#'+id); if(el) el.value='';
      const tk=host.querySelector('#'+id+'-tick'); if(tk) tk.textContent='';
    });
    host.querySelector('#res').textContent='';
  }
};

/* Ex.3 ‚Äî Combinaison lin√©aire p z1 ¬± q z2 (expression devant la saisie) */
const ex3 = {
  id:'cplx3', title:'Combinaison lin√©aire de deux complexes',
  gen(){
    const z1=randZnz(), z2=randZnz();
    const p=nz(-5,5), q=nz(-5,5);
    const t1 = termC(p, 'z_{1}');
    const expr = (q >= 0)
      ? `${t1} + ${termC(q, 'z_{2}')}`
      : `${t1} ‚àí ${termC(-q, 'z_{2}')}`;
    const r = {a: p*z1.a + q*z2.a, b: p*z1.b + q*z2.b};
    const enonce = `
      <div class="consigne"><strong>Exercice 3 :</strong></div>
      <div>Soient \\( z_{1} = ${fmtComplex(z1.a,z1.b)} \\) et \\( z_{2} = ${fmtComplex(z2.a,z2.b)} \\).</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique \\( a + bi \\).</div>

      <div style="margin-top:.35rem">\\( ${expr} \\)</div>
      <div class="ans-row" style="margin-top:.15rem">
        <span aria-hidden="true">\\( ${expr} = \\)</span>
        <input type="text" id="ans_ex3" placeholder="a + bi" style="flex:1;min-width:0">
        <span class="tick" id="ans_ex3-tick"></span>
      </div>
    `;
    return {z1,z2,p,q,r,expr,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;
    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);
    typesetAll(wrap);
    host.querySelector('#ans_ex3')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  },
  correct(host,st){
    const el=host.querySelector('#ans_ex3');
    if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    host.querySelector('#ans_ex3-tick').textContent = ok?'‚úî':'‚úò';
    return {ok,total:1};
  },
  solution(host,st){
    const a1=st.z1.a, b1=st.z1.b, a2=st.z2.a, b2=st.z2.b, p=st.p, q=st.q;
    const expr = st.expr; // d√©j√† bien form√© "pz1 ¬± qz2"

    // 2) p(‚Ä¶) ¬± q(‚Ä¶)  ‚Äî garder le signe de p devant le premier facteur
    const fac1core = (Math.abs(p) === 1 ? '' : Math.abs(p)) + parenZ_steps(st.z1);
    const fac1     = (p < 0 ? '‚àí' : '') + fac1core;   // signe de p restaur√© (sans espace)

    const op2  = (q >= 0 ? ' + ' : ' ‚àí ');            // signe entre les deux facteurs = signe de q
    const fac2 = (Math.abs(q) === 1 ? '' : Math.abs(q)) + parenZ_steps(st.z2);

    const line2 = `\\( ${expr} = ${fac1}${op2}${fac2} \\)`;

    // 3) Distribution : on ne garde que les termes non nuls, sans 1i/0
    const items = [];
    if (p*a1!==0) items.push({t:'r',v:p*a1});
    if (p*b1!==0) items.push({t:'i',v:p*b1});
    if (q*a2!==0) items.push({t:'r',v:q*a2});
    if (q*b2!==0) items.push({t:'i',v:q*b2});

    let line3Expr = '';
    if (items.length===0){
      line3Expr = '0';
    }else{
      items.forEach((it,idx)=>{
        const seg = it.t==='r' ? String(Math.abs(it.v)) : IABS(it.v);
        line3Expr += (it.v>=0 ? (idx? ' + ' : '') : (idx? ' ‚àí ' : '‚àí ')) + seg;
      });
    }
    const line3 = `\\( ${expr} = ${line3Expr} \\)`;

    // 4) R√©sultat final
    const final = `\\( ${expr} = ${fmtComplex(st.r.a, st.r.b,'a+bi')} \\)`;

    showSteps(host, [line2, line3, final]);
  },
  reset(host){
    const el=host.querySelector('#ans_ex3'); if(el) el.value='';
    const tk=host.querySelector('#ans_ex3-tick'); if(tk) tk.textContent='';
    host.querySelector('#res').textContent='';
  }
};

/* Ex.4 ‚Äî Produit z1 √ó z2 (mise en forme LaTeX) */
const ex4 = {
  id:'cplx4', title:'Produit de deux nombres complexes',
  gen(){
    const z1=randZnz(), z2=randZnz();
    const r = { a: z1.a*z2.a - z1.b*z2.b, b: z1.a*z2.b + z1.b*z2.a };
    const enonce = `
      <div class="consigne"><strong>Exercice 4 :</strong></div>
      <div>Soient \\( z_{1} = ${fmtComplex(z1.a,z1.b)} \\) et \\( z_{2} = ${fmtComplex(z2.a,z2.b)} \\).</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique \\( a + bi \\).</div>
      <div>\\( z_{1} \\times z_{2} \\)</div>
    `;
    return {z1,z2,r,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;

    // Label "z1 √ó z2 =" devant la saisie (LaTeX)
    const row=document.createElement('div'); row.className='ans-row';
    row.innerHTML = `<span aria-hidden="true">\\( z_{1} \\times z_{2} = \\)</span>
      <input type="text" id="ans" placeholder="a + bi" style="flex:1;min-width:0">
      <span class="tick" id="ans-tick"></span>`;
    S.appendChild(row);

    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);
    typesetAll(wrap);

    host.querySelector('#ans')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  },
  correct(host,st){
    const el=host.querySelector('#ans'); if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    host.querySelector('#ans-tick').textContent = ok?'‚úî':'‚úò';
    return {ok,total:1};
  },
  solution(host,st){
    const a1=st.z1.a, b1=st.z1.b, a2=st.z2.a, b2=st.z2.b;
    const t1=a1*a2, t2=a1*b2, t3=b1*a2, t4=b1*b2; // 4 termes

    const addTerm = (rhs, val, render) => {
      if(val===0) return rhs;
      const piece = render(Math.abs(val));
      if(!rhs) return (val<0 ? '‚àí ' : '') + piece;
      return rhs + (val>0 ? ' + ' : ' ‚àí ') + piece;
    };

    const L1 = `\\( z_{1} \\times z_{2} = (${fmtComplex(a1,b1,'a+bi')})(${fmtComplex(a2,b2,'a+bi')}) \\)`;

    let rhs2 = '';
    rhs2 = addTerm(rhs2, t1, v => String(v));
    rhs2 = addTerm(rhs2, t2, v => (v===1 ? 'i' : v + 'i'));
    rhs2 = addTerm(rhs2, t3, v => (v===1 ? 'i' : v + 'i'));
    rhs2 = addTerm(rhs2, t4, v => IABS2(v));
    if (!rhs2) rhs2 = '0';
    const L2 = `\\( z_{1} \\times z_{2} = ${rhs2} \\)`;

    const L3 = (t4!==0)
      ? (()=> {
          let rhs3 = '';
          rhs3 = addTerm(rhs3, t1, v => String(v));
          rhs3 = addTerm(rhs3, t2, v => (v===1 ? 'i' : v + 'i'));
          rhs3 = addTerm(rhs3, t3, v => (v===1 ? 'i' : v + 'i'));
          rhs3 = addTerm(rhs3, -t4, v => String(v)); // i^2 = ‚àí1
          return `\\( z_{1} \\times z_{2} = ${rhs3}  \\)`;
        })()
      : null;

    const L4 = `\\( z_{1} \\times z_{2} = ${fmtComplex(st.r.a, st.r.b,'a+bi')} \\)`;

    showSteps(host, L3 ? [L1, L2, L3, L4] : [L1, L2, L4]);
  },
  reset(host){
    const el=host.querySelector('#ans'); if(el) el.value='';
    const tk=host.querySelector('#ans-tick'); if(tk) tk.textContent='';
    host.querySelector('#res').textContent='';
  }
};


/* Ex.5 ‚Äî Puissance (z¬≤ ou z¬≥) avec s√©lecteur */
const ex5 = {
  id:'cplx5', title:'Puissance d‚Äôun complexe (z¬≤ ou z¬≥)',
  gen(){
    const z = randZnz();
    const pow = (typeof window !== 'undefined' && window.ZPOW) ? window.ZPOW : 2;
    const r = powResult(z, pow);
    const enonce = `
      <div class="consigne"><strong>Exercice 5 :</strong></div>
      <div>Soit \\( z = ${fmtComplex(z.a,z.b)} \\).</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique \\( a + bi \\).</div>
    `;
    return {z,pow,r,enonce};
  },
  render(host,st){
    host.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='row';
    const S=document.createElement('div'); S.className='statement'; S.innerHTML=st.enonce;

    // S√©lecteur z¬≤ / z¬≥
    const selRow=document.createElement('div'); selRow.className='ans-row';
    selRow.innerHTML = `
      <label for="pow-select" style="margin-right:6px">Puissance :</label>
      <select id="pow-select">
        <option value="2">z¬≤</option>
        <option value="3">z¬≥</option>
      </select>`;
    S.appendChild(selRow);

    // Saisie avec label dynamique "z^{n} ="
    const row=document.createElement('div'); row.className='ans-row';
    row.innerHTML = `<span aria-hidden="true" id="pow-label">\\( z^{${st.pow}} = \\)</span>
      <input type="text" id="ans" placeholder="a + bi" style="flex:1;min-width:0">
      <span class="tick" id="ans-tick"></span>`;
    S.appendChild(row);

    const res=document.createElement('div'); res.id='res';
    wrap.appendChild(S); wrap.appendChild(res); host.appendChild(wrap);

    // init s√©lecteur
    const sel = host.querySelector('#pow-select');
    sel.value = String(st.pow);

    // changement de puissance ‚Üí met √† jour l'√©tat, le label, la cible corrig√©e, et vide saisie/solution
    sel.addEventListener('change', ()=>{
      st.pow = parseInt(sel.value,10);
      window.ZPOW = st.pow;                 // m√©morise le choix
      st.r = powResult(st.z, st.pow);
      host.dataset.state = JSON.stringify(st);
      const lab = host.querySelector('#pow-label');
      if(lab) lab.innerHTML = `\\( z^{${st.pow}} = \\)`;
      const inp = host.querySelector('#ans'); if(inp) inp.value='';
      const tk  = host.querySelector('#ans-tick'); if(tk) tk.textContent='';
      const rs  = host.querySelector('#res'); if(rs) rs.textContent='';
      typesetAll(wrap);
    });

    typesetAll(wrap);

    host.querySelector('#ans')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); check(); }
    });
  },
  correct(host,st){
    const el=host.querySelector('#ans'); if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    host.querySelector('#ans-tick').textContent = ok?'‚úî':'‚úò';
    return {ok,total:1};
  },
  solution(host, st){
    const a = st.z.a, b = st.z.b;
    const zdisp = fmtComplex(a,b,'a+bi');

    const addTerm = (rhs, val, render) => {
      if(val===0) return rhs;
      const piece = render(Math.abs(val));
      if(!rhs) return (val<0 ? '‚àí ' : '') + piece;
      return rhs + (val>0 ? ' + ' : ' ‚àí ') + piece;
    };
    const biStr = (b<0 ? '‚àí ' : '') + (Math.abs(b)===1 ? 'i' : Math.abs(b)+'i');

    // z = a (b = 0)
    if (b === 0){
      if (st.pow === 2){
        const L1 = `\\( z^{2} = ${a}^{2} \\)`;
        const L2 = `\\( z^{2} = ${fmtComplex(a*a, 0, 'a+bi')} \\)`;
        showSteps(host, [L1, L2]); return;
      } else {
        const L1 = `\\( z^{3} = ${a}^{3} \\)`;
        const L2 = `\\( z^{3} = ${fmtComplex(a*a*a, 0, 'a+bi')} \\)`;
        showSteps(host, [L1, L2]); return;
      }
    }

    // z = bi (a = 0)
    if (a === 0){
      if (st.pow === 2){
        const coef2 = b*b; // >= 0
        const L1 = `\\( z^{2} = (${biStr})^{2} \\)`;
        const L2 = `\\( z^{2} = ${coef2===1 ? 'i^{2}' : coef2+'i^{2}'} \\)`;
        const L3 = `\\( z^{2} = ${fmtComplex(-coef2, 0, 'a+bi')} \\)`;
        showSteps(host, [L1, L2, L3]); return;
      } else {
        const coef3 = b*b*b; // signe de b
        const term3 = (Math.abs(coef3)===1 ? 'i^{3}' : Math.abs(coef3)+'i^{3}');
        const L1 = `\\( z^{3} = (${biStr})^{3} \\)`;
        const L2 = `\\( z^{3} = ${(coef3<0?'‚àí ':'')+term3} \\)`;
        const L3 = `\\( z^{3} = ${fmtComplex(0, -coef3, 'a+bi')} \\)`;
        showSteps(host, [L1, L2, L3]); return;
      }
    }

    // CAS G√âN√âRAL z^2
    if(st.pow===2){
      const t1=a*a, t2=2*a*b, t3=b*b;
      const L1 = `\\( z^{2} = (${zdisp})^{2} \\)`;
      let rhs2=''; rhs2=addTerm(rhs2,t1,v=>String(v)); rhs2=addTerm(rhs2,t2,v=>v===1?'i':v+'i'); rhs2=addTerm(rhs2,t3,v=> (Math.abs(v)===1?'i^{2}':v+'i^{2}'));
      const L2 = `\\( z^{2} = ${rhs2} \\)`;
      let rhs3=''; rhs3=addTerm(rhs3,t1,v=>String(v)); rhs3=addTerm(rhs3,t2,v=>v===1?'i':v+'i'); rhs3=addTerm(rhs3,-t3,v=>String(v));
      const L3 = `\\( z^{2} = ${rhs3} \\)`;
      const L4 = `\\( z^{2} = ${fmtComplex(st.r.a, st.r.b,'a+bi')} \\)`;
      showSteps(host,[L1,L2,L3,L4]); return;
    }

    // z^3 (g√©n√©ral)
    const L1 = `\\( z^{3} = (${zdisp})^{3} \\)`;
    const L2 = `\\( z^{3} = (${zdisp})^{2}(${zdisp}) \\)`;

    const s1=a*a, s2=2*a*b, s3=b*b;
    let sq=''; sq=addTerm(sq,s1,v=>String(v)); sq=addTerm(sq,s2,v=>v===1?'i':v+'i'); sq=addTerm(sq,s3,v=> (Math.abs(v)===1?'i^{2}':v+'i^{2}'));
    const L3  = `\\( z^{3} = (${sq})(${zdisp}) \\)`;

    let sqNoI2=''; sqNoI2=addTerm(sqNoI2,s1,v=>String(v)); sqNoI2=addTerm(sqNoI2,s2,v=>v===1?'i':v+'i'); sqNoI2=addTerm(sqNoI2,-s3,v=>String(v));
    const L3b = `\\( z^{3} = (${sqNoI2})(${zdisp}) \\)`;

    const SR=a*a-b*b, SI=2*a*b;
    const L4 = `\\( z^{3} = (${dispZ_steps({a:SR,b:SI})})(${zdisp}) \\)`;

    const t1=SR*a, t2=SR*b, t3=SI*a, t4=SI*b;
    let dev1=''; dev1=addTerm(dev1,t1,v=>String(v)); dev1=addTerm(dev1,t2,v=>v===1?'i':v+'i'); dev1=addTerm(dev1,t3,v=>v===1?'i':v+'i'); dev1=addTerm(dev1,t4,v=> (Math.abs(v)===1?'i^{2}':v+'i^{2}'));
    const L5 = `\\( z^{3} = ${dev1} \\)`;

    let dev2=''; dev2=addTerm(dev2,t1,v=>String(v)); dev2=addTerm(dev2,t2,v=>v===1?'i':v+'i'); dev2=addTerm(dev2,t3,v=>v===1?'i':v+'i'); dev2=addTerm(dev2,-t4,v=>String(v));
    const L6 = `\\( z^{3} = ${dev2} \\)`;

    const L7 = `\\( z^{3} = ${fmtComplex(st.r.a, st.r.b,'a+bi')} \\)`;
    showSteps(host,[L1,L2,L3,L3b,L4,L5,L6,L7]);
  },
  reset(host){
    const el=host.querySelector('#ans'); if(el) el.value='';
    const tk=host.querySelector('#ans-tick'); if(tk) tk.textContent='';
    const rs=host.querySelector('#res'); if(rs) rs.textContent='';
  }
};


/* ===== Registry & m√©canique ===== */
const REGISTRY=[ex1,ex2,ex3,ex4,ex5];
window.REGISTRY=REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(state);
  def.render(host,state);
  $('#res',host).textContent='';
  host.querySelectorAll('.tick').forEach(x=>x.textContent='');
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st = JSON.parse(host.dataset.state||'{}');
  const r = def.correct(host, st);
  scoreTot += r.total; scoreOK += r.ok?1:0; updateScore();
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st = JSON.parse(host.dataset.state||'{}');
  def.solution(host, st);
}
function resetAll(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st = JSON.parse(host.dataset.state||'{}'); def.reset(host, st);
}

/* ==== Init ==== */
whenReady(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map(e=>'<option value="'+e.id+'">'+e.title+'</option>').join('');
  sel.addEventListener('change', buildOne);
  $("#btn-new").addEventListener('click', buildOne);
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  buildOne();

  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: '1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique',
      max: 50,
      lead: '',
      leadByDefId: { cplx1:'', cplx2:'', cplx3:'', cplx4:'', cplx5:'' },
      mountAfterSelector: '.card.small'
    });
  }
});
})(); // IIFE
</script>

<script>
/* Confort mobile + clavier */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        const clone = src ? src.cloneNode(true) : null;
        if (clone) {
          clone.classList.add('btn'); clone.type='button'; clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className='btn'; fallback.type='button'; fallback.textContent=label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
