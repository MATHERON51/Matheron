<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique ‚Ä¢ Conjugu√© ‚Ä¢ Inverse ‚Ä¢ Quotient</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.55}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .row{display:grid;grid-template-columns:1fr;gap:10px}
  .statement{font-size:18px}
  .statement .consigne{opacity:.8;margin-bottom:6px}
  .equ{font-variant-numeric:tabular-nums}
  #host .inputs{display:flex;flex-direction:column;gap:8px}
  #host .ans-row{display:flex;align-items:center;gap:6px}
  #host .ans-row .tick{min-width:1.2em;text-align:center}
  #res.small{font-size:15px}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}

/* PDF-safe fractions */
.frac{
  display:inline-grid;
  grid-template-rows:auto 2px auto;
  justify-items:center;
  align-items:center;
  vertical-align:middle;
  line-height:1;
}
.frac .num,.frac .den{
  display:block;
  text-align:center;
  padding:0 .2em;
  white-space:nowrap;
}
.frac .bar{
  display:block;
  width:100%;
  height:2px;               /* barre r√©elle, pas un border ‚Äúcheveu‚Äù */
  background:currentColor;  /* m√™me couleur que le texte */
  margin:.08em 0;
}

  /* Espacement autour des formules inline dans les √©nonc√©s */
  .statement code, code.equ, .equ{
    padding:.05rem .35rem;
    border-radius:6px;
    margin:0 .35rem;
    display:inline-block;
    white-space:nowrap;
  }
  .statement code:first-child, .equ:first-child{ margin-left:0 }
  .statement code:last-child,  .equ:last-child{  margin-right:0 }
  

  @media (max-width:720px){ .controls{gap:6px} }
</style>
</head>
<body>
  <div class="header">
    <div class="controls">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>
  </div>

  <div class="wrap">
    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 1.1rem">
        <li>R√©pondre en <em>forme alg√©brique</em> : <code>a + bi</code>. Les √©critures <em>bi + a</em>, <em>a</em> (si <code>b=0</code>) et <em>bi</em> (si <code>a=0</code>) sont accept√©es.</li>
        <li><strong>Jamais</strong> <code>1i</code> / <code>‚àí1i</code> (√©crire <code>i</code> ou <code>‚àíi</code>). Pas de <code>0i</code>, <code>+0</code>, <code>0+</code>.</li>
        <li>Fractions autoris√©es : <code>p/q</code> (r√©duction automatique √† la correction, jamais ¬´ /1 ¬ª). D√©cimales : virgule ou point. Les √©critures <code>3*i</code> / <code>3√ói</code> sont normalis√©es en <code>3i</code>.</li>
        <li>La touche <kbd>Entr√©e</kbd> d√©clenche <em>V√©rifier</em>. Le score n‚Äô√©volue pas tant qu‚Äôune saisie est vide.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Scripts partag√©s -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>

<script>
/* ===== Utils (g√©n√©ral) ===== */
function $(sel, root){ return (root||document).querySelector(sel); }
function whenReady(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn, {once:true}); }
function rnd(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function nz(a,b){ let v=0; while(v===0) v=rnd(a,b); return v; }
const UMINUS = '‚àí';

function norm(s){ return String(s||'').replace(/\u2212/g,'-').replace(/,/g,'.').replace(/¬∑|√ó/g,'*').trim(); }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function reduce(p,q){ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return [p/g, q/g]; }
function fmtNum(n){ const v=Math.abs(n); const s=Number.isInteger(n)? String(v) : String(v).replace('.',','); return n<0? UMINUS+s : s; }
function fmtIcoef(b){ if(b===0) return ''; const ab=Math.abs(b); const coef = (ab===1? '' : String(ab).replace('.',',')); const sign = (b<0? ' '+UMINUS+' ' : (b>0? ' + ' : '')); return sign + coef + 'i'; }
function fmtComplex(a,b,order){
  order = order||'a+bi';
  if(order==='bi+a'){
    if(b===0) return a===0? '0' : fmtNum(a);
    if(a===0) return (b===1? 'i' : (b===-1? UMINUS+'i' : (b<0? UMINUS+String(Math.abs(b)).replace('.',',')+'i' : String(b).replace('.',',')+'i')));
    const left = (b>0 ? (b===1? 'i' : String(b).replace('.',',')+'i') : (b===-1? UMINUS+'i' : UMINUS+String(Math.abs(b)).replace('.',',')+'i'));
    const right = (a>=0 ? ' + '+fmtNum(a) : ' '+UMINUS+String(Math.abs(a)));
    return left + right;
  } else {
    if(a===0 && b===0) return '0';
    if(a===0) return (b===1? 'i' : (b===-1? UMINUS+'i' : (b<0? UMINUS+String(Math.abs(b)).replace('.',',')+'i' : String(b).replace('.',',')+'i')));
    if(b===0) return fmtNum(a);
    return fmtNum(a) + fmtIcoef(b);
  }
}
// --- Helpers "fractions exactes" ---
function gcdInt(x, y){ x=Math.trunc(Math.abs(x)); y=Math.trunc(Math.abs(y)); while(y){ const t=x%y; x=y; y=t; } return x||1; }
function fracText(num, den){
  if(den<0){ num=-num; den=-den; }
  const g = gcdInt(num, den); num/=g; den/=g;
  if(den === 1) return String(num);
  const s = (num<0 ? '-' : '');
  return s + fracOf(String(Math.abs(num)), String(den)); // <-- pile
}

/* Parsing tol√©rant de a + bi */
function parseComplex(str){
  if(!str) return null;
  let s = norm(str).replace(/\s+/g,'');
  s = s.replace(/^(?:z\s*=?\s*)/i,''); // retire "z =" √©ventuel
  s = s.replace(/\*/g,'');
  // Cas isol√©s i / -i
  if(s==='i') return {a:0,b:1};
  if(s==='-i') return {a:0,b:-1};
  const parts = s.match(/[+\-]?[^+\-]+/g);
  if(!parts) return null;
  let a=0,b=0;
  for(let t of parts){
    if(!t) continue;
    const isI = /i$/i.test(t);
    if(isI){
      t = t.replace(/i$/i,''); if(t===''||t==='+') t='1'; if(t==='-') t='-1';
      const v = Number(t); if(Number.isFinite(v)) b += v; else return null;
    } else {
      const v = Number(t); if(Number.isFinite(v)) a += v; else return null;
    }
  }
  return {a: +a, b: +b};
}
function eqComplexStr(str,A,B){ const p=parseComplex(str); return !!p && Math.abs(p.a-A)<1e-9 && Math.abs(p.b-B)<1e-9; }

/* Helpers d‚Äôaffichage pour les √©tapes */
const PM = v => v>=0 ? ' + ' : ' ‚àí ';
const IABS = v => (Math.abs(v)===1? 'i' : String(Math.abs(v)).replace('.',',')+'i');
const IABS2 = v => (Math.abs(v)===1? 'i<sup>2</sup>' : String(Math.abs(v)).replace('.',',')+'i<sup>2</sup>');
function dispZ_steps(z){ let out=''; if(z.a!==0) out+=String(z.a); if(z.b!==0){ const pref = out? PM(z.b) : (z.b<0? '‚àí ' : ''); out += pref + IABS(z.b); } return out||'0'; }

/* Fractions (affichage, jamais /1) */
function fracHTML(p,q){ p=Math.trunc(p); q=Math.trunc(q); if(q===1) return String(p); const neg=(p<0)!=(q<0); p=Math.abs(p); q=Math.abs(q); const [pp,qq]=reduce(p,q); return (neg? '<span class="frac-sign">'+UMINUS+'</span>' : '') + '<span class="frac"><span class="num">'+pp+'</span><span class="bar"></span><span class="den">'+qq+'</span></span>'; }
// Fraction g√©n√©rique (numHTML/denHTML) pour √©crire EN PILE partout
function fracOf(numHTML, denHTML){
  return '<span class="frac"><span class="num">'+numHTML+
         '</span><span class="bar"></span><span class="den">'+denHTML+
         '</span></span>';
}
// A mettre avec tes helpers (pr√®s de fracOf / fmtNum)
// x¬≤ compact : aucune espace dans (x) et exposant en <sup>
function pow2HTML(n){
  const tight = String(fmtNum(n)).replace(/[\u00A0\u202F\u2009\s]+/g,'');
  return (n<0 ? '('+tight+')' : tight) + '<sup>2</sup>';
}
// somme de termes en ignorant les z√©ros, sans fusionner pr√©matur√©ment
function joinTerms(parts){
  let out = '';
  for(const {coef, kind} of parts){
    if(!coef) continue;
    const first = out==='';
    const sign = coef<0 ? (first ? '‚àí ' : ' ‚àí ') : (first ? '' : ' + ');
    const mag  = Math.abs(coef);
    let body = '';
    if(kind==='re') body = String(mag);
    else if(kind==='i') body = (mag===1 ? 'i' : String(mag)+'i');
    else body = (mag===1 ? 'i<sup>2</sup>' : String(mag)+'i<sup>2</sup>');
    out += sign + body;
  }
  return out || '0';
}



/* Raccourcis rendu d‚Äôun bloc simple une saisie */
function renderSimple(host, enonceHTML, field){
  host.innerHTML='';
  const wrap=document.createElement('div'); wrap.className='row';
  const st=document.createElement('div'); st.className='statement'; st.innerHTML=enonceHTML||''; wrap.appendChild(st);
  const inputs=document.createElement('div'); inputs.className='inputs';
  const row=document.createElement('div'); row.className='ans-row';
  // Dans renderSimple(...)
row.innerHTML =
  (field.labelHTML
     ? field.labelHTML
     : (field.label ? `<span class="equ" aria-hidden="true">${field.label}</span>` : ''))
  + `<input type="text" id="${field.id}" placeholder="${field.placeholder||'‚Ä¶'}" style="flex:1;min-width:0">`
  + `<span class="tick" id="${field.id}-tick"></span>`;

  inputs.appendChild(row); wrap.appendChild(inputs);
  const res=document.createElement('div'); res.id='res'; wrap.appendChild(res); host.appendChild(wrap);
  $('#'+field.id,host)?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); check(); } });
}
function setTick(host,id,val){ const el=$('#'+id+'-tick',host); if(el) el.textContent = val||''; }
function showSteps(host, steps){ const uniq=[]; for(const L of steps){ if(!uniq.length || uniq[uniq.length-1]!==L) uniq.push(L); } $('#res',host).innerHTML = '<div class="steps">'+uniq.map(t=>'<div class="step">'+t+'</div>').join('')+'</div>'; $('#res',host).className='small'; }

/* Random z util */
function randZ(){ return {a:rnd(-9,9), b:rnd(-9,9)}; }
function randZnz(){ let z=randZ(); while(z.a===0 && z.b===0) z=randZ(); return z; }

// Ajoute un terme k¬∑(unit√©) √† une cha√Æne alg√©brique (sans "1z", sans 0)
function _appendTerm(out, k, unit){
  if (!k) return out;
  const first = (out === '');
  const sign  = k < 0 ? (first ? '‚àí ' : ' ‚àí ') : (first ? '' : ' + ');
  const m = Math.abs(k);
  let body = '';
  if (unit === 'z')   body = (m===1 ? 'z'  : m+'z');
  else if (unit === 'iz') body = (m===1 ? 'iz' : m+'iz');
  else if (unit === 'i')  body = (m===1 ? 'i'  : m+'i');
  else if (unit === 'i2') body = (m===1 ? 'i<sup>2</sup>' : m+'i<sup>2</sup>');
  else body = String(m);
  return out + sign + body;
}

// D√©veloppe (a+bi)(z+l)  -> "az + biz + al + bli"
function expand_ab_times_z_plus_l(a,b,l){
  let rhs = '';
  rhs = _appendTerm(rhs, a, 'z');      // az
  rhs = _appendTerm(rhs, b, 'iz');     // + biz
  rhs = _appendTerm(rhs, a*l, '');     // + al
  rhs = _appendTerm(rhs, b*l, 'i');    // + bl¬∑i
  return rhs || '0';
}

// D√©veloppe (a+bi)(z+li) -> "az + biz + ali + bli¬≤"
function expand_ab_times_z_plus_li(a,b,l, withI2=true){
  let rhs = '';
  rhs = _appendTerm(rhs, a, 'z');                 // az
  rhs = _appendTerm(rhs, b, 'iz');                // + biz
  rhs = _appendTerm(rhs, a*l, 'i');               // + al¬∑i
  rhs = _appendTerm(rhs, b*l, withI2 ? 'i2' : ''); // + bl¬∑i¬≤ (ou remplac√© ensuite)
  return rhs || '0';
}



/* ===== Exercices ===== */

/* Ex.1 ‚Äî Conjugu√© */
const ex1 = {
  id:'cplx1', title:'Conjugu√© d‚Äôun nombre complexe',
  gen(){
    const z = randZnz();
    const order = Math.random()<0.5 ? 'a+bi' : 'bi+a';
    const enonce = `
      <div class="consigne"><strong>Exercice 1 : Conjugu√©</strong></div>
      <div>D√©terminer le conjugu√© du nombre complexe suivant :</div>
      <div><code class="equ">z = ${fmtComplex(z.a,z.b,order)}</code></div>
    `;
    return {z, enonce};
  },
  render(host,st){
    renderSimple(host, st.enonce, {id:'ans', label:'<code>\u0305z=</code>', placeholder:'a ‚àí bi'});
  },
  correct(host,st){
    const el=host.querySelector('#ans'); if(!el||!el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.z.a, -st.z.b);
    setTick(host,'ans', ok?'‚úî':'‚úò');
    return {ok,total:1};
  },
  solution(host,st){
    const a=st.z.a, b=st.z.b;
    const L1 = `Rappel : si <code>z = a + bi</code> alors <code>\u0305z = a ‚àí bi</code>.`;
    const L2 = `Ici : <code>z = ${fmtComplex(a,b,'a+bi')}</code> donc <code>\u0305z = ${fmtComplex(a,-b,'a+bi')}</code>.`;
    showSteps(host,[L1,L2]);
  },
  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

/* Ex.2 ‚Äî Inverse dans C */
const ex2 = {
  id:'cplx2', title:'Inverse d‚Äôun nombre complexe',
  gen(){
    let z=randZnz(); // √©viter 0
    const enonce = `
      <div class="consigne"><strong>Exercice 2 : Inverse dans C</strong></div>
      <div>Soit le nombre complexe <code class="equ">z = ${fmtComplex(z.a,z.b,'a+bi')}</code>.</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique <code>a + bi</code>.</div>
<div style="margin-top:.25rem"><code class="equ">${fracOf('1','z')}</code></div>
    `;
    // cible
    const den = z.a*z.a + z.b*z.b; // > 0
    const A = z.a/den, B = -z.b/den; // a/den + (-b/den)i
    return {z, den, r:{a:A, b:B}, enonce};
  },
  render(host,st){ renderSimple(host, st.enonce, {
  id:'ans',
  labelHTML:'<span class="equ">'+fracOf('1','z')+' =</span>',
  placeholder:'a + bi'
});},

  correct(host,st){ const el=host.querySelector('#ans'); if(!el||!el.value.trim()) return {ok:false,total:0}; const ok=eqComplexStr(el.value, st.r.a, st.r.b); setTick(host,'ans', ok?'‚úî':'‚úò'); return {ok,total:1}; },
  solution(host,st){
  const a = st.z.a, b = st.z.b, D = a*a + b*b;

// cas particuliers ‚Äî r√©sultat SANS d√©cimales + √©tapes d√©taill√©es
if (b === 0) {
  // z = a (r√©el)
  const L0 = `<code>z = ${fmtComplex(a,0)}</code>`;
  // (on peut passer par le conjugu√©, mais ici c'est direct)
  const L1 = `<code>${fracOf('1','z')} = ${fracOf('1', String(a))}</code>`;
  const L2 = `<code>${fracOf('1','z')}= ${fracText(1, a)}</code>`;   // forme alg√©brique, jamais de d√©cimales

  showSteps(host, [L0, L1, L2]);
  return;
}
function coefI(b, sup2=false){
  const a = Math.abs(b);
  const s = b < 0 ? '-' : '';
  const k = (a === 1 ? '' : a);               // pas de ¬´ 1 ¬ª devant i
  return `${s}${k}i${sup2 ? '<sup>2</sup>' : ''}`;
}
function parensIfNeg(txt, b){ return b < 0 ? `(${txt})` : txt; }

if (a === 0 && b !== 0) {
  const den0  = coefI(b);                 // ex: "2i", "-i"
  const den0x = parensIfNeg(den0, b);     // parenth√®ses si b<0 pour l'√©tape "√ó i"

  const L1 = `<code>${fracOf('1','z')} = ${fracOf('1', den0)}</code>`;
  const L2 = `<code>${fracOf('1','z')} = ${fracOf('1 √ó i', `${den0x} √ó i`)}</code>`;
  const L3 = `<code>${fracOf('1','z')} = ${fracOf('i', coefI(b, true))}</code>`; // .../(b i^2)
  const L4 = `<code>${fracOf('1','z')} = ${fracOf('i', String(-b))}</code>`;     // i/(-b)
  const mag  = Math.abs(b);
  const sign = (b > 0 ? '-' : '+');
  const last = (mag === 1 ? 'i' : `${fracOf('1', String(mag))} i`);
  const L5 = `<code>${fracOf('1','z')} = ${sign} ${last}</code>`;                // forme alg√©brique

  showSteps(host, [L1, L2, L3, L4, L5]);
  return;
}




  const L1  = `On multiplie par le conjugu√© du d√©nominateur au num√©rateur et au d√©nominateur :`;
  const L1b = `<code><span class="equ">${fracOf('1','z')}</span> = ${fracOf('1', fmtComplex(a,b))} √ó ${fracOf(fmtComplex(a,-b), fmtComplex(a,-b))}</code>.`;

  // helper local pour √©crire x¬≤ avec parenth√®ses si x<0
const pow2 = n => (n < 0 ? `(${fmtNum(n)})¬≤` : `${fmtNum(n)}¬≤`);
const denExpandedHTML = `${pow2HTML(a)} + ${pow2HTML(b)}`;
const L1c = `<code><span class="equ">${fracOf('1','z')}</span> =
             ${fracOf(fmtComplex(a,-b,'a+bi'), denExpandedHTML)}</code>`;


  const L2  = `<code><span class="equ">${fracOf('1','z')}</span> = ${fracOf(fmtComplex(a,-b), String(D))}</code> (car <code>a¬≤ + b¬≤ = ${D}</code>).`;

  const [ra,rb] = reduce(a,D), [ia,ib] = reduce(-b,D);
  const L3  = `<code><span class="equ">${fracOf('1','z')}</span> = ${fracHTML(ra,rb)} ${(-b>=0?' + ':' ‚àí ')} ${fracHTML(Math.abs(ia),ib)} i</code>.`;

  showSteps(host,[L1, L1b,L1c,L2, L3]);
}
,
  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

/* Ex.3 ‚Äî Quotient z1 / z2 */
const ex3 = {
  id:'cplx3', title:'Quotient de deux nombres complexes',
  gen(){
    const z1 = randZnz(); 
let z2 = randZnz();
// Interdire z2 entier (b = 0)
while (z2.b === 0) z2 = randZnz();

    // √©viter division par 0 et z2 pur imaginaire avec tr√®s grand d√©nominateur inutile
    const enonce = `
      <div class="consigne"><strong>Exercice 3 : Quotient dans C</strong></div>
      <div>Soient <code class="equ">z<sub>1</sub> = ${fmtComplex(z1.a,z1.b)}</code> et <code class="equ">z<sub>2</sub> = ${fmtComplex(z2.a,z2.b)}</code>.</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique <code>a + bi</code>.</div>
<div style="margin-top:.25rem"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code></div>
    `;
    const den = z2.a*z2.a + z2.b*z2.b;
    const A = (z1.a*z2.a + z1.b*z2.b)/den;
    const B = (z1.b*z2.a - z1.a*z2.b)/den;
    return {z1,z2,den,r:{a:A,b:B}, enonce};
  },
  render(host,st){ renderSimple(host, st.enonce, {
  id:'ans',
  labelHTML:'<span class="equ">'+fracOf('z<sub>1</sub>','z<sub>2</sub>')+' =</span>',
  placeholder:'a + bi'
});
 },
  correct(host,st){ const el=host.querySelector('#ans'); if(!el||!el.value.trim()) return {ok:false,total:0}; const ok=eqComplexStr(el.value, st.r.a, st.r.b); setTick(host,'ans', ok?'‚úî':'‚úò'); return {ok,total:1}; },
  solution(host,st){
  const a1 = st.z1.a, b1 = st.z1.b, a2 = st.z2.a, b2 = st.z2.b;
  const D = a2*a2 + b2*b2;

  // x¬≤ compact sans espace dans (x)
  const pow2 = n => {
    const tight = String(fmtNum(n)).replace(/[\u00A0\u202F\u2009\s]+/g,'');
    return (n<0 ? '('+tight+')' : tight) + '<sup>2</sup>';
  };
  const denPow = `${pow2(a2)} + ${pow2(b2)}`;

  // √©crit une somme en ignorant les termes nuls (sans fusionner les termes i)
  function joinTerms(parts){
    let out = '';
    for(const {coef, kind} of parts){
      if(!coef) continue;
      const first = out==='';
      const sign = coef<0 ? (first ? '‚àí ' : ' ‚àí ') : (first ? '' : ' + ');
      const mag = Math.abs(coef);
      let body = '';
      if(kind==='re') body = String(mag);
      else if(kind==='i') body = (mag===1 ? 'i' : String(mag)+'i');
      else body = (mag===1 ? 'i<sup>2</sup>' : String(mag)+'i<sup>2</sup>');
      out += sign + body;
    }
    return out || '0';
  }

  // 1) fraction de d√©part
  const S0 = `<code class="equ"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code> = ${fracOf(
               fmtComplex(a1,b1,'a+bi'), fmtComplex(a2,b2,'a+bi'))}</code>`;

  // 2) multiplication par le conjugu√©
  const S1 = `<code class="equ"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code> = ${fracOf(
               '('+fmtComplex(a1,b1,'a+bi')+')('+
               fmtComplex(a2,-b2,'a+bi')+')', denPow)}</code>`;

  // 3) d√©veloppement (FOIL) avec i¬≤ explicite
  const t1 = a1*a2;           // r√©el
  const t2 = a1*(-b2);        // coef de i
  const t3 = b1*a2;           // coef de i
  const t4 = b1*(-b2);        // coef de i¬≤
  const numFOIL = joinTerms([
    {coef:t1, kind:'re'},
    {coef:t2, kind:'i'},
    {coef:t3, kind:'i'},
    {coef:t4, kind:'i2'}
  ]);
  const S2 = `<code class="equ"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code>= ${fracOf(numFOIL, String(D))}</code>`;

  // 3a) << √âTAPE AJOUT√âE >> remplacer i¬≤ par ‚àí1 mais SANS regrouper encore
  // => t1 + t2 i + t3 i - t4
  const numAfterI2 = joinTerms([
    {coef:t1,  kind:'re'},
    {coef:t2,  kind:'i'},
    {coef:t3,  kind:'i'},
    {coef:-t4, kind:'re'}
  ]);
  const S3a = `<code class="equ"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code> = ${fracOf(numAfterI2, String(D))}</code>`;

  // 4) regrouper r√©el/imag au num√©rateur
  const R = t1 - t4;                 // a1*a2 + b1*b2
  const I = t2 + t3;                 // -a1*b2 + b1*a2
  const numRI = (I!==0 ? joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}])
                       : String(fmtNum(R)));
  const S4 = `<code class="equ"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code> = ${fracOf(numRI, String(D))}</code>`;

  // 5) s√©parer en deux fractions (sans afficher de 0)
  const parts = [];
  if (R!==0){
    const [r1x,r1y] = reduce(R, D);
    parts.push(fracHTML(r1x, r1y));
  }
  if (I!==0){
    const [r2x,r2y] = reduce(I, D);
    const frag = fracHTML(Math.abs(r2x), r2y) + ' i';
    parts.push((I>0 && parts.length? ' + ' : (I<0 && parts.length? ' ‚àí ' : (I<0? '‚àí ' : ''))) + frag);
  }
  const S5 = `<code class="equ"><code class="equ">${fracOf('z<sub>1</sub>','z<sub>2</sub>')}</code> = ${parts.join('') || '0'}</code>`;

  showSteps(host,[S0,S1,S2,S3a,S4,S5]);
},
  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

/* Petites op√©rations complexes (pour les √©quations) */
const C = (a,b)=>({a:a,b:b});
const addC=(z,w)=>C(z.a+w.a, z.b+w.b);
const subC=(z,w)=>C(z.a-w.a, z.b-w.b);
const mulC=(z,w)=>C(z.a*w.a - z.b*w.b, z.a*w.b + z.b*w.a);
const conjC=z=>C(z.a,-z.b);
const divC=(z,w)=>{ const D=w.a*w.a+w.b*w.b; return C((z.a*w.a+z.b*w.b)/D, (z.b*w.a - z.a*w.b)/D); };

/* ===== Ex.4 ‚Äî R√©soudre une √©quation (s√©lecteur de mod√®le) ===== */
const ex4 = {
  id:'cplx4',
  title:'R√©soudre une √©quation (mod√®les)',
  _lastMode: 'M1',
  gen(mode){
    const M = mode || this._lastMode || 'M1';
    this._lastMode = M;

    if (M==='M1'){ // (a+bi)z + (u+vi) = 0
      const a=nz(-4,4), b=nz(-4,4);
      let u=rnd(-6,6), v=rnd(-6,6);
      if(u===0 && v===0){ v = 1; }  // √©viter trivial
      const A = {a,b}, U = {a:u,b:v};
      const enonce = `
        <div style="margin-bottom:.35rem">
          <label><small><b>Mod√®le :</b></small>
            <select id="ex4-model">
              <option value="M1" selected>Mod√®le 1 ‚Äî (a+bi)z + (u+vi) = 0</option>
              <option value="M2">Mod√®le 2 ‚Äî pz ‚àí qi = ‚àíiz + (r + si)</option>
            </select>
          </label>
        </div>
        <div>R√©soudre dans ‚ÑÇ l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
        <div style="margin-top:.25rem"><code class="equ">(${fmtComplex(a,b)})z ${u||v? ' + '+fmtComplex(u,v): ''} = 0</code></div>
      `;
      // solution attendue : z = ‚àí(u+vi)/(a+bi)
      const D = a*a + b*b;
      const r = { a:(-u*a - (-v)*(-b))/D, b:((-v)*a - (-u)*(-b))/D }; // = divC(-U, A)
      return {mode:'M1', enonce, A, U, r};
    }

    // M2 : pz ‚àí qi = ‚àíiz + (r + si)
    const p=nz(-9,9), q=Math.max(1, Math.abs(rnd(-6,6))); // q ‚â† 0
    const r=rnd(-9,9), s=rnd(-9,9);
    const enonce = `
      <div style="margin-bottom:.35rem">
        <label><small><b>Mod√®le :</b></small>
          <select id="ex4-model">
            <option value="M1">Mod√®le 1 ‚Äî (a+bi)z + (u+vi) = 0</option>
            <option value="M2" selected>Mod√®le 2 ‚Äî pz ‚àí qi = ‚àíiz + (r + si)</option>
          </select>
        </label>
      </div>
      <div>R√©soudre dans ‚ÑÇ l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
      <div style="margin-top:.25rem"><code class="equ">${p}z ‚àí ${q}i = ‚àíiz + ${fmtComplex(r,s)}</code></div>
    `;
    // On am√®ne : pz + iz = r + (q+s)i  ‚áí  z = (r + (q+s)i) / (p + i)
    const D = p*p + 1;
    const R = r, S = q + s;
    const rsol = { a:(R*p + S*1)/D, b:(S*p - R*1)/D };
    return {mode:'M2', enonce, p, q, r, s, R, S, rsol};
  },

  render(host, st){
    // enonce + champ de saisie
    renderSimple(host, st.enonce, {id:'ans', label:'z =', placeholder:'a + bi'});
    // brancher le selecteur dans le bloc
    const sel = host.querySelector('#ex4-model');
    if (sel){
      sel.value = st.mode;
      sel.addEventListener('change', () => {
        const next = ex4.gen(sel.value);
        host.dataset.active = ex4.id;
        host.dataset.state  = JSON.stringify(next);
        ex4.render(host, next);
      });
    }
  },

  correct(host, st){
    const el=host.querySelector('#ans');
    if(!el||!el.value.trim()) return {ok:false,total:0};
    const ok = st.mode==='M1'
      ? eqComplexStr(el.value,
                     (-(st.U.a)*st.A.a - (-(st.U.b))*(-st.A.b?st.A.b:st.A.b))/ (st.A.a*st.A.a+st.A.b*st.A.b), // not used; better compare using divC? Simplify: reuse div result:
                     undefined)
      : false; // we won‚Äôt use this; checking below
    // calcul pr√©cis attendu (utilisons ce qui a √©t√© stock√©)
    let A=false,B=false;
    if (st.mode==='M1'){
      const a=st.A.a,b=st.A.b,u=st.U.a,v=st.U.b,D=a*a+b*b;
      const ZA = ( -u*a - (-v)*(-b) )/D;
      const ZB = ( (-v)*a - (-u)*(-b) )/D;
      A = eqComplexStr(el.value, ZA, ZB);
    } else {
      A = eqComplexStr(el.value, st.rsol.a, st.rsol.b);
    }
    setTick(host,'ans', A?'‚úî':'‚úò');
    return {ok:A,total:1};
  },

  solution(host, st){
    if (st.mode==='M1'){
      const a=st.A.a, b=st.A.b, u=st.U.a, v=st.U.b;
      const D = a*a + b*b;

      // √âquation de d√©part et isolement
      const L0 = `<code class="equ">(${fmtComplex(a,b)})z ${u||v? ' + '+fmtComplex(u,v): ''} = 0</code>`;
      const L1 = `<code class="equ">(${fmtComplex(a,b)})z = ${fmtComplex(-u,-v)}</code>`;

      // z = (num)/(den)
      const L2 = `<code class="equ">z = ${fracOf(fmtComplex(-u,-v,'a+bi'), fmtComplex(a,b,'a+bi'))}</code>`;

      // Produit par le conjugu√©
      const L3 = `<code class="equ">z = ${fracOf(
                    '('+fmtComplex(-u,-v,'a+bi')+')('+
                    fmtComplex(a,-b,'a+bi')+')',
                    '('+fmtComplex(a,b,'a+bi')+')('+
                    fmtComplex(a,-b,'a+bi')+')')}</code>`;

      // D√©veloppement (num√©rateur) + d√©nominateur a¬≤+b¬≤
      const t1 = (-u)*a;
      const t2 = (-u)*(-b);   // i
      const t3 = (-v)*a;      // i
      const t4 = (-v)*(-b);   // i¬≤
      const numFOIL = joinTerms([
        {coef:t1, kind:'re'},
        {coef:t2, kind:'i'},
        {coef:t3, kind:'i'},
        {coef:t4, kind:'i2'}
      ]);
      const denPow = `${pow2HTML(a)} + ${pow2HTML(b)}`;
      const L4 = `<code class="equ">z = ${fracOf(numFOIL, denPow)}</code>`;

      // Remplacer i¬≤ = ‚àí1 (sans regrouper) puis calculer D
      const numAfterI2 = joinTerms([
        {coef:t1,  kind:'re'},
        {coef:t2,  kind:'i'},
        {coef:t3,  kind:'i'},
        {coef:-t4, kind:'re'}
      ]);
      const L5 = `<code class="equ">z = ${fracOf(numAfterI2, String(D))}</code>`;

      // Regrouper num√©rateur, puis s√©parer
      const R = t1 - t4;        // a*(-u) + b*v
      const I = t2 + t3;        // -a*v + b*(-u)? (coh√©rent avec calculs ci-dessus)
      const numRI = joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]);
      const L6 = `<code class="equ">z = ${fracOf(numRI, String(D))}</code>`;

      const parts = [];
      if (R!==0){ const [x,y]=reduce(R,D); parts.push(fracHTML(x,y)); }
      if (I!==0){
        const [x,y]=reduce(I,D);
        const frag = fracHTML(Math.abs(x),y)+' i';
        parts.push((I>0 && parts.length? ' + ' : (I<0 && parts.length? ' ‚àí ' : (I<0? '‚àí ' : ''))) + frag);
      }
      const L7 = `<code class="equ">z = ${parts.join('') || '0'}</code>`;
      showSteps(host, [L0,L1,L2,L3,L4,L5,L6,L7]);
      return;
    }

    // ===== Mod√®le 2 : pz ‚àí qi = ‚àíiz + (r + si) =====
    const p=st.p, q=st.q, r=st.r, s=st.s;
    const R = st.R, S = st.S;           // R=r, S=q+s
    const D = p*p + 1;

    const M0 = `<code class="equ">${p}z ‚àí ${q}i = ‚àíiz + ${fmtComplex(r,s)}</code>`;
    const M1 = `<code class="equ">${p}z + iz = ${fmtComplex(r, q+s)}</code>`;
    const M2 = `<code class="equ">z(${p}+i) = ${fmtComplex(r, q+s)}</code>`;
    const M3 = `<code class="equ">z = ${fracOf(fmtComplex(r, q+s,'a+bi'), fmtComplex(p,1,'a+bi'))}</code>`;
    const M4 = `<code class="equ">z = ${fracOf(
                 '('+fmtComplex(r,q+s,'a+bi')+')('+
                 fmtComplex(p,-1,'a+bi')+')',
                 '('+fmtComplex(p,1,'a+bi')+')('+
                 fmtComplex(p,-1,'a+bi')+')')}</code>`;

    // D√©veloppement num√©rateur + d√©nominateur p¬≤ + 1¬≤
    const t1 = r*p;            // r√©el
    const t2 = r*(-1);         // i
    const t3 = (q+s)*p;        // i
    const t4 = (q+s)*(-1);     // i¬≤
    const numFOIL = joinTerms([
      {coef:t1, kind:'re'},
      {coef:t2, kind:'i'},
      {coef:t3, kind:'i'},
      {coef:t4, kind:'i2'}
    ]);
    const denPow = `${pow2HTML(p)} + ${pow2HTML(1)}`; // 1¬≤
    const M5 = `<code class="equ">z = ${fracOf(numFOIL, denPow)}</code>`;

    // Remplacer i¬≤ = ‚àí1 (sans regrouper), puis D
    const numAfterI2 = joinTerms([
      {coef:t1,  kind:'re'},
      {coef:t2,  kind:'i'},
      {coef:t3,  kind:'i'},
      {coef:-t4, kind:'re'}
    ]);
    const M6 = `<code class="equ">z = ${fracOf(numAfterI2, String(D))}</code>`;

    // Regrouper puis s√©parer
    const RR = t1 - t4;        // r*p + (q+s)
    const II = t2 + t3;        // -r + (q+s)*p
    const numRI = joinTerms([{coef:RR,kind:'re'},{coef:II,kind:'i'}]);
    const M7 = `<code class="equ">z = ${fracOf(numRI, String(D))}</code>`;

    const parts = [];
    if (RR!==0){ const [x,y]=reduce(RR,D); parts.push(fracHTML(x,y)); }
    if (II!==0){
      const [x,y]=reduce(II,D);
      const frag = fracHTML(Math.abs(x),y)+' i';
      parts.push((II>0 && parts.length? ' + ' : (II<0 && parts.length? ' ‚àí ' : (II<0? '‚àí ' : ''))) + frag);
    }
    const M8 = `<code class="equ">z = ${parts.join('') || '0'}</code>`;

    showSteps(host,[M0,M1,M2,M3,M4,M5,M6,M7,M8]);
  },

  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

// ===================== Ex.5 ‚Äî √âquations fractionnelles (3 mod√®les al√©atoires) =====================
const ex5 = {
  id:'cplx5',
  title:'R√©soudre une √©quation (fractionnelle ‚Äî mod√®les)',
  _lastMode:'M1',

  // -------------------- tirages --------------------
  gen(mode){
  
  // a,b entiers non nuls
function pickABNonZero(){
  let a = rnd(-3,3), b = rnd(-3,3);
  while (a===0 || b===0) { a = rnd(-3,3); b = rnd(-3,3); }
  return {a,b};
}
// k,l entiers distincts
function pickKLDistinct(){
  let k = rnd(-5,5), l = rnd(-5,5);
  while (l === k) l = rnd(-5,5);
  return {k,l};
}

    const M = mode || this._lastMode || 'M1';
    this._lastMode = M;

    const kInt  = ()=> rnd(-5,5);
    const lInt  = ()=> rnd(-5,5);
   

    if (M==='M1'){ // (z+k)/(z+l) = a+bi
      const {k,l} = pickKLDistinct(); const w = pickABNonZero();
      const top = 'z ' + (k? (k>0?'+ '+k:'‚àí '+Math.abs(k)) : '');
      const bot = 'z ' + (l? (l>0?'+ '+l:'‚àí '+Math.abs(l)) : '');
      const enonce = `
        <div class="consigne"><strong>Exercice 5 : R√©soudre une √©quation dans C</strong></div>
        <div style="margin-bottom:.35rem">
          <label><small><b>Mod√®le :</b></small>
            <select id="ex5-model">
              <option value="M1" selected>Mod√®le 1 ‚Äî (z+k)/(z+l) = a + bi</option>
              <option value="M2">Mod√®le 2 ‚Äî (z+ki)/(z+l) = a + bi</option>
              <option value="M3">Mod√®le 3 ‚Äî (z+ki)/(z+li) = a + bi</option>
            </select>
          </label>
        </div>
        <div>R√©soudre dans C l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
        <div style="margin-top:.25rem"><code class="equ">${fracOf(top, bot)} = ${fmtComplex(w.a,w.b)}</code></div>
      `;
      // z = ( (a*l - k) + (b*l)i ) / (1 - a - bi)
      const r = divC( C(w.a*l - k, w.b*l), C(1-w.a, -w.b) );
      return {mode:'M1', enonce, k, l, w, r};
    }

    if (M==='M2'){ // (z+ki)/(z+l) = a+bi
      const k = rnd(-5,5), l = rnd(-5,5); const w = pickABNonZero();
      const top = 'z ' + (k? (k>0?'+ ':'‚àí ') + (Math.abs(k)===1?'i':Math.abs(k)+'i') : '');
      const bot = 'z ' + (l? (l>0?'+ '+l:'‚àí '+Math.abs(l)) : '');
      const enonce = `
        <div class="consigne"><strong>Exercice 5 : R√©soudre une √©quation dans C</strong></div>
        <div style="margin-bottom:.35rem">
          <label><small><b>Mod√®le :</b></small>
            <select id="ex5-model">
              <option value="M1">Mod√®le 1 ‚Äî (z+k)/(z+l) = a + bi</option>
              <option value="M2" selected>Mod√®le 2 ‚Äî (z+ki)/(z+l) = a + bi</option>
              <option value="M3">Mod√®le 3 ‚Äî (z+ki)/(z+li) = a + bi</option>
            </select>
          </label>
        </div>
        <div>R√©soudre dans C l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
        <div style="margin-top:.25rem"><code class="equ">${fracOf(top, bot)} = ${fmtComplex(w.a,w.b)}</code></div>
      `;
      // z = ( (a*l) + (b*l - k)i ) / (1 - a - bi)
      const r = divC( C(w.a*l, w.b*l - k), C(1-w.a, -w.b) );
      return {mode:'M2', enonce, k, l, w, r};
    }

    // M3 : (z+ki)/(z+li) = a+bi
    const {k,l} = pickKLDistinct(); const w = pickABNonZero();
    const top = 'z ' + (k? (k>0?'+ ':'‚àí ') + (Math.abs(k)===1?'i':Math.abs(k)+'i') : '');
    const bot = 'z ' + (l? (l>0?'+ ':'‚àí ') + (Math.abs(l)===1?'i':Math.abs(l)+'i') : '');
    const enonce = `
      <div class="consigne"><strong>Exercice 5 : R√©soudre une √©quation dans C</strong></div>
      <div style="margin-bottom:.35rem">
        <label><small><b>Mod√®le :</b></small>
          <select id="ex5-model">
            <option value="M1">Mod√®le 1 ‚Äî (z+k)/(z+l) = a + bi</option>
            <option value="M2">Mod√®le 2 ‚Äî (z+ki)/(z+l) = a + bi</option>
            <option value="M3" selected>Mod√®le 3 ‚Äî (z+ki)/(z+li) = a + bi</option>
          </select>
        </label>
      </div>
      <div>R√©soudre dans C l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
      <div style="margin-top:.25rem"><code class="equ">${fracOf(top, bot)} = ${fmtComplex(w.a,w.b)}</code></div>
    `;
    // RHS apr√®s i¬≤ : (‚àíb l) + (a l ‚àí k)i ; z = RHS / (1 ‚àí a ‚àí bi)
    const r = divC( C(-w.b*l, w.a*l - k), C(1-w.a, -w.b) );
    return {mode:'M3', enonce, k, l, w, r};
  },

  render(host, st){
    renderSimple(host, st.enonce, {id:'ans', label:'z =', placeholder:'a + bi'});
    const sel = host.querySelector('#ex5-model');
    if (sel){
      sel.value = st.mode;
      sel.addEventListener('change', ()=>{
        const next = ex5.gen(sel.value);
        host.dataset.active = ex5.id;
        host.dataset.state  = JSON.stringify(next);
        ex5.render(host, next);
      });
    }
  },

  correct(host, st){
    const el = host.querySelector('#ans');
    if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    setTick(host, 'ans', ok ? '‚úî' : '‚úò');
    return {ok,total:1};
  },

  // -------------------- solution pas-√†-pas (styles des screens) --------------------
 solution(host, st){
  // -------- Helpers d'affichage --------
  const pow2HTML = n => { const t=String(fmtNum(n)).replace(/[\u00A0\u202F\u2009\s]+/g,''); return (n<0?`(${t})`:t)+'<sup>2</sup>'; };
  const zPlusReal = t => t ? ('z ' + (t>0?'+ '+t:'‚àí '+Math.abs(t))) : 'z';
  const zPlusImag = t => t ? ('z ' + (t>0?'+ ':'‚àí ') + (Math.abs(t)===1?'i':Math.abs(t)+'i')) : 'z';

  // ajoute k¬∑(unit√©) √† une somme (jamais "1z", ni 0)
  function addTerm(s,k,unit){
    if(!k) return s;
    const first = (s==='');
    const sign  = k<0 ? (first?'‚àí ':' ‚àí ') : (first?'':' + ');
    const m = Math.abs(k);
    let body='';
    if(unit==='z')   body = (m===1? 'z' : m+'z');
    else if(unit==='iz') body = (m===1? 'iz': m+'iz');
    else if(unit==='i')  body = (m===1? 'i' : m+'i');
    else if(unit==='i2') body = (m===1? 'i<sup>2</sup>' : m+'i<sup>2</sup>');
    else body = String(m);
    return s + sign + body;
  }
  // (a+bi)(z+li) apr√®s remplacement i¬≤ = ‚àí1 : az + ali + biz ‚àí bl
function dev_z_plus_li_noI2(a,b,l){
  let s='';
  s = addTerm(s, a,   'z');   // az
  s = addTerm(s, a*l, 'i');   // + ali
  s = addTerm(s, b,   'iz');  // + biz
  s = addTerm(s, -b*l,'');    // ‚àí bl   (car bli¬≤ -> bl√ó(‚àí1))
  return s || '0';
}
  // (1‚àía)z ‚àí biz (sans factoriser)
  function leftZCombo(a,b){ let s=''; s=addTerm(s,1-a,'z'); s=addTerm(s,-b,'iz'); return s||'0'; }
  // z((1‚àía) ‚àí bi)
  function leftZFact(a,b){ let inside=''; inside=addTerm(inside,1-a,''); inside=addTerm(inside,-b,'i'); return `z(${inside})`; }
  // somme g√©n√©rique (r√©el / imag / i¬≤) sans fusionner
  const joinTerms = parts => { let out=''; for(const {coef,kind} of parts){ if(!coef) continue; out = addTerm(out, coef, (kind==='re'?'':kind)); } return out || '0'; };
  // finale a+bi √† partir de (R/D, I/D)
  function finalAplusBi(R,I,D){ const p=[]; if(R){ const [rx,ry]=reduce(R,D); p.push(fracHTML(rx,ry)); } if(I){ const [ix,iy]=reduce(I,D); p.push((I>0&&p.length?' + ':(I<0&&p.length?' ‚àí ':(I<0?'‚àí ':'')))+fracHTML(Math.abs(ix),iy)+' i'); } return p.join('')||'0'; }
  // d√©veloppements dans l'ordre des screens
  const dev_z_plus_l  = (a,b,l)=>{ let s=''; s=addTerm(s,a,'z'); s=addTerm(s,a*l,''); s=addTerm(s,b,'iz'); s=addTerm(s,b*l,'i'); return s||'0'; };
  const dev_z_plus_li = (a,b,l,withI2=true)=>{ let s=''; s=addTerm(s,a,'z'); s=addTerm(s,a*l,'i'); s=addTerm(s,b,'iz'); s=addTerm(s,b*l,withI2?'i2':''); return s||'0'; };

  const denCoefs = (a,b)=>({c1:1-a, c2:-b}); // (1-a) + (-b)i
  const denStr   = (c1,c2)=> joinTerms([{coef:c1,kind:'re'},{coef:c2,kind:'i'}]);
  const conjStr  = (c1,c2)=> joinTerms([{coef:c1,kind:'re'},{coef:-c2,kind:'i'}]);

  // -------- mod√®le 1 : (z+k)/(z+l) = a+bi --------
  const showM1 = ()=>{
    const {k,l,w:{a,b}} = st; const {c1,c2}=denCoefs(a,b);
    const H  = `<div><em>Pour tout</em> <code>z ‚â† ${fmtNum(-l)}</code>, on a :</div>`;
    const L1 = `<code class="equ">${fracOf(zPlusReal(k), zPlusReal(l))} = ${fmtComplex(a,b)}</code>`;
    const L2 = `<code class="equ">z ${k?(k>0?'+ '+k:'‚àí '+Math.abs(k)):''} = (${fmtComplex(a,b)})(z ${l?(l>0?'+ '+l:'‚àí '+Math.abs(l)):''})</code>`;
    const L3 = `<code class="equ">z ${k?(k>0?'+ '+k:'‚àí '+Math.abs(k)):''} = ${dev_z_plus_l(a,b,l)}</code>`;

    // rassembler (puis factoriser si n√©cessaire)
    const Nre = a*l - k, Nim = b*l;
    const L4  = `<code class="equ">${leftZCombo(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}</code>`;
    const steps = [H,L1,L2,L3,L4];
    if(c1!==0 && c2!==0){ // factorisation explicite seulement si mix re/imag
      steps.push(`<code class="equ">${leftZFact(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}</code>`);
    }

    // √©criture en fraction & conjugu√©
    const NumStr = joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}]);
    const L5 = `<code class="equ">z = ${fracOf(NumStr, denStr(c1,c2))}</code>`;
    const L6 = `<code class="equ">z = ${fracOf(`(${NumStr})(${conjStr(c1,c2)})`, `(${denStr(c1,c2)})(${conjStr(c1,c2)})`)}</code>`;

    // FOIL (i¬≤ visible), puis √©tape "i¬≤ ‚Üí ‚àí1" sans regrouper, puis d√©nominateur √©valu√©
    const foil = joinTerms([
      {coef:Nre*c1, kind:'re'},
      {coef:Nre*(-c2), kind:'i'},
      {coef:Nim*c1, kind:'i'},
      {coef:Nim*(-c2), kind:'i2'}
    ]);
    const L7  = `<code class="equ">z = ${fracOf(foil, `${pow2HTML(c1)} + ${pow2HTML(c2)}`)}</code>`;
    const foilNoI2 = joinTerms([
      {coef:Nre*c1,   kind:'re'},
      {coef:Nre*(-c2),kind:'i'},
      {coef:Nim*c1,   kind:'i'},
      {coef:-(Nim*(-c2)), kind:'re'}   // i¬≤ ‚Üí ‚àí1
    ]);
	    const D = c1*c1 + c2*c2;

    const L7b = `<code class="equ">z = ${fracOf(foilNoI2, String(D))}</code>`;

    // regrouper R/I, puis fraction finale et s√©paration
    const R = Nre*c1 + Nim*c2, I = Nre*(-c2) + Nim*c1;
    const L9  = `<code class="equ">z = ${fracOf(joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]), String(D))}</code>`;
    const L10 = `<code class="equ">z = ${finalAplusBi(R,I,D)}</code>`;
    showSteps(host, [...steps, L5, L6, L7, L7b,  L9, L10]);
  };

  // -------- mod√®le 2 : (z+ki)/(z+l) = a+bi --------
  const showM2 = ()=>{
    const {k,l,w:{a,b}} = st; const {c1,c2}=denCoefs(a,b);
    const H  = `<div><em>Pour tout</em> <code>z ‚â† ${fmtNum(-l)}</code>, on a :</div>`;
    const L1 = `<code class="equ">${fracOf(zPlusImag(k), zPlusReal(l))} = ${fmtComplex(a,b)}</code>`;
    const L2 = `<code class="equ">z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = (${fmtComplex(a,b)})(z ${l?(l>0?'+ '+l:'‚àí '+Math.abs(l)):''})</code>`;
    const L3 = `<code class="equ">z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = ${dev_z_plus_l(a,b,l)}</code>`;

    const Nre = a*l, Nim = b*l - k;
    const L4  = `<code class="equ">${leftZCombo(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}</code>`;
    const steps = [H,L1,L2,L3,L4];
    if(c1!==0 && c2!==0){
      steps.push(`<code class="equ">${leftZFact(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}</code>`);
    }

    const NumStr = joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}]);
    const L5 = `<code class="equ">z = ${fracOf(NumStr, denStr(c1,c2))}</code>`;
    const L6 = `<code class="equ">z = ${fracOf(`(${NumStr})(${conjStr(c1,c2)})`, `(${denStr(c1,c2)})(${conjStr(c1,c2)})`)}</code>`;

    const foil = joinTerms([
      {coef:Nre*c1, kind:'re'},
      {coef:Nre*(-c2), kind:'i'},
      {coef:Nim*c1, kind:'i'},
      {coef:Nim*(-c2), kind:'i2'}
    ]);
    const L7  = `<code class="equ">z = ${fracOf(foil, `${pow2HTML(c1)} + ${pow2HTML(c2)}`)}</code>`;
    const foilNoI2 = joinTerms([
      {coef:Nre*c1,   kind:'re'},
      {coef:Nre*(-c2),kind:'i'},
      {coef:Nim*c1,   kind:'i'},
      {coef:-(Nim*(-c2)), kind:'re'}
    ]);
        const D = c1*c1 + c2*c2;
const L7b = `<code class="equ">z = ${fracOf(foilNoI2, String(D))}</code>`;

    const R = Nre*c1 + Nim*c2, I = Nre*(-c2) + Nim*c1;
    const L9  = `<code class="equ">z = ${fracOf(joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]), String(D))}</code>`;
    const L10 = `<code class="equ">z = ${finalAplusBi(R,I,D)}</code>`;
    showSteps(host, [...steps, L5, L6, L7, L7b,  L9, L10]);
  };

  // -------- mod√®le 3 : (z+ki)/(z+li) = a+bi --------
  const showM3 = ()=>{
    const {k,l,w:{a,b}} = st; const {c1,c2}=denCoefs(a,b);
    const H  = `<div><em>Pour tout</em> <code>z ‚â† ${fmtNum(-l)}i</code>, on a :</div>`;
    const L1 = `<code class="equ">${fracOf(zPlusImag(k), zPlusImag(l))} = ${fmtComplex(a,b)}</code>`;
    const L2 = `<code class="equ">z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = (${fmtComplex(a,b)})(z ${l?(l>0?'+ ':'‚àí ')+(Math.abs(l)===1?'i':Math.abs(l)+'i'):''})</code>`;
    const L3 = `<code class="equ">z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = ${dev_z_plus_li(a,b,l,true)}</code>`; // i¬≤ visible
const L3b = `<code class="equ">z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = ${dev_z_plus_li_noI2(a,b,l)}</code>`;

    const RHSre = -b*l, RHSim = a*l - k; // apr√®s i¬≤=-1
    const L4  = `<code class="equ">${leftZCombo(a,b)} = ${joinTerms([{coef:RHSre,kind:'re'},{coef:RHSim,kind:'i'}])}</code>`;
    const steps = [H,L1,L2,L3,L3b,L4];
    if(c1!==0 && c2!==0){
      steps.push(`<code class="equ">${leftZFact(a,b)} = ${joinTerms([{coef:RHSre,kind:'re'},{coef:RHSim,kind:'i'}])}</code>`);
    }

    const NumStr = joinTerms([{coef:RHSre,kind:'re'},{coef:RHSim,kind:'i'}]);
    const L5 = `<code class="equ">z = ${fracOf(NumStr, denStr(c1,c2))}</code>`;
    const L6 = `<code class="equ">z = ${fracOf(`(${NumStr})(${conjStr(c1,c2)})`, `(${denStr(c1,c2)})(${conjStr(c1,c2)})`)}</code>`;

    const foil = joinTerms([
      {coef:RHSre*c1, kind:'re'},
      {coef:RHSre*(-c2), kind:'i'},
      {coef:RHSim*c1, kind:'i'},
      {coef:RHSim*(-c2), kind:'i2'}
    ]);
    const L7  = `<code class="equ">z = ${fracOf(foil, `${pow2HTML(c1)} + ${pow2HTML(c2)}`)}</code>`;
    const foilNoI2 = joinTerms([
      {coef:RHSre*c1,   kind:'re'},
      {coef:RHSre*(-c2),kind:'i'},
      {coef:RHSim*c1,   kind:'i'},
      {coef:-(RHSim*(-c2)), kind:'re'}
    ]);
        const D = c1*c1 + c2*c2;
const L7b = `<code class="equ">z = ${fracOf(foilNoI2, String(D))}</code>`;

    const R = RHSre*c1 + RHSim*c2, I = RHSre*(-c2) + RHSim*c1;
    const L9  = `<code class="equ">z = ${fracOf(joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]), String(D))}</code>`;
    const L10 = `<code class="equ">z = ${finalAplusBi(R,I,D)}</code>`;
    showSteps(host, [...steps, L5, L6, L7, L7b,  L9, L10]);
  };

  if (st.mode==='M1') return showM1();
  if (st.mode==='M2') return showM2();
  showM3();
}
,

  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};




/* ===== Registry & m√©canique ===== */
const REGISTRY=[ex1,ex2,ex3,ex4,ex5];
window.REGISTRY=REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(state);
  def.render(host,state);
  $('#res',host).textContent='';
  host.querySelectorAll('.tick').forEach(x=>x.textContent='');
}
function check(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); const r=def.correct(host,st); scoreTot+=r.total; scoreOK+=r.ok?1:0; updateScore(); }
function solution(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.reset(host,st); }

/* ==== Init ==== */
whenReady(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map(e=>'<option value="'+e.id+'">'+e.title+'</option>').join('');
  sel.addEventListener('change', buildOne);
  $("#btn-new").addEventListener('click', buildOne);
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  buildOne();

  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: '1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique, conjugu√©, inverse, quotient',
      max: 50,
      lead: '',
      leadByDefId: { cplx1:'', cplx2:'', cplx3:'', cplx4:'', cplx5:'' },
      mountAfterSelector: '.card.small'
    });
  }
});

/* ===== Accessibilit√© t√©l√©phone : agrandir les cibles drag si pr√©sent (h√©ritage) ===== */
window.addEventListener('pointerdown', ()=>{
  const coarse = matchMedia('(pointer:coarse)').matches;
  if (!coarse) return;
  document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
    const r = parseFloat(c.getAttribute('r')||'5');
    if (r < 10) c.setAttribute('r', String(12));
    c.style.touchAction='none';
  });
}, {passive:true});
</script>
</body>
</html>
