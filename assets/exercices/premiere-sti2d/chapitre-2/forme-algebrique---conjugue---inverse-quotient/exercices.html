<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique ‚Ä¢ Conjugu√© ‚Ä¢ Inverse ‚Ä¢ Quotient (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.55}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .row{display:grid;grid-template-columns:1fr;gap:10px}
  .statement{font-size:18px}
  .statement .consigne{opacity:.8;margin-bottom:6px}
  .equ{font-variant-numeric:tabular-nums}
  #host .inputs{display:flex;flex-direction:column;gap:8px}
  #host .ans-row{display:flex;align-items:center;gap:6px}
  #host .ans-row .tick{min-width:1.2em;text-align:center}
  #res.small{font-size:15px}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}

  /* (h√©ritage) styles de fractions HTML ‚Äì inutilis√©s apr√®s conversion LaTeX mais conserv√©s pour compat */
  .frac{display:inline-grid;grid-template-rows:auto 2px auto;justify-items:center;align-items:center;vertical-align:middle;line-height:1}
  .frac .num,.frac .den{display:block;text-align:center;padding:0 .2em;white-space:nowrap}
  .frac .fracbar{display:block;width:100%;height:2px;background:currentColor;margin:.08em 0}

  /* Espacement autour des formules inline dans les √©nonc√©s */
  .statement code{padding:.05rem .35rem;border-radius:6px;margin:0 .35rem;display:inline-block;white-space:nowrap}
  .statement code:first-child, .equ:first-child{ margin-left:0 }
  .statement code:last-child,  .equ:last-child{  margin-right:0 }

  @media (max-width:720px){ .controls{gap:6px} }

.solution .mjx-container{font-size:115%}

@media print{
  .equ{
    display:inline !important;
    padding:0 !important; margin:0 .2rem !important;
    border:0 !important; background:none !important; box-shadow:none !important;
    text-decoration:none !important;
  }
  .steps .step::before,
  .steps .step::after,
  .steps .step *::before,
  .steps .step *::after{
    content:none !important;
    border:0 !important;
    background:transparent !important;
  }
  .bar, [class*="bar"]{
    display:none !important;
    border:0 !important;
    height:0 !important; width:0 !important;
    margin:0 !important; padding:0 !important;
    background:transparent !important;
  }
}

</style>

<!-- MathJax (LaTeX) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    // ‚¨áÔ∏è CL√â: on n‚Äôignore plus <code>/<pre>
    options: {
      skipHtmlTags: ['script','noscript','style','textarea']  // (on enl√®ve 'pre' et 'code')
      // (optionnel) processHtmlClass: 'mathjax-process', ignoreHtmlClass: 'tex2jax_ignore'
    },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <div class="controls">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>
  </div>

  <div class="wrap">
    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 1.1rem">
        <li>R√©pondre en <em>forme alg√©brique : a+bi</em>. Les √©critures <em>bi + a</em>, <em>a</em> (si b=0) et <em>bi</em> (si a=0)) sont accept√©es.</li>
        <li><strong>Jamais</strong> <code>1i</code> / <code>‚àí1i</code> (√©crire <code>i</code> ou <code>‚àíi</code>). Pas de <code>0i</code>, <code>+0</code>, <code>0+</code>.</li>
        <li>Fractions autoris√©es : <code>p/q</code> (r√©duction automatique √† la correction, jamais ¬´ /1 ¬ª). D√©cimales : virgule ou point. Les √©critures <code>3*i</code> / <code>3√ói</code> sont normalis√©es en <code>3i</code>.</li>
        <li>La touche <kbd>Entr√©e</kbd> d√©clenche <em>V√©rifier</em>. Le score n‚Äô√©volue pas tant qu‚Äôune saisie est vide.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Scripts partag√©s -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>

<script>
// Ajoute un NBSP (espace ins√©cable normal) autour des formules inline quand coll√©es √† un mot
function fixInlineMathSpacing(scope){
  const root = scope || document;
  const NBSP = '\u00A0';
  const isWord = c => /\p{L}|\p{N}/u.test(c || ''); // lettre ou chiffre (Unicode)

  root.querySelectorAll('mjx-container:not([display="true"])').forEach(m => {
    // ----- BEFORE -----
    let prev = m.previousSibling;
    if (prev && prev.nodeType === 3) {
      const txt = prev.nodeValue;
      const last = txt.slice(-1);
      if (!/\s$/.test(txt) && isWord(last)) {
        prev.nodeValue = txt + NBSP;
      }
    } else if (prev && prev.nodeType === 1) {
      // ex: <em>alg√©brique</em><mjx-container>‚Ä¶  ‚Üí on met un espace
      m.parentNode.insertBefore(document.createTextNode(NBSP), m);
    }

    // ----- AFTER -----
    let next = m.nextSibling;
    if (next && next.nodeType === 3) {
      const txt = next.nodeValue;
      const first = txt.charAt(0);
      if (!/^\s/.test(txt) && isWord(first)) {
        next.nodeValue = NBSP + txt;
      }
    } else if (next && next.nodeType === 1) {
      // ex: </mjx-container><em>et</em>  ‚Üí on met un espace
      m.parentNode.insertBefore(document.createTextNode(NBSP), next);
    }
  });
}


/* ===== Utils (g√©n√©ral) ===== */
function $(sel, root){ return (root||document).querySelector(sel); }
function whenReady(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn, {once:true}); }
function rnd(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function nz(a,b){ let v=0; while(v===0) v=rnd(a,b); return v; }
const UMINUS = '‚àí';
const CC = '\\(\\mathbb{C}\\)'; // joli C
function norm(s){
  return String(s||'')
    .replace(/\u2212/g,'-')     // ‚àí (unicode) ‚Üí -
    .replace(/\u2044/g,'/')     // ‚ÅÑ (unicode fraction slash) ‚Üí /
    .replace(/,/g,'.')          // d√©cimale FR ‚Üí .
    .replace(/¬∑|√ó/g,'*')        // √ó, ¬∑ ‚Üí *
    .trim();
}
// ‚Äî‚Äî‚Äî Nombre d√©cimal OU fraction p/q (parenth√®ses tol√©r√©es) ‚Äî‚Äî‚Äî
function numFrom(str){
  const t = String(str||'').replace(/[()]/g,''); // enl√®ve () √©ventuelles

  // d√©cimal simple
  if (/^[+\-]?\d+(?:\.\d+)?$/.test(t)) return Number(t);

  // fraction : num peut √™tre vide (+/- ‚Üí ¬±1), den ‚â† 0
  const m = t.match(/^([+\-]?\d*)\s*\/\s*([+\-]?\d+)$/);
  if (m){
    let num = m[1];
    if (num === '' || num === '+') num = '1';
    if (num === '-') num = '-1';
    const n = Number(num), d = Number(m[2]);
    if (!Number.isFinite(n) || !Number.isFinite(d) || d === 0) return NaN;
    return n / d;
  }
  return NaN;
}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function reduce(p,q){ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return [p/g, q/g]; }
function fmtNum(n){ const v=Math.abs(n); const s=Number.isInteger(n)? String(v) : String(v).replace('.',','); return n<0? UMINUS+s : s; }
function fmtIcoef(b){ if(b===0) return ''; const ab=Math.abs(b); const coef = (ab===1? '' : String(ab).replace('.',',')); const sign = (b<0? ' '+UMINUS+' ' : (b>0? ' + ' : '')); return sign + coef + 'i'; }
function fmtComplex(a,b,order){
  order = order||'a+bi';
  if(order==='bi+a'){
    if(b===0) return a===0? '0' : fmtNum(a);
    if(a===0) return (b===1? 'i' : (b===-1? UMINUS+'i' : (b<0? UMINUS+String(Math.abs(b)).replace('.',',')+'i' : String(b).replace('.',',')+'i')));
    const left = (b>0 ? (b===1? 'i' : String(b).replace('.',',')+'i') : (b===-1? UMINUS+'i' : UMINUS+String(Math.abs(b)).replace('.',',')+'i'));
    const right = (a>=0 ? ' + '+fmtNum(a) : ' '+UMINUS+String(Math.abs(a)));
    return left + right;
  } else {
    if(a===0 && b===0) return '0';
    if(a===0) return (b===1? 'i' : (b===-1? UMINUS+'i' : (b<0? UMINUS+String(Math.abs(b)).replace('.',',')+'i' : String(b).replace('.',',')+'i')));
    if(b===0) return fmtNum(a);
    return fmtNum(a) + fmtIcoef(b);
  }
}
// --- Helpers "fractions exactes" ---
function gcdInt(x, y){ x=Math.trunc(Math.abs(x)); y=Math.trunc(Math.abs(y)); while(y){ const t=x%y; x=y; y=t; } return x||1; }
function fracText(num, den){
  if(den<0){ num=-num; den=-den; }
  const g = gcdInt(num, den); num/=g; den/=g;
  if(den === 1) return String(num);
  const s = (num<0 ? '-' : '');
  return s + fracOf(String(Math.abs(num)), String(den)); // <-- sera converti en LaTeX
}

// ‚Äî‚Äî‚Äî Parsing tol√©rant de a + bi (accepte p/q, i/2, 3/4i, bi+a, "z=...") ‚Äî‚Äî‚Äî
function parseComplex(str){
  if(!str) return null;

  // normalise puis compact
  let s = norm(str).replace(/\s+/g,'');
  s = s.replace(/^(?:z\s*=?\s*)/i,''); // retire "z=" √©ventuel
  s = s.replace(/\*/g,'');             // enl√®ve les √©toiles (3*i ‚Üí 3i)

  // d√©coupe par +/‚àí
  const parts = s.match(/[+\-]?[^+\-]+/g);
  if(!parts) return null;

  let a = 0, b = 0;

  for (let t of parts){
    if (!t) continue;

    const hasI = /i/i.test(t);
    if (hasI){
      // exemples accept√©s : "3/4i", "-2i", "i", "+i", "i/2", "(1/3)i"
      // on retire le 'i' (o√π qu'il soit) et on lit le coefficient
      let coef = t.replace(/i/ig,''); // "3/4", "", "/2", "(1/3)"
      if (coef === '' || coef === '+') coef = '1';
      if (coef === '-')               coef = '-1';

      const v = numFrom(coef);
      if (!Number.isFinite(v)) return null;
      b += v;
    } else {
      const v = numFrom(t);
      if (!Number.isFinite(v)) return null;
      a += v;
    }
  }
  return {a:+a, b:+b};
}
function eqComplexStr(str,A,B){ const p=parseComplex(str); return !!p && Math.abs(p.a-A)<1e-9 && Math.abs(p.b-B)<1e-9; }

/* Helpers d‚Äôaffichage pour les √©tapes */
const PM = v => v>=0 ? ' + ' : ' ‚àí ';
const IABS = v => (Math.abs(v)===1? 'i' : String(Math.abs(v)).replace('.',',')+'i');
const IABS2 = v => (Math.abs(v)===1? 'i^{2}' : String(Math.abs(v)).replace('.',',')+'i^{2}');
function dispZ_steps(z){ let out=''; if(z.a!==0) out+=String(z.a); if(z.b!==0){ const pref = out? PM(z.b) : (z.b<0? '‚àí ' : ''); out += pref + IABS(z.b); } return out||'0'; }

/* Fractions (affichage, jamais /1) */
function fracHTML(p,q){
  p=Math.trunc(p); q=Math.trunc(q);
  if(q===1) return String(p);
  const neg = (p<0)!=(q<0);
  p=Math.abs(p); q=Math.abs(q);
  const g=(a,b)=>b?g(b,a%b):a;
  const d=g(p,q)||1; const pp=p/d, qq=q/d;
  const core = `\\frac{${pp}}{${qq}}`;
  return neg ? `- ${core}` : core;
}
// Fraction g√©n√©rique (numHTML/denHTML) pour √©crire EN PILE partout (sera converti en LaTeX)
function fracOf(numHTML, denHTML){ return `\\frac{${numHTML}}{${denHTML}}`; }
// x¬≤ compact
function pow2HTML(n){
  const tight = String(fmtNum(n)).replace(/[\u00A0\u202F\u2009\s]+/g,'');
  const base = (n<0 ? `(${tight})` : tight);
  return base + '^{2}';
}

// somme de termes (HTML, convertie ensuite)
function joinTerms(parts){
  let out = '';
  for(const {coef, kind} of parts){
    if(!coef) continue;
    const first = out==='';
    const sign = coef<0 ? (first ? '‚àí ' : ' ‚àí ') : (first ? '' : ' + ');
    const mag  = Math.abs(coef);
    let body = '';
    if(kind==='re') body = String(mag);
    else if(kind==='i') body = (mag===1 ? 'i' : String(mag)+'i');
    else body = (mag===1 ? 'i^{2}' : String(mag)+'i^{2}');
    out += sign + body;
  }
  return out || '0';
}

/* === LaTeX conversion & typesetting === */
function nodeToTeX(node){
  if(node.nodeType===3){
    return node.nodeValue
      .replace(/\u00A0/g,' ')
      .replace(/√ó/g,' \\times ')
      .replace(/¬∑/g,' \\cdot ')
      .replace(/‚àí/g,'-');
  }
  if(node.nodeType===1){
    const el = node;
    if(el.classList && el.classList.contains('frac')){
      const num = el.querySelector('.num');
      const den = el.querySelector('.den');
      const N = num ? nodeToTeX(num) : '';
      const D = den ? nodeToTeX(den) : '';
      let sign = '';
      // signe √©ventuel juste avant (span.frac-sign)
      if(el.previousElementSibling && el.previousElementSibling.classList.contains('frac-sign')) sign = '-';
      return sign + '\\frac{'+N+'}{'+D+'}';
    }
    if(el.classList && el.classList.contains('frac-sign')){
      return '-';
    }
    if(el.tagName==='SUP'){
      const inner = Array.from(el.childNodes).map(nodeToTeX).join('');
      return '^{'+inner+'}';
    }
    if(el.tagName==='SUB'){
      const inner = Array.from(el.childNodes).map(nodeToTeX).join('');
      return '_{'+inner+'}';
    }
    // Par d√©faut : concat enfants
    let out='';
    for(const ch of el.childNodes) out += nodeToTeX(ch);
    return out;
  }
  return '';
}


function typesetAll(root){
  const run = () => MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  if (window.MathJax && MathJax.startup && MathJax.startup.promise) {
    MathJax.startup.promise.then(run);
  } else {
    const t = setInterval(()=>{
      if (window.MathJax && MathJax.startup && MathJax.typesetPromise){ clearInterval(t); run(); }
    }, 60);
  }
}



/* Raccourcis rendu d‚Äôun bloc simple une saisie */
function renderSimple(host, enonceHTML, field){
  host.innerHTML='';
  const wrap=document.createElement('div'); wrap.className='row';
  const st=document.createElement('div'); st.className='statement'; st.innerHTML=enonceHTML||''; wrap.appendChild(st);
  const inputs=document.createElement('div'); inputs.className='inputs';
  const row=document.createElement('div'); row.className='ans-row';
  row.innerHTML =
  (field.labelHTML ?? (field.label ? `<span aria-hidden="true">${field.label}</span>` : '')) +
  `<input type="text" id="${field.id}" placeholder="${field.placeholder||'‚Ä¶'}" style="flex:1;min-width:0">` +
  `<span class="tick" id="${field.id}-tick"></span>`;

  inputs.appendChild(row); wrap.appendChild(inputs);
  const res=document.createElement('div'); res.id='res'; wrap.appendChild(res); host.appendChild(wrap);
  typesetAll(wrap);
  $('#'+field.id,host)?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); check(); } });
}
function setTick(host,id,val){ const el=$('#'+id+'-tick',host); if(el) el.textContent = val||''; }
function showSteps(host, steps){ const uniq=[]; for(const L of steps){ if(!uniq.length || uniq[uniq.length-1]!==L) uniq.push(L); } $('#res',host).innerHTML = '<div class="steps">'+uniq.map(t=>'<div class="step">'+t+'</div>').join('')+'</div>'; $('#res',host).className='small'; typesetAll($('#res',host)); }

/* Random z util */
function randZ(){ return {a:rnd(-9,9), b:rnd(-9,9)}; }
function randZnz(){ let z=randZ(); while(z.a===0 && z.b===0) z=randZ(); return z; }

// Ajoute un terme k¬∑(unit√©) √† une cha√Æne alg√©brique (sans "1z", sans 0)
function _appendTerm(out, k, unit){
  if (!k) return out;
  const first = (out === '');
  const sign  = k < 0 ? (first ? '‚àí ' : ' ‚àí ') : (first ? '' : ' + ');
  const m = Math.abs(k);
  let body = '';
  if (unit === 'z')   body = (m===1 ? 'z'  : m+'z');
  else if (unit === 'iz') body = (m===1 ? 'iz' : m+'iz');
  else if (unit === 'i')  body = (m===1 ? 'i'  : m+'i');
  else if (unit === 'i2') body = (m===1 ? 'i^{2}' : m+'i^{2}');
  else body = String(m);
  return out + sign + body;
}

// D√©veloppe (a+bi)(z+l)  -> "az + biz + al + bli"
function expand_ab_times_z_plus_l(a,b,l){
  let rhs = '';
  rhs = _appendTerm(rhs, a, 'z');      // az
  rhs = _appendTerm(rhs, b, 'iz');     // + biz
  rhs = _appendTerm(rhs, a*l, '');     // + al
  rhs = _appendTerm(rhs, b*l, 'i');    // + bl¬∑i
  return rhs || '0';
}

// D√©veloppe (a+bi)(z+li) -> "az + biz + ali + bli¬≤"
function expand_ab_times_z_plus_li(a,b,l, withI2=true){
  let rhs = '';
  rhs = _appendTerm(rhs, a, 'z');                 // az
  rhs = _appendTerm(rhs, b, 'iz');                // + biz
  rhs = _appendTerm(rhs, a*l, 'i');               // + al¬∑i
  rhs = _appendTerm(rhs, b*l, withI2 ? 'i2' : ''); // + bl¬∑i¬≤ (ou remplac√© ensuite)
  return rhs || '0';
}

const plusC = (a,b) => ' + (' + fmtComplex(a,b,'a+bi') + ')';
function plusCNoParens(u, v){
  let s = '';
  if (u !== 0){
    s += (u > 0 ? ' + ' : ' ‚àí ') + fmtNum(Math.abs(u));
  }
  if (v !== 0){
    const mag = Math.abs(v);
    s += (v > 0 ? ' + ' : ' ‚àí ') + (mag === 1 ? 'i' : String(mag) + 'i');
  }
  return s; // '' si u=v=0
}


/* ===== Exercices ===== */

/* Ex.1 ‚Äî Conjugu√© */
const ex1 = {
  id:'cplx1', title:'Conjugu√© d‚Äôun nombre complexe',
  gen(){
    const z = randZnz();
    const order = Math.random()<0.5 ? 'a+bi' : 'bi+a';
    const enonce = `
      <div class="consigne"><strong>Exercice 1 : Conjugu√©</strong></div>
      <div>D√©terminer le conjugu√© du nombre complexe suivant :</div>
      <div>\\(z = ${fmtComplex(z.a,z.b,order)}\\)</div>
    `;
    return {z, enonce};
  },
  render(host,st){
    renderSimple(host, st.enonce, {id:'ans', label:'\\(\overline{z}=\\)', placeholder:'a ‚àí bi', labelHTML:'\\(\\overline{z}=\\)'});
  },
  correct(host,st){
    const el=host.querySelector('#ans'); if(!el||!el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.z.a, -st.z.b);
    setTick(host,'ans', ok?'‚úî':'‚úò');
    return {ok,total:1};
  },
  solution(host,st){
    const a=st.z.a, b=st.z.b;
    const L1 = `Rappel : \\(z = a+bi\\) ‚áí \\(\\overline{z}=a-bi\\).`;
    const L2 = `Ici : \\(z = ${fmtComplex(a,b,'a+bi')}\\) donc \\(\\overline{z}=${fmtComplex(a,-b,'a+bi')}\\).`;
    showSteps(host,[L1,L2]);
  },
  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

/* Ex.2 ‚Äî Inverse dans C */
const ex2 = {
  id:'cplx2', title:'Inverse d‚Äôun nombre complexe',
  gen(){
    let z=randZnz(); // √©viter 0
    const enonce = `
      <div class="consigne"><strong>Exercice 2 : Inverse dans ${CC}</strong></div>
      <div>Soit le nombre complexe \\(z = ${fmtComplex(z.a,z.b,'a+bi')}\\).</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique \\(a+bi\\).</div>
      <div style="margin-top:.25rem">\\(${fracOf('1','z')}\\)</div>
    `;
    const den = z.a*z.a + z.b*z.b; // > 0
    const A = z.a/den, B = -z.b/den; // a/den + (-b/den)i
    return {z, den, r:{a:A, b:B}, enonce};
  },
  render(host,st){ renderSimple(host, st.enonce, {
    id:'ans',
    labelHTML:'\\('+fracOf('1','z')+'\\) =',
    placeholder:'a + bi'
  });},

  correct(host,st){ const el=host.querySelector('#ans'); if(!el||!el.value.trim()) return {ok:false,total:0}; const ok=eqComplexStr(el.value, st.r.a, st.r.b); setTick(host,'ans', ok?'‚úî':'‚úò'); return {ok,total:1}; },
  solution(host,st){
    const a = st.z.a, b = st.z.b, D = a*a + b*b;

    if (b === 0) {
      const L0 = `\\(z = ${fmtComplex(a,0)}\\)`;
      const L1 = `\\(${fracOf('1','z')} = ${fracOf('1', String(a))}\\)`;
      const L2 = `\\(${fracOf('1','z')}= ${fracText(1, a)}\\)`;
      showSteps(host, [L0, L1, L2]);
      return;
    }
    function coefI(b, sup2=false){
      const A = Math.abs(b);
      const s = b < 0 ? '-' : '';
      const k = (A === 1 ? '' : A);
      return `${s}${k}i${sup2 ? '^{2}' : ''}`;
    }
    function parensIfNeg(txt, b){ return b < 0 ? `(${txt})` : txt; }

    if (a === 0 && b !== 0) {
      const den0  = coefI(b);
      const den0x = parensIfNeg(den0, b);
      const L1 = `\\(${fracOf('1','z')} = ${fracOf('1', den0)}\\)`;
      const L2 = `\\(${fracOf('1','z')} = ${fracOf('1 √ó i', `${den0x} √ó i`)}\\)`;
      const L3 = `\\(${fracOf('1','z')} = ${fracOf('i', coefI(b, true))}\\)`;
      const L4 = `\\(${fracOf('1','z')} = ${fracOf('i', String(-b))}\\)`;
      const mag  = Math.abs(b);
      const sign = (b > 0 ? '-' : '+');
      const last = (mag === 1 ? 'i' : `${fracOf('1', String(mag))} i`);
      const L5 = `\\(${fracOf('1','z')} = ${sign} ${last}\\)`;
      showSteps(host, [L1, L2, L3, L4, L5]);
      return;
    }

    const L1  = `On multiplie par le conjugu√© du d√©nominateur au num√©rateur et au d√©nominateur :`;
    const L1b = `\\(${fracOf('1','z')} = ${fracOf('1', fmtComplex(a,b))} √ó ${fracOf(fmtComplex(a,-b), fmtComplex(a,-b))}\\).`;

    const denExpandedHTML = `${pow2HTML(a)} + ${pow2HTML(b)}`;
    const L1c = `\\(${fracOf('1','z')} = ${fracOf(fmtComplex(a,-b,'a+bi'), denExpandedHTML)}\\)`;

    const L2  = `\\(${fracOf('1','z')} = ${fracOf(fmtComplex(a,-b), String(D))}\\) (car \\(a^2 + b^2 = ${D}\\)).`;

    const [ra,rb] = reduce(a,D), [ia,ib] = reduce(-b,D);
    const L3  = `\\(${fracOf('1','z')} = ${(ra<0?'‚àí ':'')}${fracHTML(Math.abs(ra),rb)} ${(-b>=0?' + ':' ‚àí ')} ${fracHTML(Math.abs(ia),ib)} i\\).`;

    showSteps(host,[L1, L1b,L1c,L2, L3]);
  }
  ,
  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

/* Ex.3 ‚Äî Quotient z1 / z2 */
const ex3 = {
  id:'cplx3', title:'Quotient de deux nombres complexes',
  gen(){
    const z1 = randZnz(); 
    let z2 = randZnz();
    while (z2.b === 0) z2 = randZnz();

    const enonce = `
      <div class="consigne"><strong>Exercice 3 : Quotient dans ${CC}</strong></div>
      <div>Soient \\(z_1 = ${fmtComplex(z1.a,z1.b)}\\) et \\(z_2 = ${fmtComplex(z2.a,z2.b)}\\).</div>
      <div>Mettre le nombre suivant sous la forme alg√©brique \\(a+bi\\).</div>
      <div style="margin-top:.25rem">\\(${fracOf('z_1','z_2')}\\)</div>
    `;
    const den = z2.a*z2.a + z2.b*z2.b;
    const A = (z1.a*z2.a + z1.b*z2.b)/den;
    const B = (z1.b*z2.a - z1.a*z2.b)/den;
    return {z1,z2,den,r:{a:A,b:B}, enonce};
  },
  render(host,st){ renderSimple(host, st.enonce, {
    id:'ans',
    labelHTML:'\\('+fracOf('z_1','z_2')+'\\) =',
    placeholder:'a + bi'
  });
 },
  correct(host,st){ const el=host.querySelector('#ans'); if(!el||!el.value.trim()) return {ok:false,total:0}; const ok=eqComplexStr(el.value, st.r.a, st.r.b); setTick(host,'ans', ok?'‚úî':'‚úò'); return {ok,total:1}; },
  solution(host,st){
    const a1 = st.z1.a, b1 = st.z1.b, a2 = st.z2.a, b2 = st.z2.b;
    const D = a2*a2 + b2*b2;

    const pow2 = n => {
      const tight = String(fmtNum(n)).replace(/[\u00A0\u202F\u2009\s]+/g,'');
      return (n<0 ? '('+tight+')' : tight) + '^{2}';
    };
    const denPow = `${pow2(a2)} + ${pow2(b2)}`;

    function joinTerms(parts){
      let out = '';
      for(const {coef, kind} of parts){
        if(!coef) continue;
        const first = out==='';
        const sign = coef<0 ? (first ? '‚àí ' : ' ‚àí ') : (first ? '' : ' + ');
        const mag = Math.abs(coef);
        let body = '';
        if(kind==='re') body = String(mag);
        else if(kind==='i') body = (mag===1 ? 'i' : String(mag)+'i');
        else body = (mag===1 ? 'i^{2}' : String(mag)+'i^{2}');
        out += sign + body;
      }
      return out || '0';
    }

    const S0 = `\\(${fracOf('z_1','z_2')} = ${fracOf(
                 fmtComplex(a1,b1,'a+bi'), fmtComplex(a2,b2,'a+bi'))}\\)`;

    const S1 = `\\(${fracOf('z_1','z_2')} = ${fracOf(
                 '('+fmtComplex(a1,b1,'a+bi')+')('+
                 fmtComplex(a2,-b2,'a+bi')+')', '('+fmtComplex(a2,b2,'a+bi')+')('+
                 fmtComplex(a2,-b2,'a+bi')+')')}\\)`;

    const t1 = a1*a2;           // r√©el
    const t2 = a1*(-b2);        // coef de i
    const t3 = b1*a2;           // coef de i
    const t4 = b1*(-b2);        // coef de i¬≤
    const numFOIL = joinTerms([
      {coef:t1, kind:'re'},
      {coef:t2, kind:'i'},
      {coef:t3, kind:'i'},
      {coef:t4, kind:'i2'}
    ]);
    const S2 = `\\(${fracOf('z_1','z_2')}= ${fracOf(numFOIL, denPow)}\\)`;

    const numAfterI2 = joinTerms([
      {coef:t1,  kind:'re'},
      {coef:t2,  kind:'i'},
      {coef:t3,  kind:'i'},
      {coef:-t4, kind:'re'}
    ]);
    const S3a = `\\(${fracOf('z_1','z_2')} = ${fracOf(numAfterI2, String(D))}\\)`;

    const R = t1 - t4;                 // a1*a2 + b1*b2
    const I = t2 + t3;                 // -a1*b2 + b1*a2
    const numRI = (I!==0 ? joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}])
                         : String(fmtNum(R)));
    const S4 = `\\(${fracOf('z_1','z_2')} = ${fracOf(numRI, String(D))}\\)`;

    const parts = [];
    if (R!==0){
      const [r1x,r1y] = reduce(R, D);
      parts.push((r1x<0?'‚àí ':'') + fracHTML(Math.abs(r1x), r1y));
    }
    if (I!==0){
      const [r2x,r2y] = reduce(I, D);
      const frag = fracHTML(Math.abs(r2x), r2y) + ' i';
      parts.push((I>0 && parts.length? ' + ' : (I<0 && parts.length? ' ‚àí ' : (I<0? '‚àí ' : ''))) + frag);
    }
    const S5 = `\\(${fracOf('z_1','z_2')} = ${parts.join('') || '0'}\\)`;

    showSteps(host,[S0,S1,S2,S3a,S4,S5]);
  },
  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

/* Petites op√©rations complexes (pour les √©quations) */
const C = (a,b)=>({a:a,b:b});
const addC=(z,w)=>C(z.a+w.a, z.b+w.b);
const subC=(z,w)=>C(z.a-w.a, z.b-w.b);
const mulC=(z,w)=>C(z.a*w.a - z.b*w.b, z.a*w.b + z.b*w.a);
const conjC=z=>C(z.a,-z.b);
const divC=(z,w)=>{ const D=w.a*w.a+w.b*w.b; return C((z.a*w.a+z.b*w.b)/D, (z.b*w.a - z.a*w.b)/D); };

/* ===== Ex.4 ‚Äî R√©soudre une √©quation (s√©lecteur de mod√®le) ===== */
const ex4 = {
  id:'cplx4',
  title:'R√©soudre une √©quation (mod√®les)',
  _lastMode: 'M1',
  gen(mode){
    const M = mode || this._lastMode || 'M1';
    this._lastMode = M;

    if (M==='M1'){ // (a+bi)z + (u+vi) = 0
      const a=nz(-4,4), b=nz(-4,4);
      let u=rnd(-6,6), v=rnd(-6,6);
      if(u===0 && v===0){ v = 1; }  // √©viter trivial
      const A = {a,b}, U = {a:u,b:v};
      const enonce = `
                <div class="consigne"><strong>Exercice 4 : R√©soudre une √©quation dans ${CC}</strong></div>
		<div style="margin-bottom:.35rem">
          <label><small><b>Mod√®le :</b></small>
            <select id="ex4-model">
              <option value="M1" selected>Mod√®le 1 ‚Äî (a+bi)z + (u+vi) = 0</option>
              <option value="M2">Mod√®le 2 ‚Äî pz ‚àí qi = ‚àíiz + (r + si)</option>
            </select>
          </label>
        </div>
        <div>R√©soudre dans ${CC} l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
<div style="margin-top:.25rem">\\((${fmtComplex(a,b)})z${u||v ? plusCNoParens(u,v) : ''} = 0\\)</div>
      `;
      const D = a*a + b*b;
// z = (-(u+vi))/(a+bi) = [(-ua - vb) + i(ub - va)] / D
const r = { a: (-u*a - v*b)/D, b: (u*b - v*a)/D };
return {mode:'M1', enonce, A, U, r};

    }

    const p=nz(-9,9), q=Math.max(1, Math.abs(rnd(-6,6))); // q ‚â† 0
    const r=rnd(-9,9), s=rnd(-9,9);
    const enonce = `
              <div class="consigne"><strong>Exercice 4 : R√©soudre une √©quation dans ${CC}</strong></div>
	  <div style="margin-bottom:.35rem">
        <label><small><b>Mod√®le :</b></small>
          <select id="ex4-model">
            <option value="M1">Mod√®le 1 ‚Äî (a+bi)z + (u+vi) = 0</option>
            <option value="M2" selected>Mod√®le 2 ‚Äî pz ‚àí qi = ‚àíiz + (r + si)</option>
          </select>
        </label>
      </div>
      <div>R√©soudre dans ${CC} l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
<div style="margin-top:.25rem">\\(${p}z ‚àí ${q}i = ‚àíiz${plusCNoParens(r,s)}\\)</div>
    `;
    const D = p*p + 1;
    const R = r, S = q + s;
    const rsol = { a:(R*p + S*1)/D, b:(S*p - R*1)/D };
    return {mode:'M2', enonce, p, q, r, s, R, S, rsol};
  },

  render(host, st){
    renderSimple(host, st.enonce, {id:'ans', label:'z =', placeholder:'a + bi', labelHTML:'\\(z =\\)'});
    const sel = host.querySelector('#ex4-model');
    if (sel){
      sel.value = st.mode;
      sel.addEventListener('change', () => {
        const next = ex4.gen(sel.value);
        host.dataset.active = ex4.id;
        host.dataset.state  = JSON.stringify(next);
        ex4.render(host, next);
      });
    }
  },

  correct(host, st){
    const el=host.querySelector('#ans');
    if(!el||!el.value.trim()) return {ok:false,total:0};
    let A=false;
    if (st.mode==='M1'){
      const a=st.A.a, b=st.A.b, u=st.U.a, v=st.U.b, D = a*a + b*b;
const ZA = (-u*a - v*b) / D;
const ZB = (u*b - v*a) / D;
A = eqComplexStr(el.value, ZA, ZB);

    } else {
      A = eqComplexStr(el.value, st.rsol.a, st.rsol.b);
    }
    setTick(host,'ans', A?'‚úî':'‚úò');
    return {ok:A,total:1};
  },

  solution(host, st){
    if (st.mode==='M1'){
      const a=st.A.a, b=st.A.b, u=st.U.a, v=st.U.b;
      const D = a*a + b*b;

const L0 = `\\((${fmtComplex(a,b)})z${u||v ? plusCNoParens(u,v) : ''} = 0\\)`;
      const L1 = `\\((${fmtComplex(a,b)})z = ${fmtComplex(-u,-v)}\\)`;
      const L2 = `\\(z = ${fracOf(fmtComplex(-u,-v,'a+bi'), fmtComplex(a,b,'a+bi'))}\\)`;
      const L3 = `\\(z = ${fracOf(
                      '('+fmtComplex(-u,-v,'a+bi')+')('+
                      fmtComplex(a,-b,'a+bi')+')',
                      '('+fmtComplex(a,b,'a+bi')+')('+
                      fmtComplex(a,-b,'a+bi')+')')}\\)`;

      const t1 = (-u)*a;
      const t2 = (-u)*(-b);   // i
      const t3 = (-v)*a;      // i
      const t4 = (-v)*(-b);   // i¬≤
      const numFOIL = joinTerms([
        {coef:t1, kind:'re'},
        {coef:t2, kind:'i'},
        {coef:t3, kind:'i'},
        {coef:t4, kind:'i2'}
      ]);
      const denPow = `${pow2HTML(a)} + ${pow2HTML(b)}`;
      const L4 = `\\(z = ${fracOf(numFOIL, denPow)}\\)`;

      const numAfterI2 = joinTerms([
        {coef:t1,  kind:'re'},
        {coef:t2,  kind:'i'},
        {coef:t3,  kind:'i'},
        {coef:-t4, kind:'re'}
      ]);
      const L5 = `\\(z = ${fracOf(numAfterI2, String(D))}\\)`;

      const R = t1 - t4;        // a*(-u) + b*v
      const I = t2 + t3;        // -a*v + b*(-u)
      const numRI = joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]);
      const L6 = `\\(z = ${fracOf(numRI, String(D))}\\)`;

      const parts = [];
      if (R!==0){ const [x,y]=reduce(R,D); parts.push((x<0?'‚àí ':'') + fracHTML(Math.abs(x), y)); }
      if (I!==0){
        const [x,y]=reduce(I,D);
        const frag = fracHTML(Math.abs(x),y)+' i';
        parts.push((I>0 && parts.length? ' + ' : (I<0 && parts.length? ' ‚àí ' : (I<0? '‚àí ' : ''))) + frag);
      }
      const L7 = `\\(z = ${parts.join('') || '0'}\\)`;
      showSteps(host, [L0,L1,L2,L3,L4,L5,L6,L7]);
      return;
    }

    // ===== Mod√®le 2 =====
    const p=st.p, q=st.q, r=st.r, s=st.s;
    const R = st.R, S = st.S;           // R=r, S=q+s
    const D = p*p + 1;

    const M0 = `\\(${p}z ‚àí ${q}i = ‚àíiz${plusCNoParens(r,s)}\\)`;
    const M1 = `\\(${p}z + iz = ${fmtComplex(r, q+s)}\\)`;
    const M2 = `\\(z(${p}+i) = ${fmtComplex(r, q+s)}\\)`;
    const M3 = `\\(z = ${fracOf(fmtComplex(r, q+s,'a+bi'), fmtComplex(p,1,'a+bi'))}\\)`;
    const M4 = `\\(z = ${fracOf(
                 '('+fmtComplex(r,q+s,'a+bi')+')('+
                 fmtComplex(p,-1,'a+bi')+')',
                 '('+fmtComplex(p,1,'a+bi')+')('+
                 fmtComplex(p,-1,'a+bi')+')')}\\)`;

    const t1 = r*p;            // r√©el
    const t2 = r*(-1);         // i
    const t3 = (q+s)*p;        // i
    const t4 = (q+s)*(-1);     // i¬≤
    const numFOIL = joinTerms([
      {coef:t1, kind:'re'},
      {coef:t2, kind:'i'},
      {coef:t3, kind:'i'},
      {coef:t4, kind:'i2'}
    ]);
    const denPow = `${pow2HTML(p)} + ${pow2HTML(1)}`; // 1¬≤
    const M5 = `\\(z = ${fracOf(numFOIL, denPow)}\\)`;

    const numAfterI2 = joinTerms([
      {coef:t1,  kind:'re'},
      {coef:t2,  kind:'i'},
      {coef:t3,  kind:'i'},
      {coef:-t4, kind:'re'}
    ]);
    const M6 = `\\(z = ${fracOf(numAfterI2, String(D))}\\)`;

    const RR = t1 - t4;        // r*p + (q+s)
    const II = t2 + t3;        // -r + (q+s)*p
    const numRI = joinTerms([{coef:RR,kind:'re'},{coef:II,kind:'i'}]);
    const M7 = `\\(z = ${fracOf(numRI, String(D))}\\)`;

    const parts = [];
    if (RR!==0){ const [x,y]=reduce(RR,D); parts.push((x<0?'‚àí ':'') + fracHTML(Math.abs(x), y)); }
    if (II!==0){
      const [x,y]=reduce(II,D);
      const frag = fracHTML(Math.abs(x),y)+' i';
      parts.push((II>0 && parts.length? ' + ' : (II<0 && parts.length? ' ‚àí ' : (II<0? '‚àí ' : ''))) + frag);
    }
    const M8 = `\\(z = ${parts.join('') || '0'}\\)`;

    showSteps(host,[M0,M1,M2,M3,M4,M5,M6,M7,M8]);
  },

  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};

// ===================== Ex.5 ‚Äî √âquations fractionnelles (3 mod√®les) =====================
const ex5 = {
  id:'cplx5',
  title:'R√©soudre une √©quation (fractionnelle ‚Äî mod√®les)',
  _lastMode:'M1',

  gen(mode){
    function pickABNonZero(){
      let a = rnd(-3,3), b = rnd(-3,3);
      while (a===0 || b===0) { a = rnd(-3,3); b = rnd(-3,3); }
      return {a,b};
    }
    function pickKLDistinct(){
      let k = rnd(-5,5), l = rnd(-5,5);
      while (l === k) l = rnd(-5,5);
      return {k,l};
    }

    const M = mode || this._lastMode || 'M1';
    this._lastMode = M;

    if (M==='M1'){ // (z+k)/(z+l) = a+bi
      const {k,l} = pickKLDistinct(); const w = pickABNonZero();
      const top = 'z ' + (k? (k>0?'+ '+k:'‚àí '+Math.abs(k)) : '');
      const bot = 'z ' + (l? (l>0?'+ '+l:'‚àí '+Math.abs(l)) : '');
      const enonce = `
        <div class="consigne"><strong>Exercice 5 : R√©soudre une √©quation dans ${CC}</strong></div>
        <div style="margin-bottom:.35rem">
          <label><small><b>Mod√®le :</b></small>
            <select id="ex5-model">
              <option value="M1" selected>Mod√®le 1 ‚Äî (z+k)/(z+l) = a + bi</option>
              <option value="M2">Mod√®le 2 ‚Äî (z+ki)/(z+l) = a + bi</option>
              <option value="M3">Mod√®le 3 ‚Äî (z+ki)/(z+li) = a + bi</option>
            </select>
          </label>
        </div>
        <div>R√©soudre dans ${CC} l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
        <div style="margin-top:.25rem">\\(${fracOf(top, bot)} = ${fmtComplex(w.a,w.b)}\\)</div>
      `;
      const r = divC( C(w.a*l - k, w.b*l), C(1-w.a, -w.b) );
      return {mode:'M1', enonce, k, l, w, r};
    }

    if (M==='M2'){ // (z+ki)/(z+l) = a+bi
      const k = rnd(-5,5), l = rnd(-5,5); const w = pickABNonZero();
      const top = 'z ' + (k? (k>0?'+ ':'‚àí ') + (Math.abs(k)===1?'i':Math.abs(k)+'i') : '');
      const bot = 'z ' + (l? (l>0?'+ '+l:'‚àí '+Math.abs(l)) : '');
      const enonce = `
        <div class="consigne"><strong>Exercice 5 : R√©soudre une √©quation dans ${CC}</strong></div>
        <div style="margin-bottom:.35rem">
          <label><small><b>Mod√®le :</b></small>
            <select id="ex5-model">
              <option value="M1">Mod√®le 1 ‚Äî (z+k)/(z+l) = a + bi</option>
              <option value="M2" selected>Mod√®le 2 ‚Äî (z+ki)/(z+l) = a + bi</option>
              <option value="M3">Mod√®le 3 ‚Äî (z+ki)/(z+li) = a + bi</option>
            </select>
          </label>
        </div>
        <div>R√©soudre dans ${CC} l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
        <div style="margin-top:.25rem">\\(${fracOf(top, bot)} = ${fmtComplex(w.a,w.b)}\\)</div>
      `;
      const r = divC( C(w.a*l, w.b*l - k), C(1-w.a, -w.b) );
      return {mode:'M2', enonce, k, l, w, r};
    }

    const {k,l} = pickKLDistinct(); const w = pickABNonZero();
    const top = 'z ' + (k? (k>0?'+ ':'‚àí ') + (Math.abs(k)===1?'i':Math.abs(k)+'i') : '');
    const bot = 'z ' + (l? (l>0?'+ ':'‚àí ') + (Math.abs(l)===1?'i':Math.abs(l)+'i') : '');
    const enonce = `
        <div class="consigne"><strong>Exercice 5 : R√©soudre une √©quation dans ${CC}</strong></div>
      <div style="margin-bottom:.35rem">
        <label><small><b>Mod√®le :</b></small>
          <select id="ex5-model">
            <option value="M1">Mod√®le 1 ‚Äî (z+k)/(z+l) = a + bi</option>
            <option value="M2">Mod√®le 2 ‚Äî (z+ki)/(z+l) = a + bi</option>
            <option value="M3" selected>Mod√®le 3 ‚Äî (z+ki)/(z+li) = a + bi</option>
          </select>
        </label>
      </div>
      <div>R√©soudre dans ${CC} l‚Äô√©quation suivante et donner la solution sous forme alg√©brique.</div>
      <div style="margin-top:.25rem">\\(${fracOf(top, bot)} = ${fmtComplex(w.a,w.b)}\\)</div>
    `;
    const r = divC( C(-w.b*l, w.a*l - k), C(1-w.a, -w.b) );
    return {mode:'M3', enonce, k, l, w, r};
  },

  render(host, st){
renderSimple(host, st.enonce, {id:'ans', label:'z =', placeholder:'a + bi', labelHTML:'\\(z =\\)'});    const sel = host.querySelector('#ex5-model');
    if (sel){
      sel.value = st.mode;
      sel.addEventListener('change', ()=>{
        const next = ex5.gen(sel.value);
        host.dataset.active = ex5.id;
        host.dataset.state  = JSON.stringify(next);
        ex5.render(host, next);
      });
    }
  },

  correct(host, st){
    const el = host.querySelector('#ans');
    if(!el || !el.value.trim()) return {ok:false,total:0};
    const ok = eqComplexStr(el.value, st.r.a, st.r.b);
    setTick(host, 'ans', ok ? '‚úî' : '‚úò');
    return {ok,total:1};
  },

  solution(host, st){
    const pow2HTML = n => { const t=String(fmtNum(n)).replace(/[\u00A0\u202F\u2009\s]+/g,''); return (n<0?`(${t})`:t)+'^{2}'; };
    const zPlusReal = t => t ? ('z ' + (t>0?'+ '+t:'‚àí '+Math.abs(t))) : 'z';
    const zPlusImag = t => t ? ('z ' + (t>0?'+ ':'‚àí ') + (Math.abs(t)===1?'i':Math.abs(t)+'i')) : 'z';

    function addTerm(s,k,unit){
      if(!k) return s;
      const first = (s==='');
      const sign  = k<0 ? (first?'‚àí ':' ‚àí ') : (first?'':' + ');
      const m = Math.abs(k);
      let body='';
      if(unit==='z')   body = (m===1? 'z' : m+'z');
      else if(unit==='iz') body = (m===1? 'iz': m+'iz');
      else if(unit==='i')  body = (m===1? 'i' : m+'i');
      else if(unit==='i2') body = (m===1? 'i^{2}' : m+'i^{2}');
      else body = String(m);
      return s + sign + body;
    }
    function dev_z_plus_li_noI2(a,b,l){
      let s='';
      s = addTerm(s, a,   'z');
      s = addTerm(s, a*l, 'i');
      s = addTerm(s, b,   'iz');
      s = addTerm(s, -b*l,'');
      return s || '0';
    }
    // Ajout local : d√©veloppement (a+bi)(z + l) pour cette section
    const dev_z_plus_l = (a,b,l)=>{
      let s='';
      s = addTerm(s, a,   'z');
      s = addTerm(s, a*l, '');
      s = addTerm(s, b,   'iz');
      s = addTerm(s, b*l, 'i');
      return s||'0';
    };

    function leftZCombo(a,b){ let s=''; s=addTerm(s,1-a,'z'); s=addTerm(s,-b,'iz'); return s||'0'; }
    function leftZFact(a,b){ let inside=''; inside=addTerm(inside,1-a,''); inside=addTerm(inside,-b,'i'); return `z(${inside})`; }
    const joinTerms = parts => { let out=''; for(const {coef,kind} of parts){ if(!coef) continue; out = addTerm(out, coef, (kind==='re'?'':kind)); } return out || '0'; };
    function finalAplusBi(R,I,D){
  const p = [];
  if (R) {
    const [rx,ry] = reduce(R,D);
    p.push((R<0?'‚àí ':'') + fracHTML(Math.abs(rx), ry));
  }
  if (I) {
    const [ix,iy] = reduce(I,D);
    p.push((I>0 && p.length ? ' + ' : (I<0 && p.length ? ' ‚àí ' : (I<0 ? '‚àí ' : '')))
           + fracHTML(Math.abs(ix), iy) + ' i');
  }
  return p.join('') || '0';
};
    const dev_z_plus_li = (a,b,l,withI2=true)=>{ let s=''; s=addTerm(s,a,'z'); s=addTerm(s,a*l,'i'); s=addTerm(s,b,'iz'); s=addTerm(s,b*l,withI2?'i2':''); return s||'0'; };

    const denCoefs = (a,b)=>({c1:1-a, c2:-b});
    const denStr   = (c1,c2)=> joinTerms([{coef:c1,kind:'re'},{coef:c2,kind:'i'}]);
    const conjStr  = (c1,c2)=> joinTerms([{coef:c1,kind:'re'},{coef:-c2,kind:'i'}]);

    const showM1 = ()=>{
      const {k,l,w:{a,b}} = st; const {c1,c2}=denCoefs(a,b);
      const H  = `<div><em>Pour tout</em> \\(z \\ne ${fmtNum(-l)}\\), on a :</div>`;
      const L1 = `\\(${fracOf(zPlusReal(k), zPlusReal(l))} = ${fmtComplex(a,b)}\\)`;
      const L2 = `\\(z ${k?(k>0?'+ '+k:'‚àí '+Math.abs(k)):''} = (${fmtComplex(a,b)})(z ${l?(l>0?'+ '+l:'‚àí '+Math.abs(l)):''})\\)`;
      const L3 = `\\(z ${k?(k>0?'+ '+k:'‚àí '+Math.abs(k)):''} = ${dev_z_plus_l(a,b,l)}\\)`;

      const Nre = a*l - k, Nim = b*l;
      const L4  = `\\(${leftZCombo(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}\\)`;
      const steps = [H,L1,L2,L3,L4];
      if(c1!==0 && c2!==0){
        steps.push(`\\(${leftZFact(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}\\)`);
      }

      const NumStr = joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}]);
      const L5 = `\\(z = ${fracOf(NumStr, denStr(c1,c2))}\\)`;
      const L6 = `\\(z = ${fracOf(`(${NumStr})(${conjStr(c1,c2)})`, `(${denStr(c1,c2)})(${conjStr(c1,c2)})`)}\\)`;

      const foil = joinTerms([
        {coef:Nre*c1, kind:'re'},
        {coef:Nre*(-c2), kind:'i'},
        {coef:Nim*c1, kind:'i'},
        {coef:Nim*(-c2), kind:'i2'}
      ]);
      const L7  = `\\(z = ${fracOf(foil, `${pow2HTML(c1)} + ${pow2HTML(c2)}`)}\\)`;
      const foilNoI2 = joinTerms([
        {coef:Nre*c1,   kind:'re'},
        {coef:Nre*(-c2),kind:'i'},
        {coef:Nim*c1,   kind:'i'},
        {coef:-(Nim*(-c2)), kind:'re'}
      ]);
      const D = c1*c1 + c2*c2;
      const L7b = `\\(z = ${fracOf(foilNoI2, String(D))}\\)`;

      const R = Nre*c1 + Nim*c2, I = Nre*(-c2) + Nim*c1;
      const L9  = `\\(z = ${fracOf(joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]), String(D))}\\)`;
      const L10 = `\\(z = ${finalAplusBi(R,I,D)}\\)`;
      showSteps(host, [...steps, L5, L6, L7, L7b,  L9, L10]);
    };

    const showM2 = ()=>{
      const {k,l,w:{a,b}} = st; const {c1,c2}=denCoefs(a,b);
      const H  = `<div><em>Pour tout</em> \\(z \\ne ${fmtNum(-l)}\\), on a :</div>`;
      const L1 = `\\(${fracOf(zPlusImag(k), zPlusReal(l))} = ${fmtComplex(a,b)}\\)`;
      const L2 = `\\(z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = (${fmtComplex(a,b)})(z ${l?(l>0?'+ '+l:'‚àí '+Math.abs(l)):''})\\)`;
      const L3 = `\\(z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = ${dev_z_plus_l(a,b,l)}\\)`;

      const Nre = a*l, Nim = b*l - k;
      const L4  = `\\(${leftZCombo(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}\\)`;
      const steps = [H,L1,L2,L3,L4];
      if(c1!==0 && c2!==0){
        steps.push(`\\(${leftZFact(a,b)} = ${joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}])}\\)`);
      }

      const NumStr = joinTerms([{coef:Nre,kind:'re'},{coef:Nim,kind:'i'}]);
      const L5 = `\\(z = ${fracOf(NumStr, denStr(c1,c2))}\\)`;
      const L6 = `\\(z = ${fracOf(`(${NumStr})(${conjStr(c1,c2)})`, `(${denStr(c1,c2)})(${conjStr(c1,c2)})`)}\\)`;

      const foil = joinTerms([
        {coef:Nre*c1, kind:'re'},
        {coef:Nre*(-c2), kind:'i'},
        {coef:Nim*c1, kind:'i'},
        {coef:Nim*(-c2), kind:'i2'}
      ]);
      const L7  = `\\(z = ${fracOf(foil, `${pow2HTML(c1)} + ${pow2HTML(c2)}`)}\\)`;
      const foilNoI2 = joinTerms([
        {coef:Nre*c1,   kind:'re'},
        {coef:Nre*(-c2),kind:'i'},
        {coef:Nim*c1,   kind:'i'},
        {coef:-(Nim*(-c2)), kind:'re'}
      ]);
      const D = c1*c1 + c2*c2;
      const L7b = `\\(z = ${fracOf(foilNoI2, String(D))}\\)`;

      const R = Nre*c1 + Nim*c2, I = Nre*(-c2) + Nim*c1;
      const L9  = `\\(z = ${fracOf(joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]), String(D))}\\)`;
      const L10 = `\\(z = ${finalAplusBi(R,I,D)}\\)`;
      showSteps(host, [...steps, L5, L6, L7, L7b,  L9, L10]);
    };

    const showM3 = ()=>{
      const {k,l,w:{a,b}} = st; const {c1,c2}=denCoefs(a,b);
      const H  = `<div><em>Pour tout</em> \\(z \\ne ${fmtNum(-l)}i\\), on a :</div>`;
      const L1 = `\\(${fracOf(zPlusImag(k), zPlusImag(l))} = ${fmtComplex(a,b)}\\)`;
      const L2 = `\\(z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = (${fmtComplex(a,b)})(z ${l?(l>0?'+ ':'‚àí ')+(Math.abs(l)===1?'i':Math.abs(l)+'i'):''})\\)`;
      const L3 = `\\(z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = ${dev_z_plus_li(a,b,l,true)}\\)`;
      const L3b = `\\(z ${k?(k>0?'+ ':'‚àí ')+(Math.abs(k)===1?'i':Math.abs(k)+'i'):''} = ${dev_z_plus_li_noI2(a,b,l)}\\)`;

      const RHSre = -b*l, RHSim = a*l - k;
      const L4  = `\\(${leftZCombo(a,b)} = ${joinTerms([{coef:RHSre,kind:'re'},{coef:RHSim,kind:'i'}])}\\)`;
      const steps = [H,L1,L2,L3,L3b,L4];
      if(c1!==0 && c2!==0){
        steps.push(`\\(${leftZFact(a,b)} = ${joinTerms([{coef:RHSre,kind:'re'},{coef:RHSim,kind:'i'}])}\\)`);
      }

      const NumStr = joinTerms([{coef:RHSre,kind:'re'},{coef:RHSim,kind:'i'}]);
      const L5 = `\\(z = ${fracOf(NumStr, denStr(c1,c2))}\\)`;
      const L6 = `\\(z = ${fracOf(`(${NumStr})(${conjStr(c1,c2)})`, `(${denStr(c1,c2)})(${conjStr(c1,c2)})`)}\\)`;

      const foil = joinTerms([
        {coef:RHSre*c1, kind:'re'},
        {coef:RHSre*(-c2), kind:'i'},
        {coef:RHSim*c1, kind:'i'},
        {coef:RHSim*(-c2), kind:'i2'}
      ]);
      const L7  = `\\(z = ${fracOf(foil, `${pow2HTML(c1)} + ${pow2HTML(c2)}`)}\\)`;
      const foilNoI2 = joinTerms([
        {coef:RHSre*c1,   kind:'re'},
        {coef:RHSre*(-c2),kind:'i'},
        {coef:RHSim*c1,   kind:'i'},
        {coef:-(RHSim*(-c2)), kind:'re'}
      ]);
      const D = c1*c1 + c2*c2;
      const L7b = `\\(z = ${fracOf(foilNoI2, String(D))}\\)`;

      const R = RHSre*c1 + RHSim*c2, I = RHSre*(-c2) + RHSim*c1;
      const L9  = `\\(z = ${fracOf(joinTerms([{coef:R,kind:'re'},{coef:I,kind:'i'}]), String(D))}\\)`;
      const L10 = `\\(z = ${finalAplusBi(R,I,D)}\\)`;
      showSteps(host, [...steps, L5, L6, L7, L7b,  L9, L10]);
    };

    if (st.mode==='M1') return showM1();
    if (st.mode==='M2') return showM2();
    showM3();
  },

  reset(host){ const el=host.querySelector('#ans'); if(el) el.value=''; setTick(host,'ans',''); $('#res',host).textContent=''; }
};


/* ===== Registry & m√©canique ===== */
const REGISTRY=[ex1,ex2,ex3,ex4,ex5];
window.REGISTRY=REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(state);
  def.render(host,state);
  $('#res',host).textContent='';
  host.querySelectorAll('.tick').forEach(x=>x.textContent='');
  typesetAll(host);
}
function check(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); const r=def.correct(host,st); scoreTot+=r.total; scoreOK+=r.ok?1:0; updateScore(); typesetAll(host); }
function solution(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); typesetAll(host); }
function resetAll(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.reset(host,st); typesetAll(host); }

/* ==== Init ==== */
whenReady(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map(e=>'<option value="'+e.id+'">'+e.title+'</option>').join('');
  sel.addEventListener('change', buildOne);
  $("#btn-new").addEventListener('click', buildOne);
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  buildOne();

  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: '1STI2D ‚Äì Nombres complexes ‚Äî Forme alg√©brique, conjugu√©, inverse, quotient (LaTeX)',
      max: 50,
      lead: '',
      leadByDefId: { cplx1:'', cplx2:'', cplx3:'', cplx4:'', cplx5:'' },
      mountAfterSelector: '.card.small'
    });
  }
});

window.addEventListener('load', ()=> { if (window.MathJax && MathJax.startup && MathJax.startup.promise) { MathJax.startup.promise.then(()=>typesetAll(document)); } else { typesetAll(document); } }, {once:true});

/* ===== Accessibilit√© t√©l√©phone : agrandir les cibles drag si pr√©sent (h√©ritage) ===== */
window.addEventListener('pointerdown', ()=>{
  const coarse = matchMedia('(pointer:coarse)').matches;
  if (!coarse) return;
  document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
    const r = parseFloat(c.getAttribute('r')||'5');
    if (r < 10) c.setAttribute('r', String(12));
    c.style.touchAction='none';
  });
}, {passive:true});
</script>
</body>
</html>
