<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>1STI2D â€“ Nombres complexes : Affixe & forme algÃ©brique</title>
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">
<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{background:#efefef}
.score{font-weight:700}
.small{font-size:.92rem;color:#666}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
</style>
  <script src="../../../../js/math-kbd.js" defer></script>
  <script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
  <script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>
<!-- MathJax -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D â€“ <strong>Nombres complexes : Affixe & forme algÃ©brique</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
      <span id="status" class="small"></span>
    </div>

    <div class="controls card" id="ampbar">
      <strong>Amplitude du repÃ¨re (max Â±12) :</strong>
      <span>x âˆˆ [</span><input id="xmin" type="number" value="-6" min="-12" max="12" step="1"><span>;</span>
      <input id="xmax" type="number" value="6"  min="-12" max="12" step="1"><span>],</span>
      <span>y âˆˆ [</span><input id="ymin" type="number" value="-6" min="-12" max="12" step="1"><span>;</span>
      <input id="ymax" type="number" value="6"  min="-12" max="12" step="1"><span>]</span>
      
      <strong style="margin-left:16px">Nombre dâ€™objets :</strong>
      <input id="nbPts" type="number" value="3" min="3" max="10" step="1" style="width:80px">
      <label class="small"><input id="nbPts-random" type="checkbox"> Nombre alÃ©atoire (par Ã©noncÃ©)</label>
    </div>

    <div class="card" id="host" aria-live="polite"></div>

    <div class="card small">
      <strong>Saisie & rÃ©ponses acceptÃ©es :</strong>
      <ul style="margin:8px 0 0 18px">
        <li>Affixe au format \(a + b\,i\). On accepte aussi \(a - b\,i\), \(i\), \(-i\), \(a\), ou \((x;y)\).</li>
        <li>Pour l'exercice 3 : il faut cliquer Ã  l'emplacement de l'extrÃ©minitÃ© de la flÃ¨che du vecteur pour le faire apparaitre</li>
      </ul>
    </div>
  </div>

<script>
(function(){'use strict';

/* ===== Palette couleurs ===== */
const PALETTE = ['#0a84ff','#d32f2f','#2e7d32','#6a1b9a','#f57c00','#00897b','#c62828','#6d4c41','#ad1457','#283593','#0277bd'];
const colorOfIndex = i => PALETTE[i % PALETTE.length];

/* ===== Utils ===== */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const UMINUS='âˆ’';
const normalizeMinus = s => String(s||'').split('-').join(UMINUS).replace(/\s+/g,' ').trim();
const uminusStr = n => (n<0?UMINUS:'')+Math.abs(n);
const L = tex => '\\(' + tex + '\\)';
const unwrapL = s => String(s||'').startsWith('\\(') ? s.slice(2,-2) : s;
function setTick(el, state){
  const node = (typeof el==='string') ? document.getElementById(el) : el;
  if(!node) return;
  node.textContent = state==='ok' ? 'âœ”' : (state==='ko' ? 'âœ˜' : '');
  node.className = 'tick ' + (state||'');
}

/* ===== MathJax helper ===== */
function MJ(el){
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}

/* ===== Parsing ===== */
function parseCoord(txt){
  txt=normalizeMinus(txt);
  const re = new RegExp('^\\(\\s*([0-9]+|(?:\\u2212[0-9]+))\\s*;\\s*([0-9]+|(?:\\u2212[0-9]+))\\s*\\)$');
  const m=txt.match(re);
  if(!m) return null;
  return { x:parseInt(m[1].replace(UMINUS,'-'),10), y:parseInt(m[2].replace(UMINUS,'-'),10) };
}
function parseComplex(txt){
  if(!txt && txt!==0) return null;
  let s = normalizeMinus(String(txt)).replace(/\s+/g,'');
  s = s.replace(/I/g,'i');
  const c = parseCoord(s); if (c) return {a:c.x, b:c.y};
  if(!s) return null;
  let m = s.match(/^([+\u2212-]?\d+)([+\u2212-]\d*)?i?$/);
  if(m){
    const A = parseInt(m[1].replace(UMINUS,'-'),10);
    if(m[2]==null){
      if(/i$/.test(s)){ const B = parseInt(m[1].replace(UMINUS,'-'),10); return {a:0,b:B}; }
      return {a:A,b:0};
    }
  }
  m = s.match(/^([+\u2212-]?\d+)([+\u2212])(\d*)i$/);
  if(m){
    const A = parseInt(m[1].replace(UMINUS,'-'),10);
    const sgn = m[2]===UMINUS||m[2]==='-' ? -1 : 1;
    const B = m[3]==='' ? 1 : parseInt(m[3],10);
    return {a:A,b:sgn*B};
  }
  m = s.match(/^([+\u2212-]?)(\d*)i([+\u2212-]\d+)?$/);
  if(m){
    const s1 = (m[1]===UMINUS||m[1]==='-') ? -1 : 1;
    const B = (m[2]===''?1:parseInt(m[2],10))*s1;
    const A = m[3] ? parseInt(m[3].replace(UMINUS,'-'),10) : 0;
    return {a:A,b:B};
  }
  if(s==='i'||s==='+i') return {a:0,b:1};
  if(s===UMINUS+'i' || s==='-i') return {a:0,b:-1};
  m = s.match(/^([+\u2212-]?\d+)i$/);
  if(m) return {a:0, b:parseInt(m[1].replace(UMINUS,'-'),10)};
  return null;
}

/* ===== Affixe â†’ LaTeX ===== */
function affixeToLatex(z){
  const a=z.a|0, b=z.b|0;
  if(b===0) return L(`${uminusStr(a)}`);
  if(a===0){
    if(b===1) return L('i');
    if(b===-1) return L(UMINUS+'i');
    return L(`${uminusStr(b)}\\,i`);
  }
  const sgn = b<0 ? ' âˆ’ ' : ' + ';
  const B = Math.abs(b)===1 ? '' : Math.abs(b)+'';
  return L(`${uminusStr(a)}${sgn}${B}i`);
}

/* ===== RepÃ¨re ===== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.points=[]; this.user=[]; this.vectors=[]; this.userVectors=[];
    this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const ns = 'http://www.w3.org/2000/svg';
    const s  = document.createElementNS(ns,'svg');
    s.setAttribute('class','svgbox');
    s.setAttribute('viewBox','0 0 420 420');
    s.setAttribute('preserveAspectRatio','xMidYMid meet');

    const defs = document.createElementNS(ns,'defs');
    const marker = document.createElementNS(ns,'marker');
    marker.setAttribute('id','arrow');
    marker.setAttribute('markerUnits','strokeWidth');
    marker.setAttribute('markerWidth','6');
    marker.setAttribute('markerHeight','4');
    marker.setAttribute('refX','5');
    marker.setAttribute('refY','2');
    marker.setAttribute('orient','auto');
    const arrowPath = document.createElementNS(ns,'path');
    arrowPath.setAttribute('d','M0,0 L6,2 L0,4 z');
    arrowPath.setAttribute('fill','#000');
    marker.appendChild(arrowPath); defs.appendChild(marker); s.appendChild(defs);

    this.gGrid=document.createElementNS(ns,'g'); s.appendChild(this.gGrid);
    this.gAxes=document.createElementNS(ns,'g'); s.appendChild(this.gAxes);
    this.gPts=document.createElementNS(ns,'g'); s.appendChild(this.gPts);
    this.gVec=document.createElementNS(ns,'g'); s.appendChild(this.gVec);
    this.gUser=document.createElementNS(ns,'g'); s.appendChild(this.gUser);
    this.gUserVec=document.createElementNS(ns,'g'); s.appendChild(this.gUserVec);

    const handleTap = (ev) => {
      if(!this.clickable) return;
      const r  = s.getBoundingClientRect();
      const vb = s.viewBox?.baseVal || {x:0,y:0,width:420,height:420};
      const cx = ('clientX' in ev ? ev.clientX : ev.touches?.[0]?.clientX);
      const cy = ('clientY' in ev ? ev.clientY : ev.touches?.[0]?.clientY);
      const x = (cx - r.left) * (vb.width  / r.width);
      const y = (cy - r.top)  * (vb.height / r.height);
      const c = this.screenToCoord(x,y);
      const lim = this.innerLimits();
      const xi  = Math.round(c.x), yi = Math.round(c.y);
      if (xi < lim.xmin || xi > lim.xmax || yi < lim.ymin || yi > lim.ymax) return;
      if (this.onClick) this.onClick({x:xi,y:yi});
    };
    s.addEventListener('pointerdown', (ev)=>{ if (ev.pointerType==='touch') ev.preventDefault(); handleTap(ev); }, {passive:false});
    s.addEventListener('click', handleTap, {passive:true});
    return s;
  }
  innerLimits(){ const R=this.R; return {xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; }
  basis(){
    const w=420,h=420,m=24;
    const X=this.R.xmax-this.R.xmin, Y=this.R.ymax-this.R.ymin;
    const Sx = (w-2*m)/X, Sy = (h-2*m)/Y;
    const O = { x:m - this.R.xmin*Sx, y:h-m + this.R.ymin*Sy };
    return {O,Sx,Sy,w,h,m};
  }
  coordToScreen(x,y){ const {O,Sx,Sy}=this.basis(); return {x:O.x + x*Sx, y:O.y - y*Sy}; }
  screenToCoord(px,py){ const {O,Sx,Sy}=this.basis(); return {x:(px-O.x)/Sx, y:-(py-O.y)/Sy}; }

  setPoints(arr){ this.points=arr||[]; this.redraw(); }
  setVectors(arr){ this.vectors=arr||[]; this.redraw(); }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  clearUserVectors(){ this.userVectors=[]; this.gUserVec.innerHTML=''; }

  _latexFO(html, x, y, color='#000'){
    const fo=document.createElementNS(this.el.namespaceURI,'foreignObject');
    fo.setAttribute('x', x); fo.setAttribute('y', y); fo.setAttribute('width', 110); fo.setAttribute('height', 26);
    const div=document.createElementNS('http://www.w3.org/1999/xhtml','div');
    div.style.fontSize='13px'; div.style.fontWeight='700'; div.style.color=color;
    div.innerHTML = html;
    fo.appendChild(div);
    return fo;
  }
  
    _dot(px, py, label, color = '#000'){
    const g = document.createElementNS(this.el.namespaceURI,'g');
    const c = document.createElementNS(this.el.namespaceURI,'circle');
    c.setAttribute('cx', px);
    c.setAttribute('cy', py);
    c.setAttribute('r', 4.2);
    c.setAttribute('fill', color);
    g.appendChild(c);
    if(label){
      const t = document.createElementNS(this.el.namespaceURI,'text');
      t.setAttribute('x', px + 6);
      t.setAttribute('y', py - 6);
      t.setAttribute('font-size', '13');
      t.textContent = label;
      g.appendChild(t);
    }
    return g;
  }

  redraw(){
  const R=this.R;
  this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gPts.innerHTML=''; this.gVec.innerHTML='';

  const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',x1);L.setAttribute('y1',y1);L.setAttribute('x2',x2);L.setAttribute('y2',y2);
    L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); return L; };

  // grille
  for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
  for(let t=R.ymin;t<=R.ymax;t++){ const p1=this.coordToScreen(R.xmin,t), p2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }

  // axes
  const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
  const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
  axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);

  // O, u, v
  const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
  // point O
  this.gAxes.appendChild(this._dot(O.x,O.y,'O'));
  // flÃ¨che de u : O -> (1;0)
  const uLn=document.createElementNS(this.el.namespaceURI,'line');
  uLn.setAttribute('x1',O.x); uLn.setAttribute('y1',O.y); uLn.setAttribute('x2',I.x); uLn.setAttribute('y2',I.y);
  uLn.setAttribute('stroke','#000'); uLn.setAttribute('stroke-width','2'); uLn.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(uLn);
  // flÃ¨che de v : O -> (0;1)
  const vLn=document.createElementNS(this.el.namespaceURI,'line');
  vLn.setAttribute('x1',O.x); vLn.setAttribute('y1',O.y); vLn.setAttribute('x2',J.x); vLn.setAttribute('y2',J.y);
  vLn.setAttribute('stroke','#000'); vLn.setAttribute('stroke-width','2'); vLn.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(vLn);
  // labels LaTeX
  this.gAxes.appendChild(this._latexFO('\\(\\vec u\\)', I.x+6, I.y-18));
  this.gAxes.appendChild(this._latexFO('\\(\\vec v\\)', J.x+6, J.y-18));
  

  // points fixes
  for(const p of this.points){
    const P=this.coordToScreen(p.x,p.y);
    const g=document.createElementNS(this.el.namespaceURI,'g');
    const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); c.setAttribute('r',4.2); c.setAttribute('fill',p.fill||'#000'); g.appendChild(c);
    if(p.label){ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6); t.setAttribute('font-size','13'); t.textContent=p.label; g.appendChild(t); }
    this.gPts.appendChild(g);
  }

  // vecteurs fixes
  for(const v of this.vectors){
    const p1=this.coordToScreen(v.x1,v.y1), p2=this.coordToScreen(v.x2,v.y2);
    const ln=document.createElementNS(this.el.namespaceURI,'line'); ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y); ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
    ln.setAttribute('stroke',v.stroke||'#000'); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrow)'); this.gVec.appendChild(ln);
    if(v.label){ this.gVec.appendChild(this._latexFO(`\\(\\vec v_{${v.label.replace('v','')}}\\)`, p2.x+6, p2.y-18, v.stroke||'#000')); }
  }

  // re-typeset pour les foreignObjects
  MJ(this.el.parentNode||document.body);
}


  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){ g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','13'); t.setAttribute('font-weight','700'); t.setAttribute('fill',color); t.textContent=label;
      g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g);
    }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }

  placeUserVector(label,x1,y1,x2,y2,color='#0a84ff'){
    let g=this.gUserVec.querySelector(`g[data-vlabel="${label}"]`);
    if(!g){
      g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.vlabel=label;
      const ln=document.createElementNS(this.el.namespaceURI,'line'); ln.setAttribute('stroke',color); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrow)');
      const fo=this._latexFO(`\\(\\vec v_{${label.replace('v','')}}\\)`, 0, 0, color);
      g.appendChild(ln); g.appendChild(fo); this.gUserVec.appendChild(g);
    }
    const p1=this.coordToScreen(x1,y1), p2=this.coordToScreen(x2,y2);
    const ln=g.querySelector('line'), fo=g.querySelector('foreignObject');
    ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y); ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
    if(fo){ fo.setAttribute('x', p2.x+6); fo.setAttribute('y', p2.y-18); }
    const i=this.userVectors.findIndex(v=>v.label===label);
    const rec={label,x1,y1,x2,y2}; if(i>=0) this.userVectors[i]=rec; else this.userVectors.push(rec);
    MJ(this.el.parentNode||document.body);
  }
}

/* ===== UI helpers ===== */
function renderWithRepere(host,opts){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const left=document.createElement('div'); const right=document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);
  const rep=new Repere(opts.R||AMP);
  left.appendChild(rep.el);
  const equ=document.createElement('div'); right.appendChild(equ);
  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  return {rep,left,right,equ,actions,res};
}

const AMP={xmin:-6,xmax:6,ymin:-6,ymax:6};
function applyAMPInputs(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  xi=clamp(isNaN(xi)?-6:xi,-12,12); xa=clamp(isNaN(xa)?6:xa,-12,12);
  yi=clamp(isNaN(yi)?-6:yi,-12,12); ya=clamp(isNaN(ya)?6:ya,-12,12);
  if(xi===xa) xa=clamp(xi+1,-12,12); if(yi===ya) ya=clamp(yi+1,-12,12);
  if(xi>xa) [xi,xa]=[xa,xi]; if(yi>ya) [yi,ya]=[ya,yi];
  Object.assign(AMP,{xmin:xi,xmax:xa,ymin:yi,ymax:ya});
  ['xmin','xmax','ymin','ymax'].forEach(id=>$('#'+id).value=AMP[id]);
}
function getNbPts(){
  const nbEl=document.getElementById('nbPts');
  const min=parseInt((nbEl?.min)||'3',10), max=parseInt((nbEl?.max)||'10',10);
  const v=parseInt((nbEl?.value)||'3',10);
  return clamp(isNaN(v)?3:v, min, max);
}

/* ===== Utilitaire PDF : forcer la taille du SVG (300Ã—300) ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }

/* ===== Exercices ===== */
function makeExos(){ const LST=[];

/* 1) Placer des points connaissant leur affixe */
LST.push({ id:'aff_pts_place', title:'Placer des points connaissant leur affixe',
  gen(){ const R={...AMP}; const n=getNbPts(); const pts=[]; const seen=new Set();
       while(pts.length<n){ const x=rnd(R.xmin+1,R.xmax-1), y=rnd(R.ymin+1,R.ymax-1); const k=x+';'+y; if(!seen.has(k)){ seen.add(k); pts.push({x,y}); } }
       const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0,n).split(''); return {R,PTS:pts.map((p,i)=>({label:labels[i],...p}))}; },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R}); ui.rep.setPoints([]);
    const list = s.PTS.map(p=>('z_{'+p.label+'} = '+unwrapL(affixeToLatex({a:p.x,b:p.y})))).map(L).join(' ; ');
    ui.equ.innerHTML = `<p>Placer sur le repÃ¨re les points dâ€™affixes :</p> <p>${list}.</p>`; MJ(ui.equ);
    const chips=document.createElement('div'); chips.className='chips'; chips.innerHTML='<span>Ã€ placer :</span>'; ui.actions.appendChild(chips);
const labels = s.PTS.map(p=>p.label), chipEls=[]; let current=labels[0];
for(let i=0;i<labels.length;i++){
  const Lb=labels[i]; const wrap=document.createElement('div'); wrap.className='chipwrap';
  const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=Lb; sp.innerHTML = `<span class="dot" style="background:${colorOfIndex(i)}"></span>${Lb}`;
  const tk=document.createElement('span'); tk.className='tick'; tk.id='tk_'+Lb; tk.style.color=colorOfIndex(i);
  wrap.appendChild(sp); wrap.appendChild(tk); chips.appendChild(wrap); chipEls.push(sp);
}
function setCurrent(l){ current=l; chipEls.forEach(c=>c.classList.toggle('active',c.dataset.l===l)); }
    chipEls.forEach(c=>c.addEventListener('click',()=>setCurrent(c.dataset.l))); setCurrent(current);
    ui.rep.clickable=true; ui.rep.onClick=({x,y})=>{ ui.rep.placeUser(current,x,y, colorOfIndex(labels.indexOf(current))); };
    host.dataset.state=JSON.stringify(s); host._ui=ui; MJ(chips);
  },
correct(host,s){
  let okCount=0, attempted=0;
  const placed = (host._ui.rep.user||[]);
  const byLabel = Object.fromEntries(placed.map(u=>[u.label,u]));
  for(let i=0;i<s.PTS.length;i++){
    const p=s.PTS[i];
    const u=byLabel[p.label];
    const tk=document.getElementById('tk_'+p.label);
    if(!u){ if(tk){ tk.textContent=''; tk.className='tick'; tk.style.color=colorOfIndex(i);} continue; }
    const ok = (u.x===p.x && u.y===p.y);
    if(tk){ tk.textContent = ok ? 'âœ”' : 'âœ˜'; tk.className='tick'; tk.style.color=colorOfIndex(i); }
    attempted++; if(ok) okCount++;
  }
  // â›”ï¸ ne pas afficher les points corrects ici
  host._ui.res.textContent = `${okCount} / ${attempted}`;
  host._ui.res.className = (attempted>0 && okCount===attempted)?'res-ok':'res-ko';
  return { okCount, attempted };
},

  solution(host,s){
    // ðŸ‘‰ Solution visuelle : points exacts dans le repÃ¨re
    const ptsCorr = s.PTS.map((p,i)=>({x:p.x,y:p.y,label:p.label,fill:colorOfIndex(i)}));
    host._ui.rep.setPoints(ptsCorr);
    const sol = s.PTS.map(p=>('z_{'+p.label+'} = '+unwrapL(affixeToLatex({a:p.x,b:p.y})))).map(L).join(' ; ');
    host._ui.res.innerHTML = `<div class="steps"><div class="step">${sol}</div></div>`; MJ(host._ui.res);
  },
  reset(host){ host._ui?.rep?.clearUser(); const r=$('#res',host); if(r) r.textContent=''; },
  /* ===== PDF ===== */
  pdfStatement(s){
    const r = new Repere(s.R);
    const html = shrinkSVG(r.el.outerHTML, 300); // taille 300Ã—300 inspirÃ©e du fichier LATEX
    const list = s.PTS.map(p=>('z_{'+p.label+'} = '+unwrapL(affixeToLatex({a:p.x,b:p.y})))).map(L).join(' ; ');
    return `<div><div class="hint">Placer sur le repÃ¨re les points dâ€™affixes : ${list}.</div>${html}</div>`;
  },
  pdfSolution(s){
    const r = new Repere(s.R);
    r.setPoints(s.PTS.map((p,i)=>({x:p.x,y:p.y,label:p.label,fill:colorOfIndex(i)})));
    const html = shrinkSVG(r.el.outerHTML, 300);
    const sol = s.PTS.map(p=>('z_{'+p.label+'} = '+unwrapL(affixeToLatex({a:p.x,b:p.y})))).map(L).join(' ; ');
    return `<div><div class="hint">Positions exactes :</div>${html}<div class="steps"><div class="step">${sol}</div></div></div>`;
  }
});

/* 2) Lire lâ€™affixe de points */
LST.push({ id:'aff_pts_read', title:'Lire lâ€™affixe de points',
  gen(){
  const R = {...AMP};
  const n = getNbPts();
  const pts = [];
  const seen = new Set();
  const forbidden = new Set(['0;0', '1;0', '0;1']);
  const lim = { xmin:R.xmin+1, xmax:R.xmax-1, ymin:R.ymin+1, ymax:R.ymax-1 };

  // tirage alÃ©atoire en Ã©vitant doublons + points interdits
  let tries = 0;
  while (pts.length < n && tries++ < 5000){
    const x = rnd(lim.xmin, lim.xmax);
    const y = rnd(lim.ymin, lim.ymax);
    const k = x+';'+y;
    if (seen.has(k) || forbidden.has(k)) continue;
    seen.add(k);
    pts.push({x,y});
  }

  // fallback dÃ©terministe si l'amplitude est trop serrÃ©e
  if (pts.length < n){
    for (let X=lim.xmin; X<=lim.xmax && pts.length<n; X++){
      for (let Y=lim.ymin; Y<=lim.ymax && pts.length<n; Y++){
        const k = X+';'+Y;
        if (seen.has(k) || forbidden.has(k)) continue;
        seen.add(k);
        pts.push({x:X,y:Y});
      }
    }
  }

  const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0,n).split('');
  return { R, PTS: pts.map((p,i)=>({label:labels[i], ...p})) };
},

  render(host,s){ const ui=renderWithRepere(host,{R:s.R}); ui.rep.setPoints(s.PTS);
    ui.equ.innerHTML = `<p>Par lecture graphique, donner les affixes ${s.PTS.map(p=>L('z_{'+p.label+'}')).join(', ')} des points ${s.PTS.map(p=>L(p.label)).join(', ')}.</p>`; MJ(ui.equ);
    for(const p of s.PTS){
      const d=document.createElement('div'); d.style.display='flex'; d.style.flexDirection='column'; d.style.gap='2px';
      const top=document.createElement('div'); top.style.display='flex'; top.style.gap='8px'; top.style.alignItems='center';
      const lbl=document.createElement('span'); lbl.innerHTML=L(`z_{${p.label}} =`); const inp=document.createElement('input'); inp.id=`ans_${p.label}`; inp.type='text'; inp.placeholder='a + b i';
      const tk=document.createElement('div'); tk.className='indline'; tk.innerHTML=`<span class="lbl"></span><span class="tick" id="tk_${p.label}"></span>`;
      top.appendChild(lbl); top.appendChild(inp); d.appendChild(top); d.appendChild(tk); ui.actions.appendChild(d);
    }
    MJ(ui.actions);
    host.dataset.state=JSON.stringify(s); host._ui=ui;
  },
  correct(host,s){
    let okCount=0, attempted=0;
    for(const p of s.PTS){
      const el = $('#ans_'+p.label,host); const raw = el ? el.value.trim() : '';
      if(!raw){ setTick('tk_'+p.label, ''); continue; }
      const val = parseComplex(raw);
      const ok  = val && val.a===p.x && val.b===p.y;
      setTick('tk_'+p.label, ok?'ok':'ko');
      if(ok) okCount++; attempted++;
    }
    host._ui.res.textContent = `${okCount} / ${attempted}`; host._ui.res.className = (attempted>0 && okCount===attempted)?'res-ok':'res-ko';
    return { okCount, attempted };
  },
  solution(host,s){
    const sol = s.PTS.map(p=>('z_{'+p.label+'} = '+unwrapL(affixeToLatex({a:p.x,b:p.y})))).map(L).join(' ; ');
    host._ui.res.innerHTML = `<div class="steps"><div class="step">${sol}</div></div>`; MJ(host._ui.res);
  },
  reset(host){ for(const el of host.querySelectorAll('input[id^="ans_"]')) el.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  /* ===== PDF ===== */
pdfStatement(s){
  // repÃ¨re 300Ã—300 avec les points affichÃ©s (lecture graphique)
  const r = new Repere(s.R);
  r.setPoints(s.PTS); // garde les labels A,B,C,...
  const html = shrinkSVG(r.el.outerHTML, 300);

  // petit rappel dâ€™Ã©noncÃ©
  const labs = s.PTS.map(p=>L('z_{'+p.label+'}')).join(', ');
  const pts  = s.PTS.map(p=>L(p.label)).join(', ');
  const cons = `<div class="hint">Par lecture graphique, donner les affixes ${labs} des points ${pts}.</div>`;

  return `<div>${cons}${html}</div>`;
},
pdfSolution(s){
  const sol = s.PTS
    .map(p => L(`z_{${p.label}} = ${unwrapL(affixeToLatex({a:p.x,b:p.y}))}`))
    .join(' ; ');
  return `<div class="steps"><div class="step">${sol}</div></div>`;
},


});

/* 3) Placer des vecteurs â€” origines donnÃ©es (A,B,C,...) */
LST.push({ id:'aff_vec_place', title:'Placer des vecteurs connaissant leur affixe (origines donnÃ©es)',
  gen(){ const R={...AMP}; const n=Math.max(2,Math.min(6,getNbPts()));
       const lim = { xmin:R.xmin+1, xmax:R.xmax-1, ymin:R.ymin+1, ymax:R.ymax-1 };
       const ORI=[]; const used=new Set();
       function uniqPoint(){ let x,y,k,tries=0; do{ x=rnd(lim.xmin,lim.xmax); y=rnd(lim.ymin,lim.ymax); k=x+';'+y; }while(used.has(k) && ++tries<1000); used.add(k); return {x,y}; }
       const V=[]; let count=0, safety=0;
       while(count<n && ++safety<5000){
         const p = uniqPoint(); let a=rnd(-5,5), b=rnd(-5,5); if(a===0 && b===0) continue;
         if(p.x+a<lim.xmin || p.x+a>lim.xmax || p.y+b<lim.ymin || p.y+b>lim.ymax) continue;
         ORI.push(p); V.push({a,b}); count++;
       }
       const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0,n).split('');
       return {R, V, ORI: ORI.map((p,i)=>({label:labels[i], x:p.x, y:p.y, color: colorOfIndex(i)}))};
  },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R}); ui.rep.setVectors([]); ui.rep.clearUserVectors();
    ui.rep.setPoints(s.ORI.map((p,i)=>({label:p.label, x:p.x, y:p.y, fill:p.color})));
    // Ã‰noncÃ© clair sous forme de liste
const items = s.V.map((v,i)=>{
  const zv  = unwrapL(affixeToLatex({a:v.a,b:v.b}));
  const ori = s.ORI[i].label;
  return `<li>Tracer le vecteur ${L(`\\vec v_${i+1}`)} d'affixe ${L(`z_${i+1} = ${zv}`)} et d'origine ${L(ori)}.</li>`;
}).join('');

ui.equ.innerHTML = `<p>Consignes :</p><ol style="margin:6px 0 0 20px">${items}</ol>`;
MJ(ui.equ);

    const chips=document.createElement('div'); chips.className='chips'; chips.innerHTML='<span>Vecteur courant :</span>'; ui.actions.appendChild(chips);
    const labels = s.V.map((_,i)=>'v'+(i+1)); const chipEls=[]; let current=labels[0];
    for(let i=0;i<labels.length;i++){
      const wrap=document.createElement('div'); wrap.className='chipwrap';
      const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=labels[i];
      sp.innerHTML = `<span class="dot" style="background:${colorOfIndex(i)}"></span> \\(\\vec v_${i+1}\\)`;
      const tk=document.createElement('span'); tk.className='tick'; tk.id='tk_'+labels[i]; tk.style.color=colorOfIndex(i);
      wrap.appendChild(sp); wrap.appendChild(tk);
      chips.appendChild(wrap); chipEls.push(sp);
    }
    function setCurrent(l){ current=l; chipEls.forEach(c=>c.classList.toggle('active',c.dataset.l===l)); }
    chipEls.forEach(c=>c.addEventListener('click',()=>setCurrent(c.dataset.l))); setCurrent(current);
    ui.rep.clickable=true;
    ui.rep.onClick = ({x,y})=>{
      const k = labels.indexOf(current); if(k<0) return;
      const origin = s.ORI[k]; const color = colorOfIndex(k);
      ui.rep.placeUserVector(current, origin.x, origin.y, x, y, color);
    };
    host.dataset.state=JSON.stringify(s); host._ui=ui; MJ(chips);
  },
  correct(host,s){
  const ui=host._ui;
  const labels = s.V.map((_,i)=>'v'+(i+1));
  let okCount=0, attempted=0;

  for(let i=0;i<labels.length;i++){
    const lab=labels[i], vref=s.V[i], oref=s.ORI[i];
    const u = (ui.rep.userVectors||[]).find(v=>v.label===lab);
    const tk=document.getElementById('tk_'+lab);
    if(!u){ if(tk){ tk.textContent=''; tk.className='tick'; tk.style.color=colorOfIndex(i);} continue; }
    const baseOK = (u.x1===oref.x && u.y1===oref.y);
    const dx = u.x2 - u.x1, dy = u.y2 - u.y1;
    const vecOK = (dx===vref.a && dy===vref.b);
    const ok = baseOK && vecOK;
    if(tk){ tk.textContent = ok ? 'âœ”' : 'âœ˜'; tk.className='tick'; tk.style.color=colorOfIndex(i); }
    attempted++; if(ok) okCount++;
  }
  // â›”ï¸ ne pas afficher les vecteurs corrects ici
  host._ui.res.textContent = `${okCount} / ${attempted}`;
  host._ui.res.className = (attempted>0 && okCount===attempted)?'res-ok':'res-ko';
  return { okCount, attempted };
},

  solution(host,s){
    // ðŸ‘‰ Solution visuelle : vecteurs exacts depuis leurs origines
    const vectsCorr = s.V.map((v,i)=>({label:'v'+(i+1), x1:s.ORI[i].x,y1:s.ORI[i].y, x2:s.ORI[i].x+v.a,y2:s.ORI[i].y+v.b, stroke: colorOfIndex(i)}));
    host._ui.rep.setVectors(vectsCorr);
    const sol = s.V.map((v,i)=>('z_{'+(i+1)+'} = '+unwrapL(affixeToLatex({a:v.a,b:v.b})))).map(L).join(' ; ');
    const assign = s.ORI.map((p,i)=> L(p.label+' \\Rightarrow \\vec v_{'+(i+1)+'}')).join(', ');
    host._ui.res.innerHTML = `<div class="steps"><div class="step">${assign}<br>${sol}</div></div>`; MJ(host._ui.res);
  },
  reset(host){ const ui=host._ui; ui?.rep?.clearUserVectors(); const r=$('#res',host); if(r) r.textContent=''; },
  /* ===== PDF ===== */
  pdfStatement(s){
    const r=new Repere(s.R);
    // Origines visibles, sans vecteurs
    r.setPoints(s.ORI.map((p)=>({x:p.x,y:p.y,label:p.label,fill:p.color})));
    const html = shrinkSVG(r.el.outerHTML, 300);
    const list = s.V.map((v,i)=>`\\(\\vec v_${i+1}\\) avec affixe \\(z_${i+1} = ${unwrapL(affixeToLatex({a:v.a,b:v.b}))}\\) et origine ${L(s.ORI[i].label)}`).join('<br>');
    return `<div><div class="hint">${list}</div>${html}</div>`;
  },
  pdfSolution(s){
    const r=new Repere(s.R);
    r.setPoints(s.ORI.map((p)=>({x:p.x,y:p.y,label:p.label,fill:p.color})));
    const vects = s.V.map((v,i)=>({label:'v'+(i+1), x1:s.ORI[i].x,y1:s.ORI[i].y, x2:s.ORI[i].x+v.a,y2:s.ORI[i].y+v.b, stroke: colorOfIndex(i)}));
    r.setVectors(vects);
    const html = shrinkSVG(r.el.outerHTML, 300);
    const sol  = s.V.map((v,i)=>('z_{'+(i+1)+'} = '+unwrapL(affixeToLatex({a:v.a,b:v.b})))).map(L).join(' ; ');
    return `<div><div class="hint">Vecteurs exacts :</div>${html}<div class="steps"><div class="step">${sol}</div></div></div>`;
  }
});

/* 4) Lire lâ€™affixe de vecteurs */
LST.push({ id:'aff_vec_read', title:'Lire lâ€™affixe de vecteurs',
  gen(){ const R={...AMP}; const n=Math.max(2,Math.min(6,getNbPts())); const V=[]; 
       const lim={xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1};
       let tries=0; while(V.length<n && ++tries<3000){ const a=rnd(-5,5), b=rnd(-5,5); if(a===0 && b===0) continue;
         const x1=rnd(lim.xmin,lim.xmax), y1=rnd(lim.ymin,lim.ymax), x2=x1+a, y2=y1+b;
         if(x2<lim.xmin || x2>lim.xmax || y2<lim.ymin || y2>lim.ymax) continue; V.push({a,b,x1,y1,x2,y2}); }
       return {R,V}; },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R});
    ui.rep.setVectors(s.V.map((v,i)=>({label:'v'+(i+1), x1:v.x1,y1:v.y1, x2:v.x2,y2:v.y2, stroke: colorOfIndex(i)})));
    ui.equ.innerHTML = `<p>Par lecture graphique, donner les affixes ${s.V.map((v,i)=>L('z_{'+(i+1)+'}')).join(', ')} des vecteurs \\(\\vec v_1, \\vec v_2,\\dots\\) tracÃ©s.</p>`; MJ(ui.equ);
    for(let i=0;i<s.V.length;i++){
      const d=document.createElement('div'); d.style.display='flex'; d.style.flexDirection='column'; d.style.gap='2px';
      const top=document.createElement('div'); top.style.display='flex'; top.style.gap='8px'; top.style.alignItems='center';
      const lbl=document.createElement('span'); lbl.innerHTML=L(`z_{${i+1}} =`); const inp=document.createElement('input'); inp.id=`ans_v_${i+1}`; inp.type='text'; inp.placeholder='a + b i';
      const tk=document.createElement('div'); tk.className='indline'; tk.innerHTML=`<span class="lbl"></span><span class="tick" id="tk_v${i+1}"></span>`;
      top.appendChild(lbl); top.appendChild(inp); d.appendChild(top); d.appendChild(tk); ui.actions.appendChild(d);
    }
    MJ(ui.actions);
    host.dataset.state=JSON.stringify(s); host._ui=ui;
  },
  correct(host,s){
    let okCount=0, attempted=0;
    for(let i=0;i<s.V.length;i++){
      const el=$('#ans_v_'+(i+1),host); const raw=el?el.value.trim():'';
      if(!raw){ setTick('tk_v'+(i+1), ''); continue; }
      const val=parseComplex(raw);
      const ok = val && val.a===s.V[i].a && val.b===s.V[i].b;
      setTick('tk_v'+(i+1), ok?'ok':'ko');
      if(ok) okCount++; attempted++;
    }
    host._ui.res.textContent = `${okCount} / ${attempted}`; host._ui.res.className = (attempted>0 && okCount===attempted)?'res-ok':'res-ko';
    return { okCount, attempted };
  },
  solution(host,s){
    const sol = s.V.map((v,i)=>('z_{'+(i+1)+'} = '+unwrapL(affixeToLatex({a:v.a,b:v.b})))).map(L).join(' ; ');
    host._ui.res.innerHTML = `<div class="steps"><div class="step">${sol}</div></div>`; MJ(host._ui.res);
  },
  reset(host){ for(const el of host.querySelectorAll('input[id^="ans_v_"]')) el.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  /* ===== PDF ===== */
pdfStatement(s){
  // repÃ¨re 300Ã—300 avec les vecteurs Ã  lire (lecture graphique)
  const r = new Repere(s.R);
  const vects = s.V.map((v,i)=>({
    label:'v'+(i+1),
    x1:v.x1, y1:v.y1, x2:v.x2, y2:v.y2,
    stroke: colorOfIndex(i)
  }));
  r.setVectors(vects);
  const html = shrinkSVG(r.el.outerHTML, 300);

  const labs = s.V.map((_,i)=>L('z_{'+(i+1)+'}')).join(', ');
  const cons = `<div class="hint">Par lecture graphique, donner les affixes ${labs} des vecteurs tracÃ©s.</div>`;

  return `<div>${cons}${html}</div>`;
},
pdfSolution(s){
  const sol = s.V
    .map((v,i)=> L(`z_${i+1} = ${unwrapL(affixeToLatex({a:v.a,b:v.b}))}`))
    .join(' ; ');
  return `<div class="steps"><div class="step">${sol}</div></div>`;
},


});

return LST; }

/* ===== App glue ===== */
function bindLiveNumber(id, handler){
  const el=document.getElementById(id); if(!el) return;
  let last=el.value; const fire=()=>{ const v=el.value; if(v!==last){ last=v; handler(); } };
  el.addEventListener('input', handler);
  el.addEventListener('change', handler);
  el.addEventListener('click', handler);
  el.addEventListener('keyup', handler);
  el.addEventListener('pointerup', handler);
  el.addEventListener('wheel', handler);
  el.addEventListener('pointerdown', ()=>{ let alive=true; const stop=()=>{alive=false;};
    el.addEventListener('pointerup', stop, {once:true}); el.addEventListener('blur', stop, {once:true});
    const tick=()=>{ if(!alive) return; fire(); requestAnimationFrame(tick); }; requestAnimationFrame(tick);
  });
}

let REGISTRY=[];

/* â›³ï¸ RENDU SAME STATE â€” global */
function rerenderSameState(){
  const host=$('#host'); const def=(REGISTRY||[]).find(e=>e.id===host.dataset.active);
  if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  st.R={...AMP};
  host.dataset.state=JSON.stringify(st);
  def.render(host,st);
}

let scoreOK=0, scoreTot=0; const updateScore=()=>$('#score').textContent=`${scoreOK} / ${scoreTot}`;

function buildOne(){
  const sel=$('#exo-select'), host=$('#host');
  const def=(REGISTRY||[]).find(e=>e.id===sel.value);
  if(!def){ host.textContent='(Aucun exercice)'; return; }
  const st=def.gen();
  host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  $('#status').textContent='';
}

function check(){
  const host=$('#host'); const def=(REGISTRY||[]).find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}'); const r=def.correct(host,st);
  if(r && 'okCount' in r){ scoreOK += (r.okCount||0); scoreTot += (r.attempted||0); updateScore(); }
}
function solution(){ const host=$('#host'); const def=(REGISTRY||[]).find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ scoreOK=0; scoreTot=0; updateScore(); const host=$('#host'); const def=(REGISTRY||[]).find(e=>e.id===host.dataset.active); if(def) def.reset(host); }

document.addEventListener('DOMContentLoaded',function(){
  try{
    REGISTRY = makeExos();
    window.REGISTRY = REGISTRY; // pour le kit PDF

    // === Mise Ã  jour immÃ©diate amplitude & nombre d'objets ===
    const ampIds = ['xmin','xmax','ymin','ymax'];
    const ampHandler = ()=>{ applyAMPInputs(); rerenderSameState(); };
    ampIds.forEach(id=>{
      const el=document.getElementById(id);
      if(!el) return;
      el.addEventListener('input', ampHandler);
      el.addEventListener('change', ampHandler);
    });
    bindLiveNumber('xmin', ampHandler);
    bindLiveNumber('xmax', ampHandler);
    bindLiveNumber('ymin', ampHandler);
    bindLiveNumber('ymax', ampHandler);

    const nb=document.getElementById('nbPts');
    if(nb){
      const onNb = ()=>{ buildOne(); };
      nb.addEventListener('input', onNb);
      nb.addEventListener('change', onNb);
      bindLiveNumber('nbPts', onNb);
    }
    const nbr=document.getElementById('nbPts-random'); if(nbr){ nbr.addEventListener('change', ()=>buildOne()); }

    const sel=$('#exo-select');
    if(!REGISTRY || !REGISTRY.length){ $('#status').textContent='(Init: aucune entrÃ©e)'; return; }
    REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
    sel.addEventListener('change',buildOne);

    $('#btn-new').addEventListener('click',buildOne);
    $('#btn-check').addEventListener('click',check);
    $('#btn-solution').addEventListener('click',solution);
    $('#btn-reset').addEventListener('click',resetAll);

    applyAMPInputs();
    sel.value = REGISTRY[0].id;
    buildOne();

    // ===== PDF kit =====
    (function(){
      if (!(window.ExoPDF && typeof ExoPDF.init==='function')) return;
      const LEADS = {
        'aff_pts_place': "Placer sur le repÃ¨re les points dâ€™affixes demandÃ©es.",
        'aff_pts_read':  "Par lecture graphique, donner les affixes des points.",
        'aff_vec_place': "Tracer les vecteurs dâ€™affixes donnÃ©es depuis les origines indiquÃ©es.",
        'aff_vec_read':  "Par lecture graphique, donner les affixes des vecteurs tracÃ©s."
      };
      ExoPDF.init({
        mountAfterSelector: '.card.small',
        title:'1STI2D â€“ Nombres complexes : Affixe & forme algÃ©brique',
        lead:'\u200B',
        leadByDefId: LEADS,
        beforeGen(def, st, ctx){ return def.gen(); },
        // ðŸ‘‰ Utilise nos vues PDF par exercice (et donc le repÃ¨re 300Ã—300)
        beforeRender(def, S, withSolutions){
          if (def && typeof def.pdfStatement === 'function' && typeof def.pdfSolution === 'function'){
            return withSolutions ? def.pdfSolution(S) : def.pdfStatement(S);
          }
        }
      });
    })();
  }catch(e){
    console.error(e); $('#status').textContent='(Erreur initialisation)';
  }
});

})();</script>
</body>
</html>
