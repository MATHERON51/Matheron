<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1STI2D ‚Äì Fonctions polyn√¥mes (deg 2 & 3) ‚Äî Cas g√©n√©ral a(x‚àíx‚ÇÅ)(x‚àíx‚ÇÇ) </title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020;--muted:#667085}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;margin:10px 0}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{white-space:nowrap}
  select, input[type=text]{padding:6px 8px;border:1px solid #d0d5dd;border-radius:8px;font:inherit}
  .btn{padding:7px 12px;border:1px solid #d0d5dd;border-radius:10px;background:#f7f7f9;cursor:pointer}
  .btn:hover{background:#f0f2f5}
  .score{margin-left:auto;font-weight:600}
  .host-title{margin:.2rem 0 .8rem;font-weight:700}
  .muted{color:var(--muted)}

.tick{display:inline-block;min-width:18px}
.tick::after{content:''}
.tick.ok::after{content:"‚úì";color:var(--ok);font-weight:700}
.tick.ko::after{content:"‚úó";color:var(--ko);font-weight:700}


  /* zone solution : copier telle quelle pour le PDF */
  .steps{background:#f6f7fb;border:1px solid #e5e7eb;border-radius:10px;padding:10px 12px}
  .steps h4{margin:.2rem 0 .4rem;font-size:1rem}
  .steps .line{margin:.12rem 0}

  /* mini rep√®re SVG */
  .g{width:100%;max-width:580px;margin:6px auto;border:1px solid #ddd;border-radius:10px;background:#fff}
  svg.axis text{font-size:11px;fill:#333}
  svg .curve{fill:none;stroke-width:2}
  .legend{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:6px;margin-top:8px}
  .legend .item{border:1px dashed #ddd;border-radius:10px;padding:6px 10px;font-size:.95rem;background:#fafafa}

  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:820px){ .two-col{grid-template-columns:1fr} }

  .set{display:block;width:100%;max-width:360px}
  .small{font-size:.95rem;color:#475467}
  
 .sign-table{
  width:100%;
  border:2px solid #000;
  border-collapse:separate;
  border-spacing:0;
  table-layout:fixed;
  --zeroW: 110px;
}
.sign-table col.col-lbl{ width: 96px; }
.sign-table col.col-zero{ width: var(--zeroW); }
.sign-table col.col-int{ width:auto; }

.sign-table th, .sign-table td{
  padding:8px 6px; text-align:center; vertical-align:middle;
  border-top:1px solid #000;
  border-bottom:1px solid #000;
  border-right:none; border-left:none;
}

.sign-table .lbl{
  font-weight:600;
  border-right:2px solid #000;
  white-space:nowrap;
}

.sign-table td.int{ border-left:0 !important; border-right:0 !important; }
.sign-table td.zero{ border-left:0 !important; border-right:0 !important; }
.sign-table .cap-left{ text-align:left; padding-left:8px; }
.sign-table .cap-right{ text-align:right; padding-right:8px; }

.sign-table .sel, .sign-table .root{
    width: var(--zeroW);
    height: 34px;
    line-height: 1.2;
    font-size: 16px;
    padding: 6px 8px;
    border:1px solid #cbd5e1; border-radius:8px;
    text-align:center; box-sizing:border-box;
    margin:0 auto; display:block; background:#fff;
  }
.sign-table .sel{
  -webkit-appearance:none; -moz-appearance:none; appearance:none;
  text-align-last:center;
}

.sign-table{ font-size:1.15rem; }
.sign-table th, .sign-table td{
  padding:10px 14px;
}
.sign-table .cell{ width:84px; height:44px; font-size:1.12rem; }
.sign-table .sel{ height:40px; min-width:84px; text-align-last:center; }
.sign-table .root{ min-width:110px; height:40px; font-size:1.12rem; }

  @media print{ .controls{display:none !important;} }

.sign-table .cell-inline{ display:inline-flex; align-items:center; justify-content:center; gap:6px; }
.tick{ min-width:1.1em; font-weight:700; font-size:16px; line-height:1; vertical-align:middle; }
.tick.ok{ color:#16a34a; }
.tick.ko{ color:#dc2626; }
.tick.nu{ color:transparent; }

.pdf-large.sign-table{
  font-size: 1.35rem;
  --zeroW: 140px;
}
.pdf-large.sign-table th,
.pdf-large.sign-table td{
  padding: 14px 16px;
}
.pdf-large.sign-table td,
.pdf-large.sign-table th{
  text-align: center !important;
  vertical-align: middle !important;
}
.pdf-large.sign-table .lbl{ text-align: center !important; }

/* Demi-taille pour le tableau de signes */
.sign-table.half{
  font-size:.575rem;           /* 1.15 / 2 */
  --zeroW:55px;                /* 110 / 2 */
}
.sign-table.half th,
.sign-table.half td{ padding:5px 7px; }      /* 10‚Äì14 -> ~5‚Äì7 */
.sign-table.half .cell{ width:42px; height:22px; font-size:.56rem; } /* 84x44 -> moiti√© */
.sign-table.half .sel{ height:20px; min-width:42px; }
.sign-table.half .root{ min-width:55px; height:22px; font-size:.56rem; }
/* Extr√©mit√©s de la ligne f(x) : gauche -> droite ; droite -> gauche */


/* Si tu utilises .half ou .pdf-large, on r√©affirme pareil */
.sign-table.half tbody tr:nth-child(2) td.int:first-of-type{ text-align:right !important; }
.sign-table.half tbody tr:nth-child(2) td.int:last-of-type { text-align:left  !important; }
.pdf-large.sign-table tbody tr:nth-child(2) td.int:first-of-type{ text-align:right !important; }
.pdf-large.sign-table tbody tr:nth-child(2) td.int:last-of-type { text-align:left  !important; }
/* Table des deux solutions x1/x2 */
.table.sol2 { table-layout:fixed; width:100% }
.table.sol2 col { width:50% }
.table.sol2 th, .table.sol2 td { padding:12px 18px; vertical-align:top }

/* Chaque ligne de calcul : vrai bloc, marge verticale visible */
.table.sol2 .line mjx-container { 
  margin:6px 0 0 !important;    /* espace r√©el autour de la fraction */
}
/* le clone destin√© au PDF ne doit jamais √™tre visible √† l'√©cran */
.equ-offscreen {
  position: absolute !important;
  left: -10000px !important;
  top: -10000px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  visibility: hidden !important;
}

  /* Dans le bloc PDF, on masque inputs/select et les ticks */
  .equ-offscreen input,
  .equ-offscreen select,
  .equ-offscreen .tick { display:none !important; }

  /* Petits blancs propres pour les r√©ponses dans le PDF */
  .equ-offscreen .blank {
    display:inline-block; min-width:140px; height:1.2em;
    border-bottom:1px solid #000; vertical-align:baseline;
  }
  .equ-offscreen .box {
    display:inline-block; width:18px; height:18px;
    border:1px solid #000; vertical-align:middle;
  }

table.pdf-tbl{
  border-collapse: separate;   /* important pour pouvoir cibler uniquement le pourtour */
  border-spacing: 0;
  border: none;                /* pas de bordure de table (√©vite le double trait) */
  margin:.4rem 0;
}
table.pdf-tbl th, table.pdf-tbl td{
  border: none;                /* on nettoie toutes les bordures int√©rieures */
  padding: 4px 6px;
  text-align: center;
  vertical-align: middle;
}
table.pdf-tbl th{ background:#f3f3f6 }

/* ‚Äî Cadre ext√©rieur uniquement ‚Äî */
table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
/* S√©parateur vertical apr√®s la 1 ≥·µâ colonne (x et f / f(x)) */
table.pdf-tbl thead tr > *:first-child,
table.pdf-tbl tbody tr > *:first-child{
  border-right: 1.5px solid #000;
}

/* Trait horizontal entre x et f(x) */
table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}

/* Uniquement pour le rendu PDF */
@media print {
  .equ-offscreen{
    position: static !important;
    left: 0 !important;
    top: 0 !important;
    width: auto !important;
    height: auto !important;
    overflow: visible !important;
    visibility: visible !important;
    display: block !important;
  }
}
@media print {
  .pdf-half{
    width:50% !important;
    display:inline-block !important;
    vertical-align:top !important;
  }
  .pdf-half .sign-table{
    width:100% !important;   /* le tableau remplit son wrapper √† 50% */
  }
}
.equ-offscreen input.no-pdf,
.equ-offscreen select.no-pdf {
  display: none !important;
}

</style>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    // ‚¨áÔ∏è CL√â: on n‚Äôignore plus <code>/<pre>
    options: {
      skipHtmlTags: ['script','noscript','style','textarea']  // (on enl√®ve 'pre' et 'code')
      // (optionnel) processHtmlClass: 'mathjax-process', ignoreHtmlClass: 'tex2jax_ignore'
    },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D ‚Äì Fonctions polyn√¥mes (deg 2 & 3) ‚Äî Cas g√©n√©ral a(x‚àíx‚ÇÅ)(x‚àíx‚ÇÇ)</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <hr><strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li><b>Entr√©e ‚èé</b> d√©clenche <b>V√©rifier</b> (sur le champ actif). Les ‚úì/‚úó apparaissent uniquement lors de la v√©rification.</li>
        <li>On privil√©gie la <b>notation clavier</b> : <code>x^2</code>, <code>(x-3)</code>, <code>a/b</code>, etc. Le signe ¬´ ‚àí ¬ª peut √™tre saisi avec <kbd>-</kbd> ou ¬´ ‚àí ¬ª.</li>
        <li><b>Ensembles de solutions</b> : accepter <code>S = { ‚Ä¶ }</code> ou simplement la liste <code>a ; b</code> (ordre indiff√©rent). <i>Ex. :</i> <code>-1 ; 3</code>.</li>
        <li><b>Intervalles</b> : <code>]a ; b[</code>, <code>[a ; b]</code>, <code>] ‚àí‚àû ; r [</code>, <code>] r ; +‚àû [</code>‚Ä¶ <b>‚àû</b> accept√© aussi en <code>-oo/+oo</code>.</li>
      </ul>
    </div>

     <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

  <!-- G√©n√©rateur PDF + clavier + patch normalisation -->
  <script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';
function $(s,r){ return (r||document).querySelector(s); }
function $all(s,r){ return Array.prototype.slice.call((r||document).querySelectorAll(s)); }
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Sign normalizer (ASCII '-' et vrai '‚àí') ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const MINUS_ASC = '-';
const MINUS_U   = '‚àí';
const PM = '\\+|['+MINUS_ASC+MINUS_U+']'; // + ou minus (unicode/ASCII)
// Nombre "joli" pour le TeX (virgule OK) :
function latexNum(n){
  const v = Math.round((+n + Number.EPSILON)*100)/100;
  return String(Math.abs(v) < 1e-12 ? 0 : v).replace('.', ',').replace(/^-0$/, '0');
}

// f(x) = ax^2 + bx + c en **TeX pur** (sans unicode '‚àí')
function polyTeX(a,b,c){
  const t=[];

  // ax^2
  if (a ===  1) t.push('x^{2}');
  else if (a === -1) t.push('-x^{2}');
  else t.push((a<0?'-':'') + latexNum(Math.abs(a)) + '\\,x^{2}');

  // bx
  if (b !== 0){
    const s = (b<0? ' - ' : ' + ');
    const m = (Math.abs(b)===1 ? 'x' : latexNum(Math.abs(b))+'\\,x');
    t.push(s + m);
  }

  // c
  if (c !== 0){
    const s = (c<0? ' - ' : ' + ');
    t.push(s + latexNum(Math.abs(c)));
  }

  return t.join('');
}

// ----- Fractions helpers (irr√©ductible, jolis LaTeX)
function _gcd(a,b){ a=Math.abs(a)|0; b=Math.abs(b)|0; while(b){ const t=a%b; a=b; b=t; } return a||1; }
// approx rationnelle de n (cont. fractions), borne de d√©nominateur raisonnable
function fracFromNumber(n, maxDen=2000, tol=1e-10){
  if (!Number.isFinite(n)) return {num:0, den:1};
  let sign = n<0?-1:1; n = Math.abs(n);
  let h1=1,h0=0,k1=0,k0=1, b=n, a=Math.floor(b);
  while (k1<=maxDen && Math.abs(h1/k1 - n) > tol){
    const a = Math.floor(b);
    const h2 = a*h1 + h0, k2 = a*k1 + k0;
    h0=h1; k0=k1; h1=h2; k1=k2;
    const frac = b - a; if(frac < tol) break;
    b = 1/frac;
  }
  let num = (sign*h1)|0, den = (k1||1)|0;
  if (den<0){ den=-den; num=-num; }
  const g=_gcd(num,den); num/=g; den/=g;
  return {num, den};
}
function fracReduce(num, den){
  if(den<0){ den=-den; num=-num; }
  const g=_gcd(num,den); return {num:num/g, den:den/g};
}
function fracTimes(n1,d1,n2,d2){ return fracReduce(n1*n2, d1*d2); }
function latexFrac(num,den){
  if(den===1) return String(num);
  return '\\dfrac{'+num+'}{'+den+'}';
}
// Emp√™che les doublons de lignes (on normalise un peu les espaces)
function pushUnique(list, s, seen){
  const canon = s.replace(/\s+/g,' ').trim();
  if(!seen.has(canon)){ list.push(s); seen.add(canon); }
}


function cleanSigns(str){
  if(!str) return str;
  return String(str)
    // --  ‚Üí +
    .replace(new RegExp('(['+MINUS_ASC+MINUS_U+'])\\s*(['+MINUS_ASC+MINUS_U+'])','g'), ' + ')
    // +-  or + ‚àí ‚Üí ‚àí
    .replace(new RegExp('\\+\\s*(['+MINUS_ASC+MINUS_U+'])','g'), ' '+MINUS_U+' ')
    // -+  ‚Üí ‚àí
    .replace(new RegExp('(['+MINUS_ASC+MINUS_U+'])\\s*\\+','g'), ' '+MINUS_U+' ')
    // ++  ‚Üí +
    .replace(/\+\s*\+/g, ' + ')
    // espaces multiples ‚Üí un espace
    .replace(/\s{2,}/g, ' ')
    // + ) ou + ] coll√©s apr√®s simplif ‚Üí r√©-ajuste (cosm√©tique)
    .replace(/\s+\)/g, ')').replace(/\s+\]/g, ']');
}

// Nettoie seulement le texte (pas les <input>) pour ne pas perdre les saisies
function cleanTextNodes(root){
  try{
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
    const nodes = [];
    while(walker.nextNode()) nodes.push(walker.currentNode);
    nodes.forEach(n => { n.nodeValue = cleanSigns(n.nodeValue); });
  }catch(_){}
}

function typeset(el){
  try{
    if (window.MathJax?.typesetPromise) { MathJax.typesetPromise([el]); }
    else if (window.MathJax?.typeset)   { MathJax.typeset([el]); }
  }catch(e){}
}

let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
function rint(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function choice(a){ return a[Math.floor(Math.random()*a.length)]; }
function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
const UMINUS = '‚àí';

// Algebra helpers (display)
function texSign(v){ return v<0 ? '‚àí' : '+'; }
function fmtNum(n){ return (n<0?UMINUS:'')+Math.abs(n); }
function parenIfNeg(n){ return n<0? '('+UMINUS+Math.abs(n)+')' : n; }
function polyExpand(a,x1,x2){ // ax^2 - a(x1+x2)x + a x1 x2
  const b = -a*(x1+x2);
  const c = a*(x1*x2);
  return {a:a,b:b,c:c};
}
function pnum(v){ const s = String(v).replace('.',','); return (v<0? '('+s+')' : s); }

function factorHTML(a,x1,x2){
  const aStr = fmtA(a); // g√®re 1, -1, d√©cimaux
  const p = (r)=>'(x '+(r<0?'+':'‚àí')+' '+Math.abs(r)+')';
  return (aStr?aStr:'') + p(x1) + p(x2);
}

function setTick(el, ok){ if(!el) return; el.classList.remove('ok','ko','nu'); el.classList.add(ok===true?'ok':ok===false?'ko':'nu'); }
// ‚Äî helpers ticks ‚Äî
function tick(id, state){ 
  const t = host.querySelector('#ok_'+id);
  if(!t) return;
  t.classList.remove('ok','ko','nu');
  if(state===null){ t.classList.add('nu'); return; }
  t.classList.add(state?'ok':'ko');
}

let ok=0, tot=0;
function check(id, got, want){
  if(!got){ tick(id,null); return; }
  tot++; const good = (got===want); if(good) ok++; tick(id,good);
}
function expectEmpty(id, got){
  tot++; const good = (got==='' || got==null); if(good) ok++;
  tick(id, good);
}
function drawParabolaSVG(container, curves){
  const W=400, H=400, xmin=-6, xmax=6, ymin=-6, ymax=6;
  const X=x=> (x-xmin)/(xmax-xmin)*W;
  const Y=y=> H-(y-ymin)/(ymax-ymin)*H;

  // ----- utilitaires g√©om√©triques
  function canonParams(c){
    // Renvoie (a, xm, ym) quelle que soit la forme entr√©e
    if (c.noRoot) return { a:c.a, xm:c.xm, ym:c.ym };
    const xm = (c.x1 + c.x2)/2;
    const ym = c.a * (xm - c.x1) * (xm - c.x2);
    return { a:c.a, xm, ym };
  }
  function yAt(c, x){
    const {a,xm,ym} = canonParams(c);
    return a*(x-xm)*(x-xm) + ym;
  }
  function slopeAt(c, x){
    const {a,xm} = canonParams(c);
    return 2*a*(x - xm);
  }

  // ----- path pour une courbe
  const pathFor=(c)=>{
    let d=''; const n=220;
    for(let i=0;i<=n;i++){
      const x = xmin + (xmax-xmin)*i/n;
      const y = yAt(c, x);
      d += (i? 'L':'M')+X(x).toFixed(2)+','+Y(y).toFixed(2)+' ';
    }
    return d;
  };

  // ----- conteneur
  const wrap = document.createElement('div');
  wrap.style.position = 'relative';
  wrap.style.width = W+'px';
  wrap.style.margin = '6px auto';
  wrap.className = 'g';

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox','0 0 '+W+' '+H);

  // defs fl√®ches
  const defs = document.createElementNS(svg.namespaceURI,'defs');
  const arrow = document.createElementNS(svg.namespaceURI,'marker');
  arrow.setAttribute('id','arr'); arrow.setAttribute('viewBox','0 0 10 10');
  arrow.setAttribute('refX','7'); arrow.setAttribute('refY','5');
  arrow.setAttribute('markerWidth','6'); arrow.setAttribute('markerHeight','6');
  arrow.setAttribute('orient','auto-start-reverse');
  const tip = document.createElementNS(svg.namespaceURI,'path');
  tip.setAttribute('d','M0 0 L10 5 L0 10 Z'); tip.setAttribute('fill','#333');
  arrow.appendChild(tip); defs.appendChild(arrow); svg.appendChild(defs);

  // grille
  for(let x=Math.ceil(xmin); x<=Math.floor(xmax); x++){
    const l=document.createElementNS(svg.namespaceURI,'line');
    l.setAttribute('x1',X(x)); l.setAttribute('x2',X(x)); l.setAttribute('y1',0); l.setAttribute('y2',H);
    l.setAttribute('stroke','#eee'); svg.appendChild(l);
  }
  for(let y=Math.ceil(ymin); y<=Math.floor(ymax); y++){
    const l=document.createElementNS(svg.namespaceURI,'line');
    l.setAttribute('x1',0); l.setAttribute('x2',W); l.setAttribute('y1',Y(y)); l.setAttribute('y2',Y(y));
    l.setAttribute('stroke','#eee'); svg.appendChild(l);
  }

  // axes
  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',0); axX.setAttribute('x2',W); axX.setAttribute('y1',Y(0)); axX.setAttribute('y2',Y(0));
  axX.setAttribute('stroke','#333'); axX.setAttribute('stroke-width','1.5'); axX.setAttribute('marker-end','url(#arr)');
  svg.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',X(0)); axY.setAttribute('x2',X(0)); axY.setAttribute('y1',H); axY.setAttribute('y2',0);
  axY.setAttribute('stroke','#333'); axY.setAttribute('stroke-width','1.5'); axY.setAttribute('marker-end','url(#arr)');
  svg.appendChild(axY);

  // graduations
  for(let x=Math.ceil(xmin); x<=Math.floor(xmax); x++){
    const t=document.createElementNS(svg.namespaceURI,'line');
    t.setAttribute('x1',X(x)); t.setAttribute('x2',X(x));
    t.setAttribute('y1',Y(0)-4); t.setAttribute('y2',Y(0)+4);
    t.setAttribute('stroke','#333'); svg.appendChild(t);
    if(x!==0){
      const tx=document.createElementNS(svg.namespaceURI,'text');
      tx.setAttribute('x', X(x)+2); tx.setAttribute('y', Y(0)+14);
      tx.setAttribute('font-size','11'); tx.textContent=String(x); svg.appendChild(tx);
    }
  }
  for(let y=Math.ceil(ymin); y<=Math.floor(ymax); y++){
    const t=document.createElementNS(svg.namespaceURI,'line');
    t.setAttribute('y1',Y(y)); t.setAttribute('y2',Y(y));
    t.setAttribute('x1',X(0)-4); t.setAttribute('x2',X(0)+4);
    t.setAttribute('stroke','#333'); svg.appendChild(t);
    if(y!==0){
      const ty=document.createElementNS(svg.namespaceURI,'text');
      ty.setAttribute('x', X(0)+6); ty.setAttribute('y', Y(y)+4);
      ty.setAttribute('font-size','11'); ty.textContent=String(y); svg.appendChild(ty);
    }
  }

  // origine
  const o=document.createElementNS(svg.namespaceURI,'text');
  o.setAttribute('x', X(0)-10); o.setAttribute('y', Y(0)+14);
  o.setAttribute('font-size','12'); o.textContent='O'; svg.appendChild(o);

  // trac√© + labels
  const colors = ['#0ea5e9','#ef4444','#10b981','#f59e0b'];
  const isSingle = (curves.length === 1);

  function placeCurveLabelAt(c, x, col, tag){
    const y = yAt(c, x);
    const g = document.createElementNS(svg.namespaceURI, 'g');
    const deg = Math.atan(slopeAt(c, x)) * 180/Math.PI;
    g.setAttribute('transform', `translate(${X(x)},${Y(y)}) rotate(${-deg})`);

    const txt = document.createElementNS(svg.namespaceURI, 'text');
    txt.setAttribute('fill', col);
    txt.setAttribute('font-size', '16');
    txt.setAttribute('paint-order', 'stroke');
    txt.setAttribute('stroke', '#fff');
    txt.setAttribute('stroke-width', '3');
    txt.setAttribute('stroke-linejoin', 'round');

    const tC = document.createElementNS(svg.namespaceURI, 'tspan');
    tC.textContent = tag[0];
    const tSub = document.createElementNS(svg.namespaceURI, 'tspan');
    tSub.textContent = tag[1];
    tSub.setAttribute('font-size', '11');
    tSub.setAttribute('dy', '4');

    txt.appendChild(tC); txt.appendChild(tSub);
    g.appendChild(txt); svg.appendChild(g);
  }

  curves.forEach((c,i)=>{
    // chemin
    const p = document.createElementNS(svg.namespaceURI,'path');
    p.setAttribute('d', pathFor(c));
    p.setAttribute('class','curve');
    p.setAttribute('stroke-width','2');
    const col = colors[i%colors.length];
    p.setAttribute('stroke', col);
    p.setAttribute('fill','none');
    svg.appendChild(p);

    // position label : r√©soudre y = a(x-xm)^2 + ym au niveau yT = ¬±5
    const {a,xm,ym} = canonParams(c);
    const yT = (a > 0 ? 5 : -5);
    const rhs = (yT - ym) / a;            // peut √™tre < 0 si yT est du "mauvais c√¥t√©"
    let rad = (rhs >= 0) ? Math.sqrt(rhs) : 0; // si <0 on colle le label au sommet
    let xL = xm - rad, xR = xm + rad;

    // borner dans la fen√™tre
    xL = Math.max(xmin, Math.min(xmax, xL));
    xR = Math.max(xmin, Math.min(xmax, xR));

    // libell√© : C_f si une seule courbe, sinon C_1, C_2‚Ä¶
    const tag = isSingle ? ['C','f'] : ['C', String(c.lab ?? (i+1))];


    // alterner gauche/droite pour √©viter les chevauchements
    if (i % 2 === 0) placeCurveLabelAt(c, xR, col, tag);
    else             placeCurveLabelAt(c, xL, col, tag);
  });

  wrap.appendChild(svg);

  // petites √©tiquettes i, j (HTML/LaTeX au dessus)
  const label = (latex, left, top, color) => {
    const d = document.createElement('div');
    d.className = 'latex';
    d.style.position = 'absolute';
    d.style.left = left + 'px';
    d.style.top  = top  + 'px';
    d.style.transform = 'translate(-50%, -60%)';
    d.style.pointerEvents = 'none';
    d.style.color = color || '#111';
    d.style.padding = '2px 4px';
    d.style.borderRadius = '6px';
    d.style.boxShadow = '0 0 0 1px rgba(0,0,0,0.05)';
    d.innerHTML = '\\(' + latex + '\\)';
    wrap.appendChild(d);
    return d;
  };
  label('\\vec{\\imath}', X(1)+6,  Y(0)-10);
  label('\\vec{\\jmath}', X(0)-8,  Y(1)-0);

  container.innerHTML='';
  container.appendChild(wrap);

  if (window.MathJax?.typesetPromise) MathJax.typesetPromise([wrap]);
  else if (window.MathJax?.typeset)   MathJax.typeset([wrap]);
}

// === Helpers pour comparer deux expressions utilisateur ===
function _toJS(expr){
  let s = String(expr||'').trim();

  // normalisations de base
  s = s
    .replace(/\u2212|‚àí/g, '-')            // vrai "‚àí" -> '-'
    .replace(/,/g, '.')                   // virgule -> point
    .replace(/¬≤/g, '**2')                 // exposant ¬≤
    .replace(/\^/g, '**')                 // ^ -> **

    // racine
    .replace(/\\sqrt\s*\{([^}]*)\}/gi, 'Math.sqrt($1)')
    .replace(/‚àö\s*\(?\s*([^)]*)\s*\)?/gi, 'Math.sqrt($1)')

    // multiplications implicites :  2(x+1), x(x-1), (x+1)(x-2), 3x, x3
    .replace(/(\d|\)|x)\s*\(/g, '$1*(')
    .replace(/\)\s*(\d|x)/g, ')*$1')
    .replace(/([0-9])\s*([a-zA-Z])/g, '$1*$2')
    .replace(/([a-zA-Z])\s*([0-9])/g, '$1*$2')
    .replace(/([a-zA-Z])\s+([a-zA-Z])/g, '$1*$2');

  return s;
}
function _fOf(expr){
  const js = _toJS(expr);
  // eslint-disable-next-line no-new-func
  return Function('x', 'return ('+js+');');
}
function _numericEq(got, want){
  let fg, fw;
  try { fg = _fOf(got); fw = _fOf(want); } catch(_){ return false; }
  const pts = [-3.2,-2.1,-1,0,0.5,1,2.3,3.7]; // 8 points de test
  for(const x of pts){
    let yg, yw;
    try { yg = +fg(x); yw = +fw(x); } catch(_){ return false; }
    if(!Number.isFinite(yg) || !Number.isFinite(yw)) return false;
    if(Math.abs(yg - yw) > 1e-6) return false;
  }
  return true;
}
function _algebraEqUser(got, a, x1, x2){
  const want = `${a}*(x-(${x1}))*(x-(${x2}))`;
  // 1) pr√©f√®re algebraOK si pr√©sent (tes r√®gles d‚Äô√©quivalence avanc√©es)
  try{
    if(typeof algebraOK === 'function'){
      return !!algebraOK('('+got+')', '('+want+')');
    }
  }catch(_){}
  // 2) sinon fallback num√©rique robuste
  return _numericEq(got, want);
}


// Helpers: set parsing for sets (solutions), intervals
function parseSet(s){
  if(!s) return [];
  s = String(s).trim().replace(/^S\s*=\s*\{|\}$/g,'');
  const parts = s.split(/[;,]/).map(x=>x.trim()).filter(Boolean);
  const nums = parts.map(x=> Number(x.replace(',','.'))).filter(v=>!Number.isNaN(v));
  nums.sort((a,b)=>a-b);
  return nums;
}
function eqSets(a,b){
  if(a.length!==b.length) return false;
  for(let i=0;i<a.length;i++) if(Math.abs(a[i]-b[i])>1e-9) return false;
  return true;
}

function intervalToText(lo,loInc,hi,hiInc){
  const L = lo===-Infinity ? ']' : (loInc?'[':']');
  const R = hi===Infinity ? '[' : (hiInc?']':'[');
  const loTxt = lo===-Infinity ? '‚àí‚àû' : String(lo);
  const hiTxt = hi===Infinity ? '+‚àû' : String(hi);
  return L+' '+loTxt+' ; '+hiTxt+' '+R;
}
// ------- affichage propre des nombres (√©vite -0, .0 etc.)
// Arrondis jolis + affichage d√©cimal avec virgule pour LaTeX
function nice(n, p=2){
  const v = Math.round((+n + Number.EPSILON) * 10**p) / 10**p;
  return Math.abs(v) < 1e-12 ? 0 : v;
}
function latexNum(n){            // 1.5 -> "1,5" ; -0 -> "0"
  const v = nice(n, 2);
  return String(v).replace('.', ',').replace(/^-0$/, '0');
}
// a(x-r1)(x-r2) en LaTeX (a peut √™tre d√©cimal, 1 ou -1)
function latexFactor(a, r1, r2){
  const aAbs = Math.abs(a);
  const aPart =
    (Math.abs(a-1) < 1e-12)  ? '' :
    (Math.abs(a+1) < 1e-12)  ? '-' :
    (a<0 ? '-' : '') + latexNum(aAbs);
  const part = r => '(x ' + (r<0? '+':'-') + ' ' + latexNum(Math.abs(r)) + ')';
  return aPart + part(r1) + part(r2);
}

function polyHTML(a,b,c){
  a = nice(a,2); b = nice(b,2); c = nice(c,2);
  const t=[];
  // ax^2
  if(a===1) t.push('x<sup>2</sup>');
  else if(a===-1) t.push('‚àíx<sup>2</sup>');
  else t.push((a<0?'‚àí':'')+Math.abs(a)+'x<sup>2</sup>');
  // bx
  if(b!==0){
    const s = (b<0? ' ‚àí ' : ' + ');
    const m = Math.abs(b)===1 ? 'x' : Math.abs(b)+'x';
    t.push(s+m);
  }
  // c
  if(c!==0){
    const s = (c<0? ' ‚àí ' : ' + ');
    t.push(s+Math.abs(c));
  }
  return t.join('');
}

function fmtA(a){
  if(Math.abs(a-1)<1e-12)  return '';      // a =  1 ‚Üí rien
  if(Math.abs(a+1)<1e-12)  return '‚àí';     // a = -1 ‚Üí signe seul
  return (a<0?'‚àí':'') + nice(Math.abs(a)); // d√©cimaux OK
}
function parseSetLoose(input){
  if(!input) return { list:[], isEmptySyntax:false };

  let s = String(input).trim();

  // ‚àÖ, {}, S={}, (avec espaces)
  if(/^(S\s*=\s*)?(‚àÖ|\{\s*\})$/i.test(s)){
    return { list:[], isEmptySyntax:true };
  }

  // enlever "S=" optionnel + accolades optionnelles
  s = s.replace(/^S\s*=\s*/i,'').replace(/^\{|\}$/g,'');

  // split par ; ou ,  ; nombres avec virgule accept√©s
  const parts = s.split(/[;,]/).map(t => t.trim()).filter(Boolean);
  const nums = parts
    .map(t => Number(t.replace(',', '.')))
    .filter(v => Number.isFinite(v));

  nums.sort((a,b)=>a-b);
  return { list: nums, isEmptySyntax:false };
}

function eqSets(a,b){
  if(a.length!==b.length) return false;
  for(let i=0;i<a.length;i++) if(Math.abs(a[i]-b[i])>1e-9) return false;
  return true;
}

// ------- racines avec sommet visible et x1<0<x2 (√©vite doublons)
function rootsWithVisibleVertex(a){
  const maxGap = Math.max(1, Math.floor(4 / Math.sqrt(Math.abs(a)))); // |x2-x1| ‚â§ 4/‚àö|a|
  let tries = 0;
  while(++tries < 200){
    const x2 = rint(1, 6);                 // √©largit le choix des racines
    const gap = rint(1, maxGap);
    const x1 = x2 - gap;                   // < 0 automatiquement
    if(x1 >= -6 && x1 <= -1) return [x1, x2];
  }
  return [-1,1];
}

// ------- fabrique une courbe unique (a,x1,x2) (ordre des racines ignor√©)
function uniqueCurve(a, used){
  let tries = 0;
  while(++tries < 200){
    const [x1,x2] = rootsWithVisibleVertex(a);
    const s1 = Math.min(x1,x2), s2 = Math.max(x1,x2);
    const sig = `${nice(a,3)}|${s1}|${s2}`;
    if(!used.has(sig)){ used.add(sig); return {a, x1:s1, x2:s2}; }
  }
  return {a, x1:-1, x2:1};
}

// Coefficients 'a' autoris√©s, entiers + d√©cimaux
const A_POS = [0.5, 0.8, 1, 1.2, 1.5, 2];
const A_NEG = A_POS.map(v => -v);

// Fabrique toutes les combinaisons (a, x1<0, x2>0) dont le sommet est visible
function allCombos(a){
  const list=[];
  const xmin=-6, xmax=6, ymin=-4, ymax=4;
  // contrainte sommet: |yS| = |a|*(gap^2)/4 <= 4  ‚áí gap <= 4/sqrt(|a|)
  const maxGap = Math.floor(4/Math.sqrt(Math.abs(a))) || 1;
  for(let x2=1; x2<=5; x2++){
    for(let gap=1; gap<=maxGap; gap++){
      const x1 = x2 - gap;        // n√©gatif
      if(x1>=-5 && x1<=-1){
        list.push({a, x1, x2});
      }
    }
  }
  return list;
}
function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
// --- helpers d'affichage coefficient √ó (mon√¥me)
// remplace ta version de term() par celle-ci
function term(k, body){
  if (Math.abs(k) < 1e-12) return '';
  const s = (k < 0 ? ' ‚àí ' : ' + ');
  const m = Math.abs(k);

  if (!body) {                 // constante : on AFFICHE le 1
    return s + nice(m);
  } else {                     // mon√¥me : on cache le 1 devant la variable
    return s + (m===1 ? body : nice(m) + '\\,' + body);
  }
}

function ax2_tex(a){                             // ax^2 sans '1'
  if (a=== 1)  return 'x^{2}';
  if (a===-1)  return '‚àíx^{2}';
  return latexNum(a) + 'x^{2}';
}
function a_tex_prefix(a){                        // a devant ( ‚Ä¶ ), sans '1'
  if (a=== 1)  return '';
  if (a===-1)  return '‚àí';
  return latexNum(a);
}
function coeffTimesX(num, den){
  // retourne le mon√¥me (num/den)¬∑x sans montrer "1x" ni "-1x"
  if(den<0){ den=-den; num=-num; }
  const g = _gcd(Math.abs(num), den) || 1;
  num/=g; den/=g;
  if(den===1 && Math.abs(num)===1) return (num<0? '‚àíx' : 'x');
  const coeff = (den===1) ? String(num) : '\\dfrac{'+num+'}{'+den+'}';
  return coeff + 'x';
}
function leadCoeff(k){                 // k peut √™tre ¬±1, ¬±2, ...
  const a = Math.abs(k);
  return (k<0?'‚àí':'') + (a===1 ? '' : latexNum(a));
}
function ensureSteps(host, title='Solution'){
  let box = host.querySelector('.steps');
  if(!box){
    box = document.createElement('div');
    box.className = 'steps';
    box.innerHTML = `<h4>${title}</h4><div class="line"></div>`;
    host.appendChild(box);
  }
  box.style.display = '';     // visible quand on demande la solution
  return box;
}
function normFactoInput(raw){
  return String(raw||'')
    .replace(/^f\s*\(\s*x\s*\)\s*=\s*/i,'')   // autorise "f(x)=" devant
    .replace(/\u2212|‚àí/g,'-')                 // vrai ‚àí -> '-'
    .replace(/\s+/g,'')                       // espaces
    .replace(/¬∑/g,'*')                        // point centr√©
    .replace(/\)\(/g,')*(')                   // ‚Ä¶)(‚Ä¶ -> ‚Ä¶)*(‚Ä¶
    .replace(/(\d|\))\(/g,'$1*(')             // 2(‚Ä¶ -> 2*(‚Ä¶
    ;
}

// parse un produit factoris√© en a * (x- r1) * (x- r2)
// renvoie { ok, a, roots:[r1,r2] } si factoris√©, sinon { ok:false }
function parseFactorizedQuad(raw){
  const s = normFactoInput(raw);
  if(!s) return { ok:false };

  // on d√©coupe par * (apr√®s normalisation)
  const parts = s.split('*').filter(Boolean);
  if(parts.length < 2) return { ok:false };

  let a = 1;
  const roots = [];

  for(let t of parts){
    // coefficient nu ou parenth√©s√© : -2  |  (-2)
    if(/^-\d+$/.test(t) || /^\d+$/.test(t) || /^\(-?\d+\)$/.test(t)){
      const k = parseInt(t.replace(/[()]/g,''),10);
      if(Number.isFinite(k)) a *= k;
      else return { ok:false };
      continue;
    }

    // facteur lin√©aire : (x¬±k) avec k entier ; k peut √™tre parenth√©s√©, ex: (x-(-3))
    //        1: signe ¬±   2: k (peut √™tre pr√©fix√© d‚Äôun -)
    const m = t.match(/^\(x([+\-])\((-?\d+)\)\)$/) || t.match(/^\(x([+\-])(-?\d+)\)$/);
    if(m){
      const sign = m[1];
      const k    = parseInt(m[2],10);
      if(!Number.isFinite(k)) return { ok:false };
      // (x - r) ‚áî facteur (x ‚àí sign*k) avec r = (sign==='-') ? k : -k
      const r = (sign === '-') ? k : -k;
      roots.push(r);
      continue;
    }

    // tout autre chose ‚Üí pas une √©criture factoris√©e attendue
    return { ok:false };
  }

  if(roots.length !== 2) return { ok:false };
  return { ok:true, a, roots: roots.sort((u,v)=>u-v) };
}
function factorLabel(r){             // pour les libell√©s de lignes du tableau
  return (r === 0) ? 'x' : ('x‚àí' + r);
}
function factorPart(r){              // pour l‚Äôexpression a(x‚àíx1)(x‚àíx2)
  if (r === 0) return 'x';
  return '(x ' + (r<0 ? '+ ' : '‚àí ') + Math.abs(r) + ')';
}
function latexFactorShort(a, r1, r2){ // remplace ta version actuelle
  const A = (a===1 ? '' : (a===-1 ? '‚àí' : String(a)));
  return A + factorPart(r1) + factorPart(r2);
}

function typesetOnce(el){
  try{
    if (window.MathJax?.typesetPromise) MathJax.typesetPromise([el]);
    else if (window.MathJax?.typeset)   MathJax.typeset([el]);
  }catch(_){}
}


// ============== REGISTRY (8 exercices) =================
const REGISTRY=[
/* ------------------------------------------------------------------ *
 * EX 1 ‚Äî 4 courbes (2 avec a>0 ; 2 avec a<0). Associer fonction‚Üîcourbe
 * ------------------------------------------------------------------ */
{
  id:'ex1_4curves_match',
  title:'Ex. 1 ‚Äî Associer 4 courbes (2 avec a>0, 2 avec a<0)',
  gen(){
  // ‚Ä¶ (ta construction de curves comme avant) ‚Ä¶
  let poolPos=[], poolNeg=[];
  A_POS.forEach(a => poolPos = poolPos.concat(allCombos(a)));
  A_NEG.forEach(a => poolNeg = poolNeg.concat(allCombos(a)));
  poolPos = shuffle(poolPos); poolNeg = shuffle(poolNeg);

  let curves = [ poolPos.pop(), poolPos.pop(), poolNeg.pop(), poolNeg.pop() ];
  curves = shuffle(curves);                       // ordre d‚Äôaffichage al√©atoire

  // ‚¨áÔ∏è labels C_i m√©lang√©s et attach√©s aux courbes
  const labNums = shuffle([1,2,3,4]);
  curves.forEach((c, i) => { c.lab = labNums[i]; });

  // forms restent f1‚Üíf4 dans l‚Äôordre d‚Äôaffichage (pas de shuffle ici)
  const forms = curves.map((c,i)=>{
    const P = polyExpand(c.a,c.x1,c.x2);
    return { idx:i+1, a:c.a, x1:c.x1, x2:c.x2, poly:P, label:'f'+(i+1) };
  });

  return { curves, forms };
},





  render(host, st){
    host.innerHTML = [
      '<div class="host-title">Associer chaque fonction propos√©e √† la courbe correspondante (√©crire <code>c1</code>, <code>c2</code>, <code>c3</code> ou <code>c4</code>).</div>',
      '<div id="g1"></div>',
      '<div class="legend">',
        st.forms.map(f=>{
  const fac = latexFactor(f.a, f.x1, f.x2);  // a,r1,r2 num√©riques
  return '<div class="item">'
       +  '<strong>\\( f_{'+f.idx+'}(x) = '+fac+' \\)</strong>'
       +  '<div style="margin-top:6px">'
       +    // ‚Ä¶ dans le map(f => ‚Ä¶)
'Courbe : <input class="ans" data-kind="ex1" data-target="'+f.idx+
'" placeholder="C1 ‚Ä¶ C4" style="width:92px"> <span class="tick nu"></span>'

       +  '</div>'
       +'</div>';
}).join(''),
      '</div>',
	  
	  
          ].join('');
    drawParabolaSVG($('#g1'), st.curves);
// Cr√©e un bloc sp√©cial pour le PDF qui contient **√©nonc√© + figure + l√©gende**
const pdf = document.createElement('div');
pdf.className = 'equ-offscreen';
pdf.style.display = 'none'; // invisible √† l‚Äô√©cran

// ‚Ä¶ apr√®s avoir cr√©√© pdf = document.createElement('div') ‚Ä¶
const legendCards = Array.from(host.querySelectorAll('.legend .item')).map(card => {
  const clone = card.cloneNode(true);
  // enl√®ve les champs et les ticks
  clone.querySelectorAll('input, select, .tick').forEach(el => el.remove());
  // remplace la ligne "Courbe : [champ]" par un texte simple
  const line = clone.querySelector('div'); // c‚Äôest la 2e ligne du .item
  if (line) line.textContent = 'Courbe : ______';
  return clone.outerHTML;
}).join('');

// bloc PDF = √©nonc√© + figure + l√©gende "propre"
pdf.innerHTML = `
  <div class="statement">
    Associer chaque fonction propos√©e √† la courbe correspondante.
  </div>
  ${document.querySelector('#g1').outerHTML}
  <div class="legend no-inputs">
    ${legendCards}
  </div>
`;
host.appendChild(pdf);




	cleanTextNodes(host);  
	typeset(host); 
  }
  ,
correct(host, st){
  let ok = 0, tot = 0;
  const inputs = $all('input.ans[data-kind="ex1"]', host);

  // Normalise "c1", "C 1", "1"  ‚Üí "C1"
  const norm = s => {
    s = String(s||'').trim().toUpperCase().replace(/\s+/g,'');
    const m = s.match(/^C?([1-4])$/);
    return m ? 'C'+m[1] : '';
  };

  inputs.forEach((inp, i) => {
    const got  = norm(inp.value);
    const lab  = (st.curves[i] && st.curves[i].lab!=null) ? st.curves[i].lab : (i+1); // attendu
    const want = 'C'+lab;

    if(!got){ setTick(inp.nextElementSibling, null); return; } // neutre si vide
    tot++;
    const good = (got === want);
    if(good) ok++;
    setTick(inp.nextElementSibling, good); // ‚úì / ‚úó
  });

  return { ok, total: tot };
},

solution(host, st){
  // Remplit explicitement les correspondances f_i ‚Üí C_j
 const solLatex = st.curves.map((c,i)=>{
  const lab = c.lab ?? (i+1); // si tu utilises l‚Äôalternance C_i m√©lang√©e
  return '\\( f_{'+(i+1)+'} \\;\\rightarrow\\; C_{'+lab+'} :'
       + ' \\; a = '+latexNum(c.a)
       + ' ,\\; x_{1} = '+c.x1
       + ' ,\\; x_{2} = '+c.x2+' \\)';
}).join(' <br> ');   // s√©parateur visuel

    const box = ensureSteps(host, 'Solution');
box.innerHTML = solLatex;    // ‚ö†Ô∏è innerHTML (pas textContent)
typeset(box);                // re-typesetter juste cette zone
}

},

/* ------------------------------------------------------------------ *
 * EX 2 ‚Äî Une seule courbe. Deviner f(x)=a(x‚àíx1)(x‚àíx2) gr√¢ce aux infos.
 * ------------------------------------------------------------------ */
{
  id:'ex2_guess_from_curve',
  title:'Ex. 2 ‚Äî Retrouver f(x) √† partir d‚Äôune courbe (une seule)',
  gen(){
  // Hauteurs max pour garder la courbe lisible dans le rep√®re (‚àí6..6)
  const LIMIT_Y_S  = 5;  // borne pour le sommet (cas racines distinctes)
  const LIMIT_Y0   = 5;  // borne pour f(0) (cas racine double)

  // Candidats pour 'a' (entiers + fractions simples)
  const A_CAND = [
    -5,-4,-3,-2,-1, -1.5, -2/3, -1/2, -1/3, -1/4,
     1/4, 1/3, 1/2,  2/3,   1,   1.5,   2,    3,   4, 5
  ];

  // On choisit le type de configuration (ajout de 'doubleRoot')
  const kind = choice(['mixed','bothNeg','bothPos','doubleRoot']);

  let x1=0, x2=0, gap=0, a=null, tries=0;

  if(kind==='doubleRoot'){
    // ===== Racine double r ; contrainte |a*r^2| ‚â§ LIMIT_Y0 pour voir (0;f(0))
    while(++tries < 400){
    const r = choice([-5,-4,-3,-2,-1,1,2,3,4,5]); // r ‚â† 0
    const r2 = r*r;

    // borne sur |a| issue de la visibilit√©
    const aMax = LIMIT_Y0 / r2 + 1e-12;

    // on filtre les 'a' candidats :
    // 1) |a| ‚â§ aMax ; 2) a ‚â† 0 ; 3) a*r^2 entier
    const pool = A_CAND.filter(v=>{
      if(Math.abs(v) > aMax || Math.abs(v) < 1e-12) return false;
      const {num,den} = fracFromNumber(v);           // v = num/den irr√©ductible
      return (num * r2) % den === 0;                 // f(0) entier
    });

    if(pool.length){
      a  = choice(pool);
      x1 = r; x2 = r; gap = 0;
      break;
    }
  }
}else{
    // ===== Racines distinctes ; sommet entier & visible : |yS|=|a|*gap^2/4 ‚â§ LIMIT_Y_S
    const pickPair = (kind) => {
  let _x1=0,_x2=0,_g=0,t=0;
  while(++t<400){
    if(kind==='mixed'){ _x1=rint(-5,-1); _x2=rint(1,5); }
    else if(kind==='bothNeg'){ _x1=rint(-5,-2); _x2=rint(_x1+1,-1); }
    else{ _x1=rint(1,4); _x2=rint(_x1+1,5); } // bothPos
    _g=_x2-_x1;
    if(_g%2===0) return {x1:_x1,x2:_x2,g:_g}; // g pair ‚áí xS entier
  }
  return {x1:-5,x2:-3,g:2};
};

    while(++tries < 400){
  const p = pickPair(kind); x1=p.x1; x2=p.x2; gap=p.g;
  const aMax = 4*LIMIT_Y_S/(gap*gap) + 1e-12; // |a|‚â§4L/g^2
  // Filtre des a : |a|‚â§aMax ET yS entier  ‚áî  (num*gap^2) multiple de (4*den)
  const pool = A_CAND.filter(v => {
    if(Math.abs(v) > aMax || Math.abs(v) < 1e-12) return false;
    const {num,den} = fracFromNumber(v);
    const top = Math.abs(num*gap*gap), bot = 4*den;
    return top % bot === 0; // yS entier
  });
  if(pool.length){ a = choice(pool); break; }
}
  }

  // Valeurs utiles (calcul√©es apr√®s avoir fix√© a, x1, x2)
  const xm = (x1 + x2)/2;                       // entier si gap pair
  const ym = a * (xm - x1) * (xm - x2);         // sommet (0 si racine double)
  const y0 = a * (0 - x1) * (0 - x2);           // ordonn√©e √† l‚Äôorigine

  // Flag pratique pour l‚Äô√©nonc√©/solution
  const isDouble = (x1 === x2);

  return { a, x1, x2, y0, xm, ym, isDouble };
}
,



  render(host, st){
  const curves=[{a:st.a,x1:st.x1,x2:st.x2}];

  const intro = st.isDouble
    ? `La courbe \\(C_f\\) est la courbe de la fonction \\(f\\) d√©finie par \\(f(x)=a(x-\\alpha)¬≤\\) et passe par \\((0; ${st.y0})\\). Retrouver \\(f(x)\\).`
    : `La courbe \\(C_f\\) est la courbe de la fonction \\(f\\) d√©finie par \\(f(x)=a(x-x_1)(x-x_2)\\). Retrouver \\(f(x)\\).`;

  host.innerHTML=[
    '<div class="host-title">'+intro+'</div>',
    '<div id="g2"></div>',
    '<div style="margin-top:8px">R√©ponse attendue (toute forme alg√©briquement √©quivalente est accept√©e) : </div>',
    '<div>\\(f(x)=\\)<input class="ans" id="ex2_f" placeholder="" style="width:320px"> <span class="tick nu"></span></div>',
    // zone solution minimaliste, on laisse solution(host,st) la remplir joliment
  ].join('');

  drawParabolaSVG($('#g2'), curves);
  // === Bloc PDF (sans saisie) ===
(function(){
  const pdf = document.createElement('div');
  pdf.className = 'equ-offscreen';

  const intro = st.isDouble
    ? `La courbe \\(C_f\\) est celle de \\(f(x)=a(x-\\alpha)^2\\) et passe par \\((0; ${st.y0})\\). Retrouver \\(f(x)\\).`
    : `La courbe \\(C_f\\) est celle de \\(f(x)=a(x-x_1)(x-x_2)\\). Retrouver \\(f(x)\\).`;

  pdf.innerHTML = `
    <div class="statement">${intro}</div>
    ${document.querySelector('#g2').outerHTML}
    <div style="margin-top:6px">R√©ponse : \\( f(x) = \\) <span class="blank" style="min-width:260px"></span></div>
  `;
  host.appendChild(pdf);
  typesetOnce(pdf);
})();

  cleanTextNodes(host);
  typeset(host);
},

  correct(host, st){
  const inp = $('#ex2_f', host);
  const got = (inp.value||'').trim();
  let good = false;
  if(got){
    good = _algebraEqUser(got, st.a, st.x1, st.x2);
  }
  setTick(inp.nextElementSibling, got ? good : null);
  return { ok: good?1:0, total: got?1:0 };
},

// --- Exercice 2 : solution compl√®te (intro + calculs d√©taill√©s + conclusion)
solution(host, st){
    const box = ensureSteps(host, 'Solution');

  const n  = x => String((Math.round((+x + Number.EPSILON)*100)/100))
                   .replace('.',',').replace(/^-0$/,'0');
  const lines=[]; const seen=new Set();
  const add = s => pushUnique(lines, s, seen);

  const coefLatex = (num,den) => {
    if(den===1 && num=== 1) return '';
    if(den===1 && num===-1) return '‚àí';
    return latexFrac(num,den) + '\\,';
  };

  if(st.isDouble){
    // ====== Racine double
    const r  = st.x1;             // (‚â†0 d'apr√®s le gen())
    const y0 = st.y0;
    const rAbs = Math.abs(r);
    const r2 = r*r;

    // Intro + choix du point
    add('<strong>Sur le graphique</strong>, la courbe \\(\\mathcal{C}_f\\) admet une <em>racine double</em> en \\(x='+n(r)+'\\).');
    add('Donc le sommet est \\(S('+n(r)+';0)\\) et \\(f(x)=a\\,(x-'+n(r)+')^{2}\\).');
    add('Pour d√©terminer \\(a\\), on utilise l‚Äôordonn√©e √† l‚Äôorigine lisible \\((0;'+n(y0)+')\\).');

    // √âtapes calcul√©es, en fraction irr√©ductible
    const fy   = fracFromNumber(y0);        // y0 = num/den
    const aNum0 = fy.num;                   // a = y0 / r^2
    const aDen0 = fy.den * r2;
    const aRed  = fracReduce(aNum0, aDen0);

    add(`\\( a(0 ${r<0?'+':'-'} ${n(rAbs)})^{2} = ${n(y0)} \\)`);
    add(`\\( a \\times ${n(rAbs)}^{2} = ${n(y0)} \\)`);
    add(`\\( ${r2}a = ${n(y0)} \\)`);
    add(`\\( a = ${latexFrac(aNum0, aDen0)} \\)`);
	    add(`\\( a =  ${latexFrac(aRed.num, aRed.den)} \\)`);

    if(aRed.den===1) add(`\\( a = ${aRed.num} \\)`);

    // Conclusion
    const aTex = coefLatex(aRed.num, aRed.den);
    add('<strong>Conclusion.</strong> On obtient \\(a = '+latexFrac(aRed.num,aRed.den)+'\\), donc '
       + '\\[ f(x) = '+aTex+'(x-'+n(r)+')^{2} \\]');

    const inp = host.querySelector('#ex2_f');
    if(inp && !inp.value) inp.value = `${st.a}*(x-(${r}))*(x-(${r}))`;

  }else{
    // ====== Deux racines distinctes
    const x1 = st.x1, x2 = st.x2;
    const xm = st.xm, ym = st.ym;
    const d1 = xm - x1, d2 = xm - x2, prod = d1*d2;

    // Intro + choix du sommet
    add('<strong>Sur le graphique</strong>, on lit les z√©ros : '
        + '\\(x_1='+n(x1)+'\\) et \\(x_2='+n(x2)+'\\). '
        + 'Donc \\(f(x)=a(x-'+n(x1)+')(x-'+n(x2)+')\\).');
    add('Pour d√©terminer \\(a\\), on utilise le sommet lisible \\(S('+n(xm)+';'+n(ym)+')\\).');

    // √âtapes calcul√©es, en fraction irr√©ductible
    const fym  = fracFromNumber(ym);       // ym = num/den
    const aNum0 = fym.num;                 // a = ym / (d1*d2)
    const aDen0 = fym.den * prod;
    const aRed  = fracReduce(aNum0, aDen0);

    add(`\\( a(${n(xm)} ${x1<0?'+':'-'} ${n(Math.abs(x1))})(${n(xm)} ${x2<0?'+':'-'} ${n(Math.abs(x2))}) = ${n(ym)} \\)`);
add(`\\( a \\times ${pnum(d1)} \\times ${pnum(d2)} = ${n(ym)} \\)`);
    add(`\\( ${prod}a = ${n(ym)} \\)`);
    add(`\\( a = ${latexFrac(aNum0, aDen0)}  \\)`);
	    add(`\\( a = ${latexFrac(aRed.num, aRed.den)} \\)`);

    if(aRed.den===1) add(`\\( a = ${aRed.num} \\)`);

    // Conclusion
    const aTex = coefLatex(aRed.num, aRed.den);
    add('<strong>Conclusion.</strong> On obtient \\(a = '+latexFrac(aRed.num,aRed.den)+'\\), donc '
       + '\\[ f(x) = '+aTex+'(x-'+n(x1)+')(x-'+n(x2)+') \\]');

  
  }

  box.innerHTML = lines.map(s=>`<div class="line">${s}</div>`).join('');
  

cleanTextNodes(host);  
	typeset(host); 
}

},

/* ------------------------------------------------------------------ *
 * EX 3 ‚Äî Tableau de signe √† remplir selon la courbe
 * ------------------------------------------------------------------ */
{
  id:'ex3_sign_table',
  title:'Ex. 3 ‚Äî Tableau de signe √† partir de la courbe',
 gen(){
  // ----- listes d'entiers pour les racines
  const NEG = [-5,-4,-3,-2,-1];
  const POS = [ 1, 2, 3, 4, 5];

  // ----- candidats pour a (entiers + d√©cimaux)
  const A_CAND = [
    -4,-3.5,-3,-2.5,-2,-1.5,-1.25,-1,-0.75,-0.5,-0.4,-0.33,-0.25,
     0.25,0.33,0.4,0.5,0.75,1,1.25,1.5,2,2.5,3,3.5,4
  ];

  // ----- tirage pond√©r√© : 70% deux racines, 20% double, 10% aucune
  const r = Math.random();
  const mode = (r < 0.70) ? 'two' : (r < 0.90 ? 'double' : 'none');

  let x1=0, x2=0, gap=0, a=null, xm=0, ym=0, kind=null;

  if (mode === 'two') {
    // ‚Äî‚Äî sous-types : mixte / deux n√©gatives / deux positives
    kind = ['mixed','bothNeg','bothPos'][Math.floor(Math.random()*3)];
    // tire deux enti√®res distinctes
    let tries = 0;
    while (++tries < 300) {
      if (kind==='mixed') { x1 = NEG[Math.floor(Math.random()*NEG.length)];
                            x2 = POS[Math.floor(Math.random()*POS.length)]; }
      else if (kind==='bothNeg') {
        const p1 = NEG[Math.floor(Math.random()*NEG.length)];
        const p2 = NEG.filter(v=>v!==p1)[Math.floor(Math.random()*(NEG.length-1))];
        x1 = Math.min(p1,p2); x2 = Math.max(p1,p2);
      } else {
        const q1 = POS[Math.floor(Math.random()*POS.length)];
        const q2 = POS.filter(v=>v!==q1)[Math.floor(Math.random()*(POS.length-1))];
        x1 = Math.min(q1,q2); x2 = Math.max(q1,q2);
      }
      gap = x2 - x1; if (gap>=1) break;
    }
    // borne |a| pour |yS|<=5 : |a| ‚â§ 20/gap^2
    const maxAbsA = 20 / (gap*gap) + 1e-12;
    const pool = A_CAND.filter(v => Math.abs(v) <= maxAbsA && Math.abs(v) > 0);
    if (pool.length) a = pool[Math.floor(Math.random()*pool.length)];
    else {
      const sgn = Math.random()<0.5?-1:1;
      a = Math.max(0.1, Math.min(4, 0.8*maxAbsA)) * sgn;
    }
    a  = Math.round(a*100)/100;
    xm = (x1+x2)/2;
    ym = a*(xm-x1)*(xm-x2);     // |ym| ‚â§ 5 par construction

    return { a, x1, x2, xm, ym, kind, isDouble:false, noRoot:false };

  } else if (mode === 'double') {
    // ‚Äî‚Äî racine double r ‚â† 0 ; yS = 0 automatiquement
    const R = NEG.concat(POS);
    const r0 = R[Math.floor(Math.random()*R.length)];
    x1 = r0; x2 = r0; gap = 0;
    a  = A_CAND.filter(v=>v!==0)[Math.floor(Math.random()*A_CAND.length)];
    a  = Math.round(a*100)/100;
    xm = r0; ym = 0;

    return { a, x1, x2, xm, ym, kind:'doubleRoot', isDouble:true, noRoot:false };

  } else {
    // ‚Äî‚Äî pas de racines : travailler en forme sommet y = a(x - xm)^2 + k
    // choisir a non nul et un sommet (xm quelconque, ym de m√™me signe que a)
    a = A_CAND.filter(v=>v!==0)[Math.floor(Math.random()*A_CAND.length)];
    a = Math.round(a*100)/100;

    // xm au choix (entier pour simplicit√© visuelle)
    const XM_CAND = [-3,-2,-1,0,1,2,3];
    xm = XM_CAND[Math.floor(Math.random()*XM_CAND.length)];

    // ym de m√™me signe que a, 0<|ym|‚â§5
    const mag = [1,2,3,4,5][Math.floor(Math.random()*5)];
    ym = (a>0? +mag : -mag);

    // pour le trac√© et la correction, signaler explicitement ce mode
    return { a, noRoot:true, xm, ym, kind:'noRoot', isDouble:false };
  }
},



  render(host, st){
  const UMINUS = '‚àí';

  function signTableHTML(x1, x2){
    return [
      '<div class="signwrap">',
        '<table id="signTable" class="sign-table" style="width:auto">',
          '<colgroup>',
            '<col class="col-lbl">',
            '<col class="col-int">',
            '<col class="col-zero">',
            '<col class="col-int">',
            '<col class="col-zero">',
            '<col class="col-int">',
          '</colgroup>',
          '<tbody>',
            // Ligne x : ‚àí‚àû | r1 | Œ± | r2 | +‚àû
            '<tr>',
              '<th class="lbl">\\(x\\)</th>',
              '<td class="int cap-left">\\('+UMINUS+'‚àû\\)</td>',
              '<td class="zero">',
                '<div class="cell-inline">',
                  '<input id="r1" class="root" placeholder="r‚ÇÅ">',
                  '<span id="ok_r1" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="int">',
                '<div class="cell-inline">',
                  '<input id="alpha" class="root" placeholder="Œ±">',
                  '<span id="ok_alpha" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="zero">',
                '<div class="cell-inline">',
                  '<input id="r2" class="root" placeholder="r‚ÇÇ">',
                  '<span id="ok_r2" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="int cap-right">\\(+‚àû\\)</td>',
            '</tr>',

            // Ligne f(x) : s1 | z1 | s2 | z2 | s3
            '<tr>',
              '<th class="lbl">\\(f(x)\\)</th>',
              '<td class="int">',
                '<div class="cell-inline">',
                  '<select id="s1" class="sel"><option value=""></option><option>+</option><option>‚àí</option></select>',
                  '<span id="ok_s1" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="zero">',
                '<div class="cell-inline">',
                  '<select id="z1" class="sel"><option value=""></option><option>0</option></select>',
                  '<span id="ok_z1" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="int">',
                '<div class="cell-inline">',
                  '<select id="s2" class="sel"><option value=""></option><option>0</option><<option>+</option><option>‚àí</option></select>',
                  '<span id="ok_s2" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="zero">',
                '<div class="cell-inline">',
                  '<select id="z2" class="sel"><option value=""></option><option>0</option></select>',
                  '<span id="ok_z2" class="tick"></span>',
                '</div>',
              '</td>',
              '<td class="int">',
                '<div class="cell-inline">',
                  '<select id="s3" class="sel"><option value=""></option><option>+</option><option>‚àí</option></select>',
                  '<span id="ok_s3" class="tick"></span>',
                '</div>',
              '</td>',
            '</tr>',
          '</tbody>',
        '</table>',
      '</div>'
    ].join('');
  }
const stepsHtml = st.noRoot
  ? [
      '<div class="steps"><h4>Solution</h4>',
        '<div class="line">Signe de \\(a\\) : '+(st.a>0?'positif (parabole tourn√©e vers le haut)':'n√©gatif (parabole tourn√©e vers le bas)')+'.</div>',
        '<div class="line"><strong>Le polyn√¥me n‚Äôadmet aucune racine r√©elle.</strong></div>',
        '<div class="line">Tableau compl√©t√© :</div>',
        '<div id="ex3_solbox" style="margin-top:6px"></div>',
      '</div>'
    ].join('')
  : [
      '<div class="steps"><h4>Solution</h4>',
        '<div class="line">Signe de \\(a\\) : '+(st.a>0?'positif (parabole tourn√©e vers le haut)':'n√©gatif (parabole tourn√©e vers le bas)')+'.</div>',
        '<div class="line">Racines : \\(x_1='+st.x1+'\\), \\(x_2='+st.x2+'\\).</div>',
        '<div class="line">Tableau compl√©t√© :</div>',
        '<div id="ex3_solbox" style="margin-top:6px"></div>',
      '</div>'
    ].join('');

 host.innerHTML = [
  '<div class="host-title">Soit \\(f\\) une fonction polyn√¥me du second degr√© dont on donne la courbe repr√©sentative ci-dessous.<br>Remplir, en utilisant la courbe, le tableau de signe de \\(f(x)\\)</div>',
  '<div id="g3"></div>',
  signTableHTML(st.x1, st.x2),
].join('');


drawParabolaSVG($('#g3'), [ st ]);
// === Bloc PDF (√©nonc√© + courbe + tableau vierge) ===
(function(){
  function signTablePDF(){
    return `
    <div class="pdf-half">
	<table class="sign-table" style="width:auto" >
      <colgroup>
        <col class="col-lbl"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int">
      </colgroup>
      <tbody>
        <tr>
          <th class="lbl">\\(x\\)</th>
          <td class="int cap-left">‚àí‚àû</td>
          <td class="zero"><span class="blank" style="min-width:70px"></span></td>
          <td class="int"><span class="blank" style="min-width:70px"></span></td>
          <td class="zero"><span class="blank" style="min-width:70px"></span></td>
          <td class="int cap-right">+‚àû</td>
        </tr>
        <tr>
          <th class="lbl">\\(f(x)\\)</th>
          <td class="int"><span class="box"></span></td>
          <td class="zero"><span class="box"></span></td>
          <td class="int"><span class="box"></span></td>
          <td class="zero"><span class="box"></span></td>
          <td class="int"><span class="box"></span></td>
        </tr>
      </tbody>
    </table></div>`;
  }
const cssTable = `
  <style>
    .equ-offscreen .sign-table{
      width:100%;
      border:2px solid #000;
      border-collapse:collapse;   /* plus fiable pour le PDF */
    }
    .equ-offscreen .sign-table th,
    .equ-offscreen .sign-table td{
      border:1px solid #000;      /* on force une bordure partout */
      padding:10px;
      text-align:center;
      vertical-align:middle;
    }
    .equ-offscreen .sign-table .lbl{
      font-weight:700;
      border-right:2px solid #000; /* colonne des labels plus marqu√©e */
      white-space:nowrap;
    }
	@media print {
  .equ-offscreen{
    position: static !important;
    left: 0 !important;
    top: 0 !important;
    width: auto !important;
    height: auto !important;
    overflow: visible !important;
    visibility: visible !important;
    display: block !important;
  }
}
@media print {
  .pdf-half{
    width:50% !important;
    display:inline-block !important;
    vertical-align:top !important;
  }
  .pdf-half .sign-table{
    width:100% !important;   /* le tableau remplit son wrapper √† 50% */
  }
}


  </style>
`;
  const pdf = document.createElement('div');
  pdf.className = 'equ-offscreen';
  pdf.innerHTML = `
    ${cssTable}
    <div class="statement">
      Soit \\(f\\) une fonction polyn√¥me du second degr√© dont on donne la courbe repr√©sentative ci-dessous.
      Remplir, √† l‚Äôaide de la courbe, le tableau de signe de \\(f(x)\\).
    </div>
    ${document.querySelector('#g3').outerHTML}
    ${signTablePDF()}
  `;
  host.appendChild(pdf);
  typesetOnce(pdf);
})();

  cleanTextNodes(host);
  typeset(host);
},


  correct(host, st){
  const v = id => (host.querySelector('#'+id)?.value || '').trim();
  // remplace la version actuelle dans ex3.correct(...)
const setTick = (id, state) => {
  const t = host.querySelector('#ok_'+id);
  if (!t) return;
  t.textContent = '';                 // ‚Üê important : on efface tout texte
  t.classList.remove('ok','ko','nu');
  if (state === null)   t.classList.add('nu');   // neutre
  else if (state)       t.classList.add('ok');   // ‚úì (via ::after en CSS)
  else                  t.classList.add('ko');   // ‚úó (via ::after en CSS)
};


  // signe attendu selon a
  const sign = st.a > 0 ? '+' : '‚àí';

  // valeurs lues
  const R1 = v('r1'), A  = v('alpha'), R2 = v('r2');
  const S1 = v('s1'), Z1 = v('z1'), S2 = v('s2'), Z2 = v('z2'), S3 = v('s3');

  // r√®gles par mode
  const modeDouble = !!st.isDouble;           // racine double ?
  const modeNoRoot = !!st.noRoot;             // pas de racine ?
  const modeTwo    = !modeDouble && !modeNoRoot;

  let ok = 0, tot = 0;

  function chkEqual(id, got, want){
    if (got === '') { setTick(id, null); return; }
    tot++; const good = (got === want);
    if (good) ok++; setTick(id, good);
  }
  function chkEmpty(id, got){
    // si vide ‚Üí neutre (pas compt√©) ; si rempli ‚Üí erreur compt√©e
    if (got === '') { setTick(id, null); return; }
    tot++; setTick(id, false);
  }

  if (modeTwo){
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Deux racines distinctes
    // r1 = x1, alpha = vide, r2 = x2
    chkEqual('r1', R1.replace('‚àí','-'), String(st.x1));
    chkEmpty('alpha', A);                        // doit rester vide
    chkEqual('r2', R2.replace('‚àí','-'), String(st.x2));

    // z1=0, z2=0 ; s1/s2/s3 = mod√®le
    const want = (st.a>0) ? ['+','‚àí','+'] : ['‚àí','+','‚àí'];
    chkEqual('z1', Z1, '0');
    chkEqual('z2', Z2, '0');
    chkEqual('s1', S1, want[0]);
    chkEqual('s2', S2, want[1]);
    chkEqual('s3', S3, want[2]);
  }
  else if (modeDouble){
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Racine double : alpha = r, r1/r2 vides
    chkEmpty('r1', R1);
    chkEqual('alpha', A.replace('‚àí','-'), String(st.x1)); // r stock√© en x1/x2
    chkEmpty('r2', R2);

    // f(x) : 0 sous alpha ‚Üí ici on exige S2 = '0'
    chkEmpty('z1', Z1);
    chkEqual('s2', S2, '0');
    chkEmpty('z2', Z2);

    // signes √† gauche/droite (s1 & s3)
    chkEqual('s1', S1, sign);
    chkEqual('s3', S3, sign);
  }
  else { // modeNoRoot
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Pas de racine : r1/alpha/r2 vides
    chkEmpty('r1', R1);
    chkEmpty('alpha', A);
    chkEmpty('r2', R2);

    // seul s2 = signe ; tous les autres champs doivent rester vides
    chkEmpty('z1', Z1);
    chkEqual('s2', S2, sign);
    chkEmpty('z2', Z2);
    chkEmpty('s1', S1);
    chkEmpty('s3', S3);
  }

  return { ok, total: tot };
},


  solution(host, st){
  const U = '‚àí';

// helpers de cellule
const TD_L   = (html) => `<td class="int cap-left"  style="text-align:left">${html||''}</td>`;
const TD_C   = (html) => `<td class="int"          style="text-align:center">${html||''}</td>`;
const TD_R   = (html) => `<td class="int cap-right" style="text-align:right">${html||''}</td>`;
const TZ     = (html) => `<td class="zero"         style="text-align:center">${html||''}</td>`;

// ligne des x : (r1) | alpha | (r2) selon mode
let x_r1 = '', x_alpha = '', x_r2 = '';
if (!st.noRoot && !st.isDouble){ x_r1 = `\\(${st.x1}\\)`; x_r2 = `\\(${st.x2}\\)`; }
if (st.isDouble){ x_alpha = `\\(${st.x1}\\)`; }

// ligne f(x)
const sgn = st.a>0 ? '+' : '‚àí';
let s1='', z1='', s2='', z2='', s3='';
if (!st.noRoot && !st.isDouble){
  const want = (st.a>0) ? ['+','‚àí','+'] : ['‚àí','+','‚àí'];
  s1 = `<b>${want[0]}</b>`; z1 = `<b>0</b>`;
  s2 = `<b>${want[1]}</b>`; z2 = `<b>0</b>`;
  s3 = `<b>${want[2]}</b>`;
} else if (st.isDouble){
  s1 = `<b>${sgn}</b>`; s2 = `<b>0</b>`; s3 = `<b>${sgn}</b>`;
} else {
  s2 = `<b>${sgn}</b>`;
}

// ‚ö†Ô∏è ICI : pas de LaTeX pour ¬±‚àû, et on utilise TD_L / TD_R
const table = [
  '<table class="sign-table pdf-large">',
    '<colgroup>',
      '<col class="col-lbl"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int">',
    '</colgroup>',
    '<tbody>',
      '<tr>',
        '<th class="lbl">\\(x\\)</th>',
        TD_L('‚àí‚àû'),
        TZ(x_r1),
        TD_C(x_alpha),
        TZ(x_r2),
        TD_R('+‚àû'),
      '</tr>',
      '<tr>',
        '<th class="lbl">\\(f(x)\\)</th>',
        TD_C(s1), TZ(z1), TD_C(s2), TZ(z2), TD_C(s3),
      '</tr>',
    '</tbody>',
  '</table>'
].join('');

    const box = ensureSteps(host, 'Solution');
if (box) box.innerHTML = table;

  // phrase d‚Äôaccompagnement
  const lines = [];
  if (!st.noRoot && !st.isDouble){
    lines.push(`Deux racines : \\(x_1=${st.x1}\\), \\(x_2=${st.x2}\\).`);
    lines.push(`Le signe est ${st.a>0?'\\(+\\) hors des racines et \\(‚àí\\) entre elles':'\\(‚àí\\) hors des racines et \\(+\\) entre elles'}.`);
  } else if (st.isDouble){
    lines.push(`Racine double en \\(x=${st.x1}\\).`);
    lines.push(`Le signe ne change pas de part et d‚Äôautre, et \\(f\\) s‚Äôannule en \\(x=${st.x1}\\).`);
  } else {
    lines.push(`Pas de racine r√©elle. Le signe de \\(f\\) est constant et vaut \\(${sgn}\\).`);
  }
  const step = document.createElement('div');
  step.className = 'line';
  step.innerHTML = lines.join(' ');
  (host.querySelector('.steps')||host).appendChild(step);

  cleanTextNodes(host);
  typeset(host);
},


},

/* ------------------------------------------------------------------ *
 * EX 4 ‚Äî Une seule fonction (x1 et x2 donn√©s). √âcrire la forme factoris√©e
 * ------------------------------------------------------------------ */
{
  id:'ex4_one_function_x1x2',
  title:'Ex. 4 ‚Äî √âcrire la forme factoris√©e (x‚ÇÅ et x‚ÇÇ donn√©s)',
  gen(){
    const a = choice([1,2,-1,-2]);
    const x1 = rint(-4,-1), x2 = rint(1,4);
    const P = polyExpand(a,x1,x2);
    return {a:a,x1:x1,x2:x2,P:P};
  },
render(host, st){
  host.innerHTML = `
    <div class="host-title">
      On consid√®re le polyn√¥me du second degr√© sous forme d√©velopp√©e \\(f(x) = ${polyTeX(st.P.a, st.P.b, st.P.c)}\\).
      On sait que \\(x_1 = ${st.x1}\\) et \\(x_2 = ${st.x2}\\).
    </div>
    <div>Donner la <strong>forme factoris√©e</strong> de \\(f(x)\\) :</div>
    <div style="margin-top:6px">
      \\(f(x)=\\)
      <input class="ans" id="ex4_inp" placeholder="" style="width:360px">
      <span class="tick nu"></span>
    </div>
  `;

  // --- Bloc PDF (√©nonc√© propre, sans doublon) ---
  (function(){
    const pdf = document.createElement('div');
    pdf.className = 'equ-offscreen';
    pdf.innerHTML = `
      <div class="statement">
        On consid√®re le polyn√¥me du second degr√© sous forme d√©velopp√©e  \\(f(x) = ${polyTeX(st.P.a, st.P.b, st.P.c)}\\).
        On sait que \\(x_1 = ${st.x1}\\) et \\(x_2 = ${st.x2}\\).
      </div>
      <div class="statement">
        Donner la <strong>forme factoris√©e</strong> de \\(f(x)\\).
      </div>
    `;
    host.appendChild(pdf);
    typesetOnce(pdf);
  })();

  cleanTextNodes(host);
  typeset(host);
},





 correct(host, st){
  const el = $('#ex4_inp', host);
  const raw = (el.value||'').trim();
  if(!raw){ setTick(el.nextElementSibling, null); return { ok:0, total:0 }; }

  const parsed = parseFactorizedQuad(raw);
  if(!parsed.ok){
    setTick(el.nextElementSibling, false);
    return { ok:0, total:1 };
  }

  const wantR = [st.x1, st.x2].sort((u,v)=>u-v);
  const coefOK = (parsed.a === st.a); // a est limit√© √† ¬±1, ¬±2 ici

  const rootsOK = (parsed.roots[0] === wantR[0] && parsed.roots[1] === wantR[1]);

  const good = coefOK && rootsOK;
  setTick(el.nextElementSibling, good);
  return { ok: good?1:0, total:1 };
},


  // √Ä placer dans l'objet REGISTRY de l'exercice 4 (ex4_one_function_x1x2)
solution(host, st){
    const box = ensureSteps(host, 'Solution');
  if(!box) return;
  // Utilise la fonction d√©j√† d√©finie plus haut :
  // latexFactor(a, r1, r2) ‚Üí rend a(x - r1)(x - r2) en vrai LaTeX,
  // en omettant 1 et en mettant juste '‚àí' pour -1.
  const fac = latexFactor(st.a, st.x1, st.x2);

  box.innerHTML = [
	    '<div class="line">\\( a=\\ '+ st.a +'\\) et on sait que \\(x_1='+st.x1+'\\) et \\(x_2='+st.x2+'\\).</div>',

    '<div class="line">\\( f(x) = a\\,(x - x_1)(x - x_2) \\)</div>',
    '<div class="line">\\( f(x) = '+ fac +' \\)</div>'
  ].join('');

const wrap = host.querySelector('#ex4_steps');
  if(wrap) wrap.style.display = '';   // on r√©v√®le la zone
  cleanTextNodes(host);
  typeset(wrap || host);

}

},

/* ------------------------------------------------------------------ *
 * EX 5 ‚Äî Une fonction avec une seule racine connue (l‚Äôautre enti√®re)
 * ------------------------------------------------------------------ */
{
  id:'ex5_one_known_root',
  title:'Ex. 5 ‚Äî Une racine connue (seconde enti√®re)',
  gen(){
    const a = choice([1,2,-1,-2]);
    const r1 = choice([-4,-3,-2,-1,1,2,3,4]);
    let r2 = choice([-5,-4,-3,-2,-1,1,2,3,4,5].filter(v=>v!=r1));
    const P = polyExpand(a,r1,r2);
    return {a:a,r1:r1,r2:r2,P:P};
  },
  render(host, st){
    host.innerHTML=[
      '<div class="host-title">On consid√®re le polyn√¥me du second degr√© sous forme d√©velopp√©e  \\(f(x) = '+polyTeX(st.P.a,st.P.b,st.P.c)+'\\). On sait que \\(x_1='+st.r1+'\\) est une racine de \\(f(x)\\).</div>',
      '<div>D√©terminer la <strong>forme factoris√©e</strong> de \\(f(x)\\) :</div>',
      '<div>\\(f(x)=\\)<input class="ans" id="ex5_inp" placeholder="" style="width:360px"> <span class="tick nu"></span></div>',
          ].join('');
	
	// --- Bloc PDF (√©nonc√© propre, sans doublon) ---
  (function(){
    const pdf = document.createElement('div');
    pdf.className = 'equ-offscreen';
    pdf.innerHTML = `
      <div class="statement">
        On consid√®re le polyn√¥me du second degr√© sous forme d√©velopp√©e  \\(f(x) = ${polyTeX(st.P.a, st.P.b, st.P.c)}\\).
        On sait que \\(x_1=${st.r1}\\) est une racine de \\(f(x)\\).
      </div>
      <div class="statement">
        Donner la <strong>forme factoris√©e</strong> de \\(f(x)\\).
      </div>
    `;
    host.appendChild(pdf);
    typesetOnce(pdf);
  })();
	cleanTextNodes(host);  
	typeset(host); 
  },
  correct(host, st){
  const el = $('#ex5_inp', host);
  const raw = (el.value || '').trim();

  // champ vide ‚Üí neutre
  if(!raw){
    setTick(el.nextElementSibling, null);
    return { ok:0, total:0 };
  }

  // n'accepte QUE la forme factoris√©e (coef partout, * ou juxtaposition, ‚àí unicode, (x-(-3))‚Ä¶)
  const parsed = parseFactorizedQuad(raw);
  if(!parsed.ok){
    setTick(el.nextElementSibling, false);
    return { ok:0, total:1 };
  }

  // comparaison ordre-indiff√©rent
  const wantA = st.a;
  const wantR = [st.r1, st.r2].sort((u,v)=>u-v);
  const gotR  = parsed.roots.slice().sort((u,v)=>u-v);

  const good = (parsed.a === wantA) && (gotR[0]===wantR[0] && gotR[1]===wantR[1]);

  setTick(el.nextElementSibling, good);
  return { ok: good?1:0, total:1 };
},

  // √Ä mettre dans l'objet REGISTRY de l'exercice 5 (ex5_one_known_root)
// Exo 5 ‚Äî Solution (corrig√©e : pas de const au milieu du tableau)
solution(host, st){
    const box = ensureSteps(host, 'Solution');

  // Donn√©es
  const a  = st.a;
  const x1 = st.r1;            // racine donn√©e
  const c  = st.P.c;           // terme constant de l'√©nonc√©
  const b  = st.P.b;           // coefficient de x (pour v√©rification)

  // x2 = c / (a*x1)  ‚Üí fraction irr√©ductible
  const num0 = c, den0 = a * x1;
  const red  = fracReduce(num0, den0);              // {num, den}
  const x2_tex = latexFrac(red.num, red.den);

  // a en TeX (sans afficher 1 / juste "‚àí" pour -1)
  const a_tex = (a===1 ? '' : (a===-1 ? '‚àí' : latexNum(a)));

  // --- D√©veloppement : 1) "inside" puis 2) distribution
// 1) D√©veloppement √† l‚Äôint√©rieur des parenth√®ses
const coefAbs = Math.abs(st.r1);
const c1 = (coefAbs===1 ? '' : latexNum(coefAbs)+'\\,'); // pas de '1' devant x ou x2
const s3 = (st.r1 < 0 ? ' + ' : ' - ') + c1 + 'x';
const s4 = (st.r1 < 0 ? ' - ' : ' + ') + c1 + 'x_{2}';

const dev_inside =
  '\\( P(x) = ' + a_tex_prefix(st.a) +
  '\\big( x^{2} - x_{2}\\,x' + s3 + s4 + ' \\big) \\)';

// 2) Distribution du facteur a  (signes corrects, jamais de '1x')
const k_x2prod = -st.a;           // coefficient de x¬∑x2
const k_x      = -st.a * st.r1;   // coefficient de x
const k_x2     =  st.a * st.r1;   // coefficient de x2  (oppos√© du pr√©c√©dent)

const dev_distrib =
  '\\( P(x) = ' + ax2_tex(st.a) +
  term(k_x2prod, 'x_{2}\\,x') +
  term(k_x,      'x') +
  term(k_x2,     'x_{2}') + ' \\)';


 const k1 = -st.a;           // devant x_2¬∑x
  const k2 = -st.a * st.r1;   // devant x

  // x2 = red.num / red.den (d√©j√† calcul√© chez toi) :

  // √âtape 1 :  k1 x2 x  +  k2 x
  const step1 = '\\(' + (k1<0?'‚àí':'') + (Math.abs(k1)===1?'':latexNum(Math.abs(k1))) +
                'x_{2}x ' + (k2<0?' ‚àí ':' + ') +
                (Math.abs(k2)===1?'':latexNum(Math.abs(k2))) + 'x\\)';

  // √âtape 2 : substitution de x2 par sa fraction irr√©ductible
  const step2 = '\\(' + (k1<0?'‚àí':'') + (Math.abs(k1)===1?'':latexNum(Math.abs(k1))) +
                ' \\times ' + latexFrac(red.num, red.den) + ' x ' +
                (k2<0?' ‚àí ':' + ') +
                (Math.abs(k2)===1?'':latexNum(Math.abs(k2))) + 'x\\)';

  // √âtape 3 : simplification du produit k1 * x2
  const prod = fracReduce(k1*red.num, red.den);             // coefficient du premier terme
  const term1 = coeffTimesX(prod.num, prod.den);            // ex: "‚àíx" ou "9/4 x"
  const term2 = (Math.abs(k2)===1 ? (k2<0?'‚àíx':'x') : latexNum(k2)+'x');
  const step3 = '\\(' + term1 + (k2<0?' ‚àí ':' + ') + (Math.abs(k2)===1?'x':latexNum(Math.abs(k2))+'x') + '\\)';

  // √âtape finale : somme r√©unie  ‚Üí b¬∑x  (o√π b = ‚àía(x1 + x2))
  const bx_num = -st.a * (st.r1*red.den + red.num);
  const bx_den = red.den;
  const bx     = fracReduce(bx_num, bx_den);
  const final  = '\\(' + coeffTimesX(bx.num, bx.den) + '\\)';

  // insertion dans le HTML (une seule ligne avec des ‚Äú=‚Äù, comme demand√©)
    

  // √âcriture finale a(x‚àíx1)(x‚àíx2) (sans "1")
  const f_tex = (function(){
    const part = r => '(x ' + (r<0? '+ ' : '- ') + latexNum(Math.abs(r)) + ')';
    return a_tex + part(x1) + '(x - ' + x2_tex + ')';
  })();

  const html = [
    '<div class="line">On consid√®re \\(f(x) = ' + polyTeX(st.P.a,st.P.b,st.P.c) + '\\). On sait que \\(x_1=' + latexNum(x1) + '\\) est une racine.</div>',

    '<div class="line">‚Ä¢ La forme factoris√©e est \\( P(x)=a(x-x_1)(x-x_2) \\) avec '
      + '\\( a=' + latexNum(a) + ' \\), \\( x_1=' + latexNum(x1) + ' \\) et \\( x_2=? \\).</div>',

    '<div class="line">On pose \\( P(x) = ' + a_tex + '(x ' + (x1<0?'+ ':'- ') + latexNum(Math.abs(x1)) + ')(x - x_2) \\).</div>',

    '<div class="line"><strong>‚Ä¢ On d√©veloppe :</strong></div>',
    '<div class="line">' + dev_inside   + '</div>',
    '<div class="line">' + dev_distrib  + '</div>',

   '<div class="line"><strong>‚Ä¢ Par unicit√© du polyn√¥me</strong>, on compare le terme sans \\(x\\) :</div>' +
  '<div class="line">\\( ' + leadCoeff(k_x2) + '\\,x_{2} = ' + latexNum(c) +
  ' \\Rightarrow x_{2} = ' + latexFrac(num0, den0) + ' = ' + x2_tex + ' \\)</div>',

'<div class="line"><strong>‚Ä¢ V√©rification (obligatoire)</strong> : </div>',
    '<div class="line">'+step1 + '  = ' + step3 + ' = ' + final + '</div>',
    '<div class="line"><strong>‚Ä¢ Conclusion</strong> : \\( P(x) = ' + f_tex + ' \\).</div>'
  ].join('');

  box.innerHTML = html;
  cleanTextNodes(box);
  typeset(box);
}


},

/* ------------------------------------------------------------------ *
 * EX 6 ‚Äî Forme factoris√©e ‚Üî d√©velopp√©e + racines
 * ------------------------------------------------------------------ */
{
  id:'ex6_facto_dev_roots',
  title:'Ex. 6 ‚Äî Forme factoris√©e ‚Üî d√©velopp√©e et racines',
  gen(){
    const a = choice([1,2,3,4,-1,-2,-3,-4]);
    const x1=rint(-9,-1), x2=rint(1,9);
    const P=polyExpand(a,x1,x2);
    return {a,x1,x2,P};
  },
  render(host, st){
    host.innerHTML=[
	      '<div class="host-title">On consid√®re le polyn√¥me du second degr√© sous forme d√©velopp√©e \\(f(x) = '+polyTeX(st.P.a,st.P.b,st.P.c)+'\\).</div>',
      `<div>1) Montrer que \\(f(x)=`+factorHTML(st.a,st.x1,st.x2)+`\\) en √©crivant l'√©tape du d√©veloppement avec deux termes en \\(x\\).</div>`,
      '<input class="ans" id="ex6_dev" placeholder="ex : ax¬≤+kx+lx+c" style="width:360px"> <span class="tick nu"></span>',
      '<div style="margin-top:8px">2) D√©terminer alors les racines de \\(f(x)\\).</div>',
      '<input class="ans set" id="ex6_roots" placeholder="ex. 1 ; 2"> <span class="tick nu"></span>',
    ].join('');
	
	// --- Bloc PDF (√©nonc√© propre, sans doublon) ---
  (function(){
    const pdf = document.createElement('div');
    pdf.className = 'equ-offscreen';
    pdf.innerHTML = `
      <div class="statement">
        On consid√®re le polyn√¥me du second degr√© sous forme d√©velopp√©e  \\(f(x) = ${polyTeX(st.P.a, st.P.b, st.P.c)}\\).
              </div>
	  <div class="statement">
        1) Montrer que \\(f(x)=${factorHTML(st.a,st.x1,st.x2)}\\).
      </div>
      <div class="statement">
        2) D√©terminer alors les racines de \\(f(x)\\).
      </div>
    `;
    host.appendChild(pdf);
    typesetOnce(pdf);
  })();
	cleanTextNodes(host);  
	typeset(host); 
  },
  correct(host, st){
  // ===== helpers compacts (utilisent les m√™mes r√®gles que l‚Äôexo 2)
  function _toJS(expr){
    let s = String(expr||'').trim();
    s = s
      .replace(/\u2212|‚àí/g,'-')       // minus unicode
      .replace(/,/g,'.')              // virgule -> point
      .replace(/¬≤/g,'**2')            // exposant ¬≤
      .replace(/\^/g,'**')            // ^ -> **
      .replace(/\\sqrt\s*\{([^}]*)\}/gi,'Math.sqrt($1)')
      .replace(/‚àö\s*\(?\s*([^)]*)\s*\)?/gi,'Math.sqrt($1)')
      // multiplications implicites
      .replace(/(\d|\)|x)\s*\(/g,'$1*(')
      .replace(/\)\s*(\d|x)/g,')*$1')
      .replace(/([0-9])\s*([a-zA-Z])/g,'$1*$2')
      .replace(/([a-zA-Z])\s*([0-9])/g,'$1*$2')
      .replace(/([a-zA-Z])\s+([a-zA-Z])/g,'$1*$2');
    return s;
  }
  function _fOf(expr){ const js=_toJS(expr); return Function('x','return ('+js+');'); }
  function _numericEq(got, want){
    let fg, fw; try{ fg=_fOf(got); fw=_fOf(want); }catch(_){ return false; }
    const pts=[-3.2,-1.7,-1,0,0.4,1,2.3,3.7];
    for(const x of pts){
      let yg, yw; try{ yg=+fg(x); yw=+fw(x); }catch(_){ return false; }
      if(!Number.isFinite(yg) || !Number.isFinite(yw)) return false;
      if(Math.abs(yg-yw) > 1e-6) return false;
    }
    return true;
  }

  // ===== Q1 : 2·µâ ligne de d√©veloppement (distribution de a, DEUX termes en x)
  const inp1 = $('#ex6_dev', host);
  const raw1 = (inp1?.value||'').trim();
  let ok1 = false, tot1 = 0;

  if(raw1){
    tot1 = 1;

    // expression "cible" = 2·µâ ligne :  a x^2 + (-a*x1)x + (-a*x2)x + a*x1*x2  (ordre libre)
    const a = st.a, x1 = st.x1, x2 = st.x2;
    const wantForms = [
      `${a}*x^2 + ${-a*x1}*x + ${-a*x2}*x + ${a*x1*x2}`,
      `${a}*x^2 + ${-a*x2}*x + ${-a*x1}*x + ${a*x1*x2}`
    ];

    // 1) √©galit√© num√©rique √† une des deux √©critures (ordre des lin√©aires)
    const numOK = _numericEq(raw1, wantForms[0]) || _numericEq(raw1, wantForms[1]);

// 2) CONTRAINTE DE STRUCTURE : exactement 2 mon√¥mes en x (non regoup√©s)
const normTxt = _toJS(raw1);

// (a) pr√©sence de x^2
const hasX2 = /\bx\s*\*\*\s*2\b/.test(normTxt) || /x¬≤/.test(raw1);

// (b) compter les termes lin√©aires distincts en x
//    apr√®s normalisation on a bien "‚Ä¶ + k*x ‚Ä¶" (on ins√®re les *)
const linTerms = normTxt.match(/(?:^|[^A-Za-z0-9_])(?:[\+\-]?\s*\d+(?:\.\d+)?)\s*\*\s*x(?!\s*\*\*\s*2)\b/g) || [];

// fallback : si quelqu‚Äôun a laiss√© un 1 implicite juste devant x (rare ici),
// autoriser aussi des " + x " / " - x " s√©par√©s
const implicitLin = normTxt.match(/(?:^|[^A-Za-z0-9_])[\+\-]?\s*x(?!\s*\*\*\s*2)\b/g) || [];

// On prend le max des deux d√©tections mais on retire les doublons simples.
const linCount = Math.max(linTerms.length, implicitLin.length);

// valid√© si num√©riquement OK, x^2 pr√©sent, et exactement 2 termes en x
ok1 = !!(numOK && hasX2 && linCount === 2);

  }

  setTick(inp1?.nextElementSibling, raw1 ? ok1 : null);

  // ===== Q2 : racines (inchang√©)
  const inp2 = $('#ex6_roots', host);
  const arr = (function parseSet(s){
    if(!s) return [];
    s = String(s).trim().replace(/^S\s*=\s*\{|\}$/g,'');
    const parts = s.split(/[;,]/).map(x=>x.trim()).filter(Boolean);
    const nums = parts.map(x=> Number(x.replace(',','.'))).filter(v=>!Number.isNaN(v));
    nums.sort((a,b)=>a-b);
    return nums;
  })(inp2?.value||'');

  function eqSets(a,b){
    if(a.length!==b.length) return false;
    for(let i=0;i<a.length;i++) if(Math.abs(a[i]-b[i])>1e-9) return false;
    return true;
  }

  const wantRoots = [st.x1, st.x2].slice().sort((a,b)=>a-b);
  const ok2 = eqSets(arr, wantRoots);
  setTick(inp2?.nextElementSibling, (inp2?.value? ok2 : null));

  return { ok: (ok1?1:0) + (inp2?.value ? (ok2?1:0) : 0),
           total: (raw1?1:0) + (inp2?.value ? 1 : 0) };
},

  // ====== Exercice 6 ‚Äî Solution en tableau 3 colonnes invisible ======
solution(host, st){
    const box = ensureSteps(host, 'Solution');
  const {a, x1, x2, P} = st;   // P = {a,b,c} correspond au d√©veloppement

  // -------- helpers d'affichage (pas de "1x")
  const nice = v => String((Math.round((+v + Number.EPSILON)*100)/100))
                     .replace('.',',').replace(/^-0$/,'0');
  const ax2 = A => (A===1?'x^{2}':A===-1?'‚àíx^{2}':nice(A)+'x^{2}');
  const facLatex = (function(){
    const A = (a=== 1)? '' : (a===-1? '‚àí' : nice(a));
    const part = r => '(x ' + (r<0? '+ ':'- ') + nice(Math.abs(r)) + ')';
    return A + part(x1) + part(x2);
  })();
  // Ajoute un terme "¬± k¬∑body" en √©vitant '1'
  function term(coef, body){
    if(Math.abs(coef)<1e-12) return '';
    const s = (coef<0?' ‚àí ':' + ');
    const m = Math.abs(coef);
    const core = (m===1 ? body : nice(m) + (body? '\\,'+body : ''));
    return s + core;
  }

  // -------- √âtapes d√©taill√©es
  // 1) d√©veloppement "√† l‚Äôint√©rieur" (x^2 ‚àí x2¬∑x ‚àí x1¬∑x + x1x2) en rempla√ßant x1, x2 par leurs valeurs
// √† la place de ton inside actuel :
const inside =
  'x^{2}'
  + term(-x2, 'x')      // ‚àíx2¬∑x  ‚Üí cache le 1 si x2=1 ‚áí "‚àí x"
  + term(-x1, 'x')      // ‚àíx1¬∑x  ‚Üí idem
  + term( x1*x2, '');   // constante x1x2  ‚Üí MONTRE le 1 si = ¬±1


  const step1 = (a===1? '' : a===-1? '‚àí' : nice(a)) + '\\big(' + inside + ' \\big)';

  // 2) distribution de a
  const step2 =
    ax2(a)
    + term(-a*x2, 'x')
    + term(-a*x1, 'x')
    + term( a*x1*x2, '');

  // 3) regroupement en ax^2 + bx + c (avec P.b, P.c)
  const step3 =
    ax2(P.a)
    + term(P.b, 'x')
    + term(P.c, '');

  // 4) √©galit√© √† f(x)
  const step4 = 'f(x)';

  // -------- tableau 3 colonnes (invisible)
 // rows = lignes du tableau 3 colonnes (col1: f factoris√©e une seule fois)
let rows;
if (a === 1) {
  // ‚¨ÖÔ∏è CAS a = ¬±1 : on SUPPRIME la 1 ≥·µâ ligne de d√©tails (step1)
  rows = [
    ['<strong>1) </strong>\\( \\) \\( '+facLatex+'\\)', '=', '\\('+step2+'\\)'], // on commence directement par la distribution
    ['',                         '=', '\\('+step3+'\\)'],
    ['',                         '=', '\\('+step4+'\\)']
  ];
} else {
  // ‚¨ÖÔ∏è CAS g√©n√©ral : on garde les 3 √©tapes
  rows = [
    ['<strong>1) </strong>\\( \\) \\('+facLatex+'\\)', '=', '\\('+step1+'\\)'],
    ['',                         '=', '\\('+step2+'\\)'],
    ['',                         '=', '\\('+step3+'\\)'],
    ['',                         '=', '\\('+step4+'\\)']
  ];
}

  const tableHTML = [
    '<table style="border-collapse:collapse;width:auto;margin:.2rem 0">',
      '<colgroup>',
        '<col style="width:auto">',
        '<col style="width:24px">',
        '<col style="width:auto">',
      '</colgroup>',
      '<tbody>',
        rows.map(r => (
          '<tr>' +
            '<td style="border:none;padding:2px 8px 2px 0;text-align:left">'+ r[0] +'</td>' +
            '<td style="border:none;padding:2px 4px;text-align:center;font-weight:600">=</td>' +
            '<td style="border:none;padding:2px 0 2px 8px;text-align:left">'+ r[2] +'</td>' +
          '</tr>'
        )).join('') +
      '</tbody>',
    '</table>',
    '<div class="line"><strong>On a bien</strong> \\( f(x) = '+facLatex+' \\)</div>',
	// 2) Racines
    '<div class="line" style="margin-top:.4rem"><strong>2)</strong> D‚Äôapr√®s la forme factoris√©e, '+
      'les racines sont \\(x_1='+ nice(x1) +'\\) et \\(x_2='+ nice(x2) +'\\).</div>'
  ].join('');

  box.innerHTML = tableHTML;
  cleanTextNodes(box);
  typeset(box);
}

},

/* ------------------------------------------------------------------ *
 * EX 7 ‚Äî S√©lecteur de types (r√©soudre f(x)=0) : 2nd & 3rd degr√©
 * ------------------------------------------------------------------ */
{
  id:'ex7_selector_types',
  title:'Ex. 7 ‚Äî R√©soudre f(x)=0 (s√©lecteur de types)',
  gen(){
    // ‚Äî‚Äî‚Äî‚Äî‚Äî FABRIQUE UNE BANQUE POUR CHAQUE TYPE ‚Äî‚Äî‚Äî‚Äî‚Äî
    // 1) b = 0  ‚áí ax^2 + c  (on choisit c pour que -c/a soit un carr√© parfait)
    function G_b0(){
      const a = choice([1,2,3,4,5,-1,-2,-3,-4,-5]);
      const u = choice([1,2,3,4,5,6,7,8,9]);                   // racines ¬±u/‚àö(a/¬±1) ‚Üí on force enti√®res
      const c = -a*u*u;                                 // ax^2 - a u^2 = a(x^2-u^2)
      const P = {a:a, b:0, c:c};
      const roots = [ -u, u ].sort((x,y)=>x-y);         // car f(x)=a(x-u)(x+u)
      return { kind:'b0', P, a, u, roots };
    }

    // 2) c = 0  ‚áí ax^2 + bx  = x(ax+b)
    function G_c0(){
      const a = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
      const r = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);     // autre racine enti√®re
      const b = -a*r;                                   // ax^2 - ar x -> racines 0 et r
      const P = {a:a, b:b, c:0};
      const roots = [0, r].sort((x,y)=>x-y);
      return { kind:'c0', P, a, b, roots };
    }

    // 3) Forme canonique  ‚áí (x-h)^2 + k  (on prend k = -u^2 pour 2 racines)
    function G_canon(){
      const h = choice([-9,-8,-7,-6,-5,-4,-2,-1,1,2,3,4,5,6,7,8,9]);
      const u = choice([1,2,3,4,5,6,7,8,9]);
      const k = -u*u;                                   // deux racines : h¬±u
      // f(x) = (x-h)^2 - u^2
      const roots = [h-u, h+u].sort((x,y)=>x-y);
      return { kind:'canon', h, u, k, roots };
    }

    // 4) a(x-Œ±)^2  ‚áí racine double Œ±
    function G_axalpha2(){
      const a = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
      const alpha = choice([-9,-8,-7,-6,-5,-4,-2,-1,1,2,3,4,5,6,7,8,9]);
      return { kind:'axalpha2', a, alpha, roots:[alpha] };
    }

    // 5) a(x-x1)(x-x2)  ‚áí produit de deux facteurs
    function G_facto(){
      const a  = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
      const x1 = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]), x2 = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
      return { kind:'facto', a, x1, x2, roots:[x1,x2].sort((x,y)=>x-y) };
    }

    const bank = {
    b0:       G_b0(),
    c0:       G_c0(),
    canon:    G_canon(),
    axalpha2: G_axalpha2(),
    facto:    G_facto()
  };
  const saved = (typeof localStorage!=='undefined' && localStorage.getItem('ex7_kind')) || 'mix';

  return { kind: saved, bank };
  },

  render(host, st){
    function latexA(a){ return a===1?'':a===-1?'‚àí':String(a); }

    function buildFor(s){
      let enonce='', placeholder='', solList='';
      if(s.kind==='b0'){
        enonce = '\\(f(x) = ' + polyTeX(s.P.a, s.P.b, s.P.c) + '\\)';
        solList = s.roots.join(' ; ');
      }
      if(s.kind==='c0'){
        enonce = '\\(f(x) = ' + polyTeX(s.P.a, s.P.b, 0) + '\\)';
        solList = s.roots.join(' ; ');
      }
      if(s.kind==='canon'){
        enonce = '\\(f(x) = (x‚àí'+s.h+')^{2} '+(s.k<0?'‚àí':'+' )+' '+Math.abs(s.k)+'\\)';
        solList = s.roots.join(' ; ');
      }
      if(s.kind==='axalpha2'){
        enonce = '\\(f(x) = '+latexA(s.a)+'(x‚àí'+s.alpha+')^{2}\\)';
        solList = s.roots[0]+' (racine double)';
      }
      if(s.kind==='facto'){
        enonce = '\\(f(x) = '+ latexFactor(s.a, s.x1, s.x2) +'\\)';
        solList = s.roots.join(' ; ');
      }
      placeholder = 'ex. ' + solList;
      return { enonce, placeholder, solList };
    }

    host.innerHTML = [
      '<div class="host-title">R√©soudre \\(f(x)=0\\) ‚Äî choisir un cas :</div>',
      '<div style="margin:.25rem 0 .6rem">',
        '<select id="ex7_kind" style="padding:6px 8px;border:1px solid #d0d5dd;border-radius:8px">',
                 '<option value="mix">M√©lange (al√©atoire)</option>',
		 '<option value="b0">ax¬≤+c (cas b=0)</option>',
          '<option value="c0">ax¬≤+bx (cas c=0)</option>',
          '<option value="canon">Forme canonique (x-Œ±)¬≤+k</option>',
          '<option value="axalpha2">a(x-Œ±)¬≤</option>',
          '<option value="facto">a(x‚àíx‚ÇÅ)(x‚àíx‚ÇÇ)</option>',
        '</select>',
      '</div>',
      '<div id="ex7_enonce" style="margin:.25rem 0 .5rem"></div>',
      '<div>Donner l‚Äôensemble des solutions (liste s√©par√©e par un ;) :</div>',
      '<input class="ans set" id="ex7_roots" placeholder="" style="max-width:360px"> <span class="tick nu"></span>',
     '<div id="ex7_solref" class="small muted" style="margin-top:6px"></div>'

    ].join('');

// --- (dans render) utilitaire pour √©crire S en TeX ---
function setTexFromRoots(s){
  if(s.kind === 'axalpha2'){
    return `\\(S=\\{${s.alpha}\\}\\) (racine double).`;
  }
  // autres cas : liste ordonn√©e r1 ; r2
  const L = s.roots.map(x => String(x)).join('\\;;\\ ');
  return `\\(S=\\{${L}\\}\\).`;
}

function makePdfBlock(host, s, built){
  // supprimer un ancien bloc PDF s‚Äôil existe (quand on change de cas)
  const old = host.querySelector('.equ-offscreen');
  if(old) old.remove();

  const pdf = document.createElement('div');
  pdf.className = 'equ-offscreen';

  pdf.innerHTML = `
    <div class="statement">
      R√©soudre \\(f(x)=0\\).
    </div>
    <div class="statement">
      ${built.enonce}
    </div>
     `;

  host.appendChild(pdf);
  cleanTextNodes(pdf);
  typesetOnce(pdf); // composition MathJax du bloc PDF uniquement
}



  const sel   = $('#ex7_kind', host);
  const enEl  = $('#ex7_enonce', host);
  const inp   = $('#ex7_roots', host);
const solEl = $('#ex7_solref', host);

   function pickActive(kind){
    if(kind==='mix'){
      const keys = Object.keys(st.bank);
      const k = keys[Math.floor(Math.random()*keys.length)];
      st._activeKind = k;         // m√©morise le tirage du mix courant
      return st.bank[k];
    }
    st._activeKind = kind;
    return st.bank[kind];
  }

 function refresh(){
  const kind = sel.value;
  st.kind = kind;
  try{ localStorage.setItem('ex7_kind', kind); }catch(_){}
  const s = pickActive(kind);
  st._cur = s;

  const built = buildFor(s);

  enEl.innerHTML = built.enonce;
  solEl.innerHTML = '';

  // -- Bloc PDF (√©nonc√© + solution propres) --
  makePdfBlock(host, s, built);

  host.dataset.state = JSON.stringify(st);
  cleanTextNodes(host);
  typeset(host);
}


  sel.value = st.kind;
  sel.addEventListener('change', refresh);
  refresh();
cleanTextNodes(host);
  typeset(host);  
},

correct(host, st){
  const el = $('#ex7_roots', host);
  const txt = el.value || '';

  // champ vide ‚Üí neutre
  if(!txt.trim()){
    setTick(el.nextElementSibling, null);
    return { ok:0, total:0 };
  }

  const parsed = parseSetLoose(txt);

  // solutions attendues selon le cas actif
  const s = st._cur; // (d√©j√† d√©fini dans render)
  let want = [];
  if(s.kind === 'axalpha2')      want = [ s.roots[0] ];
  else                           want = (s.roots||[]).slice().sort((a,b)=>a-b);

  const good = eqSets(parsed.list, want)
            || (parsed.isEmptySyntax && want.length===0); // tol√®re {} si vide attendu

  setTick(el.nextElementSibling, good);
  return { ok: good?1:0, total:1 };
},

solution(host, st){
    const box = ensureSteps(host, 'Solution');

  // ---------- helpers affichage ----------
  const nice = v => String((Math.round((+v + Number.EPSILON)*100)/100))
                      .replace('.',',').replace(/^-0$/,'0');

  // Ajoute une ligne si elle n'existe pas d√©j√† (√©vite les doublons visuels)
  const lines = [];
  const seen  = new Set();
  function pushLine(tex){
    const key = tex.replace(/\s+/g,' ').trim();
    if(!seen.has(key)){ lines.push('<div class="line">'+tex+'</div>'); seen.add(key); }
  }

  // Mon√¥me k¬∑(body). Cache le 1 pour les mon√¥mes (x, x^2, ‚Ä¶), jamais pour les constantes.
  // body: 'x', 'x^{2}', etc.  body === '' ‚Üí constante
  function mono(k, body){
    if(Math.abs(k) < 1e-12) return '';        // au cas o√π
    const s = (k < 0 ? '‚àí' : '');
    const m = Math.abs(k);
    if(!body) return s + nice(m);             // constante : on AFFICHE le 1
    return s + (m===1 ? body : nice(m)+'\\,'+body);
  }

  // ax^2 sans 1
  const ax2 = A => (A=== 1 ? 'x^{2}' : A===-1 ? '‚àíx^{2}' : nice(A)+'x^{2}');
  // a¬∑x sans 1
  const ax  = A => (A=== 1 ? 'x'     : A===-1 ? '‚àíx'     : nice(A)+'x');
  // facteur a en t√™te (x-‚Ä¶)‚Ä¶ sans 1
  const aLead = A => (A=== 1 ? ''     : A===-1 ? '‚àí'      : nice(A));

  // fractions/simplifications
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
  function fracReduce(num, den){ if(den<0){ den=-den; num=-num; } const g=gcd(num,den); return {num:num/g, den:den/g}; }
  const fracTex = (num,den) => den===1 ? String(num) : '\\dfrac{'+num+'}{'+den+'}';
  const isSquare = n => { n=Math.abs(n); const r=Math.floor(Math.sqrt(n)); return r*r===n; };
  function sqrtFrac(num, den){
    num=Math.abs(num); den=Math.abs(den);
    const sN=isSquare(num), sD=isSquare(den);
    if(sN && sD){
      const rN=Math.sqrt(num), rD=Math.sqrt(den);
      return rD===1 ? String(rN) : '\\dfrac{'+rN+'}{'+rD+'}';
    }
    return den===1 ? '\\sqrt{'+num+'}' : '\\sqrt{\\dfrac{'+num+'}{'+den+'}}';
  }

  // ---------- √©tat courant (s√©lecteur) ----------
  const S = st._cur || st.bank[st.kind];

  // ---------- CAS b=0 : ax^2 + c = 0 ----------
  if(S.kind==='b0'){
    const A=S.P.a, C=S.P.c;
    // √âtapes
    pushLine('\\(f(x)=0\\)');
    pushLine('\\('+ ax2(A) + (C<0?' ‚àí ':' + ') + nice(Math.abs(C)) + ' = 0\\)');
    pushLine('\\('+ ax2(A) + ' = '+ nice(-C) +'\\)');
    const fr = fracReduce(-C, A);
    pushLine('\\(x^{2} = '+ fracTex(fr.num, fr.den) +'\\)');
    const sq = sqrtFrac(fr.num, fr.den);
    pushLine('\\(x = -'+sq+' \\;\\;\\text{ou}\\;\\; x = '+sq+'\\)');
    // si la racine est parfaite ‚Üí ligne suppl√©mentaire simplifi√©e (sans dupliquer)
    if(isSquare(fr.num) && isSquare(fr.den)){
      const rN = Math.sqrt(Math.abs(fr.num)), rD = Math.sqrt(Math.abs(fr.den));
      const left  = (rD===1? String(-rN) : '\\dfrac{-'+rN+'}{'+rD+'}');
      const right = (rD===1? String( rN) : '\\dfrac{'+ rN+'}{'+rD+'}');
      pushLine('\\(x = '+left+' \\;\\;\\text{ou}\\;\\; x = '+right+'\\)');
      pushLine('\\(S=\\{ '+left+' ; '+right+' \\}\\)');
    }else{
      pushLine('\\(S=\\{ -\\,'+sq+' ; '+sq+' \\}\\)');
    }
  }

  // ---------- CAS c=0 : ax^2 + bx = 0 ----------
  // ---------- CAS c=0 : ax^2 + bx = 0 ----------
else if (S.kind === 'c0') {
  const A = S.P.a, B = S.P.b;

  // helpers d√©j√† pr√©sents plus haut : ax2(A), ax(A), nice(), fracReduce(), fracTex(), pushLine()

  // √©quations
  const eq2  = ax2(A) + (B<0 ? ' ‚àí ' : ' + ') + nice(Math.abs(B)) + 'x = 0';
  const fact = 'x\\big(' + ax(A) + (B<0 ? ' ‚àí ' : ' + ') + nice(Math.abs(B)) + '\\big) = 0';
  const br2  = ax(A) + (B<0 ? ' ‚àí ' : ' + ') + nice(Math.abs(B)) + ' = 0';
  const br2b = ax(A) + ' = ' + nice(-B); // √©tape manquante : ax = -b

  // fraction pour la derni√®re ligne
  const fr   = fracReduce(-B, A);
  const other = fracTex(fr.num, fr.den);

  pushLine('\\(f(x)=0\\)');
  pushLine('\\(' + eq2 + '\\)');
  pushLine('\\(' + fact + '\\)');
  pushLine('\\(x = 0 \\;\\;\\text{ou}\\;\\; ' + br2 + '\\)');
  // ‚≠ê √âtape interm√©diaire demand√©e :
  pushLine('\\(x = 0 \\;\\;\\text{ou}\\;\\; ' + br2b + '\\)');
  pushLine('\\(x = 0 \\;\\;\\text{ou}\\;\\; x = ' + other + '\\)');
  pushLine('\\(S=\\{ 0 ; ' + other + ' \\}\\)');
}


  // ---------- CAS forme canonique : (x-h)^2 + k = 0 (ici k = -u^2) ----------
  else if(S.kind==='canon'){
    const h=S.h, k=S.k, u=Math.sqrt(Math.abs(k));
    pushLine('\\(f(x)=0\\)');
    pushLine('\\((x‚àí'+nice(h)+')^{2} '+(k<0?'‚àí ':'+ ')+nice(Math.abs(k))+' = 0\\)');
    pushLine('\\((x‚àí'+nice(h)+')^{2} = '+nice(Math.abs(k))+'\\)');
    pushLine('\\(x‚àí'+nice(h)+' = ‚àí\\sqrt{'+nice(Math.abs(k))+'} \\;\\;\\text{ou}\\;\\; x‚àí'+nice(h)+' = \\sqrt{'+nice(Math.abs(k))+'}\\)');
    pushLine('\\(x‚àí'+nice(h)+' = ‚àí'+nice(u)+' \\;\\;\\text{ou}\\;\\; x‚àí'+nice(h)+' = '+nice(u)+'\\)');
    pushLine('\\(x = '+nice(h-u)+' \\;\\;\\text{ou}\\;\\; x = '+nice(h+u)+'\\)');
    pushLine('\\(S=\\{ '+nice(h-u)+' ; '+nice(h+u)+' \\}\\)');
  }

  // ---------- CAS a(x-Œ±)^2 : racine double ----------
  else if(S.kind==='axalpha2'){
    const a=S.a, alpha=S.alpha;
    pushLine('\\(f(x)=0\\)');
    pushLine('\\('+ aLead(a) +'(x‚àí'+nice(alpha)+')^{2} = 0\\)');
    pushLine('\\((x‚àí'+nice(alpha)+')^{2} = 0\\)');
    pushLine('\\(x‚àí'+nice(alpha)+' = 0\\)');
    pushLine('\\(x = '+nice(alpha)+'\\)');
    pushLine('\\(S=\\{ '+nice(alpha)+' \\}\\)');
  }

  // ---------- CAS a(x-x1)(x-x2) ----------
  else if(S.kind==='facto'){
    const a=S.a, x1=S.x1, x2=S.x2;
    pushLine('\\(f(x)=0\\)');
    pushLine('\\('+ aLead(a) +'(x‚àí'+nice(x1)+')(x‚àí'+nice(x2)+') = 0\\)');
    pushLine('\\(x‚àí'+nice(x1)+' = 0 \\;\\;\\text{ou}\\;\\; x‚àí'+nice(x2)+' = 0\\)');
    pushLine('\\(x = '+nice(x1)+' \\;\\;\\text{ou}\\;\\; x = '+nice(x2)+'\\)');
    const lo = Math.min(x1,x2), hi = Math.max(x1,x2);
    pushLine('\\(S=\\{ '+nice(lo)+' ; '+nice(hi)+' \\}\\)');
  }

  // ---------- rendu ----------
  box.innerHTML = lines.join('');
  cleanTextNodes(box);
  typeset(box);
}


},

/* ------------------------------------------------------------------ *
 * EX 8 ‚Äî Une seule in√©quation (produit de deux facteurs)
 * ------------------------------------------------------------------ */
{
  id:'ex8_ineq_table',
  title:'Ex. 8 ‚Äî R√©soudre une in√©quation avec tableau de signes',
  gen(){
  const a = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);

  // Tirage avec garantie x1 < x2 et x1 != x2
  let x1 = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]), x2 = choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
  while(x2 === x1) x2 = rint(-5,5);
  if(x1 > x2) [x1, x2] = [x2, x1];

const cmp = choice(['<','>','‚â§','‚â•']);
  const P = polyExpand(a, x1, x2);
  return { a, x1, x2, P, cmp };
},


  render(host, st){
    const hasA = (Math.abs(st.a) !== 1);

    function hdrRow(){
  return [
    '<tr>',
      '<th class="lbl">\\(x\\)</th>',
      '<td class="int cap-left">‚àí‚àû</td>',
      // ‚Äî colonne de x1 (entr√©e utilisateur)
      '<td class="zero">',
        '<div class="cell-inline">',
          '<input id="hdr_r1" class="root no-pdf" placeholder="">',
          '<span id="ok_hdr_r1" class="tick"></span>',
        '</div>',
      '</td>',
      '<td class="int"></td>',
      // ‚Äî colonne de x2 (entr√©e utilisateur)
      '<td class="zero">',
        '<div class="cell-inline">',
          '<input id="hdr_r2" class="root no-pdf" placeholder="">',
          '<span id="ok_hdr_r2" class="tick"></span>',
        '</div>',
      '</td>',
      '<td class="int cap-right">+‚àû</td>',
    '</tr>'
  ].join('');
}

	function lineA(){
      return [
        '<tr>',
          '<th class="lbl"><span>\\('+st.a+'\\)</span></th>',
          '<td class="int"><div class="cell-inline">',
            '<select id="A_L" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_A_L" class="tick"></span>',
          '</div></td>',
          '<td class="zero"></td>',
          '<td class="int"><div class="cell-inline">',
            '<select id="A_M" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_A_M" class="tick"></span>',
          '</div></td>',
          '<td class="zero"></td>',
          '<td class="int"><div class="cell-inline">',
            '<select id="A_R" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_A_R" class="tick"></span>',
          '</div></td>',
        '</tr>'
      ].join('');
    }
    function lineFactor(label, idRoot){
      // signe gauche | 0 | signe milieu | 0 | signe droite
      return [
        '<tr>',
          '<th class="lbl">\\('+label+'\\)</th>',
          '<td class="int"><div class="cell-inline">',
            '<select id="'+idRoot+'_L" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_'+idRoot+'_L" class="tick"></span>',
          '</div></td>',
          '<td class="zero"><div class="cell-inline">',
            '<select id="'+idRoot+'_Z1" class="sel"><option></option><option>0</option></select>',
            '<span id="ok_'+idRoot+'_Z1" class="tick"></span>',
          '</div></td>',
          '<td class="int"><div class="cell-inline">',
            '<select id="'+idRoot+'_M" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_'+idRoot+'_M" class="tick"></span>',
          '</div></td>',
          '<td class="zero"><div class="cell-inline">',
            '<select id="'+idRoot+'_Z2" class="sel"><option></option><option>0</option></select>',
            '<span id="ok_'+idRoot+'_Z2" class="tick"></span>',
          '</div></td>',
          '<td class="int"><div class="cell-inline">',
            '<select id="'+idRoot+'_R" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_'+idRoot+'_R" class="tick"></span>',
          '</div></td>',
        '</tr>'
      ].join('');
    }
    
    function lineProduct(){
      return [
        '<tr>',
          '<th class="lbl">\\(f(x)\\)</th>',
          '<td class="int"><div class="cell-inline">',
            '<select id="F_L" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_F_L" class="tick"></span>',
          '</div></td>',
          '<td class="zero"><div class="cell-inline">',
            '<select id="F_Z1" class="sel"><option></option><option>0</option></select>',
            '<span id="ok_F_Z1" class="tick"></span>',
          '</div></td>',
          '<td class="int"><div class="cell-inline">',
            '<select id="F_M" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_F_M" class="tick"></span>',
          '</div></td>',
          '<td class="zero"><div class="cell-inline">',
            '<select id="F_Z2" class="sel"><option></option><option>0</option></select>',
            '<span id="ok_F_Z2" class="tick"></span>',
          '</div></td>',
          '<td class="int"><div class="cell-inline">',
            '<select id="F_R" class="sel"><option></option><option>+</option><option>‚àí</option></select>',
            '<span id="ok_F_R" class="tick"></span>',
          '</div></td>',
        '</tr>'
      ].join('');
    }

    const table = [
      '<table class="sign-table" style="width:auto">',
        '<colgroup><col class="col-lbl"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int"></colgroup>',
        '<tbody>',
          hdrRow(),
		  hasA ? lineA() : '',
          lineFactor(factorLabel(st.x1), 'R1'),
lineFactor(factorLabel(st.x2), 'R2'),
                    lineProduct(),
        '</tbody>',
      '</table>'
    ].join('');

 // ‚Ä¶ (tout ce que tu as d√©j√†, y compris const table = ‚Ä¶ )

const fx = latexFactorShort(st.a, st.x1, st.x2);

// üîß 1) on ins√®re BIEN le tableau + le champ "intervalle" + la zone solution
host.innerHTML = [
  '<div class="host-title">Compl√©ter le tableau de signes et r√©soudre l‚Äôin√©quation :</div>',
  '<div style="font-size:1.05rem;margin:.3rem 0">',
    '\\('+fx+'\\) ',
    '<select id="ineqSel" style="padding:4px 6px;border:1px solid #d0d5dd;border-radius:8px">',
      '<option value="<">&lt 0</option>',
      '<option value="‚â§">‚â§ 0</option>',
      '<option value=">">&gt 0</option>',
      '<option value="‚â•">‚â• 0</option>',
    '</select>',
      '</div>',
  table, // ‚Üê  ICI le tableau !
  '<div style="margin-top:8px">R√©ponse (intervalle) :</div>',
  '<input class="ans" id="ex8_set" placeholder="" style="max-width:360px"> <span class="tick nu"></span>',
'<div id="ex8_soltext" class="small muted" style="margin-top:6px"></div>'

].join('');

function signTablePDF(st){
  const needA = Math.abs(st.a) !== 1;
  const fx = latexFactorShort(st.a, st.x1, st.x2);

  return `
  <div class="pdf-half">
    <table class="sign-table pdf-large" style="width:auto">
      <colgroup>
        <col class="col-lbl">
        <col class="col-int">
        <col class="col-zero">
        <col class="col-int">
        <col class="col-zero">
        <col class="col-int">
      </colgroup>
      <tbody>
        <tr>
          <th class="lbl">\\(x\\)</th>
          <td class="int cap-left">‚àí‚àû</td>
          <td class="zero"></td>
          <td class="int"></td>
          <td class="zero"></td>
          <td class="int cap-right">+‚àû</td>
        </tr>
        ${needA ? `
        <tr>
          <th class="lbl">\\(\\)</th>
          <td class="int"><span class="box"></span></td>
          <td class="zero"></td>
          <td class="int"><span class="box"></span></td>
          <td class="zero"></td>
          <td class="int"><span class="box"></span></td>
        </tr>` : ''}
        <tr>
          <th class="lbl">\\(\\)</th>
          <td class="int"><span class="box"></span></td>
          <td class="zero"><b></b></td>
          <td class="int"><span class="box"></span></td>
          <td class="zero"></td>
          <td class="int"><span class="box"></span></td>
        </tr>
        <tr>
          <th class="lbl">\\(\\)</th>
          <td class="int"><span class="box"></span></td>
          <td class="zero"></td>
          <td class="int"><span class="box"></span></td>
          <td class="zero"><b></b></td>
          <td class="int"><span class="box"></span></td>
        </tr>
        <tr>
          <th class="lbl">\\(f(x)\\)</th>
          <td class="int"><span class="box"></span></td>
          <td class="zero"><b></b></td>
          <td class="int"><span class="box"></span></td>
          <td class="zero"><b></b></td>
          <td class="int"><span class="box"></span></td>
        </tr>
      </tbody>
    </table>
  </div>`;
}



function makePdfBlock(host, st, cmp, fx, Sinterval){
  // supprime l'ancien bloc si on change le comparateur
  const old = host.querySelector('.equ-offscreen');
  if(old) old.remove();

  const pdf = document.createElement('div');
  pdf.className = 'equ-offscreen';
  pdf.innerHTML = `
    <div class="statement">
      Compl√©ter le tableau de signes et r√©soudre l‚Äôin√©quation.
    </div>
    <div class="statement">
      \\(${fx}\\;${cmp}\\;0\\)
    </div>
	      ${signTablePDF(st)}


    `;
  host.appendChild(pdf);
    cleanTextNodes(pdf);
  typesetOnce(pdf);
}

// üîß 2) calcul initial de la solution attendue + rendu LaTeX IMM√âDIAT
const ineqSel = $('#ineqSel', host);
ineqSel.value = st.cmp;

function recomputeAnswer(){
  const lo = Math.min(st.x1, st.x2);
  const hi = Math.max(st.x1, st.x2);
  const incl = (st.cmp === '‚â§') || (st.cmp === '‚â•');
  const wantInside = (st.cmp === '<' || st.cmp === '‚â§') ? (st.a > 0) : (st.a < 0);

  let ans;
  if (wantInside){
    // entre les racines (racines incluses si ‚â§/‚â•)
    ans = (incl ? '[' : ']') + ' ' + lo + ' ; ' + hi + ' ' + (incl ? ']' : '[');
  } else {
    // √† l‚Äôext√©rieur (‚àû toujours ouvert ; racines incluses si ‚â§/‚â•)
    const L = (incl ? '] ‚àí‚àû ; ' + lo + ' ]' : '] ‚àí‚àû ; ' + lo + ' [');
    const R = (incl ? '[ ' + hi + ' ; +‚àû [' : '] ' + hi + ' ; +‚àû [');
    ans = L + ' ‚à™ ' + R;
  }

  // ‚úÖ ces 2 lignes manquaient
  const sol = $('#ex8_soltext', host);
  host.dataset.ex8want = ans;
      makePdfBlock(host, st, st.cmp, fx, ans);

}


recomputeAnswer();                  // ‚Üê initial
ineqSel.addEventListener('change', ()=>{
  st.cmp = ineqSel.value;
  host.dataset.state = JSON.stringify(st);
  recomputeAnswer();
  cleanTextNodes(host); typeset(host); // re-typeset apr√®s changement
    makePdfBlock(host, st, st.cmp, fx, ans);

});
cleanTextNodes(host); typeset(host);   // ‚Üê rendu LaTeX au premier affichage


  },

correct(host, st){
  // ------- helpers DOM & ticks (sans mettre de texte) -------
  const v = id => (host.querySelector('#'+id)?.value || '').trim();
  const setTick = (id, state) => {
    const t = host.querySelector('#ok_'+id);
    if (!t) return;
    t.textContent = '';
    t.classList.remove('ok','ko','nu');
    if (state === null) t.classList.add('nu');
    else if (state)     t.classList.add('ok');
    else                t.classList.add('ko');
  };

  let ok = 0, tot = 0;
  const needA = (Math.abs(st.a) !== 1);

  // ------- "table complet ?" : toutes les cases qui DOIVENT √™tre remplies --------
  function present(id){ return !!host.querySelector('#'+id); }
  function nonEmpty(id){ return (v(id) !== ''); }
  function tableIsComplete(){
    const req = [
      ...(present('hdr_r1') ? ['hdr_r1'] : []),
      ...(present('hdr_r2') ? ['hdr_r2'] : []),
      // lignes facteurs : on EXCLUT les trous l√©gitimes
      ...(present('R1_L')  ? ['R1_L']  : []),
      ...(present('R1_Z1') ? ['R1_Z1'] : []),
      ...(present('R1_M')  ? ['R1_M']  : []),
      ...(present('R1_R')  ? ['R1_R']  : []),

      ...(present('R2_L')  ? ['R2_L']  : []),
      ...(present('R2_M')  ? ['R2_M']  : []),
      ...(present('R2_Z2') ? ['R2_Z2'] : []),
      ...(present('R2_R')  ? ['R2_R']  : []),

      ...(needA && present('A_L') ? ['A_L'] : []),
      ...(needA && present('A_M') ? ['A_M'] : []),
      ...(needA && present('A_R') ? ['A_R'] : []),

      ...(present('F_L')  ? ['F_L']  : []),
      ...(present('F_Z1') ? ['F_Z1'] : []),
      ...(present('F_M')  ? ['F_M']  : []),
      ...(present('F_Z2') ? ['F_Z2'] : []),
      ...(present('F_R')  ? ['F_R']  : []),
    ];
    return req.every(nonEmpty);
  }
  const allFilled = tableIsComplete();

  // ------- petites v√©rifs utilitaires -------
  const normMinus = s => String(s||'').replace(/\u2212|‚àí/g,'-');

  function check(id, got, want){
    if (!present(id)) return;
    if (!got){ setTick(id, null); return; }
    tot++; const good = (got === want);
    if (good) ok++; setTick(id, good);
  }
  function expectEmpty(id, got){
    if (!present(id)) return;
    if (!got){
      // on ne valide ‚úì (et ne compte) que quand tout le tableau est rempli
      if (!allFilled){ setTick(id, null); return; }
      tot++; ok++; setTick(id, true);
      return;
    }
    // rempli alors que √ßa devait √™tre vide
    tot++; setTick(id, false);
  }

  // ================== 1) En-t√™te : x1 et x2 ==================
  if (present('hdr_r1')){
    const r1 = normMinus(v('hdr_r1'));
    if (!r1){ setTick('hdr_r1', null); }
    else { tot++; const good = (r1 === String(st.x1)); if(good) ok++; setTick('hdr_r1', good); }
  }
  if (present('hdr_r2')){
    const r2 = normMinus(v('hdr_r2'));
    if (!r2){ setTick('hdr_r2', null); }
    else { tot++; const good = (r2 === String(st.x2)); if(good) ok++; setTick('hdr_r2', good); }
  }

  // ================== 2) Lignes facteurs =====================
  // Attendus pour x ‚àí x1 (z√©ro en x1 seulement)
  check('R1_L',  v('R1_L'),  '‚àí');
  check('R1_Z1', v('R1_Z1'), '0');
  check('R1_M',  v('R1_M'),  '+');
  expectEmpty('R1_Z2', v('R1_Z2'));
  check('R1_R',  v('R1_R'),  '+');

  // Attendus pour x ‚àí x2 (z√©ro en x2 seulement)
  check('R2_L',  v('R2_L'),  '‚àí');
  expectEmpty('R2_Z1', v('R2_Z1'));
  check('R2_M',  v('R2_M'),  '‚àí');
  check('R2_Z2', v('R2_Z2'), '0');
  check('R2_R',  v('R2_R'),  '+');

  // ================== 3) Ligne "a" (si |a|‚â†1) =================
  if (needA){
    const sgn = st.a > 0 ? '+' : '‚àí';
    check('A_L', v('A_L'), sgn);
    check('A_M', v('A_M'), sgn);
    check('A_R', v('A_R'), sgn);
  }

  // ================== 4) Ligne produit f(x) ===================
  const out = st.a > 0 ? ['+','‚àí','+'] : ['‚àí','+','‚àí'];
  check('F_L',  v('F_L'),  out[0]);
  check('F_Z1', v('F_Z1'), '0');
  check('F_M',  v('F_M'),  out[1]);
  check('F_Z2', v('F_Z2'), '0');
  check('F_R',  v('F_R'),  out[2]);

// ================== 5) Intervalle final ====================
const elSet = $('#ex8_set', host);

const norm = s => String(s||'')
  .trim()
  .replace(/\u2212|‚àí|‚Äì|‚Äî/g, '-')   // tous les tirets -> '-'
  .replace(/\s+/g, '')             // supprime espaces
  .replace(/[‚à™]/g, 'U')            // union unicode -> 'U'
  .replace(/,/g, ';')              // ',' accept√©
  .replace(/‚àû/g, 'oo')             // ‚àû -> oo
  .replace(/(^|[\[\]\];U])oo/gi, '$1+oo') // 'oo' nu -> '+oo'
  .toLowerCase();

const want = host.dataset.ex8want || '';   // d√©fini par recomputeAnswer()
const user = elSet ? elSet.value : '';
const goodSet = (user && norm(user) === norm(want));

// ‚ö†Ô∏è on manipule directement le <span class="tick"> juste √† droite du champ
const tickEl = elSet ? elSet.nextElementSibling : null;
if (tickEl){
  tickEl.classList.remove('ok','ko','nu');
  tickEl.classList.add(user ? (goodSet ? 'ok' : 'ko') : 'nu');
}

// comptage score
if (user){ tot++; if (goodSet) ok++; }


  return { ok, total: tot };
},

  solution(host, st){
    const box = ensureSteps(host, 'Solution');

  // 1) R√©solution par produit nul (toujours afficher sans ‚Äú1‚Äù)
  const A = (st.a===1?'':st.a===-1?'‚àí':String(st.a));
  const part = r => '(x ' + (r<0?'+ ':'‚àí ') + Math.abs(r) + ')';
  const fx = A + part(st.x1) + part(st.x2);

  const L=[];
  L.push('<div class="line"><strong>R√©solution par produit nul</strong></div>');
  L.push('<div class="line">\\('+fx+' = 0 \\)</div>');
    L.push('<div class="line">\\( x‚àí'+st.x1+'=0 \\;\\text{ ou }\\; x‚àí'+st.x2+'=0\\)</div>');

  L.push('<div class="line">\\(x='+st.x1+' \\;\\text{ ou }\\; x='+st.x2+'\\)</div>');

  // 2) Tableau de signes rempli (4 lignes ou 5 si |a|‚â†1)
  const needA = Math.abs(st.a)!==1;
  const sgn = st.a>0? '+':'‚àí';
  const row = (lbl, Ls, z1, Ms, z2, Rs) => (
    '<tr><th class="lbl">\\('+lbl+'\\)</th>'+
    '<td class="int"><b>'+Ls+'</b></td>'+
    '<td class="zero"><b>'+(z1||'')+'</b></td>'+
    '<td class="int"><b>'+Ms+'</b></td>'+
    '<td class="zero"><b>'+(z2||'')+'</b></td>'+
    '<td class="int"><b>'+Rs+'</b></td></tr>'
  );
  const table = [
    '<table class="sign-table" style="margin-top:6px">',
      '<colgroup><col class="col-lbl"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int"></colgroup>',
      '<tbody>',
        '<tr><th class="lbl">\\(x\\)</th><td class="int cap-left">‚àí‚àû</td><td class="zero">'+st.x1+'</td><td class="int"></td><td class="zero">'+st.x2+'</td><td class="int cap-right">+‚àû</td></tr>',
                needA ? row(st.a, sgn,'', sgn,'', sgn) : '',
		row(factorLabel(st.x1), '‚àí','0','+','', '+'),
row(factorLabel(st.x2), '‚àí','', '‚àí','0','+'),
        row('f(x)', st.a>0?'+':'‚àí','0', st.a>0?'‚àí':'+', '0', st.a>0?'+':'‚àí'),
      '</tbody>',
    '</table>'
  ].join('');

  L.push('<div class="line"><strong>Tableau de signes :</strong></div>');
  L.push('<div class="line">'+table+'</div>');

  // 3) Conclusion S= selon le signe s√©lectionn√©
  const lo=Math.min(st.x1,st.x2), hi=Math.max(st.x1,st.x2);
  const incl = (st.cmp==='‚â§') || (st.cmp==='‚â•');
  const wantInside = (st.cmp==='<'||st.cmp==='‚â§') ? (st.a>0) : (st.a<0);
  let Stext;
  if (wantInside){
    Stext = (incl?'[':']')+' '+lo+' ; '+hi+' '+(incl?']':'[');
  } else {
    const Lb = (incl? '] ‚àí‚àû ; '+lo+' ]' : '] ‚àí‚àû ; '+lo+' [');
    const Rb = (incl? '[ '+hi+' ; +‚àû [' : '] '+hi+' ; +‚àû [');
    Stext = Lb+' ‚à™ '+Rb;
  }
  L.push('<div class="line">\\('+fx+' '+st.cmp+' 0 \\)</div>');
  L.push('<div class="line"><strong>Conclusion.</strong> \\(S = '+Stext+'\\)</div>');

  box.innerHTML =  L.join('');
  cleanTextNodes(box); typeset(box);
}

}

];

// Expose REGISTRY for the PDF kit
window.REGISTRY = REGISTRY;
window.getDefById = id => REGISTRY.find(d => d.id === id);

// ===== Page wiring =====
function buildOne(){
  const id=$("#exo-select").value;
  const def=window.getDefById(id);
  const host=$("#host");
  const st=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  cleanTextNodes(host);         // <= AJOUT
  typeset(host); 
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  scoreOK=0; scoreTot=0;
  const def=window.getDefById($("#exo-select").value);
  const host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r = def.correct(host,st);
  scoreOK=r.ok; scoreTot=r.total; updateScore();
  cleanTextNodes(host);         // <= AJOUT
  typeset(host); 
}
function showSolution(){
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const def  = window.getDefById($("#exo-select").value);

  if (typeof def.solution === 'function') {
    def.solution(host, st);   // ‚Üê laisse chaque exo d√©voiler sa solution
  } else {
    // r√©tro-compat : afficher le bloc .steps s‚Äôil est d√©j√† pr√©sent
    const steps = host.querySelector('.steps');
    if (steps) steps.style.display = '';
  }
  cleanTextNodes(host);
  typeset(host);
}

function resetAll(){
  $("#host").innerHTML='';
  scoreOK=0; scoreTot=0; updateScore();
}

// Entr√©e ‚Üí V√©rifier
document.addEventListener('keydown', function(e){
  if(e.key==='Enter'){ e.preventDefault(); try{ checkAll(); }catch(_){ } }
});

document.addEventListener('DOMContentLoaded', function(){
  // Remplit le s√©lecteur des exos
  const sel = $("#exo-select");
  REGISTRY.forEach(d => {
    const opt = document.createElement('option');
    opt.value = d.id; opt.textContent = d.title; sel.appendChild(opt);
  });
  sel.addEventListener('change', buildOne);
  $("#btn-new").addEventListener('click', buildOne);
  $("#btn-check").addEventListener('click', checkAll);
  $("#btn-solution").addEventListener('click', showSolution);
  $("#btn-reset").addEventListener('click', resetAll);

  // ‚úÖ IMPORTANT : exposer ces 2 globals AVANT d‚Äôappeler le kit
  window.REGISTRY   = REGISTRY;
  window.getDefById = id => REGISTRY.find(d => d.id === id);

  // ‚úÖ Monte l‚ÄôUI PDF juste apr√®s la barre de commandes
  if (window.ExoPDF && ExoPDF.init) {
    ExoPDF.init({
      title: '1STI2D ‚Äì Fonctions polyn√¥mes (deg 2 & 3) ‚Äî Cas g√©n√©ral a(x‚àíx‚ÇÅ)(x‚àíx‚ÇÇ)',
      max: 50,
      // ‚¨ÖÔ∏è plus robuste que ".card.small" (qui peut ne pas exister selon la page)
	        mountAfterSelector: '.card.small',
      // ‚¨ÖÔ∏è corrige la cl√© : l‚ÄôID de l‚Äôexo 8 est "ex8_ineq_table"
      leadByDefId: {
        ex1_4curves_match:     'Associer chaque fonction \\(f_i\\) √† la courbe \\(c_j\\).',
        ex2_guess_from_curve:  'Retrouver \\(f(x)=a(x‚àíx_1)(x‚àíx_2)\\) √† partir de la courbe.',
        ex3_sign_table:        'Compl√©ter le signe de \\(f\\) suivant les intervalles indiqu√©s.',
        ex4_one_function_x1x2: '√âcrire la forme factoris√©e de \\(f\\) connaissant \\(x_1\\) et \\(x_2\\).',
        ex5_one_known_root:    'Une racine est donn√©e ; l‚Äôautre est enti√®re. √âcrire la forme factoris√©e.',
        ex6_facto_dev_roots:   'D√©velopper puis r√©soudre \\(f(x)=0\\).',
        ex7_selector_types:    'R√©soudre \\(f(x)=0\\) selon le type tir√© au sort.',
        ex8_ineq_table:        'R√©soudre une in√©quation du second degr√© (produit de facteurs).'
      },
      // optionnel : ouvrir l‚Äôonglet impression sans lancer l‚Äôimpression auto
      autoPrint: false
    });
  }

  // Charge un exercice par d√©faut
  sel.value = REGISTRY[0].id;
  buildOne();
});
</script>
</body>
</html>
