<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Première — ax² et ax²+c — Fiche (tableau de signe sans r₁/r₂)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"],input[type="number"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .table td:last-child,.table th:last-child{text-align:center;white-space:nowrap}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .pdf-mask{display:block;height:14px;background:#000;border-radius:2px}
  @media print{ .controls{display:none !important;} }
</style>

<!-- ===== VAR/SIGNE styles (user) ===== -->
<style>
  /* Variation table */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var tr > td:nth-child(2), table.var tr > th:nth-child(2){ border-right:none; }
  table.var tr > td:nth-child(3), table.var tr > th:nth-child(3){ border-left:none; border-right:none; }
  table.var tr > td:nth-child(4), table.var tr > th:nth-child(4){ border-left:none; }
  table.var tbody tr:first-child td:nth-child(3){ border-bottom:none; }
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

 .sign-table{
  width:100%;
  border:2px solid #000;
  border-collapse:separate;
  border-spacing:0;
  table-layout:fixed;
  --zeroW: 110px;
}
.sign-table col.col-lbl{ width: 96px; }
.sign-table col.col-zero{ width: var(--zeroW); }
.sign-table col.col-int{ width:auto; }

.sign-table th, .sign-table td{
  padding:8px 6px; text-align:center; vertical-align:middle;
  border-top:1px solid #000;
  border-bottom:1px solid #000;
  border-right:none; border-left:none;
}

.sign-table .lbl{
  font-weight:600;
  border-right:2px solid #000;
  white-space:nowrap;
}

.sign-table td.int{ border-left:0 !important; border-right:0 !important; }
.sign-table td.zero{ border-left:0 !important; border-right:0 !important; }
.sign-table .cap-left{ text-align:left; padding-left:8px; }
.sign-table .cap-right{ text-align:right; padding-right:8px; }

.sign-table .sel, .sign-table .root{
    width: var(--zeroW);
    height: 34px;
    line-height: 1.2;
    font-size: 16px;
    padding: 6px 8px;
    border:1px solid #cbd5e1; border-radius:8px;
    text-align:center; box-sizing:border-box;
    margin:0 auto; display:block; background:#fff;
  }
.sign-table .sel{
  -webkit-appearance:none; -moz-appearance:none; appearance:none;
  text-align-last:center;
}

.sign-table{ font-size:1.15rem; }
.sign-table th, .sign-table td{
  padding:10px 14px;
}
.sign-table .cell{ width:84px; height:44px; font-size:1.12rem; }
.sign-table .sel{ height:40px; min-width:84px; text-align-last:center; }
.sign-table .root{ min-width:110px; height:40px; font-size:1.12rem; }
  /* --- PDF helpers --- */
  .pdf-only{display:none}
  @media print{ .pdf-only{display:block} }

table.pdf-tbl{
  border-collapse: separate;   /* important pour pouvoir cibler uniquement le pourtour */
  border-spacing: 0;
  border: none;                /* pas de bordure de table (évite le double trait) */
  margin:.4rem 0;
}
table.pdf-tbl th, table.pdf-tbl td{
  border: none;                /* on nettoie toutes les bordures intérieures */
  padding: 4px 6px;
  text-align: center;
  vertical-align: middle;
}
table.pdf-tbl th{ background:#f3f3f6 }

/* — Cadre extérieur uniquement — */
table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
/* Séparateur vertical après la 1ʳᵉ colonne (x et f / f(x)) */
table.pdf-tbl thead tr > *:first-child,
table.pdf-tbl tbody tr > *:first-child{
  border-right: 1.5px solid #000;
}

.tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
.tick.nu::after{ content:''; }
.tick.ok::after{ content:'✓'; color:#11823b; }
.tick.ko::after{ content:'✗'; color:#b00020; }
.cell-inline .tick{ margin-left:.4rem; }



</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true,macros:{frac:['\\dfrac{#1}{#2}',2]}},options:{skipHtmlTags:['script','noscript','style','textarea']},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Première — ax² et ax²+c — (Tableau de signe sans r₁/r₂)</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

   <div class="card small">
  <strong>Saisie &amp; réponses acceptées — Ex. 3 (f(x)=ax²+c)</strong>
  <ul style="margin:.5rem 0 0 18px">
    <li><b>Racines</b> :
      <ul>
        <li><i>Deux racines</i> : liste ordonnée avec <code>;</code> ou <code>,</code> — ex. <code>-2;2</code>, <code>-3,3</code>, <code>-√2;√2</code>, <code>-√(5/3);√(5/3)</code>.</li>
        <li><i>Aucune</i> : écrire <code>∅</code> (ou <code>aucune</code>).</li>
        <li><i>Racine double</i> en 0 (si <code>c=0</code>) : écrire <code>0</code> (une seule fois).</li>
        <li><i>Formats √ acceptés</i> : <code>√n</code>, <code>sqrt(n)</code>, <code>\sqrt{n}</code>, <code>rac(n)</code> ; aussi <code>√(p/q)</code>, <code>\sqrt{p/q}</code>.</li>
        <li><b>Calcule quand c’est possible</b> : <code>√9 → 3</code>, <code>√(18/2) = √9 → 3</code>.</li>
        <li><b>Simplifie toujours</b> : <code>√20 = 2√5</code>, <code>√(12/3) = √4 = 2</code>, <code>√(8/2) = √4 = 2</code>.</li>
        <li><b>Fraction réduite, jamais “/1”</b> : écrire <code>√5</code>, pas <code>√(5/1)</code> ; <code>√(12/8) → √(3/2)</code>.</li>
        <li>Pas d’approximations décimales pour les irrationnels : préférer <code>√2</code> à <code>1,414</code>.</li>
      </ul>
    </li>



    <li><b>Sommet</b> :
      <ul>
               <li>Formats acceptés : <code>S(0;c)</code>, <code>(0;c)</code>.</li>
        <li>Ex. si <code>c=9</code> : <code>S(0;9)</code>, <code>(0;9)</code>.</li>
      </ul>
    </li>

    <li><b>Axe de symétrie</b> :
      <ul>
        <li>Écrire l'équation attendue.</li>
      </ul>
    </li>

    <li><b>Tableau de variations</b> :
      <ul>
        <li>La case centrale de la ligne <i>x</i> est <b>α</b>.</li>
        <li>Si<b>β</b> est un minimum : ne remplir que la case minimum et laisser vide la case maximum.</li>
              </ul>
    </li>

    <li><b>Tableau de signes</b> (grille <i>+ | 0 | ± | 0 | +</i>) :
      <ul>
        <li><i>Deux racines :</i> ne pas remplir la case α. </li>
        <li><i>Une seule racine :</i> ne pas remplir les cases r1 et r2</li>
        <li><i>Aucune racine</i> : voir le cours.</li>
        <li><i>Racines irrationnelles</i> :
          <ul>
            <li>Ligne du haut (r₁/r₂) : tu peux écrire <code>-√(p/q)</code> et <code>√(p/q)</code> (fraction réduite, pas “/1”).</li>
            <li>Ligne du bas (signes) : on accepte <b>avec</b> les deux <code>0</code> placés, <b>ou</b> <b>sans</b> ces <code>0</code> (seulement les signes corrects).</li>
          </ul>
        </li>
      </ul>
    </li>

    <li><b>Rappels généraux</b> :
      <ul>
        <li>Listes : séparer par <code>;</code> ou <code>,</code> — ex. <code>-2;2</code>.</li>
        <li>Décimales : virgule <i>ou</i> point — ex. <code>1,5</code> / <code>1.5</code>.</li>
        <li>Tous les “moins” sont acceptés (–, −…) et normalisés.</li>
        <li>Fractions : <b>réduire</b> systématiquement ; <b>jamais</b> <code>/1</code> sous la racine.</li>
        <li>Radicaux : privilégier l’<b>écriture exacte et simplifiée</b>.</li>
      </ul>
    </li>
  </ul>
</div>


    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- Dépendances -->
  <script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
  <script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
  <script src="../../../../js/math-kbd.js" defer></script>

<script>
(function(){
'use strict';

/* ===== Helpers ===== */
const $=(s,r)=> (r||document).querySelector(s);
const $$=(s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
const shuffle=a=>{const b=a.slice(); for(let i=b.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]];} return b;};
function L(s){return '\\( '+String(s).replace(/\\u2212/g,'-')+' \\)';}
function typesetAll(root){const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){MathJax.startup.promise.then(run);} else {const t=setInterval(()=>{if(MathJax?.typesetPromise){clearInterval(t); run();}},60);}}
// ===== ticks (pas de live) =====
function ensureTickAfter(el){
  let s = el?.nextElementSibling;
  if(!s || !s.classList || !s.classList.contains('tick')){
    s = document.createElement('span');
    s.className = 'tick nu';
    el.insertAdjacentElement('afterend', s);
  }
  return s;
}
function setTick(el, state){ // 'ok' | 'ko' | 'nu'
  if(!el) return;
  ensureTickAfter(el).className = 'tick ' + state;
}
function valTrim(el){ return (el?.value||'').replace(/\u2212/g,'-').trim(); } // normalise ‘−’

// √(p/q) → (s/t)*√(r/u) -> LaTeX propre (avec tous les cas : entier, fraction, facteur dehors, pas de /1)
function sqrtSimplifyFracTex(p0, q0){
  // p0,q0 > 0 et déjà réduits si possible
  const abs = Math.abs;
  const gcd = (x,y)=> y ? gcd(y, x%y) : abs(x);
  let p = abs(p0), q = abs(q0);

  // 1) réduire p/q
  const g1 = gcd(p,q); p/=g1; q/=g1;

  // 2) extraire les plus grands carrés parfaits s^2 | p et t^2 | q
  const sqrf = (n)=> {
    let s = Math.floor(Math.sqrt(n));
    while(s>1 && (n % (s*s) !== 0)) s--;
    return s;                 // renvoie s tel que s^2 | n
  };
  const s = sqrf(p); const t = sqrf(q);
  const r = p/(s*s);          // reste au numérateur (squarefree)
  const u = q/(t*t);          // reste au dénominateur (squarefree)

  // 3) coefficient hors racine = (s/t) réduit
  let cn = s, cd = t;
  const g2 = gcd(cn, cd); cn/=g2; cd/=g2;

  // 4) composer la forme LaTeX
  // cas A : rien sous la racine
  if(r===1 && u===1){
    if(cd===1) return `${cn}`;               // entier
    return `\\dfrac{${cn}}{${cd}}`;          // fraction
  }

  // cas B : racine simple (u=1)
  if(u===1){
    if(cn===1 && cd===1) return `\\sqrt{${r}}`;                                     // √r
    if(cd===1)            return `${cn}\\sqrt{${r}}`;                                // cn√r
    return `\\dfrac{${cn}\\sqrt{${r}}}{${cd}}`;                                      // (cn√r)/cd
  }

  // cas C : racine de fraction (u>1) — on garde r/u sous une même √
  const inside = (u===1) ? `${r}` : `\\dfrac{${r}}{${u}}`;
  if(cn===1 && cd===1) return `\\sqrt{${inside}}`;                                   // √(r/u)
  if(cd===1)            return `${cn}\\sqrt{${inside}}`;                             // cn√(r/u)
  return `\\dfrac{${cn}\\sqrt{${inside}}}{${cd}}`;                                   // (cn√(r/u))/cd
}


// Helpers manquants (tolérance numérique & parse racine)
function almost(a, b, eps = 1e-8){
  const x = Number(a), y = Number(b);
  return Number.isFinite(x) && Number.isFinite(y) && Math.abs(x - y) <= eps;
}


function normSign(s){
  // unifie tous les tirets possibles en ASCII '-'
  return String(s||'')
    .replace(/\u2212|−|–/g, '-')  // − (U+2212), – (en-dash) → '-'
    .trim();
}
function sqrtFracTex(num, den){
  return (den === 1)
    ? `\\sqrt{${num}}`
    : `\\sqrt{\\dfrac{${num}}{${den}}}`;
}

// — désactive toute validation live
const LIVE_TICKS = false;
// Parse "Sommet" saisi comme "0; c", "0,c", "S(0;c)", " (0 ; -1,5) "...
function parseVertexPoint(s){
  if(!s) return null;
  let v = String(s).replace(/\u2212/g,'-').trim();
  // retire S, parenthèses, espaces
  v = v.replace(/^s\(/i,'(').replace(/[()]/g,'').replace(/\s+/g,'');
  // on cherche le 1er séparateur entre x et y : ';' prioritaire, sinon ','
  let sep = v.indexOf(';');
  if(sep<0) sep = v.indexOf(',');
  if(sep<0) return null;
  const left = v.slice(0, sep);
  const right = v.slice(sep+1);
  // la partie droite peut contenir une décimale avec virgule → on remplace les virgules restantes par des points
  const x = left.replace(',','.');
  const y = right.replace(/,/g,'.');
  if(x==='' || y==='') return null;
  const X = Number(x), Y = Number(y);
  if(!Number.isFinite(X) || !Number.isFinite(Y)) return null;
  return [X, Y];
}
function parseRootNumber(txt){
  if(!txt) return null;
  let s = String(txt).trim()
    .replace(/\u2212/g,'-')                 // ‘−’ → '-'
    .replace(/\\sqrt\s*\{([^}]*)\}/gi,'sqrt($1)')
    .replace(/√/g,'sqrt')
    .replace(/\s+/g,'');

  // Nombre simple
  if(!/sqrt/i.test(s)){
    const v = Number(s.replace(',','.'));
    return Number.isFinite(v) ? v : null;
  }

  // Formes acceptées :
  // - [-]sqrt(A)
  // - [-](sqrt(A))/m
  // - [-]k*sqrt(A)
  // - [-](k*sqrt(A))/m
  // où k,m entiers (>0), A entier ou fraction a/b
const re = /^(-)?(?:(\d+)\*?)?sqrt\(([^)]+)\)(?:\/(\d+))?$/i;
  const m = s.match(re);
  if(!m){
    // fallback minimaliste : -sqrt(A) sans k/m
    const m2 = s.match(/^(-)?sqrt\(([^)]+)\)$/i);
    if(!m2) return null;
    const sgn = m2[1] ? -1 : +1;
    const inside = m2[2];
    let val = NaN;
    if(/^\d+(?:[.,]\d+)?\/\d+(?:[.,]\d+)?$/.test(inside)){
      const [p,q] = inside.split('/').map(t=>Number(t.replace(',','.')));
      if(q!==0 && Number.isFinite(p) && Number.isFinite(q)) val = Math.sqrt(p/q);
    }else{
      const x = Number(inside.replace(',','.'));
      if(Number.isFinite(x)) val = Math.sqrt(x);
    }
    return Number.isFinite(val) ? sgn*val : null;
  }

  const sgn = m[1] ? -1 : +1;
  const k   = m[2] ? Number(m[2]) : 1;
  const ins = m[3];
  const den = m[4] ? Number(m[4]) : 1;

  let rad;
  if(/^\d+(?:[.,]\d+)?\/\d+(?:[.,]\d+)?$/.test(ins)){
    const [p,q] = ins.split('/').map(t=>Number(t.replace(',','.')));
    if(q===0) return null;
    rad = Math.sqrt(p/q);
  }else{
    const x = Number(ins.replace(',','.'));
    if(!Number.isFinite(x)) return null;
    rad = Math.sqrt(x);
  }
  const val = sgn * (k * rad) / den;
  return Number.isFinite(val) ? val : null;
}

function rootEq(inputTxt, want){
  const v = parseRootNumber(inputTxt);
  if(v===null) return false;
  return Math.abs(v-Number(want)) < 1e-9;
}
function isZeroTxt(s){
  if(!s) return false;
  const v = Number(String(s).trim().replace(',','.').replace(/\u2212/g,'-'));
  return Number.isFinite(v) && Math.abs(v) < 1e-9;
}


// — true si la saisie représente numériquement "want" (tolérance pour irrationnels)
function rootEq(inputTxt, want){
  const v = parseRootNumber(inputTxt);
  if(v===null) return false;
  return Math.abs(v - Number(want)) < 1e-9;
}

// — true si la saisie est (numériquement) 0
function isZeroTxt(s){
  if(!s) return false;
  const v = Number(String(s).trim().replace(',', '.').replace(/\u2212/g,'-'));
  return Number.isFinite(v) && Math.abs(v) < 1e-9;
}
// --- Parse d'une racine saisie : -2, 2, -√8, -sqrt(8), -rac(8), -\sqrt{8/3}, etc.
// — Évalue un texte de "racine" en nombre (ex: "-√(3/2)", "rac{8}", "2", "-1.5", "√9/4"...)
function parseRootValue(txt){
  if(!txt) return NaN;
  let s = String(txt).trim();

  // normalisations
  s = s
    .replace(/\u2212|−|–/g, '-')                // tirets exotiques -> '-'
    .replace(/\\sqrt\s*\{([^}]*)\}/gi, 'sqrt($1)')
    .replace(/√\s*\(?\s*([^)]*)\s*\)?/gi, 'sqrt($1)')
    .replace(/rac\s*\(\s*([^)]*)\s*\)/gi, 'sqrt($1)')
    .replace(/rac\s*\{\s*([^}]*)\s*\}/gi, 'sqrt($1)')
    .replace(/\s+/g,'');                        // pas d'espaces

  // 1) nombre nu (entier/décimale)
  if(/^[-+]?\d+(?:[.,]\d+)?$/.test(s)){
    return Number(s.replace(',','.'));
  }

  // 2) fraction nue a/b (avec décimales possibles)
  const mf = s.match(/^([-+]?\d+(?:[.,]\d+)?)\/([-+]?\d+(?:[.,]\d+)?)$/);
  if(mf){
    const a = Number(mf[1].replace(',','.'));
    const b = Number(mf[2].replace(',','.'));
    if(Number.isFinite(a) && Number.isFinite(b) && b!==0) return a/b;
    return NaN;
  }

  // 3) formes à base de racine : [-] k √(A) / m  avec k,m entiers (k sans * accepté)
  //    exemples acceptés : sqrt(2), -sqrt(3/5), 2sqrt(7), 3*sqrt(5)/4, -2sqrt(1/3)/5
  const m =
    s.match(/^([+-])?(?:(\d+)\*?)?sqrt\(([^)]+)\)(?:\/(\d+))?$/i) ||
    s.match(/^([+-])?sqrt\(([^)]+)\)$/i); // secours -sqrt(A)

  if(!m) return NaN;

  let sign = +1, k = 1, inside, den = 1;
  if(m.length === 5){              // forme générale
    sign  = (m[1] === '-') ? -1 : +1;
    k     = m[2] ? Number(m[2]) : 1;     // <-- * optionnelle grâce à \*?
    inside= m[3];
    den   = m[4] ? Number(m[4]) : 1;
  }else{                           // fallback sqrt(A) ou -sqrt(A)
    sign  = (m[1] === '-') ? -1 : +1;
    inside= m[2];
  }

  inside = inside.replace(/,/g,'.');

  // inside : entier/décimale positive OU fraction positive a/b
  let rad;
  const f = inside.match(/^([-+]?\d+(?:\.\d+)?)\/([-+]?\d+(?:\.\d+)?)$/);
  if(f){
    const a = Number(f[1]), b = Number(f[2]);
    if(!Number.isFinite(a) || !Number.isFinite(b) || b===0 || a/b<0) return NaN;
    rad = Math.sqrt(a/b);
  }else{
    const x = Number(inside);
    if(!Number.isFinite(x) || x<0) return NaN;
    rad = Math.sqrt(x);
  }

  const val = sign * (k * rad) / den;
  return Number.isFinite(val) ? val : NaN;
}


// Alias compatible avec ton code existant
function parseRootVal(txt){
  const v = parseRootValue(txt);           // ta fonction déjà définie
  return Number.isFinite(v) ? v : NaN;
}

// Liste de racines (ex: "-2;2", "-√(3/2), √(3/2)", "∅", "aucune", "pas")
function parseRootList(txt){
  if(txt==null) return null;
  let s = String(txt).replace(/\u2212/g,'-').trim();
  if(!s) return null;                            // vide -> neutre
  if(/^(∅|aucun(?:e)?|pas)$/i.test(s)) return []; // aucune racine

  return s.split(/[;,]/)
          .map(t => parseRootValue(t))
          .filter(Number.isFinite);
}

function hasPlusMinusPair(list, r, eps = 1e-9){
  if(!Array.isArray(list) || list.length!==2) return false;
  const A = list.slice().sort((x,y)=>x-y);   // ordre indifférent
  return (Math.abs(A[0] + r) <= eps && Math.abs(A[1] - r) <= eps);
}

// vérifie que v est la racine attendue (signe imposé) à 1e-8 près
function isRootOK(v, expectedAbs, wantSign){ // wantSign: -1 ou +1
  if(!Number.isFinite(v)) return false;
  if(Math.sign(v||0)!==wantSign) return false;
  return Math.abs(Math.abs(v) - expectedAbs) < 1e-8;
}

/* petites utils communes */
function valTrim(el){ return (el.value||'').replace(/\u2212/g,'-').trim(); }
function numEq(a,b){ return Math.abs(Number(a)-Number(b)) < 1e-9; }
function listParse(txt){
  const s = String(txt||'').replace(/\u2212/g,'-').trim();
  if(!s) return null;                  // vide → neutre
  if(/^(∅|aucun(?:e)?|pas)$/i.test(s)) return [];  // ⬅️ les seules formes admises pour "aucune"
  return s.split(/[;,]/)
          .map(t=>Number(t.trim().replace(',','.')))
          .filter(Number.isFinite);
}


/* ===== Parabola plot (for ex1/ex4) ===== */
function svgParabolas(config){
  const W=420,H=300,m=28;
  const [xmin,xmax]=config.X,[ymin,ymax]=config.Y;
  const X=x=>m+(x-xmin)*(W-2*m)/(xmax-xmin);
  const Y=y=>H-m-(y-ymin)*(H-2*m)/(ymax-ymin);

  // grille
  let grid='';
  for(let xi=Math.ceil(xmin); xi<=Math.floor(xmax); xi++){
    const x=X(xi); grid+=`<path d="M ${x} ${m} V ${H-m}" stroke="#e5e5e5"/>`;
  }
  for(let yi=Math.ceil(ymin); yi<=Math.floor(ymax); yi++){
    const y=Y(yi); grid+=`<path d="M ${m} ${y} H ${W-m}" stroke="#e5e5e5"/>`;
  }

  // axes + graduations
  const xAxisY=(ymin<=0 && ymax>=0)?Y(0):(H-m);
  const yAxisX=(xmin<=0 && xmax>=0)?X(0):m;
  let axes='';
  for(let xi=Math.ceil(xmin); xi<=Math.floor(xmax); xi++){
    const x=X(xi);
    axes+=`<line x1="${x}" y1="${xAxisY-4}" x2="${x}" y2="${xAxisY+4}" stroke="#000"/>`;
    axes+=`<text x="${x}" y="${xAxisY+16}" font-size="11" text-anchor="middle">${xi}</text>`;
  }
  for(let yi=Math.ceil(ymin); yi<=Math.floor(ymax); yi++){
    const y=Y(yi);
    axes+=`<line x1="${yAxisX-4}" y1="${y}" x2="${yAxisX+4}" y2="${y}" stroke="#000"/>`;
    axes+=`<text x="${yAxisX-8}" y="${y+4}" font-size="11" text-anchor="end">${yi}</text>`;
  }

  // chemin complet d'une parabole
  function pathFor(a,c){
    const pts=[], step=(xmax-xmin)/360;
    for(let x=xmin; x<=xmax; x+=step){ pts.push([X(x), Y(a*x*x+c)]); }
    return 'M '+pts.map(p=>p[0].toFixed(2)+' '+p[1].toFixed(2)).join(' L ');
  }

  // courbes
  let curves='';
  config.curves.forEach(cv=>{
    curves+=`<path d="${pathFor(cv.a,cv.c)}" fill="none" stroke="${cv.color}" stroke-width="2"/>`;
  });

  // ===== labels collés à la courbe (textPath) avec candidats dynamiques =====
  const placedCenters=[];
  const minDist=26; // px
  const yMargin=0.5;

  function tooClose(px,py){
    for(const p of placedCenters){
      const dx=px-p.x, dy=py-p.y;
      if(dx*dx+dy*dy < minDist*minDist) return true;
    }
    return false;
  }

  function localPath(a,c,xi){
    // segment local centré en xi (longueur adaptée, plus courte quand |a| grand)
    const span = Math.min(1.2, Math.max(0.45, 1/Math.sqrt(Math.max(1,Math.abs(a))))); // ~ [0.45 ; 1.2]
    const x0 = Math.max(xmin, xi - span/2);
    const x1 = Math.min(xmax, xi + span/2);
    const step = (x1-x0)/24;
    const pts=[];
    for(let x=x0; x<=x1; x+=step){ pts.push([X(x), Y(a*x*x+c)]); }
    return 'M '+pts.map(p=>p[0].toFixed(2)+' '+p[1].toFixed(2)).join(' L ');
  }

  function xBoundInView(a,c){
    // plus grand |x| tel que y=a x^2 + c reste dans [ymin+yMargin, ymax-yMargin]
    if(a===0) return xmax; // pas notre cas ici
    if(a>0){
      const num = (ymax - yMargin) - c;
      if(num<=0) return 0.6;
      return Math.sqrt(num/a);
    }else{
      const num = (ymin + yMargin) - c; // négatif
      // on veut a x^2 >= ymin+yMargin - c  (a<0) -> x^2 <= num/a (>0)
      const b = num/a; // positif
      return Math.sqrt(Math.max(0,b));
    }
  }

  // fabrique des candidats sûrs pour CETTE courbe
  function candidatesForCurve(a,c){
    const B = Math.max(0.4, Math.min(6.6, xBoundInView(a,c))); // clamp
    // évite l'origine, propose plusieurs ratios décroissants
    const r = [0.85,0.7,0.6,0.5,0.4,0.3,0.25,0.2].map(k=>k*B).filter(x=>x>0.18);
    const xs=[];
    // alterne signes pour répartir visuellement
    r.forEach((v,i)=>{ xs.push(i%2? -v : v); xs.push(i%2? v : -v); });
    // si peu de place, ajoute deux tout petits proches de 0
    if(xs.length<6){ xs.push(0.22*B, -0.22*B); }
    return xs;
  }

  let defs='', labels='';
  config.curves.forEach((cv,i)=>{
    const a=cv.a, c=cv.c||0;
    const cand = candidatesForCurve(a,c);
    let placed=false;

    for(let k=0;k<cand.length && !placed;k++){
      const xi = cand[k];
      const yi = a*xi*xi + c;
      if(yi<=ymin+yMargin || yi>=ymax-yMargin) continue;

      const px=X(xi), py=Y(yi);
      if(tooClose(px,py)) continue;

      const pid = `lp_${i}_${k}_${Math.random().toString(36).slice(2,6)}`;
      defs += `<path id="${pid}" d="${localPath(a,c,xi)}"/>`;

      labels += `
        <text font-size="12" font-weight="700">
          <textPath href="#${pid}" startOffset="50%" text-anchor="middle"
                    stroke="#fff" stroke-width="3" paint-order="stroke">${cv.label}</textPath>
        </text>
        <text font-size="12" font-weight="700" fill="${cv.color}">
          <textPath href="#${pid}" startOffset="50%" text-anchor="middle">${cv.label}</textPath>
        </text>`;
      placedCenters.push({x:px,y:py});
      placed=true;
    }

    // secours (très rare maintenant)
    if(!placed){
      const x = W - m - 78, y = H - m - 14*(i+1);
      labels += `
        <text x="${x}" y="${y}" font-size="12" font-weight="700"
              stroke="#fff" stroke-width="3" paint-order="stroke">${cv.label}</text>
        <text x="${x}" y="${y}" font-size="12" font-weight="700" fill="${cv.color}">${cv.label}</text>`;
    }
  });

  return `<svg viewBox="0 0 ${W} ${H}" width="100%" height="${H}"
               style="max-width:560px;border:1px solid #ddd;border-radius:10px;background:#fff">
    <defs>${defs}</defs>
    <rect x="0" y="0" width="${W}" height="${H}" fill="#fff"/>
    ${grid}
    <path d="M ${m} ${xAxisY} H ${W-m}" stroke="#000"/>
    <path d="M ${yAxisX} ${m} V ${H-m}" stroke="#000"/>
    ${axes}
    ${curves}
    ${labels}
  </svg>`;
}



// --- Tableau de variations : bordures complètes ---
function latexTableVariations(a, alpha, beta){
  const left  = (a>0 ? '\\searrow' : '\\nearrow');
  const right = (a>0 ? '\\nearrow' : '\\searrow');
  const top = (a<0 ? `${beta}` : '\\;');
  const bot = (a>0 ? `${beta}` : '\\;');

  return String.raw`
\[
{\def\arraycolsep{14pt}
\begin{array}{|c|ccc|}
\hline
x & -\infty & ${alpha} & +\infty\\
\hline
f & ${left} & \begin{array}{c} ${top} \\[-2pt] ${bot} \end{array} & ${right}\\
\hline
\end{array}}
\]
`;
}

// --- Tableau de signes détaillé : bordures complètes ---
// rootTex: null | "0" | ["-r","r"]
function latexTableSignesDetailed(a, rootTex){
const sOut = a>0? '+' : '-';
const sIn  = a>0? '-' : '+';



  // Deux racines distinctes
  if (Array.isArray(rootTex) && rootTex.length===2){
    const [r1, r2] = rootTex;
    return String.raw`
\[
{\def\arraycolsep{16pt}
\begin{array}{|c|ccccc|}
\hline
x & -\infty & ${r1} &  & ${r2} & +\infty\\
\hline
f(x) & ${sOut} & 0 & ${sIn} & 0 & ${sOut}\\
\hline
\end{array}}
\]
`;
  }

  // Racine double en 0
  if (rootTex==='0'){
    return String.raw`
\[
{\def\arraycolsep{16pt}
\begin{array}{|c|ccc|}
\hline
x & -\infty & 0 & +\infty\\
\hline
f(x) & ${sOut} & 0 & ${sOut}\\
\hline
\end{array}}
\]
`;
  }

  // Aucune racine (signe constant)
  return String.raw`
\[
{\def\arraycolsep{22pt}
\begin{array}{|c|cc|}
\hline
x & -\infty & & +\infty\\
\hline
f(x) &  & ${sOut} & \\
\hline
\end{array}}
\]
`;
}



/* ===== Variation table (user exact) ===== */
function renderVariationTable(host){
  host.innerHTML = [
    '<div class="var-wrap"><table class="var">',
      '<thead><tr><th>\\(x\\)</th><td>\\(−∞\\)</td><td style="text-align:center"><input class="alpha-in" type="text" style="width:90px"></td><td>\\(+∞\\)</td></tr></thead>',
      '<tbody>',
      '<tr>',
        '<th rowspan="3">\\(f\\)</th>',
        '<td class="bigsel" rowspan="3"><select class="d-L"><option value=""></option><option>↘</option><option>↗</option></select></td>',
        '<td style="text-align:center"><input class="d-beta-top" type="text" placeholder="maximum"></td>',
        '<td class="bigsel" rowspan="3"><select class="d-R"><option value=""></option><option>↘</option><option>↗</option></select></td>',
      '</tr>',
      '<tr class="gaprow"><td></td></tr>',
      '<tr class="thin">',
        '<td style="text-align:center"><input class="d-beta-bot" type="text" placeholder="minimum"></td>',
      '</tr>',
      '</tbody></table></div>'
  ].join('');
}

/* ===== Slim sign table (no r1/r2) ===== */
function signTableHTML(){
  return [
    '<div class="signwrap">',
    '<table id="signTable" class="sign-table" aria-label="Tableau de signe">',
      '<colgroup>',
        '<col class="col-lbl">',
        '<col class="col-int">',
        '<col class="col-zero">',
        '<col class="col-int">',
        '<col class="col-zero">',
        '<col class="col-int">',
      '</colgroup>',
      '<tbody>',
        '<tr>',
          '<th class="lbl">\\(x\\)</th>',
          '<td class="int cap-left">\\(−∞\\)</td>',
          '<td class="zero">',
            '<div class="cell-inline">',
              '<input id="r1" class="root" placeholder="r₁">',
              '<span id="ok_r1" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="int">',
            '<div class="cell-inline">',
              '<input id="alpha" class="root" placeholder="α">',
              '<span id="ok_alpha" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="zero">',
            '<div class="cell-inline">',
              '<input id="r2" class="root" placeholder="r₂">',
              '<span id="ok_r2" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="int cap-right">\\(+∞\\)</td>',
        '</tr>',
        '<tr>',
          '<th class="lbl">\\(f(x)\\)</th>',
          '<td class="int">',
            '<div class="cell-inline">',
              '<select id="s1" class="sel">',
                '<option value=""></option><option>+</option><option>−</option>',
              '</select>',
              '<span id="ok_s1" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="zero">',
            '<div class="cell-inline">',
              '<select id="z1" class="sel">',
                '<option value=""></option><option>0</option>',
              '</select>',
              '<span id="ok_z1" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="int">',
            '<div class="cell-inline">',
              '<select id="s2" class="sel">',
                '<option value=""></option><option>+</option><option>−</option><option>0</option>',
              '</select>',
              '<span id="ok_s2" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="zero">',
            '<div class="cell-inline">',
              '<select id="z2" class="sel">',
                '<option value=""></option><option>0</option>',
              '</select>',
              '<span id="ok_z2" class="tick nu"></span>',
            '</div>',
          '</td>',
          '<td class="int">',
            '<div class="cell-inline">',
              '<select id="s3" class="sel">',
                '<option value=""></option><option>+</option><option>−</option>',
              '</select>',
              '<span id="ok_s3" class="tick nu"></span>',
            '</div>',
          '</td>',
        '</tr>',
      '</tbody>',
    '</table>',
  '</div>'
  ].join('');
}
/* ========= Helpers LaTeX pour PDF (variations & signes) ========= */
// Déterminer la forme des racines pour f(x)=ax²+c
// Remplace TOUT le bloc pdfRootsLabels par ceci
function pdfRootsLabels(a, c){
  if (c === 0) return '0';                 // racine double
  const t = -c / a;
  if (t < 0) return null;                  // pas de racine

  // t = |c|/|a| (positif) → p/q réduits entiers
  const gcd = (x,y)=> y ? gcd(y, x%y) : Math.abs(x);
  const p0 = Math.abs(c), q0 = Math.abs(a);
  const g  = gcd(p0, q0);
  const p  = p0/g, q = q0/g;

  // forme simplifiée de √(p/q)
  const R = sqrtSimplifyFracTex(p, q);

  // si R est un nombre (entier ou fraction), pas de √
  if (/^\d+(?:\/\d+)?$/.test(R)) {
    // racines rationnelles ±R
    return [ `-${R}`, `${R}` ];
  }
  // sinon R contient une √ avec facteur éventuel devant
  return [ `-${R}`, `${R}` ];
}


// Tableau de variations f(x)=a(x-α)^2+β (compact)
function latexVarTable(a, alphaTex, betaTex){
  const left = (a>0 ? '\\searrow' : '\\nearrow');
  const right = (a>0 ? '\\nearrow' : '\\searrow');
  const top = (a<0 ? betaTex : '\\;');
  const bot = (a>0 ? betaTex : '\\;');

  return String.raw`
\[
\begin{array}{c|ccc}
x & -\infty & ${alphaTex} & +\infty\\
\hline
f & ${left} & \begin{array}{c} ${top} \\[-2pt] ${bot} \end{array} & ${right}
\end{array}
\]`;
}

// Tableau de signes (affiche r₁/r₂ si disponibles)
function latexSignTable(a, rootTex){ // rootTex: null | '0' | ['-r','r']
  const sOut = (a>0? '+' : '−');

  if (Array.isArray(rootTex) && rootTex.length===2){
    const [r1, r2] = rootTex;
    const sIn = (a>0? '−' : '+');
    return String.raw`
\[
\begin{array}{c|ccccc}
x & -\infty & ${r1} & & ${r2} & +\infty\\
\hline
f(x) & ${sOut} & 0 & ${sIn} & 0 & ${sOut}
\end{array}
\]`;
  }
  if (rootTex === '0'){
    return String.raw`
\[
\begin{array}{c|ccc}
x & -\infty & 0 & +\infty\\
\hline
f(x) & ${sOut} & 0 & ${sOut}
\end{array}
\]`;
  }
  // aucune racine : signe constant (tableau 2 colonnes lisible)
  return String.raw`
\[
\begin{array}{c|cc}
x & -\infty & +\infty\\
\hline
f(x) & ${sOut} & ${sOut}
\end{array}
\]`;
}
/* === Helpers HTML pour PDF (variations & signes) === */
function pdfVarTableHTML(a, alpha, beta){
  const arrowL = a>0 ? '↘' : '↗';
  const arrowR = a>0 ? '↗' : '↘';
  const top = (a<0 ? L(beta) : '&nbsp;');
  const bot = (a>0 ? L(beta) : '&nbsp;');
  return `
<table class="pdf-tbl" aria-label="Tableau de variations (PDF)">
  <thead>
    <tr><th>${L('x')}</th><th>${L('-\\infty')}</th><th>${L(alpha)}</th><th>${L('+\\infty')}</th></tr>
  </thead>
  <tbody>
    <tr>
      <th>${L('f')}</th>
      <td>${arrowL}</td>
      <td><div>${top}</div><div style="height:4px"></div><div>${bot}</div></td>
      <td>${arrowR}</td>
    </tr>
  </tbody>
</table>`;
}

function pdfSignTableHTML(a, rootTex){
const sOut = a>0? '+' : '-';
const sIn  = a>0? '-' : '+';

  const cell = v => L(v);

  if (Array.isArray(rootTex) && rootTex.length===2){
    const [r1, r2] = rootTex;
    return `
<table class="pdf-tbl" aria-label="Tableau de signes (PDF)">
  <thead>
    <tr><th>${L('x')}</th><th>${L('-\\infty')}</th><th></th><th>${cell(r1)}</th><th></th><th>${cell(r2)}</th><th></th><th>${L('+\\infty')}</th></tr>
  </thead>
  <tbody>
    <tr><th>${L('f(x)')}</th><td></td><td>${sOut}</td><td>0</td><td>${sIn}</td><td>0</td><td>${sOut}</td><td></td></tr>
  </tbody>
</table>`;
  }

  if (rootTex === '0'){
    return `
<table class="pdf-tbl" aria-label="Tableau de signes (PDF)">
  <thead>
    <tr><th>${L('x')}</th><th>${L('-\\infty')}</th><th></th><th>0</th><th></th><th>${L('+\\infty')}</th></tr>
  </thead>
  <tbody>
    <tr><th>${L('f(x)')}</th><td></td><td>${sOut}</td><td>0</td><td>${sOut}</td><td></td></tr>
  </tbody>
</table>`;
  }

  // Signe constant
  return `
<table class="pdf-tbl" aria-label="Tableau de signes (PDF)">
  <thead>
    <tr><th>${L('x')}</th><th>${L('-\\infty')}</th><th></th><th>${L('+\\infty')}</th></tr>
  </thead>
  <tbody>
    <tr><th>${L('f(x)')}</th><td></td><td>${sOut}</td><td></td></tr>
  </tbody>
</table>`;
}

// Petite util pour écrire proprement α, β (ici α=0 pour ax², α=0, β=c pour ax²+c)
const texNum = n => String(n);

/* ===== Utilities ===== */
function rootsAx2c(a,c){
  if(c===0) return [0];
  const t = -c/a;
  if(t<0) return [];
  const r = Math.sqrt(t);
  if(Math.abs(r-Math.round(r))<1e-9) return [-Math.round(r), Math.round(r)];
  return ['irr', r];
}
function parseList(txt){
  const s=String(txt||'').replace(/\\u2212/g,'-').trim();
  if(!s) return null;
  if(/^∅$/.test(s)) return [];
  return s.split(/[;,]/).map(t=>Number(t.trim().replace(',','.'))).filter(v=>Number.isFinite(v));
}

/* =======================================================
   EXO 1 — Associer ax^2
   ======================================================= */
/* =======================================================
   EXO 1 — Associer ax^2 (50% + / 50% −)
   Positifs : 1 fraction > 1/2 ; 1 décimale 0.x avec x<5 ; 1 entier a>3
   Négatifs : miroirs (< −1/2 ; −0.x ; a<−3)
   ======================================================= */
const ex1 = {
  id:'e1',
  title:'Ex. 1 — Associer f(x)=ax² aux courbes',
  gen(){
  const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const choice=a=>a[Math.floor(Math.random()*a.length)];
  const gcd=(x,y)=>y?gcd(y,x%y):Math.abs(x);

  // -------- POSITIFS --------
  // fraction p/q dans (1/2,1), simplifiée
  const q1 = choice([3,4,5,6,7,8,9,10,12]);
  const p1 = rint(Math.floor(q1/2)+1, q1-1);
  const g1 = gcd(p1,q1);
  const p1s = p1/g1, q1s = q1/g1;
  const aFracPos = p1s/q1s;
  const texFracPos = `\\dfrac{${p1s}}{${q1s}}`;

  // décimale 0.x < 0.5
  const DEC = [0.1,0.2,0.25,0.3,0.33,0.4,0.45,0.48];
  const aDecPos = choice(DEC.filter(v=>Math.abs(v-aFracPos)>1e-9));
  const texDecPos = String(aDecPos);

  // entier > 3
  const aBigPos = choice([4,5,6]);

  // -------- NÉGATIFS (indépendants, PAS miroir) --------
  // fraction < -1/2 (générée indépendamment)
  const q2 = choice([3,4,5,6,7,8,9,10,12]);
  const p2 = rint(Math.floor(q2/2)+1, q2-1);
  const g2 = gcd(p2,q2);
  const p2s = p2/g2, q2s = q2/g2;
  const aFracNeg = -(p2s/q2s);
  const texFracNeg = `-\\dfrac{${p2s}}{${q2s}}`;

  // décimale -0.x
  const aDecNeg = -choice(DEC);
  const texDecNeg = String(aDecNeg);

  // entier < -3
  const aBigNeg = -choice([4,5,6]);

  // assemble (3 + / 3 −)
  const funcs = [
    {name:'f1', a:aFracPos, tex:texFracPos},
    {name:'f2', a:aDecPos,  tex:texDecPos},
    {name:'f3', a:aBigPos},
    {name:'f4', a:aFracNeg, tex:texFracNeg},
    {name:'f5', a:aDecNeg,  tex:texDecNeg},
    {name:'f6', a:aBigNeg}
  ];

  // courbes mélangées
  const colors=['#e53935','#1e88e5','#8e24aa','#fb8c00','#2e7d32','#000'];
  const order=[0,1,2,3,4,5].sort(()=>Math.random()-0.5);
  const curves = order.map((k,i)=>({ a:funcs[k].a, c:0, color:colors[i], label:'C'+(i+1), idx:k }));

  const mapping={}; curves.forEach(cv=>{ mapping['f'+(cv.idx+1)]=cv.label; });

  return { funcs, curves, mapping, X:[-7,7], Y:[-6,6] };
}
,
  render(host,st){
    const svg=svgParabolas({curves:st.curves,X:st.X,Y:st.Y});
    host.innerHTML=[
      '<div>Sur le repère, associer chaque fonction à sa courbe correspondante.</div>',
      `<div style="margin:.4rem 0">${svg}</div>`,
      '<table class="table"><thead><tr><th></th><th>Fonction</th><th>Courbe</th><th>Valider</th></tr></thead><tbody>',
      st.funcs.map((f,i)=>{
        // Si on a un LaTeX explicite (fraction / décimale signée), on l’utilise.
        // Sinon, règle ±1 : -x^2, x^2, 6x^2, etc.
       const coef = (f.tex!=null)
  ? f.tex
  : (f.a===-1 ? '-' : (Math.abs(f.a)===1 ? '' : String(f.a)));

// i+1 pour l’indice, ou bien extraire depuis 'f1' → '1'
const fi = (i+1); // ou: f.name.replace(/^f/, '')
const tex = `f_{${fi}}(x)= ${coef}x^2`;


        return `
          <tr data-k="${f.name}">
            <td><strong>${String.fromCharCode(97+i)}.</strong></td>
            <td>${L(tex)}</td>
            <td><select class="pick"><option value="">—</option>${st.curves.map(c=>`<option>${c.label}</option>`).join('')}</select></td>
            <td><button class="btn btn-row">Valider</button></td>
          </tr>`;
      }).join(''),
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    host.dataset.state=JSON.stringify(st);
    host.addEventListener('click',e=>{
      const b=e.target.closest('.btn-row'); if(!b) return;
      checkRowEx1(host,b.closest('tr'),true);
    });
    typesetAll(host);
	// — Ticks au clic "Valider" (par ligne)
host.querySelectorAll('.btn-row').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tr = btn.closest('tr');
    const sel = tr.querySelector('.pick');
    const k = tr.dataset.k;
    const st = JSON.parse(host.dataset.state||'{}');
    const want = st.mapping[k];
    const got  = sel.value;
    if(!got){ setTick(sel,'nu'); return; }
    setTick(sel, got===want ? 'ok' : 'ko');
  });
});

  },
  correct(host,st){
    let ok=0,tot=0;
    $$('.table tbody tr',host).forEach(tr=>{
      const r=checkRowEx1(host,tr,true); if(r){ok+=r.ok; tot+=r.total;}
    });
    $('#res',host).innerHTML=`<div class="steps"><div class="step">Résultat : <b>${ok} / ${tot}</b></div></div>`;
    return {ok,total:tot};
  },
  solution(host,st){
    const html = st.funcs.map((f,i)=>`<div class="step"><b>${String.fromCharCode(97+i)})</b> → <b>${st.mapping[f.name]}</b></div>`).join('');
    $('#res',host).innerHTML = `<div class="steps">${html}</div>`;
  },
  reset(host){ $('#res',host).textContent=''; }
};


/* =======================================================
   EXO 2 — Variations (ax^2) — no sign table
   ======================================================= */
const ex2={
  id:'e2', title:'Ex. 2 — Variations pour fonctions définies par f(x)=ax²',
gen(){
  const choice = a => a[Math.floor(Math.random()*a.length)];
  const rint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const gcd = (x,y)=> y ? gcd(y, x%y) : Math.abs(x);

  // 50% entier, 50% fraction
  if (Math.random() < 0.5){
    // ENTIER dans {±1,±2,±3,±4}
    const A = [-4,-3,-2,-1,1,2,3,4];
    const a = choice(A);
    return { a };  // pas de aTex nécessaire
  } else {
    // FRACTION ±p/q (réduite), q petit ; signe au hasard
    const q = choice([2,3,4,5,6,8]);
    const p = rint(1, q-1);
    const s = choice([+1,-1]);
    const g = gcd(p,q);
    const ps = p/g, qs = q/g;
    const a = s * (ps/qs);
    const aTex = (s<0? '-' : '') + `\\dfrac{${ps}}{${qs}}`;
    return { a, aTex };
  }
},
  render(host, st){
  const coef = (st.aTex!=null) ? st.aTex
    : (st.a===-1 ? '-' : (Math.abs(st.a)===1 ? '' : String(st.a)));
  const tex = `f(x) = ${coef}x^2`;

  host.innerHTML = [
    `<div>Compléter le <strong>tableau de variations</strong> de la fonction \\(f\\) définie par : ${L(tex)}.</div>`,

    // 🔽 bloc offscreen demandé (servira pour le PDF)
    `<div class="equ-offscreen" style="display:none">
      <p>Donner le <strong>tableau de variations</strong> de la fonction \\(f\\) définie par : ${L(tex)}.</p>
    </div>`,

    '<div style="margin:.5rem 0">',
      '<div>Sommet : \\(S\\)( <input class="alpha-q" type="text" style="width:110px"> ; <input class="beta-q" type="text" style="width:110px"> )</div>',
    '</div>',
    '<div id="var-host"></div>',
    '<div class="steps small" id="res"></div>'
  ].join('');

  renderVariationTable($('#var-host', host));
  typesetAll(host);
  // — Ticks au clic "Valider" (par ligne)
host.querySelectorAll('.btn-row').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tr = btn.closest('tr');
    const sel = tr.querySelector('.pick');
    const k = tr.dataset.k;
    const st = JSON.parse(host.dataset.state||'{}');
    const want = st.mapping[k];
    const got  = sel.value;
    if(!got){ setTick(sel,'nu'); return; }
    setTick(sel, got===want ? 'ok' : 'ko');
  });
});

},

  correct(host,st){
    let ok=0, tot=0;
    const a=st.a;
    const A=$('.alpha-q',host).value.trim(); if(A){ tot++; if(A==='0') ok++; }
    const B=$('.beta-q',host).value.trim(); if(B){ tot++; if(B==='0') ok++; }
    const expect = a>0? ['↘','↗','bot'] : ['↗','↘','top'];
    const LT=$('.d-L',host).value, RT=$('.d-R',host).value;
    if(LT){ tot++; if(LT===expect[0]) ok++; }
    if(RT){ tot++; if(RT===expect[1]) ok++; }
    const betaTop = $('.d-beta-top',host).value.trim(), betaBot = $('.d-beta-bot',host).value.trim();
    if(betaTop || betaBot){
      let betaOKv=false;
      if(expect[2]==='top'){ betaOKv = (betaTop==='0' && betaBot===''); }
      else{ betaOKv = (betaBot==='0' && betaTop===''); }
      tot++; if(betaOKv) ok++;
    }
    const alphaIn=$('.alpha-in',host).value.trim(); if(alphaIn){ tot++; if(alphaIn==='0') ok++; }
    $('#res',host).innerHTML = `<div class="step">Résultat : <b>${ok} / ${tot}</b></div>`;
    return {ok,total:tot};
  },
solution(host,st){
  const a = st.a;
  const sgnA = a > 0 ? '>0' : '<0';
  const latexVar = latexTableVariations(a, 0, 0);
  const htmlVar  = pdfVarTableHTML(a, 0, '0'); // alpha=0, beta=0

  $('#res',host).innerHTML = `
    <div class="steps">
      <div class="step"><b>Sommet :</b> \\(S(0;0)\\).</div>
      <div class="step"><u>Tableau de variations</u> :</div>
      <div class="statement">
        ${latexVar} 
        <div class="pdf-only">${htmlVar}</div><span class="muted">car \\(a ${sgnA}\\)</span>
      </div>
    </div>`;
  typesetAll($('#res',host));
},

  reset(host){ $('#res',host).textContent=''; }
};

/* =======================================================
   EXO 3 — Étude d’une fonction (ax^2 ou ax^2+c) — slim sign table
   ======================================================= */
/* =======================================================
   EXO 3 — Étude d’une fonction (variations + signes)
   Pondérations :
   - 50% : deux racines entières
   - 10% : ax^2 (c=0)
   - 20% : deux racines ±√(p/q) (fraction, avec/sans simplification)
   - 20% : aucune racine (a et c de même signe)
   ======================================================= */
const ex3 = {
  id:'e3',
  title:'Ex. 3 — Étude d’une fonction définie par f(x)=ax²+c',
  gen(){
  const choice=a=>a[Math.floor(Math.random()*a.length)];
  const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const gcd=(x,y)=>y?gcd(y,x%y):Math.abs(x);

  const A=[-6,-4,-3,-2,-1,1,2,3,4,6];      // a possibles
  const u=Math.random();
  let a,c,meta={kind:''};

  if(u<0.50){
    // 50% — 2 racines entières : -c/a = r^2
    a = choice(A);
    const r = choice([1,2,3]);
    c = -a*r*r;
    meta = {kind:'two_int', r};
  }else if(u<0.60){
    // 10% — ax^2
    a = choice(A); c = 0; meta = {kind:'ax2'};
  }else if(u<0.80){
    // 20% — 2 racines ±√(p/q), avec c ENTIER
    // Étapes : tirer p/q, choisir a multiple de q dans A, poser c = -(a/q)*p
    // q choisis de façon à avoir des multiples dans A ; on boucle si besoin.
    const possibleQ = [2,3,4,6]; // (5 exclus car pas de multiple ≤6 dans A)
    let ps, qs, ok=false, tries=0;
    while(!ok && tries++<8){
      const q = choice(possibleQ);
      const p = rint(1, 2*q);                     // p/q > 0
      const g = gcd(p,q); ps=p/g; qs=q/g;         // simplifié

      // a doit être multiple de qs et appartenir à A
      const mults = [qs, 2*qs, 3*qs, 4*qs, 6]     // candidats ≤6
        .map(x=>[x,-x]).flat()
        .filter(x=>A.includes(x));
      if(mults.length===0) continue;

      a = choice(mults);                           // a ∈ A et qs | a
      c = -(a/qs)*ps;                              // ==> c entier
      ok = true;
    }
    if(!ok){ // garde-fou (ne devrait pas arriver)
      a = 2; ps = 1; qs = 2; c = -(a/qs)*ps;       // a=2, p/q=1/2 → c=-1
    }
const rTex = sqrtSimplifyFracTex(ps, qs);   // au lieu d’un simple \sqrt{p/q}

meta = {kind:'two_frac', p:ps, q:qs, rTex};    meta = {kind:'two_frac', p:ps, q:qs, rTex};
  }else{
    // 20% — aucune racine (a et c même signe), c ENTIER
    a = choice(A);
    const s = a>0 ? 1 : -1;
    c = s * choice([1,2,3]);
    meta = {kind:'none'};
  }
  return {a,c,meta};
}
,

  render(host,st){
    const a=st.a,c=st.c;
    const aTex = (Math.abs(a)===1 ? (a===-1?'-':'') : String(a));
    const tex = `f(x)= ${aTex}x^2 ${c===0?'':(c>0?'+ ':'- ')+Math.abs(c)}`;

    host.innerHTML=[
      `<div>On considère ${L(tex)}. Compléter :</div>`,
	    // 🔽 bloc offscreen demandé (servira pour le PDF)
    `<div class="equ-offscreen" style="display:none">
      <p>Soit le polynôme ${L(tex)}.</p>
	  <p>Déterminer : ses racines éventuelles ; le sens de la parabole, son sommet et son axe de symétrie ; le tableau de variations et le tableau de signes.</p>
    </div>`,
      '<table class="table"><thead><tr><th>Élément</th><th>Réponse</th></tr></thead><tbody>',
      `<tr data-k="roots"><td>Racines</td><td><input class="roots" type="text" placeholder="" style="width:220px"></td></tr>`,
      `<tr data-k="open"><td>Ouverture de la parabole</td><td><select class="open"><option value=""></option><option>vers le haut</option><option>vers le bas</option></select></td></tr>`,
      `<tr data-k="vertex"><td>Sommet</td><td><input class="pt" type="text" placeholder="" style="width:120px"></td></tr>`,
      `<tr data-k="axis"><td>Axe de symétrie</td><td><input class="axis" type="text" placeholder="" style="width:120px"></td></tr>`,
      '</tbody></table>',
      '<div style="margin:.4rem 0">Tableau de variations :</div>',
      '<div id="var-host3"></div>',
      '<div style="margin:.4rem 0">Tableau de signes (sans r₁/r₂) :</div>',
      '<div id="sign-host3"></div>',
      '<div id="res" class="small"></div>'
    ].join('');
    renderVariationTable($('#var-host3',host));
    $('#sign-host3',host).innerHTML = signTableHTML();
    typesetAll(host);
	// — Ticks au clic "Valider" (par ligne)
host.querySelectorAll('.btn-row').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tr = btn.closest('tr');
    const sel = tr.querySelector('.pick');
    const k = tr.dataset.k;
    const st = JSON.parse(host.dataset.state||'{}');
    const want = st.mapping[k];
    const got  = sel.value;
    if(!got){ setTick(sel,'nu'); return; }
    setTick(sel, got===want ? 'ok' : 'ko');
  });
});

  },

  correct(host,st){
    let ok=0, tot=0;
    const a=st.a,c=st.c;
    const R=(function rootsAx2c(a,c){
      if(c===0) return [0];
      const t=-c/a; if(t<0) return [];
      const r=Math.sqrt(t);
      if(Math.abs(r-Math.round(r))<1e-9) return [-Math.round(r), Math.round(r)];
      return ['irr', r];
    })(a,c);

    // Racines
   

   // Racines
const got = parseRootList($('.roots',host).value);
if(got!=null){
  let good=false;
  if(Array.isArray(R) && R.length===0){
    good = (got.length===0);
  }else if(Array.isArray(R) && R[0]!=='irr'){
    const want=[...new Set(R)].sort((x,y)=>x-y);
    const A=[...new Set(got)].sort((x,y)=>x-y);
    good=(A.length===want.length)&&A.every((v,i)=>Math.abs(v-want[i])<1e-9);
  }else{
  // --- irrationnelles : il faut exactement ±sqrt(-c/a)
  const r = Math.sqrt(-c/a);
  good = hasPlusMinusPair(got, r);
}
  tot++; if(good) ok++;
}

    // Ouverture
    const v=$('.open',host).value; if(v){ tot++; if(a>0? v==='vers le haut' : v==='vers le bas') ok++; }
    // Sommet
   // Sommet (robuste : supporte virgule décimale & parenthèses)
const vPt = $('.pt',host).value;
const P = parseVertexPoint(vPt);
if(P){ 
  tot++; 
  const good = Math.abs(P[0]-0)<1e-9 && Math.abs(P[1]-c)<1e-9;
  if(good) ok++;
}
 // Axe
    const ax=($('.axis',host).value||'').replace(/\s+/g,'').toLowerCase(); if(ax){ tot++; if(ax==='x=0' || ax==='x=0.') ok++; }

    // VARIATIONS
    const expect = a>0? ['↘','↗','bot'] : ['↗','↘','top'];
    const LT=$('.d-L',host).value, RT=$('.d-R',host).value;
    if(LT){ tot++; if(LT===expect[0]) ok++; }
    if(RT){ tot++; if(RT===expect[1]) ok++; }
    const betaTop = $('.d-beta-top',host).value.trim(), betaBot = $('.d-beta-bot',host).value.trim();
    if(betaTop || betaBot){
      let betaOK=false, want=String(c);
      if(expect[2]==='top'){ betaOK = (betaTop===want && !betaBot); }
      else{ betaOK = (betaBot===want && !betaTop); }
      tot++; if(betaOK) ok++;
    }
    const alphaIn=$('.alpha-in',host).value.trim(); if(alphaIn){ tot++; if(alphaIn==='0') ok++; }
// --- Ligne des racines du tableau de signes (r1 | alpha | r2)
(function(){
  const r1 = $('#r1',host), r2 = $('#r2',host), a0 = $('#alpha',host);
  const v1 = valTrim(r1), v2 = valTrim(r2), va = valTrim(a0);

  // On compte seulement ce que l’élève a rempli (pas de pénalité si vide partout)
  let counted = false, good = true;

  if(va){ counted = true; if(va!=='0') good = false; }

  const t = -c/a, hasTwo = (t>0 && c!==0), hasNone = (t<0), hasDouble = (c===0);
  const Rabs = hasTwo ? Math.sqrt(t) : (hasDouble ? 0 : NaN);

  if(hasTwo){
    if(v1){ counted = true; if(!isRootOK(parseRootValue(v1), Rabs, -1)) good = false; }
    if(v2){ counted = true; if(!isRootOK(parseRootValue(v2), Rabs, +1)) good = false; }
  }else if(hasDouble){
    if(v1){ counted = true; if(Number(v1)!==0) good = false; }
    if(v2){ counted = true; if(Number(v2)!==0) good = false; }
  }else{ // aucune racine → r1 et r2 doivent rester vides si on les évalue
    if(v1){ counted = true; good = false; }
    if(v2){ counted = true; good = false; }
  }

  if(counted){ tot++; if(good) ok++; }
})();


   // SIGNES (nouvelle grille s1 | z1 | s2 | z2 | s3)
(function(){
  const norm = s => (s||'').replace(/\u2212/g,'-'); // normalise le "−"
  const v1 = norm($('#s1',host).value);
  const vm1= norm($('#z1',host).value);
  const v2 = norm($('#s2',host).value);
  const vm2= norm($('#z2',host).value);
  const v3 = norm($('#s3',host).value);
  if(!v1 && !vm1 && !v2 && !vm2 && !v3) return; // tout vide → pas compté

  const R2 = (Array.isArray(R) && R[0]!=='irr' && R.length===2);
  const R0 = (Array.isArray(R) && R.length===1 && R[0]===0);
  const none = (Array.isArray(R) && R.length===0);
const sOut = a>0? '+' : '-';
const sIn  = a>0? '-' : '+';



  let good=false;
  if(R2){
    // deux racines : + | 0 | - | 0 | +
    good = (v1===sOut && vm1==='0' && v2===sIn && vm2==='0' && v3===sOut);
  }else if(R0){
    // racine double en 0 (au centre) : + |   | 0 |   | +
    // (on accepte z1 vide et z2 vide, le 0 doit être sur s2)
    good = (v1===sOut && v2==='0' && v3===sOut && (!vm1||vm1==='') && (!vm2||vm2===''));
 }else if(none){
  // aucune racine :   |   | sOut |   |
  good = (
    (v1==='' || v1===undefined) &&
    v2===sOut &&
    (v3==='' || v3===undefined) &&
    (!vm1 || vm1==='') &&
    (!vm2 || vm2==='')
  );
}
else{
    // racines irrationnelles (on ne peut pas exiger l’emplacement exact) :
    // on demande simplement + | 0 | - | 0 | + si l’élève met des zéros
    // ou bien + |   | - |   | + si aucun zéro n’est mis.
    const patternWithZeros = (v1===sOut && vm1==='0' && v2===sIn && vm2==='0' && v3===sOut);
    const patternNoZeros   = (v1===sOut && (vm1===''||vm1===undefined) && v2===sIn && (vm2===''||vm2===undefined) && v3===sOut);
    good = patternWithZeros || patternNoZeros;
  }
  tot++; if(good) ok++;
})();


    $('#res',host).innerHTML = `<div class="steps"><div class="step">Résultat : <b>${ok} / ${tot}</b></div></div>`;
    return {ok,total:tot};
  },

  // === Ex.3 — SOLUTION propre (sans flèches, étapes nettes, sans doublons)
solution(host, st){
  const a = st.a, c = st.c, kind = st.meta.kind;

  // ---- helpers ----
  const sgnA = a > 0 ? '>0' : '<0';
  const aTex = (Math.abs(a) === 1 ? (a === -1 ? '-' : '') : String(a));
  const fTex = `f(x)= ${aTex}x^2 ${c===0 ? '' : (c>0?'+ ':'- ') + Math.abs(c)}`;

  const gcd = (x,y)=> y ? gcd(y, x%y) : Math.abs(x);
  const fracTex = (num, den)=>{               // fraction positive réduite
    let p=Math.abs(num), q=Math.abs(den); const g=gcd(p,q); p/=g; q/=g;
    return q===1 ? `${p}` : `\\dfrac{${p}}{${q}}`;
  };
  const fracTexSigned = (num, den)=>{         // fraction signée réduite
    const sgn = (num*den<0) ? '-' : '';
    let p=Math.abs(num), q=Math.abs(den); const g=gcd(p,q); p/=g; q/=g;
    return q===1 ? `${sgn}${p}` : `${sgn}\\dfrac{${p}}{${q}}`;
  };
  const stepsBox = (lines)=>{
    // supprime doublons & vides en conservant l’ordre
    const out=[]; let prev=null;
    lines.forEach(L=>{
      const s=String(L).trim();
      if(!s) return;
      if(s!==prev){ out.push(s); prev=s; }
    });
    return '<div class="step"><div style="border:1px solid #bbb;border-radius:8px;padding:8px 10px;background:#fff">'
         + out.map(s=>`<div>\\(${s}\\)</div>`).join('')
         + '</div></div>';
  };

  // ---- contenu spécifique par cas ----
  let rootsTxt='n’a pas de racine', rootTex=null, derivBlock='',
      remarque = '';               // NEW: valeur par défaut

  if(kind === 'ax2'){
    // c = 0 → racine double 0
    rootsTxt = 'Le polynôme a une seule racine 0 (double)';
    rootTex  = '0';
    derivBlock = stepsBox([
      `${aTex}x^2 = 0`,
      `x^2 = 0`,
      `x = 0`
    ]);

  } else if (kind === 'two_int'){
    // deux racines entières ±r
    const r = st.meta.r;
    rootsTxt = `Le polynôme a deux racines : \\(x=${-r}\\) et \\(x=${r}\\)`;
    rootTex  = [`${-r}`, `${r}`];
    const absC = Math.abs(c);

    derivBlock = stepsBox([
      `${aTex}x^2 ${c>0?'+':'-'} ${absC} = 0`,
      `${aTex}x^2 = ${-c}`,                       // signe conservé
      `x^2 = ${r*r}`,                             // on sait que -c/a = r²
      `x = ${-r} \\;\\text{ ou }\\; x = ${r}`
    ]);

  } else if (kind === 'two_frac') {
  const rTex = sqrtSimplifyFracTex(st.meta.p, st.meta.q);
  rootsTxt = `Le polynôme a deux racines : \\(x=-${rTex}\\) et \\(x=${rTex}\\)`;
  rootTex  = [`-${rTex}`, `${rTex}`];

  const absC = Math.abs(c), absA = Math.abs(a);
  derivBlock = stepsBox([
    `${aTex}x^2 ${c>0?'+':'-'} ${absC} = 0`,
    `${aTex}x^2 = ${-c}`,
    `x^2 = \\dfrac{${absC}}{${absA}}`,        // = |c|/|a| (réduit dans l’étape suivante)
    `x = -${rTex} \\;\\text{ ou }\\; x = ${rTex}`
  ]);



    } else { // 'none' — aucune racine (a et c ont le même signe)
    const absC = Math.abs(c);
    const neg = fracTexSigned(-c, a);  // (-c)/a < 0

    rootsTxt = 'Le polynôme n’a pas de racine';
    derivBlock = stepsBox([
      `${aTex}x^2 ${c>0?'+':'-'} ${absC} = 0`,
      `${aTex}x^2 = ${-c}`,
      `x^2 = ${neg} \\;< 0\\; \\text{(impossible)}`
    ]);
    remarque = `Remarque : On savait déjà que le polynôme n'avait pas de racine car \\(a\\) et \\(c\\) \\( \\)ont le même signe`; // FIX: assigner ici
  }


  // Tableaux LaTeX déjà calculés :
  const latexVar  = latexTableVariations(a, 0, c);
rootTex = pdfRootsLabels(a, c);
  const latexSign = latexTableSignesDetailed(a, rootTex);

  // Versions HTML (bordures) pour le PDF :
  const htmlVar   = pdfVarTableHTML(a, 0, String(c));
  const htmlSign  = pdfSignTableHTML(a, rootTex);

  $('#res',host).innerHTML = `
         <div class="steps">
      <div class="step"><b>On considère</b> ${L(fTex)}</div>
      <div class="statement">• \\(f\\) est de la forme \\(ax^2${c!==0?'+c':''}\\) avec \\(a=${a}\\)${c!==0?` et \\(c=${c}\\)`:''}.</div>
      <div class="statement">• ${rootsTxt}</div>
	  <div class="statement">${derivBlock}</div>
      ${remarque ? `<div class="statement">${remarque}</div>` : ''}   <!-- NEW: n’affiche que si non vide -->
      
	  
      <div class="statement">• La parabole est tournée vers le ${a>0?'haut':'bas'} car \\(a ${sgnA}\\).</div>
      <div class="statement">• Le sommet est le point \\(S(0 ; c)\\), on a donc : \\(S(0;${c})\\).</div>
      <div class="statement">• L’axe de symétrie est l’axe des ordonnées (droite \\(x=0\\)).</div>

      <div class="step">• <u>Tableau de variations</u> :</div>
      <div class="statement">
        ${latexVar} 
        <div class="pdf-only">${htmlVar}</div><span class="muted">car \\(a ${a>0?'>0':'<0'}\\)</span>
      </div>

      <div class="step">• <u>Tableau de signes</u> :</div>
      <div class="statement">
        ${latexSign}  
        <div class="pdf-only">${htmlSign}</div><span class="muted">car \\(a ${a>0?'>0':'<0'}\\)</span>
      </div>
    </div>`;
  typesetAll($('#res',host));
},
  reset(host){ $('#res',host).textContent=''; }
};


/* =======================================================
   EXO 4 — Associer ax^2 + c (mêmes contraintes de a que Ex.1)
   + Contraintes sur c :
     - 2 courbes POSITIVES partagent le même c (cA)
     - 1 courbe NÉGATIVE et 1 POSITIVE partagent le même c (cB)
     - au maximum une courbe avec c = 0
   ======================================================= */
const ex4 = {
  id:'e4',
  title:'Ex. 4 — Associer f(x)=ax²+c aux courbes',
  gen(){
    const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const choice=a=>a[Math.floor(Math.random()*a.length)];
    const shuffle=a=>{const b=a.slice(); for(let i=b.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]];} return b;};
    const gcd=(x,y)=>y?gcd(y,x%y):Math.abs(x);

    /* ---- a : mêmes contraintes que Ex.1 ---- */
    // POSITIFS
    const q1 = choice([3,4,5,6,7,8,9,10,12]);
    const p1 = rint(Math.floor(q1/2)+1, q1-1);
    const g1 = gcd(p1,q1); const p1s=p1/g1, q1s=q1/g1;
    const aFracPos = p1s/q1s, texFracPos = `\\dfrac{${p1s}}{${q1s}}`;
    const DEC = [0.1,0.2,0.25,0.3,0.33,0.4,0.45,0.48];
    const aDecPos = choice(DEC.filter(v=>Math.abs(v-aFracPos)>1e-9));
    const texDecPos = String(aDecPos);
    const aBigPos = choice([4,5,6]);
    // NÉGATIFS (indépendants)
    const q2 = choice([3,4,5,6,7,8,9,10,12]);
    const p2 = rint(Math.floor(q2/2)+1, q2-1);
    const g2 = gcd(p2,q2); const p2s=p2/g2, q2s=q2/g2;
    const aFracNeg = -(p2s/q2s), texFracNeg = `-\\dfrac{${p2s}}{${q2s}}`;
    const aDecNeg = -choice(DEC);
    const texDecNeg = String(aDecNeg);
    const aBigNeg = -choice([4,5,6]);

    const funcsBase = [
      {name:'f1', a:aFracPos, texA:texFracPos, sign:'+'},
      {name:'f2', a:aDecPos,  texA:texDecPos,  sign:'+'},
      {name:'f3', a:aBigPos,  texA:null,       sign:'+'},
      {name:'f4', a:aFracNeg, texA:texFracNeg, sign:'-'},
      {name:'f5', a:aDecNeg,  texA:texDecNeg,  sign:'-'},
      {name:'f6', a:aBigNeg,  texA:null,       sign:'-'},
    ];

    /* ---- c : contraintes demandées ---- */
    const ALLC = [-3,-2,-1,0,1,2,3];
    const NON0 = [-3,-2,-1,1,2,3];

    // 1) choisir les index des fonctions concernés par les partages
    const posIdx = [0,1,2], negIdx = [3,4,5];
    const posPair = shuffle(posIdx).slice(0,2);            // 2 positives avec même cA
    const posSolo = posIdx.find(i => !posPair.includes(i));// l'autre positive
    const negPair = choice(negIdx);                        // 1 négative qui partagera cB
    const negRest = negIdx.filter(i => i !== negPair);     // les 2 négatives restantes

    // 2) choisir cA et cB (éviter 0 par défaut ; "au plus un 0" reste possible plus bas)
    const cA = choice(NON0);
    const cB = choice(NON0.filter(v => v !== cA));

    // 3) choisir cC et cD pour les deux négatives restantes
    //    - distincts entre eux
    //    - différents de cA et cB
    //    - au plus un 0 au total
    let used = new Set([cA, cB]);
    let zeroUsed = false;
    const pickC = (allowZero)=>{
      let pool = (allowZero ? ALLC : NON0).filter(v => !used.has(v));
      if(pool.length===0) pool = NON0.filter(v => !used.has(v));
      return choice(pool);
    };
    let cC = pickC(true);
    if(cC===0) zeroUsed = true; used.add(cC);
    let cD = pickC(!zeroUsed); // si 0 déjà utilisé, on interdit 0 ici
    used.add(cD);

    // 4) on a maintenant : cA pour les deux positives posPair,
    //    cB pour (posSolo + negPair), et cC, cD pour negRest[0], negRest[1]
    const cMap = new Map();
    cMap.set(posPair[0], cA);
    cMap.set(posPair[1], cA);
    cMap.set(posSolo,   cB);
    cMap.set(negPair,   cB);
    cMap.set(negRest[0], cC);
    cMap.set(negRest[1], cD);

    // 5) appliquer les c aux fonctions
    const funcs = funcsBase.map((f,idx)=>({ ...f, c: cMap.get(idx) }));

    /* ---- courbes / mapping ---- */
    const colors=['#e53935','#1e88e5','#8e24aa','#fb8c00','#2e7d32','#000'];
    const order=shuffle([0,1,2,3,4,5]);
    const curves = order.map((idx,i)=>({
      a: funcs[idx].a, c: funcs[idx].c, color: colors[i], label: 'C'+(i+1), idx
    }));
    const mapping={}; curves.forEach(cv=>{ mapping['f'+(cv.idx+1)] = cv.label; });

    return { funcs, curves, mapping, X:[-7,7], Y:[-6,6] };
  },
  render(host,st){
    const svg = svgParabolas({curves:st.curves, X:st.X, Y:st.Y});
    host.innerHTML = [
      '<div>Relier chaque fonction à sa courbe.</div>',
      `<div style="margin:.4rem 0">${svg}</div>`,
      '<table class="table"><thead><tr><th></th><th>Fonction</th><th>Courbe</th><th>Valider</th></tr></thead><tbody>',
      st.funcs.map((f,i)=>{
       const aTex = (f.texA!=null)
  ? f.texA
  : (f.a===-1 ? '-' : (Math.abs(f.a)===1 ? '' : String(f.a)));

const fi = (i+1); // ou: f.name.replace(/^f/, '')
const tex = `f_{${fi}}(x)= ${aTex}x^2 ${f.c===0?'':(f.c>0?'+ ':'- ')+Math.abs(f.c)}`;
return `
          <tr data-k="${f.name}">
            <td><strong>${i+1}.</strong></td>
            <td>${L(tex)}</td>
            <td><select class="pick"><option value="">—</option>${st.curves.map(c=>`<option>${c.label}</option>`).join('')}</select></td>
            <td><button class="btn btn-row">Valider</button></td>
          </tr>`;
      }).join(''),
      '</tbody></table>',
      '<div id="res" class="small"></div>'
    ].join('');
    host.dataset.state=JSON.stringify(st);
    host.addEventListener('click',e=>{
      const b=e.target.closest('.btn-row'); if(!b) return;
      checkRowEx4(host,b.closest('tr'),true);
    });
    typesetAll(host);
	// — Ticks au clic "Valider" (par ligne)
host.querySelectorAll('.btn-row').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tr = btn.closest('tr');
    const sel = tr.querySelector('.pick');
    const k = tr.dataset.k;
    const st = JSON.parse(host.dataset.state||'{}');
    const want = st.mapping[k];
    const got  = sel.value;
    if(!got){ setTick(sel,'nu'); return; }
    setTick(sel, got===want ? 'ok' : 'ko');
  });
});

  },
  correct(host,st){
    let ok=0, tot=0;
    $$('.table tbody tr',host).forEach(tr=>{
      const r=checkRowEx4(host,tr,true); if(r){ ok+=r.ok; tot+=r.total; }
    });
    $('#res',host).innerHTML = `<div class="steps"><div class="step">Résultat : <b>${ok} / ${tot}</b></div></div>`;
    return {ok, total:tot};
  },
  solution(host,st){
    const html = st.funcs.map((f,i)=>`<div class="step"><b>${i+1}.</b> → <b>${st.mapping[f.name]}</b></div>`).join('');
    $('#res',host).innerHTML = `<div class="steps">${html}</div>`;
  },
  reset(host){ $('#res',host).textContent=''; }
};


/* ===== Registre & UI ===== */
const REGISTRY=[ex1,ex2,ex3,ex4];
window.REGISTRY = REGISTRY;                 // <— required by the PDF kit
window.getDefById = id => REGISTRY.find(d => d.id === id); // (optional helper)
function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }
/* ===== Live validators par exercice ===== */


// Ex.1 — Associer ax²
function wireLiveEx1(host, st){
  // un tick sur chaque <select class="pick">
  host.querySelectorAll('tr[data-k] .pick').forEach(sel=>{
    ensureTickAfter(sel);
    sel.addEventListener('change', ()=>{
      const k = sel.closest('tr').dataset.k;     // f1..f6
      const want = st.mapping[k];                // 'C3'...
      const got  = sel.value;
      if(!got){ setTick(sel,'nu'); return; }     // vide → neutre
      setTick(sel, got===want ? 'ok' : 'ko');
    });
  });
}

// Ex.4 — Associer ax²+c (même logique que Ex.1)
function wireLiveEx4(host, st){
  host.querySelectorAll('tr[data-k] .pick').forEach(sel=>{
    ensureTickAfter(sel);
    sel.addEventListener('change', ()=>{
      const k = sel.closest('tr').dataset.k;
      const want = st.mapping[k];
      const got  = sel.value;
      if(!got){ setTick(sel,'nu'); return; }
      setTick(sel, got===want ? 'ok' : 'ko');
    });
  });
}

// Ex.2 — Variations ax² (alpha/beta 0, directions, position de 0)
function wireLiveEx2(host, st){
  const a = st.a;
  const expect = a>0 ? {L:'↘', R:'↗', zeroAt:'bot'} : {L:'↗', R:'↘', zeroAt:'top'};

  const A = host.querySelector('.alpha-q');
  const B = host.querySelector('.beta-q');
  const Ls= host.querySelector('.d-L');
  const Rs= host.querySelector('.d-R');
  const tTop = host.querySelector('.d-beta-top');
  const tBot = host.querySelector('.d-beta-bot');
  const alphaIn = host.querySelector('.alpha-in');

  [A,B,Ls,Rs,tTop,tBot,alphaIn].forEach(el=> el && ensureTickAfter(el));

  A?.addEventListener('input', ()=>{
    const v=valTrim(A);
    if(!v){ setTick(A,'nu'); return; }
    setTick(A, v==='0' ? 'ok' : 'ko');
  });
  B?.addEventListener('input', ()=>{
    const v=valTrim(B);
    if(!v){ setTick(B,'nu'); return; }
    setTick(B, v==='0' ? 'ok' : 'ko');
  });
  Ls?.addEventListener('change', ()=>{
    const v=valTrim(Ls);
    if(!v){ setTick(Ls,'nu'); return; }
    setTick(Ls, v===expect.L ? 'ok' : 'ko');
  });
  Rs?.addEventListener('change', ()=>{
    const v=valTrim(Rs);
    if(!v){ setTick(Rs,'nu'); return; }
    setTick(Rs, v===expect.R ? 'ok' : 'ko');
  });
  function checkZeroCell(){
    const vTop=valTrim(tTop), vBot=valTrim(tBot);
    if(!vTop && !vBot){ setTick(tTop,'nu'); setTick(tBot,'nu'); return; }
    const ok = (expect.zeroAt==='top') ? (vTop==='0' && !vBot) : (vBot==='0' && !vTop);
    setTick(tTop, ok ? 'ok':'ko');
    setTick(tBot, ok ? 'ok':'ko');
  }
  tTop?.addEventListener('input', checkZeroCell);
  tBot?.addEventListener('input', checkZeroCell);

  alphaIn?.addEventListener('input', ()=>{
    const v=valTrim(alphaIn);
    if(!v){ setTick(alphaIn,'nu'); return; }
    setTick(alphaIn, v==='0' ? 'ok' : 'ko');
  });
}

// Ex.3 — Étude ax²+c (live ticks complets)
function wireLiveEx3(host, st){
  const a=st.a, c=st.c;

  // éléments
  const tRoots = host.querySelector('.roots');
  const sOpen  = host.querySelector('.open');
  const tPt    = host.querySelector('.pt');
  const tAxis  = host.querySelector('.axis');

  const Ls= host.querySelector('.d-L');
  const Rs= host.querySelector('.d-R');
  const tTop = host.querySelector('.d-beta-top');
  const tBot = host.querySelector('.d-beta-bot');
  const alphaIn = host.querySelector('.alpha-in');

  // --- ligne du haut du tableau de signes
  const r1El = host.querySelector('#r1');
  const aEl  = host.querySelector('#alpha');
  const r2El = host.querySelector('#r2');

  const s1 = host.querySelector('#s1');
  const z1 = host.querySelector('#z1');
  const s2 = host.querySelector('#s2');
  const z2 = host.querySelector('#z2');
  const s3 = host.querySelector('#s3');

  // ticks
  [tRoots,sOpen,tPt,tAxis,Ls,Rs,tTop,tBot,alphaIn,s1,z1,s2,z2,s3,r1El,aEl,r2El]
    .forEach(el=> el && ensureTickAfter(el));

  // Racines "math" attendues
  // R = [] (aucune) | [0] (double) | ['irr', r] (irrationnelles) | [-k, +k] (entières)
  const R=(function rootsAx2c(a,c){
    if(c===0) return [0];
    const t=-c/a; if(t<0) return [];
    const r=Math.sqrt(t);
    if(Math.abs(r-Math.round(r))<1e-9) return [-Math.round(r), Math.round(r)];
    return ['irr', r];
  })(a,c);

  // === ticks "r1 / alpha / r2" ===
function updateTopRowTicks(){
  const v1 = valTrim(r1El);
  const va = valTrim(aEl);
  const v2 = valTrim(r2El);

  // nothing filled -> neutral ticks
  if(!v1 && !va && !v2){ [r1El,aEl,r2El].forEach(el=> setTick(el,'nu')); return; }

  const t = -c/a;
  const hasNone   = (t<0);
  const hasDouble = (c===0);
  const hasTwo    = (!hasNone && !hasDouble);

  if(hasNone){
    // expect all empty; α may be 0
    setTick(r1El, v1 ? 'ko' : 'ok');
    setTick(r2El, v2 ? 'ko' : 'ok');
    if(!va){ setTick(aEl,'ok'); } else { setTick(aEl, (va==='0')?'ok':'ko'); }
    return;
  }

  if(hasDouble){
    // r1 empty, r2 empty, α = 0 (α empty stays neutral)
    setTick(r1El, v1 ? 'ko' : 'ok');
    setTick(r2El, v2 ? 'ko' : 'ok');
    if(!va){ setTick(aEl,'nu'); } else { setTick(aEl, (va==='0')?'ok':'ko'); }
    return;
  }

  // hasTwo: integer or irrational
  const Rabs = Math.sqrt(t);

  // ok flags for r1/r2 (works for integer and irrational entries)
  const okL = v1 && isRootOK(parseRootValue(v1), Rabs, -1);
  const okR = v2 && isRootOK(parseRootValue(v2), Rabs, +1);

  setTick(r1El, v1 ? (okL?'ok':'ko') : 'nu');
  setTick(r2El, v2 ? (okR?'ok':'ko') : 'nu');

  // α: empty → ✓ only if BOTH roots are correct; otherwise neutral.
  if(!va){
    setTick(aEl, (okL && okR) ? 'ok' : 'nu');
  }else{
    setTick(aEl, almost(parseRootVal(va),0) ? 'ok':'ko');
  }
}


  [r1El,aEl,r2El].forEach(el=> el && el.addEventListener('input', updateTopRowTicks));
  updateTopRowTicks();

  // ======== RACINES (champ liste) ========
  tRoots?.addEventListener('input', ()=>{
    const got = parseRootList(valTrim(tRoots));
    if(Array.isArray(R) && R.length===0){
      good = (got.length===0);
    }else if(Array.isArray(R) && R[0]!=='irr'){
      // racines entières → comparer numériquement (accepte -√4;√4, etc.)
const want = [...new Set(R)].sort((x,y)=>x-y);
const A    = [...new Set(got)].sort((x,y)=>x-y);
      good=(A.length===want.length)&&A.every((v,i)=>Math.abs(v-want[i])<1e-9);
    }else{
      // irrationnelles : au moins une saisie (forme exacte ou non)
      // irrationnelles : il faut exactement deux valeurs, ±r
const r = Math.sqrt(-c/a);
if(got.length===2){
  const [g1,g2] = got;
  const okL = Math.abs(g1 + r) < 1e-9 || Math.abs(g2 + r) < 1e-9;
  const okR = Math.abs(g1 - r) < 1e-9 || Math.abs(g2 - r) < 1e-9;
  good = okL && okR;
}else{
  good = false;
}

   }
    setTick(tRoots, good?'ok':'ko');
  });

  // ======== Ouverture, sommet, axe ========
  sOpen?.addEventListener('change', ()=>{
    const v=valTrim(sOpen);
    if(!v){ setTick(sOpen,'nu'); return; }
    setTick(sOpen, (a>0 ? v==='vers le haut' : v==='vers le bas') ? 'ok':'ko');
  });

// --- Sommet (live) : accepter (0;0), 0;0, 0,0, S(0;0), espaces, virgule décimale, etc.
tPt?.addEventListener('input', ()=>{
  const P = parseVertexPoint(valTrim(tPt));  // ← on réutilise le parseur robuste
  if(!P){ setTick(tPt,'nu'); return; }
  const ok = Math.abs(P[0]-0) < 1e-9 && Math.abs(P[1]-c) < 1e-9;
  setTick(tPt, ok ? 'ok' : 'ko');
});

  tAxis?.addEventListener('input', ()=>{
    const v=valTrim(tAxis).toLowerCase();
    if(!v){ setTick(tAxis,'nu'); return; }
    setTick(tAxis, (v==='x=0'||v==='x=0.')?'ok':'ko');
  });

  // ======== Variations ========
  const expect = a>0 ? {L:'↘', R:'↗', zeroAt:'bot', beta:String(c)} : {L:'↗', R:'↘', zeroAt:'top', beta:String(c)};
  Ls?.addEventListener('change', ()=>{
    const v=valTrim(Ls);
    if(!v){ setTick(Ls,'nu'); return; }
    setTick(Ls, v===expect.L ? 'ok' : 'ko');
  });
  Rs?.addEventListener('change', ()=>{
    const v=valTrim(Rs);
    if(!v){ setTick(Rs,'nu'); return; }
    setTick(Rs, v===expect.R ? 'ok' : 'ko');
  });
  function checkZeroCell3(){
    const vTop=valTrim(tTop), vBot=valTrim(tBot);
    if(!vTop && !vBot){ setTick(tTop,'nu'); setTick(tBot,'nu'); return; }
    const ok = (expect.zeroAt==='top') ? (vTop===expect.beta && !vBot) : (vBot===expect.beta && !vTop);
    setTick(tTop, ok ? 'ok':'ko'); setTick(tBot, ok ? 'ok':'ko');
  }
  tTop?.addEventListener('input', checkZeroCell3);
  tBot?.addEventListener('input', checkZeroCell3);
  alphaIn?.addEventListener('input', ()=>{
    const v=valTrim(alphaIn);
    if(!v){ setTick(alphaIn,'nu'); return; }
    setTick(alphaIn, v==='0' ? 'ok':'ko');
  });

  // ======== Signes (ligne du bas) ========
  function checkSignSlim(){
  const v1 = normSign($('#s1',host).value);
const vm1= normSign($('#z1',host).value);
const v2 = normSign($('#s2',host).value);
const vm2= normSign($('#z2',host).value);
const v3 = normSign($('#s3',host).value);



    if(!v1 && !vm1 && !v2 && !vm2 && !v3){
      [s1,z1,s2,z2,s3].forEach(el=> setTick(el,'nu')); return;
    }

    const R2   = (Array.isArray(R) && R[0]!=='irr' && R.length===2);
    const R0   = (Array.isArray(R) && R.length===1 && R[0]===0);
    const none = (Array.isArray(R) && R.length===0);

   const sOut = (a>0? '+' : '-');
const sIn  = (a>0? '-' : '+');

    let good=false;
    if(R2){
      good = (v1===sOut && vm1==='0' && v2===sIn && vm2==='0' && v3===sOut);
    }else if(R0){
      good = (v1===sOut && v2==='0' && v3===sOut && (!vm1||vm1==='') && (!vm2||vm2===''));
    }else if(none){
      good = ((v1===''||v1===undefined) && v2===sOut && (v3===''||v3===undefined) && (!vm1||vm1==='') && (!vm2||vm2===''));
    } else { // irrationnelles — par champ, vide => neutre
  const mark = (el, ok) => setTick(el, el.value ? (ok?'ok':'ko') : 'nu');
  mark(s1, v1===sOut);
  mark(z1, (!vm1) || vm1==='0');
  mark(s2, v2===sIn);
  mark(z2, (!vm2) || vm2==='0');
  mark(s3, v3===sOut);
}


    [s1,z1,s2,z2,s3].forEach(el=> setTick(el, good?'ok':'ko'));
  }
  ;[s1,z1,s2,z2,s3].forEach(el=> el && el.addEventListener('change', checkSignSlim));
  checkSignSlim();
}



/* ==== Branchement après chaque render ==== */
function wireLiveAll(){
  const host = document.querySelector('#host');
  if(!host) return;
  const st = JSON.parse(host.dataset.state||'{}');
  const id = host.dataset.active;

  if(id==='e1') wireLiveEx1(host, st);
  else if(id==='e2') wireLiveEx2(host, st);
  else if(id==='e3') wireLiveEx3(host, st);
  else if(id==='e4') wireLiveEx4(host, st);
}

function buildOne(){
  const id=$("#exo-select").value;
  const def=getDefById(id), host=$("#host");
  const st=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(st);
  def.render(host,st);

  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}

function checkAll(){
  scoreOK=0; scoreTot=0;
  const def=getDefById($("#exo-select").value),
        host=$("#host"),
        st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st);
  scoreOK=r.ok; scoreTot=r.total; updateScore();

  (function showTicksOnce(){
    const def = getDefById($("#exo-select").value);
    const host = $("#host");
    const st = JSON.parse(host.dataset.state||'{}');
    const id = def.id;

    if(id==='e1' || id==='e4'){
      host.querySelectorAll('tr[data-k] .pick').forEach(sel=>{
        const k   = sel.closest('tr').dataset.k;
        const want= st.mapping[k];
        const got = sel.value;
        if(!got){ setTick(sel,'nu'); return; }
        setTick(sel, got===want ? 'ok' : 'ko');
      });
      return;
    }

    if(id==='e2'){
      const a=st.a;
      const expect = a>0 ? {L:'↘',R:'↗',pos:'bot'} : {L:'↗',R:'↘',pos:'top'};
      const A=$('.alpha-q',host), B=$('.beta-q',host);
      const Ls=$('.d-L',host), Rs=$('.d-R',host);
      const tTop=$('.d-beta-top',host), tBot=$('.d-beta-bot',host);
      const alphaIn=$('.alpha-in',host);

      [A,B].forEach(el=>{ const v=valTrim(el); setTick(el, v? (v==='0'?'ok':'ko') : 'nu'); });
      [[Ls,expect.L],[Rs,expect.R]].forEach(([el,w])=>{
        const v=valTrim(el); setTick(el, v? (v===w?'ok':'ko') : 'nu');
      });
      const vTop=valTrim(tTop), vBot=valTrim(tBot);
      if(!vTop && !vBot){ setTick(tTop,'nu'); setTick(tBot,'nu'); }
      else{
        const ok = (expect.pos==='top') ? (vTop==='0' && !vBot) : (vBot==='0' && !vTop);
        setTick(tTop, ok?'ok':'ko'); setTick(tBot, ok?'ok':'ko');
      }
      const vA=valTrim(alphaIn); setTick(alphaIn, vA? (vA==='0'?'ok':'ko') : 'nu');
      return;
    }

    if(id==='e3'){
  const a=st.a, c=st.c, host=$("#host");
  const get = (sel)=> $(sel,host);
  const val = (el)=> (el?.value||'').replace(/\u2212/g,'-').trim();
  const almost = (x,y)=> Math.abs(Number(x)-Number(y))<1e-9;
  const sOut = a>0? '+' : '-';
  const sIn  = a>0? '-' : '+';
  const t = -c/a;
  const mode = (c===0) ? 'double0'
             : (t<0)   ? 'none'
             : (Math.abs(Math.sqrt(t)-Math.round(Math.sqrt(t)))<1e-10 ? 'two_int' : 'two_irr');

  // champs
  const tRoots=get('.roots'), sOpen=get('.open'), tPt=get('.pt'), tAxis=get('.axis');
  const Ls=get('.d-L'), Rs=get('.d-R'), tTop=get('.d-beta-top'), tBot=get('.d-beta-bot'), alphaIn=get('.alpha-in');
  const r1=get('#r1'), a0=get('#alpha'), r2=get('#r2');
  const s1=get('#s1'), z1=get('#z1'), s2=get('#s2'), z2=get('#z2'), s3=get('#s3');

  // helpers ticks
  const okEmpty = el => setTick(el,'ok');                 // ✓ même si vide (quand c'est attendu)
  const nuOr    = (el,cond)=> setTick(el, cond ? 'ok' : (val(el)?'ko':'nu'));

  // -------- Racines (champ liste) : inchangé (on garde ta logique actuelle) --------
(function(){
  const got = parseRootList(val(tRoots));

  const R = (function rootsAx2c(a,c){
    if(c===0) return [0];                  // racine double 0 → on attend [0]
    const t = -c/a; 
    if(t < 0) return [];                    // aucune racine → liste vide attendue
    const r = Math.sqrt(t);
    if(Math.abs(r - Math.round(r)) < 1e-9)  // racines entières ±r
      return [-Math.round(r), Math.round(r)];
    return ['irr', r];                      // racines ±√(p/q) (irrationnelles)
  })(a,c);

  if(got === null){ 
    setTick(tRoots, 'nu');                  // champ vide → neutre
    return;
  }

  let good = false;

  if(Array.isArray(R) && R.length === 0){
    // aucune racine : il faut que la liste soit vide (∅ / aucune)
    good = (got.length === 0);

  } else if(Array.isArray(R) && R[0] !== 'irr'){
    // racines entières (ou 0 double) : comparaison numérique stricte
    const W = [...new Set(R)].sort((x,y)=>x-y);
    const A = [...new Set(got)].sort((x,y)=>x-y);
    good = (A.length === W.length) && A.every((v,i)=>Math.abs(v - W[i]) < 1e-9);

  } else {
    // racines irrationnelles : il faut EXACTEMENT ±√(-c/a)
    const r = R[1]; // valeur positive attendue
    good = hasPlusMinusPair(got, r);
  }

  setTick(tRoots, good ? 'ok' : 'ko');
})();


(function(){
  // Ouverture
  const vO = val(sOpen);
  setTick(sOpen, vO ? (a>0 ? (vO==='vers le haut'?'ok':'ko') : (vO==='vers le bas'?'ok':'ko')) : 'nu');

  // Sommet — utilise le même parseur robuste
  const P = parseVertexPoint(val(tPt));
  if(!P){ setTick(tPt,'nu'); }
  else{
    const ok = Math.abs(P[0]-0) < 1e-9 && Math.abs(P[1]-c) < 1e-9;
    setTick(tPt, ok ? 'ok' : 'ko');
  }

  // Axe
  const vAx = val(tAxis).toLowerCase();
  setTick(tAxis, vAx ? ((vAx==='x=0'||vAx==='x=0.')?'ok':'ko') : 'nu');

  // Variations (inchangé)
  const expect = a>0 ? {L:'↘',R:'↗',pos:'top',beta:String(c)} : {L:'↗',R:'↘',pos:'top',beta:String(c)};
  [[Ls,expect.L],[Rs,expect.R]].forEach(([el,w])=>{
    const v=val(el); setTick(el, v? (v===w?'ok':'ko') : 'nu');
  });
  const vTop = val(tTop), vBot = val(tBot);
  if(!vTop && !vBot){ setTick(tTop,'nu'); setTick(tBot,'nu'); }
  else{
    const ok = (a>0 ? (vTop===String(c) && !vBot) : (vTop===String(c) && !vBot)); // ta logique actuelle
    setTick(tTop, ok?'ok':'ko'); setTick(tBot, ok?'ok':'ko');
  }
  const vA=val(alphaIn); setTick(alphaIn, vA? (vA==='0'?'ok':'ko') : 'nu');
})();


// --- Ligne du haut : r1 | α | r2 — miroir exact du live, y compris 0 racine
(function(){
  const r1 = $('#r1',host), a0 = $('#alpha',host), r2 = $('#r2',host);
  const v1 = valTrim(r1),   va = valTrim(a0),       v2 = valTrim(r2);

  const t = -c/a;
  const hasNone   = (t < 0);     // 0 racine
  const hasDouble = (c === 0);   // racine double en 0
  const hasTwo    = (!hasNone && !hasDouble);

  if(hasNone){
    // attendu : r1 vide ✓, α vide ✓ (ou "0" ✓), r2 vide ✓
    setTick(r1, v1 ? 'ko' : 'ok');
    setTick(r2, v2 ? 'ko' : 'ok');
    setTick(a0, va ? (va==='0' ? 'ok' : 'ko') : 'ok');
    return;
  }

  if(hasDouble){
    // attendu : r1 vide ✓, α=0 (vide → neutre), r2 vide ✓
    setTick(r1, v1 ? 'ko' : 'ok');
    setTick(r2, v2 ? 'ko' : 'ok');
    setTick(a0, va ? (va==='0' ? 'ok' : 'ko') : 'nu');
    return;
  }

  // deux racines (entières ou irrationnelles)
  const Rabs = Math.sqrt(t);
  const okL = v1 && isRootOK(parseRootValue(v1), Rabs, -1);
  const okR = v2 && isRootOK(parseRootValue(v2), Rabs, +1);
  setTick(r1, v1 ? (okL ? 'ok' : 'ko') : 'nu');
  setTick(r2, v2 ? (okR ? 'ok' : 'ko') : 'nu');

  // α vide ✓ seulement si r1 ET r2 sont corrects ; sinon neutre
  if(!va){
    setTick(a0, (okL && okR) ? 'ok' : 'nu');
  }else{
    setTick(a0, almost(parseRootVal(va),0) ? 'ok' : 'ko');
  }
})();




// --- Signes (ligne du bas) — ✓ vert sur vides attendus si au moins un champ du BAS est rempli
(function(){
  const s1 = $('#s1',host), z1 = $('#z1',host),
        s2 = $('#s2',host), z2 = $('#z2',host), s3 = $('#s3',host);

  const v1 = normSign($('#s1',host).value);
  const zL = normSign($('#z1',host).value);
  const v2 = normSign($('#s2',host).value);
  const zR = normSign($('#z2',host).value);
  const v3 = normSign($('#s3',host).value);

  const anyFilled = !!(v1 || zL || v2 || zR || v3);
  if(!anyFilled){ [s1,z1,s2,z2,s3].forEach(el=> setTick(el,'nu')); return; }

  const t = -c/a;
  const mode = (c===0) ? 'double0'
             : (t<0)   ? 'none'
             : (Math.abs(Math.sqrt(t)-Math.round(Math.sqrt(t)))<1e-10 ? 'two_int' : 'two_irr');

  const sOut = (a>0 ? '+' : '-');
  const sIn  = (a>0 ? '-' : '+');

  // helper : ✓ vert si vide attendu (et au moins un champ du bas est rempli)
  const okEmpty = (el) => { if(!valTrim(el)) { setTick(el,'ok'); return true; } return false; };

  if(mode==='two_int'){
    setTick(s1, v1 ? (v1===sOut?'ok':'ko') : 'nu');
    setTick(z1, zL ? (zL==='0'?'ok':'ko') : 'nu');
    setTick(s2, v2 ? (v2===sIn ?'ok':'ko') : 'nu');
    setTick(z2, zR ? (zR==='0'?'ok':'ko') : 'nu');
    setTick(s3, v3 ? (v3===sOut?'ok':'ko') : 'nu');
    const good = (v1===sOut && zL==='0' && v2===sIn && zR==='0' && v3===sOut);

  }else if(mode==='double0'){        // z1 et z2 doivent rester vides
    setTick(s1, v1 ? (v1===sOut?'ok':'ko') : 'nu');
    if(!okEmpty(z1)) setTick(z1,'ko');
    setTick(s2, v2 ? (v2==='0'?'ok':'ko') : 'nu');
    if(!okEmpty(z2)) setTick(z2,'ko');
    setTick(s3, v3 ? (v3===sOut?'ok':'ko') : 'nu');
    const good = (v1===sOut && v2==='0' && v3===sOut && !zL && !zR);

  }else if(mode==='none'){           // signe constant sOut au centre
    if(!okEmpty(s1)) setTick(s1, v1 ? (v1===sOut?'ok':'ko') : 'nu');
    if(!okEmpty(z1)) setTick(z1,'ko');
    setTick(s2, v2 ? (v2===sOut?'ok':'ko') : 'nu');
    if(!okEmpty(z2)) setTick(z2,'ko');
    if(!okEmpty(s3)) setTick(s3, v3 ? (v3===sOut?'ok':'ko') : 'nu');
    const good = (!zL && !zR && v2===sOut && (!v1 || v1===sOut) && (!v3 || v3===sOut));

  }else{ // two_irr — accepte avec ou sans zéros
    const withZ = (v1===sOut && zL==='0' && v2===sIn && zR==='0' && v3===sOut);
    const noZ   = (v1===sOut && !zL        && v2===sIn && !zR        && v3===sOut);

    setTick(s1, v1 ? (v1===sOut?'ok':'ko') : 'nu');
    if(!okEmpty(z1)) setTick(z1, zL==='0'?'ok':'ko');
    setTick(s2, v2 ? (v2===sIn?'ok':'ko') : 'nu');
    if(!okEmpty(z2)) setTick(z2, zR==='0'?'ok':'ko');
    setTick(s3, v3 ? (v3===sOut?'ok':'ko') : 'nu');

  }
})();



}


  })(); // ✅ <— ceci manquait
} // fin de checkAll()

function showSolution(){ const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const def=getDefById($("#exo-select").value), host=$("#host"); def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

/* PDF */
function cloneTableForPDF(root){
  const t = root.querySelector('.var') || root.querySelector('.sign-table') || root.querySelector('.table');
  if(!t) return '';
  const c=t.cloneNode(true);
  c.querySelectorAll('input,select,button').forEach(el=>{
    const mask=document.createElement('span'); mask.className='pdf-mask'; el.replaceWith(mask);
  });
  return '<div>'+c.outerHTML+'</div>';
}
function collectLeadAndTable(def, st){
  const tmp=document.createElement('div'); tmp.style.position='fixed'; tmp.style.left='-10000px'; document.body.appendChild(tmp);
  def.render(tmp, st);
  const tblHTML = cloneTableForPDF(tmp);
  const blocks=Array.from(tmp.children).filter(el=>el.tagName!=='TABLE');
  const lead=blocks.map(el=>el.outerHTML).join('');
  tmp.remove();
  return lead + (tblHTML?('<div class="step" style="margin-top:6px">'+tblHTML+'</div>'):'');}
function whenReady(cb){ const ok=()=>window.ExoPDF!==undefined; let t=0, i=setInterval(()=>{ if(ok()){clearInterval(i); cb();} else if((t+=100)>6000){clearInterval(i);} },100); }
const PDF_CSS = `<style>
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .mjx-container{white-space:normal !important}
  .mjx-math{overflow-wrap:anywhere;word-break:break-word}
  svg{width:560px;max-width:100%;height:auto}

/* === PDF : on IMPRIME les tableaux HTML, pas les \array LaTeX === */

/* Afficher normalement les tables HTML */
table.table, table.var, table.sign-table { 
  display: table !important;
}

/* Cacher les tableaux LaTeX rendus par MathJax (les \array) en PDF */
.mjx-container mjx-mtable { 
  display: none !important;
}

/* Confort impression */
.mjx-container, .mjx-container * { box-sizing: content-box !important; }
.mjx-container .mjx-math { overflow-wrap: normal !important; word-break: normal !important; }

/* Optionnel : version compacte des tableaux pour PDF */
.sign-table.half{
  font-size:.575rem;
  --zeroW:55px;
}
.sign-table.half th, .sign-table.half td{ padding:5px 7px; }
.sign-table.half .sel{ height:20px; min-width:42px; }
.sign-table.half .root{ min-width:55px; height:22px; font-size:.56rem; }
/* En PDF : on cache TOUTES les tables HTML interactives */
@media print{
  table.table, table.var, table.sign-table{
    display:none !important;
  }
}
/* En PDF, cacher les tableaux LaTeX rendus par MathJax (les \array) dans les solutions */
@media print{
  #res mjx-mtable { display: none !important; }
}

</style>`;


whenReady(function(){
  const sel = $("#exo-select");

  // 🔧 Remplir le sélecteur et brancher les boutons
  sel.innerHTML = REGISTRY
    .map((ex, idx) => `<option value="${ex.id}">${idx+1} — ${ex.title}</option>`)
    .join('');

  sel.onchange      = buildOne;
  $("#btn-new").onclick      = buildOne;
  $("#btn-check").onclick    = checkAll;
  $("#btn-solution").onclick = showSolution;
  $("#btn-reset").onclick    = resetAll;

  sel.value = REGISTRY[0].id;   // 'e1'
  buildOne();                   // afficher un exo au chargement

  // ⚠️ Rappel : en mode impression/PDF, le bloc .controls est caché par:
  // @media print { .controls { display:none !important; } }
  // Donc c'est normal de ne pas voir le sélecteur dans l'aperçu PDF.

  if (typeof ExoPDF !== 'undefined' && ExoPDF && ExoPDF.init) {
    ExoPDF.init({
      title: document.title,
      max: 40,
      mountAfterSelector: '.card.small',
      beforeGen(def, _st, ctx){ /* ... tel que dans ton code ... */ },

      // 2) Construire l’HTML à imprimer
    beforeRender(def, st, withSolutions){
  const host = document.createElement('div');
  host.id = 'pdf-host';
  host.style.position = 'fixed';
  host.style.left = '-200vw';
  document.body.appendChild(host);

  // 1) Rendu de l'exo
  if (def && typeof def.render === 'function'){
    def.render(host, st);
  }
  host.dataset.state = JSON.stringify(st || {});

  // 2) Si corrigé : fabriquer #res
  if (withSolutions && def && typeof def.solution === 'function'){
    try{ def.solution(host, st); }catch(_){}
  }

  // --- Utils ---
  function maskInteractive(root){
    root.querySelectorAll('input, select, button').forEach(el=>{
      const m=document.createElement('span'); m.className='pdf-mask'; el.replaceWith(m);
    });
  }
  function inlineTableStyles(root){
    root.querySelectorAll('table').forEach(table=>{
      const csT = getComputedStyle(table);
      table.style.borderCollapse = csT.borderCollapse;
      table.style.borderSpacing  = csT.borderSpacing;
      ['Top','Right','Bottom','Left'].forEach(side=>{
        table.style['border'+side] =
          csT['border'+side+'Width']+' '+csT['border'+side+'Style']+' '+csT['border'+side+'Color'];
      });
      table.querySelectorAll('th,td').forEach(td=>{
        const cs = getComputedStyle(td);
        ['Top','Right','Bottom','Left'].forEach(side=>{
          td.style['border'+side] =
            cs['border'+side+'Width']+' '+cs['border'+side+'Style']+' '+cs['border'+side+'Color'];
        });
        td.style.verticalAlign = cs.verticalAlign;
        td.style.textAlign     = cs.textAlign;
        td.style.padding       = cs.paddingTop+' '+cs.paddingRight+' '+cs.paddingBottom+' '+cs.paddingLeft;
      });
    });
  }
  // ⬇️ Retire uniquement les tableaux LaTeX (MathJax) des solutions
  function stripLaTeXArrays(root){
    // A) Si MathJax a déjà rendu : enlever les <mjx-mtable> (le bloc entier)
    root.querySelectorAll('mjx-mtable').forEach(m=>{
      const cont = m.closest('mjx-container') || m;
      cont.remove();
    });
    // B) Si MathJax n’a PAS encore rendu : enlever les \[ ... \begin{array} ... \end{array} ... \]
    root.querySelectorAll('.statement, .steps, #res').forEach(node=>{
      const html = node.innerHTML;
      const cleaned = html.replace(/\\\[[\s\S]*?\\begin\{array\}[\s\S]*?\\end\{array\}[\s\S]*?\\\]/g, '');
      if (cleaned !== html) node.innerHTML = cleaned;
    });
  }

  // =========================
  //         É N O N C É
  // =========================
  if (!withSolutions){
    if (def && (def.id === 'e2' || def.id === 'e3')){
      // Ex.2 & Ex.3 : uniquement les blocs offscreen
      const blocks = Array.from(host.querySelectorAll('.equ-offscreen'));
      const outHTML = blocks.length
        ? blocks.map(b => { const c=b.cloneNode(true); c.style.display='block'; return c.outerHTML; }).join('')
        : '<div></div>';
      host.remove();
      return outHTML;
    } else {
      // Ex.1 & Ex.4 : tout l’énoncé (courbes + tableaux), sans UI
      maskInteractive(host);
      inlineTableStyles(host);
      const outHTML = host.innerHTML;
      host.remove();
      return outHTML;
    }
  }

  // =========================
  //        C O R R I G É
  // =========================
  const res = host.querySelector('#res') || host;

  // retirer les tableaux LaTeX, garder le reste (texte, formules inline, etc.)
  stripLaTeXArrays(res);

  // forcer l’affichage des tableaux PDF réservés
  res.querySelectorAll('.pdf-only').forEach(el => { el.style.display = 'block'; });

  inlineTableStyles(res);

  const outHTML = res.outerHTML || res.innerHTML;
  host.remove();
  return outHTML;
}



      
    });
  }
});



})();

</script>
</body>
</html>
