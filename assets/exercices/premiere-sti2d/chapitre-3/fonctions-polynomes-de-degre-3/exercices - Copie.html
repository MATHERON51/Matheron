<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1STI2D – Application bilan (3ᵉ degré)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}

  /* —— Variations (3ᵉ degré) —— */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  /* x | -∞ | m1 | m2 | +∞ (4 « colonnes » pour f) */
  table.var tbody tr:first-child td:nth-child(3){border-bottom:none}
  table.var .thin td{border-top:none;border-left:none;border-right:none;padding-top:2px}
  table.var .gaprow td{border:none!important;height:8px;padding:0}

  /* —— Tableau de signes (3 racines) —— */
  .sign-table{
    width:auto;border:2px solid #000;border-collapse:separate;border-spacing:0;table-layout:fixed;
    --zeroW:120px;
  }
  .sign-table col.col-lbl{width:120px}
  .sign-table col.col-zero{width:var(--zeroW)}
  .sign-table col.col-int{width:140px}
  .sign-table th,.sign-table td{
    padding:10px 12px;text-align:center;vertical-align:middle;
    border-top:1px solid #000;border-bottom:1px solid #000;border-right:none;border-left:none;
  }
  .sign-table .lbl{font-weight:600;border-right:2px solid #000;white-space:nowrap}
  .sign-table .cap-left{ text-align:left; padding-left:8px; }
  .sign-table .cap-right{ text-align:right; padding-right:8px; }
  .sign-table .sel,.sign-table .root{
    width:var(--zeroW);height:40px;font-size:16px;padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;text-align:center;background:#fff
  }
  .sign-table .sel{appearance:none;text-align-last:center}

  /* ticks */
  .tick{display:inline-block;min-width:1.15em;text-align:center;margin-left:.35rem;font-weight:700}
  .tick.nu::after{content:''}
  .tick.ok::after{content:'✓';color:#11823b}
  .tick.ko::after{content:'✗';color:#b00020}

  .left-dev{display:flex;justify-content:space-between;align-items:baseline;gap:.5rem}
  .left-dev .fact-latex{white-space:nowrap}
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D — Application bilan (3ᵉ degré)</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Racines : liste ordonnée — ex. <code>-3;-1;2</code>.</li>
        <li>Inéquations : intervalles au format <code>]a;b[</code>, unions avec <code>∪</code>, infinis <code>-∞</code>, <code>+∞</code>.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script defer src="../../../../js/exo-pdf-kit.multiplicatif-latex.js"></script>
<script>
(function(){
'use strict';

/* ===== utils ===== */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s || !s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function valTrim(el){ return (el?.value||'').replace(/\u2212/g,'-').trim(); }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
// ——— Inéquations cubiques à 3 racines simples ———
function sort3(a,b,c){ const t=[a,b,c].sort((x,y)=>x-y); return {x1:t[0],x2:t[1],x3:t[2]}; }

// Chaînes attendues (forme officielle, avec variantes ',' au lieu de ';')
function expectedSetsCubic(a, r1, r2, r3, cmp){
  const {x1,x2,x3} = sort3(r1,r2,r3);
  const incl = (cmp==='≤' || cmp==='≥');

  function V(s){ return [s, s.replaceAll(';',',')]; }

  if(cmp==='<' || cmp==='≤'){           // f(x) < 0  /  ≤ 0
    if(a>0){
      return incl ? V(`]-∞;${x1}] ∪ [${x2};${x3}]`)
                  : V(`]-∞;${x1}[ ∪ ]${x2};${x3}[`);
    }else{
      return incl ? V(`[${x1};${x2}] ∪ [${x3};+∞[`)
                  : V(`]${x1};${x2}[ ∪ ]${x3};+∞[`);
    }
  }else{                                 // f(x) > 0  /  ≥ 0
    if(a>0){
      return incl ? V(`[${x1};${x2}] ∪ [${x3};+∞[`)
                  : V(`]${x1};${x2}[ ∪ ]${x3};+∞[`);
    }else{
      return incl ? V(`]-∞;${x1}] ∪ [${x2};${x3}]`)
                  : V(`]-∞;${x1}[ ∪ ]${x2};${x3}[`);
    }
  }
}

// Placeholder “exemple de forme attendue”
function ineqPlaceholderForCubic(st){
  // st.cmp, st.a, st.r1,r2,r3 supposés définis
  const [form] = expectedSetsCubic(st.a, st.r1, st.r2, st.r3, st.cmp);
  return form;
}

/* ——— affichages « propres » (jamais 1x, pas de (x−0)) ——— */
const UMINUS='−';
function coefText(k){ if(k===1) return ''; if(k===-1) return UMINUS; return String(k); }
function factorCore(r){ return r===0 ? 'x' : `x${r<0?'+':UMINUS}${Math.abs(r)}`; }
function factorText(r){ const core=factorCore(r); return core==='x'?'x':`(${core})`; }
function factorized3(a,r1,r2,r3){
  const aTxt=coefText(a);
  const f = [r1,r2,r3].map(factorText).join('');
  return `${aTxt}${f}`.replace(/\(x[−-]0\)/g,'x');
}
function poly3String(a,b,c,d){
  // f(x)=ax^3+bx^2+cx+d, sans 1x^... et sans 0-termes
  const p=(k,pow,tag)=>k===0?'':((k>0?'+ ':' '+UMINUS+' ') + (Math.abs(k)===1?tag:Math.abs(k)+tag));
  const head = a===1?'x^3':(a===-1?UMINUS+'x^3':a+'x^3');
  const t2=p(b,'x^2','x^2'), t1=p(c,'x','x'), t0=d===0?'':(d>0?'+ ':' '+UMINUS+' ')+Math.abs(d);
  return [head,t2,t1,t0].join(' ').replace(/^\+\s*/,'').replace(/\s+/g,' ').trim();
}
function coef(k){ return k===1?'':(k===-1?UMINUS:String(k)); }

/* ===== Variations 3ᵉ degré ===== */
function renderVariationTableCubic(host, a){
  // 3 segments : ↗ ↘ ↗ si a>0 ; inverse si a<0
  host.innerHTML = [
    '<div class="var-wrap"><table class="var">',
      '<thead>',
        '<tr><th>\\(x\\)</th><td>\\(−∞\\)</td><td style="text-align:center"><input class="crit1" type="text" placeholder="m₁"></td><td style="text-align:center"><input class="crit2" type="text" placeholder="m₂"></td><td>\\(+∞\\)</td></tr>',
      '</thead>',
      '<tbody>',
        '<tr>',
          '<th rowspan="3">\\(f\\)</th>',
          '<td class="bigsel" rowspan="3"><select class="var-L"><option></option><option>↗</option><option>↘</option></select></td>',
          '<td style="text-align:center"><input class="beta-top" type="text" placeholder="maximum local"></td>',
          '<td style="text-align:center"><input class="beta-top2" type="text" placeholder="minimum local"></td>',
          '<td class="bigsel" rowspan="3"><select class="var-R"><option></option><option>↗</option><option>↘</option></select></td>',
        '</tr>',
        '<tr class="gaprow"><td></td><td></td></tr>',
        '<tr class="thin">',
          '<td style="text-align:center"><small>en \\(x=m_1\\)</small></td>',
          '<td style="text-align:center"><small>en \\(x=m_2\\)</small></td>',
        '</tr>',
      '</tbody>',
    '</table></div>'
  ].join('');
}

/* ===== Tableau de signes (3 racines) ===== */
function buildSignTableHTML_cubic(st){
  const hasA = st.a!==1;
  function hdrRow(){
    return [
      '<tr>',
        '<th class="lbl">\\(x\\)</th>',
        '<td class="int cap-left">−∞</td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r1" class="root"><span class="tick"></span></div></td>',
        '<td class="int"></td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r2" class="root"><span class="tick"></span></div></td>',
        '<td class="int"></td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r3" class="root"><span class="tick"></span></div></td>',
        '<td class="int cap-right">+∞</td>',
      '</tr>'
    ].join('');
  }
  function lineA(){
    return [
      '<tr><th class="lbl">\\('+st.a+'\\)</th>',
      '<td class="int"><select id="A_L" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_M1" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_M2" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_R" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '</tr>'
    ].join('');
  }
  function lineFactor(label,id){
    return [
      '<tr><th class="lbl">\\('+label+'\\)</th>',
      `<td class="int"><select id="${id}_L" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_M1" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z2" class="sel"><option></option><option>0</option></select></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_M2" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z3" class="sel" ><option></option><option>0</option></select></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_R" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      '</tr>'
    ].join('');
  }
  function lineProduct(){
    return [
      '<tr><th class="lbl">\\(f(x)\\)</th>',
      '<td class="int"><select id="F_L" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z1" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_M1" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z2" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_M2" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z3" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_R" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '</tr>'
    ].join('');
  }
  const lab = r => (r===0?'x':`x${r<0?'+':UMINUS}${Math.abs(r)}`);
  return [
    '<table class="sign-table" aria-label="Tableau de signes (3 racines)">',
      '<colgroup>',
        '<col class="col-lbl">',
        '<col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int">',
      '</colgroup><tbody>',
      hdrRow(),
      (hasA? lineA():''),
      lineFactor(lab(st.r1),'R1'),
      lineFactor(lab(st.r2),'R2'),
      lineFactor(lab(st.r3),'R3'),
      lineProduct(),
      '</tbody>',
    '</table>'
  ].join('');
}
function buildSignTableHTML_cubic_solution(st){
  const U='−';
  const lab = r => (r===0 ? '\\(x\\)' : `\\(x${r<0?'+':U}${Math.abs(r)}\\)`);
  const sA = st.a>0?'+':'−';
  const sLeft  = st.a>0?'−':'+';
  const sRight = st.a>0?'+':'−';
  const sMid1  = (sLeft==='+'? '−':'+');
  const sMid2  = (sLeft==='+'? '+':'−');

  return `
  <div class="var-wrap">
    <table class="sign-table" aria-label="Tableau de signes détaillé (solution)">
      <colgroup>
        <col class="col-lbl">
        <col class="col-int"><col class="col-zero">
        <col class="col-int"><col class="col-zero">
        <col class="col-int"><col class="col-zero">
        <col class="col-int">
      </colgroup>
      <tbody>
        <tr>
          <th class="lbl">\\(x\\)</th>
          <td class="int cap-left">−∞</td>
          <td class="zero">\\(${st.r1}\\)</td>
          <td class="int"></td>
          <td class="zero">\\(${st.r2}\\)</td>
          <td class="int"></td>
          <td class="zero">\\(${st.r3}\\)</td>
          <td class="int cap-right">+∞</td>
        </tr>
        ${st.a!==1 ? `
        <tr>
          <th class="lbl">\\(${st.a}\\)</th>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td>
        </tr>` : ''}

        <tr>
          <th class="lbl">${lab(st.r1)}</th>
          <td class="int">−</td><td class="zero">0</td>
          <td class="int">+</td><td class="zero"></td>
          <td class="int">+</td><td class="zero"></td>
          <td class="int">+</td>
        </tr>
        <tr>
          <th class="lbl">${lab(st.r2)}</th>
          <td class="int">−</td><td class="zero"></td>
          <td class="int">−</td><td class="zero">0</td>
          <td class="int">+</td><td class="zero"></td>
          <td class="int">+</td>
        </tr>
        <tr>
          <th class="lbl">${lab(st.r3)}</th>
          <td class="int">−</td><td class="zero"></td>
          <td class="int">−</td><td class="zero"></td>
          <td class="int">−</td><td class="zero">0</td>
          <td class="int">+</td>
        </tr>

        <tr>
          <th class="lbl">\\(f(x)\\)</th>
          <td class="int">${sLeft}</td><td class="zero">0</td>
          <td class="int">${sMid1}</td><td class="zero">0</td>
          <td class="int">${sMid2}</td><td class="zero">0</td>
          <td class="int">${sRight}</td>
        </tr>
      </tbody>
    </table>
  </div>`;
}

// Normalise une chaîne pour comparer 2 lignes (suppression espaces, \big, virgules fines, etc.)
// Normalise une saisie pour comparaison "texte à texte"
// ----------- Normalisations ----------
function canonDev(s){
  return String(s||'')
    .replace(/\u2212|−/g,'-')
    .replace(/\\\(|\\\)/g,'')
    .replace(/\\big/g,'')
    .replace(/\\,/g,'')
    .replace(/([A-Za-z])²/g,'$1^2').replace(/([A-Za-z])³/g,'$1^3')
    .replace(/\s+/g,'')
    .replace(/^\((.*)\)$/,'$1');
}
// Pour détection de "produit écrit" et comptages
function normLight(s){
  return String(s||'')
    .replace(/\u2212|−/g,'-')
    .replace(/([A-Za-z])²/g,'$1^2').replace(/([A-Za-z])³/g,'$1^3')
    .replace(/\s+/g,'');
}
function countOcc(s, re){ const m = s.match(re); return m? m.length : 0; }

// ----------- Équivalence numérique sûre (mais pas seule) -----------
function normExprInput(s){
  return String(s||'')
    .replace(/\u2212|−/g,'-')
    .replace(/×|·|⋅/g,'*')
    .replace(/([0-9])\s*x/g,'$1*x')
    .replace(/x\s*([0-9])/g,'x*$1')
    .replace(/\)\s*\(/g,')*(')
    .replace(/([0-9x])\s*\(/g,'$1*(')
    .replace(/\)\s*([0-9x])/g,')*$1')
    .replace(/([A-Za-z])²/g,'$1^2').replace(/([A-Za-z])³/g,'$1^3')
    .replace(/\^/g,'**')
    .replace(/\s+/g,'');
}
function isExprSafe(e){
  return /^[0-9x+\-*/().^*]+$/.test(e.replace(/\*\*/g,'^'));
}
function evalExprAt(expr, x){
  const e = normExprInput(expr);
  if(!isExprSafe(e)) return NaN;
  try{ const f = new Function('x', 'return ('+e+');'); const v=f(x); return Number.isFinite(v)?v:NaN; }
  catch(_){ return NaN; }
}
function eqCubic(expr, a, r1, r2, r3){
  const pts = [-4,-3,-2,-1,0,1,2,3,4];
  for(const x of pts){
    const tgt = a*(x-r1)*(x-r2)*(x-r3);
    const val = evalExprAt(expr, x);
    if(!Number.isFinite(val) || Math.abs(val-tgt) > 1e-6) return false;
  }
  return true;
}
function isFxLoose(s){ return canonDev(s).toLowerCase()==='f(x)'; }

// ----------- Formes attendues par ligne -----------
function shapeFlags(expr){
  const raw = String(expr||'');
  const lite = normLight(raw);
  return {
    hasParens: /[()]/.test(raw),
    hasProductLook: /\)\s*\(/.test(raw) || /\)\*\(/.test(normExprInput(raw)), // …)(…
    hasX3: /x\^?3/.test(lite),
    x2count: countOcc(lite, /x\^?2/g),
    xcount:  countOcc(lite.replace(/x\^?2/g,''), /x(?!\^)/g) // "x" hors x^2/x^3
  };
}

// Renvoie la liste des parenthèses "facteurs" ( ( ... ) )
function factorGroups(expr){
  return (String(expr||'').match(/\([^()]*\)/g) || []);
}
// Un groupe ( ... ) est "linéaire" s'il contient x mais pas x^2, x^3, ...
function isLinearGroup(s){
  const t = String(s||'').replace(/\u2212|−/g,'-')
                         .replace(/([A-Za-z])²/g,'$1^2')
                         .replace(/([A-Za-z])³/g,'$1^3')
                         .replace(/\s+/g,'');
  return /x/.test(t) && !/x\^/.test(t);
}
// Produit de **trois facteurs linéaires** (ex: (-2x-6)(x+1)(x-4))
// Produit de trois facteurs linéaires :
//  - OK si ≥ 3 groupes ( … ) linéaires
//  - OU si ≥ 2 groupes linéaires + au moins un facteur x "nu"
function isTripleLinearProduct(expr){
  const raw = String(expr||'');

  // Tous les groupes "( … )"
  const groups = (raw.match(/\([^()]*\)/g) || []);

  // Un groupe est linéaire s'il contient x mais pas x^k (k≥2)
  const linGroups = groups.filter(g=>{
    const t = g.replace(/\u2212|−/g,'-')
               .replace(/([A-Za-z])²/g,'$1^2')
               .replace(/([A-Za-z])³/g,'$1^3')
               .replace(/\s+/g,'');
    return /x/.test(t) && !/x\^/.test(t);
  });

  // Squelette : remplace chaque "(…)" par "G", puis compte les x "nus"
  let skel = raw;
  groups.forEach(g => { skel = skel.replace(g, 'G'); });
  skel = skel.replace(/\s+|\u2212|−|\*/g,''); // sans espaces/−/*

  const bareX = (skel.match(/x(?!\^)/g) || []).length;

  return (linGroups.length >= 3) || (linGroups.length >= 2 && bareX >= 1);
}



// ====== Fabrique les lignes de développement (droite) + l’en-tête (gauche) ======
function makeDevRows_cubic(a, r1, r2, r3){
  const U='−';
  const coef = k => k===1 ? '' : (k===-1 ? U : String(k));
  const par  = r => r===0 ? 'x' : `\\big(x${r<0?'+':U}${Math.abs(r)}\\big)`;
  const aHead = coef(a) ? coef(a)+'\\,' : '';
  const head  = `${coef(a)}${par(r1)}${par(r2)}${par(r3)}`.replace(/\\big\(x[−-]0\\big\)/g,'x');

  const T = (k, tag) => k===0 ? '' : (k>0?' + ':' '+U+' ') + (Math.abs(k)===1 ? tag : Math.abs(k)+tag);

  // (x−r1)(x−r2) : S, P
  const S = r1 + r2, P = r1 * r2;
  const k1 = -r2, k2 = -r1;

  // lignes 1 & 2
  const l1 = `\\( ${aHead}\\big(${ ('x^2' + T(k1,'x') + T(k2,'x') + (P? (P>0?' + ':' '+U+' ')+Math.abs(P) : '')).trim() }\\big)\\,${par(r3)} \\)`;
  const l2 = `\\( ${aHead}\\big(${ ('x^2' + T(-S,'x') + (P? (P>0?' + ':' '+U+' ')+Math.abs(P) : '')).trim() }\\big)\\,${par(r3)} \\)`;

  // développement contre (x−r3) (6 termes), regroupement, distribution
  const cx2_r3 = -r3, cx2_S = -S, cx_Sr3 = S*r3, cx_P = P, cst = -P*r3;
  const six = ('x^3' + T(cx2_r3,'x^2') + T(cx2_S,'x^2') + T(cx_Sr3,'x') + T(cx_P,'x')
              + (cst? (cst>0?' + ':' '+U+' ')+Math.abs(cst):''))
              .replace(/^\+\s*/,'').trim();

  const B = -(r3+S), C = S*r3 + P, D = -P*r3;

  const grp = ('x^3' + T(B,'x^2') + T(C,'x') + (D? (D>0?' + ':' '+U+' ')+Math.abs(D) : ''))
              .trim();

  const dist = (
    (a===1 ? 'x^3' : (a===-1 ? U+'x^3' : a+'x^3'))
    + T(a*B,'x^2') + T(a*C,'x') + (a*D ? (a*D>0?' + ':' '+U+' ')+Math.abs(a*D) : '')
  ).replace(/^\+\s*/,'').trim();

  // a=1 => pas de parenthèses à partir de la 3e ligne
  const l3 = (a===1) ? `\\( ${six} \\)` : `\\( ${aHead}\\big(${six}\\big) \\)`;
  const l4 = (a===1) ? `\\( ${grp} \\)` : `\\( ${aHead}\\big(${grp}\\big) \\)`;
  const l5 = `\\( ${dist} \\)`;
  const l6 = `\\( f(x) \\)`;

  // empile en supprimant les doublons CONSÉCUTIFS
  const rows = [];
  const pushU = (s) => { if(!rows.length || canonDev(rows.at(-1)) !== canonDev(s)) rows.push(s); };
  [l1,l2,l3,l4,l5,l6].forEach(pushU);

  return { head: `\\( ${head} = \\)`, rows };   // rows = tableau des lignes de droite
}


function buildQ1TableHTML_cubic(a, r1, r2, r3){
  const dev = makeDevRows_cubic(a, r1, r2, r3);
  return [
    '<table style="border-collapse:collapse;width:auto;margin:.2rem 0">',
      '<colgroup><col style="width:auto"><col style="width:24px"><col style="width:auto"></colgroup>',
      '<tbody>',
        dev.rows.map((right,i) =>
          `<tr>
            <td style="border:none;padding:2px 8px 2px 0;text-align:left">${ i===0 ? dev.head : '' }</td>
            <td style="border:none;padding:2px 4px;text-align:center;font-weight:600">=</td>
            <td style="border:none;padding:2px 0 2px 8px;text-align:left">${right}</td>
          </tr>`
        ).join('')
      + '</tbody>',
    '</table>'
  ].join('');
}


// supprime tout (x−0) résiduel (avec − unicode ou tiret ASCII, avec/ sans \big)
function fixXminus0(root){
  const RE1 = /\(x\s*[−-]\s*0\)/g;                  // (x-0) → x
  const RE2 = /\\big\(x\s*[−-]\s*0\\big\)/g;         // \big(x-0\big) → x
  const RE3 = /x\s*[−-]\s*0(?=\s*=)/g;               // x-0 = ... → x = ...
  (root || document).querySelectorAll('#host, #res, .steps').forEach(el=>{
    el.innerHTML = el.innerHTML
      .replace(RE1,'x')
      .replace(RE2,'x')
      .replace(RE3,'x');
  });
}


/* ===== ÉNONCÉ / CORRECTION ===== */
const exo = {
  id:'bilan3d_rand',
  title:'Application bilan 3ᵉ degré',
  gen(){
    const A=[-3,-2,-1,1,2,3];
    const a=choice(A);
    let r1=rint(-5,5), r2=rint(-5,5), r3=rint(-5,5);
    while(new Set([r1,r2,r3]).size<3){ r1=rint(-5,5); r2=rint(-5,5); r3=rint(-5,5); }
    [r1,r2,r3]=[r1,r2,r3].sort((x,y)=>x-y);
    // f(x)=a(x-r1)(x-r2)(x-r3)= ax^3 + bx^2 + cx + d
    const b = -a*(r1+r2+r3);
    const c =  a*(r1*r2 + r1*r3 + r2*r3);
    const d = -a*(r1*r2*r3);
    // comparateur par défaut
    const cmp = '≤';
    return {a,b,c,d,r1,r2,r3,cmp};
  },

  render(host,st){
    const tex = `f(x)= ${poly3String(st.a,st.b,st.c,st.d)}`;
    const fact = factorized3(st.a,st.r1,st.r2,st.r3);
// … à l’intérieur de render(host, st)
const dev = makeDevRows_cubic(st.a, st.r1, st.r2, st.r3);
const devInputs = dev.rows
  .map((_,i)=>`<input class="fact" data-step="${i+1}" type="text" style="width:420px">`)
  .join('<br>');

const leftDev = `
  <div class="left-dev">
    <span class="lbl">Développement :</span>
    <span class="fact-latex">${dev.head}</span>
  </div>
`;

const rightDev = `<div class="dev-inputs">${devInputs}</div>`;


    host.innerHTML = [
      `<div>Soit la fonction définie sur ℝ par \\( ${tex} \\).</div>`,
      '<ol style="margin:.4rem 0 .2rem 1.1rem">',
        `<li>Montrer que \\(f(x)=${fact}\\).</li>`,
        `<li>Résoudre \\(f(x)=0\\).</li>`,
        '<li>Indiquer le sens de variations de \\(f\\) (sans se préoccuper des intervalles).</li>',
        `<li>
           a) Dresser le tableau de <em>signes</em> complet.<br>
           b) En déduire 
             \\( f(x) \\) 
             <select class="cmp" style="margin-left:.35rem">
               <option value="<">&lt; 0</option>
               <option value="≤" selected>≤ 0</option>
               <option value=">">&gt; 0</option>
               <option value="≥">≥ 0</option>
             </select>
             
           </li>`,
      '</ol>',

     `<table class="table tbl-main3">
  <colgroup>
    <col class="col-left">
    <col class="col-right">
  </colgroup>
  <thead>
    <tr><th>Élément</th><th>Réponse (à compléter)</th></tr>
  </thead>
  <tbody>
`,
          `<tr class="row-dev">
  <td>${leftDev}</td>
  <td>${rightDev}<div class="pdf-expand"></div></td>
</tr>
          <tr class="row-dev"><td>Équation \\(f(x)=0\\)<div class="pdf-expand"></td><td><input class="roots" type="text" style="width:260px" placeholder="-3;-1;2"></td></tr>
          <tr class="row-variations">
  <td>Variations</td>
  <td>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <select class="var-sel v1" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>↗</option>
        <option>↘</option>
      </select>
      <select class="var-sel v2" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>↗</option>
        <option>↘</option>
      </select>
      <select class="var-sel v3" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>↗</option>
        <option>↘</option>
      </select>
    </div>
  </td>
</tr>

		  
		  <tr><td>Inéquation : \\( f(x) \\) <span id="cmp-view">≤</span> \\( 0 \\)</td><td><input class="ineq" type="text" style="width:320px" placeholder=""></td></tr>
        </tbody>
      </table>`,



      '<div style="margin:.6rem 0 .2rem">Tableau de signes détaillé :</div>',
      '<div id="sign-host"></div>',

      '<div id="res" class="steps small"></div>'
    ].join('');

    $('#sign-host',host).innerHTML = buildSignTableHTML_cubic(st);

    // placeholder inéquation
    const cmpSel = $('.cmp',host);
    function ineqPlaceholderFor({a,r1,r2,r3,cmp}){
      // alternance parité 3 : signe de f = signe(a) à l’extérieur
      const I1=`]-∞;${r1}[`, I2=`]${r1};${r2}[`, I3=`]${r2};${r3}[`, I4=`]${r3};+∞[`;
      // signes: a, −a, a, −a sur I1..I4
      const s = (sgn)=> sgn>0?['<','≤'] : ['>','≥'];
      const wantNeg = (a>0? ['I2','I4'] : ['I1','I3']);
      const wantPos = (a>0? ['I1','I3'] : ['I2','I4']);
      if(cmp==='<')  return (wantNeg.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
      if(cmp==='>')  return (wantPos.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
      if(cmp==='≤'){ // inclut les racines
        const ne = (wantNeg.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
        return `${ne} ∪ {${r1};${r2};${r3}}`;
      }
      const po = (wantPos.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
      return `${po} ∪ {${r1};${r2};${r3}}`;
    }
function updateIneqUI(){
  st.cmp = cmpSel.value;
  host.dataset.state = JSON.stringify(st);
  $('#cmp-view',host).textContent = st.cmp;
  const ineqInput = $('.ineq',host);
  typesetAll(host);
}

    cmpSel.addEventListener('change', updateIneqUI);
    updateIneqUI();

    host.querySelectorAll('input,select').forEach(el=>ensureTickAfter(el));
    typesetAll(host);
  },

    correct(host, st){
    const get = sel => (host.querySelector(sel));
    const read = sel => (get(sel)?.value||'').trim().replace(/\u2212/g,'-');

    let ok=0, tot=0;

    // --- Correction Développement (mêmes lignes que la solution) ---
// --- Correction Développement : stricte par ligne, variantes autorisées ---
(function(){
  const els = Array.from(host.querySelectorAll('.fact'));
  if(!els.length) return;

  // même nombre d’inputs que de lignes de solution (dédup déjà gérée côté render)
  els.forEach((el, i)=>{
    const raw = (el.value||'').trim();
    if(!raw){ setTick(el,'nu'); return; }
    scoreTot++;

    const eqOK = eqCubic(raw, st.a, st.r1, st.r2, st.r3);
    const sh   = shapeFlags(raw);

    // Garde-fous communs : on refuse la forme factorisée partout
    // -> Sur les lignes 1–2, on n’accepte PAS de x^3 ; sur les 3–5 on EXIGE x^3.
    let formOK = false;
    if(i === 0){
  // L1 doit être un produit "quadratique × linéaire" OU
  // un produit de trois facteurs linéaires si a a été distribué dans le 1er facteur.
  const patternQL = (!sh.hasX3 && sh.hasParens && sh.hasProductLook && sh.x2count >= 1);
  const patternLLL = isTripleLinearProduct(raw);   // <-- NEW: (-2x-6)(x+1)(x-4) accepté
  formOK = (patternQL || patternLLL);
}
else if(i === 1){
      // L2 : idem L1 (ligne de regroupement) — on autorise les deux (selon le choix de l’élève)
      formOK = (!sh.hasX3 && sh.hasParens && sh.hasProductLook && sh.x2count >= 1);
    }else if(i === 2){
      // L3 : "6 termes" (ou presque) : il doit y avoir x^3 ET AU MOINS deux x^2
      // (si a=1, pas d’obligation de parenthèses ; si a≠1, on tolère a( … ))
      formOK = (sh.hasX3 && sh.x2count >= 2);
    }else if(i === 3){
      // L4 : cubique REGROUPÉE : x^3 présent et exactement 1 x^2
      // (avec ou sans a(…); si a=1, souvent identique à L5 → la dédup a déjà réduit le nb de lignes)
      formOK = (sh.hasX3 && sh.x2count === 1);
    }else if(i === 4){
      // L5 : cubique DÉVELOPPÉE (a distribué) : x^3 présent, 1 seul x^2, et pas de produit explicite
      // => pas de motif “)(” ; on tolère parenthèses englobantes inoffensives.
      formOK = (sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook);
    }else{
      // L6 (dernière) : f(x)
      formOK = isFxLoose(raw);
    }

    const good = (i===els.length-1) ? formOK : (eqOK && formOK);
    setTick(el, good ? 'ok' : 'ko');
    if(good) scoreOK++;
  });
})();



    // Racines : ordre libre ; ; ou , ; { }
    (function(){
      const el = $('.roots', host);
      const raw = (el?.value||'').trim();
      if(!raw) return;
      tot++;
      let s = raw.replace(/\s+/g,'').replace(/^S=/i,'').replace(/^[\{\(\[]/,'').replace(/[\}\)\]]$/,'');
      const parts = s.split(/[;,]/).filter(Boolean).map(Number).sort((x,y)=>x-y);
      const want  = [st.r1,st.r2,st.r3].slice().sort((x,y)=>x-y);
      const good = parts.length===3 && parts.every((v,i)=>v===want[i]);
      setTick(el, good?'ok':'ko'); if(good) ok++;
    })();

    // Variations : flèches extrêmes (qualitatif)
  // Variations : 3 sélecteurs ↗/↘ (qualitatif)
(function(){
  const s1 = $('.var-sel.v1', host),
        s2 = $('.var-sel.v2', host),
        s3 = $('.var-sel.v3', host);
  if(!s1 || !s2 || !s3) return;

  const any = [s1,s2,s3].some(e => (e.value||'').trim());
  if(!any) return;              // rien rempli → pas noté

  tot++;

  // Cubique : a>0 ⇒ ↗,↘,↗ ; a<0 ⇒ ↘,↗,↘
  const want = (st.a > 0) ? ['↗','↘','↗'] : ['↘','↗','↘'];
  const good = (s1.value===want[0] && s2.value===want[1] && s3.value===want[2]);

  [s1,s2,s3].forEach((el,i)=>{
    const v = (el.value||'').trim();
    setTick(el, v ? (v===want[i] ? 'ok' : 'ko') : 'nu');
  });

  if(good) ok++;
})();


    /* ====== Correction du tableau de signes (3 racines) ====== */
// entête (r1,r2,r3)
(function(){
  const r1 = Number(valTrim(get('#hdr_r1'))),
        r2 = Number(valTrim(get('#hdr_r2'))),
        r3 = Number(valTrim(get('#hdr_r3')));
  const filled = [get('#hdr_r1'), get('#hdr_r2'), get('#hdr_r3')].some(e => (e?.value||'').trim());
  if(!filled) return;
  tot++;
  const good = (r1===st.r1 && r2===st.r2 && r3===st.r3);
  [get('#hdr_r1'), get('#hdr_r2'), get('#hdr_r3')].forEach(e => setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();

// ligne 'a' si elle existe (signe constant)
(function(){
  const AL = get('#A_L'), AM1 = get('#A_M1'), AM2 = get('#A_M2'), AR = get('#A_R');
  if(!AL || !AM1 || !AM2 || !AR) return;               // ligne a absente si a==1
  const any = [AL,AM1,AM2,AR].some(e=>e.value);
  if(!any) return;
  tot++;
  const sA = (st.a>0?'+':'−');
  const good = (AL.value===sA && AM1.value===sA && AM2.value===sA && AR.value===sA);
  [AL,AM1,AM2,AR].forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();

// helpers pour lignes des facteurs
function gradeFactorRow(prefix, pattern){
  const L  = get(`#${prefix}_L`);
  const Z1 = get(`#${prefix}_Z`);
  const M1 = get(`#${prefix}_M1`);
  const Z2 = get(`#${prefix}_Z2`);
  const M2 = get(`#${prefix}_M2`);
  const Z3 = get(`#${prefix}_Z3`);
  const R  = get(`#${prefix}_R`);
  const els = [L,Z1,M1,Z2,M2,Z3,R].filter(Boolean);
  const any = els.some(e=>e.value);
  if(!any) return;
  tot++;
  const good =
    (!L  || L.value  === pattern.L)  &&
    (!Z1 || Z1.value === (pattern.Z1||'')) &&
    (!M1 || M1.value === pattern.M1) &&
    (!Z2 || Z2.value === (pattern.Z2||'')) &&
    (!M2 || M2.value === pattern.M2) &&
    (!Z3 || Z3.value === (pattern.Z3||'')) &&
    (!R  || R.value  === pattern.R);
  els.forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
}

// (x − r1) : [ − | 0 | + | + | + ]
gradeFactorRow('R1', { L:'−', Z1:'0', M1:'+', M2:'+', R:'+' });
// (x − r2) : [ − |   | − | 0 | + ]
gradeFactorRow('R2', { L:'−',       M1:'−', Z2:'0', M2:'+', R:'+' });
// (x − r3) : [ − |   |   |   | 0 | + ]
gradeFactorRow('R3', { L:'−',       M1:'−',         M2:'−', Z3:'0', R:'+' });

// ligne produit f(x) — degré impair ⇒ signes opposés à gauche/droite
(function(){
  const L  = get('#F_L'), Z1 = get('#F_Z1'), M1 = get('#F_M1'),
        Z2 = get('#F_Z2'), M2 = get('#F_M2'), Z3 = get('#F_Z3'), R = get('#F_R');
  const any = [L,Z1,M1,Z2,M2,Z3,R].some(e=>e?.value);
  if(!any) return;
  tot++;

  const sRight = (st.a>0?'+':'−');           // +∞
  const sLeft  = (st.a>0?'−':'+');           // −∞  (opposé car degré impair)
  const sMid1  = (sLeft==='+'? '−' : '+');   // alternance
  const sMid2  = (sLeft==='+'? '+' : '−');

  const good = (L.value===sLeft && Z1.value==='0' &&
                M1.value===sMid1 && Z2.value==='0' &&
                M2.value===sMid2 && Z3.value==='0' &&
                R.value===sRight);

  [L,Z1,M1,Z2,M2,Z3,R].forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();


   // 12) Inéquation (accepte -oo/+oo/oo, U/∪, () au lieu de [])
(function(){
  const el = $('.ineq', host);
  let raw = (el?.value || '');
  if(!raw.trim()) return;
  tot++;

  function normSet(s){
    s = String(s)
      .replace(/\u2212|−/g, '-')        // minus
      .replace(/\s+/g, '')
      .replace(/^[sS]=?/, '')           // enlève "S=" toléré
      .replace(/[()]/g, m => m==='(' ? '[' : ']')
      .replace(/[\u222aUu]/g, '∪')
      .replace(/-oo/gi,'-∞').replace(/\+oo/gi,'+∞')
      .replace(/(^|[^+\-])oo/gi, (_,$1)=> `${$1}+∞`)
      .replace(/(^|[^+\-])∞/g, (_,$1)=> `${$1}+∞`);
    return s;
  }

  const wants = expectedSetsCubic(st.a, st.r1, st.r2, st.r3, st.cmp).map(normSet);
  const got   = normSet(raw);
  const good  = wants.includes(got);

  setTick(el, good ? 'ok' : 'ko');
  if(good) ok++;
})();


    scoreOK=ok; scoreTot=tot; updateScore();
    return {ok, total:tot};
  },

  solution(host, st){
    const fact = factorized3(st.a,st.r1,st.r2,st.r3);
    const poly = poly3String(st.a,st.b,st.c,st.d);

    // 1) Développement — tableau 3 colonnes
    const q1 = buildQ1TableHTML_cubic(st.a, st.r1, st.r2, st.r3, st.b, st.c, st.d);

    // 2) Équation — chaque facteur = 0
    function eqFactorToZero3(r){ return r===0 ? 'x=0' : String.raw`x${r<0?'+':UMINUS}${Math.abs(r)}=0`; }
    const eq0 = [
      String.raw`$${coef(st.a)}(x${st.r1<0?'+':'−'}${Math.abs(st.r1)})(x${st.r2<0?'+':'−'}${Math.abs(st.r2)})(x${st.r3<0?'+':'−'}${Math.abs(st.r3)})=0$`,
      String.raw`$\iff ${eqFactorToZero3(st.r1)}\;\text{ ou }\;${eqFactorToZero3(st.r2)}\;\text{ ou }\;${eqFactorToZero3(st.r3)}$`,
      String.raw`$\iff x=${st.r1}\;\text{ ou }\;x=${st.r2}\;\text{ ou }\;x=${st.r3}$`,
      String.raw`$S=\{${st.r1}\;;\;${st.r2}\;;\;${st.r3}\}$`
    ].map(s=>`<div class="step">${s}</div>`).join('');

// 3) Variations — séquence attendue + justification par le signe de a
const varSeq = (st.a > 0) ? '↗, ↘, ↗' : '↘, ↗, ↘';

const varJustif = (st.a > 0)
  ? String.raw`Comme \(a>0\) et que le degré est impair, on a  l'alternance \( \text{↗ } , \text{↘ } , \text{↗  } \).`
  : String.raw`Comme \(a<0\) et que le degré est impair, on a l’alternance \( \text{↘  } , \text{↗ } , \text{↘ } \).`;

const varBlock = `
  <div class="step"><b>3) Variations :</b></div>
  <div class="step" >${varJustif}</div>
`;



    // 4) Tableau de signes — schéma LaTeX (en plus du tableau interactif)
    const sOut = (st.a>0?'+':'−'), sMid1=(st.a>0?'−':'+'), sMid2=(st.a>0?'+':'−');
    const signLatex = String.raw`\[
\begin{array}{c|ccccccc}
x&-\infty&${st.r1}&&${st.r2}&&${st.r3}&+\infty\\\hline
f(x)& ${sOut} & 0 & ${sMid1} & 0 & ${sMid2} & 0 & ${sOut}
\end{array}\]`;

    const {a,r1,r2,r3} = st;
  const {x1,x2,x3} = sort3(r1,r2,r3);
  const cmp = st.cmp;

  function texSet(a, r1, r2, r3, cmp){
    const [form] = expectedSetsCubic(a, r1, r2, r3, cmp);    // forme "officielle"
    return form.replaceAll(';','\\;;\\;');                   // un peu d’espace en TeX
  }

  const ineqLine = String.raw`$\,f(x)\,${cmp}\,0 \iff x \in ${texSet(a,r1,r2,r3,cmp)}\,$`;
  const setLine  = String.raw`$S = ${texSet(a,r1,r2,r3,cmp)}$`;

    // Tableau de signes détaillé (HTML) – réutilise celui de l'énoncé pour « montrer » la solution
const signDetailHTML = buildSignTableHTML_cubic_solution(st);

    $('#res',host).innerHTML = `
      <div class="steps">
        <div class="step"><b>1) Développer</b></div>
        ${q1}
      

        <div class="step"><b>2) Résoudre</b> \\(f(x)=0\\)</div>
        ${eq0}

    ${varBlock}

     

        <div class="step"><b>4a)  Tableau de signes</b></div>
        <div class="step">${signDetailHTML}</div>

    <div class="step"><b>4b) Inéquation :</b> ${ineqLine}</div>
     <div class="step" style="margin-left:2.2em">${setLine}</div>
      </div>`;
	  fixXminus0(host);
    typesetAll($('#res',host));
  },

  reset(host){ $('#res',host).textContent=''; }
};

/* ===== Registre & UI ===== */
const REGISTRY=[exo];
window.REGISTRY = REGISTRY;

// init PDF (optionnel, même mécanique que tes autres pages)
(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: '1STI2D – Application bilan (3ᵉ degré)',
      mountAfterSelector: '.card.small',
      leadByDefId: { 'bilan3d_rand': '' },
    });
  } else { setTimeout(waitExoPDF, 50); }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }
function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  scoreOK=0; scoreTot=0;
  const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st); scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){ const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const def=getDefById($("#exo-select").value), host=$("#host"); def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} — ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();
})();
</script>
</body>
</html>
