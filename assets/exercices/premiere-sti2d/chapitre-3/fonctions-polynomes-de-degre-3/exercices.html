<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1STI2D ‚Äì Application bilan (3·µâ degr√©)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}

  /* ‚Äî‚Äî Variations (3·µâ degr√©) ‚Äî‚Äî */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  /* x | -‚àû | m1 | m2 | +‚àû (4 ¬´ colonnes ¬ª pour f) */
  table.var tbody tr:first-child td:nth-child(3){border-bottom:none}
  table.var .thin td{border-top:none;border-left:none;border-right:none;padding-top:2px}
  table.var .gaprow td{border:none!important;height:8px;padding:0}

  /* ‚Äî‚Äî Tableau de signes (3 racines) ‚Äî‚Äî */
  .sign-table{
    width:auto;border:2px solid #000;border-collapse:separate;border-spacing:0;table-layout:fixed;
    --zeroW:120px;
  }
  .sign-table col.col-lbl{width:120px}
  .sign-table col.col-zero{width:var(--zeroW)}
  .sign-table col.col-int{width:140px}
  .sign-table th,.sign-table td{
    padding:10px 12px;text-align:center;vertical-align:middle;
    border-top:1px solid #000;border-bottom:1px solid #000;border-right:none;border-left:none;
  }
  .sign-table .lbl{font-weight:600;border-right:2px solid #000;white-space:nowrap}
  .sign-table .cap-left{ text-align:left; padding-left:8px; }
  .sign-table .cap-right{ text-align:right; padding-right:8px; }
  .sign-table .sel,.sign-table .root{
    width:var(--zeroW);height:40px;font-size:16px;padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;text-align:center;background:#fff
  }
  .sign-table .sel{appearance:none;text-align-last:center}

  /* ticks */
  .tick{display:inline-block;min-width:1.15em;text-align:center;margin-left:.35rem;font-weight:700}
  .tick.nu::after{content:''}
  .tick.ok::after{content:'‚úì';color:#11823b}
  .tick.ko::after{content:'‚úó';color:#b00020}

  .left-dev{display:flex;justify-content:space-between;align-items:baseline;gap:.5rem}
  .left-dev .fact-latex{white-space:nowrap}
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D ‚Äî Application bilan (3·µâ degr√©)</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Racines : liste ordonn√©e ‚Äî ex. <code>-3;-1;2</code>.</li>
        <li>In√©quations : intervalles au format <code>]a;b[</code>, unions avec <code>‚à™</code>, infinis <code>-‚àû</code>, <code>+‚àû</code>.</li>
        <li>Conseil pour le d√©veloppement : <br>
	Pour √™tre certain que la saisie soit acc√©pt√©e, il faut : </br>
	<ol><li>Laisser le coefficient \(a\) </li>
	<li>D√©velopper les deux premiers facteurs dans une nouvelle parenth√®se </li>
	<li>R√©duire cette parenth√®se</li>
	<li> D√©velopper cette parenth√®se avec le trois√®me facteur dans une nouvelle parenth√®se </li>
	<li>R√©duire cette parenth√®se</li>
	<li>Distribuer \(a\) avec cette parenth√®se</li></ol>
	</li>
	  </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script defer src="../../../../js/exo-pdf-kit.multiplicatif-latex.js"></script>
<script>
(function(){
'use strict';

/* ===== utils ===== */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s || !s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function valTrim(el){ return (el?.value||'').replace(/\u2212/g,'-').trim(); }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
// ‚Äî‚Äî‚Äî In√©quations cubiques √† 3 racines simples ‚Äî‚Äî‚Äî
function sort3(a,b,c){ const t=[a,b,c].sort((x,y)=>x-y); return {x1:t[0],x2:t[1],x3:t[2]}; }

// Cha√Ænes attendues (forme officielle, avec variantes ',' au lieu de ';')
function expectedSetsCubic(a, r1, r2, r3, cmp){
  const {x1,x2,x3} = sort3(r1,r2,r3);
  const incl = (cmp==='‚â§' || cmp==='‚â•');

  function V(s){ return [s, s.replaceAll(';',',')]; }

  if(cmp==='<' || cmp==='‚â§'){           // f(x) < 0  /  ‚â§ 0
    if(a>0){
      return incl ? V(`]-‚àû;${x1}] ‚à™ [${x2};${x3}]`)
                  : V(`]-‚àû;${x1}[ ‚à™ ]${x2};${x3}[`);
    }else{
      return incl ? V(`[${x1};${x2}] ‚à™ [${x3};+‚àû[`)
                  : V(`]${x1};${x2}[ ‚à™ ]${x3};+‚àû[`);
    }
  }else{                                 // f(x) > 0  /  ‚â• 0
    if(a>0){
      return incl ? V(`[${x1};${x2}] ‚à™ [${x3};+‚àû[`)
                  : V(`]${x1};${x2}[ ‚à™ ]${x3};+‚àû[`);
    }else{
      return incl ? V(`]-‚àû;${x1}] ‚à™ [${x2};${x3}]`)
                  : V(`]-‚àû;${x1}[ ‚à™ ]${x2};${x3}[`);
    }
  }
}

// Placeholder ‚Äúexemple de forme attendue‚Äù
function ineqPlaceholderForCubic(st){
  // st.cmp, st.a, st.r1,r2,r3 suppos√©s d√©finis
  const [form] = expectedSetsCubic(st.a, st.r1, st.r2, st.r3, st.cmp);
  return form;
}

/* ‚Äî‚Äî‚Äî affichages ¬´ propres ¬ª (jamais 1x, pas de (x‚àí0)) ‚Äî‚Äî‚Äî */
const UMINUS='‚àí';
function coefText(k){ if(k===1) return ''; if(k===-1) return UMINUS; return String(k); }
function factorCore(r){ return r===0 ? 'x' : `x${r<0?'+':UMINUS}${Math.abs(r)}`; }
function factorText(r){ const core=factorCore(r); return core==='x'?'x':`(${core})`; }
function factorized3(a,r1,r2,r3, order){
  const aTxt=coefText(a);
  const roots = order && order.length===3 ? order : [r1,r2,r3];
  const f = roots.map(factorText).join('');
  return `${aTxt}${f}`.replace(/\(x[‚àí-]0\)/g,'x');
}

function poly3String(a,b,c,d){
  // f(x)=ax^3+bx^2+cx+d, sans 1x^... et sans 0-termes
  const p=(k,pow,tag)=>k===0?'':((k>0?'+ ':' '+UMINUS+' ') + (Math.abs(k)===1?tag:Math.abs(k)+tag));
  const head = a===1?'x^3':(a===-1?UMINUS+'x^3':a+'x^3');
  const t2=p(b,'x^2','x^2'), t1=p(c,'x','x'), t0=d===0?'':(d>0?'+ ':' '+UMINUS+' ')+Math.abs(d);
  return [head,t2,t1,t0].join(' ').replace(/^\+\s*/,'').replace(/\s+/g,' ').trim();
}
function coef(k){ return k===1?'':(k===-1?UMINUS:String(k)); }

/* ===== Variations 3·µâ degr√© ===== */
function renderVariationTableCubic(host, a){
  // 3 segments : ‚Üó ‚Üò ‚Üó si a>0 ; inverse si a<0
  host.innerHTML = [
    '<div class="var-wrap"><table class="var">',
      '<thead>',
        '<tr><th>\\(x\\)</th><td>\\(‚àí‚àû\\)</td><td style="text-align:center"><input class="crit1" type="text" placeholder="m‚ÇÅ"></td><td style="text-align:center"><input class="crit2" type="text" placeholder="m‚ÇÇ"></td><td>\\(+‚àû\\)</td></tr>',
      '</thead>',
      '<tbody>',
        '<tr>',
          '<th rowspan="3">\\(f\\)</th>',
          '<td class="bigsel" rowspan="3"><select class="var-L"><option></option><option>‚Üó</option><option>‚Üò</option></select></td>',
          '<td style="text-align:center"><input class="beta-top" type="text" placeholder="maximum local"></td>',
          '<td style="text-align:center"><input class="beta-top2" type="text" placeholder="minimum local"></td>',
          '<td class="bigsel" rowspan="3"><select class="var-R"><option></option><option>‚Üó</option><option>‚Üò</option></select></td>',
        '</tr>',
        '<tr class="gaprow"><td></td><td></td></tr>',
        '<tr class="thin">',
          '<td style="text-align:center"><small>en \\(x=m_1\\)</small></td>',
          '<td style="text-align:center"><small>en \\(x=m_2\\)</small></td>',
        '</tr>',
      '</tbody>',
    '</table></div>'
  ].join('');
}

/* ===== Tableau de signes (3 racines) ===== */
function buildSignTableHTML_cubic(st){
  const hasA = st.a!==1;
  function hdrRow(){
    return [
      '<tr>',
        '<th class="lbl">\\(x\\)</th>',
        '<td class="int cap-left">‚àí‚àû</td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r1" class="root"><span class="tick"></span></div></td>',
        '<td class="int"></td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r2" class="root"><span class="tick"></span></div></td>',
        '<td class="int"></td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r3" class="root"><span class="tick"></span></div></td>',
        '<td class="int cap-right">+‚àû</td>',
      '</tr>'
    ].join('');
  }
  function lineA(){
    return [
      '<tr><th class="lbl">\\('+st.a+'\\)</th>',
      '<td class="int"><select id="A_L" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_M1" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_M2" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_R" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '</tr>'
    ].join('');
  }
  function lineFactor(label,id){
    return [
      '<tr><th class="lbl">\\('+label+'\\)</th>',
      `<td class="int"><select id="${id}_L" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_M1" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z2" class="sel"><option></option><option>0</option></select></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_M2" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z3" class="sel" ><option></option><option>0</option></select></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_R" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>`,
      '</tr>'
    ].join('');
  }
  function lineProduct(){
    return [
      '<tr><th class="lbl">\\(f(x)\\)</th>',
      '<td class="int"><select id="F_L" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z1" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_M1" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z2" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_M2" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z3" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_R" class="sel"><option></option><option>+</option><option>‚àí</option></select><span class="tick"></span></td>',
      '</tr>'
    ].join('');
  }
  const lab = r => (r===0?'x':`x${r<0?'+':UMINUS}${Math.abs(r)}`);
  return [
    '<table class="sign-table" aria-label="Tableau de signes (3 racines)">',
      '<colgroup>',
        '<col class="col-lbl">',
        '<col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int">',
      '</colgroup><tbody>',
      hdrRow(),
      (hasA? lineA():''),
        // APR√àS ‚Äî on respecte l‚Äôordre de la factorisation (st.fac)
  lineFactor(lab(st.fac[0]), 'R1'),
  lineFactor(lab(st.fac[1]), 'R2'),
  lineFactor(lab(st.fac[2]), 'R3'),

      lineProduct(),
      '</tbody>',
    '</table>'
  ].join('');
}
function buildSignTableHTML_cubic_solution(st){
  const U='‚àí';
  const lab = r => (r===0 ? '\\(x\\)' : `\\(x${r<0?'+':U}${Math.abs(r)}\\)`);
  const {x1,x2,x3} = sort3(st.r1, st.r2, st.r3);
  const posOf = r => (r===x1?1 : r===x2?2 : 3);     // position du z√©ro (colonne) pour ce facteur

  const sA = st.a>0?'+':'‚àí';
  const sRight = sA;                 // degr√© impair : signe √† +‚àû = signe(a)
  const sLeft  = (sA==='+')?'‚àí':'+'; // √† ‚àí‚àû = oppos√©
  const sMid1  = (sLeft==='+')?'‚àí':'+'; // alternance
  const sMid2  = (sLeft==='+')?'+':'‚àí';

  function factorRow(r){
    const k = posOf(r); // 1,2,3 ‚áí z√©ro en Z1/Z2/Z3
    // patrons par colonne : L | Z1 | M1 | Z2 | M2 | Z3 | R
    let L='‚àí', Z1='', M1='‚àí', Z2='', M2='‚àí', Z3='', R='+';
    if(k===1){ Z1='0'; M1='+'; M2='+'; R='+'; }
    if(k===2){        M1='‚àí'; Z2='0'; M2='+'; R='+'; }
    if(k===3){        M1='‚àí';        M2='‚àí'; Z3='0'; R='+'; }

    return `
      <tr>
        <th class="lbl">${lab(r)}</th>
        <td class="int">${L}</td><td class="zero">${Z1}</td>
        <td class="int">${M1}</td><td class="zero">${Z2}</td>
        <td class="int">${M2}</td><td class="zero">${Z3}</td>
        <td class="int">${R}</td>
      </tr>`;
  }

  return `
  <div class="var-wrap">
    <table class="sign-table" aria-label="Tableau de signes d√©taill√© (solution)">
      <colgroup>
        <col class="col-lbl">
        <col class="col-int"><col class="col-zero">
        <col class="col-int"><col class="col-zero">
        <col class="col-int"><col class="col-zero">
        <col class="col-int">
      </colgroup>
      <tbody>
        <tr>
          <th class="lbl">\\(x\\)</th>
          <td class="int cap-left">‚àí‚àû</td>
          <td class="zero">\\(${x1}\\)</td>
          <td class="int"></td>
          <td class="zero">\\(${x2}\\)</td>
          <td class="int"></td>
          <td class="zero">\\(${x3}\\)</td>
          <td class="int cap-right">+‚àû</td>
        </tr>
        ${st.a!==1 ? `
        <tr>
          <th class="lbl">\\(${st.a}\\)</th>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td>
        </tr>` : ''}

        ${ (st.fac && st.fac.length===3 ? st.fac : [st.r1,st.r2,st.r3]).map(factorRow).join('') }

        <tr>
          <th class="lbl">\\(f(x)\\)</th>
          <td class="int">${sLeft}</td><td class="zero">0</td>
          <td class="int">${sMid1}</td><td class="zero">0</td>
          <td class="int">${sMid2}</td><td class="zero">0</td>
          <td class="int">${sRight}</td>
        </tr>
      </tbody>
    </table>
  </div>`;
}


// Normalise une cha√Æne pour comparer 2 lignes (suppression espaces, \big, virgules fines, etc.)
// Normalise une saisie pour comparaison "texte √† texte"
// ----------- Normalisations ----------
function canonDev(s){
  return String(s||'')
    .replace(/\u2212|‚àí/g,'-')
    .replace(/\\\(|\\\)/g,'')
    .replace(/\\big/g,'')
    .replace(/\\,/g,'')
    .replace(/([A-Za-z])¬≤/g,'$1^2').replace(/([A-Za-z])¬≥/g,'$1^3')
    .replace(/\s+/g,'')
    .replace(/^\((.*)\)$/,'$1');
}
// Pour d√©tection de "produit √©crit" et comptages
function normLight(s){
  return String(s||'')
    .replace(/\u2212|‚àí/g,'-')
    .replace(/([A-Za-z])¬≤/g,'$1^2').replace(/([A-Za-z])¬≥/g,'$1^3')
    .replace(/\s+/g,'');
}
function countOcc(s, re){ const m = s.match(re); return m? m.length : 0; }

// ----------- √âquivalence num√©rique s√ªre (mais pas seule) -----------
function normExprInput(s){
  return String(s||'')
    .replace(/\u2212|‚àí/g,'-')
    .replace(/√ó|¬∑|‚ãÖ/g,'*')
    .replace(/([0-9])\s*x/g,'$1*x')
    .replace(/x\s*([0-9])/g,'x*$1')
    .replace(/\)\s*\(/g,')*(')
    .replace(/([0-9x])\s*\(/g,'$1*(')
    .replace(/\)\s*([0-9x])/g,')*$1')
    .replace(/([A-Za-z])¬≤/g,'$1^2').replace(/([A-Za-z])¬≥/g,'$1^3')
    .replace(/\^/g,'**')
    .replace(/\s+/g,'');
}
function isExprSafe(e){
  return /^[0-9x+\-*/().^*]+$/.test(e.replace(/\*\*/g,'^'));
}
function evalExprAt(expr, x){
  const e = normExprInput(expr);
  if(!isExprSafe(e)) return NaN;
  try{ const f = new Function('x', 'return ('+e+');'); const v=f(x); return Number.isFinite(v)?v:NaN; }
  catch(_){ return NaN; }
}
function eqCubic(expr, a, r1, r2, r3){
  const pts = [-4,-3,-2,-1,0,1,2,3,4];
  for(const x of pts){
    const tgt = a*(x-r1)*(x-r2)*(x-r3);
    const val = evalExprAt(expr, x);
    if(!Number.isFinite(val) || Math.abs(val-tgt) > 1e-6) return false;
  }
  return true;
}
function isFxLoose(s){ return canonDev(s).toLowerCase()==='f(x)'; }

// ----------- Formes attendues par ligne -----------
function shapeFlags(expr){
  const raw  = String(expr||'');
  const lite = normLight(raw);
  const tight = raw.replace(/\s+/g,'');

  const prodAny =
      /\)\s*\(/.test(tight)    // ‚Ä¶)(‚Ä¶
   || /\)\s*[0-9x]/.test(tight) // ‚Ä¶)x ou ‚Ä¶)2
   || /[0-9x]\s*\(/.test(tight); // x(‚Ä¶ ou 2(‚Ä¶

  return {
    hasParens: /[()]/.test(raw),
    hasProductLook: prodAny,
    hasX3: /x\^?3/.test(lite),
    x2count: (lite.match(/x\^?2/g)||[]).length,
    xcount:  (lite.replace(/x\^?2/g,'').match(/x(?!\^)/g)||[]).length
  };
}


// Renvoie la liste des parenth√®ses "facteurs" ( ( ... ) )
function factorGroups(expr){
  return (String(expr||'').match(/\([^()]*\)/g) || []);
}
// Un groupe ( ... ) est "lin√©aire" s'il contient x mais pas x^2, x^3, ...
function isLinearGroup(s){
  const t = String(s||'').replace(/\u2212|‚àí/g,'-')
                         .replace(/([A-Za-z])¬≤/g,'$1^2')
                         .replace(/([A-Za-z])¬≥/g,'$1^3')
                         .replace(/\s+/g,'');
  return /x/.test(t) && !/x\^/.test(t);
}
// Produit de **trois facteurs lin√©aires** (ex: (-2x-6)(x+1)(x-4))
// Produit de trois facteurs lin√©aires :
//  - OK si ‚â• 3 groupes ( ‚Ä¶ ) lin√©aires
//  - OU si ‚â• 2 groupes lin√©aires + au moins un facteur x "nu"
function isTripleLinearProduct(expr){
  const raw = String(expr||'');

  // Tous les groupes "( ‚Ä¶ )"
  const groups = (raw.match(/\([^()]*\)/g) || []);

  // Un groupe est lin√©aire s'il contient x mais pas x^k (k‚â•2)
  const linGroups = groups.filter(g=>{
    const t = g.replace(/\u2212|‚àí/g,'-')
               .replace(/([A-Za-z])¬≤/g,'$1^2')
               .replace(/([A-Za-z])¬≥/g,'$1^3')
               .replace(/\s+/g,'');
    return /x/.test(t) && !/x\^/.test(t);
  });

  // Squelette : remplace chaque "(‚Ä¶)" par "G", puis compte les x "nus"
  let skel = raw;
  groups.forEach(g => { skel = skel.replace(g, 'G'); });
  skel = skel.replace(/\s+|\u2212|‚àí|\*/g,''); // sans espaces/‚àí/*

  const bareX = (skel.match(/x(?!\^)/g) || []).length;

  return (linGroups.length >= 3) || (linGroups.length >= 2 && bareX >= 1);
}



// ====== Fabrique les lignes de d√©veloppement (droite) + l‚Äôen-t√™te (gauche) ======
function makeDevRows_cubic(a, r1, r2, r3, order){
  const U='‚àí';
  const coef = k => k===1 ? '' : (k===-1 ? U : String(k));
  const par  = r => r===0 ? 'x' : `\\big(x${r<0?'+':U}${Math.abs(r)}\\big)`;

  // ‚Üê ordre d‚Äôaffichage/d√©veloppement (ex: st.fac), sinon ordre tri√© par d√©faut
  const roots = (order && order.length===3) ? order.slice() : [r1,r2,r3];
  const [p1, p2, p3] = roots;

  const aHead = coef(a) ? coef(a)+'\\,' : '';
  const head  = `${coef(a)}${par(p1)}${par(p2)}${par(p3)}`.replace(/\\big\(x[‚àí-]0\\big\)/g,'x');
  const T = (k, tag) => k===0 ? '' : (k>0?' + ':' '+U+' ') + (Math.abs(k)===1 ? tag : Math.abs(k)+tag);

  // (x‚àíp1)(x‚àíp2) : S, P selon p1,p2 (pas r1,r2 !)
  const S = p1 + p2, P = p1 * p2;

  // L1 : regroupement ¬´ quadratique √ó lin√©aire ¬ª avant simplif
  const k1 = -p2, k2 = -p1;
  const quadRaw = ('x^2' + T(k1,'x') + T(k2,'x') + (P? (P>0?' + ':' '+U+' ')+Math.abs(P) : '')).trim();
  const l1 = `\\( ${aHead}\\big(${quadRaw}\\big)\\,${par(p3)} \\)`;

  // L2 : quadratique simplifi√©e (x^2 ‚àí Sx + P) √ó (x‚àíp3)
  const quad = ('x^2' + T(-S,'x') + (P? (P>0?' + ':' '+U+' ')+Math.abs(P) : '')).trim();
  const l2 = `\\( ${aHead}\\big(${quad}\\big)\\,${par(p3)} \\)`;

  // L3 : ¬´ 6 termes ¬ª avant regroupement
  const cx2_r3 = -p3, cx2_S = -S, cx_Sr3 = S*p3, cx_P = P, cst = -P*p3;
  const six = ('x^3' + T(cx2_r3,'x^2') + T(cx2_S,'x^2') + T(cx_Sr3,'x') + T(cx_P,'x')
              + (cst? (cst>0?' + ':' '+U+' ')+Math.abs(cst):''))
              .replace(/^\+\s*/,'').trim();

  // L4 : regroup√© dans la parenth√®se
  const B = -(p3+S), C = S*p3 + P, D = -P*p3;
  const grp = ('x^3' + T(B,'x^2') + T(C,'x') + (D? (D>0?' + ':' '+U+' ')+Math.abs(D) : ''))
              .trim();

  // L5 : distribution du coefficient a
  const dist = (
    (a===1 ? 'x^3' : (a===-1 ? U+'x^3' : a+'x^3'))
    + T(a*B,'x^2') + T(a*C,'x') + (a*D ? (a*D>0?' + ':' '+U+' ')+Math.abs(a*D) : '')
  ).replace(/^\+\s*/,'').trim();

  // a=1 ‚áí pas de parenth√®ses sur L3/L4
  const l3 = (a===1) ? `\\( ${six} \\)` : `\\( ${aHead}\\big(${six}\\big) \\)`;
  const l4 = (a===1) ? `\\( ${grp} \\)` : `\\( ${aHead}\\big(${grp}\\big) \\)`;
  const l5 = `\\( ${dist} \\)`;
  const l6 = `\\( f(x) \\)`;

  // empile en supprimant les doublons cons√©cutifs
  const rows = [];
  const pushU = (s) => { if(!rows.length || canonDev(rows.at(-1)) !== canonDev(s)) rows.push(s); };
  [l1,l2,l3,l4,l5,l6].forEach(pushU);

  return { head: `\\( ${head} = \\)`, rows };
}



function buildQ1TableHTML_cubic(a, r1, r2, r3, order){
  const dev = makeDevRows_cubic(a, r1, r2, r3, order);
  return [
    '<table style="border-collapse:collapse;width:auto;margin:.2rem 0">',
      '<colgroup><col style="width:auto"><col style="width:24px"><col style="width:auto"></colgroup>',
      '<tbody>',
        dev.rows.map((right,i) =>
          `<tr>
            <td style="border:none;padding:2px 8px 2px 0;text-align:left">${ i===0 ? dev.head : '' }</td>
            <td style="border:none;padding:2px 4px;text-align:center;font-weight:600">=</td>
            <td style="border:none;padding:2px 0 2px 8px;text-align:left">${right}</td>
          </tr>`
        ).join('')
      + '</tbody>',
    '</table>'
  ].join('');
}


// supprime tout (x‚àí0) r√©siduel (avec ‚àí unicode ou tiret ASCII, avec/ sans \big)
function fixXminus0(root){
  const RE1 = /\(x\s*[‚àí-]\s*0\)/g;                  // (x-0) ‚Üí x
  const RE2 = /\\big\(x\s*[‚àí-]\s*0\\big\)/g;         // \big(x-0\big) ‚Üí x
  const RE3 = /x\s*[‚àí-]\s*0(?=\s*=)/g;               // x-0 = ... ‚Üí x = ...
  (root || document).querySelectorAll('#host, #res, .steps').forEach(el=>{
    el.innerHTML = el.innerHTML
      .replace(RE1,'x')
      .replace(RE2,'x')
      .replace(RE3,'x');
  });
}
// utils (ajoute)
function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function factorOrder(r1,r2,r3){
  // renvoie un tableau [q1,q2,q3] : ordre d'affichage des facteurs
  const arr=[r1,r2,r3].slice();
  const hasZero = arr.includes(0);
  if(hasZero){
    const no0 = arr.filter(v=>v!==0);
    shuffleInPlace(no0);
    no0.push(0);              // x en dernier
    return no0;
  }else{
    shuffleInPlace(arr);
    return arr;
  }
}


/* ===== √âNONC√â / CORRECTION ===== */
const exo = {
  id:'bilan3d_rand',
  title:'Application bilan 3·µâ degr√©',
  gen(){
    const A=[-3,-2,-1,1,2,3];
    const a=choice(A);
    let r1=rint(-5,5), r2=rint(-5,5), r3=rint(-5,5);
    while(new Set([r1,r2,r3]).size<3){ r1=rint(-5,5); r2=rint(-5,5); r3=rint(-5,5); }
    [r1,r2,r3]=[r1,r2,r3].sort((x,y)=>x-y);
	const fac = factorOrder(r1,r2,r3);   // ordre pour l‚Äôaffichage factoris√©

    // f(x)=a(x-r1)(x-r2)(x-r3)= ax^3 + bx^2 + cx + d
    const b = -a*(r1+r2+r3);
    const c =  a*(r1*r2 + r1*r3 + r2*r3);
    const d = -a*(r1*r2*r3);
    // comparateur par d√©faut
// comparateur tir√© au sort
const cmp = choice(['<','‚â§','>','‚â•']);
return {a,b,c,d,r1,r2,r3,cmp, fac};  // ‚Üê on stocke aussi fac
  },

  render(host,st){
    const tex = `f(x)= ${poly3String(st.a,st.b,st.c,st.d)}`;
const fact = factorized3(st.a,st.r1,st.r2,st.r3, st.fac);
// ‚Ä¶ √† l‚Äôint√©rieur de render(host, st)
const dev = makeDevRows_cubic(st.a,st.r1,st.r2,st.r3, st.fac);
const devInputs = dev.rows
  .map((_,i)=>`<input class="fact" data-step="${i+1}" type="text" style="width:420px">`)
  .join('<br>');

const leftDev = `
  <div class="left-dev">
    <span class="lbl">D√©veloppement :
	<br>Vous pouvez laisser des saisies vides</span>
    <span class="fact-latex">${dev.head}</span>
  </div>
`;

const rightDev = `<div class="dev-inputs">${devInputs}</div>`;


    host.innerHTML = [
      `<div>Soit la fonction d√©finie sur ‚Ñù par \\( ${tex} \\).</div>`,
      '<ol style="margin:.4rem 0 .2rem 1.1rem">',
        `<li>Montrer que \\(f(x)=${fact}\\).</li>`,
        `<li>R√©soudre \\(f(x)=0\\).</li>`,
        '<li>Indiquer le sens de variations de \\(f\\) (sans se pr√©occuper des intervalles).</li>',
        `<li>
           a) Dresser le tableau de <em>signes</em> complet.<br>
           b) En d√©duire 
             \\( f(x) \\) 
             <select class="cmp" style="margin-left:.35rem">
  <option value="<">&lt; 0</option>
  <option value="‚â§">‚â§ 0</option>
  <option value=">">&gt; 0</option>
  <option value="‚â•">‚â• 0</option>
</select>
             
           </li>`,
      '</ol>',

     `<table class="table tbl-main3">
  <colgroup>
    <col class="col-left">
    <col class="col-right">
  </colgroup>
  <thead>
    <tr><th>√âl√©ment</th><th>R√©ponse (√† compl√©ter)</th></tr>
  </thead>
  <tbody>
`,
          `<tr class="row-dev">
  <td>${leftDev}</td>
  <td>${rightDev}<div class="pdf-expand"></div></td>
</tr>
          <tr class="row-dev"><td>√âquation \\(f(x)=0\\)<div class="pdf-expand"></td><td><input class="roots" type="text" style="width:260px" placeholder="-3;-1;2"></td></tr>
          <tr class="row-variations">
  <td>Variations</td>
  <td>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <select class="var-sel v1" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>‚Üó</option>
        <option>‚Üò</option>
      </select>
      <select class="var-sel v2" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>‚Üó</option>
        <option>‚Üò</option>
      </select>
      <select class="var-sel v3" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>‚Üó</option>
        <option>‚Üò</option>
      </select>
    </div>
  </td>
</tr>

		  
		  <tr><td>In√©quation : \\( f(x) \\) <span id="cmp-view">‚â§</span> \\( 0 \\)</td><td><input class="ineq" type="text" style="width:320px" placeholder=""></td></tr>
        </tbody>
      </table>`,



      '<div style="margin:.6rem 0 .2rem">Tableau de signes d√©taill√© :</div>',
      '<div id="sign-host"></div>',

      '<div id="res" class="steps small"></div>'
    ].join('');

    $('#sign-host',host).innerHTML = buildSignTableHTML_cubic(st);

    // placeholder in√©quation
    const cmpSel = $('.cmp',host);
	cmpSel.value = st.cmp;     // refl√®te le tirage ou la reprise d‚Äô√©tat
updateIneqUI();            // met √† jour l‚Äôaffichage et le state

    function ineqPlaceholderFor({a,r1,r2,r3,cmp}){
      // alternance parit√© 3 : signe de f = signe(a) √† l‚Äôext√©rieur
      const I1=`]-‚àû;${r1}[`, I2=`]${r1};${r2}[`, I3=`]${r2};${r3}[`, I4=`]${r3};+‚àû[`;
      // signes: a, ‚àía, a, ‚àía sur I1..I4
      const s = (sgn)=> sgn>0?['<','‚â§'] : ['>','‚â•'];
      const wantNeg = (a>0? ['I2','I4'] : ['I1','I3']);
      const wantPos = (a>0? ['I1','I3'] : ['I2','I4']);
      if(cmp==='<')  return (wantNeg.map(x=>({I1,I2,I3,I4}[x])).join(' ‚à™ '));
      if(cmp==='>')  return (wantPos.map(x=>({I1,I2,I3,I4}[x])).join(' ‚à™ '));
      if(cmp==='‚â§'){ // inclut les racines
        const ne = (wantNeg.map(x=>({I1,I2,I3,I4}[x])).join(' ‚à™ '));
        return `${ne} ‚à™ {${r1};${r2};${r3}}`;
      }
      const po = (wantPos.map(x=>({I1,I2,I3,I4}[x])).join(' ‚à™ '));
      return `${po} ‚à™ {${r1};${r2};${r3}}`;
    }
function updateIneqUI(){
  st.cmp = cmpSel.value;
  host.dataset.state = JSON.stringify(st);
  $('#cmp-view',host).textContent = st.cmp;
  const ineqInput = $('.ineq',host);
  typesetAll(host);
}

    cmpSel.addEventListener('change', updateIneqUI);
    updateIneqUI();

    host.querySelectorAll('input,select').forEach(el=>ensureTickAfter(el));
    typesetAll(host);
  },

    correct(host, st){
    const get = sel => (host.querySelector(sel));
    const read = sel => (get(sel)?.value||'').trim().replace(/\u2212/g,'-');

    let ok=0, tot=0;

    // --- Correction D√©veloppement (m√™mes lignes que la solution) ---
// --- Correction D√©veloppement : stricte par ligne, variantes autoris√©es ---
(function(){
  const els = Array.from(host.querySelectorAll('.fact'));
  if(!els.length) return;
const fam = {
  QL(expr){                // quadratique √ó lin√©aire (avec ou sans r√©duction)
    const sh = shapeFlags(expr);
    return !sh.hasX3 && sh.hasParens && sh.hasProductLook && sh.x2count >= 1;
  },
  SIX(expr){               // forme "six-termes" (x^3 pr√©sent + au moins 2 x^2)
    const sh = shapeFlags(expr);
    return sh.hasX3 && sh.x2count >= 2;
  },
  GROUP(expr){             // cubique regroup√©e (x^3 + Bx^2 + Cx + D)
    const sh = shapeFlags(expr);
    return sh.hasX3 && sh.x2count === 1;
  },
  DIST(expr){              // cubique enti√®rement distribu√©e (pas de produit explicite)
    const sh = shapeFlags(expr);
    return sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook;
  }
};

  // m√™me nombre d‚Äôinputs que de lignes de solution (d√©dup d√©j√† g√©r√©e c√¥t√© render)
 els.forEach((el, i)=>{
  const raw = (el.value||'').trim();
  if(!raw){ setTick(el,'nu'); return; }
  scoreTot++;

  const eqOK = eqCubic(raw, st.a, st.r1, st.r2, st.r3);
  const sh   = shapeFlags(raw);
const allowQL = (!sh.hasX3 && sh.hasParens && sh.hasProductLook && sh.x2count >= 1);

  // d√©tecteurs de "familles" de formes
  const isSix   = (sh.hasX3 && sh.x2count >= 2);                 // x^3 + ... + ... x^2 + ... x^2 + ...
  const isGroup = (sh.hasX3 && sh.x2count === 1);                // x^3 + Bx^2 + Cx + D  (avec ou sans a(‚Ä¶))
  const isDist  = (sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook); // compl√®tement distribu√©

  let formOK = false;

 if(i === 0){
  // L1 : quadratique √ó lin√©aire OU produit de 3 lin√©aires
  formOK = fam.QL(raw) || isTripleLinearProduct(raw);

} else if (i === 1){
  // L2 : accepter QL OU six-termes OU regroup√©e OU d√©j√† distribu√©e
  formOK = fam.QL(raw) || fam.SIX(raw) || fam.GROUP(raw) || fam.DIST(raw);
}else if(i === 3){
  // L4 : accepter "regroup√©e" OU "d√©j√† distribu√©e"
  const isGroup = (sh.hasX3 && sh.x2count === 1);
  const isDist  = (sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook);
  formOK = (isGroup || isDist);
} else if (i === els.length - 1){
  // Derni√®re ligne
  formOK = isFxLoose(raw);

} else {
  // L3‚Ä¶L(n-1) : six-termes OU regroup√©e OU distribu√©e (peu importe l‚Äôordre)
  formOK = fam.SIX(raw) || fam.GROUP(raw) || fam.DIST(raw);
}

const good = (i===els.length-1) ? formOK : (eqOK && formOK);


  setTick(el, good ? 'ok' : 'ko');
  if(good) scoreOK++;
});

})();



    // Racines : ordre libre ; ; ou , ; { }
    (function(){
      const el = $('.roots', host);
      const raw = (el?.value||'').trim();
      if(!raw) return;
      tot++;
      let s = raw.replace(/\s+/g,'').replace(/^S=/i,'').replace(/^[\{\(\[]/,'').replace(/[\}\)\]]$/,'');
      const parts = s.split(/[;,]/).filter(Boolean).map(Number).sort((x,y)=>x-y);
      const want  = [st.r1,st.r2,st.r3].slice().sort((x,y)=>x-y);
      const good = parts.length===3 && parts.every((v,i)=>v===want[i]);
      setTick(el, good?'ok':'ko'); if(good) ok++;
    })();

    // Variations : fl√®ches extr√™mes (qualitatif)
  // Variations : 3 s√©lecteurs ‚Üó/‚Üò (qualitatif)
(function(){
  const s1 = $('.var-sel.v1', host),
        s2 = $('.var-sel.v2', host),
        s3 = $('.var-sel.v3', host);
  if(!s1 || !s2 || !s3) return;

  const any = [s1,s2,s3].some(e => (e.value||'').trim());
  if(!any) return;              // rien rempli ‚Üí pas not√©

  tot++;

  // Cubique : a>0 ‚áí ‚Üó,‚Üò,‚Üó ; a<0 ‚áí ‚Üò,‚Üó,‚Üò
  const want = (st.a > 0) ? ['‚Üó','‚Üò','‚Üó'] : ['‚Üò','‚Üó','‚Üò'];
  const good = (s1.value===want[0] && s2.value===want[1] && s3.value===want[2]);

  [s1,s2,s3].forEach((el,i)=>{
    const v = (el.value||'').trim();
    setTick(el, v ? (v===want[i] ? 'ok' : 'ko') : 'nu');
  });

  if(good) ok++;
})();


    /* ====== Correction du tableau de signes (3 racines) ====== */
// ent√™te (r1,r2,r3)
(function(){
  const r1 = Number(valTrim(get('#hdr_r1'))),
        r2 = Number(valTrim(get('#hdr_r2'))),
        r3 = Number(valTrim(get('#hdr_r3')));
  const filled = [get('#hdr_r1'), get('#hdr_r2'), get('#hdr_r3')].some(e => (e?.value||'').trim());
  if(!filled) return;
  tot++;
  const good = (r1===st.r1 && r2===st.r2 && r3===st.r3);
  [get('#hdr_r1'), get('#hdr_r2'), get('#hdr_r3')].forEach(e => setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();

// ligne 'a' si elle existe (signe constant)
(function(){
  const AL = get('#A_L'), AM1 = get('#A_M1'), AM2 = get('#A_M2'), AR = get('#A_R');
  if(!AL || !AM1 || !AM2 || !AR) return;               // ligne a absente si a==1
  const any = [AL,AM1,AM2,AR].some(e=>e.value);
  if(!any) return;
  tot++;
  const sA = (st.a>0?'+':'‚àí');
  const good = (AL.value===sA && AM1.value===sA && AM2.value===sA && AR.value===sA);
  [AL,AM1,AM2,AR].forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();

// ‚Äî‚Äî‚Äî Correction des 3 lignes "facteur" : ordre libre ‚Äî‚Äî‚Äî
// R√®gle : une ligne facteur doit avoir exactement un '0' (sur Z1 ou Z2 ou Z3)
// et respecter les signes attendus autour de CE z√©ro.
// Z√©ro en Z1  ‚Üí [L='‚àí', Z1='0', M1='+', M2='+', R='+']
// Z√©ro en Z2  ‚Üí [L='‚àí',             M1='‚àí', Z2='0', M2='+', R='+']
// Z√©ro en Z3  ‚Üí [L='‚àí',                         M2='‚àí', Z3='0', R='+']
// ===== Correction des 3 lignes "facteur" ‚Äî strict : z√©ro √† la BONNE colonne =====
(function(){
  const get = sel => host.querySelector(sel);

  // positions des racines (colonnes 1,2,3) d'apr√®s st.r1<st.r2<st.r3
  const rootsSorted = [st.r1, st.r2, st.r3].slice().sort((a,b)=>a-b);
  const posOf = r => (r===rootsSorted[0]?1 : r===rootsSorted[1]?2 : 3);

  // ordre d‚Äôaffichage des lignes facteur (√©tiquettes) : st.fac si pr√©sent, sinon (r1,r2,r3)
  const fac = (st.fac && st.fac.length===3) ? st.fac.slice() : [st.r1, st.r2, st.r3];

  // mapping lignes ‚Üí racines
  const rows = [
    { id:'R1', r: fac[0] },
    { id:'R2', r: fac[1] },
    { id:'R3', r: fac[2] },
  ];

  function read(prefix){
    return {
      L:  get(`#${prefix}_L`),
      Z1: get(`#${prefix}_Z`),
      M1: get(`#${prefix}_M1`),
      Z2: get(`#${prefix}_Z2`),
      M2: get(`#${prefix}_M2`),
      Z3: get(`#${prefix}_Z3`),
      R:  get(`#${prefix}_R`)
    };
  }
  function expectedPatternFor(col){ // col = 1,2 ou 3 (position de la racine de CETTE ligne)
    if(col===1) return { L:'‚àí', Z1:'0', M1:'+',            M2:'+',            R:'+' };
    if(col===2) return { L:'‚àí',            M1:'‚àí', Z2:'0',  M2:'+',            R:'+' };
    return        { L:'‚àí',            M1:'‚àí',          M2:'‚àí', Z3:'0',        R:'+' };
  }

  let anyFilled=false, rowOKs=[];

  rows.forEach(({id,r})=>{
    const v = read(id);
    const filled = [v.L,v.Z1,v.M1,v.Z2,v.M2,v.Z3,v.R].some(e=>e && e.value);
    if(filled) anyFilled=true;

    // motif EXIG√â pour CETTE ligne (sa racine r √† SA colonne attendue)
    const kExp = posOf(r);
    const exp  = expectedPatternFor(kExp);

    // Ticks cellule par cellule : si rempli, doit matcher le motif exp
    let allOK = true;
    [['L','L'],['Z1','Z1'],['M1','M1'],['Z2','Z2'],['M2','M2'],['Z3','Z3'],['R','R']]
    .forEach(([key,ek])=>{
      const el = v[ek]; if(!el) return;
      const want = exp[key] || '';      // vide autoris√© si non exig√©
      const cur  = (el.value||'');
      if(!cur){ setTick(el,'nu'); return; }
      const good = (cur===want);
      setTick(el, good ? 'ok' : 'ko');
      if(!good) allOK=false;
    });

    rowOKs.push(filled ? allOK : true); // ligne vide ‚Üí non not√©e
  });

  if(!anyFilled) return;  // rien rempli ‚Üí pas not√©
  tot++;

  // Toutes les lignes remplies doivent √™tre correctes
  if(rowOKs.every(Boolean)) ok++;
})();





// ligne produit f(x) ‚Äî degr√© impair ‚áí signes oppos√©s √† gauche/droite
(function(){
  const L  = get('#F_L'), Z1 = get('#F_Z1'), M1 = get('#F_M1'),
        Z2 = get('#F_Z2'), M2 = get('#F_M2'), Z3 = get('#F_Z3'), R = get('#F_R');
  const any = [L,Z1,M1,Z2,M2,Z3,R].some(e=>e?.value);
  if(!any) return;
  tot++;

  const sRight = (st.a>0?'+':'‚àí');           // +‚àû
  const sLeft  = (st.a>0?'‚àí':'+');           // ‚àí‚àû  (oppos√© car degr√© impair)
  const sMid1  = (sLeft==='+'? '‚àí' : '+');   // alternance
  const sMid2  = (sLeft==='+'? '+' : '‚àí');

  const good = (L.value===sLeft && Z1.value==='0' &&
                M1.value===sMid1 && Z2.value==='0' &&
                M2.value===sMid2 && Z3.value==='0' &&
                R.value===sRight);

  [L,Z1,M1,Z2,M2,Z3,R].forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();


   // 12) In√©quation (accepte -oo/+oo/oo, U/‚à™, () au lieu de [])
(function(){
  const el = $('.ineq', host);
  let raw = (el?.value || '');
  if(!raw.trim()) return;
  tot++;

  function normSet(s){
    s = String(s)
      .replace(/\u2212|‚àí/g, '-')        // minus
      .replace(/\s+/g, '')
      .replace(/^[sS]=?/, '')           // enl√®ve "S=" tol√©r√©
      .replace(/[()]/g, m => m==='(' ? '[' : ']')
      .replace(/[\u222aUu]/g, '‚à™')
      .replace(/-oo/gi,'-‚àû').replace(/\+oo/gi,'+‚àû')
      .replace(/(^|[^+\-])oo/gi, (_,$1)=> `${$1}+‚àû`)
      .replace(/(^|[^+\-])‚àû/g, (_,$1)=> `${$1}+‚àû`);
    return s;
  }

  const wants = expectedSetsCubic(st.a, st.r1, st.r2, st.r3, st.cmp).map(normSet);
  const got   = normSet(raw);
  const good  = wants.includes(got);

  setTick(el, good ? 'ok' : 'ko');
  if(good) ok++;
})();


    scoreOK=ok; scoreTot=tot; updateScore();
    return {ok, total:tot};
  },

  solution(host, st){
const fact = factorized3(st.a,st.r1,st.r2,st.r3, st.fac);
    const poly = poly3String(st.a,st.b,st.c,st.d);

    // 1) D√©veloppement ‚Äî tableau 3 colonnes
const q1 = buildQ1TableHTML_cubic(st.a, st.r1, st.r2, st.r3, st.fac);

const facOrder = (st.fac && st.fac.length===3) ? st.fac : [st.r1, st.r2, st.r3];

function eqFactorToZero3(r){ return r===0 ? 'x=0' : String.raw`x${r<0?'+':UMINUS}${Math.abs(r)}=0`; }

const eq0 = [
  // 1) √©criture factoris√©e = 0
  `$${coef(st.a)}${facOrder.map(r=>`(x${r<0?'+':UMINUS}${Math.abs(r)})`).join('')}=0$`,
  // 2) √©quivalences (inline -> align√©es √† gauche)
  `$\\iff ${eqFactorToZero3(facOrder[0])}\\;\\text{ ou }\\;${eqFactorToZero3(facOrder[1])}\\;\\text{ ou }\\;${eqFactorToZero3(facOrder[2])}$`,
  `$\\iff x=${facOrder[0]}\\;\\text{ ou }\\;x=${facOrder[1]}\\;\\text{ ou }\\;x=${facOrder[2]}$`,
  `$S=\\{${[st.r1,st.r2,st.r3].join('\\;;\\;')}\\}$`
].map(s=>`<div class="step">${s}</div>`).join('');



// 3) Variations ‚Äî s√©quence attendue + justification par le signe de a
const varSeq = (st.a > 0) ? '‚Üó, ‚Üò, ‚Üó' : '‚Üò, ‚Üó, ‚Üò';

const varJustif = (st.a > 0)
  ? String.raw`Comme \(a>0\) et que le degr√© est impair, on a  l'alternance \( \text{‚Üó } , \text{‚Üò } , \text{‚Üó  } \).`
  : String.raw`Comme \(a<0\) et que le degr√© est impair, on a l‚Äôalternance \( \text{‚Üò  } , \text{‚Üó } , \text{‚Üò } \).`;

const varBlock = `
  <div class="step"><b>3) Variations :</b></div>
  <div class="step" >${varJustif}</div>
`;



    // 4) Tableau de signes ‚Äî sch√©ma LaTeX (en plus du tableau interactif)
    const sOut = (st.a>0?'+':'‚àí'), sMid1=(st.a>0?'‚àí':'+'), sMid2=(st.a>0?'+':'‚àí');
    const signLatex = String.raw`\[
\begin{array}{c|ccccccc}
x&-\infty&${st.r1}&&${st.r2}&&${st.r3}&+\infty\\\hline
f(x)& ${sOut} & 0 & ${sMid1} & 0 & ${sMid2} & 0 & ${sOut}
\end{array}\]`;

    const {a,r1,r2,r3} = st;
  const {x1,x2,x3} = sort3(r1,r2,r3);
  const cmp = st.cmp;

  function texSet(a, r1, r2, r3, cmp){
    const [form] = expectedSetsCubic(a, r1, r2, r3, cmp);    // forme "officielle"
    return form.replaceAll(';','\\;;\\;');                   // un peu d‚Äôespace en TeX
  }

  const ineqLine = String.raw`$\,f(x)\,${cmp}\,0 \iff x \in ${texSet(a,r1,r2,r3,cmp)}\,$`;
  const setLine  = String.raw`$S = ${texSet(a,r1,r2,r3,cmp)}$`;

    // Tableau de signes d√©taill√© (HTML) ‚Äì r√©utilise celui de l'√©nonc√© pour ¬´ montrer ¬ª la solution
const signDetailHTML = buildSignTableHTML_cubic_solution(st);

    $('#res',host).innerHTML = `
      <div class="steps">
        <div class="step"><b>1) D√©velopper</b></div>
        ${q1}
      

        <div class="step"><b>2) R√©soudre</b> \\(f(x)=0\\)</div>
        ${eq0}

    ${varBlock}

     

        <div class="step"><b>4a)  Tableau de signes</b></div>
        <div class="step">${signDetailHTML}</div>

    <div class="step"><b>4b) In√©quation :</b> ${ineqLine}</div>
     <div class="step" style="margin-left:2.2em">${setLine}</div>
      </div>`;
	  fixXminus0(host);
    typesetAll($('#res',host));
  },

  reset(host){ $('#res',host).textContent=''; }
};

/* ===== Registre & UI ===== */
const REGISTRY=[exo];
window.REGISTRY = REGISTRY;

// init PDF (optionnel, m√™me m√©canique que tes autres pages)
(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: '1STI2D ‚Äì Application bilan (3·µâ degr√©)',
      mountAfterSelector: '.card.small',
      leadByDefId: { 'bilan3d_rand': '' },
    });
  } else { setTimeout(waitExoPDF, 50); }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }
function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  scoreOK=0; scoreTot=0;
  const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st); scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){ const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const def=getDefById($("#exo-select").value), host=$("#host"); def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();
})();
</script>
</body>
</html>
