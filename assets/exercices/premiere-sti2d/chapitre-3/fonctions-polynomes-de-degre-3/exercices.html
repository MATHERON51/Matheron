<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1STI2D – Application bilan (3ᵉ degré)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}

  /* —— Variations (3ᵉ degré) —— */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  /* x | -∞ | m1 | m2 | +∞ (4 « colonnes » pour f) */
  table.var tbody tr:first-child td:nth-child(3){border-bottom:none}
  table.var .thin td{border-top:none;border-left:none;border-right:none;padding-top:2px}
  table.var .gaprow td{border:none!important;height:8px;padding:0}

  /* —— Tableau de signes (3 racines) —— */
  .sign-table{
    width:auto;border:2px solid #000;border-collapse:separate;border-spacing:0;table-layout:fixed;
    --zeroW:120px;
  }
  .sign-table col.col-lbl{width:120px}
  .sign-table col.col-zero{width:var(--zeroW)}
  .sign-table col.col-int{width:140px}
  .sign-table th,.sign-table td{
    padding:10px 12px;text-align:center;vertical-align:middle;
    border-top:1px solid #000;border-bottom:1px solid #000;border-right:none;border-left:none;
  }
  .sign-table .lbl{font-weight:600;border-right:2px solid #000;white-space:nowrap}
  .sign-table .cap-left{ text-align:left; padding-left:8px; }
  .sign-table .cap-right{ text-align:right; padding-right:8px; }
  .sign-table .sel,.sign-table .root{
    width:var(--zeroW);height:40px;font-size:16px;padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;text-align:center;background:#fff
  }
  .sign-table .sel{appearance:none;text-align-last:center}

  /* ticks */
  .tick{display:inline-block;min-width:1.15em;text-align:center;margin-left:.35rem;font-weight:700}
  .tick.nu::after{content:''}
  .tick.ok::after{content:'✓';color:#11823b}
  .tick.ko::after{content:'✗';color:#b00020}

  .left-dev{display:flex;justify-content:space-between;align-items:baseline;gap:.5rem}
  .left-dev .fact-latex{white-space:nowrap}
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">1STI2D — Application bilan (3ᵉ degré)</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Racines : liste ordonnée — ex. <code>-3;-1;2</code>.</li>
        <li>Inéquations : intervalles au format <code>]a;b[</code>, unions avec <code>∪</code>, infinis <code>-∞</code>, <code>+∞</code>.</li>
        <li>Conseil pour le développement : <br>
	Pour être certain que la saisie soit accéptée, il faut : </br>
	<ol><li>Laisser le coefficient \(a\) </li>
	<li>Développer les deux premiers facteurs dans une nouvelle parenthèse </li>
	<li>Réduire cette parenthèse</li>
	<li> Développer cette parenthèse avec le troisème facteur dans une nouvelle parenthèse </li>
	<li>Réduire cette parenthèse</li>
	<li>Distribuer \(a\) avec cette parenthèse</li></ol>
	</li>
	  </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script defer src="../../../../js/exo-pdf-kit.multiplicatif-latex.js"></script>
<script>
(function(){
'use strict';

/* ===== utils ===== */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s || !s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function valTrim(el){ return (el?.value||'').replace(/\u2212/g,'-').trim(); }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
// ——— Inéquations cubiques à 3 racines simples ———
function sort3(a,b,c){ const t=[a,b,c].sort((x,y)=>x-y); return {x1:t[0],x2:t[1],x3:t[2]}; }

// Chaînes attendues (forme officielle, avec variantes ',' au lieu de ';')
function expectedSetsCubic(a, r1, r2, r3, cmp){
  const {x1,x2,x3} = sort3(r1,r2,r3);
  const incl = (cmp==='≤' || cmp==='≥');

  function V(s){ return [s, s.replaceAll(';',',')]; }

  if(cmp==='<' || cmp==='≤'){           // f(x) < 0  /  ≤ 0
    if(a>0){
      return incl ? V(`]-∞;${x1}] ∪ [${x2};${x3}]`)
                  : V(`]-∞;${x1}[ ∪ ]${x2};${x3}[`);
    }else{
      return incl ? V(`[${x1};${x2}] ∪ [${x3};+∞[`)
                  : V(`]${x1};${x2}[ ∪ ]${x3};+∞[`);
    }
  }else{                                 // f(x) > 0  /  ≥ 0
    if(a>0){
      return incl ? V(`[${x1};${x2}] ∪ [${x3};+∞[`)
                  : V(`]${x1};${x2}[ ∪ ]${x3};+∞[`);
    }else{
      return incl ? V(`]-∞;${x1}] ∪ [${x2};${x3}]`)
                  : V(`]-∞;${x1}[ ∪ ]${x2};${x3}[`);
    }
  }
}

// Placeholder “exemple de forme attendue”
function ineqPlaceholderForCubic(st){
  // st.cmp, st.a, st.r1,r2,r3 supposés définis
  const [form] = expectedSetsCubic(st.a, st.r1, st.r2, st.r3, st.cmp);
  return form;
}

/* ——— affichages « propres » (jamais 1x, pas de (x−0)) ——— */
const UMINUS='−';
function coefText(k){ if(k===1) return ''; if(k===-1) return UMINUS; return String(k); }
function factorCore(r){ return r===0 ? 'x' : `x${r<0?'+':UMINUS}${Math.abs(r)}`; }
function factorText(r){ const core=factorCore(r); return core==='x'?'x':`(${core})`; }
function factorized3(a,r1,r2,r3, order){
  const aTxt=coefText(a);
  const roots = order && order.length===3 ? order : [r1,r2,r3];
  const f = roots.map(factorText).join('');
  return `${aTxt}${f}`.replace(/\(x[−-]0\)/g,'x');
}

function poly3String(a,b,c,d){
  // f(x)=ax^3+bx^2+cx+d, sans 1x^... et sans 0-termes
  const p=(k,pow,tag)=>k===0?'':((k>0?'+ ':' '+UMINUS+' ') + (Math.abs(k)===1?tag:Math.abs(k)+tag));
  const head = a===1?'x^3':(a===-1?UMINUS+'x^3':a+'x^3');
  const t2=p(b,'x^2','x^2'), t1=p(c,'x','x'), t0=d===0?'':(d>0?'+ ':' '+UMINUS+' ')+Math.abs(d);
  return [head,t2,t1,t0].join(' ').replace(/^\+\s*/,'').replace(/\s+/g,' ').trim();
}
function coef(k){ return k===1?'':(k===-1?UMINUS:String(k)); }

/* ===== Variations 3ᵉ degré ===== */
function renderVariationTableCubic(host, a){
  // 3 segments : ↗ ↘ ↗ si a>0 ; inverse si a<0
  host.innerHTML = [
    '<div class="var-wrap"><table class="var">',
      '<thead>',
        '<tr><th>\\(x\\)</th><td>\\(−∞\\)</td><td style="text-align:center"><input class="crit1" type="text" placeholder="m₁"></td><td style="text-align:center"><input class="crit2" type="text" placeholder="m₂"></td><td>\\(+∞\\)</td></tr>',
      '</thead>',
      '<tbody>',
        '<tr>',
          '<th rowspan="3">\\(f\\)</th>',
          '<td class="bigsel" rowspan="3"><select class="var-L"><option></option><option>↗</option><option>↘</option></select></td>',
          '<td style="text-align:center"><input class="beta-top" type="text" placeholder="maximum local"></td>',
          '<td style="text-align:center"><input class="beta-top2" type="text" placeholder="minimum local"></td>',
          '<td class="bigsel" rowspan="3"><select class="var-R"><option></option><option>↗</option><option>↘</option></select></td>',
        '</tr>',
        '<tr class="gaprow"><td></td><td></td></tr>',
        '<tr class="thin">',
          '<td style="text-align:center"><small>en \\(x=m_1\\)</small></td>',
          '<td style="text-align:center"><small>en \\(x=m_2\\)</small></td>',
        '</tr>',
      '</tbody>',
    '</table></div>'
  ].join('');
}

/* ===== Tableau de signes (3 racines) ===== */
function buildSignTableHTML_cubic(st){
  const hasA = st.a!==1;
  function hdrRow(){
    return [
      '<tr>',
        '<th class="lbl">\\(x\\)</th>',
        '<td class="int cap-left">−∞</td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r1" class="root"><span class="tick"></span></div></td>',
        '<td class="int"></td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r2" class="root"><span class="tick"></span></div></td>',
        '<td class="int"></td>',
        '<td class="zero"><div class="cell-inline"><input id="hdr_r3" class="root"><span class="tick"></span></div></td>',
        '<td class="int cap-right">+∞</td>',
      '</tr>'
    ].join('');
  }
  function lineA(){
    return [
      '<tr><th class="lbl">\\('+st.a+'\\)</th>',
      '<td class="int"><select id="A_L" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_M1" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_M2" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"></td>',
      '<td class="int"><select id="A_R" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '</tr>'
    ].join('');
  }
  function lineFactor(label,id){
    return [
      '<tr><th class="lbl">\\('+label+'\\)</th>',
      `<td class="int"><select id="${id}_L" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_M1" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z2" class="sel"><option></option><option>0</option></select></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_M2" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      `<td class="zero"><select id="${id}_Z3" class="sel" ><option></option><option>0</option></select></select><span class="tick"></span></td>`,
      `<td class="int"><select id="${id}_R" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>`,
      '</tr>'
    ].join('');
  }
  function lineProduct(){
    return [
      '<tr><th class="lbl">\\(f(x)\\)</th>',
      '<td class="int"><select id="F_L" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z1" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_M1" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z2" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_M2" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '<td class="zero"><select id="F_Z3" class="sel"><option></option><option>0</option></select><span class="tick"></span></td>',
      '<td class="int"><select id="F_R" class="sel"><option></option><option>+</option><option>−</option></select><span class="tick"></span></td>',
      '</tr>'
    ].join('');
  }
  const lab = r => (r===0?'x':`x${r<0?'+':UMINUS}${Math.abs(r)}`);
  return [
    '<table class="sign-table" aria-label="Tableau de signes (3 racines)">',
      '<colgroup>',
        '<col class="col-lbl">',
        '<col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int">',
      '</colgroup><tbody>',
      hdrRow(),
      (hasA? lineA():''),
        // APRÈS — on respecte l’ordre de la factorisation (st.fac)
  lineFactor(lab(st.fac[0]), 'R1'),
  lineFactor(lab(st.fac[1]), 'R2'),
  lineFactor(lab(st.fac[2]), 'R3'),

      lineProduct(),
      '</tbody>',
    '</table>'
  ].join('');
}
function buildSignTableHTML_cubic_solution(st){
  const U='−';
  const lab = r => (r===0 ? '\\(x\\)' : `\\(x${r<0?'+':U}${Math.abs(r)}\\)`);
  const {x1,x2,x3} = sort3(st.r1, st.r2, st.r3);
  const posOf = r => (r===x1?1 : r===x2?2 : 3);     // position du zéro (colonne) pour ce facteur

  const sA = st.a>0?'+':'−';
  const sRight = sA;                 // degré impair : signe à +∞ = signe(a)
  const sLeft  = (sA==='+')?'−':'+'; // à −∞ = opposé
  const sMid1  = (sLeft==='+')?'−':'+'; // alternance
  const sMid2  = (sLeft==='+')?'+':'−';

  function factorRow(r){
    const k = posOf(r); // 1,2,3 ⇒ zéro en Z1/Z2/Z3
    // patrons par colonne : L | Z1 | M1 | Z2 | M2 | Z3 | R
    let L='−', Z1='', M1='−', Z2='', M2='−', Z3='', R='+';
    if(k===1){ Z1='0'; M1='+'; M2='+'; R='+'; }
    if(k===2){        M1='−'; Z2='0'; M2='+'; R='+'; }
    if(k===3){        M1='−';        M2='−'; Z3='0'; R='+'; }

    return `
      <tr>
        <th class="lbl">${lab(r)}</th>
        <td class="int">${L}</td><td class="zero">${Z1}</td>
        <td class="int">${M1}</td><td class="zero">${Z2}</td>
        <td class="int">${M2}</td><td class="zero">${Z3}</td>
        <td class="int">${R}</td>
      </tr>`;
  }

  return `
  <div class="var-wrap">
    <table class="sign-table" aria-label="Tableau de signes détaillé (solution)">
      <colgroup>
        <col class="col-lbl">
        <col class="col-int"><col class="col-zero">
        <col class="col-int"><col class="col-zero">
        <col class="col-int"><col class="col-zero">
        <col class="col-int">
      </colgroup>
      <tbody>
        <tr>
          <th class="lbl">\\(x\\)</th>
          <td class="int cap-left">−∞</td>
          <td class="zero">\\(${x1}\\)</td>
          <td class="int"></td>
          <td class="zero">\\(${x2}\\)</td>
          <td class="int"></td>
          <td class="zero">\\(${x3}\\)</td>
          <td class="int cap-right">+∞</td>
        </tr>
        ${st.a!==1 ? `
        <tr>
          <th class="lbl">\\(${st.a}\\)</th>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td><td class="zero"></td>
          <td class="int">${sA}</td>
        </tr>` : ''}

        ${ (st.fac && st.fac.length===3 ? st.fac : [st.r1,st.r2,st.r3]).map(factorRow).join('') }

        <tr>
          <th class="lbl">\\(f(x)\\)</th>
          <td class="int">${sLeft}</td><td class="zero">0</td>
          <td class="int">${sMid1}</td><td class="zero">0</td>
          <td class="int">${sMid2}</td><td class="zero">0</td>
          <td class="int">${sRight}</td>
        </tr>
      </tbody>
    </table>
  </div>`;
}


// Normalise une chaîne pour comparer 2 lignes (suppression espaces, \big, virgules fines, etc.)
// Normalise une saisie pour comparaison "texte à texte"
// ----------- Normalisations ----------
function canonDev(s){
  return String(s||'')
    .replace(/\u2212|−/g,'-')
    .replace(/\\\(|\\\)/g,'')
    .replace(/\\big/g,'')
    .replace(/\\,/g,'')
    .replace(/([A-Za-z])²/g,'$1^2').replace(/([A-Za-z])³/g,'$1^3')
    .replace(/\s+/g,'')
    .replace(/^\((.*)\)$/,'$1');
}
// Pour détection de "produit écrit" et comptages
function normLight(s){
  return String(s||'')
    .replace(/\u2212|−/g,'-')
    .replace(/([A-Za-z])²/g,'$1^2').replace(/([A-Za-z])³/g,'$1^3')
    .replace(/\s+/g,'');
}
function countOcc(s, re){ const m = s.match(re); return m? m.length : 0; }

// ----------- Équivalence numérique sûre (mais pas seule) -----------
function normExprInput(s){
  return String(s||'')
    .replace(/\u2212|−/g,'-')
    .replace(/×|·|⋅/g,'*')
    .replace(/([0-9])\s*x/g,'$1*x')
    .replace(/x\s*([0-9])/g,'x*$1')
    .replace(/\)\s*\(/g,')*(')
    .replace(/([0-9x])\s*\(/g,'$1*(')
    .replace(/\)\s*([0-9x])/g,')*$1')
    .replace(/([A-Za-z])²/g,'$1^2').replace(/([A-Za-z])³/g,'$1^3')
    .replace(/\^/g,'**')
    .replace(/\s+/g,'');
}
function isExprSafe(e){
  return /^[0-9x+\-*/().^*]+$/.test(e.replace(/\*\*/g,'^'));
}
function evalExprAt(expr, x){
  const e = normExprInput(expr);
  if(!isExprSafe(e)) return NaN;
  try{ const f = new Function('x', 'return ('+e+');'); const v=f(x); return Number.isFinite(v)?v:NaN; }
  catch(_){ return NaN; }
}
function eqCubic(expr, a, r1, r2, r3){
  const pts = [-4,-3,-2,-1,0,1,2,3,4];
  for(const x of pts){
    const tgt = a*(x-r1)*(x-r2)*(x-r3);
    const val = evalExprAt(expr, x);
    if(!Number.isFinite(val) || Math.abs(val-tgt) > 1e-6) return false;
  }
  return true;
}
function isFxLoose(s){ return canonDev(s).toLowerCase()==='f(x)'; }

// ----------- Formes attendues par ligne -----------
function shapeFlags(expr){
  const raw  = String(expr||'');
  const lite = normLight(raw);
  const tight = raw.replace(/\s+/g,'');

  const prodAny =
      /\)\s*\(/.test(tight)    // …)(…
   || /\)\s*[0-9x]/.test(tight) // …)x ou …)2
   || /[0-9x]\s*\(/.test(tight); // x(… ou 2(…

  return {
    hasParens: /[()]/.test(raw),
    hasProductLook: prodAny,
    hasX3: /x\^?3/.test(lite),
    x2count: (lite.match(/x\^?2/g)||[]).length,
    xcount:  (lite.replace(/x\^?2/g,'').match(/x(?!\^)/g)||[]).length
  };
}


// Renvoie la liste des parenthèses "facteurs" ( ( ... ) )
function factorGroups(expr){
  return (String(expr||'').match(/\([^()]*\)/g) || []);
}
// Un groupe ( ... ) est "linéaire" s'il contient x mais pas x^2, x^3, ...
function isLinearGroup(s){
  const t = String(s||'').replace(/\u2212|−/g,'-')
                         .replace(/([A-Za-z])²/g,'$1^2')
                         .replace(/([A-Za-z])³/g,'$1^3')
                         .replace(/\s+/g,'');
  return /x/.test(t) && !/x\^/.test(t);
}
// Produit de **trois facteurs linéaires** (ex: (-2x-6)(x+1)(x-4))
// Produit de trois facteurs linéaires :
//  - OK si ≥ 3 groupes ( … ) linéaires
//  - OU si ≥ 2 groupes linéaires + au moins un facteur x "nu"
function isTripleLinearProduct(expr){
  const raw = String(expr||'');

  // Tous les groupes "( … )"
  const groups = (raw.match(/\([^()]*\)/g) || []);

  // Un groupe est linéaire s'il contient x mais pas x^k (k≥2)
  const linGroups = groups.filter(g=>{
    const t = g.replace(/\u2212|−/g,'-')
               .replace(/([A-Za-z])²/g,'$1^2')
               .replace(/([A-Za-z])³/g,'$1^3')
               .replace(/\s+/g,'');
    return /x/.test(t) && !/x\^/.test(t);
  });

  // Squelette : remplace chaque "(…)" par "G", puis compte les x "nus"
  let skel = raw;
  groups.forEach(g => { skel = skel.replace(g, 'G'); });
  skel = skel.replace(/\s+|\u2212|−|\*/g,''); // sans espaces/−/*

  const bareX = (skel.match(/x(?!\^)/g) || []).length;

  return (linGroups.length >= 3) || (linGroups.length >= 2 && bareX >= 1);
}



// ====== Fabrique les lignes de développement (droite) + l’en-tête (gauche) ======
function makeDevRows_cubic(a, r1, r2, r3, order){
  const U='−';
  const coef = k => k===1 ? '' : (k===-1 ? U : String(k));
  const par  = r => r===0 ? 'x' : `\\big(x${r<0?'+':U}${Math.abs(r)}\\big)`;

  // ← ordre d’affichage/développement (ex: st.fac), sinon ordre trié par défaut
  const roots = (order && order.length===3) ? order.slice() : [r1,r2,r3];
  const [p1, p2, p3] = roots;

  const aHead = coef(a) ? coef(a)+'\\,' : '';
  const head  = `${coef(a)}${par(p1)}${par(p2)}${par(p3)}`.replace(/\\big\(x[−-]0\\big\)/g,'x');
  const T = (k, tag) => k===0 ? '' : (k>0?' + ':' '+U+' ') + (Math.abs(k)===1 ? tag : Math.abs(k)+tag);

  // (x−p1)(x−p2) : S, P selon p1,p2 (pas r1,r2 !)
  const S = p1 + p2, P = p1 * p2;

  // L1 : regroupement « quadratique × linéaire » avant simplif
  const k1 = -p2, k2 = -p1;
  const quadRaw = ('x^2' + T(k1,'x') + T(k2,'x') + (P? (P>0?' + ':' '+U+' ')+Math.abs(P) : '')).trim();
  const l1 = `\\( ${aHead}\\big(${quadRaw}\\big)\\,${par(p3)} \\)`;

  // L2 : quadratique simplifiée (x^2 − Sx + P) × (x−p3)
  const quad = ('x^2' + T(-S,'x') + (P? (P>0?' + ':' '+U+' ')+Math.abs(P) : '')).trim();
  const l2 = `\\( ${aHead}\\big(${quad}\\big)\\,${par(p3)} \\)`;

  // L3 : « 6 termes » avant regroupement
  const cx2_r3 = -p3, cx2_S = -S, cx_Sr3 = S*p3, cx_P = P, cst = -P*p3;
  const six = ('x^3' + T(cx2_r3,'x^2') + T(cx2_S,'x^2') + T(cx_Sr3,'x') + T(cx_P,'x')
              + (cst? (cst>0?' + ':' '+U+' ')+Math.abs(cst):''))
              .replace(/^\+\s*/,'').trim();

  // L4 : regroupé dans la parenthèse
  const B = -(p3+S), C = S*p3 + P, D = -P*p3;
  const grp = ('x^3' + T(B,'x^2') + T(C,'x') + (D? (D>0?' + ':' '+U+' ')+Math.abs(D) : ''))
              .trim();

  // L5 : distribution du coefficient a
  const dist = (
    (a===1 ? 'x^3' : (a===-1 ? U+'x^3' : a+'x^3'))
    + T(a*B,'x^2') + T(a*C,'x') + (a*D ? (a*D>0?' + ':' '+U+' ')+Math.abs(a*D) : '')
  ).replace(/^\+\s*/,'').trim();

  // a=1 ⇒ pas de parenthèses sur L3/L4
  const l3 = (a===1) ? `\\( ${six} \\)` : `\\( ${aHead}\\big(${six}\\big) \\)`;
  const l4 = (a===1) ? `\\( ${grp} \\)` : `\\( ${aHead}\\big(${grp}\\big) \\)`;
  const l5 = `\\( ${dist} \\)`;
  const l6 = `\\( f(x) \\)`;

  // empile en supprimant les doublons consécutifs
  const rows = [];
  const pushU = (s) => { if(!rows.length || canonDev(rows.at(-1)) !== canonDev(s)) rows.push(s); };
  [l1,l2,l3,l4,l5,l6].forEach(pushU);

  return { head: `\\( ${head} = \\)`, rows };
}



function buildQ1TableHTML_cubic(a, r1, r2, r3, order){
  const dev = makeDevRows_cubic(a, r1, r2, r3, order);
  return [
    '<table style="border-collapse:collapse;width:auto;margin:.2rem 0">',
      '<colgroup><col style="width:auto"><col style="width:24px"><col style="width:auto"></colgroup>',
      '<tbody>',
        dev.rows.map((right,i) =>
          `<tr>
            <td style="border:none;padding:2px 8px 2px 0;text-align:left">${ i===0 ? dev.head : '' }</td>
            <td style="border:none;padding:2px 4px;text-align:center;font-weight:600">=</td>
            <td style="border:none;padding:2px 0 2px 8px;text-align:left">${right}</td>
          </tr>`
        ).join('')
      + '</tbody>',
    '</table>'
  ].join('');
}


// supprime tout (x−0) résiduel (avec − unicode ou tiret ASCII, avec/ sans \big)
function fixXminus0(root){
  const RE1 = /\(x\s*[−-]\s*0\)/g;                  // (x-0) → x
  const RE2 = /\\big\(x\s*[−-]\s*0\\big\)/g;         // \big(x-0\big) → x
  const RE3 = /x\s*[−-]\s*0(?=\s*=)/g;               // x-0 = ... → x = ...
  (root || document).querySelectorAll('#host, #res, .steps').forEach(el=>{
    el.innerHTML = el.innerHTML
      .replace(RE1,'x')
      .replace(RE2,'x')
      .replace(RE3,'x');
  });
}
// utils (ajoute)
function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function factorOrder(r1,r2,r3){
  // renvoie un tableau [q1,q2,q3] : ordre d'affichage des facteurs
  const arr=[r1,r2,r3].slice();
  const hasZero = arr.includes(0);
  if(hasZero){
    const no0 = arr.filter(v=>v!==0);
    shuffleInPlace(no0);
    no0.push(0);              // x en dernier
    return no0;
  }else{
    shuffleInPlace(arr);
    return arr;
  }
}


/* ===== ÉNONCÉ / CORRECTION ===== */
const exo = {
  id:'bilan3d_rand',
  title:'Application bilan 3ᵉ degré',
  gen(){
    const A=[-3,-2,-1,1,2,3];
    const a=choice(A);
    let r1=rint(-5,5), r2=rint(-5,5), r3=rint(-5,5);
    while(new Set([r1,r2,r3]).size<3){ r1=rint(-5,5); r2=rint(-5,5); r3=rint(-5,5); }
    [r1,r2,r3]=[r1,r2,r3].sort((x,y)=>x-y);
	const fac = factorOrder(r1,r2,r3);   // ordre pour l’affichage factorisé

    // f(x)=a(x-r1)(x-r2)(x-r3)= ax^3 + bx^2 + cx + d
    const b = -a*(r1+r2+r3);
    const c =  a*(r1*r2 + r1*r3 + r2*r3);
    const d = -a*(r1*r2*r3);
    // comparateur par défaut
// comparateur tiré au sort
const cmp = choice(['<','≤','>','≥']);
return {a,b,c,d,r1,r2,r3,cmp, fac};  // ← on stocke aussi fac
  },

  render(host,st){
    const tex = `f(x)= ${poly3String(st.a,st.b,st.c,st.d)}`;
const fact = factorized3(st.a,st.r1,st.r2,st.r3, st.fac);
// … à l’intérieur de render(host, st)
const dev = makeDevRows_cubic(st.a,st.r1,st.r2,st.r3, st.fac);
const devInputs = dev.rows
  .map((_,i)=>`<input class="fact" data-step="${i+1}" type="text" style="width:420px">`)
  .join('<br>');

const leftDev = `
  <div class="left-dev">
    <span class="lbl">Développement :
	<br>Vous pouvez laisser des saisies vides</span>
    <span class="fact-latex">${dev.head}</span>
  </div>
`;

const rightDev = `<div class="dev-inputs">${devInputs}</div>`;


    host.innerHTML = [
      `<div>Soit la fonction définie sur ℝ par \\( ${tex} \\).</div>`,
      '<ol style="margin:.4rem 0 .2rem 1.1rem">',
        `<li>Montrer que \\(f(x)=${fact}\\).</li>`,
        `<li>Résoudre \\(f(x)=0\\).</li>`,
        '<li>Indiquer le sens de variations de \\(f\\) (sans se préoccuper des intervalles).</li>',
        `<li>
           a) Dresser le tableau de <em>signes</em> complet.<br>
           b) En déduire 
             \\( f(x) \\) 
             <select class="cmp" style="margin-left:.35rem">
  <option value="<">&lt; 0</option>
  <option value="≤">≤ 0</option>
  <option value=">">&gt; 0</option>
  <option value="≥">≥ 0</option>
</select>
             
           </li>`,
      '</ol>',

     `<table class="table tbl-main3">
  <colgroup>
    <col class="col-left">
    <col class="col-right">
  </colgroup>
  <thead>
    <tr><th>Élément</th><th>Réponse (à compléter)</th></tr>
  </thead>
  <tbody>
`,
          `<tr class="row-dev">
  <td>${leftDev}</td>
  <td>${rightDev}<div class="pdf-expand"></div></td>
</tr>
          <tr class="row-dev"><td>Équation \\(f(x)=0\\)<div class="pdf-expand"></td><td><input class="roots" type="text" style="width:260px" placeholder="-3;-1;2"></td></tr>
          <tr class="row-variations">
  <td>Variations</td>
  <td>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <select class="var-sel v1" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>↗</option>
        <option>↘</option>
      </select>
      <select class="var-sel v2" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>↗</option>
        <option>↘</option>
      </select>
      <select class="var-sel v3" style="min-width:70px;text-align-last:center">
        <option value=""></option>
        <option>↗</option>
        <option>↘</option>
      </select>
    </div>
  </td>
</tr>

		  
		  <tr><td>Inéquation : \\( f(x) \\) <span id="cmp-view">≤</span> \\( 0 \\)</td><td><input class="ineq" type="text" style="width:320px" placeholder=""></td></tr>
        </tbody>
      </table>`,



      '<div style="margin:.6rem 0 .2rem">Tableau de signes détaillé :</div>',
      '<div id="sign-host"></div>',

      '<div id="res" class="steps small"></div>'
    ].join('');

    $('#sign-host',host).innerHTML = buildSignTableHTML_cubic(st);

    // placeholder inéquation
    const cmpSel = $('.cmp',host);
	cmpSel.value = st.cmp;     // reflète le tirage ou la reprise d’état
updateIneqUI();            // met à jour l’affichage et le state

    function ineqPlaceholderFor({a,r1,r2,r3,cmp}){
      // alternance parité 3 : signe de f = signe(a) à l’extérieur
      const I1=`]-∞;${r1}[`, I2=`]${r1};${r2}[`, I3=`]${r2};${r3}[`, I4=`]${r3};+∞[`;
      // signes: a, −a, a, −a sur I1..I4
      const s = (sgn)=> sgn>0?['<','≤'] : ['>','≥'];
      const wantNeg = (a>0? ['I2','I4'] : ['I1','I3']);
      const wantPos = (a>0? ['I1','I3'] : ['I2','I4']);
      if(cmp==='<')  return (wantNeg.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
      if(cmp==='>')  return (wantPos.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
      if(cmp==='≤'){ // inclut les racines
        const ne = (wantNeg.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
        return `${ne} ∪ {${r1};${r2};${r3}}`;
      }
      const po = (wantPos.map(x=>({I1,I2,I3,I4}[x])).join(' ∪ '));
      return `${po} ∪ {${r1};${r2};${r3}}`;
    }
function updateIneqUI(){
  st.cmp = cmpSel.value;
  host.dataset.state = JSON.stringify(st);
  $('#cmp-view',host).textContent = st.cmp;
  const ineqInput = $('.ineq',host);
  typesetAll(host);
}

    cmpSel.addEventListener('change', updateIneqUI);
    updateIneqUI();

    host.querySelectorAll('input,select').forEach(el=>ensureTickAfter(el));
    typesetAll(host);
  },

    correct(host, st){
    const get = sel => (host.querySelector(sel));
    const read = sel => (get(sel)?.value||'').trim().replace(/\u2212/g,'-');

    let ok=0, tot=0;

    // --- Correction Développement (mêmes lignes que la solution) ---
// --- Correction Développement : stricte par ligne, variantes autorisées ---
(function(){
  const els = Array.from(host.querySelectorAll('.fact'));
  if(!els.length) return;
const fam = {
  QL(expr){                // quadratique × linéaire (avec ou sans réduction)
    const sh = shapeFlags(expr);
    return !sh.hasX3 && sh.hasParens && sh.hasProductLook && sh.x2count >= 1;
  },
  SIX(expr){               // forme "six-termes" (x^3 présent + au moins 2 x^2)
    const sh = shapeFlags(expr);
    return sh.hasX3 && sh.x2count >= 2;
  },
  GROUP(expr){             // cubique regroupée (x^3 + Bx^2 + Cx + D)
    const sh = shapeFlags(expr);
    return sh.hasX3 && sh.x2count === 1;
  },
  DIST(expr){              // cubique entièrement distribuée (pas de produit explicite)
    const sh = shapeFlags(expr);
    return sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook;
  }
};

  // même nombre d’inputs que de lignes de solution (dédup déjà gérée côté render)
 els.forEach((el, i)=>{
  const raw = (el.value||'').trim();
  if(!raw){ setTick(el,'nu'); return; }
  scoreTot++;

  const eqOK = eqCubic(raw, st.a, st.r1, st.r2, st.r3);
  const sh   = shapeFlags(raw);
const allowQL = (!sh.hasX3 && sh.hasParens && sh.hasProductLook && sh.x2count >= 1);

  // détecteurs de "familles" de formes
  const isSix   = (sh.hasX3 && sh.x2count >= 2);                 // x^3 + ... + ... x^2 + ... x^2 + ...
  const isGroup = (sh.hasX3 && sh.x2count === 1);                // x^3 + Bx^2 + Cx + D  (avec ou sans a(…))
  const isDist  = (sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook); // complètement distribué

  let formOK = false;

 if(i === 0){
  // L1 : quadratique × linéaire OU produit de 3 linéaires
  formOK = fam.QL(raw) || isTripleLinearProduct(raw);

} else if (i === 1){
  // L2 : accepter QL OU six-termes OU regroupée OU déjà distribuée
  formOK = fam.QL(raw) || fam.SIX(raw) || fam.GROUP(raw) || fam.DIST(raw);
}else if(i === 3){
  // L4 : accepter "regroupée" OU "déjà distribuée"
  const isGroup = (sh.hasX3 && sh.x2count === 1);
  const isDist  = (sh.hasX3 && sh.x2count === 1 && !sh.hasProductLook);
  formOK = (isGroup || isDist);
} else if (i === els.length - 1){
  // Dernière ligne
  formOK = isFxLoose(raw);

} else {
  // L3…L(n-1) : six-termes OU regroupée OU distribuée (peu importe l’ordre)
  formOK = fam.SIX(raw) || fam.GROUP(raw) || fam.DIST(raw);
}

const good = (i===els.length-1) ? formOK : (eqOK && formOK);


  setTick(el, good ? 'ok' : 'ko');
  if(good) scoreOK++;
});

})();



    // Racines : ordre libre ; ; ou , ; { }
    (function(){
      const el = $('.roots', host);
      const raw = (el?.value||'').trim();
      if(!raw) return;
      tot++;
      let s = raw.replace(/\s+/g,'').replace(/^S=/i,'').replace(/^[\{\(\[]/,'').replace(/[\}\)\]]$/,'');
      const parts = s.split(/[;,]/).filter(Boolean).map(Number).sort((x,y)=>x-y);
      const want  = [st.r1,st.r2,st.r3].slice().sort((x,y)=>x-y);
      const good = parts.length===3 && parts.every((v,i)=>v===want[i]);
      setTick(el, good?'ok':'ko'); if(good) ok++;
    })();

    // Variations : flèches extrêmes (qualitatif)
  // Variations : 3 sélecteurs ↗/↘ (qualitatif)
(function(){
  const s1 = $('.var-sel.v1', host),
        s2 = $('.var-sel.v2', host),
        s3 = $('.var-sel.v3', host);
  if(!s1 || !s2 || !s3) return;

  const any = [s1,s2,s3].some(e => (e.value||'').trim());
  if(!any) return;              // rien rempli → pas noté

  tot++;

  // Cubique : a>0 ⇒ ↗,↘,↗ ; a<0 ⇒ ↘,↗,↘
  const want = (st.a > 0) ? ['↗','↘','↗'] : ['↘','↗','↘'];
  const good = (s1.value===want[0] && s2.value===want[1] && s3.value===want[2]);

  [s1,s2,s3].forEach((el,i)=>{
    const v = (el.value||'').trim();
    setTick(el, v ? (v===want[i] ? 'ok' : 'ko') : 'nu');
  });

  if(good) ok++;
})();


    /* ====== Correction du tableau de signes (3 racines) ====== */
// entête (r1,r2,r3)
(function(){
  const r1 = Number(valTrim(get('#hdr_r1'))),
        r2 = Number(valTrim(get('#hdr_r2'))),
        r3 = Number(valTrim(get('#hdr_r3')));
  const filled = [get('#hdr_r1'), get('#hdr_r2'), get('#hdr_r3')].some(e => (e?.value||'').trim());
  if(!filled) return;
  tot++;
  const good = (r1===st.r1 && r2===st.r2 && r3===st.r3);
  [get('#hdr_r1'), get('#hdr_r2'), get('#hdr_r3')].forEach(e => setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();

// ligne 'a' si elle existe (signe constant)
(function(){
  const AL = get('#A_L'), AM1 = get('#A_M1'), AM2 = get('#A_M2'), AR = get('#A_R');
  if(!AL || !AM1 || !AM2 || !AR) return;               // ligne a absente si a==1
  const any = [AL,AM1,AM2,AR].some(e=>e.value);
  if(!any) return;
  tot++;
  const sA = (st.a>0?'+':'−');
  const good = (AL.value===sA && AM1.value===sA && AM2.value===sA && AR.value===sA);
  [AL,AM1,AM2,AR].forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();

// ——— Correction des 3 lignes "facteur" : ordre libre ———
// Règle : une ligne facteur doit avoir exactement un '0' (sur Z1 ou Z2 ou Z3)
// et respecter les signes attendus autour de CE zéro.
// Zéro en Z1  → [L='−', Z1='0', M1='+', M2='+', R='+']
// Zéro en Z2  → [L='−',             M1='−', Z2='0', M2='+', R='+']
// Zéro en Z3  → [L='−',                         M2='−', Z3='0', R='+']
// ===== Correction des 3 lignes "facteur" — strict : zéro à la BONNE colonne =====
(function(){
  const get = sel => host.querySelector(sel);

  // positions des racines (colonnes 1,2,3) d'après st.r1<st.r2<st.r3
  const rootsSorted = [st.r1, st.r2, st.r3].slice().sort((a,b)=>a-b);
  const posOf = r => (r===rootsSorted[0]?1 : r===rootsSorted[1]?2 : 3);

  // ordre d’affichage des lignes facteur (étiquettes) : st.fac si présent, sinon (r1,r2,r3)
  const fac = (st.fac && st.fac.length===3) ? st.fac.slice() : [st.r1, st.r2, st.r3];

  // mapping lignes → racines
  const rows = [
    { id:'R1', r: fac[0] },
    { id:'R2', r: fac[1] },
    { id:'R3', r: fac[2] },
  ];

  function read(prefix){
    return {
      L:  get(`#${prefix}_L`),
      Z1: get(`#${prefix}_Z`),
      M1: get(`#${prefix}_M1`),
      Z2: get(`#${prefix}_Z2`),
      M2: get(`#${prefix}_M2`),
      Z3: get(`#${prefix}_Z3`),
      R:  get(`#${prefix}_R`)
    };
  }
  function expectedPatternFor(col){ // col = 1,2 ou 3 (position de la racine de CETTE ligne)
    if(col===1) return { L:'−', Z1:'0', M1:'+',            M2:'+',            R:'+' };
    if(col===2) return { L:'−',            M1:'−', Z2:'0',  M2:'+',            R:'+' };
    return        { L:'−',            M1:'−',          M2:'−', Z3:'0',        R:'+' };
  }

  let anyFilled=false, rowOKs=[];

  rows.forEach(({id,r})=>{
    const v = read(id);
    const filled = [v.L,v.Z1,v.M1,v.Z2,v.M2,v.Z3,v.R].some(e=>e && e.value);
    if(filled) anyFilled=true;

    // motif EXIGÉ pour CETTE ligne (sa racine r à SA colonne attendue)
    const kExp = posOf(r);
    const exp  = expectedPatternFor(kExp);

    // Ticks cellule par cellule : si rempli, doit matcher le motif exp
    let allOK = true;
    [['L','L'],['Z1','Z1'],['M1','M1'],['Z2','Z2'],['M2','M2'],['Z3','Z3'],['R','R']]
    .forEach(([key,ek])=>{
      const el = v[ek]; if(!el) return;
      const want = exp[key] || '';      // vide autorisé si non exigé
      const cur  = (el.value||'');
      if(!cur){ setTick(el,'nu'); return; }
      const good = (cur===want);
      setTick(el, good ? 'ok' : 'ko');
      if(!good) allOK=false;
    });

    rowOKs.push(filled ? allOK : true); // ligne vide → non notée
  });

  if(!anyFilled) return;  // rien rempli → pas noté
  tot++;

  // Toutes les lignes remplies doivent être correctes
  if(rowOKs.every(Boolean)) ok++;
})();





// ligne produit f(x) — degré impair ⇒ signes opposés à gauche/droite
(function(){
  const L  = get('#F_L'), Z1 = get('#F_Z1'), M1 = get('#F_M1'),
        Z2 = get('#F_Z2'), M2 = get('#F_M2'), Z3 = get('#F_Z3'), R = get('#F_R');
  const any = [L,Z1,M1,Z2,M2,Z3,R].some(e=>e?.value);
  if(!any) return;
  tot++;

  const sRight = (st.a>0?'+':'−');           // +∞
  const sLeft  = (st.a>0?'−':'+');           // −∞  (opposé car degré impair)
  const sMid1  = (sLeft==='+'? '−' : '+');   // alternance
  const sMid2  = (sLeft==='+'? '+' : '−');

  const good = (L.value===sLeft && Z1.value==='0' &&
                M1.value===sMid1 && Z2.value==='0' &&
                M2.value===sMid2 && Z3.value==='0' &&
                R.value===sRight);

  [L,Z1,M1,Z2,M2,Z3,R].forEach(e=>setTick(e, good?'ok':'ko'));
  if(good) ok++;
})();


   // 12) Inéquation (accepte -oo/+oo/oo, U/∪, () au lieu de [])
(function(){
  const el = $('.ineq', host);
  let raw = (el?.value || '');
  if(!raw.trim()) return;
  tot++;

  function normSet(s){
    s = String(s)
      .replace(/\u2212|−/g, '-')        // minus
      .replace(/\s+/g, '')
      .replace(/^[sS]=?/, '')           // enlève "S=" toléré
      .replace(/[()]/g, m => m==='(' ? '[' : ']')
      .replace(/[\u222aUu]/g, '∪')
      .replace(/-oo/gi,'-∞').replace(/\+oo/gi,'+∞')
      .replace(/(^|[^+\-])oo/gi, (_,$1)=> `${$1}+∞`)
      .replace(/(^|[^+\-])∞/g, (_,$1)=> `${$1}+∞`);
    return s;
  }

  const wants = expectedSetsCubic(st.a, st.r1, st.r2, st.r3, st.cmp).map(normSet);
  const got   = normSet(raw);
  const good  = wants.includes(got);

  setTick(el, good ? 'ok' : 'ko');
  if(good) ok++;
})();


    scoreOK=ok; scoreTot=tot; updateScore();
    return {ok, total:tot};
  },

  solution(host, st){
const fact = factorized3(st.a,st.r1,st.r2,st.r3, st.fac);
    const poly = poly3String(st.a,st.b,st.c,st.d);

    // 1) Développement — tableau 3 colonnes
const q1 = buildQ1TableHTML_cubic(st.a, st.r1, st.r2, st.r3, st.fac);

const facOrder = (st.fac && st.fac.length===3) ? st.fac : [st.r1, st.r2, st.r3];

function eqFactorToZero3(r){ return r===0 ? 'x=0' : String.raw`x${r<0?'+':UMINUS}${Math.abs(r)}=0`; }

const eq0 = [
  // 1) écriture factorisée = 0
  `$${coef(st.a)}${facOrder.map(r=>`(x${r<0?'+':UMINUS}${Math.abs(r)})`).join('')}=0$`,
  // 2) équivalences (inline -> alignées à gauche)
  `$\\iff ${eqFactorToZero3(facOrder[0])}\\;\\text{ ou }\\;${eqFactorToZero3(facOrder[1])}\\;\\text{ ou }\\;${eqFactorToZero3(facOrder[2])}$`,
  `$\\iff x=${facOrder[0]}\\;\\text{ ou }\\;x=${facOrder[1]}\\;\\text{ ou }\\;x=${facOrder[2]}$`,
  `$S=\\{${[st.r1,st.r2,st.r3].join('\\;;\\;')}\\}$`
].map(s=>`<div class="step">${s}</div>`).join('');



// 3) Variations — séquence attendue + justification par le signe de a
const varSeq = (st.a > 0) ? '↗, ↘, ↗' : '↘, ↗, ↘';

const varJustif = (st.a > 0)
  ? String.raw`Comme \(a>0\) et que le degré est impair, on a  l'alternance \( \text{↗ } , \text{↘ } , \text{↗  } \).`
  : String.raw`Comme \(a<0\) et que le degré est impair, on a l’alternance \( \text{↘  } , \text{↗ } , \text{↘ } \).`;

const varBlock = `
  <div class="step"><b>3) Variations :</b></div>
  <div class="step" >${varJustif}</div>
`;



    // 4) Tableau de signes — schéma LaTeX (en plus du tableau interactif)
    const sOut = (st.a>0?'+':'−'), sMid1=(st.a>0?'−':'+'), sMid2=(st.a>0?'+':'−');
    const signLatex = String.raw`\[
\begin{array}{c|ccccccc}
x&-\infty&${st.r1}&&${st.r2}&&${st.r3}&+\infty\\\hline
f(x)& ${sOut} & 0 & ${sMid1} & 0 & ${sMid2} & 0 & ${sOut}
\end{array}\]`;

    const {a,r1,r2,r3} = st;
  const {x1,x2,x3} = sort3(r1,r2,r3);
  const cmp = st.cmp;

  function texSet(a, r1, r2, r3, cmp){
    const [form] = expectedSetsCubic(a, r1, r2, r3, cmp);    // forme "officielle"
    return form.replaceAll(';','\\;;\\;');                   // un peu d’espace en TeX
  }

  const ineqLine = String.raw`$\,f(x)\,${cmp}\,0 \iff x \in ${texSet(a,r1,r2,r3,cmp)}\,$`;
  const setLine  = String.raw`$S = ${texSet(a,r1,r2,r3,cmp)}$`;

    // Tableau de signes détaillé (HTML) – réutilise celui de l'énoncé pour « montrer » la solution
const signDetailHTML = buildSignTableHTML_cubic_solution(st);

    $('#res',host).innerHTML = `
      <div class="steps">
        <div class="step"><b>1) Développer</b></div>
        ${q1}
      

        <div class="step"><b>2) Résoudre</b> \\(f(x)=0\\)</div>
        ${eq0}

    ${varBlock}

     

        <div class="step"><b>4a)  Tableau de signes</b></div>
        <div class="step">${signDetailHTML}</div>

    <div class="step"><b>4b) Inéquation :</b> ${ineqLine}</div>
     <div class="step" style="margin-left:2.2em">${setLine}</div>
      </div>`;
	  fixXminus0(host);
    typesetAll($('#res',host));
  },

  reset(host){ $('#res',host).textContent=''; }
};

/* ===== Registre & UI ===== */
const REGISTRY=[exo];
window.REGISTRY = REGISTRY;

// init PDF (optionnel, même mécanique que tes autres pages)
(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: '1STI2D – Application bilan (3ᵉ degré)',
      mountAfterSelector: '.card.small',
      leadByDefId: { 'bilan3d_rand': '' },
    });
  } else { setTimeout(waitExoPDF, 50); }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }
function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  scoreOK=0; scoreTot=0;
  const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st); scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){ const def=getDefById($("#exo-select").value), host=$("#host"), st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const def=getDefById($("#exo-select").value), host=$("#host"); def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} — ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();
})();
</script>
</body>
</html>
