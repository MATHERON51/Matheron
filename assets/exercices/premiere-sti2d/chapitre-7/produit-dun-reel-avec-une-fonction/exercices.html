<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>1√®re STI2D ‚Äî D√©rivation : Produit par un r√©el</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .table{width:100%;border-collapse:collapse;margin:.35rem 0}
  .table th,.table td{border:1px solid #e5e5e5;padding:6px 8px;vertical-align:top}
  .table th{background:#f3f3f6;text-align:left}

  /* tableau avec espace horizontal pour les √©tapes */
  .table.xgap{ border-collapse:separate; border-spacing:22px 0; }
  .table.xgap th,.table.xgap td{ border:1px solid #e5e5e5; padding:10px 14px; white-space:nowrap; }
  @media print{ .table.xgap{ border-spacing:24px 0; } }

  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f7f8fb;border:1px dashed #c7d2fe;border-radius:10px}
  .line{white-space:nowrap}
  .tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
  .tick.ok{color:#11823b}.tick.ko{color:#b00020}

  .answers{ display:flex; flex-wrap:wrap; gap:.4rem .5rem; }
  .answers .qa-row{ flex-basis:100%; display:flex; align-items:center; gap:.4rem; margin-top:.35rem; }
  .answers .qa-row label{ margin-right:.3rem; }

  @media print{ .controls{display:none !important;} }

  /* espacement lisible des lignes LaTeX */
  .steps .line{ margin:.32rem 0; line-height:1.9 }
  .steps mjx-container{ padding-bottom:.08em }

  @media print{
    .steps .line{ margin:.36rem 0; line-height:2 }
  }
</style>

<!-- ‚≠ê MATHJAX CONFIG CHTML (PAS SVG) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<!-- FIN MathJax -->

<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem"><strong>1√®re STI2D ‚Äì D√©rivation : Produit par un r√©el</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Puissances : <code>x^n</code>, <code>x**n</code>, <code>x¬≤</code>‚Ä¶</li>
        <li>Racines : <code>sqrt(‚Ä¶)</code>, <code>rac(‚Ä¶)</code>, <code>‚àö(‚Ä¶)</code>.</li>
        <li>Fractions : <code>a/b</code>. Multiplications implicites accept√©es.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- D√©pendances projet -->
  <script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
  <script src='../../../../js/math-kbd.js' defer></script>
  <script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

  /* ==== Utils ==== */
  const $  = (s,r)=> (r||document).querySelector(s);
  const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
  let scoreOK=0, scoreTot=0;
  function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }
  const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const choice=a=>a[Math.floor(Math.random()*a.length)];
  const UMINUS = (window.DevRules && DevRules.consts && DevRules.consts.UMINUS) || '‚àí';
  function scanFractions(root){ try{ if(window.FractionSignClarity?.scan) FractionSignClarity.scan(root||document); }catch(_){} }

  /* ==== Normalisation / √©val saisie ==== */
  function normalizeRac(s){
    s = String(s||'');

    // \sqrt{...} et \rac{...} ‚Üí sqrt(...)
    s = s.replace(/\\sqrt\{([^{}]+)\}/g, 'sqrt($1)')
         .replace(/\\rac\{([^{}]+)\}/g,  'sqrt($1)');

    // 2rac(...), )rac(...), etc.
    s = s.replace(/(\d|\))\s*rac\s*\(/gi, '$1*sqrt(');
    s = s.replace(/(^|[^A-Za-z0-9_])rac\s*\(/gi, '$1sqrt(');

    // variantes avec ‚àö
    s = s.replace(/(\d|\))\s*‚àö\s*\(/g, '$1*sqrt(');
    s = s.replace(/(\d|\))\s*‚àö\s*x\b/gi, '$1*sqrt(x)');
    s = s.replace(/‚àö\s*\(/g,   'sqrt(')
         .replace(/‚àö\s*x\b/gi, 'sqrt(x)');

    // ")sqrt(" -> ")*sqrt("
    s = s.replace(/\)\s*(?=sqrt\()/g, ')*');

    // cas 1/(2sqrt(...)) si √©toile manquait
    s = s.replace(/\/\(\s*(\d+)\s*(?=sqrt\()/gi, '/($1*');
    return s;
  }

  function numEval(expr, x){
    if(expr==null) return NaN;
    let s = String(expr);

    // normalisations de base
    s = s.replace(/‚àí/g,'-').replace(/[√ó¬∑]/g,'*');

    // racine
    s = normalizeRac(s);

    // puissances unicode -> ^ -> **
    const SUP = {'‚Å∞':'0','¬π':'1','¬≤':'2','¬≥':'3','‚Å¥':'4','‚Åµ':'5','‚Å∂':'6','‚Å∑':'7','‚Å∏':'8','‚Åπ':'9'};
    s = s.replace(/([A-Za-z0-9\)\]])([‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+)/g,
          (_m, base, expo)=> base + '^' + expo.split('').map(c=>SUP[c]||'').join('')
        )
        .replace(/\^/g,'**');

    // sqrt -> Math.sqrt
    s = s.replace(/\bsqrt\s*\(/gi,'Math.sqrt(');

    // multiplications implicites
    s = s
      .replace(/\)\s*\(/g, ')*(')
      .replace(/(\d)\s*\(/g, '$1*(')
      .replace(/(\d)\s*x/g, '$1*x')
      .replace(/\)\s*x/g, ')*x')
      .replace(/x\s*\(/g, 'x*(');

    // √©toile implicite avant Math.sqrt
    s = s
      .replace(/(\d|\))\s*(?=Math\.sqrt\()/g, '$1*')
      .replace(/x\s*(?=Math\.sqrt\()/g, 'x*');

    // substituer x par la valeur test
    if (typeof x === 'number') {
      s = s.replace(/(?<![A-Za-z_])x(?![A-Za-z_])/g, '('+x+')');
    }

    try { return Number(Function('"use strict";return ('+s+')')()); }
    catch { return NaN; }
  }

  function almost(a,b,eps=1e-8){ return Math.abs(a-b) <= eps*(1+Math.max(1,Math.abs(a),Math.abs(b))); }

  /* ==== Outils d'assemblage LaTeX & simplification ==== */
  function isZeroTex(t){ return /^\s*[+-]?\s*0\s*$/.test(String(t||'')); }
  function stripSign(s){ return String(s||'').replace(/^\s*[+]\s*/,'').trim(); }
  function joinTermsNoZero(terms){
    const kept=[];
    for(const raw of (terms||[])){
      const t=String(raw||'').trim();
      if(!t) continue;
      if(isZeroTex(t)) continue;
      kept.push(t);
    }
    if(kept.length===0) return '0';
    let out = kept[0].startsWith('-') ? kept[0] : stripSign(kept[0]);
    for(let i=1;i<kept.length;i++){
      const t=kept[i].trim();
      out += (t.startsWith('-') ? ' - ' + t.slice(1).trim()
                                : ' + ' + stripSign(t));
    }
    return out.replace(/\s+[+]\s+0\b/g,'').replace(/\s+[-]\s+0\b/g,'').trim();
  }

  function _gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }

  // mets le signe devant la fraction plut√¥t que dans le num√©rateur
  function moveSignOutOfFracNum(lx){
    const re = /\\dfrac\{\s*([+-])\s*(\d+)\s*\}\{\s*(x(?:\^\{\d+\})?)\s*\}/g;
    return String(lx||'').replace(re, (_m, sign, p, den) =>
      (sign === '-' ? '-' : '') + `\\dfrac{${p}}{${den}}`
    );
  }

  // 2/(2‚àöx) -> 1/‚àöx etc.
  function simplifySqrtHalf(lx){
    return String(lx||'').replace(/\\dfrac\{([+-]?\d+)\}\{2\\sqrt\{x\}\}/g, (_m, nStr) => {
      const n = parseInt(nStr,10);
      if (!Number.isFinite(n) || (n % 2)) return _m;
      const m = n/2;
      if (m === 1)  return '\\dfrac{1}{\\sqrt{x}}';
      if (m === -1) return '-\\dfrac{1}{\\sqrt{x}}';
      return `\\dfrac{${m}}{\\sqrt{x}}`;
    });
  }

  // \dfrac{p}{q}x^{n} etc.
  function simplifyFracIntXOverInt(lx){
    const re = /\\dfrac\{\s*([+-]?\d+)\s*x(?:\^\{(\d+)\})?\s*\}\{\s*([+-]?\d+)\s*\}/g;
    return String(lx||'').replace(re, (_m, pStr, exp, qStr)=>{
      let p = parseInt(pStr,10), q = parseInt(qStr,10);
      if(!Number.isFinite(p) || !Number.isFinite(q) || q===0) return _m;
      const neg = (p<0) ^ (q<0);
      p = Math.abs(p); q = Math.abs(q);
      const g = _gcd(p,q); p/=g; q/=g;
      const xpow = exp ? `x^{${exp}}` : 'x';
      if(q===1){
        const c = neg ? -p : p;
        if(c=== 1)  return xpow;
        if(c===-1)  return '-'+xpow;
        return `${c}${xpow}`;
      }
      const frac = `\\dfrac{${p}}{${q}}`;
      return (neg?'-':'') + frac + xpow;
    });
  }

  // \dfrac{p}{q} (sans x derri√®re)
  function simplifyDfracIntInt(lx){
    const re = /\\dfrac\{\s*([+-]?\d+)\s*\}\{\s*([+-]?\d+)\s*\}(\s*x(?:\^\{\d+\})?)?/g;
    return String(lx||'').replace(re, (_m, pStr, qStr, xpart='')=>{
      let p = parseInt(pStr,10), q = parseInt(qStr,10);
      if(!Number.isFinite(p) || !Number.isFinite(q) || q===0) return _m;
      const neg = (p<0) ^ (q<0); p=Math.abs(p); q=Math.abs(q);
      const g = _gcd(p,q); p/=g; q/=g;
      const xp = (xpart||'').trim();
      if(q===1){
        const c = neg ? -p : p;
        if(!xp) return String(c);
        if(c=== 1) return xp;
        if(c===-1) return '-'+xp;
        return String(c)+xp;
      }
      const core = `\\dfrac{${p}}{${q}}`;
      return (neg?'-':'') + core + (xp? xp : '');
    });
  }

  // nettoyer +-, --, etc.
  function tidySigns(lx){
    let s = String(lx||'');
    const M='[\\-‚àí]';
    s = s.replace(new RegExp('\\+\\s*'+M,'g'),' - ');
    s = s.replace(new RegExp(M+'\\s*'+M,'g'),' + ');
    s = s.replace(/\+\s*\+/g,' + ');
    return s.trim();
  }

  // virer "1x" / "-1x"
  function stripUnitCoeff(lx){
    let s = String(lx||'');
    s = s.replace(/(^|[+\-]\s*)1(?=x(\^\{\d+\})?)/g,'$1');
    s = s.replace(/(^|[+\-]\s*)-1(?=x(\^\{\d+\})?)/g,'$1-');
    return s;
  }

  function simplifyAll(lx){
    return tidySigns(
             stripUnitCoeff(
               simplifyDfracIntInt(
                 simplifyFracIntXOverInt(
                   simplifySqrtHalf(
                     moveSignOutOfFracNum(String(lx||''))
                   )
                 )
               )
             )
           );
  }

  /* ==== G√©n√©rateur : Produit par un r√©el d'une fonction de r√©f√©rence ==== */

  // k entier ‚â†0
  function pickCoef(){
    const vals=[-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9];
    return choice(vals);
  }

  // formateur pour k*x^n (n>=2) et k*x (identit√©)
  function make_k_x_pow_n(k,n){
    // f(x)
    let fLatex;
    if(n===1){
      // kx
      if(k===1) fLatex='x';
      else if(k===-1) fLatex='-x';
      else fLatex=`${k}x`;
    }else{
      // k x^n
      const absK = Math.abs(k);
      if(absK===1){
        fLatex = (k<0?'-':'') + `x^{${n}}`;
      }else{
        fLatex = `${k}x^{${n}}`;
      }
    }

    // d√©riv√©e symbolique brute (Application)
    // d/dx [k x^n] = k*n x^{n-1}
    const kn = k*n;
    let fpRaw;
    if(n-1===0){
      // cste
      fpRaw = String(kn);
    }else if(n-1===1){
      // k*n * x
      const absKN = Math.abs(kn);
      if(absKN===1){
        fpRaw = (kn<0?'-':'')+'x';
      }else{
        fpRaw = `${kn}x`;
      }
    }else{
      // k*n x^{n-1}
      const absKN = Math.abs(kn);
      if(absKN===1){
        fpRaw = (kn<0?'-':'')+`x^{${n-1}}`;
      }else{
        fpRaw = `${kn}x^{${n-1}}`;
      }
    }

    // r√®gle √† afficher
    const rulePow = "\\text{Si } f(x)=x^{n} \\text{ alors } f'(x)=n\\,x^{n-1}";
    const ruleProd = "\\text{Produit par un r√©el : } (k\\,u)'=k\\,u'";
    const ruleId   = "\\text{Si } f(x)=x \\text{ alors } f'(x)=1";

    const rules = [];
    if(n===1){
      rules.push([ruleId, ruleProd]);
    }else{
      rules.push([rulePow, ruleProd]);
    }

    return {
      title:"Exercice ‚Äî Produit par un r√©el",
      latexF: fLatex,
      latexFp_raw: fpRaw,
      latexFp: simplifyAll(fpRaw),
      rules,
      f: x => k*Math.pow(x,n),
      fp: x => k*n*Math.pow(x,n-1)
    };
  }

  // k * sqrt(x)
  function make_k_sqrt_x(k){
    // f(x) = k‚àöx
    let fLatex;
    if(k===1) fLatex="\\sqrt{x}";
    else if(k===-1) fLatex="-\\sqrt{x}";
    else fLatex = `${k}\\,\\sqrt{x}`;

    // d√©riv√©e brute : k * (1/(2‚àöx)) => k/(2‚àöx)
    const fpRaw = `\\dfrac{${k}}{2\\sqrt{x}}`;

    const ruleSqrt = "\\text{Si } f(x)=\\sqrt{x} \\text{ alors } f'(x)=\\dfrac{1}{2\\sqrt{x}}";
    const ruleProd = "\\text{Produit par un r√©el : } (k\\,u)'=k\\,u'";

    return {
      title:"Exercice ‚Äî Produit par un r√©el",
      latexF: fLatex,
      latexFp_raw: fpRaw,
      latexFp: simplifyAll(fpRaw),
      rules:[[ruleSqrt, ruleProd]],
      f: x => k*Math.sqrt(x),
      fp: x => k*(1/(2*Math.sqrt(x)))
    };
  }

  // k * (1/x)
  function make_k_inv_x(k){
    // f(x)=k/x
    let fLatex;
    if(k===1) fLatex="\\dfrac{1}{x}";
    else if(k===-1) fLatex="-\\dfrac{1}{x}";
    else fLatex=`\\dfrac{${k}}{x}`;

    // d√©riv√©e brute :
    // d/dx [k * 1/x] = k * (-1/x^2) = -(k)/x^2
    // On fabrique proprement une fraction avec le signe dehors.
    const num = -k;
    const absNum = Math.abs(num);
    let fpRaw;
    if(absNum===1){
      fpRaw = (num<0)
        ? "-\\dfrac{1}{x^{2}}"
        : "\\dfrac{1}{x^{2}}";
    }else{
      fpRaw = (num<0)
        ? `-\\dfrac{${absNum}}{x^{2}}`
        : `\\dfrac{${absNum}}{x^{2}}`;
    }

    const ruleInv = "\\text{Si } f(x)=\\dfrac{1}{x} \\text{ alors } f'(x)=-\\dfrac{1}{x^{2}}";
    const ruleProd= "\\text{Produit par un r√©el : } (k\\,u)'=k\\,u'";

    return {
      title:"Exercice ‚Äî Produit par un r√©el",
      latexF: fLatex,
      latexFp_raw: fpRaw,
      latexFp: simplifyAll(fpRaw),
      rules:[[ruleInv, ruleProd]],
      f: x => k*(1/x),
      fp: x => k*(-1/(x*x))
    };
  }

  function genProduitReel(){
    // Choix du type de fonction de r√©f√©rence
    // 0 : k*x^n (n>=2)
    // 1 : k*x (identit√©)
    // 2 : k*sqrt(x)
    // 3 : k*(1/x)
    const which = choice([0,1,2,3]);
    const k = pickCoef();

    if(which===0){
      const n = rnd(2,5); // x^2, x^3, x^4, x^5
      return make_k_x_pow_n(k,n);
    }
    if(which===1){
      return make_k_x_pow_n(k,1); // identit√©
    }
    if(which===2){
      return make_k_sqrt_x(k);
    }
    return make_k_inv_x(k); // which===3
  }

  /* ==== Affichage / V√©rification / Solution ==== */

  function buildHostHTML(st){
    const fClean = joinTermsNoZero([st.latexF]);
    return `
      <div class="card">
        <div><strong>Exercice :</strong> Soit la fonction \\(f\\) d√©finie par : \\(f(x)=${fClean}\\). <br>Donner sa fonction d√©riv√©e d√©finie par :</div>
        <div class="answers">
          <div class="qa-row">
            <label for="ansF"><strong>\\(f'(x)=\\)</strong></label>
            <input id="ansF" class="inp" style="min-width:360px">
            <span id="tickF" class="tick" style="margin-left:6px"></span>
          </div>
        </div>
      </div>
      <div id="res"></div>
    `;
  }

  function setTick(host, ok){
    const el = $('#tickF', host);
    if(!el) return;
    el.className = 'tick ' + (ok===true?'ok':ok===false?'ko':'');
    el.textContent = ok===true?'‚úì': ok===false?'‚úó':'‚Äî';
  }

  function checkAnswer(st, val){
    if(!val || !String(val).trim()) return null;
    if(typeof st?.fp !== 'function') return false;
    const xs = [1.2, 1.8, 2.5, 3.7, 5.1];
    try{
      for(const x of xs){
        const got = numEval(val, x);
        const ref = st.fp(x);
        if(!Number.isFinite(got) || !Number.isFinite(ref) || !almost(got, ref, 1e-6)) return false;
      }
      return true;
    }catch(_){ return false; }
  }

  function solutionHTML(st){
    const rows = [];
    const seen = new Set();

    (st.rules||[]).forEach(pair=>{
      const rule = pair[0]||'';
      if(rule && !seen.has(rule)) {
        rows.push(`<tr><td><em>R√®gle</em></td><td>\\(${rule}\\)</td></tr>`);
        seen.add(rule);
      }
    });

    // On ajoute toujours la r√®gle produit par un r√©el si elle est dans pair[1]
    (st.rules||[]).forEach(pair=>{
      const rule2 = pair[1]||'';
      if(rule2 && !seen.has(rule2)) {
        rows.push(`<tr><td><em>R√®gle</em></td><td>\\(${rule2}\\)</td></tr>`);
        seen.add(rule2);
      }
    });

    const fpRaw  = st.latexFp_raw || st.latexFp || '';
    const fpSimp = simplifyAll(fpRaw);

    // Application brute
    rows.push(`<tr><td><em>Application</em></td><td>\\(f'(x) = ${fpRaw}\\)</td></tr>`);

    // Ligne simplification seulement si √ßa change vraiment
    const showSimp = tidySigns(fpRaw) !== tidySigns(fpSimp);
    if (showSimp){
      rows.push(`<tr><td><em>Simplification</em></td><td>\\(f'(x) = ${fpSimp}\\)</td></tr>`);
    }

    return `
      <div class="steps">
        <table class="table xgap">
          <thead>
            <tr><th style="text-align:center">Justification</th><th style="text-align:center">√âcriture</th></tr>
          </thead>
          <tbody>${rows.join('')}</tbody>
        </table><br>
        <div class="line"><strong>Conclusion :</strong> \\(\\;f'(x) = ${fpSimp}\\).</div>
      </div>
    `;
  }

  /* ==== D√©finition unique de l'exercice ==== */

  const EXO_PROD = {
    id:'prod-reel',
    title:'Produit par un r√©el',
    gen(host){
	 let localHost = host, tempMade = false;
    if(!localHost){
      localHost = document.createElement('div');
      localHost.style.position='fixed';
      localHost.style.left='-10000px';
      localHost.style.top='-10000px';
      localHost.style.width='800px';
      localHost.style.zIndex='-1';
      document.body.appendChild(localHost);
      tempMade = true;
    }
      const st = genProduitReel();
 localHost.innerHTML = buildHostHTML(st);

    localHost.__state = st;
    localHost.dataset.state = JSON.stringify({
      latexF:      st.latexF,
      latexFp:     st.latexFp,
      latexFp_raw: st.latexFp_raw,
      rules:       st.rules || []
    });

    if(!tempMade && window.MathJax?.typeset) MathJax.typeset();

    if(tempMade){
      return {
        st,
        light:{
          latexF:      st.latexF,
          latexFp:     st.latexFp,
          latexFp_raw: st.latexFp_raw,
          rules:       st.rules || []
        },
        dom: localHost
      };
    }
  },
    correct(host, st){
      const val=$('#ansF',host)?.value||'';
      const ok=checkAnswer(st,val);
      scoreTot+= (val.trim()?1:0);
      scoreOK+= (ok?1:0);
      updateScore();
      setTick(host, val.trim()?ok:null);
    },
    solution(host, st){
      $('#res',host).innerHTML = solutionHTML(st);
      if (window.MathJax?.typeset) MathJax.typeset();
    },
    reset(host){
      $('#res',host).textContent='';
      setTick(host,null);
    }
  };

  const REG = [EXO_PROD];
  window.REG=REG;
  window.REGISTRY=REG;

  /* ==== Montage UI ==== */
  function mount(){
    const sel=$("#exo-select"); if(!sel) return;
    sel.innerHTML=REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

    function get(){ const id=sel.value||REG[0].id; return REG.find(e=>e.id===id)||REG[0]; }
    function newOne(){ const ex=get(); const host=$("#host"); ex.gen(host); scanFractions(host); }
    function check(){ const ex=get(); const host=$("#host"); ex.correct(host, host.__state); }
    function sol(){ const ex=get(); const host=$("#host"); ex.solution(host, host.__state); }
    function reset(){ const ex=get(); const host=$("#host"); ex.reset(host); }

    sel.onchange=newOne;
    $("#btn-new").onclick=newOne;
    $("#btn-check").onclick=check;
    $("#btn-solution").onclick=sol;
    $("#btn-reset").onclick=reset;
    document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

    sel.value=REG[0].id;
    newOne();
  }
  document.addEventListener('DOMContentLoaded', mount);
</script>

<!-- === Adaptateur PDF === -->
<script>
/* =========================================================
   Adaptateur PDF : version iframe SVG
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try {
          st = JSON.parse(hostTmp.dataset.state || '{}');
        } catch(_){}
        return st;
      },




      // >>>>>>>>>>>>> async PROMISE RETURN
  beforeRender(def, st, withSolutions){
  return (async () => {
    let host = null;
    try {

      // 1. Construire un host OFFSCREEN juste pour r√©cup√©rer l'√©tat (mais SANS typeset √©cran)
      host = document.createElement('div');
      host.id = 'pdf-host';
      host.style.position='fixed';
      host.style.left='-10000px';
      host.style.top='-10000px';
      document.body.appendChild(host);

      // on DOIT recr√©er l'enonc√© de base
      host.innerHTML = buildHostHTML(st);
      host.dataset.state = JSON.stringify(st);

      // üëâ‚ö† NE PAS appeler def.solution(host, st) ici,
      //    car √ßa MathJax-typeset en CHTML et flingue le LaTeX brut.

      // 2. Construire le HTML qu'on veut envoyer dans le PDF
      //    - si withSolutions === false : on prend juste l'√©nonc√© tel quel
      //    - si withSolutions === true  : on fabrique nous-m√™me un bloc
      //      qui contient st.solHTML (non encore typeset).
      // --- construire l'√©nonc√© en LaTeX √† partir de st ---
function enonceForPDF(st){
  // m√™me phrase que l'√©cran, mais en pur texte HTML
  // + une ligne de r√©ponse vide
  const fClean = st.latexF;
  return `
    <div class="exo-enonce">
      <div><strong>Exercice :</strong> Soit la fonction \\(f\\) d√©finie par : \\(f(x)=${fClean}\\).<br>
      Donner sa fonction d√©riv√©e d√©finie par :</div>
      <div style="margin-top:.6rem">
        \\(f'(x)=\\) 
      </div>
    </div>
  `;
}

// --- construire le corrig√© LaTeX exactement comme √† l'√©cran ---
function solForPDF(st){
  return `
    <div style="margin-top:1rem;font-weight:600">Corrig√© :</div>
    ${solutionHTML(st)}
  `;
}

let innerHTML_for_pdf;
if (withSolutions){
  innerHTML_for_pdf = `
    <div class="exo-block">
      ${enonceForPDF(st)}
      ${solForPDF(st)}
    </div>
  `;
} else {
  // juste l'√©nonc√© sans la zone de saisie HTML/input
  innerHTML_for_pdf = `
    <div class="exo-block">
      ${enonceForPDF(st)}
    </div>
  `;
}



      // 3. IFRAME sandbox pour MathJax SVG ...
      // (le reste de ton code continue comme avant)


      // 2. Cr√©er l'iframe sandbox
      const iframe = document.createElement('iframe');
      iframe.style.position   = 'fixed';
      iframe.style.left       = '-10000px';
      iframe.style.top        = '-10000px';
      iframe.style.width      = '0';
      iframe.style.height     = '0';
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);

      const iwin = iframe.contentWindow;
      const idoc = iframe.contentDocument;

      // 3. √âcrire un DOM minimal dans l'iframe
      // pas de <script> ici pour √©viter de casser notre propre <script> parent
      idoc.open();
      idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
      idoc.close();
// 4. Injecter le contenu (√©nonc√©/solution) dans l'iframe
const contentDiv = idoc.getElementById('content');
contentDiv.innerHTML = innerHTML_for_pdf;

// üîß IMPORTANT : on vire toute trace d'anciens rendus MathJax CHTML
// (dans le host original il y a d√©j√† des <mjx-container jax="CHTML">...</mjx-container> )
// On veut repartir du LaTeX brut pour que MathJax SVG refasse tout proprement.

contentDiv.querySelectorAll('mjx-container').forEach(mjx => {
  // On essaie de r√©cup√©rer le tex d'origine si MathJax l'a gard√© en commentaire,
  // sinon on remplace par juste le texte rendu (fallback).
  // Mais dans notre cas, comme l'innerHTML_for_pdf vient AVANT typeset dans l'iframe,
  // il devrait d√©j√† contenir le LaTeX source (\( ... \)). Donc en pratique,
  // ce bloc servira surtout si jamais un ancien mjx traine.
  mjx.replaceWith(mjx.textContent || '');
});

// Enlever aussi l'accessibilit√© MathML pr√©-existante (au cas o√π)
contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml')
  .forEach(n => n.remove());


      // 5. Pr√©parer MathJax SVG dans l'iframe
      //    a) script config MathJax
      const cfg = idoc.createElement('script');
      cfg.type = 'text/javascript';
      cfg.text = `
        window.MathJax = {
          tex: {
            inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
            displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
            processEscapes: true,
            packages: { '[+]': ['bbox','ams'] }
          },
          svg: {
            fontCache: 'none'
          },
          options: {
            skipHtmlTags: ['script','noscript','style','textarea']
          },
          startup: { typeset: false }
        };
      `;
      idoc.head.appendChild(cfg);

      //    b) script tex-svg.js (URL absolue pour √™tre s√ªr)
      const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
      const mj = idoc.createElement('script');
      mj.type = 'text/javascript';
      mj.src  = svgScriptURL;
      idoc.head.appendChild(mj);

// 6. Attendre que tex-svg.js soit charg√© puis typer
await new Promise(resolve=>{
  mj.onload = resolve;
  mj.onerror = resolve; // on r√©sout quand m√™me m√™me si √ßa plante
});

// s√©curit√©: attendre que MathJax initialise typesetPromise
async function waitMathJaxReady(win){
  const limit = 200;
  let n = 0;
  while (
    (!win.MathJax) ||
    (!win.MathJax.typesetPromise && !win.MathJax.typeset)
  ){
    await new Promise(res=>setTimeout(res,5));
    n++;
    if(n>limit) break;
  }
}
await waitMathJaxReady(iwin);

// 7. Faire le typeset SVG dans l'iframe
if (iwin.MathJax && iwin.MathJax.typesetPromise){
  await iwin.MathJax.typesetPromise([ contentDiv ]);
} else if (iwin.MathJax && iwin.MathJax.typeset){
  iwin.MathJax.typeset([ contentDiv ]);
}

// 8. *** NETTOYAGE ANTI-DOUBLON ***
//    On enl√®ve la version CHTML h√©rit√©e de l'√©cran et on garde la version SVG.
(function purgeCHTML(){
  // 1. Supprimer les conteneurs CHTML de l'√©cran s'ils existent
  //    (dans ta page √©cran, MathJax CHTML g√©n√®re <mjx-container jax="CHTML"> ...)
  contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n => n.remove());

  // 2. Certains contenus d'origine peuvent encore contenir du texte LaTeX brut
  //    suivi d'un conteneur SVG g√©n√©r√©. Ex :
  //      "f'(x)=" <mjx-container jax="SVG">...</mjx-container>
  //    ‚Üí √ßa va, on garde.

  // 3. Option belt & suspenders :
  //    Si jamais MathJax SVG a clon√© au lieu de remplacer, on vire les doublons restants
  //    du type <mjx-container jax="CHTML"> m√™me imbriqu√©s.
  contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n => n.remove());

  // 4. On enl√®ve les aides d‚Äôaccessibilit√© inutiles pour le PDF
  contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n => n.remove());
})();

// 9. R√©cup√©rer le HTML final (ne contenant plus que le SVG)
const finalHTML = contentDiv.innerHTML;

// 10. Nettoyage DOM temporaire
iframe.remove();
if (host) host.remove();

// 11. Retourner le HTML pr√™t pour le PDF
return finalHTML;


    } catch(e){
      console.error('beforeRender SVG error:', e);

      let fallbackHTML = '';
      if (host) {
        fallbackHTML = withSolutions
          ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
          : host.innerHTML;
        host.remove();
        host = null;
      }
      return fallbackHTML;
    }
  })(); // IIFE async
}

    }); // <-- FERMETURE ExoPDF.init
  }); // <-- FERMETURE addEventListener DOMContentLoaded
})(); // <-- FERMETURE IIFE global
</script>



<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
