<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì √âcritures fractionnaires (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css"><!-- m√™me fichier que ta page LaTeX -->
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap;margin-left:auto}
.small{font-size:.92rem;color:#666}

/* consigne (√©cran) */
.consigne .c-label{font-weight:600; margin-right:.35em}

/* grille : √©nonc√© + saisie en haut, correction en bas */
.row{
  display:grid;
  grid-template-columns:1fr minmax(260px,340px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px; align-items:start;
}
.row .col-label{grid-area:lab}
.row .input-line{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

/* case gris√©e correction */
#host #res .steps,
#host #res .steps--two{
  background:#f2f3f5;border:1px solid #e6e6e6;border-radius:10px;
  padding:.6rem .75rem;margin-top:.25rem;
}
#host #res .step{white-space:nowrap}

/* 2 colonnes (si besoin) */
.steps--two{
  display:grid;
  grid-template-columns:max-content 0.33ch minmax(240px,1fr);
  gap:0; align-items:start;
}
.steps--two .spacer-3ch{width:0.33ch}
.note-box{padding:0;border:none;background:transparent;font-size:.92rem}

/* √©nonc√© pour PDF */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;}
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
  /* Ne pas afficher "Consigne :" dans le PDF */
  .equ-offscreen .c-label{display:none !important;}
}

.hint{opacity:.9;margin:.2rem 0 .6rem}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;border:1px dashed #e3e3e3;border-radius:8px;background:#fafafa}
</style>

<!-- MathJax (LaTeX) ‚Äî m√™me config que ¬´ exercices - Latex.html ¬ª -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$','$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      // Petit raccourci utile
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: {
      // On ne saute PAS <code>/<pre> : on veut tout rendre
      skipHtmlTags: ['script','noscript','style','textarea']
    },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script>
  window.MathJax = {
    loader: { load: ['[tex]/color'] },
    tex: { packages: { '[+]': ['color'] }, inlineMath: [['\\(','\\)']] }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì <strong>√âcritures fractionnaires</strong></h1>
  </div>

  <div class="wrap">

    <!-- barre -->
    <div class="card controls">
      <label for="exo-select">Type d‚Äôexercice :</label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn" title="G√©n√®re un nouvel √©nonc√© (m√™me type)">üîÅ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn" title="V√©rifie votre r√©ponse">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn" title="Affiche la correction et pr√©-remplit la r√©ponse">üß† Solution</button>
      <button id="btn-reset" class="btn" title="Remet le score √† z√©ro et vide la saisie">üßπ R√©initialiser</button>

      <div class="score" id="score" title="R√©ussites / Tentatives">0 / 0</div>
    </div>

    <!-- zone exercice -->
    <div class="card">
      <div id="host"><!-- host-inner inject√© par JS --></div>
    </div>

    <!-- aide saisie -->
    <div class="card small">
      <div class="small"><strong>Saisie &amp; r√©ponses accept√©es :</strong></div>
      <ul class="tips">
        <li>R√©pondez sous forme de fraction <code>a/b</code> (ou entier si possible).</li>
        <li><strong>R√®gles des signes :</strong> on s‚Äôoccupe de compter les ¬´ ‚àí ¬ª d‚Äôabord :
          <ul>
            <li>Si le nombre est pair, il n‚Äôy a plus de ¬´ ‚àí ¬ª dans le calcul.</li>
            <li>Si le nombre est impair, il y a un seul ¬´ ‚àí ¬ª devant la fraction dans le calcul.</li>
          </ul>
        </li>
        <li><strong>PPCM (m√©thode coll√®ge)</strong> : pour chaque <strong>d√©nominateur</strong> <strong>d</strong> (celui de la fraction consid√©r√©e, <em>pas forc√©ment le plus petit</em>), lister ses multiples et s‚Äôarr√™ter d√®s le <strong>premier multiple commun</strong> (le plus petit). Astuce : commencer √† <code>2√ód</code> acc√©l√®re la recherche, mais si le PPCM vaut d√©j√† <code>d</code>, la liste peut commencer par <code>d</code>.</li>
        <li><strong>PGCD (m√©thode coll√®ge)</strong> : lister les diviseurs de chaque nombre puis prendre le <strong>plus grand commun</strong> (s‚Äôil vaut 1, les nombres sont <em>premiers entre eux</em> : <strong>aucun diviseur commun autre que 1</strong>).</li>
      </ul>
    </div>

    <!-- Clavier math, centr√© -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>

  </div>

<script>
(function(){'use strict';
/* ===== helpers ===== */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
// Couleur s√ªre (n√©cessite MathJax [tex]/color)
const C = v => `\\textcolor{#c62828}{${v}}`;

// Produit sans ‚Äú√ó 1‚Äù
const mulTex = (arr)=>{
  const a = (arr||[]).filter(v => v !== 1 && v !== '1' && v != null && v !== '');
  return a.length ? a.join(' \\times ') : '1';
};
const dfrac = (num, den) => `\\dfrac{${num}}{${den}}`;

/* ---- COMPTAGE DES FACTEURS COMMUNS ---- */
function _commonCounts(nums, dens){
  const ca={}, cb={};
  nums.forEach(v=>{ const k=String(v); ca[k]=(ca[k]||0)+1; });
  dens.forEach(v=>{ const k=String(v); cb[k]=(cb[k]||0)+1; });
  const com={};
  Object.keys(ca).forEach(k=>{
    const m=Math.min(ca[k], cb[k]||0);
    if(m>0) com[k]=m;
  });
  return com;
}
function _applyColorByCounts(arr, com){
  const used={};
  return arr.map(v=>{
    const k=String(v);
    const u=used[k]||0;
    if((com[k]||0)>u){ used[k]=u+1; return C(v); }
    return String(v);
  });
}

/* Produit "√† plat" color√© : num=[|n1|,|n2|], den=[|d1|,|d2|] */
function flatProductColored(n1,n2,d1,d2){
  const num=[Math.abs(n1), Math.abs(n2)];
  const den=[Math.abs(d1), Math.abs(d2)];
  const com=_commonCounts(num, den);
  const numC=_applyColorByCounts(num, com);
  const denC=_applyColorByCounts(den, com);
  return dfrac(mulTex(numC), mulTex(denC));
}

function decompFactorsByGCDs(n1,n2,d1,d2,gA,gB){
  const n1a=Math.abs(n1), n2a=Math.abs(n2), d1a=Math.abs(d1), d2a=Math.abs(d2);
  const num=[], den=[];

  // Paire A : n1 ‚Üî d2
  if(gA>1){
    if(n1a===d2a){
      num.push(n1a); den.push(d2a);
    }else{
      num.push(gA); if(n1a/gA!==1) num.push(n1a/gA);
      den.push(gA); if(d2a/gA!==1) den.push(d2a/gA);
    }
  }else{
    num.push(n1a); den.push(d2a);
  }

  // Paire B : n2 ‚Üî d1 (ici on √©vite le "18" en for√ßant une factorisation par d2 si possible)
  if(gB>1){
    if(n2a===d1a){
      num.push(n2a); den.push(d1a);
    }else{
      if(n2a/gB!==1) num.push(n2a/gB);
      num.push(gB);

      den.push(gB);
      let rest = d1a / gB; // ex. 90/5 = 18
      if(rest !== 1){
        if(rest % d2a === 0){
          const k = rest / d2a;   // ex. 18/9 = 2
          if(k !== 1) den.push(k);
          den.push(d2a);          // ex. ... √ó 9
        }else{
          den.push(rest);         // pas divisible : on garde tel quel
        }
      }
    }
  }else{
    num.push(n2a); den.push(d1a);
  }

  return {num, den};
}


/* D√©composition color√©e (applique la r√®gle "min des comptes" sur TOUS les facteurs) */
function decompColoredProduct(n1,n2,d1,d2,gA,gB){
  const {num, den} = decompFactorsByGCDs(n1,n2,d1,d2,gA,gB);
  const com=_commonCounts(num, den);
  const numC=_applyColorByCounts(num, com);
  const denC=_applyColorByCounts(den, com);
  return dfrac(mulTex(numC), mulTex(denC));
}





/* ====== MathJax utils (comme dans ¬´ exercices - Latex.html ¬ª) ====== */
function typesetAll(scope){
  try{
    if(window.MathJax && MathJax.typesetPromise){
      return MathJax.typesetPromise(scope ? [scope] : undefined).catch(()=>{});
    }
  }catch(_e){}
  return Promise.resolve();
}

/* ==== PARSE SAISIE STRICTE (entier ou a/b ; accepte U+2212) ==== */
function parseFracInputStrict(raw){
  const s = String(raw||'').trim().replace(/\u2212/g,'-').replace(/\s+/g,'');
  if(!s) return null;

  const mFrac = s.match(/^([+-]?\d+)\/([+-]?\d+)$/);
  if (mFrac){
    let p = parseInt(mFrac[1],10), q = parseInt(mFrac[2],10);
    if(q === 0) return null;
    if(q < 0){ p = -p; q = -q; }
    const g = gcd(Math.abs(p), Math.abs(q));
    return { type:'frac', p, q, irr:(g===1), red:{ p:p/g, q:q/g } };
  }

  const mInt = s.match(/^([+-]?\d+)$/);
  if (mInt){
    const p = parseInt(mInt[1],10);
    return { type:'int', p, q:1, irr:true, red:{ p, q:1 } };
  }
  return null; // tout le reste est refus√©
}

/* host-inner */
function innerHost(root){
  let n=root.querySelector('.host-inner');
  if(!n){ n=document.createElement('div'); n.className='host-inner'; root.innerHTML=''; root.appendChild(n); }
  return n;
}

/* ==== arith fractions ==== */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function lcm(a,b){ return Math.abs(a*b)/gcd(a,b); }
function norm(p,q){ if(q===0) throw new Error("denominator 0"); let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; } return {p,q}; }
const makeR=(p,q)=>norm(p,q||1);
const addR=(A,B)=>norm(A.p*B.q+B.p*A.q, A.q*B.q);
const subR=(A,B)=>norm(A.p*B.q-B.p*A.q, A.q*B.q);
const mulR=(A,B)=>norm(A.p*B.p, A.q*B.q);
const divR=(A,B)=>norm(A.p*B.q, A.q*B.p);
const isEqualR=(A,B)=>A.p===B.p && A.q===B.q;

/* ====== LaTeX helpers (plus AUCUNE fraction HTML) ====== */
const wrap = s => `\\(${s}\\)`;
function fracTex(p,q){
  let sgn = (p*q<0) ? '-' : '';
  p=Math.abs(p); q=Math.abs(q);
  if(q===1) return sgn + String(p);
  return `${sgn}\\dfrac{${p}}{${q}}`;
}
const exprFracTex = R => fracTex(R.p,R.q);
function parenFracTex(R){
  const neg = R.p*R.q<0 && R.q!==1;
  const core = fracTex(R.p,R.q);
  return neg ? `\\left(${core}\\right)` : core;
}
const fmtInt=n=>(n<0?`-${Math.abs(n)}`:String(n));
function fracProdTex(n1,n2,d1,d2){
  const f=v=> (v<0?`\\left(-${Math.abs(v)}\\right)` : String(v));
  return `\\dfrac{${f(n1)}\\times ${f(n2)}}{${f(d1)}\\times ${f(d2)}}`;
}
function fracProdTex_g(g, p1, q1){
  // on n‚Äôessaie pas de colorer : lisible et 100% LaTeX
  return `\\dfrac{${g}\\times ${p1}}{${g}\\times ${q1}}`;
}
function fracProdTex_cancel(n1,n2,d1,d2){
  // version simple sans surlignage (tout LaTeX)
  const f=v=> (v<0?`\\left(-${Math.abs(v)}\\right)` : String(v));
  return `\\dfrac{${f(n1)}\\times ${f(n2)}}{${f(d1)}\\times ${f(d2)}}`;
}

/* normalisation signes (texte hors LaTeX) ‚Äì conserv√© */
function normalizeSigns(html){
  const parts=String(html).split(/(<[^>]+>)/g);
  for(let i=0;i<parts.length;i++){
    const s=parts[i]; if(!s||s.startsWith('<')) continue;
    let t=s;
    t=t.replace(/\+\s*[‚àí-]\s*/g,' ‚àí ').replace(/[‚àí-]\s*\+\s*/g,' ‚àí ');
    t=t.replace(/[‚àí-]\s*[‚àí-]\s*/g,' + ');
    t=t.replace(/([√ó√∑])\s*[‚àí-]\s*([0-9]+(?:[.,][0-9]+)?)/g,(_m,op,num)=>`${op} (‚àí${num})`);
    t=t.replace(/([√ó√∑])\s*[‚àí-]\s*([a-zA-Z]\w*)/g,(_m,op,v)=>`${op} (‚àí${v})`);
    t=t.replace(/\s{2,}/g,' ').trim();
    parts[i]=t;
  }
  return parts.join('');
}

/* ===== d√©dup robuste ===== */
function stripTags(s){ return String(s).replace(/<[^>]*>/g, ''); }

const NEED_F_PREFIX=new Set(['reduce','addsub','muldiv','dec2frac','pct2frac','part-total']);
function addFprefixLine(str){
  const s = String(str);

  // Pas de "F =" pour ces lignes
  if (/(?:^|\s)(PPCM|PGCD)\s*\(/.test(s)) return s;

  // Retire un √©ventuel "= ..." au d√©but
  let t = s.replace(/^\s*=\s*/,'').trimStart();

  // D√©j√† au bon format -> ne rien faire
  if (/^\\\(F\s*=/.test(t) || /^\\\[F\s*=/.test(t)) return t;

  // Si t est d√©j√† un bloc LaTeX \( ... \) ou \[ ... \], on fusionne
  const mInline = t.match(/^\\\(([\s\S]*)\\\)$/);
  if (mInline) return `\\(F = ${mInline[1].trimStart()}\\)`;

  const mDisplay = t.match(/^\\\[([\s\S]*)\\\]$/);
  if (mDisplay) return `\\[F = ${mDisplay[1].trimStart()}\\]`;

  // Sinon, on cr√©e un seul bloc inline
  return `\\(F = ${t}\\)`;
}

function isLatex(s){ return /\\\(|\\\[|\\begin\{|\\dfrac|\\frac|\\times|\\div|\\color/.test(String(s)); }

function stepsHTML_F(defId, lines){
  const out = [], seen = new Set();
  for(const L of lines){
    const obj = (typeof L==='object' && L) ? L : { text:String(L) };
    const withF = NEED_F_PREFIX.has(defId) && !obj.noF ? addFprefixLine(obj.text) : obj.text;
    const key   = stripTags(String(withF)).replace(/\s+/g,' ').trim();
    if(seen.has(key)) continue; seen.add(key);
    out.push(`<div class="step">${isLatex(withF) ? withF : normalizeSigns(withF)}</div>`);
  }
  return `<div class="steps">${out.join('')}</div>`;
}


function stepsHTML_F_2col(defId, leftLines, notesRight){
  const outL = [], outR = [];
  const seenL = new Set(), seenR = new Set();

  for(const L of leftLines){
    const obj = (typeof L==='object' && L) ? L : { text:String(L) };
    const withF = NEED_F_PREFIX.has(defId) && !obj.noF ? addFprefixLine(obj.text) : obj.text;
    const key = stripTags(normalizeSigns(withF)).replace(/\s+/g,' ').trim();
    if(seenL.has(key)) continue;
    seenL.add(key);
    outL.push(`<div class="step">${withF}</div>`);
  }
  for(const R of (notesRight||[])){
    const txt = String(R);
    const key = stripTags(normalizeSigns(txt)).replace(/\s+/g,' ').trim();
    if(seenR.has(key)) continue;
    seenR.add(key);
    outR.push(`<div class="step">${txt}</div>`);
  }
  return `<div class="steps--two"><div class="col-left">${outL.join('')}</div><div class="spacer-3ch"></div><div class="note-box">${outR.join('')}</div></div>`;
}

/* aides ‚Äúcoll√®ge‚Äù */
function listDivisors(n){
  n=Math.abs(n); if(n===0) return [0];
  const ds=[]; for(let i=1;i<=Math.sqrt(n);i++){ if(n%i===0){ ds.push(i); if(i*i!==n) ds.push(n/i); } }
  return ds.sort((a,b)=>a-b).map(x=>Math.round(x));
}
function formatDivisorsUpToG(n, g){
  const dsAll = listDivisors(n).filter(x => x <= g);
  const ds = dsAll.length ? dsAll : [g];
  return ds.map(x => x===g ? `<span style="color:#c62828;font-weight:700">${x}</span>` : String(x)).join(' ; ');
}
function formatMultiplesTo(d, L){
  const out = [];
  for(let k=2; k*d <= L; k++){
    const v = k*d;
    out.push(v===L ? `<span style="color:#c62828;font-weight:700">${v}</span>` : String(v));
  }
  if (!out.length || !out.join(' ; ').includes(String(L))) {
    out.push(`<span style="color:#c62828;font-weight:700">${L}</span>`);
  }
  return out.join(' ; ');
}

function renderRow(host, consigneText, labelLatex, placeholder="ex.  3/4", prefixLabel=""){
  const root=innerHost(host); root.innerHTML="";

  // consigne (√©cran)
  const hint=document.createElement('div'); hint.className="hint consigne";
  hint.innerHTML=`<span class="c-label">Consigne :</span> <span class="c-text">${consigneText}</span>`;
  root.appendChild(hint);

  // bloc offscreen pour PDF
  const off=document.createElement('div'); off.className="equ-offscreen";
  const needWrap = !(/\\\(|\\\[|<[^>]+>/.test(labelLatex));  // ‚áê d√©j√† LaTeX ou HTML ?
  off.innerHTML = `<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">${consigneText}</span></div>
                   <div class="equation">${needWrap ? wrap(labelLatex) : labelLatex}</div>`;
  root.appendChild(off);

  // ligne interactive
  const row=document.createElement("div"); row.className="row";
  const lab=document.createElement("div"); lab.className="col-label";
  lab.innerHTML = needWrap ? wrap(labelLatex) : labelLatex;   // ‚áê pas de double wrap
  row.appendChild(lab);

  const inpLine=document.createElement('div'); inpLine.className='input-line';
  if(prefixLabel){ const pref=document.createElement('span'); pref.className='input-prefix'; pref.textContent=prefixLabel; inpLine.appendChild(pref); }
  const inp=document.createElement('input'); inp.type="text"; inp.id="reponse"; inp.placeholder=placeholder; inpLine.appendChild(inp);
  row.appendChild(inpLine);

  const res=document.createElement('div'); res.id='res'; row.appendChild(res);
  root.appendChild(row);

  typesetAll(root);
  return {inp,res,root,row,lab,off};
}


/* ========= Exercices ========= */
/* 1 ‚Äî R√©duire (irr√©ductible) */
const ex1={
  id:"reduce", title:"R√©duire une fraction (irr√©ductible)",
  gen(){
    const denom=[6,8,9,10,12,14,15,16,18,20,21,24];
    const p0=rnd(-12,12)*choice([2,3,4,5]);
    const q0=choice(denom);
    const given={p:p0,q:q0}, expected=makeR(p0,q0);
    return {given, expected};
  },
  text(st){ return `F = ${exprFracTex(st.given)}`; },
  render(host, st){ renderRow(host, "√âcrire sous forme irr√©ductible :", this.text(st)); },
  correct(host, st){
  const parsed = parseFracInputStrict(($("#reponse",host).value||""));
  let ok = false, msg = "";

  if(parsed && isEqualR(parsed.red, st.expected)){
    if(parsed.type==='frac' && !parsed.irr){
      msg = "Tu peux encore r√©duire la fraction.";
    }else{
      ok = true;
    }
  }

  $("#res",host).innerHTML = ok ? "‚úî" : (msg || `${wrap(`F = ${exprFracTex(st.expected)}`)}`);
  $("#res",host).className  = ok ? "res-ok" : "res-ko";
  typesetAll($("#res",host));
  return {ok,total:1};
},
  solution(host, st){
    const a=Math.abs(st.given.p), b=Math.abs(st.given.q), g=gcd(a,b);
    const p1=st.given.p/g, q1=st.given.q/g;
    const dA=formatDivisorsUpToG(a, g), dB=formatDivisorsUpToG(b, g);
    const steps = [
      {text:`Diviseurs de ${a} : ${dA}`, noF:true},
      {text:`Diviseurs de ${b} : ${dB}`, noF:true},
      {text:`PGCD(${a} ; ${b}) = <span style="color:#c62828;font-weight:700">${g}</span>${g===1 ? ' ‚Äî Les deux nombres sont premiers entre eux : aucun diviseur commun autre que 1.' : ''}`, noF:true},
      wrap(`${exprFracTex(st.given)}`),
      ...(g>1 ? [
        wrap(`${fracProdTex_g(g, p1, q1)}`),
        wrap(`${exprFracTex({p:p1,q:q1})}`)
      ] : [{text:`La fraction est d√©j√† irr√©ductible.`, noF:true}])
    ];
    $("#res",host).innerHTML=stepsHTML_F('reduce', steps);
    typesetAll($("#res",host));
    $("#reponse",host).value=(st.expected.q===1? String(st.expected.p) : `${st.expected.p}/${st.expected.q}`);
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 2 ‚Äî Addition / Soustraction (PPCM) */
const ex2={
  id:"addsub", title:"Addition / Soustraction",
  gen(){
    const A=makeR(rnd(-99,99), rnd(2,30)), B=makeR(rnd(-99,99), rnd(2,30));
    const op=Math.random()<0.5?'+':'‚àí';
    const res=(op==='+')?addR(A,B):subR(A,B);
    const L=lcm(A.q,B.q);
    const a1=A.p*(L/A.q), b1=B.p*(L/B.q), raw={p:(op==='+')?a1+b1:a1-b1,q:L};
    return {A,B,op,res,L,a1,b1,raw};
  },
  text(st){
    const Bneg=st.B.p<0;
    const opDisp=(st.op==='+'&&Bneg)?'‚àí':(st.op==='‚àí'&&Bneg)?'+':st.op;
    const Babs={p:Math.abs(st.B.p),q:st.B.q};
    const left = `${exprFracTex(st.A)}`;
    const right = `${exprFracTex(Bneg?Babs:st.B)}`;
    const mid = (opDisp==='+'?'+':'‚àí');
    return `F =${left} ${mid} ${right}`;
  },
  render(host, st){ renderRow(host, "Calculer et donner une √©criture irr√©ductible :", this.text(st)); },
  correct(host, st){
  const parsed = parseFracInputStrict(($("#reponse",host).value||""));
  let ok=false, msg="";

  if(parsed && isEqualR(parsed.red, st.res)){
    if(parsed.type==='frac' && !parsed.irr){
      msg = "Tu peux encore r√©duire la fraction.";
    }else{
      ok = true;
    }
  }

  $("#res",host).innerHTML = ok ? "‚úî" : (msg || `${wrap(`F = ${exprFracTex(st.res)}`)}`);
  $("#res",host).className  = ok ? "res-ok" : "res-ko";
  typesetAll($("#res",host));
  return {ok,total:1};
},
  solution(host, st){
    const A=st.A, B=st.B, L=st.L;
    const multA=formatMultiplesTo(A.q, L);
    const multB=formatMultiplesTo(B.q, L);
    const Bneg=B.p<0;
    const opDisp=(st.op==='+'&&Bneg)?'‚àí':(st.op==='‚àí'&&Bneg)?'+':st.op;
    const Bdisp=Bneg?{p:Math.abs(B.p),q:B.q}:B;
    const lines=[
      {text:`Multiples de ${A.q} : ${multA}`, noF:true},
      {text:`Multiples de ${B.q} : ${multB}`, noF:true},
      {text:`PPCM(${A.q} ; ${B.q}) = <span style="color:#c62828;font-weight:700">${L}</span>`, noF:true},
      wrap(`${exprFracTex(A)} ${opDisp==='+'?'+':'‚àí'} ${exprFracTex(Bdisp)}`),
      wrap(`${fracProdTex(A.p, (L/A.q), A.q, (L/A.q))} ${opDisp==='+'?'+':'‚àí'} ${fracProdTex(Bdisp.p, (L/B.q), B.q, (L/B.q))}`),
      wrap(`${exprFracTex({p:st.a1,q:L})} ${opDisp==='+'?'+':'‚àí'} ${exprFracTex({p:(Bneg?Math.abs(st.b1):st.b1),q:L})}`),
      wrap(`${exprFracTex(st.raw)}`),
      ...(isEqualR(makeR(st.raw.p, st.raw.q), st.res) ? [] : [wrap(`${exprFracTex(st.res)}`)])
    ];
    $("#res",host).innerHTML=stepsHTML_F('addsub', lines);
    typesetAll($("#res",host));
    $("#reponse",host).value=(st.res.q===1? String(st.res.p) : `${st.res.p}/${st.res.q}`);
  },
  reset: ex1.reset
};

const ex3={
  id:"muldiv", title:"Produit / Quotient",
  gen(){
    const A = makeR(rnd(-99,99), rnd(2,100));
    const op = Math.random() < 0.5 ? '√ó' : '√∑';
    let B = makeR(rnd(-9,9), rnd(2,10));
    if (op === '√∑') { while (B.p === 0) B = makeR(rnd(-9,9), rnd(2,10)); }

    const res = (op === '√ó') ? mulR(A,B) : divR(A,B);
    const n1=A.p, d1=A.q, n2=(op==='√ó')?B.p:B.q, d2=(op==='√ó')?B.q:B.p;

    const gA=gcd(Math.abs(n1),Math.abs(d2)); // commun n1 ‚Üî d2
    const gB=gcd(Math.abs(n2),Math.abs(d1)); // commun n2 ‚Üî d1

    const n1r=n1/gA, d2r=d2/gA, n2r=n2/gB, d1r=d1/gB; // r√©ductions partielles
    const raw={p:n1r*n2r, q:d1r*d2r}, irre=makeR(raw.p, raw.q);
    return {A,B,op,res,n1,n2,d1,d2,gA,gB,n1r,n2r,d1r,d2r,raw,irre};
  },
  text(st){
    return (st.op==='√ó')
      ? `F =${exprFracTex(st.A)} \\times ${parenFracTex(st.B)}`
      : `F =${exprFracTex(st.A)} \\div ${parenFracTex(st.B)}`;
  },
  render(host, st){ renderRow(host, "Calculer et donner une √©criture irr√©ductible :", this.text(st)); },
  correct(host, st){
    const parsed = parseFracInputStrict(($("#reponse",host).value||""));
    let ok=false, msg="";
    if(parsed && isEqualR(parsed.red, st.irre)){
      if(parsed.type==='frac' && !parsed.irr) msg="Tu peux encore r√©duire la fraction.";
      else ok = true;
    }
    $("#res",host).innerHTML = ok ? "‚úî" : (msg || `${wrap(`F = ${exprFracTex(st.irre)}`)}`);
    $("#res",host).className  = ok ? "res-ok" : "res-ko";
    typesetAll($("#res",host));
    return {ok,total:1};
  },
  solution(host, st){
  const first = (st.op==='√ó')
    ? `${exprFracTex(st.A)} \\times ${parenFracTex(st.B)}`
    : `${exprFracTex(st.A)} \\div ${parenFracTex(st.B)}`;
  const invLine = (st.op==='√∑')
    ? `${exprFracTex(st.A)} \\times ${parenFracTex({p:st.B.q,q:st.B.p})}`
    : null;

  // signe global appliqu√© √† chaque fraction/mise en √©vidence
  const neg = [st.n1, st.n2, st.d1, st.d2].filter(x=>x<0).length % 2 === 1;
  const S = s => neg ? `-${s}` : s;

  const n1a=Math.abs(st.n1), n2a=Math.abs(st.n2), d1a=Math.abs(st.d1), d2a=Math.abs(st.d2);
  const hasCommon = (st.gA>1 || st.gB>1);
  const eqA = st.gA>1 && n1a===d2a;   // m√™me nombre n1/d2
  const eqB = st.gB>1 && n2a===d1a;   // m√™me nombre n2/d1
  const exactSame = eqA || eqB;
  const multiples = hasCommon && !exactSame;
  const noCommon  = !hasCommon;

  const prodSimple   = S( dfrac(mulTex([n1a, n2a]), mulTex([d1a, d2a])) );
  const flatColored  = S( flatProductColored(st.n1, st.n2, st.d1, st.d2) );
  const decompColor  = S( decompColoredProduct(st.n1, st.n2, st.d1, st.d2, st.gA, st.gB) );
  const reducedProd  = S( dfrac(mulTex([Math.abs(st.n1r), Math.abs(st.n2r)]),
                                mulTex([Math.abs(st.d1r), Math.abs(st.d2r)])) );
  const finalLine    = exprFracTex(st.irre);

  const lines=[
    {text:`On s‚Äôoccupe de compter les " ‚àí " d‚Äôabord :`, noF:true},
    {text:`‚Ä¢ Si le nombre est pair, il n‚Äôy a plus de " ‚àí " dans le calcul`, noF:true},
    {text:`‚Ä¢ Si le nombre est impair, il y a un seul " ‚àí " devant la fraction dans le calcul`, noF:true},
    wrap(first),
    ...(invLine ? [{text:'‚Äî Diviser par un nombre revient √† multiplier par son inverse.', noF:true}, wrap(invLine)] : []),

    // Branches demand√©es
    ...(exactSame
      // m√™mes nombres en face : colorier directement sur la ligne "√† plat", puis r√©sultat
      ? [ wrap(flatColored), wrap(finalLine) ]
      : multiples
        // multiples : d√©composer (gA/gB), colorier par comptage, r√©duire, r√©sultat
        ? [ wrap(decompColor), wrap(reducedProd), wrap(finalLine) ]
        // aucun commun : produit simple, r√©sultat
        : [ wrap(prodSimple), wrap(finalLine) ]
    )
  ];

  $("#res",host).innerHTML=stepsHTML_F('muldiv', lines);
  typesetAll($("#res",host));
  $("#reponse",host).value=(st.irre.q===1? String(st.irre.p) : `${st.irre.p}/${st.irre.q}`);
},


  reset: ex1.reset
};



/* 4 ‚Äî D√©cimal ‚Üí n/10^k */
const ex4={
  id:"dec2frac", title:"√âcrire un d√©cimal sous forme n/10^k",
  gen(){
    const denomPow=choice([10,100,1000,10000]);
    const sgn=choice([1,-1]);
    let n; do{ n=rnd(1,20*denomPow-1)*sgn; }while(n%denomPow===0);
    const val=n/denomPow; return {value:val, denomPow, num:n};
  },
  text(st){ return `F =${String(st.value).replace('.',',')}`; },
render(host, st){
  renderRow(host,
    "√âcrire sous la forme \\(\\dfrac{n}{10^{k}}\\) (pas de virgule) :",
    this.text(st)
  );
},

  correct(host, st){
  const raw = ($("#reponse",host).value||"").replace(/\u2212/g,'-').trim();
  const m = raw.match(/^([-+]?\d+)\s*\/\s*(10|100|1000|10000)$/);
  const ok = !!m && (parseInt(m[1],10)===st.num) && (parseInt(m[2],10)===st.denomPow);
  $("#res",host).innerHTML = ok ? "‚úî" : wrap(` ${fracTex(st.num, st.denomPow)}`);
  $("#res",host).className  = ok ? "res-ok" : "res-ko";
  typesetAll($("#res",host));
  return {ok,total:1};
},
  solution(host, st){
    const lines=[ wrap(` ${String(st.value).replace('.',',')}`), wrap(` ${fracTex(st.num, st.denomPow)}`) ];
    $("#res",host).innerHTML=stepsHTML_F('dec2frac', lines);
    typesetAll($("#res",host));
    $("#reponse",host).value=`${st.num}/${st.denomPow}`;
  },
  reset: ex1.reset
};

/* 5 ‚Äî Comparer deux fractions */
const ex5={
  id:"compare", title:"Comparer deux fractions",
  gen(){
    const A=makeR(rnd(-9,9), rnd(2,10)), B=makeR(rnd(-9,9), rnd(2,10));
    if(A.p*B.q===B.p*A.q){ A.p += (A.p>0?1:-1); }
    const cmp=Math.sign(A.p*B.q - B.p*A.q), symbol=(cmp<0)?' < ':(cmp>0?' > ':' = ');
    return {A,B,cmp,symbol};
  },
  text(st){
    // On s√©pare en trois blocs LaTeX pour ins√©rer le <select> au milieu
    return `${wrap(exprFracTex(st.A))} <span id="cmp-slot"></span> ${wrap(exprFracTex(st.B))}`;
  },
  render(host, st){
    const ctx=renderRow(host, "Comparer deux fractions :", this.text(st), "", "");
    const inpLine = ctx.row.querySelector('.input-line'); if (inpLine) inpLine.remove();
    const slot = ctx.lab.querySelector('#cmp-slot');
    const sel=document.createElement('select'); sel.id="reponse-sym"; ["","<","=",">"].forEach(v=> sel.appendChild(new Option(v,v)));
    sel.style.verticalAlign="middle"; sel.style.margin="0 .35rem";
    if(slot){ slot.replaceWith(sel); }
    const offEq = ctx.root.querySelector('.equ-offscreen .equation');
    if (offEq) offEq.innerHTML = wrap(`${exprFracTex(st.A)} \\square ${exprFracTex(st.B)}`);
    typesetAll(ctx.root);
  },
  correct(host, st){
    const val=($("#reponse-sym",host)||{}).value||"";
    const ok=(val===(st.cmp<0?"<":st.cmp>0?">":"="));
    $("#res",host).innerHTML= ok ? "‚úî" : wrap(`${exprFracTex(st.A)} ${st.symbol.trim()} ${exprFracTex(st.B)}`);
    $("#res",host).className= ok ? "res-ok":"res-ko";
    typesetAll($("#res",host));
    return {ok,total:1};
  },
  solution(host, st){
    const left=st.A.p*st.B.q, right=st.B.p*st.A.q;
    const lS=fmtInt(left), rS=fmtInt(right);
    const steps=[
      wrap(`${exprFracTex(st.A)} \\square ${exprFracTex(st.B)}`),
      `Comparer \\(${exprFracTex(st.A)}\\) et \\(${exprFracTex(st.B)}\\) revient √† comparer \\(${lS}\\) et \\(${rS}\\) (produits en croix).`,
      wrap(`${lS} ${st.symbol.trim()} ${rS} \\;\\Rightarrow\\; ${exprFracTex(st.A)} ${st.symbol.trim()} ${exprFracTex(st.B)}`)
    ];
    $("#res",host).innerHTML=stepsHTML_F('compare', steps);
    typesetAll($("#res",host));
  },
  reset(host){ const sel=$("#reponse-sym",host); if(sel){ sel.value=""; } $("#res",host).textContent=""; }
};

/* 6 ‚Äî Mettre au m√™me d√©nominateur (PPCM) */
const ex6={
  id:"same-den", title:"Mettre au m√™me d√©nominateur (PPCM)",
  gen(){
    const A=makeR(rnd(-9,9), rnd(2,10)), B=makeR(rnd(-9,9), rnd(2,10));
    const L=lcm(A.q,B.q); const A1={p:A.p*(L/A.q), q:L}, B1={p:B.p*(L/B.q), q:L};
    return {A,B,L,A1,B1};
  },
  text(st){ return `${exprFracTex(st.A)} \\text{ et } ${exprFracTex(st.B)}`; },
  render(host, st){ renderRow(host, "Mettre au m√™me d√©nominateur (On cherchera le d√©nominateur le plus petit possible) :", this.text(st), "ex.  3/8 et -5/8"); },
  correct(host, st){
  const raw = ($("#reponse",host).value||"")
    .trim()
    .replace(/\s+/g,'')
    .replace(/\u2212/g,'-')
    .replace(/et/gi,';');

  const m = raw.match(/^([+-]?\d+)\/(\d+);([+-]?\d+)\/(\d+)$/);
  let ok = false, msg = "";

  if(m){
    const a1 = parseInt(m[1],10), qa = parseInt(m[2],10);
    const b1 = parseInt(m[3],10), qb = parseInt(m[4],10);

    const L = lcm(st.A.q, st.B.q);
    const expA_L = st.A.p * (L / st.A.q);
    const expB_L = st.B.p * (L / st.B.q);

    if (qa === qb && qa === L && a1 === expA_L && b1 === expB_L){
      ok = true;
    } else {
      const sameDen = (qa === qb);
      const kA = qa / st.A.q, kB = qb / st.B.q;
      const isCommonMultiple = sameDen && Number.isInteger(kA) && Number.isInteger(kB);
      const scaledOk = isCommonMultiple && (a1 === st.A.p * kA) && (b1 === st.B.p * kB);

      if (scaledOk && qa % L === 0 && qa !== L){
        msg = "Tu peux encore r√©duire les fractions avec un d√©nominateur plus petit.";
      }
    }
  }

  $("#res",host).innerHTML = ok
    ? "‚úî"
    : (msg || wrap(`${exprFracTex(st.A1)} \\text{ et } ${exprFracTex(st.B1)}`));

  $("#res",host).className = ok ? "res-ok" : "res-ko";
  typesetAll($("#res",host));
  return {ok,total:1};
},
  solution(host, st){
    const multA=formatMultiplesTo(st.A.q, st.L);
    const multB=formatMultiplesTo(st.B.q, st.L);
    const steps=[
      {text:`Multiples de ${st.A.q} : ${multA}`, noF:true},
      {text:`Multiples de ${st.B.q} : ${multB}`, noF:true},
      {text:`PPCM(${st.A.q} ; ${st.B.q}) = <span style="color:#c62828;font-weight:700">${st.L}</span>`, noF:true},
      wrap(`${exprFracTex(st.A)} = ${fracProdTex(st.A.p, (st.L/st.A.q), st.A.q, (st.L/st.A.q))}`),
      wrap(`${exprFracTex(st.B)} = ${fracProdTex(st.B.p, (st.L/st.B.q), st.B.q, (st.L/st.B.q))}`),
      wrap(`\\text{On obtient donc : } ${exprFracTex(st.A1)} \\text{ et } ${exprFracTex(st.B1)}`)
    ];
    $("#res",host).innerHTML=stepsHTML_F('same-den', steps);
    typesetAll($("#res",host));
  },
  reset: ex1.reset
};

/* 7 ‚Äî Pourcentage ‚Üí fraction irr√©ductible */
const ex7={
  id:"pct2frac", title:"Pourcentage ‚Üí fraction irr√©ductible",
  gen(){
  const kind=choice(['int','d1','d2']); let num,den,label;
  if(kind==='int'){
    const p=(Math.random()<.5?-1:1)*rnd(1,150);
    num=p; den=100;
    label = String(p).replace('.',',') + '\\,\\%';
  } else if(kind==='d1'){
    const m=(Math.random()<.5?-1:1)*rnd(1,300);
    num=m; den=1000;
    label = (m/10).toString().replace('.',',') + '\\,\\%';
  } else {
    const m=(Math.random()<.5?-1:1)*rnd(1,300);
    num=m; den=10000;
    label = (m/100).toString().replace('.',',') + '\\,\\%';
  }
  return {disp:label, value:{p:num,q:den}, expected: makeR(num,den)};
},

  text(st){ return `F = ${st.disp}`; },
  render(host, st){ renderRow(host, "√âcrire sous forme de fraction irr√©ductible :", this.text(st)); },
  correct(host, st){
  const parsed = parseFracInputStrict(($("#reponse",host).value||""));
  let ok=false, msg="";

  if(parsed && isEqualR(parsed.red, st.expected)){
    if(parsed.type==='frac' && !parsed.irr){
      msg = "Tu peux encore r√©duire la fraction.";
    }else{
      ok = true;
    }
  }

  $("#res",host).innerHTML = ok ? "‚úî" : (msg || wrap(`F = ${exprFracTex(st.expected)}`));
  $("#res",host).className  = ok ? "res-ok" : "res-ko";
  typesetAll($("#res",host));
  return {ok,total:1};
},
  solution(host, st){
    const arr=[ wrap(`F = ${st.disp}`), wrap(`F = ${exprFracTex(st.value)}`), ...(isEqualR(st.value, st.expected) ? [] : [wrap(`F = ${exprFracTex(st.expected)}`)]) ];
    $("#res",host).innerHTML=stepsHTML_F('pct2frac', arr);
    typesetAll($("#res",host));
    $("#reponse",host).value=(st.expected.q===1? String(st.expected.p) : `${st.expected.p}/${st.expected.q}`);
  },
  reset: ex1.reset
};

/* 8 ‚Äî Fraction d‚Äôun tout (PGCD + diviseurs) */
const ex8={
  id:"part-total", title:"√âcrire la fraction d‚Äôun tout",
  gen(){
    const total=rnd(10,60), part=rnd(1,total-1), expected=makeR(part,total);
    return {part,total,expected};
  },
  text(st){ return `${exprFracTex({p:st.part,q:st.total})}`; },
  render(host, st){ renderRow(host, "Donner la fraction irr√©ductible correspondant √† :", this.text(st)); },
  correct(host, st){
  const parsed = parseFracInputStrict(($("#reponse",host).value||""));
  let ok=false, msg="";

  if(parsed && isEqualR(parsed.red, st.expected)){
    if(parsed.type==='frac' && !parsed.irr){
      msg = "Tu peux encore r√©duire la fraction.";
    }else{
      ok = true;
    }
  }

  $("#res",host).innerHTML = ok ? "‚úî" : (msg || wrap(`F = ${exprFracTex(st.expected)}`));
  $("#res",host).className  = ok ? "res-ok" : "res-ko";
  typesetAll($("#res",host));
  return {ok,total:1};
},
  solution(host, st){
    const a=st.part, b=st.total, g=gcd(a,b);
    const p1=a/g, q1=b/g;
    const dA=formatDivisorsUpToG(a, g), dB=formatDivisorsUpToG(b, g);
    const steps=[
      wrap(`${exprFracTex({p:a,q:b})}`),
      {text:`Diviseurs de ${a} : ${dA}`, noF:true},
      {text:`Diviseurs de ${b} : ${dB}`, noF:true},
      {text:`PGCD(${a} ; ${b}) = <span style="color:#c62828;font-weight:700">${g}</span>${g===1 ? ' ‚Äî Les deux nombres sont premiers entre eux : aucun diviseur commun autre que 1.' : ''}`, noF:true},
      ...(g>1 ? [
        wrap(`${fracProdTex_g(g, p1, g, q1)}`),
        wrap(`${exprFracTex({p:p1,q:q1})}`)
      ] : [{text:`La fraction est d√©j√† irr√©ductible.`, noF:true}])
    ];
    $("#res",host).innerHTML=stepsHTML_F('part-total', steps);
    typesetAll($("#res",host));
  },
  reset: ex1.reset
};

/* ===== registre & moteur ===== */
const REGISTRY=[ex1,ex6,ex2,ex3,ex4,ex5];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host, st); const inp=$("#reponse",host)||$("#reponse-sym",host); if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st); if(r){ scoreOK+=(r.ok?1:0); scoreTot+=(r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}"); if(def.solution) def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore(); const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def) def.reset(host);
}

document.addEventListener('DOMContentLoaded', function(){
  innerHost(document.getElementById('host'));

  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });

  sel.addEventListener('change', buildOne);
  $("#btn-new").addEventListener('click', buildOne);
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);

  sel.value=REGISTRY[0].id; buildOne(); updateScore();

  // Entr√©e -> V√©rifier
  document.addEventListener('keydown', function(ev){
    const a=document.activeElement;
    if(ev.key==='Enter' && a && a.id==='reponse'){ ev.preventDefault(); try{ check(); }catch(_e){} }
  });

  // PDF : consigne (sans libell√©) + √©nonc√© OU correction seule
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Seconde ‚Äì Chapitre 0 ‚Äì √âcritures fractionnaires',
      max:50,
      mountAfterSelector:'.card.small',
      beforeRender(def, st, withSolutions){
        try{
          const tmp=document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          def.render(tmp, st);
          if(!withSolutions){
            const equ=tmp.querySelector('.equ-offscreen');
            if(equ){
              const clone=equ.cloneNode(true);
              const lab=clone.querySelector('.c-label'); if(lab) lab.remove();
              return clone.outerHTML;
            }
            return tmp.innerHTML;
          }else{
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            const sol=tmp.querySelector('.steps, .steps--two');
            return sol ? sol.outerHTML : tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }

  // clavier
  if(window.MathKbd && MathKbd.mount) MathKbd.mount("#math-kbd", { bindTo:"#reponse" });

  // nettoyages/normalisations (scripts fournis)
  if(window.DevRules && DevRules.attachCleaner) DevRules.attachCleaner();
});
})();
</script>

<!-- JS fournis -->
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/fraction-sign-clarity.dom.v3.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
[['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche (h√©ritage)
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
