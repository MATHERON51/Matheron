<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì Factorisation (F = ‚Ä¶)</title>
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
#exo-select{min-width:360px}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer}
.btn:hover{background:#efefef}
.score{font-weight:700}

/* Enonc√© + case gris√©e √† droite */
.row3{display:grid;grid-template-columns:1fr 24px minmax(460px,1fr);gap:10px;align-items:start}
.eq-left .line{font-size:1.05rem}
.steps{background:#f6f7f8;border:1px dashed #cfd3d7;border-radius:10px;padding:.6rem .8rem;min-height:54px}
.steps .line{white-space:pre-wrap;font-size:1.02rem}
.steps .line + .line{margin-top:.25rem}

/* Tableaux (l‚Äô√©cran utilise .tbl ; les styles PDF sont inline dans le HTML inject√©) */
.tbl{width:100%;margin:.55rem auto;table-layout:fixed;border-collapse:collapse}

/* Facteur commun (rouge) √† l‚Äô√©cran */
.fc{color:#d32f2f;font-weight:700}

/* Saisie */
.ans-row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.ans-row .F{font-weight:700}
.ans-row input[type=text]{flex:1;min-width:200px;max-width:420px}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}

/* Carr√©s utiles */
.sqstrip{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px;margin-top:10px}
.sqbox{border:1px solid #e0e0e0;background:#fff;padding:8px 10px;border-radius:8px;text-align:center;font-variant-numeric:tabular-nums}

@media (max-width:980px){ .row3{grid-template-columns:1fr} }


</style>
</head>
<body>
  <div class="header">
    <div class="wrap" style="padding:10px 18px">
      <div class="controls">
        <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
        <select id="exo-select"></select>
        <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
        <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
        <button id="btn-solution" class="btn">üí° Solution</button>
        <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
        <span class="score">Score : <span id="score">0 / 0</span></span>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- Enonc√© + solution -->
    <div class="card" id="host"></div>

    <!-- Saisie & r√©ponses accept√©es -->
    <div class="card" id="accept">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:.6rem 0 .2rem 1.25rem">
        <li>R√©pondre avec une <em>forme factoris√©e</em> (produit, parenth√®ses, puissance).</li>
        <li><strong>Toute factorisation non triviale</strong> (facteur ‚â† 1, y compris un facteur num√©rique global ou un seul facteur commun) est <strong>accept√©e</strong> si elle est alg√©briquement √©quivalente √† F mais il est toujours demand√© d‚Äôessayer de trouver la plus factoris√©e possible.</li>
        <li>√âcriture : <code>x</code> pour <code>1x</code>, <code>‚àíx</code> pour <code>‚àí1x</code>. Puissances : <code>x^n</code> ou <code>x¬≤</code>. Multiplications implicites accept√©es.</li>
      </ul>
      <div style="margin-top:.6rem"><strong>Carr√©s utiles (0 √† 20)</strong></div>
      <div class="sqstrip" id="squares-host"></div>
    </div>

    <!-- UI PDF -->
    <div id="pdf-anchor"></div>

    <!-- Clavier -->
    <div class="card" style="display:flex;justify-content:center"><div data-math-kbd></div></div>
  </div>

<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rndEx=(a,except)=>{let v=choice(a); if(except!=null){while(v===except){v=choice(a);} } return v;}
const MULT='√ó';

/* ==== √âvaluation tol√©rante ==== */
// ajout de \u2212 (moins unicode)
const SAFE_RE = /^[0-9xX+\-*/().\s^¬∑√ó¬≤\u2212]+$/;

/* ==== √âvaluation tol√©rante ==== */
function insertImplicitMultiplication(s){
  return String(s)
    // nombre  x   ‚Üí nombre*x  (espaces autoris√©s)
    .replace(/(\d)\s*x/gi, '$1*x')
    // x  nombre ‚Üí x*nombre
    .replace(/x\s*(\d)/gi, 'x*$1')
    // nombre ( ‚Ä¶ ) ‚Üí nombre*( ‚Ä¶ )
    .replace(/(\d)\s*\(/g, '$1*(')
    // x ( ‚Ä¶ ) ‚Üí x*( ‚Ä¶ )
    .replace(/x\s*\(/gi, 'x*(')
    // ( ‚Ä¶ ) nombre ‚Üí ( ‚Ä¶ )*nombre
    .replace(/\)\s*(\d)/g, ')*$1')
    // ( ‚Ä¶ ) x ‚Üí ( ‚Ä¶ )*x
    .replace(/\)\s*x/gi, ')*x')
    // ( ‚Ä¶ ) ( ‚Ä¶ ) ‚Üí ( ‚Ä¶ )*( ‚Ä¶ )
    .replace(/\)\s*\(/g, ')*(');
}

function evalExprAt(expr,x){
  let s=(expr||'').trim();
  if(!SAFE_RE.test(s)) throw new Error('chars');
  s=s.replace(/\u2212/g,'-').replace(/√ó|¬∑/g,'*')
     .replace(/([0-9xX)\]])\s*¬≤/g,'$1**2').replace(/\^/g,'**');
  s=insertImplicitMultiplication(s);
  if(/(?:new|Function|=>|while|for|class|import|require|this)/.test(s)) throw new Error('bad');
  s=s.replace(/X/g,'x');
  const f=new Function('x',`return (${s});`);
  const v=f(x); if(!Number.isFinite(v)) throw new Error('NaN'); return v;
}
function algebraicEqual(user,ref){
  try{ for(const t of [-3,-2,-1,0,1,2,3,4]){ if(Math.abs(evalExprAt(user,t)-evalExprAt(ref,t))>1e-9) return false; } return true; }
  catch(e){ return false; }
}
function isTrivialByOne(user){
  const s = insertImplicitMultiplication(String(user||'')).replace(/\s+/g,'');
  // 1*(...) ou (...)*1
  if (/^[+]?1\*/.test(s)) return true;
  if (/\*1$/.test(s))     return true;
  // juste des parenth√®ses autour d‚Äôun polyn√¥me : ( ... ) sans produit/puissance
  if (/^\([^()]+\)$/.test(s)) return true;
  return false;
}

function looksFactorized(user){
  if (isTrivialByOne(user)) return false;

  // normalisation douce : implicite ‚Üí *, espaces supprim√©s, ‚àí unicode ‚Üí '-'
  var s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-'))
            .replace(/\s+/g,'');

  // (‚Ä¶)(‚Ä¶)  OU  ‚Ä¶*(‚Ä¶)  OU  (‚Ä¶)*‚Ä¶   ‚Üí produit de blocs
  if (/\)\(/.test(s)) return true;
  if (/\*\(/.test(s) || /\)\*/.test(s)) return true;

  // k(‚Ä¶) avec k ‚â† 1
  if (/^[+-]?\d+\(.*\)$/.test(s) && !/^[+-]?1\(/.test(s)) return true;

  // ¬±kx(‚Ä¶)  ou  ¬±x(‚Ä¶)  ou  ¬±kx^n(‚Ä¶)
  if (/^[+-]?(?:\d+)?x(?:\^\d+)?\(.+\)$/i.test(s)) return true;

  // (‚Ä¶ )^n / ¬≤ / ¬≥ : puissance d‚Äôun bloc parenth√©s√©
  if (/\([^()]+\)(?:\^\d+|¬≤|¬≥)$/.test(s)) return true;

  return false;
}

// Normalisation l√©g√®re pour les motifs
function _normDS(s){
  return String(s||'')
    .replace(/\u2212/g,'-')     // minus unicode
    .replace(/\s+/g,'')         // espaces
    .replace(/\*\*/g,'^')       // **2 -> ^2
    .replace(/¬≤/g,'^2')         // ¬≤ -> ^2
    .replace(/[√ó¬∑]/g,'*');      // √ó ¬∑ -> *
}
const _isPerfectSquare = n => {
  const k = Math.sqrt(n);
  return Number.isInteger(k) && k>=0;
};
// (x¬±n)(x‚àìn) pr√©sent ?
function _alreadyFactoredDSX(s){
  const t = _normDS(s);
  const re = /\(x([+-])(\d+)\)\*?\(x([+-])(\d+)\)/gi;
  let m; 
  while((m = re.exec(t))){
    const s1=m[1], n1=+m[2], s2=m[3], n2=+m[4];
    if(n1===n2 && s1!==s2) return true;
  }
  return false;
}
// Contient un (x^2 - n) ou (n - x^2) avec n carr√© parfait, non encore factoris√© ?
function _hasReducibleX2MinusSquare(s){
  const t = _normDS(s);
  // cherche dans des parenth√®ses quelconques
  const re = /\((?:x\^2-(\d+)|(\d+)-x\^2)\)/g;
  let m;
  while((m=re.exec(t))){
    const n = +(m[1] ?? m[2]);
    if(_isPerfectSquare(n)) return true;
  }
  return false;
}
// "Ultime" pour l'ex.4 : d√©j√† (x¬±n)(x‚àìn) OU pas de x^2 - n^2 r√©siduel
function isUltimateEx4(user){
  if (_alreadyFactoredDSX(user)) return true;
  return !_hasReducibleX2MinusSquare(user);
}
// Normalise pour comparer proprement
function _normFlat(s){
  return insertImplicitMultiplication(String(s||''))
    .replace(/\u2212/g,'-')    // minus unicode ‚Üí '-'
    .replace(/[√ó¬∑]/g,'*')      // √ó ¬∑ ‚Üí *
    .replace(/\s+/g,'');       // sans espaces
}

// D√©tecte "r√©√©criture brute" pour ex.6 : (..)*(..) + (..)*(..)
// avec un facteur parenth√©s√© identique des deux c√¥t√©s du '+'
function isRewriteOriginalEx6(user){
  const t = _normFlat(user);
  // force ')(' ‚Üí ')*(' via insertImplicitMultiplication ‚áí on peut chercher '*'
  const re = /\(([^()]+)\)\*\(([^()]+)\)\+\(([^()]+)\)\*\(([^()]+)\)/;
  const m = re.exec(t);
  if(!m) return false;
  const a=m[1], b=m[2], c=m[3], d=m[4];
  // facteur commun r√©p√©t√© √† gauche et √† droite ?
  return (a===c || a===d || b===c || b===d);
}

// D√©tecte "r√©√©criture brute" pour ex.7 : (..)*(..) - (..)*(..)
// avec un facteur parenth√©s√© identique des deux c√¥t√©s du '‚àí'
function isRewriteOriginalEx7(user){
  const t = _normFlat(user);
  const re = /\(([^()]+)\)\*\(([^()]+)\)\-\(([^()]+)\)\*\(([^()]+)\)/;
  const m = re.exec(t);
  if(!m) return false;
  const a=m[1], b=m[2], c=m[3], d=m[4];
  return (a===c || a===d || b===c || b===d);
}


function acceptAnyFactorization(user,expandedRef){
  const eq=algebraicEqual(user,expandedRef); if(!eq) return false; return looksFactorized(user);
}
// PGFC
// PGCD
const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a||0; };

// Toutes les parenth√®ses "lin√©aires" (ax+b), formes: ax+b, b+ax, ax, x, etc.
function parseAllLinearInParens(user){
  let s = String(user||'').replace(/\u2212/g,'-');
  s = insertImplicitMultiplication(s);
  const L=[], re=/\(([^()]+)\)/g; let m;
  while((m=re.exec(s))){
    let t = m[1].replace(/\s+/g,'').replace(/\*/g,'');
    let r = t.match(/^([+-]?\d*)x([+-]\d+)$/);        // ax+b
    if(r){
      let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
      let b = parseInt(r[2],10);
      L.push({a,b}); continue;
    }
    r = t.match(/^([+-]?\d+)([+-])(\d*)x$/);          // b+ax
    if(r){
      let b = parseInt(r[1],10);
      let a = (r[3]===''?1:parseInt(r[3],10)) * (r[2]==='-'?-1:1);
      L.push({a,b}); continue;
    }
    r = t.match(/^([+-]?\d*)x$/);                     // ax
    if(r){
      let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
      L.push({a,b:0}); continue;
    }
    // constante seule ‚Üí on ignore
  }
  return L;
}

// x plac√© √† l‚Äôext√©rieur d‚Äôune parenth√®se ? (utile pour ex.1)
function hasOuterXAroundParen(user){
  let s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-')).replace(/\s+/g,'');
  return /x\*\(|\)\*x/i.test(s);
}

// "Ultime" g√©n√©rique : tous les (ax¬±b) copremiers ; possibilit√© d‚Äôexiger x dehors (ex.1)
function isUltimateGeneric(user, opts={}){
  if (opts.requireOuterX && !hasOuterXAroundParen(user)) return false;
  const L = parseAllLinearInParens(user);
  for(const {a,b} of L){ if (gcd(a,b)>1) return false; }
  return true;
}

// Extrait (a,b) de la premi√®re parenth√®se rencontr√©e si elle est lin√©aire en x
function parseLinearFromFirstParen(user){
  let s = String(user||'').replace(/\u2212/g,'-');
  s = insertImplicitMultiplication(s);
  const m = s.match(/\(([^()]+)\)/);
  if(!m) return null;
  let t = m[1].replace(/\s+/g,'').replace(/\*/g,'');
  // formes "ax+b" ou "b+ax"
  let r = t.match(/^([+-]?\d*)x([+-]\d+)$/);
  if(r){
    let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
    let b = parseInt(r[2],10);
    return {a,b};
  }
  r = t.match(/^([+-]?\d+)([+-])(\d*)x$/);
  if(r){
    let b = parseInt(r[1],10);
    let a = (r[3]===''?1:parseInt(r[3],10)) * (r[2]==='-'?-1:1);
    return {a,b};
  }
  return null;
}

// x plac√© hors de la parenth√®se (‚Ä¶)*x ou x*(‚Ä¶)
function hasOuterXAroundParen(user){
  let s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-')).replace(/\s+/g,'');
  return /x\*\(|\)\*x/i.test(s);
}

/* ==== helpers ==== */
function uminus(n){return n<0?'‚àí'+Math.abs(n):String(n);}
function fmtAx(a){ if(a===1) return 'x'; if(a===-1) return '‚àíx'; return `${uminus(a)}x`; }
function binom(a,b){ return `( ${fmtAx(a)} ${b>=0?'+':'‚àí'} ${Math.abs(b)} )`; }
function fc(s){ return `<span class="fc" style="color:#d32f2f;font-weight:700">${s}</span>`; }
function dedup(lines){ const out=[]; for(const L of lines){ if(!out.length || out[out.length-1]!==L) out.push(L); } return out; }

/* ==== rendu ==== */
function renderFrame(host,enonceHTML,placeholder){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row3';
  row.innerHTML=`
    <div class="consigne" style="grid-column:1/-1">Factoriser :</div>
    <div class="eq-left">
      <div class="line">F = <span class="equ">${enonceHTML}</span></div>
      <div style="margin-top:.7rem"><strong>R√©ponse (forme factoris√©e) :</strong></div>
      <div class="ans-row" style="margin-top:.1rem"><span class="F">F =</span> <input type="text" id="reponse" placeholder="${placeholder}"></div>
      <div id="res"></div>
    </div>
    <div></div>
    <div id="sol" class="steps"></div>
  `;
  host.appendChild(row);
  const ip=$("#reponse",host); ip&&ip.addEventListener('keydown',e=>{ if(e.key==='Enter'){e.preventDefault(); check(); }});
}

/* ================= EXERCICES ================= */

/* 1. Facteur commun */
/* 1. Facteur commun ‚Äî PGFC syst√©matique */
const ex1 = {
  id:"facteur-commun",
  title:"Mise en √©vidence du plus grand facteur commun",
  gen(){
    const g=choice([2,3,4,5,6,8,10,12]);
    const A=choice([1,2,3,4,5,6]);
    const B=choice([1,2,3,4,5,6,7,8,9]);
    const a=g*A, b=g*B;

    // PGFC num√©rique
    const d = gcd(a,b);
    const A1 = a/d, B1 = b/d;

    const lines = [
      `F = ${a}x¬≤ + ${b}x`,
      `F = ${fc(d+'x')} ( ${A1}x + ${B1} )`
    ];
    return {
      txt:`${a}x¬≤ + ${b}x`,
      ref:`${a}*x**2 + ${b}*x`,
      d, A1, B1,
      lines:dedup(lines)
    };
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  12x(2x+3)"); },

  // on exige la factorisation MAXIMALE : x dehors + coefficients copremiers dedans
  title:"Mise en √©vidence d‚Äôun facteur commun",

correct(h,st){
  const v = ($("#reponse",h).value||"").trim();
  const ok = acceptAnyFactorization(v, st.ref); // √©quivalence + vraie factorisation
  $("#res",h).textContent = ok
    ? "‚úî"
    : "‚úò R√©ponse attendue : une forme factoris√©e √©quivalente (pas la forme d√©velopp√©e, ni 1(‚Ä¶)).";
  $("#res",h).className = ok ? "res-ok" : "res-ko";
  return {ok,total:1};
},


  solution(h,st){
    $("#sol",h).innerHTML = st.lines.map(t=>`<div class="line">${t}</div>`).join("");
  },
  printSolutionPDF(st){
  const lines = Array.isArray(st?.lines) ? st.lines : (st?.lines ? [st.lines] : []);
  if (!lines.length) return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  const inner = lines.map(t => '<div class="line">' + String(t) + '</div>').join('');
  return '<div class="steps">' + inner + '</div>';
}

};


/* 2. (a ¬± b)¬≤ ‚Äî A/B et ¬´ car ¬ª sur la m√™me ligne ; PDF resserr√© ET align√© √† gauche */
const ex2={ id:"carre-parfait", title:"Reconnaitre (a ¬± b)¬≤",
  gen(){
    const p=choice([2,3,4,5,6,7]), q=choice([1,2,3,4,5,6,7,8,9]); const minus=Math.random()<0.5;
    const a2=p*p, b2=q*q, mid=2*p*q;

    const tdTop='style="border-left:2px solid #000;border-right:2px solid #000;border-top:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';
    const td0='style="border-left:2px solid #000;border-right:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';
    const tdBot='style="border-left:2px solid #000;border-right:2px solid #000;border-bottom:2px solid #000;padding:.45rem .9rem;vertical-align:middle;text-align:center"';

    const tbl_screen=`
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${p}x&nbsp;&nbsp; <u>car</u> : (${p}x)¬≤ = ${a2}x¬≤</td>
          <td ${tdTop}>B = ${q}&nbsp;&nbsp; <u>car</u> : ${q}¬≤ = ${b2}</td>
        </tr>
        <tr><td ${td0} colspan="2" style="text-align:center">2AB = 2 ${MULT} ${p}x ${MULT} ${q} = ${mid}x</td></tr>
        <tr><td ${tdBot} colspan="2"><u>c‚Äôest</u> donc bon</td></tr>
      </table>`;

    const tbl_pdf=`<div style="max-width:560px;margin:.2rem 0;font-size:95%">
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${p}x&nbsp;&nbsp; <u>car</u> : (${p}x)¬≤ = ${a2}x¬≤</td>
          <td ${tdTop}>B = ${q}&nbsp;&nbsp; <u>car</u> : ${q}¬≤ = ${b2}</td>
        </tr>
        <tr><td ${td0} colspan="2" style="text-align:center">2AB = 2 ${MULT} ${p}x ${MULT} ${q} = ${mid}x</td></tr>
        <tr><td ${tdBot} colspan="2"><u>c‚Äôest</u> donc bon</td></tr>
      </table></div>`;

    const txt=`${a2}x¬≤ ${minus?'‚àí':'+'} ${mid}x + ${b2}`;
    const ref=`${a2}*x**2 ${minus?'-':'+'} ${mid}*x + ${b2}`;

    const lines=[
      minus?`Rappel : A¬≤ ‚àí 2AB + B¬≤ = (A ‚àí B)¬≤`:`Rappel : A¬≤ + 2AB + B¬≤ = (A + B)¬≤`,
      `On cherche A tel que A¬≤ = ${a2}x¬≤, B tel que B¬≤ = ${b2} puis on v√©rifie si 2AB = ${mid}`,
      tbl_screen,
      `F = ${a2}x¬≤ ${minus?'‚àí':'+'} ${mid}x + ${b2}`,
      `F = (${p}x ${minus?'‚àí':'+'} ${q})¬≤`
    ];
    return {txt,ref,lines:dedup(lines),tbl_pdf};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (5x¬±7)^2"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò R√©ponse attendue : forme factoris√©e √©quivalente (non triviale)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
 printSolutionPDF(st){
  const src = Array.isArray(st && st.lines) ? st.lines
            : (st && st.lines ? [st.lines] : []);
  const pick = i => (i >= 0 && i < src.length ? src[i] : null);

  const selected = [
    pick(0),
    pick(1),
    st && st.tbl_pdf,
    pick(3),
    pick(4)
  ].filter(Boolean).map(String);

  if (!selected.length) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }

  var inner = '';
  for (var i = 0; i < selected.length; i++) {
    inner += '<div class="line">' + selected[i] + '</div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 3. A¬≤ ‚àí B¬≤ ‚Äî m√™me format ; PDF resserr√© & align√© √† gauche */
const ex3={ id:"diff-carres", title:"Diff√©rence de deux carr√©s",
  gen(){
    const t=choice([5,6,7,8,9,10,11,12,13,14]), c=choice([2,3,4,5,6,7,8,9,10]);

    const tdTop='style="border-left:2px solid #000;border-right:2px solid #000;border-top:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';

    const tbl_screen=`
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${t}x&nbsp;&nbsp; <u>car</u> : (${t}x)¬≤ = ${t*t}x¬≤</td>
          <td ${tdTop}>B = ${c}&nbsp;&nbsp; <u>car</u> : ${c}¬≤ = ${c*c}</td>
        </tr>
      </table>`;

    const tbl_pdf=`<div style="max-width:560px;margin:.2rem 0;font-size:95%">
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${t}x&nbsp;&nbsp; <u>car</u> : (${t}x)¬≤ = ${t*t}x¬≤</td>
          <td ${tdTop}>B = ${c}&nbsp;&nbsp; <u>car</u> : ${c}¬≤ = ${c*c}</td>
        </tr>
      </table></div>`;

    const txt=`${t*t}x¬≤ ‚àí ${c*c}`;
    const ref=`${t*t}*x**2 - ${c*c}`;

    const lines=[
      `Rappel : A¬≤ ‚àí B¬≤ = (A + B)(A ‚àí B)`,
      `On cherche A tel que A¬≤ = ${t*t}x¬≤, B tel que B¬≤ = ${c*c}`,
      tbl_screen,
      `F = ${t*t}x¬≤ ‚àí ${c*c}`,
      `F = ( ${t}x + ${c} )( ${t}x ‚àí ${c} )`
    ];
    return {txt,ref,lines:dedup(lines),tbl_pdf};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (13x+8)(13x‚àí8)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò Attendu : (tx¬±c)(tx‚àìc) ou forme √©quivalente."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var src = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  function pick(i){ return (i>=0 && i<src.length) ? src[i] : null; }

  var parts = [
    pick(0),
    pick(1),
    st && st.tbl_pdf,
    pick(3),
    pick(4)
  ].filter(function(v){ return v!=null && v!==''; }).map(String);

  if (!parts.length){
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i=0;i<parts.length;i++){
    var t = parts[i];
    if (seen[t]) continue;     // √©vite les doublons √©ventuels
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 4. Diff√©rence de deux carr√©s (apr√®s factorisation) ‚Äì x¬≤ ‚àí r¬≤ */
const ex4={ id:"diff-carres-apres-facto", title:"Diff√©rence de deux carr√©s (apr√®s factorisation)",
  gen(){
    const k=choice([2,3,4,5,6,8,9]), r=choice([2,3,4,5,6,7,8,9]);
    const txt=`${k}x¬≤ ‚àí ${k*r*r}`;
    const ref=`${k}*x**2 - ${k*r*r}`;
    const lines=[
      `F = ${txt}`,
      `F = ${fc(String(k))}( x¬≤ ‚àí ${r*r} )`,
      `F = ${fc(String(k))}( x + ${r} )( x ‚àí ${r} )`,
      `Rappel : A¬≤ ‚àí B¬≤ = (A + B)(A ‚àí B)`
    ];
    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  3(x+3)(x‚àí3)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò Attendu : extraire k puis utiliser A¬≤‚àíB¬≤."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines
        : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue;     // √©vite les doublons √©ventuels
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 5. Trin√¥me ‚Äì phrase ¬´ Il faudra r√©soudre un syst√®me. ¬ª */
const ex5={ id:"trinome-hors", title:"x¬≤ + bx + c (hors programme)",
  gen(){
    let r=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
    let s=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]); while(s===r) s=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
    const S=r+s, P=r*s;
    const B=-(S), C=P;
    const txt=`x¬≤ ${B>=0?'+':'‚àí'} ${Math.abs(B)}x + ${C}`;
    const ref=`x**2 ${B>=0?'+':'-'} ${Math.abs(B)}*x + ${C}`;
    const lines=[
      `On cherche r, s tels que r + s = ${S} et rs = ${P}.`,
      `Il faudra r√©soudre un syst√®me.`,
      `F = ${txt}`,
      `F = ( x ${(-r>=0?'+':'‚àí')} ${Math.abs(r)} )( x ${(-s>=0?'+':'‚àí')} ${Math.abs(s)} )`
    ];
    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (x‚àír)(x‚àís)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò Attendu : (x‚àír)(x‚àís) (non trivial)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue; // √©vite un doublon √©ventuel
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 6. Regrouper (somme de produits) ‚Äî ajoute √©ventuellement la ligne k(ax+b) ou kx(ax+b) */
const ex6={ id:"regroup-somme", title:"Regrouper (somme de produits)",
  gen(){
    const a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), b=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]),
          c=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), d=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]),
          e=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), f=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const axb=binom(a,b), cxd=binom(c,d), exf=binom(e,f);
    const A=c+e, B=d+f;
    const txt=`${axb} ${cxd} + ${exf} ${axb}`.replace(/\)\s+\(/g,') (');
    const ref=`(${a}*x+(${b}))*( ${c}*x+(${d}) ) + (${e}*x+(${f}))*( ${a}*x+(${b}) )`;

    const lines=[
      `F = ${fc(axb)} ${cxd} + ${exf} ${fc(axb)}`,
      `F = ${fc(axb)} [ ${cxd} + ${exf} ]`,
      `F = ${fc(axb)} [ ${fmtAx(c)} ${d>=0?'+':'‚àí'} ${Math.abs(d)} ${e>=0?'+':'‚àí'} ${Math.abs(e)}x ${f>=0?'+':'‚àí'} ${Math.abs(f)} ]`,
      `F = ${fc(axb)} ( ${fmtAx(A)} ${ B>=0?'+':'‚àí'} ${Math.abs(B)} )`
    ];
    if (A===0){ lines.push(`F = ${uminus(B)}${fc(axb)}`); }
    else if (B===0){ lines.push(`F = ${fmtAx(A)}${fc(axb)}`); }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (ax+b)((c+e)x+(d+f))"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò Attendu : extraction du facteur commun puis simplification."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue; // √©vite les doublons
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 7. Regrouper (diff√©rence de produits) ‚Äî pas de doublons ; conclusions seulement si A=0 ou B=0 */
const ex7={ id:"regroup-diff", title:"Regrouper (diff√©rence de produits)",
  gen(){
    const u=choice([2,3,4,5,6,7,8,9]);
    const a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const b=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const collapse = Math.random() < 0.30;
    const c = collapse ? a : rndEx([-5,-4,-3,-2,-1,1,2,3,4,5], a);
    const d=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const e=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const f=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);

    const axb=binom(a,b), cxd=binom(c,d), exf=binom(e,f);
    const txt=`${axb} ${cxd} ‚àí ${exf} ${axb}`.replace(/\)\s+\(/g,') (');
    const ref=`(${a}*x+(${b}))*(${c}*x+(${d})) - (${e}*x+(${f}))*(${a}*x+(${b}))`;

    const A=a-c, B=b-d;                     // (x+u)(Ax + B)
    const last = A===0 ? `${B}` : `${fmtAx(A)} ${B>=0?'+':'‚àí'} ${Math.abs(B)}`;

    const lines = [
      `F = ${fc('( x + '+u+' )')} ${axb} ‚àí ${cxd} ${fc('( x + '+u+' )')}`,
      `F = ${fc('( x + '+u+' )')} [ ${axb} ‚àí ${cxd} ]`,
      `F = ${fc('( x + '+u+' )')} ( ${fmtAx(a)} ${b>=0?'+':'‚àí'} ${Math.abs(b)} ${(-c)>=0?'+':'‚àí'} ${Math.abs(c)}x ${(-d)>=0?'+':'‚àí'} ${Math.abs(d)} )`,
      `F = ${fc('( x + '+u+' )')} ( ${last} )`
    ];
    if (A === 0) {
      lines.push(`F = ${B}( x + ${u} )`);
    } else if (B === 0) {
      lines.push(`F = ( x + ${u} )( ${fmtAx(A)} )`);
      lines.push(`F = ${fmtAx(A)}( x + ${u} )`);
    }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (x+u)((a‚àíc)x+(b‚àíd)) ou k(x+u)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò Attendu : extraction de (x+u) puis regroupement (avec signe ¬´ ‚àí ¬ª)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue; // √©vite les doublons
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">Corrig√© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 8. M√©lange ‚Äî la 1 ≥·µâ ligne du corrig√© est l‚Äô√©nonc√© avec le facteur commun en ROUGE (x¬≤ ‚Üí x color√©, ¬≤ gard√©) */
const ex8={ id:"melange", title:"Sommes / diff√©rences factorisables",
  gen(){
    const pat=choice([1,2,3]);
    let txt, ref, lines;

    if(pat===1){
      const k=choice([2,3,4,5]), u=choice([2,3,4,5,6,7]), b=choice([2,3,4]), c=choice([2,3,4,5,6]);
      txt=`${k}x( x ‚àí ${u} ) ‚àí ${2*k}x¬≤( x ‚àí ${u} )( ${b}x ‚àí ${c} )`;
      ref=`${k}*x*(x-(${u})) - ${2*k}*x**2*(x-(${u}))*(${b}*x-(${c}))`;
      const first=`F = ${fc(`${k}x( x ‚àí ${u} )`)} ‚àí ${2*k}x¬≤( x ‚àí ${u} )( ${b}x ‚àí ${c} )`;
      lines=[ first,
              `F = ${fc(`${k}x( x ‚àí ${u} )`)} [ 1 ‚àí 2x( ${b}x ‚àí ${c} ) ]`,
              `F = ${fc(`${k}x( x ‚àí ${u} )`)} ( 1 ‚àí ${2*b}x¬≤ + ${2*c}x )`];

    }else if(pat===2){
      const a=choice([-4,-3,-2,-1,1,2,3,4]), b=choice([-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8]);
      const m=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), n=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      const AB=`( ${fmtAx(a)} ${b>=0?'+':'‚àí'} ${Math.abs(b)} )`;
      txt=`${AB} ( x ${m>=0?'+':'‚àí'} ${Math.abs(m)} ) ‚àí ${AB} ( x ${n>=0?'+':'‚àí'} ${Math.abs(n)} )`;
      ref=`(${a}*x+(${b}))*(x+(${m})) - (${a}*x+(${b}))*(x+(${n}))`;
      const first=`F = ${fc(AB)} ( x ${m>=0?'+':'‚àí'} ${Math.abs(m)} ) ‚àí ${fc(AB)} ( x ${n>=0?'+':'‚àí'} ${Math.abs(n)} )`;
      lines=[ first,
              `F = ${fc(AB)} [ ( x ${m>=0?'+':'‚àí'} ${Math.abs(m)} ) ‚àí ( x ${n>=0?'+':'‚àí'} ${Math.abs(n)} ) ]`,
              `F = ${fc(AB)} ( ${m-n} )`];

    }else{ // pat===3
      const a=choice([1,2,3]), b=choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);
      const u=choice([-4,-3,-2,-1,1,2,3,4]), v=choice([-4,-3,-2,-1,1,2,3,4]);
      txt=`x¬≤( ${a}x ${b>=0?'+':'‚àí'} ${Math.abs(b)} ) + x( x ${u>=0?'+':'‚àí'} ${Math.abs(u)} )( x ${v>=0?'+':'‚àí'} ${Math.abs(v)} )`;
      ref=`x**2*(${a}*x+(${b})) + x*(x+(${u}))*(x+(${v}))`;
      // Colore uniquement le x de x¬≤, garde bien ¬≤ ; colore le x factored du second terme (quel que soit le signe)
      const txtFC = txt
        .replace('x¬≤', `${fc('x')}¬≤`)
        .replace(/([+\-])\s*x\(/, (_,s)=> `${s} ${fc('x')}(`);
      const first=`F = ${txtFC}`;
      const expandUV=`x¬≤ ${(u+v)>=0?'+':'‚àí'} ${Math.abs(u+v)}x ${(u*v)>=0?'+':'‚àí'} ${Math.abs(u*v)}`;
      const combined=`${a+1}x¬≤ ${(b+u+v)>=0?'+':'‚àí'} ${Math.abs(b+u+v)}x ${(u*v)>=0?'+':'‚àí'} ${Math.abs(u*v)}`;
      lines=[ first, `F = ${fc('x')} [ ${a}x¬≤ ${b>=0?'+':'‚àí'} ${Math.abs(b)}x + ${expandUV} ]`, `F = ${fc('x')} ( ${combined} )`];
    }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  ‚Ä¶"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"‚úî":"‚úò Attendu : extraction d‚Äôun facteur pertinent puis simplification."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines
        : (st && st.lines ? [st.lines] : []);
  var inner = '';

  if (L.length){
    var seen = Object.create(null);
    for (var i = 0; i < L.length; i++){
      var t = L[i];
      if (t == null || t === '') continue;
      t = String(t);
      if (seen[t]) continue; // √©vite les doublons √©ventuels
      seen[t] = true;
      inner += '<div class="line">' + t + '</div>';
    }
  }

  if (!inner){
    inner = '<div class="line">Corrig√© indisponible.</div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

const REGISTRY=[ex1,ex2,ex3,ex4,ex5,ex6,ex7,ex8];
window.REGISTRY=REGISTRY;
// Fabrique un correcteur "accepte + signale si non-ultime", avec rejets sp√©cifiques
function makeCorrector(opts){
  return function(h, st){
    const v = ($("#reponse",h).value||"").trim();

    // 0) Rejet cibl√© : r√©√©criture brute de l‚Äô√©nonc√© (ex.6/7)
    if (opts && typeof opts.rejectOriginalRewrite === 'function' && opts.rejectOriginalRewrite(v, st)){
      $("#res",h).textContent = "‚úò Ce n‚Äôest pas une factorisation : tu as r√©√©crit l‚Äô√©nonc√©. Extrais d‚Äôabord le facteur commun.";
      $("#res",h).className = "res-ko";
      return {ok:false,total:1};
    }

    // 1) Doit √™tre une factorisation √©quivalente et non triviale
    const okCore = acceptAnyFactorization(v, st.ref);
    if(!okCore){
      $("#res",h).textContent = "‚úò R√©ponse attendue : une forme factoris√©e √©quivalente (pas la forme d√©velopp√©e, ni 1(‚Ä¶)).";
      $("#res",h).className = "res-ko";
      return {ok:false,total:1};
    }

    // 2) Ultime ? (sp√©cifique si fourni, sinon g√©n√©rique)
    const ultime = (opts && typeof opts.customUltimate==='function')
      ? opts.customUltimate(v, st)
      : isUltimateGeneric(v, opts||{});

    $("#res",h).innerHTML = ultime ? "‚úî" : "‚úî (mais tu peux encore factoriser)";
    $("#res",h).className = "res-ok";
    return {ok:true,total:1};
  };
}

// (R√©-)installation des correcteurs pour tous les exos
(function installUltimateCheck(){
  const OPTS = {
    "facteur-commun": { requireOuterX:true },
    "carre-parfait": {},
    "diff-carres": {},
    // ex.4 : r√®gle sp√©ciale ‚Äúx¬≤ ‚àí n¬≤‚Äù (si tu l'as d√©j√† ajout√©e)
    "diff-carres-apres-facto": { customUltimate: (typeof isUltimateEx4==='function'? isUltimateEx4 : undefined) },
    // ‚¨áÔ∏è refus explicite de la r√©√©criture brute
    "regroup-somme": { rejectOriginalRewrite: isRewriteOriginalEx6 },
    "regroup-diff":  { rejectOriginalRewrite: isRewriteOriginalEx7 },
    "trinome-hors": {},
    "melange": {}
  };

  (window.REGISTRY||REGISTRY).forEach(ex=>{
    const opts = OPTS[ex.id] || {};
    ex.correct = makeCorrector(opts);
  });
})();



/* ==== Orchestration ==== */
let scoreOK=0,scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){ const sel=$("#exo-select"),host=$("#host"); const def=REGISTRY.find(e=>e.id===sel.value); if(!def)return;
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st); const inp=$("#reponse",host); if(inp) inp.focus(); }
function check(){ const h=$("#host"); const d=REGISTRY.find(e=>e.id===h.dataset.active); if(!d)return; const st=JSON.parse(h.dataset.state||"{}"); const r=d.correct(h,st); if(r){scoreOK+=(r.ok?1:0);scoreTot+=(r.total||1);updateScore();}}
function solution(){ const h=$("#host"); const d=REGISTRY.find(e=>e.id===h.dataset.active); if(!d)return; const st=JSON.parse(h.dataset.state||"{}"); if(typeof d.solution==='function') d.solution(h,st); const sol=$("#sol",h); sol && sol.scrollIntoView({behavior:'smooth',block:'center'}); }
function resetAll(){ scoreOK=0;scoreTot=0;updateScore(); const h=$("#host"); $("#reponse",h)&&($("#reponse",h).value=""); $("#res",h).textContent=""; $("#sol",h).innerHTML=""; }

document.addEventListener('DOMContentLoaded',function(){
  const sel=$("#exo-select"); REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change',buildOne);

  // carr√©s utiles
  const sbox=$("#squares-host"); const items=[]; for(let n=0;n<=20;n++){items.push(`<div class="sqbox">${n}<sup>2</sup> = ${n*n}</div>`);} sbox.innerHTML=items.join("");

  $("#btn-new").addEventListener('click',buildOne);
  $("#btn-check").addEventListener('click',check);
  $("#btn-solution").addEventListener('click',solution);
  $("#btn-reset").addEventListener('click',resetAll);

  sel.value=REGISTRY[0].id; buildOne(); updateScore();
});
})();
</script>

<!-- G√©n√©rateur de fiches PDF -->
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded',function(){
  if(window.ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì Factorisation (F = ‚Ä¶)',
      max:50,
      mountAfterSelector:'#accept',
      lead:'Factoriser :',
      beforeRender:function(def,st,withSolutions){
        if(!withSolutions){
          const txt=(st&&st.txt?String(st.txt):'').replace(/<[^>]+>/g,'');
          return {statement:`F = ${txt}`};
        }
        // si l‚Äôexo expose une version PDF d√©di√©e (tableaux resserr√©s, align√©s √† gauche)
        if(typeof def.printSolutionPDF==='function'){ return {solution:def.printSolutionPDF(st)}; }
        // sinon on rend la solution telle quelle (conserve le rouge pour l‚Äô√©nonc√© de l‚Äôex. 8)
        try{
          const tmp=document.createElement('div'); def.render(tmp,st);
          if(typeof def.solution==='function') def.solution(tmp,st);
          const sol=tmp.querySelector('.steps')||tmp.querySelector('#sol')||tmp;
          return {solution: sol.outerHTML||sol.innerHTML||''};
        }catch(e){
          return {solution:'<div class="steps"><div class="line">Corrig√© indisponible.</div></div>'};
        }
      }
    });
  }
});
</script>

<!-- Clavier -->
<script src="../../../../js/math-kbd.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on d√©clenche .click() sur eux)
[['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l‚Äôoriginal est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s‚Äôouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
