<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation (F = â€¦)</title>
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
#exo-select{min-width:360px}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer}
.btn:hover{background:#efefef}
.score{font-weight:700}

/* EnoncÃ© + case grisÃ©e Ã  droite */
.row3{display:grid;grid-template-columns:1fr 24px minmax(460px,1fr);gap:10px;align-items:start}
.eq-left .line{font-size:1.05rem}
.steps{background:#f6f7f8;border:1px dashed #cfd3d7;border-radius:10px;padding:.6rem .8rem;min-height:54px}
.steps .line{white-space:pre-wrap;font-size:1.02rem}
.steps .line + .line{margin-top:.25rem}

/* Tableaux (lâ€™Ã©cran utilise .tbl ; les styles PDF sont inline dans le HTML injectÃ©) */
.tbl{width:100%;margin:.55rem auto;table-layout:fixed;border-collapse:collapse}

/* Facteur commun (rouge) Ã  lâ€™Ã©cran */
.fc{color:#d32f2f;font-weight:700}

/* Saisie */
.ans-row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.ans-row .F{font-weight:700}
.ans-row input[type=text]{flex:1;min-width:200px;max-width:420px}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}

/* CarrÃ©s utiles */
.sqstrip{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px;margin-top:10px}
.sqbox{border:1px solid #e0e0e0;background:#fff;padding:8px 10px;border-radius:8px;text-align:center;font-variant-numeric:tabular-nums}

@media (max-width:980px){ .row3{grid-template-columns:1fr} }


</style>
</head>
<body>
  <div class="header">
    <div class="wrap" style="padding:10px 18px">
      <div class="controls">
        <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
        <select id="exo-select"></select>
        <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
        <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
        <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
        <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
        <span class="score">Score : <span id="score">0 / 0</span></span>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- EnoncÃ© + solution -->
    <div class="card" id="host"></div>

    <!-- Saisie & rÃ©ponses acceptÃ©es -->
    <div class="card" id="accept">
      <strong>Saisie & rÃ©ponses acceptÃ©es :</strong>
      <ul style="margin:.6rem 0 .2rem 1.25rem">
        <li>RÃ©pondre avec une <em>forme factorisÃ©e</em> (produit, parenthÃ¨ses, puissance).</li>
        <li><strong>Toute factorisation non triviale</strong> (facteur â‰  1, y compris un facteur numÃ©rique global ou un seul facteur commun) est <strong>acceptÃ©e</strong> si elle est algÃ©briquement Ã©quivalente Ã  F mais il est toujours demandÃ© dâ€™essayer de trouver la plus factorisÃ©e possible.</li>
        <li>Ã‰criture : <code>x</code> pour <code>1x</code>, <code>âˆ’x</code> pour <code>âˆ’1x</code>. Puissances : <code>x^n</code> ou <code>xÂ²</code>. Multiplications implicites acceptÃ©es.</li>
      </ul>
      <div style="margin-top:.6rem"><strong>CarrÃ©s utiles (0 Ã  20)</strong></div>
      <div class="sqstrip" id="squares-host"></div>
    </div>

    <!-- UI PDF -->
    <div id="pdf-anchor"></div>

    <!-- Clavier -->
    <div class="card" style="display:flex;justify-content:center"><div data-math-kbd></div></div>
  </div>

<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rndEx=(a,except)=>{let v=choice(a); if(except!=null){while(v===except){v=choice(a);} } return v;}
const MULT='Ã—';

/* ==== Ã‰valuation tolÃ©rante ==== */
// ajout de \u2212 (moins unicode)
const SAFE_RE = /^[0-9xX+\-*/().\s^Â·Ã—Â²\u2212]+$/;

/* ==== Ã‰valuation tolÃ©rante ==== */
function insertImplicitMultiplication(s){
  return String(s)
    // nombre  x   â†’ nombre*x  (espaces autorisÃ©s)
    .replace(/(\d)\s*x/gi, '$1*x')
    // x  nombre â†’ x*nombre
    .replace(/x\s*(\d)/gi, 'x*$1')
    // nombre ( â€¦ ) â†’ nombre*( â€¦ )
    .replace(/(\d)\s*\(/g, '$1*(')
    // x ( â€¦ ) â†’ x*( â€¦ )
    .replace(/x\s*\(/gi, 'x*(')
    // ( â€¦ ) nombre â†’ ( â€¦ )*nombre
    .replace(/\)\s*(\d)/g, ')*$1')
    // ( â€¦ ) x â†’ ( â€¦ )*x
    .replace(/\)\s*x/gi, ')*x')
    // ( â€¦ ) ( â€¦ ) â†’ ( â€¦ )*( â€¦ )
    .replace(/\)\s*\(/g, ')*(');
}

function evalExprAt(expr,x){
  let s=(expr||'').trim();
  if(!SAFE_RE.test(s)) throw new Error('chars');
  s=s.replace(/\u2212/g,'-').replace(/Ã—|Â·/g,'*')
     .replace(/([0-9xX)\]])\s*Â²/g,'$1**2').replace(/\^/g,'**');
  s=insertImplicitMultiplication(s);
  if(/(?:new|Function|=>|while|for|class|import|require|this)/.test(s)) throw new Error('bad');
  s=s.replace(/X/g,'x');
  const f=new Function('x',`return (${s});`);
  const v=f(x); if(!Number.isFinite(v)) throw new Error('NaN'); return v;
}
function algebraicEqual(user,ref){
  try{ for(const t of [-3,-2,-1,0,1,2,3,4]){ if(Math.abs(evalExprAt(user,t)-evalExprAt(ref,t))>1e-9) return false; } return true; }
  catch(e){ return false; }
}
function isTrivialByOne(user){
  const s = insertImplicitMultiplication(String(user||'')).replace(/\s+/g,'');
  // 1*(...) ou (...)*1
  if (/^[+]?1\*/.test(s)) return true;
  if (/\*1$/.test(s))     return true;
  // juste des parenthÃ¨ses autour dâ€™un polynÃ´me : ( ... ) sans produit/puissance
  if (/^\([^()]+\)$/.test(s)) return true;
  return false;
}

function looksFactorized(user){
  if (isTrivialByOne(user)) return false;

  // normalisation douce : implicite â†’ *, espaces supprimÃ©s, âˆ’ unicode â†’ '-'
  var s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-'))
            .replace(/\s+/g,'');

  // (â€¦)(â€¦)  OU  â€¦*(â€¦)  OU  (â€¦)*â€¦   â†’ produit de blocs
  if (/\)\(/.test(s)) return true;
  if (/\*\(/.test(s) || /\)\*/.test(s)) return true;

  // k(â€¦) avec k â‰  1
  if (/^[+-]?\d+\(.*\)$/.test(s) && !/^[+-]?1\(/.test(s)) return true;

  // Â±kx(â€¦)  ou  Â±x(â€¦)  ou  Â±kx^n(â€¦)
  if (/^[+-]?(?:\d+)?x(?:\^\d+)?\(.+\)$/i.test(s)) return true;

  // (â€¦ )^n / Â² / Â³ : puissance dâ€™un bloc parenthÃ©sÃ©
  if (/\([^()]+\)(?:\^\d+|Â²|Â³)$/.test(s)) return true;

  return false;
}

// Normalisation lÃ©gÃ¨re pour les motifs
function _normDS(s){
  return String(s||'')
    .replace(/\u2212/g,'-')     // minus unicode
    .replace(/\s+/g,'')         // espaces
    .replace(/\*\*/g,'^')       // **2 -> ^2
    .replace(/Â²/g,'^2')         // Â² -> ^2
    .replace(/[Ã—Â·]/g,'*');      // Ã— Â· -> *
}
const _isPerfectSquare = n => {
  const k = Math.sqrt(n);
  return Number.isInteger(k) && k>=0;
};
// (xÂ±n)(xâˆ“n) prÃ©sent ?
function _alreadyFactoredDSX(s){
  const t = _normDS(s);
  const re = /\(x([+-])(\d+)\)\*?\(x([+-])(\d+)\)/gi;
  let m; 
  while((m = re.exec(t))){
    const s1=m[1], n1=+m[2], s2=m[3], n2=+m[4];
    if(n1===n2 && s1!==s2) return true;
  }
  return false;
}
// Contient un (x^2 - n) ou (n - x^2) avec n carrÃ© parfait, non encore factorisÃ© ?
function _hasReducibleX2MinusSquare(s){
  const t = _normDS(s);
  // cherche dans des parenthÃ¨ses quelconques
  const re = /\((?:x\^2-(\d+)|(\d+)-x\^2)\)/g;
  let m;
  while((m=re.exec(t))){
    const n = +(m[1] ?? m[2]);
    if(_isPerfectSquare(n)) return true;
  }
  return false;
}
// "Ultime" pour l'ex.4 : dÃ©jÃ  (xÂ±n)(xâˆ“n) OU pas de x^2 - n^2 rÃ©siduel
function isUltimateEx4(user){
  if (_alreadyFactoredDSX(user)) return true;
  return !_hasReducibleX2MinusSquare(user);
}
// Normalise pour comparer proprement
function _normFlat(s){
  return insertImplicitMultiplication(String(s||''))
    .replace(/\u2212/g,'-')    // minus unicode â†’ '-'
    .replace(/[Ã—Â·]/g,'*')      // Ã— Â· â†’ *
    .replace(/\s+/g,'');       // sans espaces
}

// DÃ©tecte "rÃ©Ã©criture brute" pour ex.6 : (..)*(..) + (..)*(..)
// avec un facteur parenthÃ©sÃ© identique des deux cÃ´tÃ©s du '+'
function isRewriteOriginalEx6(user){
  const t = _normFlat(user);
  // force ')(' â†’ ')*(' via insertImplicitMultiplication â‡’ on peut chercher '*'
  const re = /\(([^()]+)\)\*\(([^()]+)\)\+\(([^()]+)\)\*\(([^()]+)\)/;
  const m = re.exec(t);
  if(!m) return false;
  const a=m[1], b=m[2], c=m[3], d=m[4];
  // facteur commun rÃ©pÃ©tÃ© Ã  gauche et Ã  droite ?
  return (a===c || a===d || b===c || b===d);
}

// DÃ©tecte "rÃ©Ã©criture brute" pour ex.7 : (..)*(..) - (..)*(..)
// avec un facteur parenthÃ©sÃ© identique des deux cÃ´tÃ©s du 'âˆ’'
function isRewriteOriginalEx7(user){
  const t = _normFlat(user);
  const re = /\(([^()]+)\)\*\(([^()]+)\)\-\(([^()]+)\)\*\(([^()]+)\)/;
  const m = re.exec(t);
  if(!m) return false;
  const a=m[1], b=m[2], c=m[3], d=m[4];
  return (a===c || a===d || b===c || b===d);
}


function acceptAnyFactorization(user,expandedRef){
  const eq=algebraicEqual(user,expandedRef); if(!eq) return false; return looksFactorized(user);
}
// PGFC
// PGCD
const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a||0; };

// Toutes les parenthÃ¨ses "linÃ©aires" (ax+b), formes: ax+b, b+ax, ax, x, etc.
function parseAllLinearInParens(user){
  let s = String(user||'').replace(/\u2212/g,'-');
  s = insertImplicitMultiplication(s);
  const L=[], re=/\(([^()]+)\)/g; let m;
  while((m=re.exec(s))){
    let t = m[1].replace(/\s+/g,'').replace(/\*/g,'');
    let r = t.match(/^([+-]?\d*)x([+-]\d+)$/);        // ax+b
    if(r){
      let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
      let b = parseInt(r[2],10);
      L.push({a,b}); continue;
    }
    r = t.match(/^([+-]?\d+)([+-])(\d*)x$/);          // b+ax
    if(r){
      let b = parseInt(r[1],10);
      let a = (r[3]===''?1:parseInt(r[3],10)) * (r[2]==='-'?-1:1);
      L.push({a,b}); continue;
    }
    r = t.match(/^([+-]?\d*)x$/);                     // ax
    if(r){
      let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
      L.push({a,b:0}); continue;
    }
    // constante seule â†’ on ignore
  }
  return L;
}

// x placÃ© Ã  lâ€™extÃ©rieur dâ€™une parenthÃ¨se ? (utile pour ex.1)
function hasOuterXAroundParen(user){
  let s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-')).replace(/\s+/g,'');
  return /x\*\(|\)\*x/i.test(s);
}

// "Ultime" gÃ©nÃ©rique : tous les (axÂ±b) copremiers ; possibilitÃ© dâ€™exiger x dehors (ex.1)
function isUltimateGeneric(user, opts={}){
  if (opts.requireOuterX && !hasOuterXAroundParen(user)) return false;
  const L = parseAllLinearInParens(user);
  for(const {a,b} of L){ if (gcd(a,b)>1) return false; }
  return true;
}

// Extrait (a,b) de la premiÃ¨re parenthÃ¨se rencontrÃ©e si elle est linÃ©aire en x
function parseLinearFromFirstParen(user){
  let s = String(user||'').replace(/\u2212/g,'-');
  s = insertImplicitMultiplication(s);
  const m = s.match(/\(([^()]+)\)/);
  if(!m) return null;
  let t = m[1].replace(/\s+/g,'').replace(/\*/g,'');
  // formes "ax+b" ou "b+ax"
  let r = t.match(/^([+-]?\d*)x([+-]\d+)$/);
  if(r){
    let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
    let b = parseInt(r[2],10);
    return {a,b};
  }
  r = t.match(/^([+-]?\d+)([+-])(\d*)x$/);
  if(r){
    let b = parseInt(r[1],10);
    let a = (r[3]===''?1:parseInt(r[3],10)) * (r[2]==='-'?-1:1);
    return {a,b};
  }
  return null;
}

// x placÃ© hors de la parenthÃ¨se (â€¦)*x ou x*(â€¦)
function hasOuterXAroundParen(user){
  let s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-')).replace(/\s+/g,'');
  return /x\*\(|\)\*x/i.test(s);
}

/* ==== helpers ==== */
function uminus(n){return n<0?'âˆ’'+Math.abs(n):String(n);}
function fmtAx(a){ if(a===1) return 'x'; if(a===-1) return 'âˆ’x'; return `${uminus(a)}x`; }
function binom(a,b){ return `( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`; }
function fc(s){ return `<span class="fc" style="color:#d32f2f;font-weight:700">${s}</span>`; }
function dedup(lines){ const out=[]; for(const L of lines){ if(!out.length || out[out.length-1]!==L) out.push(L); } return out; }

/* ==== rendu ==== */
function renderFrame(host,enonceHTML,placeholder){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row3';
  row.innerHTML=`
    <div class="consigne" style="grid-column:1/-1">Factoriser :</div>
    <div class="eq-left">
      <div class="line">F = <span class="equ">${enonceHTML}</span></div>
      <div style="margin-top:.7rem"><strong>RÃ©ponse (forme factorisÃ©e) :</strong></div>
      <div class="ans-row" style="margin-top:.1rem"><span class="F">F =</span> <input type="text" id="reponse" placeholder="${placeholder}"></div>
      <div id="res"></div>
    </div>
    <div></div>
    <div id="sol" class="steps"></div>
  `;
  host.appendChild(row);
  const ip=$("#reponse",host); ip&&ip.addEventListener('keydown',e=>{ if(e.key==='Enter'){e.preventDefault(); check(); }});
}

/* ================= EXERCICES ================= */

/* 1. Facteur commun */
/* 1. Facteur commun â€” PGFC systÃ©matique */
const ex1 = {
  id:"facteur-commun",
  title:"Mise en Ã©vidence du plus grand facteur commun",
  gen(){
    const g=choice([2,3,4,5,6,8,10,12]);
    const A=choice([1,2,3,4,5,6]);
    const B=choice([1,2,3,4,5,6,7,8,9]);
    const a=g*A, b=g*B;

    // PGFC numÃ©rique
    const d = gcd(a,b);
    const A1 = a/d, B1 = b/d;

    const lines = [
      `F = ${a}xÂ² + ${b}x`,
      `F = ${fc(d+'x')} ( ${A1}x + ${B1} )`
    ];
    return {
      txt:`${a}xÂ² + ${b}x`,
      ref:`${a}*x**2 + ${b}*x`,
      d, A1, B1,
      lines:dedup(lines)
    };
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  12x(2x+3)"); },

  // on exige la factorisation MAXIMALE : x dehors + coefficients copremiers dedans
  title:"Mise en Ã©vidence dâ€™un facteur commun",

correct(h,st){
  const v = ($("#reponse",h).value||"").trim();
  const ok = acceptAnyFactorization(v, st.ref); // Ã©quivalence + vraie factorisation
  $("#res",h).textContent = ok
    ? "âœ”"
    : "âœ˜ RÃ©ponse attendue : une forme factorisÃ©e Ã©quivalente (pas la forme dÃ©veloppÃ©e, ni 1(â€¦)).";
  $("#res",h).className = ok ? "res-ok" : "res-ko";
  return {ok,total:1};
},


  solution(h,st){
    $("#sol",h).innerHTML = st.lines.map(t=>`<div class="line">${t}</div>`).join("");
  },
  printSolutionPDF(st){
  const lines = Array.isArray(st?.lines) ? st.lines : (st?.lines ? [st.lines] : []);
  if (!lines.length) return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  const inner = lines.map(t => '<div class="line">' + String(t) + '</div>').join('');
  return '<div class="steps">' + inner + '</div>';
}

};


/* 2. (a Â± b)Â² â€” A/B et Â« car Â» sur la mÃªme ligne ; PDF resserrÃ© ET alignÃ© Ã  gauche */
const ex2={ id:"carre-parfait", title:"Reconnaitre (a Â± b)Â²",
  gen(){
    const p=choice([2,3,4,5,6,7]), q=choice([1,2,3,4,5,6,7,8,9]); const minus=Math.random()<0.5;
    const a2=p*p, b2=q*q, mid=2*p*q;

    const tdTop='style="border-left:2px solid #000;border-right:2px solid #000;border-top:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';
    const td0='style="border-left:2px solid #000;border-right:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';
    const tdBot='style="border-left:2px solid #000;border-right:2px solid #000;border-bottom:2px solid #000;padding:.45rem .9rem;vertical-align:middle;text-align:center"';

    const tbl_screen=`
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${p}x&nbsp;&nbsp; <u>car</u> : (${p}x)Â² = ${a2}xÂ²</td>
          <td ${tdTop}>B = ${q}&nbsp;&nbsp; <u>car</u> : ${q}Â² = ${b2}</td>
        </tr>
        <tr><td ${td0} colspan="2" style="text-align:center">2AB = 2 ${MULT} ${p}x ${MULT} ${q} = ${mid}x</td></tr>
        <tr><td ${tdBot} colspan="2"><u>câ€™est</u> donc bon</td></tr>
      </table>`;

    const tbl_pdf=`<div style="max-width:560px;margin:.2rem 0;font-size:95%">
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${p}x&nbsp;&nbsp; <u>car</u> : (${p}x)Â² = ${a2}xÂ²</td>
          <td ${tdTop}>B = ${q}&nbsp;&nbsp; <u>car</u> : ${q}Â² = ${b2}</td>
        </tr>
        <tr><td ${td0} colspan="2" style="text-align:center">2AB = 2 ${MULT} ${p}x ${MULT} ${q} = ${mid}x</td></tr>
        <tr><td ${tdBot} colspan="2"><u>câ€™est</u> donc bon</td></tr>
      </table></div>`;

    const txt=`${a2}xÂ² ${minus?'âˆ’':'+'} ${mid}x + ${b2}`;
    const ref=`${a2}*x**2 ${minus?'-':'+'} ${mid}*x + ${b2}`;

    const lines=[
      minus?`Rappel : AÂ² âˆ’ 2AB + BÂ² = (A âˆ’ B)Â²`:`Rappel : AÂ² + 2AB + BÂ² = (A + B)Â²`,
      `On cherche A tel que AÂ² = ${a2}xÂ², B tel que BÂ² = ${b2} puis on vÃ©rifie si 2AB = ${mid}`,
      tbl_screen,
      `F = ${a2}xÂ² ${minus?'âˆ’':'+'} ${mid}x + ${b2}`,
      `F = (${p}x ${minus?'âˆ’':'+'} ${q})Â²`
    ];
    return {txt,ref,lines:dedup(lines),tbl_pdf};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (5xÂ±7)^2"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ RÃ©ponse attendue : forme factorisÃ©e Ã©quivalente (non triviale)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
 printSolutionPDF(st){
  const src = Array.isArray(st && st.lines) ? st.lines
            : (st && st.lines ? [st.lines] : []);
  const pick = i => (i >= 0 && i < src.length ? src[i] : null);

  const selected = [
    pick(0),
    pick(1),
    st && st.tbl_pdf,
    pick(3),
    pick(4)
  ].filter(Boolean).map(String);

  if (!selected.length) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }

  var inner = '';
  for (var i = 0; i < selected.length; i++) {
    inner += '<div class="line">' + selected[i] + '</div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 3. AÂ² âˆ’ BÂ² â€” mÃªme format ; PDF resserrÃ© & alignÃ© Ã  gauche */
const ex3={ id:"diff-carres", title:"DiffÃ©rence de deux carrÃ©s",
  gen(){
    const t=choice([5,6,7,8,9,10,11,12,13,14]), c=choice([2,3,4,5,6,7,8,9,10]);

    const tdTop='style="border-left:2px solid #000;border-right:2px solid #000;border-top:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';

    const tbl_screen=`
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${t}x&nbsp;&nbsp; <u>car</u> : (${t}x)Â² = ${t*t}xÂ²</td>
          <td ${tdTop}>B = ${c}&nbsp;&nbsp; <u>car</u> : ${c}Â² = ${c*c}</td>
        </tr>
      </table>`;

    const tbl_pdf=`<div style="max-width:560px;margin:.2rem 0;font-size:95%">
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>A = ${t}x&nbsp;&nbsp; <u>car</u> : (${t}x)Â² = ${t*t}xÂ²</td>
          <td ${tdTop}>B = ${c}&nbsp;&nbsp; <u>car</u> : ${c}Â² = ${c*c}</td>
        </tr>
      </table></div>`;

    const txt=`${t*t}xÂ² âˆ’ ${c*c}`;
    const ref=`${t*t}*x**2 - ${c*c}`;

    const lines=[
      `Rappel : AÂ² âˆ’ BÂ² = (A + B)(A âˆ’ B)`,
      `On cherche A tel que AÂ² = ${t*t}xÂ², B tel que BÂ² = ${c*c}`,
      tbl_screen,
      `F = ${t*t}xÂ² âˆ’ ${c*c}`,
      `F = ( ${t}x + ${c} )( ${t}x âˆ’ ${c} )`
    ];
    return {txt,ref,lines:dedup(lines),tbl_pdf};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (13x+8)(13xâˆ’8)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : (txÂ±c)(txâˆ“c) ou forme Ã©quivalente."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var src = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  function pick(i){ return (i>=0 && i<src.length) ? src[i] : null; }

  var parts = [
    pick(0),
    pick(1),
    st && st.tbl_pdf,
    pick(3),
    pick(4)
  ].filter(function(v){ return v!=null && v!==''; }).map(String);

  if (!parts.length){
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i=0;i<parts.length;i++){
    var t = parts[i];
    if (seen[t]) continue;     // Ã©vite les doublons Ã©ventuels
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 4. DiffÃ©rence de deux carrÃ©s (aprÃ¨s factorisation) â€“ xÂ² âˆ’ rÂ² */
const ex4={ id:"diff-carres-apres-facto", title:"DiffÃ©rence de deux carrÃ©s (aprÃ¨s factorisation)",
  gen(){
    const k=choice([2,3,4,5,6,8,9]), r=choice([2,3,4,5,6,7,8,9]);
    const txt=`${k}xÂ² âˆ’ ${k*r*r}`;
    const ref=`${k}*x**2 - ${k*r*r}`;
    const lines=[
      `F = ${txt}`,
      `F = ${fc(String(k))}( xÂ² âˆ’ ${r*r} )`,
      `F = ${fc(String(k))}( x + ${r} )( x âˆ’ ${r} )`,
      `Rappel : AÂ² âˆ’ BÂ² = (A + B)(A âˆ’ B)`
    ];
    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  3(x+3)(xâˆ’3)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraire k puis utiliser AÂ²âˆ’BÂ²."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines
        : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue;     // Ã©vite les doublons Ã©ventuels
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 5. TrinÃ´me â€“ phrase Â« Il faudra rÃ©soudre un systÃ¨me. Â» */
const ex5={ id:"trinome-hors", title:"xÂ² + bx + c (hors programme)",
  gen(){
    let r=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
    let s=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]); while(s===r) s=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
    const S=r+s, P=r*s;
    const B=-(S), C=P;
    const txt=`xÂ² ${B>=0?'+':'âˆ’'} ${Math.abs(B)}x + ${C}`;
    const ref=`x**2 ${B>=0?'+':'-'} ${Math.abs(B)}*x + ${C}`;
    const lines=[
      `On cherche r, s tels que r + s = ${S} et rs = ${P}.`,
      `Il faudra rÃ©soudre un systÃ¨me.`,
      `F = ${txt}`,
      `F = ( x ${(-r>=0?'+':'âˆ’')} ${Math.abs(r)} )( x ${(-s>=0?'+':'âˆ’')} ${Math.abs(s)} )`
    ];
    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (xâˆ’r)(xâˆ’s)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : (xâˆ’r)(xâˆ’s) (non trivial)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue; // Ã©vite un doublon Ã©ventuel
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 6. Regrouper (somme de produits) â€” ajoute Ã©ventuellement la ligne k(ax+b) ou kx(ax+b) */
const ex6={ id:"regroup-somme", title:"Regrouper (somme de produits)",
  gen(){
    const a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), b=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]),
          c=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), d=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]),
          e=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), f=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const axb=binom(a,b), cxd=binom(c,d), exf=binom(e,f);
    const A=c+e, B=d+f;
    const txt=`${axb} ${cxd} + ${exf} ${axb}`.replace(/\)\s+\(/g,') (');
    const ref=`(${a}*x+(${b}))*( ${c}*x+(${d}) ) + (${e}*x+(${f}))*( ${a}*x+(${b}) )`;

    const lines=[
      `F = ${fc(axb)} ${cxd} + ${exf} ${fc(axb)}`,
      `F = ${fc(axb)} [ ${cxd} + ${exf} ]`,
      `F = ${fc(axb)} [ ${fmtAx(c)} ${d>=0?'+':'âˆ’'} ${Math.abs(d)} ${e>=0?'+':'âˆ’'} ${Math.abs(e)}x ${f>=0?'+':'âˆ’'} ${Math.abs(f)} ]`,
      `F = ${fc(axb)} ( ${fmtAx(A)} ${ B>=0?'+':'âˆ’'} ${Math.abs(B)} )`
    ];
    if (A===0){ lines.push(`F = ${uminus(B)}${fc(axb)}`); }
    else if (B===0){ lines.push(`F = ${fmtAx(A)}${fc(axb)}`); }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (ax+b)((c+e)x+(d+f))"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraction du facteur commun puis simplification."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue; // Ã©vite les doublons
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 7. Regrouper (diffÃ©rence de produits) â€” pas de doublons ; conclusions seulement si A=0 ou B=0 */
const ex7={ id:"regroup-diff", title:"Regrouper (diffÃ©rence de produits)",
  gen(){
    const u=choice([2,3,4,5,6,7,8,9]);
    const a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const b=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const collapse = Math.random() < 0.30;
    const c = collapse ? a : rndEx([-5,-4,-3,-2,-1,1,2,3,4,5], a);
    const d=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const e=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const f=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);

    const axb=binom(a,b), cxd=binom(c,d), exf=binom(e,f);
    const txt=`${axb} ${cxd} âˆ’ ${exf} ${axb}`.replace(/\)\s+\(/g,') (');
    const ref=`(${a}*x+(${b}))*(${c}*x+(${d})) - (${e}*x+(${f}))*(${a}*x+(${b}))`;

    const A=a-c, B=b-d;                     // (x+u)(Ax + B)
    const last = A===0 ? `${B}` : `${fmtAx(A)} ${B>=0?'+':'âˆ’'} ${Math.abs(B)}`;

    const lines = [
      `F = ${fc('( x + '+u+' )')} ${axb} âˆ’ ${cxd} ${fc('( x + '+u+' )')}`,
      `F = ${fc('( x + '+u+' )')} [ ${axb} âˆ’ ${cxd} ]`,
      `F = ${fc('( x + '+u+' )')} ( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} ${(-c)>=0?'+':'âˆ’'} ${Math.abs(c)}x ${(-d)>=0?'+':'âˆ’'} ${Math.abs(d)} )`,
      `F = ${fc('( x + '+u+' )')} ( ${last} )`
    ];
    if (A === 0) {
      lines.push(`F = ${B}( x + ${u} )`);
    } else if (B === 0) {
      lines.push(`F = ( x + ${u} )( ${fmtAx(A)} )`);
      lines.push(`F = ${fmtAx(A)}( x + ${u} )`);
    }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  (x+u)((aâˆ’c)x+(bâˆ’d)) ou k(x+u)"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraction de (x+u) puis regroupement (avec signe Â« âˆ’ Â»)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines : (st && st.lines ? [st.lines] : []);
  if (!L.length) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }

  var seen = Object.create(null), inner = '';
  for (var i = 0; i < L.length; i++) {
    var t = L[i];
    if (t == null || t === '') continue;
    t = String(t);
    if (seen[t]) continue; // Ã©vite les doublons
    seen[t] = true;
    inner += '<div class="line">' + t + '</div>';
  }

  if (!inner) {
    return '<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

/* 8. MÃ©lange â€” la 1Ê³áµ‰ ligne du corrigÃ© est lâ€™Ã©noncÃ© avec le facteur commun en ROUGE (xÂ² â†’ x colorÃ©, Â² gardÃ©) */
const ex8={ id:"melange", title:"Sommes / diffÃ©rences factorisables",
  gen(){
    const pat=choice([1,2,3]);
    let txt, ref, lines;

    if(pat===1){
      const k=choice([2,3,4,5]), u=choice([2,3,4,5,6,7]), b=choice([2,3,4]), c=choice([2,3,4,5,6]);
      txt=`${k}x( x âˆ’ ${u} ) âˆ’ ${2*k}xÂ²( x âˆ’ ${u} )( ${b}x âˆ’ ${c} )`;
      ref=`${k}*x*(x-(${u})) - ${2*k}*x**2*(x-(${u}))*(${b}*x-(${c}))`;
      const first=`F = ${fc(`${k}x( x âˆ’ ${u} )`)} âˆ’ ${2*k}xÂ²( x âˆ’ ${u} )( ${b}x âˆ’ ${c} )`;
      lines=[ first,
              `F = ${fc(`${k}x( x âˆ’ ${u} )`)} [ 1 âˆ’ 2x( ${b}x âˆ’ ${c} ) ]`,
              `F = ${fc(`${k}x( x âˆ’ ${u} )`)} ( 1 âˆ’ ${2*b}xÂ² + ${2*c}x )`];

    }else if(pat===2){
      const a=choice([-4,-3,-2,-1,1,2,3,4]), b=choice([-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8]);
      const m=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), n=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      const AB=`( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`;
      txt=`${AB} ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ${AB} ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} )`;
      ref=`(${a}*x+(${b}))*(x+(${m})) - (${a}*x+(${b}))*(x+(${n}))`;
      const first=`F = ${fc(AB)} ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ${fc(AB)} ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} )`;
      lines=[ first,
              `F = ${fc(AB)} [ ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} ) ]`,
              `F = ${fc(AB)} ( ${m-n} )`];

    }else{ // pat===3
      const a=choice([1,2,3]), b=choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);
      const u=choice([-4,-3,-2,-1,1,2,3,4]), v=choice([-4,-3,-2,-1,1,2,3,4]);
      txt=`xÂ²( ${a}x ${b>=0?'+':'âˆ’'} ${Math.abs(b)} ) + x( x ${u>=0?'+':'âˆ’'} ${Math.abs(u)} )( x ${v>=0?'+':'âˆ’'} ${Math.abs(v)} )`;
      ref=`x**2*(${a}*x+(${b})) + x*(x+(${u}))*(x+(${v}))`;
      // Colore uniquement le x de xÂ², garde bien Â² ; colore le x factored du second terme (quel que soit le signe)
      const txtFC = txt
        .replace('xÂ²', `${fc('x')}Â²`)
        .replace(/([+\-])\s*x\(/, (_,s)=> `${s} ${fc('x')}(`);
      const first=`F = ${txtFC}`;
      const expandUV=`xÂ² ${(u+v)>=0?'+':'âˆ’'} ${Math.abs(u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;
      const combined=`${a+1}xÂ² ${(b+u+v)>=0?'+':'âˆ’'} ${Math.abs(b+u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;
      lines=[ first, `F = ${fc('x')} [ ${a}xÂ² ${b>=0?'+':'âˆ’'} ${Math.abs(b)}x + ${expandUV} ]`, `F = ${fc('x')} ( ${combined} )`];
    }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,"ex.  â€¦"); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraction dâ€™un facteur pertinent puis simplification."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=st.lines.map(t=>`<div class="line">${t}</div>`).join(""); },
  printSolutionPDF(st){
  var L = Array.isArray(st && st.lines) ? st.lines
        : (st && st.lines ? [st.lines] : []);
  var inner = '';

  if (L.length){
    var seen = Object.create(null);
    for (var i = 0; i < L.length; i++){
      var t = L[i];
      if (t == null || t === '') continue;
      t = String(t);
      if (seen[t]) continue; // Ã©vite les doublons Ã©ventuels
      seen[t] = true;
      inner += '<div class="line">' + t + '</div>';
    }
  }

  if (!inner){
    inner = '<div class="line">CorrigÃ© indisponible.</div>';
  }
  return '<div class="steps">' + inner + '</div>';
}

};

const REGISTRY=[ex1,ex2,ex3,ex4,ex5,ex6,ex7,ex8];
window.REGISTRY=REGISTRY;
// Fabrique un correcteur "accepte + signale si non-ultime", avec rejets spÃ©cifiques
function makeCorrector(opts){
  return function(h, st){
    const v = ($("#reponse",h).value||"").trim();

    // 0) Rejet ciblÃ© : rÃ©Ã©criture brute de lâ€™Ã©noncÃ© (ex.6/7)
    if (opts && typeof opts.rejectOriginalRewrite === 'function' && opts.rejectOriginalRewrite(v, st)){
      $("#res",h).textContent = "âœ˜ Ce nâ€™est pas une factorisation : tu as rÃ©Ã©crit lâ€™Ã©noncÃ©. Extrais dâ€™abord le facteur commun.";
      $("#res",h).className = "res-ko";
      return {ok:false,total:1};
    }

    // 1) Doit Ãªtre une factorisation Ã©quivalente et non triviale
    const okCore = acceptAnyFactorization(v, st.ref);
    if(!okCore){
      $("#res",h).textContent = "âœ˜ RÃ©ponse attendue : une forme factorisÃ©e Ã©quivalente (pas la forme dÃ©veloppÃ©e, ni 1(â€¦)).";
      $("#res",h).className = "res-ko";
      return {ok:false,total:1};
    }

    // 2) Ultime ? (spÃ©cifique si fourni, sinon gÃ©nÃ©rique)
    const ultime = (opts && typeof opts.customUltimate==='function')
      ? opts.customUltimate(v, st)
      : isUltimateGeneric(v, opts||{});

    $("#res",h).innerHTML = ultime ? "âœ”" : "âœ” (mais tu peux encore factoriser)";
    $("#res",h).className = "res-ok";
    return {ok:true,total:1};
  };
}

// (RÃ©-)installation des correcteurs pour tous les exos
(function installUltimateCheck(){
  const OPTS = {
    "facteur-commun": { requireOuterX:true },
    "carre-parfait": {},
    "diff-carres": {},
    // ex.4 : rÃ¨gle spÃ©ciale â€œxÂ² âˆ’ nÂ²â€ (si tu l'as dÃ©jÃ  ajoutÃ©e)
    "diff-carres-apres-facto": { customUltimate: (typeof isUltimateEx4==='function'? isUltimateEx4 : undefined) },
    // â¬‡ï¸ refus explicite de la rÃ©Ã©criture brute
    "regroup-somme": { rejectOriginalRewrite: isRewriteOriginalEx6 },
    "regroup-diff":  { rejectOriginalRewrite: isRewriteOriginalEx7 },
    "trinome-hors": {},
    "melange": {}
  };

  (window.REGISTRY||REGISTRY).forEach(ex=>{
    const opts = OPTS[ex.id] || {};
    ex.correct = makeCorrector(opts);
  });
})();



/* ==== Orchestration ==== */
let scoreOK=0,scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){ const sel=$("#exo-select"),host=$("#host"); const def=REGISTRY.find(e=>e.id===sel.value); if(!def)return;
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st); const inp=$("#reponse",host); if(inp) inp.focus(); }
function check(){ const h=$("#host"); const d=REGISTRY.find(e=>e.id===h.dataset.active); if(!d)return; const st=JSON.parse(h.dataset.state||"{}"); const r=d.correct(h,st); if(r){scoreOK+=(r.ok?1:0);scoreTot+=(r.total||1);updateScore();}}
function solution(){ const h=$("#host"); const d=REGISTRY.find(e=>e.id===h.dataset.active); if(!d)return; const st=JSON.parse(h.dataset.state||"{}"); if(typeof d.solution==='function') d.solution(h,st); const sol=$("#sol",h); sol && sol.scrollIntoView({behavior:'smooth',block:'center'}); }
function resetAll(){ scoreOK=0;scoreTot=0;updateScore(); const h=$("#host"); $("#reponse",h)&&($("#reponse",h).value=""); $("#res",h).textContent=""; $("#sol",h).innerHTML=""; }

document.addEventListener('DOMContentLoaded',function(){
  const sel=$("#exo-select"); REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change',buildOne);

  // carrÃ©s utiles
  const sbox=$("#squares-host"); const items=[]; for(let n=0;n<=20;n++){items.push(`<div class="sqbox">${n}<sup>2</sup> = ${n*n}</div>`);} sbox.innerHTML=items.join("");

  $("#btn-new").addEventListener('click',buildOne);
  $("#btn-check").addEventListener('click',check);
  $("#btn-solution").addEventListener('click',solution);
  $("#btn-reset").addEventListener('click',resetAll);

  sel.value=REGISTRY[0].id; buildOne(); updateScore();
});
})();
</script>

<!-- GÃ©nÃ©rateur de fiches PDF -->
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded',function(){
  if(window.ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation (F = â€¦)',
      max:50,
      mountAfterSelector:'#accept',
      lead:'Factoriser :',
      beforeRender:function(def,st,withSolutions){
        if(!withSolutions){
          const txt=(st&&st.txt?String(st.txt):'').replace(/<[^>]+>/g,'');
          return {statement:`F = ${txt}`};
        }
        // si lâ€™exo expose une version PDF dÃ©diÃ©e (tableaux resserrÃ©s, alignÃ©s Ã  gauche)
        if(typeof def.printSolutionPDF==='function'){ return {solution:def.printSolutionPDF(st)}; }
        // sinon on rend la solution telle quelle (conserve le rouge pour lâ€™Ã©noncÃ© de lâ€™ex. 8)
        try{
          const tmp=document.createElement('div'); def.render(tmp,st);
          if(typeof def.solution==='function') def.solution(tmp,st);
          const sol=tmp.querySelector('.steps')||tmp.querySelector('#sol')||tmp;
          return {solution: sol.outerHTML||sol.innerHTML||''};
        }catch(e){
          return {solution:'<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>'};
        }
      }
    });
  }
});
</script>

<!-- Clavier -->
<script src="../../../../js/math-kbd.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre dâ€™actions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on dÃ©clenche .click() sur eux)
[['#btn-check','VÃ©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais lâ€™original est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si prÃ©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier sâ€™ouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points Ã  dÃ©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
