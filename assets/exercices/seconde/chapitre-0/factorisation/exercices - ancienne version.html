<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation</title>
<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.row{display:grid;grid-template-columns:1fr auto minmax(560px,1fr);gap:8px;align-items:center}
.row > div:last-child{overflow-x:auto}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.equ{font-weight:700}

/* Ã‰tapes alignÃ©es (jamais coupÃ©es) */
.steps{margin:.5rem 0 0 .15rem;padding:.6rem .7rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:10px;overflow-x:auto}
.eqline{display:grid;grid-template-columns:auto 2ch 1fr;gap:.4rem;align-items:baseline;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;white-space:nowrap}
.eqline .eq{text-align:center}
.eqline.none{grid-template-columns:1fr}
.eqline.colon{grid-template-columns:auto 2ch 1fr}
.eqline.colon .eq::after{content:":"}
.note{margin:.2rem 0 .4rem 0; color:#444}

/* Facteur commun (rouge) â€“ seulement lÃ  oÃ¹ il y a un FC */
.fc{color:#d32f2f;font-weight:700}

/* Tableau des carrÃ©s (exercice 3) */
.sqwrap{margin-top:.5rem}
.sqwrap .note{margin-bottom:.2rem}
.sqtab{border-collapse:collapse;width:auto}
.sqtab th,.sqtab td{border:1px solid #e0e0e0;padding:4px 8px;text-align:center;font-variant-numeric:tabular-nums}

/* Clavier */
.kbd-host{display:flex;justify-content:center}
.small{font-size:.92rem;color:#555}
</style>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde â€“ Chapitre 0 â€“ Calculs â€“ <strong>Factorisation</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <!-- Clavier math -->
    <div class="card kbd-host"><div data-math-kbd></div></div>
    <div class="small" style="text-align:center">
      Astuce : tu peux Ã©crire les puissances avec <code>^</code> (ex. <code>x^2</code>) ou utiliser <code>xÂ²</code>.
    </div>
  </div>

<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ===== affichage & signes ===== */
function uminus(n){ return n<0 ? 'âˆ’'+String(Math.abs(n)) : String(n); }
function normalizeSigns(s){
  return s
    .replace(/\u2212/g,'âˆ’')
    .replace(/\+\s*[âˆ’-]/g,' âˆ’ ')
    .replace(/[âˆ’-]\s*\+/g,' âˆ’ ')
    .replace(/[âˆ’-]\s*[âˆ’-]/g,' + ')
    .replace(/\+\s*\+/g,' + ')
    .replace(/\s{2,}/g,' ')
    .trim();
}
function canonPow2(s){ return s.replace(/([x0-9)])Â²/g, '$1<sup>2</sup>').replace(/\(<sup>2<\/sup>/g,'('); }
function fmtAx(a){ if(a===1) return 'x'; if(a===-1) return 'âˆ’x'; return `${uminus(a)}x`; }
function binom(a,b){ return `( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`; }
function fc(s){ return `<span class="fc" style="color:#d32f2f;font-weight:700">${s}</span>`; }

/* === Tableau des carrÃ©s 1..20 (affichÃ© sous lâ€™Ã©noncÃ© de lâ€™exo 3) === */
function squaresTableHTML(){
  const ns = Array.from({length:20}, (_,i)=>i+1);
  const rowN  = ns.map(n=>`<td>${n}</td>`).join('');
  const rowN2 = ns.map(n=>`<td>${n*n}</td>`).join('');
  return `
  <div class="sqwrap">
    <div class="note">CarrÃ©s utiles (1 Ã  20)</div>
    <table class="sqtab">
      <tr><th>n</th>${rowN}</tr>
      <tr><th>nÂ²</th>${rowN2}</tr>
    </table>
  </div>`;
}

/* ===== Ã‰tapes alignÃ©es ===== */
function stepsAlignedHTML(rows, notes = []) {
  const notesHTML = notes.map(t => `<div class="note">${t}</div>`).join("");
  const norm = (r) => {
    if (Array.isArray(r)) {
      const lhs = canonPow2(normalizeSigns((r[0] || ""))).trim();
      const rhs = canonPow2(normalizeSigns((r[1] || ""))).trim();
      return { lhs, rhs, connector: 'eq' };
    } else {
      const lhs = canonPow2(normalizeSigns((r.lhs || ""))).trim();
      const rhs = canonPow2(normalizeSigns((r.rhs || ""))).trim();
      const connector = r.connector || 'eq';
      return { lhs, rhs, connector };
    }
  };
  const out = []; let prevKey = "";
  for (const row of rows) {
    const { lhs, rhs, connector } = norm(row);
    const key = `${connector}|${lhs}|${rhs}`;
    if (key === prevKey) continue;
    prevKey = key;
    if (connector === 'none') out.push(`<div class="eqline none"><div class="lhs">${lhs}</div></div>`);
    else if (connector === 'colon') out.push(`<div class="eqline colon"><div class="lhs">${lhs}</div><div class="eq"></div><div class="rhs">${rhs}</div></div>`);
    else out.push(`<div class="eqline"><div class="lhs">${lhs}</div><div class="eq">=</div><div class="rhs">${rhs}</div></div>`);
  }
  return `<div class="steps">${notesHTML}${out.join("")}</div>`;
}

/* ===== Ã‰valuation sÃ»re (une seule dÃ©claration !) ===== */
const SAFE_RE = /^[0-9xX+\-*/().\s^Â·Ã—Â²]+$/;

// Ajoute les * manquants : 3x -> 3*x, 2(x+1) -> 2*(x+1), (x+1)(x-2) -> (x+1)*(x-2), etc.
function insertImplicitMultiplication(s){
  return s
    .replace(/(\d)(x)/gi, '$1*$2')   // 3x -> 3*x
    .replace(/(\d)\(/g, '$1*(')      // 2( -> 2*(
    .replace(/x(\d)/gi, 'x*$1')      // x2 -> x*2
    .replace(/x\(/gi, 'x*(')         // x( -> x*(
    .replace(/\)(\d)/g, ')*$1')      // )2 -> )*2
    .replace(/\)(x)/gi, ')*$1')      // )x -> )*x
    .replace(/\)\(/g, ')*(');        // )( -> )*(
}

function evalExprAt(expr, x){
  let s = (expr||"").trim();
  if(!SAFE_RE.test(s)) throw new Error("caractÃ¨res non autorisÃ©s");

  // normalisation des signes et opÃ©rateurs usuels
  s = s
    .replace(/\u2212/g,'-')   // âˆ’ -> -
    .replace(/Ã—|Â·/g,'*');     // Ã— Â· -> *

  // gÃ©rer toutes les Ã©critures au carrÃ© :
  //  - xÂ², 7Â², (2x+1)Â², XÂ², )Â²  â†’ **2
  s = s.replace(/([0-9xX)\]])\s*Â²/g, '$1**2');

  // gÃ©rer l'Ã©criture avec ^ (ex. ^2 ou ^3)
  s = s.replace(/\^/g,'**');

  // multiplications implicites (3x, 2(x+1), (x+1)(x-2), etc.)
  s = insertImplicitMultiplication(s);

  // petite sÃ©curitÃ©
  if(/(?:new|Function|=>|while|for|class|import|require|this)/.test(s)) throw new Error("expression invalide");

  s = s.replace(/X/g,'x');

  // eslint-disable-next-line no-new-func
  const f = new Function('x', `return (${s});`);
  const val = f(x);
  if(!Number.isFinite(val)) throw new Error("NaN");
  return val;
}

function algebraicEqual(user, refExpr){
  try{
    const pts = [-3,-2,-1,0,1,2,3,4];
    for(const t of pts){
      const u = evalExprAt(user, t);
      const v = evalExprAt(refExpr, t);
      if(Math.abs(u - v) > 1e-9) return false;
    }
    return true;
  }catch(e){ return false; }
}

/* ===== rendu commun ===== */
function renderOne(host, htmlEq, placeholder="ex.  (2x+3)(5xâˆ’1)", label='RÃ©ponse (forme factorisÃ©e)'){
  host.innerHTML="";
  const row0=document.createElement("div"); row0.className="row";
  const lab0=document.createElement("div"); lab0.className="equ"; lab0.innerHTML=htmlEq; row0.appendChild(lab0);
  const spacer=document.createElement("div"); spacer.textContent=""; row0.appendChild(spacer);
  const res0=document.createElement("div"); res0.id="res"; row0.appendChild(res0);
  host.appendChild(row0);

  const row1=document.createElement("div"); row1.className="row";
  const lab1=document.createElement("div"); lab1.innerHTML=label;
  const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder=placeholder;
  const res1=document.createElement("div"); res1.textContent="";
  row1.appendChild(lab1); row1.appendChild(inp); row1.appendChild(res1);
  host.appendChild(row1);
}

/* ================== EXERCICES ================== */

/* 1 â€” Facteur commun (avec rouge) */
const ex1 = {
  id:"facteur-commun",
  title:"Mise en Ã©vidence dâ€™un facteur commun",
  gen(){
    const useThree = Math.random()<0.5;
    const g = choice([2,3,4,5,6,7,8,9,10]);
    const ax = choice([1,2,3,4,5]);
    const bx = choice([1,2,3,4,5]);
    const c  = choice([1,2,3,4,5,6,7,8,9]);
    const withX = Math.random()<0.6;

    let txt="", factTxt="", inside="";
    if(useThree && withX){
      const a2 = g*ax, a1 = g*bx + g*c;
      txt = `${uminus(a2)}x<sup>2</sup> ${a1>=0?'+':'âˆ’'} ${Math.abs(a1)}x`;
      factTxt = `${g}x`; inside = `${ax}x ${(bx+c)>=0?'+':'âˆ’'} ${Math.abs(bx+c)}`;
    }else if(useThree){
      const a2 = g*ax, a1 = g*bx, a0 = g*c;
      txt = `${uminus(a2)}x<sup>2</sup> ${a1>=0?'+':'âˆ’'} ${Math.abs(a1)}x ${a0>=0?'+':'âˆ’'} ${Math.abs(a0)}`;
      factTxt = `${g}`; inside = `${ax}x<sup>2</sup> ${bx>=0?'+':'âˆ’'} ${Math.abs(bx)}x ${c>=0?'+':'âˆ’'} ${Math.abs(c)}`;
    }else if(withX){
      const a2 = g*ax, a1 = g*bx;
      txt = `${uminus(a2)}x<sup>2</sup> ${a1>=0?'+':'âˆ’'} ${Math.abs(a1)}x`;
      factTxt = `${g}x`; inside = `${ax}x ${bx>=0?'+':'âˆ’'} ${Math.abs(bx)}`;
    }else{
      const a1 = g*ax, a0 = g*c;
      txt = `${uminus(a1)}x ${a0>=0?'+':'âˆ’'} ${Math.abs(a0)}`;
      factTxt = `${g}`; inside = `${ax}x ${c>=0?'+':'âˆ’'} ${Math.abs(c)}`;
    }
    const refExpr = txt.replace(/x<sup>2<\/sup>/g,'x^2').replace(/âˆ’/g,'-').replace(/\s+/g,'');
    return {txt, factTxt, inside, refExpr};
  },
  text(st){ return `Factoriser : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  5x(x+12)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.refExpr) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue sous une forme factorisÃ©e Ã©quivalente (ex. a(x+â€¦)).";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
      {lhs:`On cherche un facteur commun`, connector:'none'},
      [`${st.txt}`, `${fc(st.factTxt)} ( ${st.inside} )`],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines);
    $("#reponse",host).value = `${st.factTxt}(${st.inside.replace(/\s/g,'')})`.replace(/\+\s*-/g,' - ');
  },
  printSolutionHTML(st){
    const chain = `${st.txt} = ${fc(st.factTxt)} ( ${st.inside} )`;
    return `<div class="steps"><div>${chain}</div></div>`;
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 2 â€” CarrÃ© parfait (sans rouge) */
const exCarre = {
  id:"carre-parfait",
  title:"Factoriser : carrÃ© parfait",
  gen(){
    const p = choice([1,2,3,4,5]);
    const q = choice([1,2,3,4,5,6,7,8,9]);
    const sign = choice(['+','âˆ’']);
    const a2 = p*p, a1 = (sign==='+') ? 2*p*q : -2*p*q, a0 = q*q;
    const txt = `${a2===1?'':uminus(a2)}x<sup>2</sup> ${a1>=0?'+':'âˆ’'} ${Math.abs(a1)}x ${a0>=0?'+':'âˆ’'} ${Math.abs(a0)}`;
    const refExpr = txt.replace(/x<sup>2<\/sup>/g,'x^2').replace(/âˆ’/g,'-').replace(/\s+/g,'');
    return {p,q,sign,txt,refExpr};
  },
  text(st){ return `Factoriser (reconnaÃ®tre un carrÃ© parfait) : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (3x+5)^2"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.refExpr) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : forme factorisÃ©e Ã©quivalente.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const A = `${st.p}x`, B = `${st.q}`;
    const lines = [
      {lhs:`On reconnaÃ®t la forme ${st.sign==='+'?'(A + B)Â²':'(A âˆ’ B)Â²'}`, connector:'none'},
      [`${st.txt}`, `${`( ${A} ${st.sign==='+'?'+':'âˆ’'} ${B} )`}<sup>2</sup>`],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines,[`Rappel : ${st.sign==='+'?'(A + B)Â² = AÂ² + 2AB + BÂ²':'(A âˆ’ B)Â² = AÂ² âˆ’ 2AB + BÂ²'}`]);
    $("#reponse",host).value = lines[1][1].replace(/Â²/g,'^2');
  },
  printSolutionHTML(st){
    const fact = st.sign==='+'?`(${st.p}x + ${st.q})Â²`:`(${st.p}x âˆ’ ${st.q})Â²`;
    return `<div class="steps"><div>${st.txt} = ${fact}</div></div>`;
  },
  reset: ex1.reset
};

/* 3 â€” DiffÃ©rence de deux carrÃ©s (t âˆˆ [1..20]) + tableau sous lâ€™Ã©noncÃ© */
const exDiffCarres = {
  id:"diff-carres",
  title:"Factoriser : diffÃ©rence de deux carrÃ©s",
  gen(){
    const t = choice(Array.from({length:20}, (_,i)=>i+1)); // t âˆˆ [1..20]
    const c = choice([1,2,3,4,5,6,7,8,9,10]);
    const aCoeff = t*t;
    const txt = `${aCoeff===1?'':uminus(aCoeff)}x<sup>2</sup> âˆ’ ${c*c}`;
    const refExpr = `${aCoeff}*x**2 - ${c*c}`;
    return {t,c,txt,refExpr};
  },
  text(st){ return `Factoriser (diffÃ©rence de deux carrÃ©s) : <span class="equ">${st.txt}</span>`; },
  render(host, st){
    host.innerHTML="";
    const row0=document.createElement("div"); row0.className="row";
    const lab0=document.createElement("div"); lab0.className="equ"; lab0.innerHTML=this.text(st);
    const spacer=document.createElement("div"); spacer.textContent="";
    const res0=document.createElement("div"); res0.id="res";
    row0.appendChild(lab0); row0.appendChild(spacer); row0.appendChild(res0);
    host.appendChild(row0);
    // tableau des carrÃ©s (sous lâ€™Ã©noncÃ©)
    const sq=document.createElement("div"); sq.innerHTML=squaresTableHTML(); host.appendChild(sq);
    // rÃ©ponse
    const row1=document.createElement("div"); row1.className="row";
    const lab1=document.createElement("div"); lab1.textContent='RÃ©ponse (forme factorisÃ©e)';
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="ex.  (txâˆ’c)(tx+c)";
    const res1=document.createElement("div"); res1.textContent="";
    row1.appendChild(lab1); row1.appendChild(inp); row1.appendChild(res1);
    host.appendChild(row1);
  },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.refExpr) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : (txâˆ’c)(tx+c) avec t entier.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const A = `${st.t}x`, B = `${st.c}`;
    const lines = [
      {lhs:`On utilise AÂ² âˆ’ BÂ² = (A âˆ’ B)(A + B)`, connector:'none'},
      [`${st.txt}`, `( ${A} âˆ’ ${B} )( ${A} + ${B} )`],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines); // pas de tableau ici
    $("#reponse",host).value = `(${st.t}x-${st.c})(${st.t}x+${st.c})`;
  },
  printSolutionHTML(st){
    const chain = `${st.txt} = ( ${st.t}x âˆ’ ${st.c} )( ${st.t}x + ${st.c} )`;
    return `<div class="steps"><div>${chain}</div></div>`; // pas de tableau dans le PDF
  },
  reset: ex1.reset
};

/* 3bis â€” DiffÃ©rence de carrÃ©s (aprÃ¨s factorisation) */
const exDiffCarresFacto = {
  id:"diff-carres-facto",
  title:"DiffÃ©rence de deux carrÃ©s (aprÃ¨s factorisation)",
  gen(){
    const k = choice([2,3,5]);
    const p = choice([1,2,3,4,5,6]);
    const q = choice([1,2,3,4,5,6,7,8,9]);
    const txt = `${k*p*p===1?'':uminus(k*p*p)}x<sup>2</sup> âˆ’ ${k*q*q}`;
    const refExpr = `${k*p*p}*x**2 - ${k*q*q}`;
    return {k,p,q,txt,refExpr};
  },
  text(st){ return `Factoriser : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  k(pxâˆ’q)(px+q)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.refExpr) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Piste : extraire dâ€™abord le facteur commun k, puis AÂ²âˆ’BÂ² Ã  lâ€™intÃ©rieur.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
      {lhs:`On extrait le facteur commun k`, connector:'none'},
      [`${st.txt}`, `${st.k} [ ${st.p*st.p}x<sup>2</sup> âˆ’ ${st.q*st.q} ]`],
      {lhs:`On applique AÂ² âˆ’ BÂ²`, connector:'none'},
      [``       , `${st.k} ( ${st.p}x âˆ’ ${st.q} )( ${st.p}x + ${st.q} )`],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines);
    $("#reponse",host).value = `${st.k}(${st.p}x-${st.q})(${st.p}x+${st.q})`;
  },
  printSolutionHTML(st){
    const chain = `${st.txt} = ${st.k} [ ${st.p*st.p}xÂ² âˆ’ ${st.q*st.q} ] = ${st.k} ( ${st.p}x âˆ’ ${st.q} )( ${st.p}x + ${st.q} )`;
    return `<div class="steps"><div>${normalizeSigns(chain)}</div></div>`;
  },
  reset: ex1.reset
};

/* 4 â€” TrinÃ´me simple (hors programme) */
const exTrinome = {
  id:"trinome-simple",
  title:"Factoriser : xÂ² + bx + c (racines entiÃ¨res) (hors programme)",
  gen(){
    const r = choice([-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9,10]);
    const s = choice([-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9,10]);
    if(Math.random()<0.4 && (r===0 || s===0)) return this.gen();
    const a1 = r+s, a0 = r*s;
    const txt = `x<sup>2</sup> ${a1>=0?'+':'âˆ’'} ${Math.abs(a1)}x ${a0>=0?'+':'âˆ’'} ${Math.abs(a0)}`;
    const refExpr = `x**2 ${a1>=0?'+':'-'} ${Math.abs(a1)}*x ${a0>=0?'+':'-'} ${Math.abs(a0)}`;
    return {r,s,txt,refExpr};
  },
  text(st){ return `Factoriser : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (x+3)(x-5)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.refExpr) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : forme factorisÃ©e Ã©quivalente (hors programme).";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
      {lhs:`On cherche r,s tels que r+s=${st.r+st.s} et rs=${st.r*st.s}`, connector:'none'},
      [`${st.txt}`, `( x ${st.r>=0?'+':'âˆ’'} ${Math.abs(st.r)} )( x ${st.s>=0?'+':'âˆ’'} ${Math.abs(st.s)} )`],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines);
  },
  printSolutionHTML(st){
    const chain = `${st.txt} = ( x ${st.r>=0?'+':'âˆ’'} ${Math.abs(st.r)} )( x ${st.s>=0?'+':'âˆ’'} ${Math.abs(st.s)} )`;
    return `<div class="steps"><div>${chain}</div></div>`;
  },
  reset: ex1.reset
};

/* 5 â€” Regrouper : somme (FC ax+b) */
const exSumCommon = {
  id:"regroupement-somme-produits",
  title:"Regrouper : somme de deux produits avec un facteur commun (ax+b)",
  gen(){
    const a = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const b = choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const c = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const d = choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const e = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const f = choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);

    const left1  = Math.random()<0.5;
    const left2  = Math.random()<0.5;

    const P = left1 ? `${binom(a,b)} ${binom(c,d)}` : `${binom(c,d)} ${binom(a,b)}`;
    const Q = left2 ? `${binom(a,b)} ${binom(e,f)}` : `${binom(e,f)} ${binom(a,b)}`;

    const txt = `${P} + ${Q}`.replace(/\)\s+\(/g,') (');
    const ref = `(${a}*x+(${b}))*(${c}*x+(${d})) + (${a}*x+(${b}))*(${e}*x+(${f}))`;

    const insideRemove = `${c}x ${d>=0?'+':'âˆ’'} ${Math.abs(d)} ${e>=0?'+':'âˆ’'} ${Math.abs(e)}x ${f>=0?'+':'âˆ’'} ${Math.abs(f)}`;
    const insideCombine = `${fmtAx(c+e)} ${ (d+f)>=0?'+':'âˆ’'} ${Math.abs(d+f)}`;

    return {a,b,c,d,e,f,left1,left2,txt,ref,insideRemove,insideCombine};
  },
  text(st){ return `Factoriser : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (ax+b)((c+e)x+(d+f))"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.ref) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : extraire (ax+b) puis simplifier lâ€™expression entre crochets.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const axb = `( ${fmtAx(st.a)} ${st.b>=0?'+':'âˆ’'} ${Math.abs(st.b)} )`;
    const step1Inside = `${binom(st.c,st.d)} + ${binom(st.e,st.f)}`;
    const lines = [
      {lhs:`Mise en Ã©vidence du facteur commun`, connector:'none'},
      [ `${st.txt}`, `${fc(axb)} [ ${step1Inside} ]` ],
      {lhs:`On enlÃ¨ve les parenthÃ¨ses`, connector:'none'},
      [ ``, `${fc(axb)} [ ${st.insideRemove} ]` ],
      {lhs:`On regroupe`, connector:'none'},
      [ ``, `${fc(axb)} ( ${st.insideCombine} )` ],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines);
    $("#reponse",host).value = `${axb.replace(/\s/g,'')}( ${(st.c+st.e)}x ${(st.d+st.f)>=0?'+':'-'} ${Math.abs(st.d+st.f)} )`.replace(/\s+/g,'');
  },
  printSolutionHTML(st){
    const axb = `( ${fmtAx(st.a)} ${st.b>=0?'+':'âˆ’'} ${Math.abs(st.b)} )`;
    const chain = `${st.txt} = ${fc(axb)} [ ${binom(st.c,st.d)} + ${binom(st.e,st.f)} ] = ${fc(axb)} [ ${st.insideRemove} ] = ${fc(axb)} ( ${st.insideCombine} )`;
    return `<div class="steps"><div>${normalizeSigns(chain)}</div></div>`;
  },
  reset: ex1.reset
};

/* 6 â€” Regrouper : diffÃ©rence (FC ax+b) */
const exDiffCommon = {
  id:"regroupement-difference-produits",
  title:"Regrouper : diffÃ©rence de deux produits avec un facteur commun (ax+b)",
  gen(){
    const a = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const b = choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const c = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const d = choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const e = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const f = choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);

    const left1  = Math.random()<0.5;
    const left2  = Math.random()<0.5;

    const P = left1 ? `${binom(a,b)} ${binom(c,d)}` : `${binom(c,d)} ${binom(a,b)}`;
    const Q = left2 ? `${binom(a,b)} ${binom(e,f)}` : `${binom(e,f)} ${binom(a,b)}`;

    const txt = `${P} âˆ’ ${Q}`.replace(/\)\s+\(/g,') (');
    const ref = `(${a}*x+(${b}))*(${c}*x+(${d})) - (${a}*x+(${b}))*(${e}*x+(${f}))`;

    const t1 = `${c}x`;
    const t2 = ` ${d>=0?'+':'âˆ’'} ${Math.abs(d)}`;
    const t3 = ` ${e>=0?'âˆ’':'+'} ${Math.abs(e)}x`;
    const t4 = ` ${f>=0?'âˆ’':'+'} ${Math.abs(f)}`;
    const insideRemoveDistributed = `${t1}${t2}${t3}${t4}`;
    const insideCombine = `${fmtAx(c-e)} ${ (d-f)>=0?'+':'âˆ’'} ${Math.abs(d-f)}`;

    return {a,b,c,d,e,f,left1,left2,txt,ref,insideRemoveDistributed,insideCombine};
  },
  text(st){ return `Factoriser : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (ax+b)((câˆ’e)x+(dâˆ’f))"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.ref) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : extraire (ax+b), distribuer le signe âˆ’, puis regrouper.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const axb = `( ${fmtAx(st.a)} ${st.b>=0?'+':'âˆ’'} ${Math.abs(st.b)} )`;
    const lines = [
      {lhs:`Mise en Ã©vidence du facteur commun`, connector:'none'},
      [ `${st.txt}`, `${fc(axb)} [ ${binom(st.c,st.d)} âˆ’ ${binom(st.e,st.f)} ]` ],
      {lhs:`On enlÃ¨ve les parenthÃ¨ses en distribuant "âˆ’"`, connector:'none'},
      [ ``, `${fc(axb)} [ ${st.insideRemoveDistributed} ]` ],
      {lhs:`On regroupe`, connector:'none'},
      [ ``, `${fc(axb)} ( ${st.insideCombine} )` ],
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(lines);
    $("#reponse",host).value = `${axb.replace(/\s/g,'')}( ${(st.c-st.e)}x ${(st.d-st.f)>=0?'+':'-'} ${Math.abs(st.d-st.f)} )`.replace(/\s+/g,'');
  },
  printSolutionHTML(st){
    const axb = `( ${fmtAx(st.a)} ${st.b>=0?'+':'âˆ’'} ${Math.abs(st.b)} )`;
    const chain = `${st.txt} = ${fc(axb)} [ ${binom(st.c,st.d)} âˆ’ ${binom(st.e,st.f)} ] = ${fc(axb)} [ ${st.insideRemoveDistributed} ] = ${fc(axb)} ( ${st.insideCombine} )`;
    return `<div class="steps"><div>${normalizeSigns(chain)}</div></div>`;
  },
  reset: ex1.reset
};

/* 7 â€” MÃ©lange (sommes / diffÃ©rences factoriables) */
const exMix = {
  id:"melange-sommes-differences",
  title:"MÃ©lange : sommes / diffÃ©rences factoriables",
  gen(){
    const pat = choice([1,2,3]);
    let txt, ref, data={};

    if(pat===1){
      const k=choice([1,2,3,4,5]), a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      const b=choice([1,2,3]), c=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      txt = `${k}x( x ${a>=0?'+':'âˆ’'} ${Math.abs(a)} ) âˆ’ ${2*k}x<sup>2</sup>( x ${a>=0?'+':'âˆ’'} ${Math.abs(a)} )( ${b}x ${c>=0?'+':'âˆ’'} ${Math.abs(c)} )`;
      ref = `${k}*x*(x+(${a})) - ${2*k}*x**2*(x+(${a}))*(${b}*x+(${c}))`;
      data = {k,a,b,c};
    } else if(pat===2){
      const a=choice([1,2,3]), b=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      const u=choice([-4,-3,-2,-1,1,2,3,4]), v=choice([-4,-3,-2,-1,1,2,3,4]);
      txt = `x<sup>2</sup>( ${a}x ${b>=0?'+':'âˆ’'} ${Math.abs(b)} ) + x( x ${u>=0?'+':'âˆ’'} ${Math.abs(u)} )( x ${v>=0?'+':'âˆ’'} ${Math.abs(v)} )`;
      ref = `x**2*(${a}*x+(${b})) + x*(x+(${u}))*(x+(${v}))`;
      data = {a,b,u,v};
    } else {
      const a=choice([-4,-3,-2,-1,1,2,3,4]), b=choice([-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8]);
      const m=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), n=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      txt = `${binom(a,b)} ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ${binom(a,b)} ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} )`;
      ref = `(${a}*x+(${b}))*(x+(${m})) - (${a}*x+(${b}))*(x+(${n}))`;
      data = {a,b,m,n};
    }
    return {pat, txt, ref, data};
  },
  text(st){ return `Factoriser : <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  x(x+a)[â€¦]"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = algebraicEqual(input, st.ref) && /\(/.test(input);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : extraire un facteur commun pertinent et simplifier.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const L = [];
    if(st.pat===1){
      const {k,a,b,c} = st.data;
      const F = `${k}x( x ${a>=0?'+':'âˆ’'} ${Math.abs(a)} )`;
      const inside1 = `1 âˆ’ 2x( ${b}x ${c>=0?'+':'âˆ’'} ${Math.abs(c)} )`;
      const inside2 = `1 âˆ’ ${(2*b)}x<sup>2</sup> ${(2*c)>=0?'+':'âˆ’'} ${Math.abs(2*c)}x`;
      const inside2Ordered = `${-(2*b)}x<sup>2</sup> ${(-2*c)>=0?'+':'âˆ’'} ${Math.abs(-2*c)}x + 1`;

      L.push({lhs:`Extraction du facteur commun`, connector:'none'});
      L.push([ `${st.txt}`, `${fc(F)} [ ${inside1} ]` ]);
      L.push({lhs:`On enlÃ¨ve les parenthÃ¨ses`, connector:'none'});
      L.push([ ``, `${fc(F)} [ ${inside2} ]` ]);
      L.push({lhs:`PolynÃ´me ordonnÃ© (degrÃ© dÃ©croissant)`, connector:'none'});
      L.push([ ``, `${fc(F)} ( ${inside2Ordered} )` ]);

      $("#res",host).innerHTML = stepsAlignedHTML(L);
      $("#reponse",host).value = `${F.replace(/\s/g,'')}( ${inside2Ordered.replace(/\s/g,'')} )`.replace(/âˆ’/g,'-');
    }
    else if(st.pat===2){
      const {a,b,u,v} = st.data;
      const F = `x`;
      const expandUV = `x<sup>2</sup> ${(u+v)>=0?'+':'âˆ’'} ${Math.abs(u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;
      const combined = `${(a+1)}x<sup>2</sup> ${(b+u+v)>=0?'+':'âˆ’'} ${Math.abs(b+u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;

      L.push({lhs:`Extraction du facteur commun`, connector:'none'});
      L.push([ `${st.txt}`, `${fc(F)} [ ${a}x<sup>2</sup> ${b>=0?'+':'âˆ’'} ${Math.abs(b)}x + ( x ${u>=0?'+':'âˆ’'} ${Math.abs(u)} )( x ${v>=0?'+':'âˆ’'} ${Math.abs(v)} ) ]` ]);
      L.push({lhs:`DÃ©veloppement de (x+u)(x+v)`, connector:'none'});
      L.push([ ``, `${fc(F)} [ ${a}x<sup>2</sup> ${b>=0?'+':'âˆ’'} ${Math.abs(b)}x + ${expandUV} ]` ]);
      L.push({lhs:`Regroupement des termes`, connector:'none'});
      L.push([ ``, `${fc(F)} ( ${combined} )` ]);

      $("#res",host).innerHTML = stepsAlignedHTML(L);
      $("#reponse",host).value = `x(${combined.replace(/\s/g,'')})`.replace(/âˆ’/g,'-');
    }
    else {
      const {a,b,m,n} = st.data;
      const AB = `( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`;
      const constMN = `${m-n}`;
      const expanded = `${(m-n)*a}x ${((m-n)*b)>=0?'+':'âˆ’'} ${Math.abs((m-n)*b)}`;

      L.push({lhs:`Mise en Ã©vidence du facteur commun`, connector:'none'});
      L.push([ `${st.txt}`, `${fc(AB)} [ ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} ) ]` ]);
      L.push({lhs:`On enlÃ¨ve les parenthÃ¨ses`, connector:'none'});
      L.push([ ``, `${fc(AB)} [ x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} âˆ’ x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} ]` ]);
      L.push({lhs:`On regroupe`, connector:'none'});
      L.push([ ``, `${fc(AB)} ( ${constMN} )` ]);
      L.push({lhs:`DÃ©veloppement (si souhaitÃ©)`, connector:'none'});
      L.push([ ``, `${fc(AB)} ( ${constMN} ) = ${constMN}Â·${fmtAx(a)} ${((m-n)*b)>=0?'+':'âˆ’'} ${Math.abs((m-n)*b)} = ${expanded}` ]);

      $("#res",host).innerHTML = stepsAlignedHTML(L);
      $("#reponse",host).value = `${AB.replace(/\s/g,'')}(${m-n})`.replace(/âˆ’/g,'-');
    }
  },
  printSolutionHTML(st){
    if(st.pat===1){
      const {k,a,b,c} = st.data;
      const F = `${k}x( x ${a>=0?'+':'âˆ’'} ${Math.abs(a)} )`;
      const inside2Ordered = `${-(2*b)}xÂ² ${(-2*c)>=0?'+':'âˆ’'} ${Math.abs(-2*c)}x + 1`;
      const chain = `${st.txt} = ${fc(F)} [ 1 âˆ’ 2x( ${b}x ${c>=0?'+':'âˆ’'} ${Math.abs(c)} ) ] = ${fc(F)} ( ${inside2Ordered} )`;
      return `<div class="steps"><div>${normalizeSigns(chain)}</div></div>`;
    }else if(st.pat===2){
      const {a,b,u,v} = st.data;
      const combined = `${(a+1)}xÂ² ${(b+u+v)>=0?'+':'âˆ’'} ${Math.abs(b+u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;
      const chain = `${st.txt} = ${fc('x')} [ ${a}xÂ² ${b>=0?'+':'âˆ’'} ${Math.abs(b)}x + (x+${u})(x+${v}) ] = ${fc('x')} ( ${combined} )`;
      return `<div class="steps"><div>${normalizeSigns(chain)}</div></div>`;
    }else{
      const {a,b,m,n} = st.data;
      const AB = `( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`;
      const chain = `${st.txt} = ${fc(AB)} [ (x+${m}) âˆ’ (x+${n}) ] = ${fc(AB)} ( ${m-n} )`;
      return `<div class="steps"><div>${normalizeSigns(chain)}</div></div>`;
    }
  },
  reset: ex1.reset
};

/* ====== Orchestrateur ====== */
const REGISTRY = [
  ex1,                 // facteur commun (rouge)
  exCarre,             // carrÃ© parfait
  exDiffCarres,        // A^2 - B^2 (t âˆˆ [1..20]) + tableau sous lâ€™Ã©noncÃ©
  exDiffCarresFacto,   // A^2 - B^2 aprÃ¨s factorisation
  exTrinome,           // trinÃ´me (hors programme)
  exSumCommon,         // regroupement somme (rouge)
  exDiffCommon,        // regroupement diffÃ©rence (rouge)
  exMix                // mÃ©lange
];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st=def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);
  const inp = $("#reponse",host) || $("#reponse-vf",host) || $("#reponse-id",host); if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def){ def.reset(host); }
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement("option"); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  sel.value = REGISTRY[0].id;
  buildOne(); updateScore();
});
})();
</script>

<!-- GÃ©nÃ©rateur de fiches PDF -->
<script src="../../../../js/exo-pdf-kit.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  ExoPDF.init({
    title: 'Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation',
    max: 50,
    lead: 'Factoriser les expressions suivantes :',
    leadByDefId: {
      "facteur-commun": 'Mise en Ã©vidence dâ€™un facteur commun =',
      "carre-parfait": 'CarrÃ© parfait =',
      "diff-carres": 'DiffÃ©rence de deux carrÃ©s =',
      "diff-carres-facto": 'DiffÃ©rence de deux carrÃ©s (aprÃ¨s factorisation) =',
      "trinome-simple": 'xÂ² + bx + c (hors programme) =',
      "regroupement-somme-produits": 'Regrouper (somme de produits) =',
      "regroupement-difference-produits": 'Regrouper (diffÃ©rence de produits) =',
      "melange-sommes-differences": 'Sommes / diffÃ©rences factoriables ='
    }
  });
});
</script>

<!-- Clavier math -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.js" defer></script>
</body>
</html>
