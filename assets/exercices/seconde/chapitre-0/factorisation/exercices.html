<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation (F = â€¦)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
#exo-select{min-width:360px}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer}
.btn:hover{background:#efefef}
.score{font-weight:700}

/* EnoncÃ© + case grisÃ©e Ã  droite */
.row3{display:grid;grid-template-columns:1fr 24px minmax(460px,1fr);gap:10px;align-items:start}
.eq-left .line{font-size:1.05rem}
.steps{background:#f6f7f8;border:1px dashed #cfd3d7;border-radius:10px;padding:.6rem .8rem;min-height:54px}
.steps .line{white-space:pre-wrap;font-size:1.02rem}
.steps .line + .line{margin-top:.25rem}

/* Tableaux (lâ€™Ã©cran utilise .tbl ; les styles PDF sont inline dans le HTML injectÃ©) */
.tbl{width:100%;margin:.55rem auto;table-layout:fixed;border-collapse:collapse}



/* Saisie */
.ans-row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.ans-row .F{font-weight:700}
.ans-row input[type=text]{flex:1;min-width:200px;max-width:420px}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}

/* CarrÃ©s utiles */
.sqstrip{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px;margin-top:10px}
.sqbox{border:1px solid #e0e0e0;background:#fff;padding:8px 10px;border-radius:8px;text-align:center;font-variant-numeric:tabular-nums}

@media (max-width:980px){ .row3{grid-template-columns:1fr} }
</style>

<!-- MathJax v3 -->
<script>
  window.MathJax = {
    loader: { load: ['[tex]/color'] },
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['color'] },
      macros: {
        frac: ['\\dfrac{#1}{#2}', 2],
        // rouge Material D32F2F â‰ˆ (0.827, 0.184, 0.184)
        fc:   ['{\\color[rgb]{0.827,0.184,0.184}{#1}}', 1]
      }
    },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>

<body>
  <div class="header">
    <div class="wrap" style="padding:10px 18px">
      <div class="controls">
        <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
        <select id="exo-select"></select>
        <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
        <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
        <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
        <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
        <span class="score">Score : <span id="score">0 / 0</span></span>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- EnoncÃ© + solution -->
    <div class="card" id="host"></div>

    <!-- Saisie & rÃ©ponses acceptÃ©es -->
    <div class="card" id="accept">
      <strong>Saisie & rÃ©ponses acceptÃ©es :</strong>
      <ul style="margin:.6rem 0 .2rem 1.25rem">
        <li>RÃ©pondre avec une <em>forme factorisÃ©e</em> (produit, parenthÃ¨ses, puissance).</li>
        <li><strong>Toute factorisation non triviale</strong> (facteur â‰  1, y compris un facteur numÃ©rique global ou un seul facteur commun) est <strong>acceptÃ©e</strong> si elle est algÃ©briquement Ã©quivalente Ã  F mais il est toujours demandÃ© dâ€™essayer de trouver la plus factorisÃ©e possible.</li>
        <li>Ã‰criture : <code>x</code> pour <code>1x</code>, <code>âˆ’x</code> pour <code>âˆ’1x</code>. Puissances : <code>x^n</code> ou <code>xÂ²</code>. Multiplications implicites acceptÃ©es.</li>
      </ul>
      <div style="margin-top:.6rem"><strong>CarrÃ©s utiles (0 Ã  20)</strong></div>
      <div class="sqstrip" id="squares-host"></div>
    </div>

    <!-- UI PDF -->
    <div id="pdf-anchor"></div>

    <!-- Clavier -->
    <div class="card" style="display:flex;justify-content:center"><div data-math-kbd></div></div>
  </div>

<script>
(function(){'use strict';
/* ====== util ====== */
const $=(s,r=document)=>r.querySelector(s);
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rndEx=(a,except)=>{let v=choice(a); if(except!=null){while(v===except){v=choice(a);} } return v;}
const MULT='Ã—';

/* ==== Ã‰valuation tolÃ©rante ==== */
// ajout de \u2212 (moins unicode)
const SAFE_RE = /^[-0-9xX+*/().\s^Â·Ã—Â²\u2212]+$/;

function insertImplicitMultiplication(s){
  return String(s)
    .replace(/(\d)\s*x/gi, '$1*x')
    .replace(/x\s*(\d)/gi, 'x*$1')
    .replace(/(\d)\s*\(/g, '$1*(')
    .replace(/x\s*\(/gi, 'x*(')
    .replace(/\)\s*(\d)/g, ')*$1')
    .replace(/\)\s*x/gi, ')*x')
    .replace(/\)\s*\(/g, ')*(');
}

function evalExprAt(expr,x){
  let s=(expr||'').trim();
  if(!SAFE_RE.test(s)) throw new Error('chars');
  s=s.replace(/\u2212/g,'-').replace(/Ã—|Â·/g,'*')
     .replace(/([0-9xX)\]])\s*Â²/g,'$1**2').replace(/\^/g,'**');
  s=insertImplicitMultiplication(s);
  if(/(?:new|Function|=>|while|for|class|import|require|this)/.test(s)) throw new Error('bad');
  s=s.replace(/X/g,'x');
  const f=new Function('x',`return (${s});`);
  const v=f(x); if(!Number.isFinite(v)) throw new Error('NaN'); return v;
}
function algebraicEqual(user,ref){
  try{ for(const t of [-3,-2,-1,0,1,2,3,4]){ if(Math.abs(evalExprAt(user,t)-evalExprAt(ref,t))>1e-9) return false; } return true; }
  catch(e){ return false; }
}
function isTrivialByOne(user){
  const s = insertImplicitMultiplication(String(user||'')).replace(/\s+/g,'');
  if (/^[+]?1\*/.test(s)) return true;
  if (/\*1$/.test(s))     return true;
  if (/^\([^()]+\)$/.test(s)) return true;
  return false;
}

function looksFactorized(user){
  if (isTrivialByOne(user)) return false;
  var s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-')).replace(/\s+/g,'');
  if (/\)\(/.test(s)) return true;
  if (/\*\(/.test(s) || /\)\*/.test(s)) return true;
  if (/^[+-]?\d+\(.*\)$/.test(s) && !/^[+-]?1\(/.test(s)) return true;
  if (/^[+-]?(?:\d+)?x(?:\^\d+)?\(.+\)$/i.test(s)) return true;
  if (/\([^()]+\)(?:\^\d+|Â²|Â³)$/.test(s)) return true;
  return false;
}

/* ==== helpers ==== */
function uminus(n){return n<0?'âˆ’'+Math.abs(n):String(n);}
function fmtAx(a){ if(a===1) return 'x'; if(a===-1) return 'âˆ’x'; return `${uminus(a)}x`; }
function binom(a,b){ return `( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`; }
function fc(s){ return '\\fc{'+ s +'}'; }
function dedup(lines){ const out=[]; for(const L of lines){ if(!out.length || out[out.length-1]!==L) out.push(L); } return out; }

/* === LaTeX helpers === */
function toTex(s){
  return String(s||'')
    .replace(/&nbsp;/g,' ')
    .replace(/\u2212/g,'-')
    .replace(/âˆ’/g,'-')
    .replace(/Ã—/g,'\\times')
    .replace(/Â·/g,'\\cdot')
    .replace(/xÂ²/g,'x^2')
    .replace(/xÂ³/g,'x^3')
    .replace(/\(\s*/g,'(').replace(/\s*\)/g,')');
}
function latexWrap(s){ return '\\( ' + toTex(s) + ' \\)'; }

/* Enveloppe toutes les lignes solution/PDF en \( ... \)
   - Si la ligne contient dÃ©jÃ  du TeX (\\( ou \\[) OU commence par "<" (HTML/table),
     on NE rajoute pas un second wrapper. */
function renderStepsLatex(lines){
  const L = Array.isArray(lines) ? lines : (lines ? [lines] : []);
  if(!L.length) return '<div class="steps"><div class="line">Aucune Ã©tape.</div></div>';
  const parts = L.map(t=>{
    const str = String(t);
    const isHTML = /^\s*</.test(str);
    const hasTeX = /\\\(|\\\[/.test(str);
    if(isHTML) return '<div class="line">'+str+'</div>';
    return '<div class="line">'+(hasTeX?str:latexWrap(str))+'</div>';
  }).join('');
  return '<div class="steps">'+parts+'</div>';
}

/* ==== PDF helpers ==== */
function acceptAnyFactorization(user,expandedRef){
  const eq=algebraicEqual(user,expandedRef); if(!eq) return false; return looksFactorized(user);
}
const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a||0; };

/* Parsers/ultimes spÃ©cifiques (ex.4, ex.6, ex.7) */
function _normDS(s){
  return String(s||'')
    .replace(/\u2212/g,'-')
    .replace(/\s+/g,'')
    .replace(/\*\*/g,'^')
    .replace(/Â²/g,'^2')
    .replace(/[Ã—Â·]/g,'*');
}
const _isPerfectSquare = n => { const k = Math.sqrt(n); return Number.isInteger(k) && k>=0; };
function _alreadyFactoredDSX(s){
  const t = _normDS(s);
  const re = /\(x([+-])(\d+)\)\*?\(x([+-])(\d+)\)/gi;
  let m; 
  while((m = re.exec(t))){
    const s1=m[1], n1=+m[2], s2=m[3], n2=+m[4];
    if(n1===n2 && s1!==s2) return true;
  }
  return false;
}
function _hasReducibleX2MinusSquare(s){
  const t = _normDS(s);
  const re = /\((?:x\^2-(\d+)|(\d+)-x\^2)\)/g;
  let m;
  while((m=re.exec(t))){
    const n = +(m[1] ?? m[2]);
    if(_isPerfectSquare(n)) return true;
  }
  return false;
}
function isUltimateEx4(user){
  if (_alreadyFactoredDSX(user)) return true;
  return !_hasReducibleX2MinusSquare(user);
}
function _normFlat(s){
  return insertImplicitMultiplication(String(s||''))
    .replace(/\u2212/g,'-')
    .replace(/[Ã—Â·]/g,'*')
    .replace(/\s+/g,'');
}
function isRewriteOriginalEx6(user){
  const t = _normFlat(user);
  const re = /\(([^()]+)\)\*\(([^()]+)\)\+\(([^()]+)\)\*\(([^()]+)\)/;
  const m = re.exec(t);
  if(!m) return false;
  const a=m[1], b=m[2], c=m[3], d=m[4];
  return (a===c || a===d || b===c || b===d);
}
function isRewriteOriginalEx7(user){
  const t = _normFlat(user);
  const re = /\(([^()]+)\)\*\(([^()]+)\)\-\(([^()]+)\)\*\(([^()]+)\)/;
  const m = re.exec(t);
  if(!m) return false;
  const a=m[1], b=m[2], c=m[3], d=m[4];
  return (a===c || a===d || b===c || b===d);
}
function parseAllLinearInParens(user){
  let s = String(user||'').replace(/\u2212/g,'-');
  s = insertImplicitMultiplication(s);
  const L=[], re=/\(([^()]+)\)/g; let m;
  while((m=re.exec(s))){
    let t = m[1].replace(/\s+/g,'').replace(/\*/g,'');
    let r = t.match(/^([+-]?\d*)x([+-]\d+)$/);        // ax+b
    if(r){
      let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
      let b = parseInt(r[2],10);
      L.push({a,b}); continue;
    }
    r = t.match(/^([+-]?\d+)([+-])(\d*)x$/);          // b+ax
    if(r){
      let b = parseInt(r[1],10);
      let a = (r[3]===''?1:parseInt(r[3],10)) * (r[2]==='-'?-1:1);
      L.push({a,b}); continue;
    }
    r = t.match(/^([+-]?\d*)x$/);                     // ax
    if(r){
      let a = r[1]===''||r[1]==='+'?1:(r[1]==='-'?-1:parseInt(r[1],10));
      L.push({a,b:0}); continue;
    }
  }
  return L;
}
function hasOuterXAroundParen(user){
  let s = insertImplicitMultiplication(String(user||'').replace(/\u2212/g,'-')).replace(/\s+/g,'');
  return /x\*\(|\)\*x/i.test(s);
}
function isUltimateGeneric(user, opts={}){
  if (opts.requireOuterX && !hasOuterXAroundParen(user)) return false;
  const L = parseAllLinearInParens(user);
  for(const {a,b} of L){ if (gcd(a,b)>1) return false; }
  return true;
}
// -- Relance MathJax sur un nÅ“ud quand on injecte du LaTeX --
function mjxTypeset(node){
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([node]).catch(()=>{ /* noop */ });
  }
}

/* ==== rendu ==== */
function renderFrame(host,enonceHTML,placeholder){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row3';
  row.innerHTML=`
    <div class="consigne" style="grid-column:1/-1">Factoriser :</div>
    <div class="eq-left">
      <div class="line">\\( F\\;=\\;${toTex(enonceHTML)} \\)</div>
      <div style="margin-top:.7rem"><strong>RÃ©ponse (forme factorisÃ©e) :</strong></div>
      <div class="ans-row" style="margin-top:.1rem"><span class="F">F =</span> <input type="text" id="reponse" placeholder="${placeholder}"></div>
      <div id="res"></div>
    </div>
    <div></div>
    <div id="sol" class="steps"></div>
  `;
  host.appendChild(row);
  mjxTypeset(host);   // âŸµ  AJOUT
  const ip=$("#reponse",host); ip&&ip.addEventListener('keydown',e=>{ if(e.key==='Enter'){e.preventDefault(); check(); }});
}

/* ================= EXERCICES ================= */

/* 1. Facteur commun */
const ex1 = {
  id:"facteur-commun",
  title:"Mise en Ã©vidence du plus grand facteur commun",
  gen(){
    const g=choice([2,3,4,5,6,8,10,12]);
    const A=choice([1,2,3,4,5,6]);
    const B=choice([1,2,3,4,5,6,7,8,9]);
    const a=g*A, b=g*B;

    const d = gcd(a,b);
    const A1 = a/d, B1 = b/d;

    const lines = [
      `F = ${a}xÂ² + ${b}x`,
      `F = ${fc(d+'x')} ( ${A1}x + ${B1} )`
    ];
    return {
      txt:`${a}xÂ² + ${b}x`,
      ref:`${a}*x**2 + ${b}*x`,
      d, A1, B1,
      lines:dedup(lines)
    };
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){
    const v = ($("#reponse",h).value||"").trim();
    const ok = acceptAnyFactorization(v, st.ref);
    $("#res",h).textContent = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : une forme factorisÃ©e Ã©quivalente (pas la forme dÃ©veloppÃ©e, ni 1(â€¦)).";
    $("#res",h).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(h,st){
    $("#sol",h).innerHTML = renderStepsLatex(st.lines);
	mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){
    return renderStepsLatex(st && st.lines ? st.lines : []);
  }
};

/* 2. (a Â± b)Â² â€” A/B et Â« car Â» sur la mÃªme ligne ; PDF resserrÃ© ET alignÃ© Ã  gauche */
const ex2={ id:"carre-parfait", title:"Reconnaitre (a Â± b)Â²",
  gen(){
    const p=choice([2,3,4,5,6,7]), q=choice([1,2,3,4,5,6,7,8,9]); const minus=Math.random()<0.5;
    const a2=p*p, b2=q*q, mid=2*p*q;

    const tdTop='style="border-left:2px solid #000;border-right:2px solid #000;border-top:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';
    const td0='style="border-left:2px solid #000;border-right:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';
    const tdBot='style="border-left:2px solid #000;border-right:2px solid #000;border-bottom:2px solid #000;padding:.45rem .9rem;vertical-align:middle;text-align:center"';

    const tbl_screen=`
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>\\(A = ${p}x\\) <u>car</u> : \\( (${p}x)^2 \\) = \\( ${a2}x^2 \\)</td>
          <td ${tdTop}>\\(B = ${q}\\) <u>car</u> : \\( ${q}^2 \\) = \\( ${b2} \\)</td>
        </tr>
        <tr><td ${td0} colspan="2" style="text-align:center">\\( 2AB = 2 \\times ${p}x \\times ${q} = ${mid}x \\)</td></tr>
        <tr><td ${tdBot} colspan="2"><u>câ€™est</u> donc bon</td></tr>
      </table>`;

    const tbl_pdf=`<div style="max-width:560px;margin:.2rem 0;font-size:95%">
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>\\(A = ${p}x\\) <u>car</u> : \\( (${p}x)^2 \\) = \\( ${a2}x^2 \\)</td>
          <td ${tdTop}>\\(B = ${q}\\) <u>car</u> : \\( ${q}^2 \\) = \\( ${b2} \\)</td>
        </tr>
        <tr><td ${td0} colspan="2" style="text-align:center">\\( 2AB = 2 \\times ${p}x \\times ${q} = ${mid}x \\)</td></tr>
        <tr><td ${tdBot} colspan="2"><u>câ€™est</u> donc bon</td></tr>
      </table></div>`;

    const txt=`${a2}x^2 ${minus?'âˆ’':'+'} ${mid}x + ${b2}`;
    const ref=`${a2}*x**2 ${minus?'-':'+'} ${mid}*x + ${b2}`;
const l0 = minus
  ? 'Rappel : \\( A^2 - 2AB + B^2 = (A - B)^2 \\)'
  : 'Rappel : \\( A^2 + 2AB + B^2 = (A + B)^2 \\)';

const l1 = `On cherche \\(A\\) tel que \\(A^2 = ${a2}x^2\\), \\(B\\) tel que \\(B^2 = ${b2}\\),
puis on vÃ©rifie si \\(2AB = ${mid}x\\)`;

    const lines = [
  l0,
  l1,
  tbl_screen,
  `F = ${a2}x^2 ${minus?'âˆ’':'+'} ${mid}x + ${b2}`,
  `F = (${p}x ${minus?'âˆ’':'+'} ${q})^2`
];

    return {txt,ref,lines:dedup(lines),tbl_pdf};
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ RÃ©ponse attendue : forme factorisÃ©e Ã©quivalente (non triviale)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines); 
  mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){
    const src = Array.isArray(st?.lines) ? st.lines : (st?.lines ? [st.lines] : []);
    const pick = i => (i >= 0 && i < src.length ? src[i] : null);
    const selected = [ pick(0), pick(1), st?.tbl_pdf, pick(3), pick(4) ]
      .filter(Boolean).map(String);
    return renderStepsLatex(selected);
  }
};

/* 3. AÂ² âˆ’ BÂ² â€” mÃªme format ; PDF resserrÃ© & alignÃ© Ã  gauche */
const ex3={ id:"diff-carres", title:"DiffÃ©rence de deux carrÃ©s",
  gen(){
    const t=choice([5,6,7,8,9,10,11,12,13,14]), c=choice([2,3,4,5,6,7,8,9,10]);

    const tdTop='style="border-left:2px solid #000;border-right:2px solid #000;border-top:2px solid #000;padding:.45rem .9rem;vertical-align:middle"';

    const tbl_screen=`
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>\\(A = ${t}x\\) <u>car</u> : \\( (${t}x)^2 \\) = \\( ${t*t}x^2 \\)</td>
          <td ${tdTop}>\\(B = ${c}\\) <u>car</u> : \\( ${c}^2 \\) = \\( ${c*c} \\)</td>
        </tr>
      </table>`;

    const tbl_pdf=`<div style="max-width:560px;margin:.2rem 0;font-size:95%">
      <table class="tbl" style="width:100%;table-layout:fixed;border-collapse:collapse;border:2px solid #000">
        <tr>
          <td ${tdTop}>\\(A = ${t}x\\)  <u>car</u> : \\( (${t}x)^2 \\) = \\( ${t*t}x^2 \\)</td>
          <td ${tdTop}>\\(B = ${c}\\)  <u>car</u> : \\( ${c}^2 \\) = \\( ${c*c} \\)</td>
        </tr>
      </table></div>`;

    const txt=`${t*t}x^2 âˆ’ ${c*c}`;
    const ref=`${t*t}*x**2 - ${c*c}`;

  const l0 = 'Rappel : \\( A^2 - B^2 = (A + B)(A - B) \\)';
const l1 = `On cherche \\(A \\) tel que \\(A^2 = ${t*t}x^2\\), \\(B \\) tel que \\(B^2 = ${c*c}\\).`;

const lines = [
  l0,
  l1,
  tbl_screen,
  `F = ${t*t}x^2 âˆ’ ${c*c}`,
  `F = ( ${t}x + ${c} )( ${t}x âˆ’ ${c} )`
];

    return {txt,ref,lines:dedup(lines),tbl_pdf};
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : (txÂ±c)(txâˆ“c) ou forme Ã©quivalente."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines); 
  mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){
    const src = Array.isArray(st?.lines) ? st.lines : (st?.lines ? [st.lines] : []);
    const pick=i=>(i>=0 && i<src.length)?src[i]:null;
    const parts=[ pick(0), pick(1), st?.tbl_pdf, pick(3), pick(4) ]
      .filter(v=>v!=null && v!=='').map(String);
    return renderStepsLatex(parts);
  }
};

/* 4. DiffÃ©rence de deux carrÃ©s (aprÃ¨s factorisation) â€“ xÂ² âˆ’ rÂ² */
const ex4={ id:"diff-carres-apres-facto", title:"DiffÃ©rence de deux carrÃ©s (aprÃ¨s factorisation)",
  gen(){
    const k=choice([2,3,4,5,6,8,9]), r=choice([2,3,4,5,6,7,8,9]);
    const txt=`${k}xÂ² âˆ’ ${k*r*r}`;
    const ref=`${k}*x**2 - ${k*r*r}`;
    const lines=[
      `F = ${txt}`,
      `F = ${fc(String(k))}( x^2 âˆ’ ${r*r} )`,
      `F = ${fc(String(k))}( x + ${r} )( x âˆ’ ${r} )`,
      `Rappel : A^2 âˆ’ B^2 = (A + B)(A âˆ’ B)`
    ];
    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraire k puis utiliser A^2âˆ’B^2."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines); 
  mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){ return renderStepsLatex(st?.lines||[]); }
};

/* 5. TrinÃ´me â€“ phrase Â« Il faudra rÃ©soudre un systÃ¨me. Â» */
const ex5={ id:"trinome-hors", title:"x^2 + bx + c (hors programme)",
  gen(){
    let r=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
    let s=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]); while(s===r) s=choice([-9,-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8,9]);
    const S=r+s, P=r*s;
    const B=-(S), C=P;
    const txt=`x^2 ${B>=0?'+':'âˆ’'} ${Math.abs(B)}x + ${C}`;
    const ref=`x**2 ${B>=0?'+':'-'} ${Math.abs(B)}*x + ${C}`;
    
	const l0 = `On cherche \\(r\\) et \\(s\\) tels que \\(r+s = ${S}\\) et \\(rs = ${P}\\).`;
const l1 = '<span>Il faudra rÃ©soudre un systÃ¨me.</span>';

const lines = [
  l0,
  l1,
  `F = ${txt}`,
  `F = ( x ${(-r>=0?'+':'âˆ’')} ${Math.abs(r)} )( x ${(-s>=0?'+':'âˆ’')} ${Math.abs(s)} )`
];

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : (xâˆ’r)(xâˆ’s) (non trivial)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines); 
  mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){ return renderStepsLatex(st?.lines||[]); }
};

/* 6. Regrouper (somme de produits) */
const ex6={ id:"regroup-somme", title:"Regrouper (somme de produits)",
  gen(){
    const a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), b=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]),
          c=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), d=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]),
          e=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), f=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const axb=binom(a,b), cxd=binom(c,d), exf=binom(e,f);
    const A=c+e, B=d+f;
    const txt=`${axb} ${cxd} + ${exf} ${axb}`.replace(/\)\s+\(/g,') (');
    const ref=`(${a}*x+(${b}))*( ${c}*x+(${d}) ) + (${e}*x+(${f}))*( ${a}*x+(${b}) )`;

    const lines=[
      `F = ${fc(axb)} ${cxd} + ${exf} ${fc(axb)}`,
      `F = ${fc(axb)} [ ${cxd} + ${exf} ]`,
      `F = ${fc(axb)} [ ${fmtAx(c)} ${d>=0?'+':'âˆ’'} ${Math.abs(d)} ${e>=0?'+':'âˆ’'} ${Math.abs(e)}x ${f>=0?'+':'âˆ’'} ${Math.abs(f)} ]`,
      `F = ${fc(axb)} ( ${fmtAx(A)} ${ B>=0?'+':'âˆ’'} ${Math.abs(B)} )`
    ];
    if (A===0){ lines.push(`F = ${uminus(B)}${fc(axb)}`); }
    else if (B===0){ lines.push(`F = ${fmtAx(A)}${fc(axb)}`); }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraction du facteur commun puis simplification."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines); 
  mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){ return renderStepsLatex(st?.lines||[]); }
};

/* 7. Regrouper (diffÃ©rence de produits) */
const ex7 = { id: "regroup-diff", title: "Regrouper (diffÃ©rence de produits)",
  gen(){
    const a=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const b=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const c=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const d=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);
    const e=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const f=choice([-9,-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,9]);

    const axb = binom(a,b), cxd = binom(c,d), exf = binom(e,f);

    // Ã‰noncÃ© (on garde lâ€™espacement entre ) ( )
    const txt = `${axb} ${cxd} âˆ’ ${exf} ${axb}`.replace(/\)\s+\(/g,') (');

    // RÃ©fÃ©rence numÃ©rique pour lâ€™Ã©valuation
    const ref = `(${a}*x+(${b}))*(${c}*x+(${d})) - (${e}*x+(${f}))*(${a}*x+(${b}))`;

    // Coeffs aprÃ¨s regroupement : (cx+d) - (ex+f) = (c-e)x + (d-f)
    const A = c - e, B = d - f;
    const last = A===0 ? `${B}` : `${fmtAx(A)} ${B>=0?'+':'âˆ’'} ${Math.abs(B)}`;

    const lines = [
      `F = ${fc(axb)} ${cxd} âˆ’ ${exf} ${fc(axb)}`,
      `F = ${fc(axb)} [ ${cxd} âˆ’ ${exf} ]`,
      `F = ${fc(axb)} ( ${fmtAx(c)} ${d>=0?'+':'âˆ’'} ${Math.abs(d)} ${(-e)>=0?'+':'âˆ’'} ${Math.abs(e)}x ${(-f)>=0?'+':'âˆ’'} ${Math.abs(f)} )`,
      `F = ${fc(axb)} ( ${last} )`
    ];

    if (A===0) { lines.push(`F = ${B}${fc(axb)}`); }
    else if (B===0) {
      lines.push(`F = ( ${fc(axb)} )( ${fmtAx(A)} )`);
      lines.push(`F = ${fmtAx(A)}${fc(axb)}`);
    }

    return { txt, ref, lines: dedup(lines) };
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraction de (x+u) puis regroupement (avec signe Â« âˆ’ Â»)."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines); 
  mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){ return renderStepsLatex(st?.lines||[]); }
};

/* 8. MÃ©lange â€” 1re ligne du corrigÃ© : facteur commun en ROUGE (si xÂ², seul le x est colorÃ©) */
const ex8={ id:"melange", title:"Sommes / diffÃ©rences factorisables",
  gen(){
    const pat=choice([1,2,3]);
    let txt, ref, lines;

    if(pat===1){
      const k=choice([2,3,4,5]), u=choice([2,3,4,5,6,7]), b=choice([2,3,4]), c=choice([2,3,4,5,6]);
      txt=`${k}x( x âˆ’ ${u} ) âˆ’ ${2*k}x^2( x âˆ’ ${u} )( ${b}x âˆ’ ${c} )`;
      ref=`${k}*x*(x-(${u})) - ${2*k}*x**2*(x-(${u}))*(${b}*x-(${c}))`;
      const first=`F = ${fc(`${k}x( x âˆ’ ${u} )`)} âˆ’ ${2*k}x^2( x âˆ’ ${u} )( ${b}x âˆ’ ${c} )`;
      lines=[ first,
              `F = ${fc(`${k}x( x âˆ’ ${u} )`)} [ 1 âˆ’ 2x( ${b}x âˆ’ ${c} ) ]`,
              `F = ${fc(`${k}x( x âˆ’ ${u} )`)} ( 1 âˆ’ ${2*b}x^2 + ${2*c}x )`];

    }else if(pat===2){
      const a=choice([-4,-3,-2,-1,1,2,3,4]), b=choice([-8,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,8]);
      const m=choice([-5,-4,-3,-2,-1,1,2,3,4,5]), n=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
      const AB=`( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`;
      txt=`${AB} ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ${AB} ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} )`;
      ref=`(${a}*x+(${b}))*(x+(${m})) - (${a}*x+(${b}))*(x+(${n}))`;
      const first=`F = ${fc(AB)} ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ${fc(AB)} ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} )`;
      lines=[ first,
              `F = ${fc(AB)} [ ( x ${m>=0?'+':'âˆ’'} ${Math.abs(m)} ) âˆ’ ( x ${n>=0?'+':'âˆ’'} ${Math.abs(n)} ) ]`,
              `F = ${fc(AB)} ( ${m-n} )`];

    }else{ // pat===3
      const a=choice([1,2,3]), b=choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);
      const u=choice([-4,-3,-2,-1,1,2,3,4]), v=choice([-4,-3,-2,-1,1,2,3,4]);
      txt=`x^2( ${a}x ${b>=0?'+':'âˆ’'} ${Math.abs(b)} ) + x( x ${u>=0?'+':'âˆ’'} ${Math.abs(u)} )( x ${v>=0?'+':'âˆ’'} ${Math.abs(v)} )`;
      ref=`x**2*(${a}*x+(${b})) + x*(x+(${u}))*(x+(${v}))`;
      const txtFC = txt
        .replace('x^2', `${fc('x')}^2`)
        .replace(/([+\-])\s*x\(/, (_,s)=> `${s} ${fc('x')}(`);
      const first=`F = ${txtFC}`;
      const expandUV=`x^2 ${(u+v)>=0?'+':'âˆ’'} ${Math.abs(u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;
      const combined=`${a+1}x^2 ${(b+u+v)>=0?'+':'âˆ’'} ${Math.abs(b+u+v)}x ${(u*v)>=0?'+':'âˆ’'} ${Math.abs(u*v)}`;
      lines=[ first, `F = ${fc('x')} [ ${a}x^2 ${b>=0?'+':'âˆ’'} ${Math.abs(b)}x + ${expandUV} ]`, `F = ${fc('x')} ( ${combined} )`];
    }

    return {txt,ref,lines:dedup(lines)};
  },
  render(h,st){ renderFrame(h,st.txt,""); },
  correct(h,st){ const v=($("#reponse",h).value||"").trim(); const ok=acceptAnyFactorization(v,st.ref);
    $("#res",h).textContent= ok?"âœ”":"âœ˜ Attendu : extraction dâ€™un facteur pertinent puis simplification."; $("#res",h).className= ok?"res-ok":"res-ko"; return {ok,total:1}; },
  solution(h,st){ $("#sol",h).innerHTML=renderStepsLatex(st.lines);
mjxTypeset($("#sol",h));   // âŸµ  AJOUT
  },
  printSolutionPDF(st){ return renderStepsLatex(st?.lines||[]); }
};

const REGISTRY=[ex1,ex2,ex3,ex4,ex6,ex7,ex8];
window.REGISTRY=REGISTRY;

/* Correcteurs Â« ultime Â» + rejets spÃ©cifiques */
function makeCorrector(opts){
  return function(h, st){
    const v = ($("#reponse",h).value||"").trim();

    if (opts && typeof opts.rejectOriginalRewrite === 'function' && opts.rejectOriginalRewrite(v, st)){
      $("#res",h).textContent = "âœ˜ Ce nâ€™est pas une factorisation : tu as rÃ©Ã©crit lâ€™Ã©noncÃ©. Extrais dâ€™abord le facteur commun.";
      $("#res",h).className = "res-ko";
      return {ok:false,total:1};
    }

    const okCore = acceptAnyFactorization(v, st.ref);
    if(!okCore){
      $("#res",h).textContent = "âœ˜ RÃ©ponse attendue : une forme factorisÃ©e Ã©quivalente (pas la forme dÃ©veloppÃ©e, ni 1(â€¦)).";
      $("#res",h).className = "res-ko";
      return {ok:false,total:1};
    }

    const ultime = (opts && typeof opts.customUltimate==='function')
      ? opts.customUltimate(v, st)
      : isUltimateGeneric(v, opts||{});

    $("#res",h).innerHTML = ultime ? "âœ”" : "âœ” (mais tu peux encore factoriser)";
    $("#res",h).className = "res-ok";
    return {ok:true,total:1};
  };
}

(function installUltimateCheck(){
  const OPTS = {
    "facteur-commun": { requireOuterX:true },
    "carre-parfait": {},
    "diff-carres": {},
    "diff-carres-apres-facto": { customUltimate: (typeof isUltimateEx4==='function'? isUltimateEx4 : undefined) },

    // âŸµ ICI : pas d'exigence "ultime"
    "regroup-somme": { rejectOriginalRewrite: isRewriteOriginalEx6, customUltimate: ()=>true },
    "regroup-diff":  { rejectOriginalRewrite: isRewriteOriginalEx7, customUltimate: ()=>true },
    "melange":       { customUltimate: ()=>true },

    "trinome-hors": {}
  };
  (window.REGISTRY||REGISTRY).forEach(ex=>{
    const opts = OPTS[ex.id] || {};
    ex.correct = makeCorrector(opts);
  });
})();


/* ==== Orchestration ==== */
let scoreOK=0,scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){ const sel=$("#exo-select"),host=$("#host"); const def=REGISTRY.find(e=>e.id===sel.value); if(!def)return;
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st); const inp=$("#reponse",host); if(inp) inp.focus(); }
function check(){ const h=$("#host"); const d=REGISTRY.find(e=>e.id===h.dataset.active); if(!d)return; const st=JSON.parse(h.dataset.state||"{}"); const r=d.correct(h,st); if(r){scoreOK+=(r.ok?1:0);scoreTot+=(r.total||1);updateScore();}}
function solution(){ const h=$("#host"); const d=REGISTRY.find(e=>e.id===h.dataset.active); if(!d)return; const st=JSON.parse(h.dataset.state||"{}"); if(typeof d.solution==='function') d.solution(h,st); const sol=$("#sol",h); sol && sol.scrollIntoView({behavior:'smooth',block:'center'}); }
function resetAll(){ scoreOK=0;scoreTot=0;updateScore(); const h=$("#host"); $("#reponse",h)&&($("#reponse",h).value=""); $("#res",h).textContent=""; $("#sol",h).innerHTML=""; }

document.addEventListener('DOMContentLoaded',function(){
  const sel=$("#exo-select"); REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change',buildOne);

  // carrÃ©s utiles
  const sbox=$("#squares-host"); const items=[]; for(let n=0;n<=20;n++){items.push(`<div class="sqbox">\\( ${n}^2 = ${n*n} \\)</div>`);} sbox.innerHTML=items.join("");
mjxTypeset(sbox);   // âŸµ  AJOUT

  $("#btn-new").addEventListener('click',buildOne);
  $("#btn-check").addEventListener('click',check);
  $("#btn-solution").addEventListener('click',solution);
  $("#btn-reset").addEventListener('click',resetAll);

  sel.value=REGISTRY[0].id; buildOne(); updateScore();
});
})();
</script>

<!-- GÃ©nÃ©rateur de fiches PDF -->
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded',function(){
  if(window.ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation (F = â€¦)',
      max:50,
      mountAfterSelector:'#accept',
      lead:'Factoriser :',
      beforeRender:function(def,st,withSolutions){
        if(!withSolutions){
          const txt=(st&&st.txt?String(st.txt):'').replace(/<[^>]+>/g,'');
          return {statement:`\\( F = ${toTex(txt)} \\)`};
        }
        if(typeof def.printSolutionPDF==='function'){ return {solution:def.printSolutionPDF(st)}; }
        try{
          const tmp=document.createElement('div'); def.render(tmp,st);
          if(typeof def.solution==='function') def.solution(tmp,st);
          const sol=tmp.querySelector('.steps')||tmp.querySelector('#sol')||tmp;
          return {solution: sol.outerHTML||sol.innerHTML||''};
        }catch(e){
          return {solution:'<div class="steps"><div class="line">CorrigÃ© indisponible.</div></div>'};
        }
      }
    });
  }
});
</script>

<!-- Clavier -->
<script src="../../../../js/math-kbd.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre dâ€™actions mobile
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','VÃ©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si prÃ©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points Ã  dÃ©placer (si jamais il y en avait)
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
