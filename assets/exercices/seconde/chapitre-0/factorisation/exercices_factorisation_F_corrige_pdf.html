<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation (F = â€¦) â€” corrigÃ©s version PDF</title>
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.row{display:grid;grid-template-columns:1fr auto minmax(560px,1fr);gap:8px;align-items:center}
.row .consigne{grid-column:1/-1;color:#5f6368;font-size:.95rem;margin:-2px 0 4px 0}
.row > div:last-child{overflow-x:auto}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.equ{font-weight:700}

/* Ã‰tapes alignÃ©es (jamais coupÃ©es) */
.steps{margin:.5rem 0 0 .15rem;padding:.6rem .7rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:10px;overflow-x:auto}
.eqline{display:grid;grid-template-columns:auto 2ch 1fr;gap:.4rem;align-items:baseline;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;white-space:nowrap}
.eqline .eq{text-align:center}
.eqline.none{grid-template-columns:1fr}
.eqline.colon{grid-template-columns:auto 2ch 1fr}
.eqline.colon .eq::after{content:":"}
.note{margin:.2rem 0 .4rem 0; color:#444}

/* Facteur commun (rouge) â€“ comme lâ€™ancienne version */
.fc{color:#d32f2f;font-weight:700}

/* Surlignage des 2 premiÃ¨res lignes (Ã©noncÃ© / extraction) */
.s-eno{color:#1a73e8;font-weight:700}
.s-dist{color:#8e24aa;font-weight:700}

/* Tableau des carrÃ©s (exercice 3) */
.sqwrap{margin-top:.5rem}
.sqwrap .note{margin-bottom:.2rem}
.sqtab{border-collapse:collapse;width:auto}
.sqtab th,.sqtab td{border:1px solid #e0e0e0;padding:4px 8px;text-align:center;font-variant-numeric:tabular-nums}

/* Clavier */
.kbd-host{display:flex;justify-content:center}
.small{font-size:.92rem;color:#555}

/* Input "F = __" */
.ans-row{display:flex;align-items:center;gap:6px}
.ans-row .F{font-weight:700}
</style>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde â€“ Chapitre 0 â€“ Calculs â€“ <strong>Factorisation</strong> <small style="opacity:.7">(format Â« F = â€¦ Â», corrigÃ©s calquÃ©s sur le PDF)</small></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <!-- Clavier math -->
    <div class="card kbd-host"><div data-math-kbd></div></div>

    <!-- Saisie & rÃ©ponses acceptÃ©es -->
    <div class="card">
      <strong>Saisie & rÃ©ponses acceptÃ©es :</strong>
      <ul style="margin:.6rem 0 .2rem 1.25rem">
        <li>RÃ©pondre avec une <em>forme factorisÃ©e</em> (produit, parenthÃ¨ses, puissance).</li>
        <li><strong>Toute factorisation non triviale</strong> (facteur diffÃ©rent de 1, y compris un facteur numÃ©rique global ou un seul facteur commun mis en Ã©vidence) est <strong>acceptÃ©e</strong> si elle est algÃ©briquement Ã©quivalente Ã  F.</li>
        <li>La <strong>correction affichÃ©e</strong> proposera la <em>forme la plus factorisÃ©e possible</em>.</li>
        <li>Ã‰criture : <code>x</code> pour <code>1x</code>, <code>âˆ’x</code> pour <code>âˆ’1x</code> (signe Â« âˆ’ Â» Unicode). Puissances en <code>x^n</code> ou <code>xÂ²</code>. Les multiplications implicites sont comprises.</li>
      </ul>
    </div>
  </div>

<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ===== affichage & signes ===== */
function uminus(n){ return n<0 ? 'âˆ’'+String(Math.abs(n)) : String(n); }
function normalizeSigns(s){
  return s
    .replace(/\u2212/g,'âˆ’')
    .replace(/\+\s*[âˆ’-]/g,' âˆ’ ')
    .replace(/[âˆ’-]\s*\+/g,' âˆ’ ')
    .replace(/[âˆ’-]\s*[âˆ’-]/g,' + ')
    .replace(/\+\s*\+/g,' + ')
    .replace(/\s{2,}/g,' ')
    .trim();
}
function canonPow2(s){ return s.replace(/([x0-9)])Â²/g, '$1<sup>2</sup>').replace(/\(<sup>2<\/sup>/g,'('); }
function fmtAx(a){ if(a===1) return 'x'; if(a===-1) return 'âˆ’x'; return `${uminus(a)}x`; }
function binom(a,b){ return `( ${fmtAx(a)} ${b>=0?'+':'âˆ’'} ${Math.abs(b)} )`; }
function fc(s){ return `<span class="fc">${s}</span>`; }
const MULT = 'Ã—';

/* === Tableau des carrÃ©s 1..20 (affichÃ© sous lâ€™Ã©noncÃ© de lâ€™exo 3) === */
function squaresTableHTML(){
  const ns = Array.from({length:20}, (_,i)=>i+1);
  const rowN  = ns.map(n=>`<td>${n}</td>`).join('');
  const rowN2 = ns.map(n=>`<td>${n*n}</td>`).join('');
  return `
  <div class="sqwrap">
    <div class="note">CarrÃ©s utiles (1 Ã  20)</div>
    <table class="sqtab">
      <tr><th>n</th>${rowN}</tr>
      <tr><th>nÂ²</th>${rowN2}</tr>
    </table>
  </div>`;
}

/* ===== Ã‰tapes alignÃ©es ===== */
function stepsAlignedHTML(rows, notes = []) {
  const notesHTML = notes.map(t => `<div class="note">${t}</div>`).join("");
  const norm = (r) => {
    if (Array.isArray(r)) {
      const lhs = canonPow2(normalizeSigns((r[0] || ""))).trim();
      const rhs = canonPow2(normalizeSigns((r[1] || ""))).trim();
      return { lhs, rhs, connector: 'eq' };
    } else {
      const lhs = canonPow2(normalizeSigns((r.lhs || ""))).trim();
      const rhs = canonPow2(normalizeSigns((r.rhs || ""))).trim();
      const connector = r.connector || 'eq';
      return { lhs, rhs, connector, cls:r.cls||'' };
    }
  };
  const out = []; let prevKey = "";
  for (const row of rows) {
    const o = norm(row);
    const key = `${o.connector}|${o.lhs}|${o.rhs}|${o.cls}`;
    if (key === prevKey) continue;
    prevKey = key;
    const clsAttr = o.cls ? ` ${o.cls}` : '';
    if (o.connector === 'none') out.push(`<div class="eqline none${clsAttr}"><div class="lhs">${o.lhs}</div></div>`);
    else if (o.connector === 'colon') out.push(`<div class="eqline colon${clsAttr}"><div class="lhs">${o.lhs}</div><div class="eq"></div><div class="rhs">${o.rhs}</div></div>`);
    else out.push(`<div class="eqline${clsAttr}"><div class="lhs">${o.lhs}</div><div class="eq">=</div><div class="rhs">${o.rhs}</div></div>`);
  }
  return `<div class="steps">${notesHTML}${out.join("")}</div>`;
}

/* ===== Ã‰valuation & tolÃ©rance Â« toute factorisation Â» ===== */
const SAFE_RE = /^[0-9xX+\-*/().\s^Â·Ã—Â²]+$/;

// insÃ¨re des multiplications implicites
function insertImplicitMultiplication(s){
  return s
    .replace(/(\d)(x)/gi, '$1*$2')
    .replace(/(\d)\(/g, '$1*(')
    .replace(/x(\d)/gi, 'x*$1')
    .replace(/x\(/gi, 'x*(')
    .replace(/\)(\d)/g, ')*$1')
    .replace(/\)(x)/gi, ')*$1')
    .replace(/\)\(/g, ')*(');
}

function evalExprAt(expr, x){
  let s = (expr||"").trim();
  if(!SAFE_RE.test(s)) throw new Error("caractÃ¨res non autorisÃ©s");
  s = s.replace(/\u2212/g,'-').replace(/Ã—|Â·/g,'*'); // âˆ’, Ã—, Â·
  s = s.replace(/([0-9xX)\]])\s*Â²/g, '$1**2');      // ^2 en Unicode
  s = s.replace(/\^/g,'**');                        // caret
  s = insertImplicitMultiplication(s);              // implicites
  if(/(?:new|Function|=>|while|for|class|import|require|this)/.test(s)) throw new Error("expression invalide");
  s = s.replace(/X/g,'x');
  const f = new Function('x', `return (${s});`);
  const val = f(x);
  if(!Number.isFinite(val)) throw new Error("NaN");
  return val;
}

function algebraicEqual(user, refExpr){
  try{
    const pts = [-3,-2,-1,0,1,2,3,4];
    for(const t of pts){
      const u = evalExprAt(user, t);
      const v = evalExprAt(refExpr, t);
      if(Math.abs(u - v) > 1e-9) return false;
    }
    return true;
  }catch(e){ return false; }
}

// DÃ©tecte si la rÃ©ponse **montre** une factorisation non triviale (autre que 1)
function looksFactorized(sRaw){
  const s = (sRaw||'').replace(/\s+/g,'');
  // Produit de parenthÃ¨ses / binÃ´mes / puissance
  if(/\([^()]*[+\-][^()]*\)/.test(s)) return true; // (a+b)
  if(/\)\(/.test(s)) return true;                  // )( -> produit de binÃ´mes
  if(/\^2|\u00B2/.test(s)) return true;            // carrÃ© d'un binÃ´me
  if(/\*\(/.test(s) || /\)\*/.test(s)) return true; // produit explicite avec parenthÃ¨ses
  // Facteur numÃ©rique global â‰  1 devant une parenthÃ¨se
  if(/^[+-]?\d+\(.*\)$/.test(s) && !/^[+-]?1\(/.test(s)) return true;
  return false;
}

function acceptAnyFactorization(userExpr, expandedRef){
  const eq = algebraicEqual(userExpr, expandedRef);
  if(!eq) return false;
  return looksFactorized(userExpr);
}

/* ===== rendu commun (F = â€¦) ===== */
function renderOne(host, htmlEq, placeholder="ex.  (2x+3)(5xâˆ’1)", label='RÃ©ponse (forme factorisÃ©e)'){
  host.innerHTML="";
  const row0=document.createElement("div"); row0.className="row";
  const cons=document.createElement("div"); cons.className="consigne small"; cons.innerHTML="Factoriser :";
  const lab0=document.createElement("div"); lab0.className="equ"; lab0.innerHTML=htmlEq;
  const spacer=document.createElement("div"); spacer.textContent="";
  const res0=document.createElement("div"); res0.id="res";
  row0.appendChild(cons);
  row0.appendChild(lab0); row0.appendChild(spacer); row0.appendChild(res0);
  host.appendChild(row0);

  const row1=document.createElement("div"); row1.className="row";
  const lab1=document.createElement("div"); lab1.textContent=label;
  const ans=document.createElement("div"); ans.className="ans-row";
  ans.innerHTML = '<span class="F">F =</span> <input type="text" id="reponse" placeholder="'+placeholder+'">';
  const res1=document.createElement("div"); res1.textContent="";
  row1.appendChild(lab1); row1.appendChild(ans); row1.appendChild(res1);
  host.appendChild(row1);

  const ip = row1.querySelector('#reponse');
  ip && ip.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); check(); }});
}

/* ================== EXERCICES (libellÃ©s inchangÃ©s) ================== */

/* 1 â€” Facteur commun (PDF) */
const ex1 = {
  id:"facteur-commun",
  title:"Mise en Ã©vidence dâ€™un facteur commun",
  gen(){
    const g = choice([2,3,4,5,6,7,8,9,10]);
    const A = choice([1,2,3,4,5,6,7,8,9,10]);
    const B = choice([1,2,3,4,5,6,7,8,9,10]);
    const a = g*A, b = g*B;
    const txt = `${a===1?'':uminus(a)}x<sup>2</sup> ${b>=0?'+':'âˆ’'} ${Math.abs(b)}x`;
    const refExpr = `${a}*x**2 ${b>=0?'+':'-'} ${Math.abs(b)}*x`;
    const most = `${g}x( ${A}x ${B>=0?'+':'âˆ’'} ${Math.abs(B)} )`;
    return {g,A,B,a,b,txt,refExpr,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  10x(2x+4)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : une factorisation non triviale, algÃ©briquement Ã©quivalente Ã  F.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const L = [
      {lhs:`<span class="s-eno">F = ${st.txt}</span>`, rhs:`<span class="s-dist">${fc(`${st.g}x`)} ( ${st.A}x ${st.B>=0?'+':'âˆ’'} ${Math.abs(st.B)} )</span>`},
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(L);
    $("#reponse",host).value = st.most.replace(/\s+/g,'');
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 2 â€” CarrÃ© parfait (PDF) */
const ex2 = {
  id:"carre-parfait",
  title:"Factoriser : carrÃ© parfait",
  gen(){
    const p = choice([2,3,4,5]); // exclut p=0 et p=1 Ã  la demande (Ã©vite cas dÃ©gÃ©nÃ©rÃ©)
    const q = choice([1,2,3,4,5,6,7,8,9]);
    const signPlus = Math.random() < 0.7; // la plupart des exemples PDF sont en +
    const a2 = p*p, mid = 2*p*q*(signPlus?1:-1), b2 = q*q;
    const txt = `${a2===1?'':uminus(a2)}x<sup>2</sup> ${mid>=0?'+':'âˆ’'} ${Math.abs(mid)}x ${b2>=0?'+':'âˆ’'} ${Math.abs(b2)}`;
    const refExpr = `${a2}*x**2 ${mid>=0?'+':'-'} ${Math.abs(mid)}*x ${b2>=0?'+':'-'} ${Math.abs(b2)}`;
    const fact = signPlus?`( ${p}x + ${q} )<sup>2</sup>`:`( ${p}x âˆ’ ${q} )<sup>2</sup>`;
    const most = (signPlus?`(${p}x+${q})^2`:`(${p}x-${q})^2`);
    return {p,q,mid,txt,refExpr,fact,most,signPlus};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (5x+7)^2"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ RÃ©ponse attendue : forme factorisÃ©e Ã©quivalente (non triviale).";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
`Rappel : AÂ² + 2AB + BÂ² = (A + B)Â²`,
`On cherche A tel que AÂ² = ${st.p*st.p}xÂ², B tel que BÂ² = ${st.q*st.q} puis on vÃ©rifie si 2AB = ${Math.abs(st.mid)}x`,
`On trouve :`,
`A = ${st.p}x car : (${st.p}x)Â² = ${st.p*st.p}xÂ²  B = ${st.q} car : ${st.q}Â² = ${st.q*st.q}  2AB = 2 ${MULT} ${st.p}x ${MULT} ${st.q} = ${Math.abs(st.mid)}x            câ€™est donc bon`,
`F = ${st.txt.replace(/<[^>]+>/g,'')}`,
`F = ${st.fact}`
    ];
    const rows = lines.map((t,i)=>({lhs: i<4?'<span class="s-eno"></span>':'', rhs: t, connector: (i<4?'none':'eq')}));
    $("#res",host).innerHTML = stepsAlignedHTML(rows);
    $("#reponse",host).value = st.most;
  },
  reset: ex1.reset
};

/* 3 â€” DiffÃ©rence de deux carrÃ©s (PDF) */
const ex3 = {
  id:"diff-carres",
  title:"DiffÃ©rence de deux carrÃ©s",
  gen(){
    const t = choice([2,3,4,5,6,7,8,9,10,11,12,13]);
    const c = choice([2,3,4,5,6,7,8,9]);
    const txt = `${t*t===1?'':uminus(t*t)}x<sup>2</sup> âˆ’ ${c*c}`;
    const refExpr = `${t*t}*x**2 - ${c*c}`;
    const most = `(${t}x+${c})(${t}x-${c})`;
    return {t,c,txt,refExpr,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){
    host.innerHTML="";
    const row0=document.createElement("div"); row0.className="row";
    const cons=document.createElement("div"); cons.className="consigne small"; cons.innerHTML="Factoriser (diffÃ©rence de deux carrÃ©s) :";
    const lab0=document.createElement("div"); lab0.className="equ"; lab0.innerHTML=this.text(st);
    const spacer=document.createElement("div"); spacer.textContent="";
    const res0=document.createElement("div"); res0.id="res";
    row0.appendChild(cons); row0.appendChild(lab0); row0.appendChild(spacer); row0.appendChild(res0);
    host.appendChild(row0);
    const sq=document.createElement("div"); sq.innerHTML=squaresTableHTML(); host.appendChild(sq);
    const row1=document.createElement("div"); row1.className="row";
    const lab1=document.createElement("div"); lab1.textContent='RÃ©ponse (forme factorisÃ©e)';
    const ans=document.createElement("div"); ans.className="ans-row";
    ans.innerHTML = '<span class="F">F =</span> <input type="text" id="reponse" placeholder="ex.  (txâˆ’c)(tx+c)">';
    const res1=document.createElement("div"); res1.textContent="";
    row1.appendChild(lab1); row1.appendChild(ans); row1.appendChild(res1);
    host.appendChild(row1);
    const ip = row1.querySelector('#reponse'); ip && ip.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); check(); }});
  },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : une factorisation de type (txÂ±c)(txâˆ“c).";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
`Rappel : AÂ² âˆ’ BÂ² = (A + B)(A âˆ’ B)`,
`On cherche A tel que AÂ² = ${st.t*st.t} xÂ², B tel que BÂ² = ${st.c*st.c}`,
`On trouve :`,
`A = ${st.t}x car : (${st.t}x)Â² = ${st.t*st.t} xÂ²  B = ${st.c} car : ${st.c}Â² = ${st.c*st.c}`,
`F = ${st.txt.replace(/<[^>]+>/g,'')}`,
`F = ( ${st.t}x + ${st.c} )( ${st.t}x âˆ’ ${st.c} )`
    ];
    const rows = lines.map((t,i)=>({lhs: i<4?'<span class="s-eno"></span>':'', rhs: t, connector: (i<4?'none':'eq')}));
    $("#res",host).innerHTML = stepsAlignedHTML(rows);
    $("#reponse",host).value = st.most;
  },
  reset: ex1.reset
};

/* 4 â€” kxÂ² âˆ’ k rÂ² (PDF) */
const ex4 = {
  id:"kx2-kr2",
  title:"kxÂ² âˆ’ k rÂ²",
  gen(){
    const k = choice([2,3,4,5,6]); const r = choice([2,3,4,5,6,7,8,9]);
    const txt = `${k===1?'':uminus(k)}x<sup>2</sup> âˆ’ ${k*r*r}`.replace(/^âˆ’/,''); // we want kxÂ² âˆ’ k rÂ²
    const refExpr = `${k}*x**2 - ${k*r*r}`;
    const mid = `${k}(x<sup>2</sup> âˆ’ ${r}<sup>2</sup>)`;
    const lastMost = `${k}( x + ${r} )( x âˆ’ ${r} )`; // forme la plus factorisÃ©e
    const most = `${k}(x+${r})(x-${r})`;
    return {k,r,txt,refExpr,mid,lastMost,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  k(x+r)(xâˆ’r)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : extraire k puis utiliser AÂ²âˆ’BÂ².";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const rows = [
      {lhs:`<span class="s-eno">F = ${st.txt}</span>`, rhs:`${st.mid}` , connector:'eq'},
      {lhs:``, rhs:`${st.lastMost}`, connector:'eq'} // on affiche ici la forme **la plus factorisÃ©e**
    ];
    $("#res",host).innerHTML = stepsAlignedHTML(rows,[`Rappel : AÂ² âˆ’ BÂ² = (A + B)(A âˆ’ B)`]);
    $("#reponse",host).value = st.most;
  },
  reset: ex1.reset
};

/* 5 â€” xÂ² âˆ’ (r+s)x + rs (PDF) */
const ex5 = {
  id:"trinome-rs",
  title:"xÂ² âˆ’ (r+s)x + rs",
  gen(){
    let r = choice([1,2,3,4,5,6,7,8,9]);
    let s = choice([1,2,3,4,5,6,7,8,9]);
    while(s===r) s = choice([1,2,3,4,5,6,7,8,9]);
    const B = -(r+s), C = r*s;
    const txt = `x<sup>2</sup> ${B>=0?'+':'âˆ’'} ${Math.abs(r+s)}x ${C>=0?'+':'âˆ’'} ${Math.abs(C)}`.replace('+ 0x','+ 0x');
    const refExpr = `x**2 ${B>=0?'+':'-'} ${Math.abs(r+s)}*x ${C>=0?'+':'-'} ${Math.abs(C)}`;
    const most = `( x âˆ’ ${r} )( x âˆ’ ${s} )`.replace('--','+');
    return {r,s,B,C,txt,refExpr,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (xâˆ’r)(xâˆ’s)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : (xâˆ’r)(xâˆ’s) avec r+s et rs corrects (toute factorisation non triviale acceptÃ©e).";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
`On cherche r, s tels que r + s = ${st.r+st.s} et rs = ${st.r*st.s}`,
`Il faut faire un petit systÃ¨me Ã  faire et on obtient :`,
`F = ${st.txt.replace(/<[^>]+>/g,'')}`,
`F = ( x âˆ’ ${st.r} )( x âˆ’ ${st.s} )`
    ];
    const rows = lines.map((t,i)=>({lhs:'', rhs: t, connector:'eq'}));
    $("#res",host).innerHTML = stepsAlignedHTML(rows);
    $("#reponse",host).value = st.most.replace(/\s+/g,'');
  },
  reset: ex1.reset
};

/* 6 â€” Regroupement : somme (PDF style) */
const ex6 = {
  id:"regroupement-somme-produits",
  title:"Regrouper : somme de deux produits avec un facteur commun (ax+b)",
  gen(){
    const u = choice([-8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8]);
    const p = choice([-4,-3,-2,-1,1,2,3,4]);
    const q = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const r = choice([-4,-3,-2,-1,1,2,3,4]);
    const s = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    const left = `( x ${u>=0?'+':'âˆ’'} ${Math.abs(u)} ) ( ${fmtAx(p)} ${q>=0?'+':'âˆ’'} ${Math.abs(q)} )`;
    const right= `( ${fmtAx(r)} ${s>=0?'+':'âˆ’'} ${Math.abs(s)} ) ( x ${u>=0?'+':'âˆ’'} ${Math.abs(u)} )`;
    const txt = `${left} + ${right}`;
    const inside = `${fmtAx(p+r)} ${ (q+s)>=0?'+':'âˆ’'} ${Math.abs(q+s)}`;
    const refExpr = `(${1}*x+(${u}))*(${p}*x+(${q})) + (${r}*x+(${s}))*(${1}*x+(${u}))`.replace('1*','');
    const most = `(x${u>=0?'+':'-'}${Math.abs(u)})(${p+r===1?'x':p+r===-1?'âˆ’x':(p+r)+'x'} ${ (q+s)>=0?'+':'âˆ’'} ${Math.abs(q+s)})`;
    return {u,p,q,r,s,txt,inside,refExpr,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  (x+u)((p+r)x+(q+s))"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : extraction du facteur commun puis simplification.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines = [
`F = ${st.txt}`,
`F = ( x ${st.u>=0?'+':'âˆ’'} ${Math.abs(st.u)} ) [ ${binom(st.p,st.q)} + ${binom(st.r,st.s)} ]`,
`F = ( x ${st.u>=0?'+':'âˆ’'} ${Math.abs(st.u)} ) ( ${st.inside} )`
    ];
    const rows = lines.map((t,i)=> i===1
      ? {lhs:'', rhs:t.replace('( x','<span class="s-dist">'+fc('( x') ).replace(' ]', ' ]</span>'), connector:'eq'}
      : {lhs: i===0?'<span class="s-eno"></span>':'', rhs:t, connector:'eq'});
    $("#res",host).innerHTML = stepsAlignedHTML(rows);
    $("#reponse",host).value = st.most.replace(/\s+/g,'');
  },
  reset: ex1.reset
};

/* 7 â€” Regrouper : diffÃ©rence (PDF exact) */
const ex7 = {
  id:"regroupement-difference-produits",
  title:"Regrouper : diffÃ©rence de deux produits avec un facteur commun (ax+b)",
  gen(){
    const u = choice([5,6,7,8]); // pour caler sur l'exemple PDF (x+5)
    const p = -2, q = -2, r = -2, s = 3; // structure de l'exemple PDF
    const left = `( x + ${u} ) ( ${fmtAx(p)} ${q>=0?'+':'âˆ’'} ${Math.abs(q)} )`;
    const right= `( ${fmtAx(r)} ${s>=0?'+':'âˆ’'} ${Math.abs(s)} ) ( x + ${u} )`;
    const txt = `${left} âˆ’ ${right}`;
    const refExpr = `(x+(${u}))*(${p}*x+(${q})) - (${r}*x+(${s}))*(x+(${u}))`;
    const linesExact = [
`F = ${txt}`,
`F = ( x + ${u} ) [ ( ${fmtAx(p)} ${q>=0?'+':'âˆ’'} ${Math.abs(q)} ) âˆ’ ( ${fmtAx(r)} ${s>=0?'+':'âˆ’'} ${Math.abs(s)} ) ]`,
`F = ( x + ${u} ) ( ${fmtAx(p)} ${q>=0?'+':'âˆ’'} ${Math.abs(q)} + ${(-r>=0?'+':'âˆ’')} ${Math.abs(-r)}x ${(-s>=0?'+':'âˆ’')} ${Math.abs(-s)} )`,
`F = ( x + ${u} ) ( âˆ’5 )`,
`F = âˆ’5( x + ${u} )`
    ];
    const most = `-5(x+${u})`;
    return {u,p,q,r,s,txt,refExpr,linesExact,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  âˆ’5(x+5)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : extraction de (x+u), distribution du signe âˆ’, puis regroupement.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    // on colle **exactement** la trame PDF pour les 5 lignes
    const rows = st.linesExact.map((t,i)=> i===1
      ? {lhs:'', rhs:t.replace('( x +','<span class="s-dist">'+fc('( x +') ).replace(' ]', ' ]</span>'), connector:'eq'}
      : {lhs: i===0?'<span class="s-eno"></span>':'', rhs:t, connector:'eq'});
    $("#res",host).innerHTML = stepsAlignedHTML(rows);
    $("#reponse",host).value = st.most;
  },
  reset: ex1.reset
};

/* 8 â€” ModÃ¨le PDF: 4x(xâˆ’3) âˆ’ 8xÂ²(xâˆ’3)(3xâˆ’4) */
const ex8 = {
  id:"melange-sommes-differences",
  title:"MÃ©lange : sommes / diffÃ©rences factoriables",
  gen(){
    const k = 4, u = 3, a = 2, b = 3, c = -4; // structure analogue au PDF, mais reste alÃ©atoire possible si besoin
    const txt = `${k}x( x âˆ’ ${u} ) âˆ’ ${2*k}x<sup>2</sup>( x âˆ’ ${u} )( ${b}x âˆ’ ${-c} )`;
    const refExpr = `${k}*x*(x-(${u})) - ${2*k}*x**2*(x-(${u}))*(${b}*x+(${c}))`;
    const lines = [
`F = ${txt.replace(/<[^>]+>/g,'')}`,
`F = ${k}x( x âˆ’ ${u} ) [ 1 âˆ’ ${a}x( ${b}x âˆ’ ${-c} ) ]`,
`F = ${k}x( x âˆ’ ${u} ) ( 1 âˆ’ ${2*b}xÂ² ${2*c>=0?'+':'âˆ’'} ${Math.abs(2*c)}x )`,
`F = ${k}x( x âˆ’ ${u} ) ( âˆ’${2*b}xÂ² ${(-2*c)>=0?'+':'âˆ’'} ${Math.abs(-2*c)}x + 1 )`
    ];
    const most = `${k}x(x-${u})(1-${2*b}x^2+${-2*c}x)`.replace('--','+');
    return {k,u,a,b,c,txt,refExpr,lines,most};
  },
  text(st){ return `F = <span class="equ">${st.txt}</span>`; },
  render(host, st){ renderOne(host, this.text(st), "ex.  4x(xâˆ’3)(âˆ’6xÂ²+8x+1)"); },
  correct(host, st){
    const input = ($("#reponse",host).value||"").trim();
    const ok = acceptAnyFactorization(input, st.refExpr);
    $("#res",host).innerHTML = ok ? "âœ”" : "âœ˜ Attendu : extraire les facteurs communs puis ordonner le polynÃ´me interne.";
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const rows = st.lines.map((t,i)=> i===1
      ? {lhs:'', rhs:t.replace(`${st.k}x(`,'<span class="s-dist">'+fc(`${st.k}x(`) ).replace(' ]', ' ]</span>'), connector:'eq'}
      : {lhs: i===0?'<span class="s-eno"></span>':'', rhs:t, connector:'eq'});
    $("#res",host).innerHTML = stepsAlignedHTML(rows);
    $("#reponse",host).value = st.most;
  },
  reset: ex1.reset
};

/* ====== Orchestrateur ====== */
const REGISTRY = [ex1, ex2, ex3, ex4, ex5, ex6, ex7, ex8];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st=def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);
  const inp = $("#reponse",host) || $("#reponse-vf",host) || $("#reponse-id",host); if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def){ def.reset(host); }
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement("option"); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  sel.value = REGISTRY[0].id;
  buildOne(); updateScore();
});
})();
</script>

<!-- GÃ©nÃ©rateur de fiches PDF (reprend exactement le .steps) -->
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  if (window.ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde â€“ Chapitre 0 â€“ Calculs â€“ Factorisation (F = â€¦) â€” corrigÃ©s PDF',
      max: 50,
      lead: 'Factoriser les expressions suivantes :',
      leadByDefId: {
        "facteur-commun": 'Mise en Ã©vidence dâ€™un facteur commun =',
        "carre-parfait": 'CarrÃ© parfait =',
        "diff-carres": 'DiffÃ©rence de deux carrÃ©s =',
        "kx2-kr2": 'kxÂ² âˆ’ k rÂ² =',
        "trinome-rs": 'xÂ² âˆ’ (r+s)x + rs =',
        "regroupement-somme-produits": 'Regrouper (somme de produits) =',
        "regroupement-difference-produits": 'Regrouper (diffÃ©rence de produits) =',
        "melange-sommes-differences": 'Sommes / diffÃ©rences factoriables ='
      }
    });
  }
});
</script>

<!-- Clavier math (version fournie) -->
<script src="../../../../js/math-kbd.multiplicatif.js" defer></script>
</body>
</html>