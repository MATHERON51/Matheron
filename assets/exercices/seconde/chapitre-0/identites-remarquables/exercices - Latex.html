<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì Identit√©s remarquables</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css"><!-- m√™me fichier que ta page LaTeX -->
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#666}

/* Grille : √©nonc√© + saisie (1√®re ligne), corrig√© pleine largeur dessous */
.row{
  display:grid;
  grid-template-columns:1fr minmax(260px,340px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px;
  align-items:start;
}
.row .col-label{grid-area:lab}
.row input[type=text], .row .input-line{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

.input-line{display:flex;align-items:center;gap:6px}
.input-line .input-prefix{font-weight:600; white-space:nowrap}

.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
/* .equ {font-weight:600}  ‚Äî plus utilis√© */
.hint{opacity:.85;margin:.2rem 0 .6rem}

/* √âtapes */
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0; white-space:nowrap}

/* === Bloc .equ-offscreen : ENONC√â complet (consigne + √©quation) pour le PDF === */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;} /* pas de doublon de consigne */
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
}
.equ-offscreen .consigne{margin-bottom:6px;font-weight:600}

/* Petit tableau d‚Äôaide (carr√©s parfaits) */
.sqtbl{width:100%;border-collapse:collapse;margin-top:10px}
.sqtbl td{border:1px solid #eaeaea;padding:8px;text-align:center;white-space:nowrap}
.sqtbl tr:nth-child(even) td{background:#fbfbfb}
#sol-wrap .btn,#mode-conseil{width:100%}
</style>

<!-- MathJax v3 pour l‚Äôaffichage LaTeX \( ... \) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì <strong>Identit√©s remarquables</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre principale -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn" title="G√©n√®re un nouvel √©nonc√©">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn" title="V√©rifie ta r√©ponse">‚úÖ V√©rifier</button>

      <!-- Le bouton Solution sera "envelopp√©" avec le s√©lecteur (colonne) -->
      <span id="sol-wrap" style="display:inline-flex;flex-direction:column;align-items:flex-start;gap:4px;min-width:260px;width:260px">
        <button id="btn-solution" class="btn" title="Affiche une solution d√©taill√©e">üí° Solution</button>
        <!-- le select est inject√© ici via JS -->
      </span>

      <button id="btn-reset" class="btn" title="R√©initialise la saisie et le score">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <!-- ENONC√â / SAISIE / CORRIG√â -->
    <div class="card" id="host"></div>

    <!-- Saisie & indications -->
    <div class="card small" id="help-card">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:8px 0 0 18px">
        <li>√âcris en forme r√©duite, par exemple : <code class="code">x^2 + 4x + 4</code> (ou <code class="code">x¬≤ + 4x + 4</code>).</li>
        <li>Les signes sont normalis√©s en <code>‚àí</code> (moins Unicode) et la multiplication en <code>√ó</code> si affich√©e.</li>
        <li><strong>S√©lecteur ‚ÄúSolution (avec / sans conseil)‚Äù</strong> : pour les formes <code>(‚àía ¬± b)¬≤</code>, le mode <em>avec conseil</em> r√©√©crit d‚Äôabord l‚Äôexpression (ex. <code>(‚àíA ‚àí B)¬≤ ‚Üí (A + B)¬≤</code>) avant de d√©velopper&nbsp;; <em>sans conseil</em> d√©veloppe directement l‚Äôexpression donn√©e.</li>
        <li><strong>Conseil (exercice 5)</strong> : si la somme ou la diff√©rence est ‚â§ 20, calcule directement sans d√©velopper. Exemple : <code class="code">(10 ‚àí 2)¬≤ = 8¬≤ = 64</code>.</li>
      </ul>
    </div>

    <!-- Clavier math, centr√© -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Librairies -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){'use strict';
/* ==== Utils ==== */
const $  = (s,r=document)=>r.querySelector(s);
const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
const rnd    = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = a=>a[Math.floor(Math.random()*a.length)];

/* ===== Helpers (version LaTeX) ===== */
const UMINUS = '‚àí';           // pour texte hors math
const LMINUS = '-';           // pour LaTeX
const TIMES  = '\\times';     // \times en LaTeX
const FEQ    = s => `\\( F\\;=\\;${s} \\)`;   // ligne ‚ÄúF = ‚Ä¶‚Äù en LaTeX

function uminus(n){ return n<0 ? UMINUS+String(Math.abs(n)) : String(n); }

/* ax en affichage texte (hors math) */
function axStr(a){
  const k=Math.abs(a);
  return (a<0? UMINUS : '') + (k===1? 'x' : (k+'x'));
}

/* ax en LaTeX */
function axLatex(a){
  const k=Math.abs(a);
  return (a<0? LMINUS : '') + (k===1? 'x' : (k+'x'));
}

/* Polyn√¥me -> cha√Æne LaTeX (ax^2 + bx + c) */
function polyToLatex({a2=0,a1=0,a0=0}){
  const parts=[];
  if(a2){ parts.push(a2===1?'x^2':a2===-1?'-x^2':`${a2}x^2`); }
  if(a1){
    const k=Math.abs(a1), t=(k===1?'x':k+'x');
    parts.push((a1>0?'+ ':'- ') + t);
  }
  if(a0){
    parts.push((a0>0?'+ ':'- ') + Math.abs(a0));
  }
  return (parts.join(' ')||'0').replace(/^\+ /,'');
}

/* Pour remplir la saisie (notation clavier) au clic ‚ÄúSolution‚Äù */
function polyToAscii({a2=0,a1=0,a0=0}){
  let s='';
  if(a2){ s = (a2===1?'x^2':a2===-1?'-x^2':a2+'x^2'); }
  if(a1){
    const k=Math.abs(a1), t=(k===1?'x':k+'x');
    s += (s?' ':'') + (a1>0? '+ ':'- ') + t;
  }
  if(a0){
    s += (s?' ':'') + (a0>0? '+ ':'- ') + Math.abs(a0);
  }
  return s || '0';
}

/* Petit tableau des carr√©s 0 ‚Üí 20 (en LaTeX) */
function squaresTableHTML(){
  const nPerRow = 7;
  const t = [];
  t.push('<div class="hint">');
  t.push('<div style="font-weight:600;margin:.4rem 0;">Table des carr√©s 0‚Üí20</div>');
  t.push('<table class="sqtbl"><tbody>');
  for(let i=0;i<=21;i+=nPerRow){
    const start = i, end = Math.min(20, i + nPerRow - 1);
    if(start > 20) break;
    t.push('<tr>');
    for(let n = start; n <= end; n++){
      t.push(`<td>\\( ${n}^2 = ${n*n} \\)</td>`);
    }
    t.push('</tr>');
  }
  t.push('</tbody></table></div>');
  return t.join('');
}

/* ===== PATCH ‚Äî normalisation stricte de la saisie (forme r√©duite) =====
   (identique au comportement d‚Äôorigine, tol√®re x^2 / x¬≤, etc.)
*/
function normalizeInputPoly(txt){
  if(!txt) return "";
  let s = String(txt);

  // Refus imm√©diat : consigne/√©tapes ou √©galit√©
  if(/[=]/.test(s) || /\bF\b/i.test(s) || /\b(Formule|Conseil|Or)\b/i.test(s)) return "__REJECT__";

  // Normalisations des symboles
  s = s.replace(/[\u2212\u2013\u2014]/g,'-'); // ‚àí ‚Äì ‚Äî -> -
  s = s.replace(/[√ó¬∑]/g,'*');                // √ó ¬∑ -> *

  // Puissances : ¬≤/¬≥ -> ^2/^3
  s = s.replace(/([xX])\s*¬≤/g, '$1^2')
       .replace(/([xX])\s*¬≥/g, '$1^3')
       .replace(/([xX])\s*\^\s*(\d+)/g, '$1^$2');

  // Multiplication autour de x
  s = s.replace(/(\d)\s+([xX])/g, '$1$2');      // "3 x" -> "3x"
  s = s.replace(/(\d)\s*\*\s*([xX])/g, '$1$2'); // "3*x" -> "3x"
  s = s.replace(/([xX])\s*\*\s*(\d)/g, '$2x');  // "x*3" -> "3x"

  // x * x, x x, xx -> x^2 (it√©r√© pour s√ªret√©)
  for(let i=0;i<3;i++){
    s = s.replace(/([xX])\s*(?:\*\s*)?([xX])/g, 'x^2');
  }

  // Nettoyage espaces
  s = s.replace(/\s+/g,'');

  // Rejets restants
  if(/[()\/]/.test(s)) return "__REJECT__";
  if(/\*/.test(s)) return "__REJECT__";
  if(/[A-WYZ]/i.test(s)) return "__REJECT__"; // seules les x/X sont tol√©r√©es

  // Canonical
  s = s.replace(/X/g,'x');
  s = s.replace(/x\^1\b/g,'x').replace(/x\^2\b/g,'x2');

  if(/\^/.test(s)) return "__REJECT__";
  return s;
}

/* Parseur simple de polyn√¥mes ax^2+bx+c */
function parsePoly(txt){
  let s = normalizeInputPoly(txt);
  if(!s || s==="__REJECT__") return null;

  if(!/^[0-9x+\-]*$/.test(s)) return null;

  const parts = s.match(/[+\-]?[^+\-]+/g) || [];
  let a2=0, a1=0, a0=0;

  for(const p0 of parts){
    const p = p0.trim();
    if(!p) continue;

    if(/x2$/.test(p)){                 // terme en x^2
      let k = p.replace(/x2$/,'');
      if(k===''||k==='+') k=1; else if(k==='-') k=-1; else k=parseInt(k,10);
      if(!Number.isFinite(k)) return null;
      a2 += k;

    }else if(/x$/.test(p)){            // terme en x
      let k = p.replace(/x$/,'');
      if(k===''||k==='+') k=1; else if(k==='-') k=-1; else k=parseInt(k,10);
      if(!Number.isFinite(k)) return null;
      a1 += k;

    }else{                              // constant
      if(!/^[+\-]?\d+$/.test(p)) return null;
      a0 += parseInt(p,10);
    }
  }
  return {a2,a1,a0};
}

/* Bloc √©tapes ‚Äî on affiche directement des cha√Ænes LaTeX \( ... \) */
function stepsHTML(lines){
  const arr = Array.isArray(lines) ? lines : [lines];

  // Ajoute automatiquement un &nbsp; avant \( quand il est pr√©c√©d√© d‚Äôun ":" ou d‚Äôun mot-cl√©
  const fixPunct = s => String(s)
    // ":" juste avant une formule -> ": \("
    .replace(/:\s*\\\(/g, ':&nbsp;\\(')
    // cas usuels "Formule : \( ‚Ä¶", "Conseil : \( ‚Ä¶", "Or \( ‚Ä¶"
    .replace(/\b(Formule|Conseil)\s*:\s*\\\(/g, (_m, p)=> `${p} :&nbsp;\\(`)
    .replace(/\bOr\s*\\\(/g, 'Or&nbsp;\\(');

  return '<div class="steps">' +
    arr.filter(x => x != null && x !== false)
       .map(s => `<div class="step">${fixPunct(s)}</div>`)
       .join('') +
    '</div>';
}


/* ===== D√©veloppement : (ax ¬± b)¬≤ ‚Äî lignes LaTeX =====
   useAdvice : si true, affiche les r√©√©critures (‚àíA¬±B)¬≤ ‚Üí ‚Ä¶
   k : facteur ext√©rieur √©ventuel (null sinon)
*/
function buildSquareLines(a,b,sign, k=null, useAdvice=true){
  const plus    = (sign === '+');
  const signL   = plus ? '+' : '-';
  const Apos    = Math.abs(a);
  const Bpos    = Math.abs(b);
  const ArawLx  = axLatex(a);
  const AposLx  = axLatex(Apos);
  const BLx     = String(Bpos);
  const kL      = (k==null) ? '' : (k<0?`-${Math.abs(k)}`:String(k));

  const lines = [];

  // 1) √ânonc√© exact en LaTeX
  const lhs0 = (k==null)
    ? `(${ArawLx} ${signL} ${BLx})^2`
    : `${kL}\\,\\big(${ArawLx} ${signL} ${BLx}\\big)^2`;
  lines.push(FEQ(lhs0));

  // 2) Mode "conseil" si a<0
  if(useAdvice && a<0){
    if(!plus){
      // (‚àíA ‚àí B)¬≤ = (A + B)¬≤
      lines.push(`Conseil :&nbsp; \\( (-A - B)^2 = (A + B)^2 \\)`);
      const rhs = (k==null)
        ? `(${AposLx} + ${BLx})^2`
        : `${kL}\\,\\big(${AposLx} + ${BLx}\\big)^2`;
      lines.push(FEQ(rhs));
      lines.push(`Formule :&nbsp; \\( (A + B)^2 \\) avec \\( A=${AposLx} \\), \\( B=${BLx} \\)`);
      lines.push(`Or&nbsp; \\( (A + B)^2 = A^2 + 2AB + B^2 \\)`);

      // CAS a<0 et sign === '‚àí'  (conseil : (-A ‚àí B)¬≤ ‚Üí (A + B)¬≤)
const inner = `(${AposLx})^2 + 2 ${TIMES} ${AposLx} ${TIMES} ${BLx} + ${BLx}^2`;
lines.push(FEQ(k==null ? inner : `${kL}\\,\\big(${inner}\\big)`));

      const a2=Apos*Apos, a1=2*Apos*Bpos, a0=Bpos*Bpos;
      const last = polyToLatex({a2:(k||1)*a2, a1:(k||1)*a1, a0:(k||1)*a0});
      lines.push(FEQ(last));
      return lines;

    }else{
      // (‚àíA + B)¬≤ = (B ‚àí A)¬≤
      lines.push(`Conseil :&nbsp; \\( (-A + B)^2 = (B - A)^2 \\)`);
      const rhs = (k==null)
        ? `(${BLx} - ${AposLx})^2`
        : `${kL}\\,\\big(${BLx} - ${AposLx}\\big)^2`;
      lines.push(FEQ(rhs));
      lines.push(`Formule :&nbsp; \\( (B - A)^2 \\) avec \\( B=${AposLx} \\), \\( A=${BLx} \\)`);
      lines.push(`Or&nbsp; \\( (B - A)^2 = B^2 - 2BA + A^2 \\)`);

      // CAS a<0 et sign === '+'  (conseil : (-A + B)¬≤ ‚Üí (B ‚àí A)¬≤)
const inner = `(${AposLx})^2 - 2 ${TIMES} ${AposLx} ${TIMES} ${BLx} + ${BLx}^2`;
lines.push(FEQ(k==null ? inner : `${kL}\\,\\big(${inner}\\big)`));

      const a2=Apos*Apos, a1=-2*Apos*Bpos, a0=Bpos*Bpos;
      const last = polyToLatex({a2:(k||1)*a2, a1:(k||1)*a1, a0:(k||1)*a0});
      lines.push(FEQ(last));
      return lines;
    }
  }

  // 3) Cas ¬´ sans conseil ¬ª (ou a>=0)
  const form = plus ? '(A + B)^2' : '(A - B)^2';
  lines.push(`Formule :&nbsp; \\( ${form} \\) avec \\( A=${ArawLx} \\), \\( B=${BLx} \\)`);
  lines.push(`Or&nbsp; \\( ${form} = ${ plus ? 'A^2 + 2AB + B^2' : 'A^2 - 2AB + B^2' } \\)`);

// CAS g√©n√©ral (a‚â•0 ou sans conseil)
const inner = plus
  ? `(${ArawLx})^2 + 2 ${TIMES} ${ArawLx} ${TIMES} ${BLx} + ${BLx}^2`
  : `(${ArawLx})^2 - 2 ${TIMES} ${ArawLx} ${TIMES} ${BLx} + ${BLx}^2`;
lines.push(FEQ(k==null ? inner : `${kL}\\,\\big(${inner}\\big)`));

  const Acoef=Math.abs(a);
  const innerA1 = (plus ? 1 : -1) * 2*(a)*Bpos; // a sign√© ici
  const last = polyToLatex({
    a2:(k||1)*Acoef*Acoef,
    a1:(k||1)*innerA1,
    a0:(k||1)*Bpos*Bpos
  });
  lines.push(FEQ(last));
  return lines;
}

/* ===== Exercices ===== */
const ex1 = {
  id:"carre-binom",
  title:"D√©velopper : (ax ¬± b)¬≤",
  gen(){
    const a = rnd(-9,9)||1;
    const b = Math.abs(rnd(-12,12)||2);
    const sign = choice(['+','‚àí']);
    const A = Math.abs(a), B = b;
    const pm = sign;
    const exp = {
      a2: A*A,
      a1: (pm==='+') ? 2*a*B : -2*a*B, // a sign√©
      a0: B*B
    };
    return {a,b,sign,exp};
  },
  text(st){
    const s = st.sign==='‚àí' ? '-' : '+';
    return FEQ(`(${axLatex(st.a)} ${s} ${Math.abs(st.b)})^2`);
  },
  render(host, st){ renderRow(host, "D√©velopper et r√©duire :", this.text(st), "ex.  x^2 + 4x + 4", "R√©ponse (forme r√©duite)", "F ="); },
  correct(host, st){
    const ans = parsePoly($("#reponse",host).value);
    if(!ans){ $("#res",host).innerHTML="‚úò R√©ponse invalide (ex.  x^2 + 4x + 4)"; $("#res",host).className="res-ko"; return {ok:false,total:1}; }
    const ok = ans.a2===st.exp.a2 && ans.a1===st.exp.a1 && ans.a0===st.exp.a0;
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : \\( ${polyToLatex(st.exp)} \\))`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const adv = useAdvice();
    const lines = buildSquareLines(st.a, st.b, st.sign, null, adv);
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value  = polyToAscii(st.exp);
  },
  printSolutionHTML(st){ return stepsHTML(buildSquareLines(st.a, st.b, st.sign, null, true)); },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

const ex2 = {
  id:"produit-conj",
  title:"D√©velopper : (a + b)(a ‚àí b)",
  gen(){
    const a = rnd(-9,9) || -1;
    const b = Math.abs(rnd(-12,12) || 2);
    const order = Math.random() < 0.5 ? 'pm' : 'mp';
    return {a,b,order,exp:{a2:Math.abs(a)*Math.abs(a),a1:0,a0:-(b*b)}};
  },
  text(st){
    const A = axLatex(st.a), B = String(Math.abs(st.b));
    const e = st.order==='pm'
      ? `(${A} + ${B})(${A} - ${B})`
      : `(${A} - ${B})(${A} + ${B})`;
    return FEQ(e);
  },
  render(host, st){ renderRow(host, "D√©velopper et r√©duire :", this.text(st), "ex.  x^2 + 4x + 4", "R√©ponse (forme r√©duite)", "F ="); },
  correct(host, st){
    const ans = parsePoly($("#reponse",host).value);
    if(!ans){ $("#res",host).innerHTML="‚úò R√©ponse invalide (ex.  x^2 - 4)"; $("#res",host).className="res-ko"; return {ok:false,total:1}; }
    const ok = ans.a2===st.exp.a2 && ans.a1===st.exp.a1 && ans.a0===st.exp.a0;
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : \\( ${polyToLatex(st.exp)} \\))`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    const A=axLatex(st.a), B=String(Math.abs(st.b));
    const form  = st.order==='pm' ? '(A + B)(A - B)' : '(A - B)(A + B)';
    const first = st.order==='pm'
      ? FEQ(`(${A} + ${B})(${A} - ${B})`)
      : FEQ(`(${A} - ${B})(${A} + ${B})`);
    const lines = [
      first,
      `Formule :&nbsp; \\( ${form} \\) avec \\( A=${A} \\), \\( B=${B} \\)`,
      `Or&nbsp; \\( ${form} = A^2 - B^2 \\)`,
      FEQ(`(${A})^2 - ${B}^2`),
      FEQ(`${polyToLatex({a2:Math.abs(st.a)*Math.abs(st.a),a1:0,a0:-(st.b*st.b)})}`)
    ];
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value  = polyToAscii({a2:Math.abs(st.a)*Math.abs(st.a),a1:0,a0:-(st.b*st.b)});
  },
  printSolutionHTML(st){
    const A=axLatex(st.a), B=String(Math.abs(st.b));
    const form  = st.order==='pm' ? '(A + B)(A - B)' : '(A - B)(A + B)';
    const first = st.order==='pm'
      ? FEQ(`(${A} + ${B})(${A} - ${B})`)
      : FEQ(`(${A} - ${B})(${A} + ${B})`);
    const lines = [
      first,
      `Formule :&nbsp; \\( ${form} \\) avec \\( A=${A} \\), \\( B=${B} \\)`,
      `Or&nbsp; \\( ${form} = A^2 - B^2 \\)`,
      FEQ(`(${A})^2 - ${B}^2`),
      FEQ(`${polyToLatex({a2:Math.abs(st.a)*Math.abs(st.a),a1:0,a0:-(st.b*st.b)})}`)
    ];
    return stepsHTML(lines);
  },
  reset: ex1.reset
};

const ex3 = {
  id:"k-carr√©",
  title:"D√©velopper : k ¬∑ (ax ¬± b)¬≤",
  gen(){
    const k = rnd(-9,9)||1;
    const a = rnd(-9,9)||1;
    const b = Math.abs(rnd(-12,12)||2);
    const sign = choice(['+','‚àí']);
    const A=Math.abs(a), B=b;
    const exp={ a2:k*(A*A), a1:k*((sign==='+')?2*a*B:-2*a*B), a0:k*(B*B) }; // a sign√©
    return {k,a,b,sign,exp};
  },
  text(st){
    const s = st.sign==='‚àí' ? '-' : '+';
    const k = st.k<0 ? `-${Math.abs(st.k)}` : String(st.k);
    return FEQ(`${k}\\,\\big(${axLatex(st.a)} ${s} ${Math.abs(st.b)}\\big)^2`);
  },
  render(host, st){ renderRow(host, "D√©velopper et r√©duire :", this.text(st), "ex.  x^2 + 4x + 4", "R√©ponse (forme r√©duite)", "F ="); },
  correct(host, st){
    const ans = parsePoly($("#reponse",host).value);
    if(!ans){ $("#res",host).innerHTML="‚úò R√©ponse invalide (ex.  x^2 - 4)"; $("#res",host).className="res-ko"; return {ok:false,total:1}; }
    const ok = ans.a2===st.exp.a2 && ans.a1===st.exp.a1 && ans.a0===st.exp.a0;
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : \\( ${polyToLatex(st.exp)} \\))`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    const lines = buildSquareLines(st.a, st.b, st.sign, st.k, useAdvice());
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value = polyToAscii(st.exp);
  },
  printSolutionHTML(st){ return stepsHTML(buildSquareLines(st.a, st.b, st.sign, st.k, true)); },
  reset: ex1.reset
};

const ex4 = {
  id: "vf-idr",
  title: "Vrai / Faux : identit√© remarquable",

  gen(){
    const type = choice(['carre+','carre-','conj']);
    const a = rnd(-6,6) || 1;
    const b = rnd(-9,9) || 2;

    let exp, prop, answer;

    if (type === 'conj') {
      // (ax + b)(ax ‚àí b) = a^2 x^2 ‚àí b^2
      const A = Math.abs(a), B = Math.abs(b);
      exp = { a2: A*A, a1: 0, a0: -(B*B) };

      const correct = Math.random() < 0.6;
      prop = { ...exp };
      if (!correct) {
        if (Math.random() < 0.5) prop.a0 = -prop.a0;         // inverse le signe du terme constant
        else                     prop.a1 = choice([-1,1]) * rnd(1,5); // ajoute un terme x
      }
      answer = correct ? 'Vrai' : 'Faux';
    } else {
      // (ax ¬± b)^2  ‚Äî on prend a SIGN√â pour 2ab
      const s = (type === 'carre+') ? +1 : -1;
      const A = Math.abs(a), B = Math.abs(b);
      exp = {
        a2: A*A,
        a1: 2 * a * s * B,      // a sign√©, B>0
        a0: B*B
      };

      const correct = Math.random() < 0.6;
      prop = { ...exp };
      if (!correct) {
        if (Math.random() < 0.5) prop.a1 = -prop.a1;        // inverse le signe du terme x
        else                     prop.a0 += choice([-1,1]) * rnd(1,3); // petite perturbation du constant
      }
      answer = correct ? 'Vrai' : 'Faux';
    }

    return { type, a, b, exp, prop, answer };
  },

  text(st){
    if (st.type === 'conj') {
      return `\\( (${axLatex(st.a)}+${Math.abs(st.b)})(${axLatex(st.a)}-${Math.abs(st.b)}) \\;=\\; ${polyToLatex(st.prop)} \\)`;
    } else if (st.type === 'carre+') {
      return `\\( (${axLatex(st.a)}+${Math.abs(st.b)})^2 \\;=\\; ${polyToLatex(st.prop)} \\)`;
    } else { // carre-
      return `\\( (${axLatex(st.a)}-${Math.abs(st.b)})^2 \\;=\\; ${polyToLatex(st.prop)} \\)`;
    }
  },

  render(host, st){
    renderRow(host, "Dire si l‚Äô√©galit√© est vraie :", this.text(st), "Choisir Vrai / Faux", "R√©ponse", "");
    const row = host.querySelector('.row');
    const inpWrap = row.querySelector('.input-line');
    const sel = document.createElement('select'); sel.id = "reponse-vf";
    ["","Vrai","Faux"].forEach(v => sel.appendChild(new Option(v, v)));
    inpWrap.replaceWith(sel);
  },

  correct(host, st){
    const val = ($("#reponse-vf", host) || {}).value || "";
    const ok = (val === st.answer);
    $("#res", host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${st.answer})`;
    $("#res", host).className = ok ? "res-ok" : "res-ko";
    return { ok, total: 1 };
  },

  solution(host, st){
    const { type, a, b } = st;

    // LHS EXACTEMENT comme dans l‚Äô√©nonc√©
    let lhs = "";
    if (type === 'conj') {
      lhs = `(${axLatex(a)} + ${Math.abs(b)})(${axLatex(a)} - ${Math.abs(b)})`;
    } else if (type === 'carre+') {
      lhs = `(${axLatex(a)} + ${Math.abs(b)})^2`;
    } else {
      lhs = `(${axLatex(a)} - ${Math.abs(b)})^2`;
    }

    let lines = [];

    if (type === 'conj') {
      const A=axLatex(a), B=String(Math.abs(b));
      lines = [
        FEQ(lhs),
        `Formule :&nbsp; \\( (A + B)(A - B) \\) avec \\( A=${A} \\), \\( B=${B} \\)`,
        `Or&nbsp; \\( (A + B)(A - B) = A^2 - B^2 \\)`,
        FEQ(`(${A})^2 - ${B}^2`),
        FEQ(`${polyToLatex({a2:Math.abs(a)*Math.abs(a), a1:0, a0:-(Math.abs(b)*Math.abs(b))})}`)
      ];
    } else {
      const signSym = (type === 'carre+') ? '+' : '‚àí';
      const adv = useAdvice();
      lines = buildSquareLines(a, b, signSym, null, adv);
      // 1 ≥·µâ ligne = √©nonc√© exact
      lines[0] = FEQ(lhs);
    }

    // Conclusion : uniquement pour l‚Äôex. 4
    lines.push('Conclusion : l‚Äô√©galit√© est ' + (st.answer === 'Vrai' ? 'vraie' : 'fausse') + '.');

    $$(".hint",host).forEach(n => n.remove());
    $$(".equ-offscreen",host).forEach(n => n.remove());
    $("#res",host).innerHTML = stepsHTML(lines);
  },

  printSolutionHTML(st){
    const host = document.createElement('div');
    this.solution(host, st);
    return host.querySelector('#res')?.innerHTML || '';
  },

  reset(host){
    const sel = $("#reponse-vf",host);
    if (sel) sel.value = "";
    $("#res",host).textContent = "";
  }
};

const ex5 = {
  id:"calcul-num",
  title:"Calculer rapidement (identit√© remarquable)",
  gen(){
    const kind = choice(['square','prod']);
    const pool = [-20,-15,-12,-10,-8,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,10,12,15,20,-100,100];
    if(kind==='square'){
      const a = choice(pool.filter(v=>v>0));
      const d = choice([1,2,3,4,5,6,8,10]);
      const sign = choice(['+','‚àí']);
      const val = (sign==='+'? (a+d)*(a+d) : (a-d)*(a-d));
      return {kind,sign,a,b:d,expected:val};
    }else{
      const a = choice(pool);
      const k = choice([1,2,3,4,5,6,8,10]);
      const val = a*a - k*k;
      return {kind,a,k,expected:val};
    }
  },
  text(st){
    if(st.kind==='square'){
      const s = st.sign==='‚àí' ? '-' : '+';
      return FEQ(`(${st.a} ${s} ${st.b})^2`);
    }else{
      return FEQ(`(${st.a} - ${st.k})(${st.a} + ${st.k})`);
    }
  },
  render(host, st){
    renderRow(host, "Calculer (sans calculatrice) :", this.text(st), "ex.  2401", "R√©ponse (nombre entier)");
    const box=document.createElement('div'); box.innerHTML = squaresTableHTML(); host.appendChild(box);
  },
  correct(host, st){
    const txt = ($("#reponse",host).value||"").trim().replace(/\s+/g,'');
    if(!/^-?\d+$/.test(txt)){
      $("#res",host).innerHTML = "‚úò Entrez un entier (ex.  9801)";
      $("#res",host).className = "res-ko";
      return {ok:false,total:1};
    }
    const ok = (parseInt(txt,10)===st.expected);
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${st.expected})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines=[];
    if(st.kind==='square'){
      const A = st.a, B = st.b;
      const sum = st.sign==='+' ? (A+B) : (A-B);
      const pow = v => v<0 ? `(${LMINUS}${Math.abs(v)})^2` : `${v}^2`;
      lines.push(FEQ(`(${A} ${st.sign==='‚àí'?'-':'+'} ${B})^2`));
      lines.push(FEQ(`${pow(sum)}`));
      lines.push(FEQ(`${String(sum*sum)}`));
    }else{
      const A = st.a, B = st.k;
      const p2 = n => (n<0?`(${n})`:`${n}`)+'^2';
      lines.push(FEQ(`(${A} - ${B})(${A} + ${B})`));
      lines.push(FEQ(`${p2(A)} - ${p2(B)}`));
      lines.push(FEQ(`${A*A} - ${B*B}`));
      lines.push(FEQ(`${String(st.expected)}`));
    }
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value = String(st.expected);
  },
  printSolutionHTML(st){
    if(st.kind==='square'){
      const A=st.a, B=st.b, sum=(st.sign==='+'?A+B:A-B);
      const pow = v => v<0 ? `(${LMINUS}${Math.abs(v)})^2` : `${v}^2`;
      return stepsHTML([FEQ(`(${A} ${st.sign==='‚àí'?'-':'+'} ${B})^2`), FEQ(`${pow(sum)}`), FEQ(`${ sum*sum }`)]);
    }else{
      const A=st.a, K=st.k;
      const p2 = n => (n<0?`(${n})`:`${n}`)+'^2';
      return stepsHTML([FEQ(`(${A} - ${K})(${A} + ${K})`), FEQ(`${p2(A)} - ${p2(K)}`), FEQ(`${A*A} - ${K*K}`), FEQ(`${A*A - K*K}`)]);
    }
  },
  reset: ex1.reset
};

/* ===== Registre & moteur ===== */
const REGISTRY = [ex1, ex2, ex3, ex4, ex5];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function renderRow(host, consigneText, htmlEq, placeholder="ex.  x^2 + 4x + 4", label='R√©ponse (forme r√©duite)', prefixLabel=""){
  host.innerHTML="";
  const hint=document.createElement('p'); hint.className="hint"; hint.textContent=`Consigne : ${consigneText}`; host.appendChild(hint);
  const off=document.createElement('div'); off.className="equ-offscreen";
  off.innerHTML=`<div class="consigne">${consigneText}</div><div class="equation">${htmlEq}</div>`;
  host.appendChild(off);

  const row=document.createElement("div"); row.className="row";
  const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=htmlEq; row.appendChild(lab);

  const inpWrap=document.createElement("div"); inpWrap.className="input-line";
  if(prefixLabel){ const pre=document.createElement("span"); pre.className="input-prefix"; pre.innerHTML=prefixLabel.replace(' = ','&nbsp;=&nbsp;'); inpWrap.appendChild(pre); }
  const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder=placeholder; inpWrap.appendChild(inp);
  row.appendChild(inpWrap);

  const res=document.createElement("div"); res.id="res"; row.appendChild(res);
  host.appendChild(row);

  // Demande √† MathJax de typesetter les nouvelles maths
  if (window.MathJax && MathJax.typesetPromise) { MathJax.typesetPromise([host]); }

  return {inp,res};
}

function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st=def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);
  const inp = $("#reponse",host) || $("#reponse-vf",host); if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  def.solution(host, st);
  if (window.MathJax && MathJax.typesetPromise) { MathJax.typesetPromise([host]); }
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def){ def.reset(host); }
}

// === Choix d'affichage de la solution pour (-a ¬± b)¬≤ ===
function useAdvice(){
  const sel = document.getElementById('mode-conseil');
  return !sel || sel.value !== 'nocons';
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement("option"); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  // S√©lecteur "solution avec/sans conseil" ‚Äî sous le bouton Solution mais sans d√©placer les autres boutons
  const wrap = document.getElementById('sol-wrap');
  const modeConseil = document.createElement('select');
  modeConseil.id = 'mode-conseil';
  modeConseil.title = "Mode d'affichage de la solution";
  modeConseil.innerHTML = `
    <option value="cons">Solution (avec conseil)</option>
    <option value="nocons">Solution (sans conseil)</option>
  `;
  wrap.appendChild(modeConseil);

  sel.value = REGISTRY[0].id;
  buildOne(); updateScore();
  document.addEventListener('keydown', function(ev){
    if(ev.key === 'Enter'){
      const a = document.activeElement;
      if(a && a.id === 'reponse'){
        ev.preventDefault();
        try{ check(); }catch(_){}
      }
    }
  });

  // PDF : ins√®re l‚Äôoutil au-dessus du clavier, capture consigne+√©nonc√© et corrig√©
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì Identit√©s remarquables',
      max: 50,
      mountAfterSelector: '.card.small',
      beforeRender(def, st, withSolutions){
        try{
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          def.render(tmp, st);
          if(!withSolutions){
            const equ = tmp.querySelector('.equ-offscreen');
            if(equ) return equ.outerHTML;  // consigne + √©quation (LaTeX)
            return tmp.innerHTML;
          }else{
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            const res = tmp.querySelector('#res');
            if(res) return res.innerHTML;   // √©tapes LaTeX
            return tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }

  // Normalisation Unicode (‚àí, √ó ‚Ä¶)
  if (window.DevRules && DevRules.attachCleaner) DevRules.attachCleaner();
});
})();
</script>

<script>
/* Am√©liorations UI mobile & confort (identique √† ta base) */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on d√©clenche .click() sur eux)
[['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s‚Äôouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
