<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì Identit√©s remarquables</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#666}

/* Grille : √©nonc√© + saisie (1√®re ligne), corrig√© pleine largeur dessous */
.row{
  display:grid;
  grid-template-columns:1fr minmax(260px,340px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px;
  align-items:start;
}
.row .col-label{grid-area:lab}
.row input[type=text], .row .input-line{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

.input-line{display:flex;align-items:center;gap:6px}
.input-line .input-prefix{font-weight:600; white-space:nowrap}

.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.equ{font-weight:600}
.hint{opacity:.85;margin:.2rem 0 .6rem}

/* √âtapes */
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0; white-space:nowrap}

/* === Bloc .equ-offscreen : ENONC√â complet (consigne + √©quation) pour le PDF === */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;} /* pas de doublon de consigne */
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
}
.equ-offscreen .consigne{margin-bottom:6px;font-weight:600}

/* Petit tableau d‚Äôaide (carr√©s parfaits) */
.sqtbl{width:100%;border-collapse:collapse;margin-top:10px}
.sqtbl td{border:1px solid #eaeaea;padding:8px;text-align:center;white-space:nowrap}
.sqtbl tr:nth-child(even) td{background:#fbfbfb}
#sol-wrap .btn,#mode-conseil{width:100%}

/* === Patch 2025-08-31 ‚Äî Saisie sous la question === */
.row{
  grid-template-columns: 1fr !important;
  grid-template-areas:
    'lab'
    'inp'
    'res' !important;
}


/* ===== Mobile-first tokens ===== */
:root{
  --tap:48px; --gap:10px; --pad:14px;
  --ink:#111; --bg:#fff; --line:#e6e6e6;
}
@media (max-width:760px){
  /* Conteneur + cartes plus respirants */
  .wrap{padding:12px !important}
  .card{padding:14px !important}

  /* Grilles ‚Üí une colonne (tes .grid/.g2/.two etc.) */
  .grid, .g2, .grid.two, .grid2{display:grid;grid-template-columns:1fr !important;gap:var(--gap)}

  /* Champs sous la question + largeur 100% */
  .q input[type="text"], .q .answer, input[type="text"], textarea, select{
    width:100%; min-height:var(--tap); font-size:16px; /* √©vite le zoom iOS */
    margin-top:8px;
  }

  /* Boutons plus grands et cliquables */
  .controls button, .controls .btn, button, .kbd .key{
    min-height:var(--tap);
    padding:12px 14px; font-weight:600;
  }

  /* Tables scrollables si trop larges */
  table{display:block; overflow-x:auto; -webkit-overflow-scrolling:touch}
  table thead, table tbody{width:100%}

  /* Figures (SVG/canvas) fluides */
  svg, canvas, .figure, .circle-host{max-width:100% !important; width:100% !important; height:auto}

  /* Barre d‚Äôactions mobile en bas (duplique l‚Äôimportant) */
  .mb-actions{
    position:sticky; bottom:0; z-index:20;
    background:var(--bg); border-top:1px solid var(--line);
    padding:8px calc(10px + env(safe-area-inset-right)) calc(8px + env(safe-area-inset-bottom)) calc(10px + env(safe-area-inset-left));
    display:flex; gap:8px;
  }
  .mb-actions .btn{flex:1}

  /* Clavier math en tiroir */
  .kbd-host[data-collapsible]{position:fixed; left:0; right:0; bottom:0;
    background:#fff; border-top:1px solid var(--line);
    transform:translateY(100%); transition:transform .25s ease; z-index:30;
    padding-bottom:calc(env(safe-area-inset-bottom) + 6px);
  }
  .kbd-host[data-open="1"]{transform:translateY(0)}
  .kbd-toggle{position:fixed; right:12px; bottom:calc(64px + env(safe-area-inset-bottom));
    background:#111; color:#fff; border-radius:999px; padding:10px 14px; z-index:31}
}

/* Focus visibles partout */
:focus-visible{outline:2px solid #60a5fa; outline-offset:2px}
</style>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì <strong>Identit√©s remarquables</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre principale -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn" title="G√©n√®re un nouvel √©nonc√©">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn" title="V√©rifie ta r√©ponse">‚úÖ V√©rifier</button>

      <!-- Le bouton Solution sera "envelopp√©" avec le s√©lecteur (colonne) -->
      <span id="sol-wrap" style="display:inline-flex;flex-direction:column;align-items:flex-start;gap:4px;min-width:260px;width:260px">
        <button id="btn-solution" class="btn" title="Affiche une solution d√©taill√©e">üí° Solution</button>
        <!-- le select est inject√© ici via JS -->
      </span>

      <button id="btn-reset" class="btn" title="R√©initialise la saisie et le score">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <!-- ENONC√â / SAISIE / CORRIG√â -->
    <div class="card" id="host"></div>

    <!-- Saisie & indications -->
    <div class="card small" id="help-card">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:8px 0 0 18px">
        <li>√âcris en forme r√©duite, par exemple : <code class="code">x^2 + 4x + 4</code> (ou <code class="code">x¬≤ + 4x + 4</code>).</li>
        <li>Les signes sont normalis√©s en <code>‚àí</code> (moins Unicode) et la multiplication en <code>√ó</code> si affich√©e.</li>
        <li><strong>S√©lecteur ‚ÄúSolution (avec / sans conseil)‚Äù</strong> : pour les formes <code>(‚àía ¬± b)¬≤</code>, le mode <em>avec conseil</em> r√©√©crit d‚Äôabord l‚Äôexpression (ex. <code>(‚àíA ‚àí B)¬≤ ‚Üí (A + B)¬≤</code>) avant de d√©velopper&nbsp;; <em>sans conseil</em> d√©veloppe directement l‚Äôexpression donn√©e.</li>
        <li><strong>Conseil (exercice 5)</strong> : si la somme ou la diff√©rence est ‚â§ 20, calcule directement sans d√©velopper. Exemple : <code class="code">(10 ‚àí 2)¬≤ = 8¬≤ = 64</code>.</li>
      </ul>
    </div>

    <!-- Clavier math, centr√© -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Librairies -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
const UMINUS='‚àí', MULT='√ó';
const FEQ = s => `F&nbsp;=&nbsp;${s}`;

/* ===== Helpers ===== */
function uminus(n){ return n<0 ? UMINUS+String(Math.abs(n)) : String(n); }
function axStr(a){ const k=Math.abs(a); return (a<0? UMINUS : '') + (k===1? 'x' : (k+'x')); }
function normalizeSigns(s){
  return s.replace(/\u2212/g,UMINUS)
          .replace(/\+\s*[‚àí-]/g,' ‚àí ')
          .replace(/[‚àí-]\s*\+/g,' ‚àí ')
          .replace(/[‚àí-]\s*[‚àí-]/g,' + ')
          .replace(/\+\s*\+/g,' + ')
          .replace(/\s{2,}/g,' ')
          .trim();
}
function canonSup2(s){
  return s.replace(/([x0-9)])¬≤/g, '$1<sup>2</sup>').replace(/\(<sup>2<\/sup>/g,'(');
}
function polyToHTML({a2=0,a1=0,a0=0}){
  const parts=[];
  if(a2){ parts.push(a2===1?'x<sup>2</sup>':a2===-1?`${UMINUS}x<sup>2</sup>`:uminus(a2)+'x<sup>2</sup>'); }
  if(a1){
    const k=Math.abs(a1), t=(k===1?'x':k+'x');
    if(parts.length) parts.push(a1>0?' + '+t:' ‚àí '+t); else parts.push(a1<0? UMINUS+t : t);
  }
  if(a0){
    const k=Math.abs(a0);
    if(parts.length) parts.push(a0>0?' + '+k:' ‚àí '+k); else parts.push(a0<0? UMINUS+k : ''+k);
  }
  return parts.length? parts.join('') : '0';
}
function polyToAscii({a2=0,a1=0,a0=0}){
  let s='';
  if(a2){ s = (a2===1?'x^2':a2===-1?'-x^2':a2+'x^2'); }
  if(a1){
    const k=Math.abs(a1), t=(k===1?'x':k+'x');
    s += (s?' ':'') + (a1>0? '+ ':'- ') + t;
  }
  if(a0){
    s += (s?' ':'') + (a0>0? '+ ':'- ') + Math.abs(a0);
  }
  return s || '0';
}
// Remplace la version actuelle
function stepsHTML(lines){
  const toStr = v =>
    v == null ? "" :
    (v.outerHTML ? v.outerHTML : String(v));

  // Normalise uniquement les segments de texte (on pr√©serve les balises)
  const beautify = s => String(s)
    .split(/(<[^>]+>)/g)
    .map(seg => seg.startsWith('<') ? seg : canonSup2(normalizeSigns(seg)))
    .join('');

  const arr = Array.isArray(lines) ? lines : [lines];
  return '<div class="steps">' +
    arr.filter(x => x != null && x !== false)
       .map(t => `<div class="step">${ beautify(toStr(t)) }</div>`)
       .join('') +
    '</div>';
}

/* ===== PATCH ‚Äî normalisation stricte de la saisie (forme r√©duite) =====
   Accepte : espaces, '*', '√ó', moins Unicode, puissances ^n / ¬≤.
   Refuse : parenth√®ses, '/', '=', mots de solution ("F", "Formule", "Conseil", "Or").
   Objectif : un polyn√¥me r√©duit de la forme ax^2 + bx + c (ordre libre).
*/
function normalizeInputPoly(txt){
  if(!txt) return "";
  let s = String(txt);

  // Refus imm√©diat : consigne/√©tapes ou √©galit√©
  if(/[=]/.test(s) || /\bF\b/i.test(s) || /\b(Formule|Conseil|Or)\b/i.test(s)) return "__REJECT__";

  // Normalisations des symboles
  s = s.replace(/[\u2212\u2013\u2014]/g,'-'); // ‚àí ‚Äì ‚Äî -> -
  s = s.replace(/[√ó¬∑]/g,'*');                // √ó ¬∑ -> *

  // Puissances : ¬≤/¬≥ -> ^2/^3 ; autoriser espaces autour de ^
  s = s.replace(/([xX])\s*¬≤/g, '$1^2')
       .replace(/([xX])\s*¬≥/g, '$1^3')
       .replace(/([xX])\s*\^\s*(\d+)/g, '$1^$2');

  // Multiplication implicite/explicite autour de x
  s = s.replace(/(\d)\s+([xX])/g, '$1$2');   // "3 x" -> "3x"
  s = s.replace(/(\d)\s*\*\s*([xX])/g, '$1$2'); // "3*x" -> "3x"
  s = s.replace(/([xX])\s*\*\s*(\d)/g, '$2x');  // "x*3" -> "3x"

  // x * x, x x, xx -> x^2 (on it√®re quelques fois, suffisant pour degr√© 2)
  for(let i=0;i<3;i++){
    s = s.replace(/([xX])\s*(?:\*\s*)?([xX])/g, 'x^2');
  }

  // Nettoyage espaces
  s = s.replace(/\s+/g,'');

  // Rejets restants : parenth√®ses, division, ast√©risques r√©siduels, autres lettres
  if(/[()\/]/.test(s)) return "__REJECT__";
  if(/\*/.test(s)) return "__REJECT__";
  if(/[A-WYZ]/i.test(s)) return "__REJECT__"; // seules les x/X sont tol√©r√©es

  // Canonical 'x' et puissances usuelles
  s = s.replace(/X/g,'x');
  s = s.replace(/x\^1\b/g,'x').replace(/x\^2\b/g,'x2');

  // Si un '^' reste -> rejet (on ne parse que jusqu'√† x^2)
  if(/\^/.test(s)) return "__REJECT__";

  return s;
}

/* Simple parseur de polyn√¥mes ax^2+bx+c */
/* Simple parseur de polyn√¥mes ax^2+bx+c (forme r√©duite uniquement) */
function parsePoly(txt){
  let s = normalizeInputPoly(txt);
  if(!s || s==="__REJECT__") return null;

  // Caract√®res autoris√©s apr√®s normalisation
  if(!/^[0-9x+\-]*$/.test(s)) return null;

  // D√©coupage en termes sign√©s
  const parts = s.match(/[+\-]?[^+\-]+/g) || [];
  let a2=0, a1=0, a0=0;

  for(const p0 of parts){
    const p = p0.trim();
    if(!p) continue;

    if(/x2$/.test(p)){                 // terme en x^2
      let k = p.replace(/x2$/,'');
      if(k===''||k==='+') k=1; else if(k==='-') k=-1; else k=parseInt(k,10);
      if(!Number.isFinite(k)) return null;
      a2 += k;

    }else if(/x$/.test(p)){            // terme en x
      let k = p.replace(/x$/,'');
      if(k===''||k==='+') k=1; else if(k==='-') k=-1; else k=parseInt(k,10);
      if(!Number.isFinite(k)) return null;
      a1 += k;

    }else{                              // constant
      if(!/^[+\-]?\d+$/.test(p)) return null;
      a0 += parseInt(p,10);
    }
  }
  return {a2,a1,a0};
}


/* ===== D√©veloppement : (ax ¬± b)¬≤ (avec conseils) =====
   useAdvice : si true, ins√®re les lignes de "Conseil : ‚Ä¶" pour (-a ¬± b)¬≤  */
function buildSquareLines(a,b,sign,k=null, useAdvice=true){
  const kprefix = (k==null) ? '' : uminus(k);
  const AposStr = axStr(Math.abs(a));   // ex: 2x
  const ArawStr = axStr(a);             // ex: ‚àí2x si a<0
  const Bstr    = String(Math.abs(b));  // ex: 5
  const Acoef   = Math.abs(a);
  const Bcoef   = Math.abs(b);
  const lines=[];

  // ===== CAS AVEC CONSEIL quand a<0 =====
  if(useAdvice && a<0){
    if(sign==='‚àí'){
      // (-A ‚àí B)^2 -> (A + B)^2
      lines.push('Conseil : (‚àíA ‚àí B)¬≤ = (A + B)¬≤');
      lines.push(FEQ(`${kprefix}(${AposStr} + ${Bstr})¬≤`));
      lines.push(`Formule : (A + B)¬≤ avec A = ${AposStr}, B = ${Bstr}`);
      lines.push(`Or (A + B)¬≤ = A¬≤ + 2AB + B¬≤`);

      if(k==null){
        lines.push(FEQ(`(${AposStr})¬≤ + 2 ${MULT} (${AposStr}) ${MULT} ${Bstr} + ${Bstr}¬≤`));
      }else{
        lines.push(FEQ(`${kprefix}( (${AposStr})¬≤ + 2 ${MULT} (${AposStr}) ${MULT} ${Bstr} + ${Bstr}¬≤ )`));
      }

      if(k!=null){
        lines.push(FEQ(`${kprefix}( ${polyToHTML({a2:Acoef*Acoef,a1: 2*Acoef*Bcoef,a0:Bcoef*Bcoef})} )`));
      }
      lines.push(FEQ(`${polyToHTML({a2:(k||1)*Acoef*Acoef, a1:(k||1)*( 2*Acoef*Bcoef), a0:(k||1)*Bcoef*Bcoef})}`));
      return lines;
    }else{
      // (-A + B)^2 -> (B ‚àí A)^2 , et on explicite selon la demande
      lines.push('Conseil : (‚àíA + B)¬≤ = (B ‚àí A)¬≤');
      lines.push(FEQ(`${kprefix}(${Bstr} ‚àí ${AposStr})¬≤`));
      lines.push(`Formule : (B ‚àí A)¬≤ avec B = ${AposStr}, A = ${Bstr}`);
      lines.push(`Or (B ‚àí A)¬≤ = B¬≤ ‚àí 2BA + A¬≤`);

      if(k==null){
        lines.push(FEQ(`(${AposStr})¬≤ ‚àí 2 ${MULT} (${AposStr}) ${MULT} ${Bstr} + ${Bstr}¬≤`));
      }else{
        lines.push(FEQ(`${kprefix}( (${AposStr})¬≤ ‚àí 2 ${MULT} (${AposStr}) ${MULT} ${Bstr} + ${Bstr}¬≤ )`));
      }

      if(k!=null){
        lines.push(FEQ(`${kprefix}( ${polyToHTML({a2:Acoef*Acoef,a1:-2*Acoef*Bcoef,a0:Bcoef*Bcoef})} )`));
      }
      lines.push(FEQ(`${polyToHTML({a2:(k||1)*Acoef*Acoef, a1:(k||1)*(-2*Acoef*Bcoef), a0:(k||1)*Bcoef*Bcoef})}`));
      return lines;
    }
  }

  // ===== CAS SANS CONSEIL (ou a >= 0) =====
  // On garde l'expression telle quelle et on applique la bonne formule
  lines.push(FEQ(`${kprefix}(${ArawStr} ${sign} ${Bstr})¬≤`));
  const form = sign==='+' ? '(A + B)¬≤' : '(A ‚àí B)¬≤';
  lines.push(`Formule : ${form} avec A = ${ArawStr}, B = ${Bstr}`);
  lines.push(`Or ${form} = ${ sign==='+' ? 'A¬≤ + 2AB + B¬≤' : 'A¬≤ ‚àí 2AB + B¬≤' }`);

  if(sign==='+'){
    if(k==null){
      lines.push(FEQ(`(${ArawStr})¬≤ + 2 ${MULT} (${ArawStr}) ${MULT} ${Bstr} + ${Bstr}¬≤`));
    }else{
      lines.push(FEQ(`${kprefix}( (${ArawStr})¬≤ + 2 ${MULT} (${ArawStr}) ${MULT} ${Bstr} + ${Bstr}¬≤ )`));
    }
  }else{
    if(k==null){
      lines.push(FEQ(`(${ArawStr})¬≤ ‚àí 2 ${MULT} (${ArawStr}) ${MULT} ${Bstr} + ${Bstr}¬≤`));
    }else{
      lines.push(FEQ(`${kprefix}( (${ArawStr})¬≤ ‚àí 2 ${MULT} (${ArawStr}) ${MULT} ${Bstr} + ${Bstr}¬≤ )`));
    }
  }

  // calcul
  const innerA1 = (sign==='+' ? 1 : -1) * 2*(a)*Bcoef; // ici a sign√©
  if(k!=null){
    lines.push(FEQ(`${kprefix}( ${polyToHTML({a2:Acoef*Acoef,a1:innerA1,a0:Bcoef*Bcoef})} )`));
  }
  lines.push(FEQ(`${polyToHTML({a2:(k||1)*Acoef*Acoef, a1:(k||1)*innerA1, a0:(k||1)*Bcoef*Bcoef})}`));
  return lines;
}

/* ===== Exercices ===== */
const ex1 = {
  id:"carre-binom",
  title:"D√©velopper : (ax ¬± b)¬≤",
  gen(){
    const a = rnd(-9,9)||1;
    const b = Math.abs(rnd(-12,12)||2);
    const sign = choice(['+','‚àí']);
    const A = Math.abs(a), B = b;
    const pm = sign;
    const exp = {
      a2: A*A,
      a1: (pm==='+') ? 2*a*B : -2*a*B, // a sign√©
      a0: B*B
    };
    return {a,b,sign,exp};
  },
  text(st){ return `<span class="equ">${FEQ(`(${axStr(st.a)} ${st.sign} ${Math.abs(st.b)})¬≤`)}</span>`; },
  render(host, st){ renderRow(host, "D√©velopper et r√©duire :", this.text(st), "ex.  x^2 + 4x + 4", "R√©ponse (forme r√©duite)", "F ="); },
  correct(host, st){
    const ans = parsePoly($("#reponse",host).value);
    if(!ans){ $("#res",host).innerHTML="‚úò R√©ponse invalide (ex.  x^2 + 4x + 4)"; $("#res",host).className="res-ko"; return {ok:false,total:1}; }
    const ok = ans.a2===st.exp.a2 && ans.a1===st.exp.a1 && ans.a0===st.exp.a0;
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${polyToHTML(st.exp)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const adv = useAdvice();
    const baseLHS = FEQ(`(${axStr(st.a)} ${st.sign} ${Math.abs(st.b)})¬≤`);
    const lines = buildSquareLines(st.a, st.b, st.sign, null, adv);
    // 1√®re ligne = √©nonc√© exact; si conseil actif et a<0 on affiche l'√©nonc√© puis la r√©√©criture
    if(adv && st.a<0){ lines.unshift(baseLHS); } else { lines[0] = baseLHS; }
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value = polyToAscii(st.exp);
},
  printSolutionHTML(st){ return stepsHTML(buildSquareLines(st.a, st.b, st.sign, null, true)); },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

const ex2 = {
  id:"produit-conj",
  title:"D√©velopper : (a + b)(a ‚àí b)",
  gen(){
    const a = rnd(-9,9) || -1;
    const b = Math.abs(rnd(-12,12) || 2);
    const order = Math.random() < 0.5 ? 'pm' : 'mp';
    return {a,b,order,exp:{a2:Math.abs(a)*Math.abs(a),a1:0,a0:-(b*b)}};
  },
  text(st){
    const A = axStr(st.a), B = String(Math.abs(st.b));
    const e = st.order==='pm'
      ? `(${A} + ${B})(${A} ‚àí ${B})`
      : `(${A} ‚àí ${B})(${A} + ${B})`;
    return `<span class="equ">${FEQ(e)}</span>`;
  },
  render(host, st){ renderRow(host, "D√©velopper et r√©duire :", this.text(st), "ex.  x^2 + 4x + 4", "R√©ponse (forme r√©duite)", "F ="); },
  correct(host, st){
    const ans = parsePoly($("#reponse",host).value);
    if(!ans){ $("#res",host).innerHTML="‚úò R√©ponse invalide (ex.  x^2 - 4)"; $("#res",host).className="res-ko"; return {ok:false,total:1}; }
    const ok = ans.a2===st.exp.a2 && ans.a1===st.exp.a1 && ans.a0===st.exp.a0;
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${polyToHTML(st.exp)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    const Aterm = axStr(st.a), Bterm = String(Math.abs(st.b));
    const form  = st.order==='pm' ? '(A + B)(A ‚àí B)' : '(A ‚àí B)(A + B)';
    const first = st.order==='pm'
      ? FEQ(`(${Aterm} + ${Bterm})(${Aterm} ‚àí ${Bterm})`)
      : FEQ(`(${Aterm} ‚àí ${Bterm})(${Aterm} + ${Bterm})`);
    const lines = [
      first,
      `Formule : ${form} avec A = ${Aterm}, B = ${Bterm}`,
      `Or ${form} = A¬≤ ‚àí B¬≤`,
      FEQ(`(${Aterm})<sup>2</sup> ‚àí ${Bterm}<sup>2</sup>`),
      FEQ(`${polyToHTML({a2:Math.abs(st.a)*Math.abs(st.a),a1:0,a0:-(st.b*st.b)})}`)
    ];
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value  = polyToAscii({a2:Math.abs(st.a)*Math.abs(st.a),a1:0,a0:-(st.b*st.b)});
  },
  printSolutionHTML(st){
    const Aterm = axStr(st.a), Bterm = String(Math.abs(st.b));
    const form  = st.order==='pm' ? '(A + B)(A ‚àí B)' : '(A ‚àí B)(A + B)';
    const first = st.order==='pm'
      ? FEQ(`(${Aterm} + ${Bterm})(${Aterm} ‚àí ${Bterm})`)
      : FEQ(`(${Aterm} ‚àí ${Bterm})(${Aterm} + ${Bterm})`);
    const lines = [
      first,
      `Formule : ${form} avec A = ${Aterm}, B = ${Bterm}`,
      `Or ${form} = A¬≤ ‚àí B¬≤`,
      FEQ(`(${Aterm})<sup>2</sup> ‚àí ${Bterm}<sup>2</sup>`),
      FEQ(`${polyToHTML({a2:Math.abs(st.a)*Math.abs(st.a),a1:0,a0:-(st.b*st.b)})}`)
    ];
    return stepsHTML(lines);
  },
  reset: ex1.reset
};

const ex3 = {
  id:"k-carr√©",
  title:"D√©velopper : k ¬∑ (ax ¬± b)¬≤",
  gen(){
    const k = rnd(-9,9)||1;
    const a = rnd(-9,9)||1;
    const b = Math.abs(rnd(-12,12)||2);
    const sign = choice(['+','‚àí']);
    const A=Math.abs(a), B=b;
    const exp={ a2:k*(A*A), a1:k*((sign==='+')?2*a*B:-2*a*B), a0:k*(B*B) }; // a sign√©
    return {k,a,b,sign,exp};
  },
  text(st){ return `<span class="equ">${FEQ(`${uminus(st.k)}(${axStr(st.a)} ${st.sign} ${st.b})¬≤`)}</span>`; },
  render(host, st){ renderRow(host, "D√©velopper et r√©duire :", this.text(st), "ex.  x^2 + 4x + 4", "R√©ponse (forme r√©duite)", "F ="); },
  correct(host, st){
    const ans = parsePoly($("#reponse",host).value);
    if(!ans){ $("#res",host).innerHTML="‚úò R√©ponse invalide (ex.  x^2 - 4)"; $("#res",host).className="res-ko"; return {ok:false,total:1}; }
    const ok = ans.a2===st.exp.a2 && ans.a1===st.exp.a1 && ans.a0===st.exp.a0;
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${polyToHTML(st.exp)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    const lines = buildSquareLines(st.a, st.b, st.sign, st.k, useAdvice());
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value = polyToAscii(st.exp);
  },
  printSolutionHTML(st){ return stepsHTML(buildSquareLines(st.a, st.b, st.sign, st.k, true)); },
  reset: ex1.reset
};

const ex4 = {
  id: "vf-idr",
  title: "Vrai / Faux : identit√© remarquable",

  gen(){
    const type = choice(['carre+','carre-','conj']);
    const a = rnd(-6,6) || 1;
    const b = rnd(-9,9) || 2;

    let exp, prop, answer;

    if (type === 'conj') {
      // (ax + b)(ax ‚àí b) = a^2 x^2 ‚àí b^2
      const A = Math.abs(a), B = Math.abs(b);
      exp = { a2: A*A, a1: 0, a0: -(B*B) };

      const correct = Math.random() < 0.6;
      prop = { ...exp };
      if (!correct) {
        if (Math.random() < 0.5) prop.a0 = -prop.a0;         // inverse le signe du terme constant
        else                     prop.a1 = choice([-1,1]) * rnd(1,5); // ajoute un terme x
      }
      answer = correct ? 'Vrai' : 'Faux';
    } else {
      // (ax ¬± b)^2  ‚Äî on prend a SIGN√â pour 2ab
      const s = (type === 'carre+') ? +1 : -1;
      const A = Math.abs(a), B = Math.abs(b);
      exp = {
        a2: A*A,
        a1: 2 * a * s * B,      // a sign√©, B>0
        a0: B*B
      };

      const correct = Math.random() < 0.6;
      prop = { ...exp };
      if (!correct) {
        if (Math.random() < 0.5) prop.a1 = -prop.a1;        // inverse le signe du terme x
        else                     prop.a0 += choice([-1,1]) * rnd(1,3); // petite perturbation du constant
      }
      answer = correct ? 'Vrai' : 'Faux';
    }

    return { type, a, b, exp, prop, answer };
  },

  text(st){
    if (st.type === 'conj') {
      return `<span class="equ">( ${axStr(st.a)} + ${Math.abs(st.b)} ) ( ${axStr(st.a)} ‚àí ${Math.abs(st.b)} ) = ${polyToHTML(st.prop)}</span>`;
    } else if (st.type === 'carre+') {
      return `<span class="equ">( ${axStr(st.a)} + ${Math.abs(st.b)} )<sup>2</sup> = ${polyToHTML(st.prop)}</span>`;
    } else { // carre-
      return `<span class="equ">( ${axStr(st.a)} ‚àí ${Math.abs(st.b)} )<sup>2</sup> = ${polyToHTML(st.prop)}</span>`;
    }
  },

  render(host, st){
    renderRow(host, "Dire si l‚Äô√©galit√© est vraie :", this.text(st), "Choisir Vrai / Faux", "R√©ponse", "");
    const row = host.querySelector('.row');
    const inpWrap = row.querySelector('.input-line');
    const sel = document.createElement('select'); sel.id = "reponse-vf";
    ["","Vrai","Faux"].forEach(v => sel.appendChild(new Option(v, v)));
    inpWrap.replaceWith(sel);
  },

  correct(host, st){
    const val = ($("#reponse-vf", host) || {}).value || "";
    const ok = (val === st.answer);
    $("#res", host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${st.answer})`;
    $("#res", host).className = ok ? "res-ok" : "res-ko";
    return { ok, total: 1 };
  },

  solution(host, st){
    const { type, a, b } = st;

    // LHS EXACTEMENT comme dans l‚Äô√©nonc√©
    let lhs = "";
    if (type === 'conj') {
      lhs = `( ${axStr(a)} + ${Math.abs(b)} ) ( ${axStr(a)} ‚àí ${Math.abs(b)} )`;
    } else if (type === 'carre+') {
      lhs = `( ${axStr(a)} + ${Math.abs(b)} )<sup>2</sup>`;
    } else {
      lhs = `( ${axStr(a)} ‚àí ${Math.abs(b)} )<sup>2</sup>`;
    }

    let lines = [];

    if (type === 'conj') {
      const Aterm = axStr(a);                 // A sign√© √† l‚Äôaffichage
      const Bterm = String(Math.abs(b));
      lines = [
        FEQ(lhs),
        `Formule : (A + B)(A ‚àí B) avec A = ${Aterm}, B = ${Bterm}`,
        `Or (A + B)(A ‚àí B) = A¬≤ ‚àí B¬≤`,
        FEQ(`(${Aterm})<sup>2</sup> ‚àí ${Bterm}<sup>2</sup>`),
        FEQ(`${polyToHTML({a2:Math.abs(a)*Math.abs(a), a1:0, a0:-(Math.abs(b)*Math.abs(b))})}`)
      ];
    } else {
      // M√™me m√©canique que l‚Äôexercice 3, avec buildSquareLines et gestion ‚Äúconseil / sans conseil‚Äù
      const adv = useAdvice();
      const signSym = (type === 'carre+') ? '+' : '‚àí';
      lines = buildSquareLines(a, b, signSym, null, adv);

      // 1 ≥·µâ ligne = √©nonc√© exact ; si ‚Äúconseil‚Äù & a<0 ‚Üí on ins√®re l‚Äô√©nonc√© puis la r√©√©criture
      if (adv && a < 0) { lines.unshift(FEQ(lhs)); } else { lines[0] = FEQ(lhs); }
    }

    // Conclusion : uniquement pour l‚Äôex. 4
    lines.push('Conclusion : l‚Äô√©galit√© est ' + (st.answer === 'Vrai' ? 'vraie' : 'fausse') + '.');

    $$(".hint",host).forEach(n => n.remove());
    $$(".equ-offscreen",host).forEach(n => n.remove());
    $("#res",host).innerHTML = stepsHTML(lines);
  },

  printSolutionHTML(st){
    const host = document.createElement('div');
    this.solution(host, st);
    return host.querySelector('#res')?.innerHTML || '';
  },

  reset(host){
    const sel = $("#reponse-vf",host);
    if (sel) sel.value = "";
    $("#res",host).textContent = "";
  }
};


const ex5 = {
  id:"calcul-num",
  title:"Calculer rapidement (identit√© remarquable)",
  gen(){
    const kind = choice(['square','prod']);
    const pool = [-20,-15,-12,-10,-8,-5,-4,-3,-2,-1,1,2,3,4,5,6,8,10,12,15,20,-100,100];
    if(kind==='square'){
      const a = choice(pool.filter(v=>v>0));
      const d = choice([1,2,3,4,5,6,8,10]);
      const sign = choice(['+','‚àí']);
      const val = (sign==='+'? (a+d)*(a+d) : (a-d)*(a-d));
      return {kind,sign,a,b:d,expected:val};
    }else{
      const a = choice(pool);
      const k = choice([1,2,3,4,5,6,8,10]);
      const val = a*a - k*k;
      return {kind,a,k,expected:val};
    }
  },
  text(st){
    return (st.kind==='square')
      ? `<span class="equ">( ${st.a} ${st.sign} ${st.b} )<sup>2</sup></span>`
      : `<span class="equ">( ${st.a} ‚àí ${st.k} ) ( ${st.a} + ${st.k} )</span>`;
  },
  render(host, st){
    renderRow(host, "Calculer (sans calculatrice) :", this.text(st), "ex.  2401", "R√©ponse (nombre entier)");
    const box=document.createElement('div'); box.innerHTML = squaresTableHTML(); host.appendChild(box);
  },
  correct(host, st){
    const txt = ($("#reponse",host).value||"").trim().replace(/\s+/g,'');
    if(!/^-?\d+$/.test(txt)){
      $("#res",host).innerHTML = "‚úò Entrez un entier (ex.  9801)";
      $("#res",host).className = "res-ko";
      return {ok:false,total:1};
    }
    const ok = (parseInt(txt,10)===st.expected);
    $("#res",host).innerHTML = ok ? "‚úî" : `‚úò (attendu : ${st.expected})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const lines=[];
    if(st.kind==='square'){
      const A = st.a, B = st.b;
      const sum = st.sign==='+' ? (A+B) : (A-B);
      const pow = v => v<0 ? `(${UMINUS}${Math.abs(v)})<sup>2</sup>` : `${v}<sup>2</sup>`;
      lines.push(FEQ(`( ${A} ${st.sign} ${B} )¬≤`));
      lines.push(FEQ(`${pow(sum)}`));
      lines.push(FEQ(`${String(sum*sum)}`));
    }else{
      const A = st.a, B = st.k;
      const p2 = n => (n<0?`(${n})`:`${n}`)+'<sup>2</sup>';
      lines.push(FEQ(`( ${A} ‚àí ${B} ) ( ${A} + ${B} )`));
      lines.push(FEQ(`${p2(A)} ‚àí ${p2(B)}`));
      lines.push(FEQ(`${A*A} ‚àí ${B*B}`));
      lines.push(FEQ(`${String(st.expected)}`));
    }
    $$(".hint",host).forEach(n=>n.remove()); $$(".equ-offscreen",host).forEach(n=>n.remove());
    $("#res",host).innerHTML = stepsHTML(lines);
    $("#reponse",host).value = String(st.expected);
  },
  printSolutionHTML(st){
    if(st.kind==='square'){
      const A=st.a, B=st.b, sum=(st.sign==='+'?A+B:A-B);
      const pow = v => v<0 ? `(${UMINUS}${Math.abs(v)})<sup>2</sup>` : `${v}<sup>2</sup>`;
      return stepsHTML([FEQ(`( ${A} ${st.sign} ${B} )¬≤`), FEQ(`${pow(sum)}`), FEQ(`${ sum*sum }`)]);
    }else{
      const A=st.a, K=st.k;
      const p2 = n => (n<0?`(${n})`:`${n}`)+'<sup>2</sup>';
      return stepsHTML([FEQ(`( ${A} ‚àí ${K} ) ( ${A} + ${K} )`), FEQ(`${p2(A)} ‚àí ${p2(K)}`), FEQ(`${A*A} ‚àí ${K*K}`), FEQ(`${A*A - K*K}`)]);
    }
  },
  reset: ex1.reset
};

/* ===== Registre & moteur ===== */
const REGISTRY = [ex1, ex2, ex3, ex4, ex5];
window.REGISTRY = REGISTRY;

let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function renderRow(host, consigneText, htmlEq, placeholder="ex.  x^2 + 4x + 4", label='R√©ponse (forme r√©duite)', prefixLabel=""){
  host.innerHTML="";
  const hint=document.createElement('p'); hint.className="hint"; hint.textContent=`Consigne : ${consigneText}`; host.appendChild(hint);
  const off=document.createElement('div'); off.className="equ-offscreen";
  off.innerHTML=`<div class="consigne">${consigneText}</div><div class="equation">${htmlEq}</div>`;
  host.appendChild(off);

  const row=document.createElement("div"); row.className="row";
  const lab=document.createElement("div"); lab.className="col-label equ"; lab.innerHTML=htmlEq; row.appendChild(lab);

  const inpWrap=document.createElement("div"); inpWrap.className="input-line";
  if(prefixLabel){ const pre=document.createElement("span"); pre.className="input-prefix"; pre.innerHTML=prefixLabel.replace(' = ','&nbsp;=&nbsp;'); inpWrap.appendChild(pre); }
  const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder=placeholder; inpWrap.appendChild(inp);
  row.appendChild(inpWrap);

  const res=document.createElement("div"); res.id="res"; row.appendChild(res);
  host.appendChild(row);
  return {inp,res};
}

function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st=def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);
  const inp = $("#reponse",host) || $("#reponse-vf",host); if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def){ def.reset(host); }
}

// === Choix d'affichage de la solution pour (-a ¬± b)¬≤ ===
function useAdvice(){
  const sel = document.getElementById('mode-conseil');
  return !sel || sel.value !== 'nocons';
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement("option"); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  // S√©lecteur "solution avec/sans conseil" ‚Äî sous le bouton Solution mais sans d√©placer les autres boutons
  const wrap = document.getElementById('sol-wrap');
  const modeConseil = document.createElement('select');
  modeConseil.id = 'mode-conseil';
  modeConseil.title = "Mode d'affichage de la solution";
  modeConseil.innerHTML = `
    <option value="cons">Solution (avec conseil)</option>
    <option value="nocons">Solution (sans conseil)</option>
  `;
  wrap.appendChild(modeConseil);

  sel.value = REGISTRY[0].id;
  buildOne(); updateScore();
  document.addEventListener('keydown', function(ev){
    if(ev.key === 'Enter'){
      const a = document.activeElement;
      if(a && a.id === 'reponse'){
        ev.preventDefault();
        try{ check(); }catch(_){}
      }
    }
  });

  // PDF : ins√®re l‚Äôoutil au-dessus du clavier, capture consigne+√©nonc√© et corrig√©
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde ‚Äì Chapitre 0 ‚Äì Calculs ‚Äì Identit√©s remarquables',
      max: 50,
      mountAfterSelector: '.card.small',
      beforeRender(def, st, withSolutions){
        try{
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          def.render(tmp, st);
          if(!withSolutions){
            const equ = tmp.querySelector('.equ-offscreen');
            if(equ) return equ.outerHTML;  // consigne + √©quation
            return tmp.innerHTML;
          }else{
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            const res = tmp.querySelector('#res');
            if(res) return res.innerHTML;   // steps (par d√©faut avec conseils)
            return tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }

  // Normalisation Unicode (‚àí, √ó ‚Ä¶)
  if (window.DevRules && DevRules.attachCleaner) DevRules.attachCleaner();
});
})();
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Prend V√©rifier & Solution (prioritaires sur mobile)
      ['V√©rifier','Solution'].forEach(txt=>{
        const src = [...actions.querySelectorAll('button, a')].find(b=>b.textContent.trim().toLowerCase().includes(txt.toLowerCase()));
        if(src){
          const clone = src.cloneNode(true); clone.classList.add('btn');
          // √©vite double id
          clone.removeAttribute('id');
          bar.appendChild(clone);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s‚Äôouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>