<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde ‚Äì Chapitre 1 ‚Äì √âquations produit (produit nul) ‚Äì Exercices (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:nowrap;gap:8px;align-items:center;overflow-x:auto}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#666}

/* Grille : √©nonc√© + saisie en 1√®re ligne, corrig√© pleine largeur dessous */
.row{
  display:grid;
  grid-template-columns:1fr minmax(260px,340px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px;
  align-items:start;
}
.row .col-label{grid-area:lab}
.row input[type=text]{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}

/* Bloc √©tapes : une √©galit√© par ligne, √©viter les retours qui cassent le '=' */
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0; white-space:nowrap}

/* === Bloc .equ-offscreen : ENONC√â complet (consigne + √©quation) pour le PDF === */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;} /* pas de doublon de consigne */
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
}
.equ-offscreen .consigne{margin-bottom:6px;font-weight:600}

/* ‚ÄúTableau invisible‚Äù pour parall√©liser les facteurs */
.proof-table{display:grid;column-gap:14px;row-gap:0;margin-top:.4rem;white-space:nowrap}
.proof-table .cell{align-self:start}
.proof-table .ou{align-self:start;text-align:center;color:#555;white-space:nowrap;padding:.35rem .5rem}
</style>

<!-- MathJax v3 (LaTeX) -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Chapitre 1 ‚Äì <strong>√âquations produit (produit nul)</strong></h1>
  </div>

  <div class="wrap">
    <!-- Barre principale -->
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn" title="G√©n√®re un nouvel √©nonc√©">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn" title="V√©rifie ta r√©ponse">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn" title="Affiche une solution d√©taill√©e">üí° Solution</button>
      <button id="btn-reset" class="btn" title="R√©initialise la saisie et le score">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <!-- Saisie & indications -->
    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:8px 0 0 18px">
        <li><strong>Format impos√©</strong> : <code class="code">S = { ‚Ä¶ }</code> avec <strong>accolades</strong>. Exemples :
          <code class="code">S = { 2 ; ‚àí3/4 }</code>, <code class="code">S={0}</code>.</li>
        <li>S√©parateurs internes accept√©s : <code class="code">;</code>, <code class="code">,</code>, espace, <code class="code">ou</code>. On tol√®re <code>x=‚Ä¶</code> dans les √©l√©ments.</li>
      </ul>
    </div>

    <!-- Clavier math, centr√© -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Librairies align√©es sur v8 -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){'use strict';
/* ===== Utils ===== */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ===== MathJax typeset helper ===== */
function typesetAll(root){
  const run = () => MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  if (window.MathJax && MathJax.startup && MathJax.startup.promise) {
    MathJax.startup.promise.then(run);
  } else {
    const t = setInterval(()=>{
      if (window.MathJax && MathJax.startup && MathJax.typesetPromise){ clearInterval(t); run(); }
    }, 60);
  }
}
const L = s => `\\(${s}\\)`;

/* ===== Arithm√©tique rationnelle ===== */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function norm(p,q){
  if(q===0) throw new Error("denominator 0");
  let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; }
  return {p,q};
}
function addR(A,B){ return norm(A.p*B.q + B.p*A.q, A.q*B.q); }
function subR(A,B){ return norm(A.p*B.q - B.p*A.q, A.q*B.q); }
function mulR(A,B){ return norm(A.p*B.p, A.q*B.q); }
function divR(A,B){ if(B.p===0) throw new Error("div by 0"); return norm(A.p*B.q, A.q*B.p); }
function isZero(R){ return R.p===0; }
function toNumber(R){ return R.p / R.q; }
function makeR(p,q){ return norm(p,q||1); }
function absR(R){ return makeR(Math.abs(R.p), R.q); }
function quotientRaw(N,D){ let num = N.p * D.q; let den = N.q * D.p; if(den<0){ num=-num; den=-den; } return {p:num,q:den}; }
function needsSimplify(fr){ return gcd(Math.abs(fr.p), Math.abs(fr.q)) > 1; }

/* ===== Affichages LaTeX ===== */
function fracLatex(p,q){
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg?'-':'')+String(p);
  return (neg?'-':'')+`\\frac{${p}}{${q}}`;
}
function fracOf(numLatex, denLatex){ return `\\frac{${numLatex}}{${denLatex}}`; }

function isOne(R){ return R.q===1 && R.p===1; }
function isNegOne(R){ return R.q===1 && R.p===-1; }

function fmtCoeffXLatex(A){ // A¬∑x
  if(isOne(A)) return `x`;
  if(isNegOne(A)) return `-x`;
  const s = fracLatex(A.p, A.q).replace(/^-/,'-');
  return `${s}x`;
}
function fmtConstLatex(B){
  if(B.q===1) return String(B.p);
  return fracLatex(B.p,B.q);
}
function fmtSignedConstLatex(B){
  if(isZero(B)) return "";
  const abs = absR(B);
  const core = fmtConstLatex(abs);
  return (B.p>0? " + " : " - ") + core.replace(/^-/,'');
}
function sideLatex(A,B){ // A‚â†0 garanti
  return fmtCoeffXLatex(A) + fmtSignedConstLatex(B);
}

// Affiche U ‚àí V (sans calcul), g√®re bien U=0 ou V<0
function showDiffLatex(U, V){
  if (isZero(V)) return fmtConstLatex(U);              // U - 0 -> U
  if (isZero(U)) {
    if (V.p < 0) return fmtConstLatex(absR(V));        // 0 - (-v) -> +v
    return `- ${fmtConstLatex(V)}`;                    // 0 - v -> -v
  }
  if (V.p < 0) return fmtConstLatex(U) + " + " + fmtConstLatex(absR(V));
  return fmtConstLatex(U) + " - " + fmtConstLatex(V);
}

/* ‚Äî Normalisation + d√©doublonnage des √©tapes ‚Äî */
function normalizeSigns(txt){
  return txt
    .replace(/\+\s*-/g, ' - ')
    .replace(/-\s*\+/g, ' - ')
    .replace(/-\s*-/g, ' + ')
    .replace(/\+\s*\+/g, ' + ')
    .replace(/\s{2,}/g, ' ');
}
function ensureArray(x){ return Array.isArray(x) ? x : []; }
function stepKey(s){ return String(s).replace(/\s+/g,' ').replace(/^\\\(|\\\)$/g,'').trim(); }
function dedupeSteps(list){
  const out=[]; for(const s of list){
    if(!out.length || stepKey(out[out.length-1])!==stepKey(s)) out.push(s);
  } return out;
}
function finalizeSteps(steps){
  steps = ensureArray(steps);
  return dedupeSteps(steps.map(normalizeSigns));
}

/* √âtapes p√©dagogiques communes :
   - si A est fractionnaire, ins√©rer x = K √ó (d/n) + phrase
   - si A < 0, ins√©rer x = K / (‚àía) joliment */
function insertCoeffHints(steps, A, K){
  if (!Array.isArray(steps)) return;

  const KisZero = isZero(K);
  const firstXeq = steps.findIndex(s => /^x\s*=/.test(stepKey(s)));
  let insertIndex = (firstXeq >= 0) ? firstXeq : steps.length;

  // 1) Si A est fractionnaire ‚Üí on montre "multiplier par l'inverse" (une seule fois)
  if (!KisZero && A.q !== 1) {
    const inv = norm(A.q, A.p);            // inverse dA/nA
    const invRaw = fracLatex(inv.p, inv.q);
    const invL   = (inv.p < 0) ? `\\left(${invRaw}\\right)` : invRaw;  // (‚àía/b)
    steps.splice(
      insertIndex, 0,
      `${L(`x = ${fmtConstLatex(K)} \\times ${invL}`)} ‚Äî Diviser par un nombre revient √† multiplier par son inverse.`
    );

  // 2) Sinon, si A est un entier n√©gatif ‚Üí on montre "x = K / (‚àía)"
  } else if (!KisZero && A.p < 0) {
    steps.splice(insertIndex, 0, L(`x = ${fracOf(fmtConstLatex(K), fmtConstLatex(A))}`));
  }
}

/* ===== Parsing / comparaison des r√©ponses ===== */
function parseNumberOrFrac(str){
  if(!str) return null;
  let s = str.trim().replace(/\u2212/g,'-');
  if(/^[-+]?(\d+([.,]\d+)?|\d*[.,]\d+)$/.test(s)){ s=s.replace(',','.'); return parseFloat(s); }
  const m = s.match(/^([-+]?\d+)\s*\/\s*([-+]?\d+)$/);
  if(m){ const p = parseInt(m[1],10), q = parseInt(m[2],10); if(q===0) return null; return p/q; }
  return null;
}
function sameNumber(a,b){ const na=parseFloat(a), nb=parseFloat(b); if(Number.isNaN(na)||Number.isNaN(nb)) return false; return Math.abs(na-nb)<1e-9; }
function parseSolutionsStrict(str){
  if(!str) return {okFormat:false, values:[]};
  const full = str.trim();
  const m = full.match(/^S\s*=\s*\{([\s\S]*)\}$/i);
  if(!m) return {okFormat:false, values:[]}; // exige S={...}
  let inner = m[1].trim();
  inner = inner
    .replace(/\bou\b/gi,';')
    .replace(/,/g,';')
    .replace(/\s*;\s*/g,';')
    .replace(/\s+/g,' ')
    .replace(/x\s*=\s*/gi,'')
    .replace(/\s*\/\s*/g,'/'); // pour les fractions
  const parts = inner.split(/[;\s]+/).filter(Boolean);
  const vals=[];
  for(const tok of parts){
    const v = parseNumberOrFrac(tok);
    if(v!==null) vals.push(v);
  }
  const uniq=[];
  vals.forEach(v=>{ if(!uniq.some(u=>sameNumber(u,v))) uniq.push(v); });
  return {okFormat:true, values:uniq.sort((a,b)=>a-b)};
}
function cmpSets(ans, exp){
  if(ans.length!==exp.length) return false;
  const A=[...ans].sort((x,y)=>x-y), B=[...exp].sort((x,y)=>x-y);
  for(let i=0;i<A.length;i++){ if(!sameNumber(A[i],B[i])) return false; }
  return true;
}

/* ===== Rendu commun (structure v8) ===== */
function renderRow(host, latexEq){
  host.innerHTML="";
  // Consigne visible
  const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : R√©soudre l‚Äô√©quation."; host.appendChild(hint);
  // Bloc √©nonc√© pour PDF (consigne + √©quation)
  const off=document.createElement('div'); off.className="equ-offscreen";
  off.innerHTML='<div class="consigne">R√©soudre l‚Äô√©quation.</div>' + '<div class="equation">'+L(latexEq)+'</div>';
  host.appendChild(off);

  const row=document.createElement("div"); row.className="row";
  const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(latexEq); row.appendChild(lab);
  const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder=""; row.appendChild(inp);
  const res=document.createElement("div"); res.id="res"; row.appendChild(res);
  host.appendChild(row);
  typesetAll(host);
  return {inp, res};
}

/* ===== √âtapes LaTeX pour un facteur (ax+b)=0 ===== */
function factorStepsHTML(F){
  const isZeroNum = (F.raw.p === 0); // num√©rateur 0 ‚Üí solution x = 0

  let steps = [
    L(`${sideLatex(F.A,F.B)} = 0`),
    L(`${fmtCoeffXLatex(F.A)} = ${fmtConstLatex(F.rhs)}`)
  ];

  if (isZeroNum) {
    // On ne montre ni la fraction 0/q, ni les hints d'inversion de coefficient
    steps.push(L(`x = 0`));
  } else {
    steps.push(L(`x = ${fracLatex(F.raw.p, F.raw.q)}`));
    insertCoeffHints(steps, F.A, F.rhs);
    if (needsSimplify(F.raw)) steps.push(L(`x = ${fmtConstLatex(F.S)}`));
  }

  steps = finalizeSteps(steps);
const box = document.createElement('div');
box.className = 'steps';
steps.forEach(t => {
  const d = document.createElement('div');
  d.className = 'step';
  d.innerHTML = t;
  box.appendChild(d);
});
return box.outerHTML;
}

function factorGridHTML(fs){
  const cols = [];
  for(let i=0;i<fs.length;i++){ cols.push('1fr'); if(i<fs.length-1) cols.push('auto'); }
  let html = `<div class="proof-table" style="grid-template-columns:${cols.join(' ')}">`;
  for(let i=0;i<fs.length;i++){
    html += `<div class="cell">${factorStepsHTML(fs[i])}</div>`;
    if(i<fs.length-1) html += `<div class="ou">ou</div>`;
  }
  html += `</div>`;
  return html;
}

/* ===== G√©n√©rateurs d‚Äôexercices ===== */
function rintNZ(min,max){ let x=0; while(x===0){ x=rnd(min,max); } return x; }
function rint(min,max){ return rnd(min,max); }
function genLinearInt(){
  const a=rintNZ(-9,9), b=rint(-9,9);
  const A=makeR(a,1), B=makeR(b,1);
  const rhs = negR(B);
  const S = divR(rhs, A);
  const raw = quotientRaw(rhs, A);
  return {A,B,rhs,S,raw};
}
function randRat(opts={allowZero:true}){
  const isFrac = Math.random()<0.5;
  if(!isFrac){
    let v = opts.allowZero ? rint(-9,9) : rintNZ(-9,9);
    return makeR(v,1);
  }
  const d = choice([2,3,4,5,6]);
  const n = opts.allowZero ? rint(-9,9) : rintNZ(-9,9);
  return makeR(n,d);
}
function genLinearRat(){
  let A = randRat({allowZero:false});
  const B = randRat({allowZero:true});
  const rhs = negR(B);
  const S = divR(rhs, A);
  const raw = quotientRaw(rhs, A);
  return {A,B,rhs,S,raw};
}
function negR(R){ return makeR(-R.p, R.q); }
/* === Unicit√© des facteurs (ax+b) === */
function eqR(U,V){ return U.p===V.p && U.q===V.q; }       // rationnels normalis√©s
function sameFactor(F,G){ return eqR(F.A,G.A) && eqR(F.B,G.B); }

function genDistinct(fgen, n){
  const out=[];
  while(out.length < n){
    const f = fgen();
    if(!out.some(g=>sameFactor(f,g))) out.push(f);
  }
  return out;
}
// Tri croissant et d√©doublonnage de rationnels {p,q} (normalis√©s)
function sortUniqueRationals(Rs){
  const uniq=[];
  Rs.forEach(R=>{
    if(!uniq.some(U => U.p*R.q === R.p*U.q)) uniq.push(R); // m√™me valeur
  });
  uniq.sort((A,B)=> A.p*B.q - B.p*A.q); // tri par valeur
  return uniq;
}
// Ne pas pr√©-remplir la saisie quand on affiche la solution
const PREFILL_ON_SOLUTION = false;

function maybePrefill(host, text){
  if (!PREFILL_ON_SOLUTION) return;
  const inp = $("#reponse", host);
  if (inp) inp.value = text;
}

/* ===== Exercices ===== */
const ex1 = {
  id:"prod2_int",
  title:"(ax + b)(cx + d) = 0 (coefficients entiers)",
gen(){
  const [f1, f2] = genDistinct(genLinearInt, 2);
  return {f1, f2};
},
  text(st){ return `\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)\\left(${sideLatex(st.f2.A,st.f2.B)}\\right) = 0`; },
  render(host, st){ renderRow(host, this.text(st)); },
  correct(host, st){
    const exp=[toNumber(st.f1.S), toNumber(st.f2.S)];
    const expU=[]; exp.forEach(v=>{ if(!expU.some(u=>sameNumber(u,v))) expU.push(v); });
    const parsed = (function(v){
      if(!v) return {okFormat:false, values:[]};
      const m = v.trim().match(/^S\s*=\s*\{([\s\S]*)\}$/i);
      if(!m) return {okFormat:false, values:[]};
      let inner = m[1].trim()
        .replace(/\bou\b/gi,';')
        .replace(/,/g,';')
        .replace(/\s*;\s*/g,';')
        .replace(/\s+/g,' ')
        .replace(/x\s*=\s*/gi,'')
        .replace(/\s*\/\s*/g,'/');
      const parts = inner.split(/[;\s]+/).filter(Boolean);
      const vals=[]; for(const t of parts){ const pv = parseNumberOrFrac(t); if(pv!==null) vals.push(pv); }
      const uniq=[]; vals.forEach(v=>{ if(!uniq.some(u=>sameNumber(u,v))) uniq.push(v); });
      return {okFormat:true, values:uniq.sort((a,b)=>a-b)};
    })($("#reponse",host).value);
    if(!parsed.okFormat){
      $("#res",host).innerHTML = "‚úò (format attendu : S = { ‚Ä¶ })";
      $("#res",host).className = "res-ko";
      return {ok:false,total:1};
    }
    const ok = cmpSets(parsed.values, expU);
    const want = `S = { ${expU.map(v=>Number.isInteger(v)? String(v).replace(/-/g,'‚àí') : v.toString()).join(' ; ')} }`;
    $("#res",host).innerHTML = ok? "‚úî" : `‚úò (attendu : ${want})`;
    $("#res",host).className = ok? "res-ok":"res-ko";
    return {ok,total:1};
  },
solution(host, st){
  $$(".hint",host).forEach(n=>n.remove());
  $$(".equ-offscreen",host).forEach(n=>n.remove());

  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  const sText  = `S = { ${sols.map(R=> R.q===1? String(R.p) : `${R.p}/${R.q}`).join(' ; ')} }`;

  const html = [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");

  $("#res",host).innerHTML = html;
maybePrefill(host, sText);
  typesetAll($("#res",host));
},

printSolutionHTML(st){
  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  return [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");
},

  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

const ex2 = {
  id:"k_prod2",
  title:"k(ax + b)(cx + d) = 0 (k ‚â† 0)",
gen(){
  let k;
  do { k = rint(-6, 6); } while (k === 0 || k === 1); // ‚üµ exclut k=0 et k=1

  // si tu as d√©j√† les helpers de non-duplication
  const [f1, f2] = genDistinct(genLinearInt, 2);
  return { k, f1, f2 };

  // (fallback sans genDistinct)
  // const f1 = genLinearInt(); let f2; do { f2 = genLinearInt(); } while (sameFactor(f1, f2));
  // return { k, f1, f2 };
},

text(st){
  return `${st.k}\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)\\left(${sideLatex(st.f2.A,st.f2.B)}\\right) = 0`;
},
  render: ex1.render,
  correct: ex1.correct,
solution(host, st){
  $$(".hint",host).forEach(n=>n.remove());
  $$(".equ-offscreen",host).forEach(n=>n.remove());

  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  const sText  = `S = { ${sols.map(R=> R.q===1? String(R.p) : `${R.p}/${R.q}`).join(' ; ')} }`;

  const html = [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step"><span class="hint">Comme ${st.k} ‚â† 0, le facteur ${st.k} n‚Äôinfluence pas l‚Äô√©galit√© √† 0.</span></div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");

  $("#res",host).innerHTML = html;
maybePrefill(host, sText);
  typesetAll($("#res",host));
},

printSolutionHTML(st){
  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  return [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step"><span class="hint">Comme ${st.k} ‚â† 0, le facteur ${st.k} n‚Äôinfluence pas l‚Äô√©galit√© √† 0.</span></div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");
},

  reset: ex1.reset
};

const ex3 = {
  id:"prod3_int",
  title:"(ax + b)(cx + d)(ex + f) = 0 (coefficients entiers)",
gen(){
  const [f1, f2, f3] = genDistinct(genLinearInt, 3);
  return {f1, f2, f3};
},
  text(st){ return `\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)\\left(${sideLatex(st.f2.A,st.f2.B)}\\right)\\left(${sideLatex(st.f3.A,st.f3.B)}\\right) = 0`; },
  render: ex1.render,
  correct(host, st){
    const exp=[toNumber(st.f1.S), toNumber(st.f2.S), toNumber(st.f3.S)];
    const expU=[]; exp.forEach(v=>{ if(!expU.some(u=>sameNumber(u,v))) expU.push(v); });
    const parsed = parseSolutionsStrict($("#reponse",host).value);
    if(!parsed.okFormat){
      $("#res",host).innerHTML = "‚úò (format attendu : S = { ‚Ä¶ })";
      $("#res",host).className = "res-ko";
      return {ok:false,total:1};
    }
    const ok=cmpSets(parsed.values, expU);
    const want = `S = { ${expU.map(v=>Number.isInteger(v)? String(v).replace(/-/g,'‚àí') : v.toString()).join(' ; ')} }`;
    $("#res",host).innerHTML = ok? "‚úî" : `‚úò (attendu : ${want})`;
    $("#res",host).className = ok? "res-ok":"res-ko";
    return {ok,total:1};
  },
solution(host, st){
  $$(".hint",host).forEach(n=>n.remove());
  $$(".equ-offscreen",host).forEach(n=>n.remove());

  const sols = sortUniqueRationals([st.f1.S, st.f2.S, st.f3.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  const sText  = `S = { ${sols.map(R=> R.q===1? String(R.p) : `${R.p}/${R.q}`).join(' ; ')} }`;

  const html = [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    factorGridHTML([st.f1, st.f2, st.f3]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");

  $("#res",host).innerHTML = html;
maybePrefill(host, sText);
  typesetAll($("#res",host));
},

printSolutionHTML(st){
  const sols = sortUniqueRationals([st.f1.S, st.f2.S, st.f3.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  return [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    factorGridHTML([st.f1, st.f2, st.f3]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");
},

  reset: ex1.reset
};

const ex4 = {
  id:"prod2_frac",
  title:"(ax + b)(cx + d) = 0 (coefficients fractionnaires possibles)",
gen(){
  const [f1, f2] = genDistinct(genLinearRat, 2);
  return {f1, f2};
},
  text(st){ return `\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)\\left(${sideLatex(st.f2.A,st.f2.B)}\\right) = 0`; },
  render: ex1.render,
  correct: ex1.correct,
solution(host, st){
  $$(".hint",host).forEach(n=>n.remove());
  $$(".equ-offscreen",host).forEach(n=>n.remove());

  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  const sText  = `S = { ${sols.map(R=> R.q===1? String(R.p) : `${R.p}/${R.q}`).join(' ; ')} }`;

  const html = [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");

  $("#res",host).innerHTML = html;
maybePrefill(host, sText);
  typesetAll($("#res",host));
},

printSolutionHTML(st){
  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  return [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");
},

  reset: ex1.reset
};

const ex5 = {
  id:"square_prod",
  title:"(ax + b)¬≤ (cx + d) = 0",
gen(){
  const f1 = genLinearInt();
  let f2;
  do { f2 = genLinearInt(); } while(sameFactor(f1, f2));
  return {f1, f2};
},
  text(st){ return `\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)^{2}\\left(${sideLatex(st.f2.A,st.f2.B)}\\right) = 0`; },
  render: ex1.render,
  correct: ex1.correct,
solution(host, st){
  $$(".hint",host).forEach(n=>n.remove());
  $$(".equ-offscreen",host).forEach(n=>n.remove());

  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  const sText  = `S = { ${sols.map(R=> R.q===1? String(R.p) : `${R.p}/${R.q}`).join(' ; ')} }`;

  const html = [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    `<div class="steps"><div class="step">${L(`\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)^{2} = 0 \\iff ${sideLatex(st.f1.A,st.f1.B)} = 0`)}</div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");

  $("#res",host).innerHTML = html;
maybePrefill(host, sText);
  typesetAll($("#res",host));
},

printSolutionHTML(st){
  const sols = sortUniqueRationals([st.f1.S, st.f2.S]);
  const sLatex = L(`S = \\{ ${sols.map(fmtConstLatex).join(' \\; ; \\; ')} \\}`);
  return [
    `<div class="steps"><div class="step">${L(this.text(st))}</div><div class="step">Un produit est nul si et seulement si l‚Äôun des facteurs est nul.</div></div>`,
    `<div class="steps"><div class="step">${L(`\\left(${sideLatex(st.f1.A,st.f1.B)}\\right)^{2} = 0 \\iff ${sideLatex(st.f1.A,st.f1.B)} = 0`)}</div></div>`,
    factorGridHTML([st.f1, st.f2]),
    `<div class="steps"><div class="step">${sLatex}</div></div>`
  ].join("");
},

  reset: ex1.reset
};

const REGISTRY = [ex1, ex2, ex3, ex4, ex5];
window.REGISTRY = REGISTRY; // pour exo-pdf-kit

/* ===== Score & actions ===== */
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function buildOne(){
  const sel=$("#exo-select");
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const st=def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);
  const inp = $("#reponse",host); if(inp) inp.focus();
  typesetAll(host);
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def){ const inp=$("#reponse",host); if(inp) inp.value=""; const res=$("#res",host); if(res) res.textContent=""; }
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement("option"); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  sel.value = REGISTRY[0].id;
  buildOne(); updateScore();

  // Initialisation PDF (version ‚Äúmultiplicatif‚Äù avec hook de capture)
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde ‚Äì Chapitre 1 ‚Äì √âquations produit (produit nul)',
      max: 50,
      mountAfterSelector: '.card.small', // au-dessus du clavier
      beforeRender(def, st, withSolutions){
        try{
          // re-render offscreen pour r√©cup√©rer l'√©nonc√© (consigne + √©quation) et le corrig√©
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          def.render(tmp, st);
          if(!withSolutions){
            const equ = tmp.querySelector('.equ-offscreen');
            if(equ) return equ.outerHTML;
            return tmp.innerHTML;
          }else{
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            const steps = tmp.querySelector('#res');
            if(steps) return steps.innerHTML;
            return tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }

  // Activer la normalisation Unicode des signes (‚àí, √ó‚Ä¶) apr√®s chargement des libs
  if (window.DevRules && DevRules.attachCleaner) DevRules.attachCleaner();
});
})();
</script>

<script>
/* === Confort mobile, clavier, etc. (inchang√©) === */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
