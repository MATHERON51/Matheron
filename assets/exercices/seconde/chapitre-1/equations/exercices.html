<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde – Chapitre 1 – Équations (1er degré) – Exercices (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:nowrap;gap:8px;align-items:center;overflow-x:auto}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#111}

/* grille : énoncé + saisie en ligne 1, corrigé plein largeur en dessous */
.row{
  display:grid;
  grid-template-columns:1fr minmax(240px,320px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px;
  align-items:start;
}
.row .col-label{grid-area:lab}
.row input[type=text]{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}

/* Bloc étapes : lignes simples, éviter les retours qui cassent l'alignement du signe = */
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0; white-space:nowrap}

/* === Bloc .equ-offscreen : ENONCÉ complet (consigne + équation) pour le PDF === */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;} /* pas de doublon de consigne */
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
}
.equ-offscreen .consigne{margin-bottom:6px;font-weight:600}
</style>

<!-- MathJax v3 -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: {
      skipHtmlTags: ['script','noscript','style','textarea']
    },
    chtml: { matchFontHeight: false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde – Chapitre 1 – <strong>Équations (1er degré)</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Saisie & réponses acceptées :</strong>
      <ul style="margin:8px 0 0 18px">
        <li>Tu peux écrire <code class="code">x = 3</code> ou simplement <code class="code">3</code>. Les décimaux acceptent <code class="code">,</code> ou <code class="code">.</code>.</li>
        <li>Les fractions se tapent <code class="code">a/b</code> et s’affichent en vraies fractions (LaTeX) dans les énoncés et solutions.</li>
      </ul>
    </div>

    <!-- Clavier math, centré -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>
  </div>

<!-- Librairies partagées -->
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>

<script>
(function(){'use strict';
/* ===== util DOM ===== */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ===== MathJax typeset helper ===== */
function typesetAll(root){
  const run = () => MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  if (window.MathJax && MathJax.startup && MathJax.startup.promise) {
    MathJax.startup.promise.then(run);
  } else {
    const t = setInterval(()=>{
      if (window.MathJax && MathJax.startup && MathJax.typesetPromise){ clearInterval(t); run(); }
    }, 60);
  }
}
const L = s => `\\(${s}\\)`;

/* ===== Arithmétique rationnelle ===== */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function norm(p,q){
  if(q===0) throw new Error("denominator 0");
  let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; }
  return {p,q};
}
function addR(A,B){ return norm(A.p*B.q + B.p*A.q, A.q*B.q); }
function subR(A,B){ return norm(A.p*B.q - B.p*A.q, A.q*B.q); }
function mulR(A,B){ return norm(A.p*B.p, A.q*B.q); }
function divR(A,B){ if(B.p===0) throw new Error("div by 0"); return norm(A.p*B.q, A.q*B.p); }
function isZero(R){
  // tolère undefined / null / nombres natifs
  if (R == null) return false;
  if (typeof R === 'number') return Math.abs(R) < 1e-12;
  return typeof R.p === 'number' ? (R.p === 0) : false;
}
function toNumber(R){ return R.p / R.q; }
function makeR(p,q){ return norm(p,q||1); }
function absR(R){ return makeR(Math.abs(R.p), R.q); }

/* ===== Affichages LaTeX ===== */
function fracLatex(p,q){
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg?'-':'')+String(p);
  return (neg?'-':'')+`\\frac{${p}}{${q}}`;
}
function fracOf(numLatex, denLatex){ return `\\frac{${numLatex}}{${denLatex}}`; }

function isOne(R){ return R.q===1 && R.p===1; }
function isNegOne(R){ return R.q===1 && R.p===-1; }

function fmtCoeffXLatex(A){
  if(isOne(A)) return `x`;
  if(isNegOne(A)) return `-x`;
  const s = fracLatex(A.p, A.q).replace(/^-/,'-');
  return `${s}x`;
}
function fmtConstLatex(B){ return fracLatex(B.p,B.q); }
function fmtSignedConstLatex(B){
  if(isZero(B)) return "";
  const abs = absR(B);
  const core = fmtConstLatex(abs);
  return (B.p>0? " + " : " - ") + core.replace(/^-/,'');
}
function sideLatex(A,B){ return fmtCoeffXLatex(A) + fmtSignedConstLatex(B); }

// Affiche U − V (sans calcul), gère bien U=0 ou V<0
function showDiffLatex(U, V){
  if (isZero(V)) return fmtConstLatex(U);              // U - 0 -> U
  if (isZero(U)) {
    if (V.p < 0) return fmtConstLatex(absR(V));        // 0 - (-v) -> +v
    return `- ${fmtConstLatex(V)}`;                    // 0 - v -> -v
  }
  if (V.p < 0) return fmtConstLatex(U) + " + " + fmtConstLatex(absR(V)); // U - (-v) -> U + v
  return fmtConstLatex(U) + " - " + fmtConstLatex(V);  // U - v
}

function quotientRaw(N,D){
  let num = N.p * D.q;
  let den = N.q * D.p;
  if(den<0){ num = -num; den = -den; }
  return {p:num, q:den};
}
function needsSimplify(fr){
  const g = gcd(Math.abs(fr.p), Math.abs(fr.q));
  return g > 1;
}

/* — Normalisation + dédoublonnage des étapes — */
function normalizeSigns(txt){
  return txt
    .replace(/\+\s*-/g, ' - ')
    .replace(/-\s*\+/g, ' - ')
    .replace(/-\s*-/g, ' + ')
    .replace(/\+\s*\+/g, ' + ')
    .replace(/\s{2,}/g, ' ');
}
function ensureArray(x){ return Array.isArray(x) ? x : []; }

function stepKey(s){
  return String(s).replace(/\s+/g,' ').replace(/^\\\(|\\\)$/g,'').trim();
}
function dedupeSteps(list){
  const out=[]; for(const s of list){
    if(!out.length || stepKey(out[out.length-1])!==stepKey(s)) out.push(s);
  } return out;
}
function finalizeSteps(steps){
  steps = ensureArray(steps);
  return dedupeSteps(steps.map(normalizeSigns));
}

function insertCoeffHints(steps, A, K){
  if (!Array.isArray(steps)) return;       // <<--- garde-fou

  const KisZero = isZero(K);
  const firstXeq = steps.findIndex(s => /^x\s*=/.test(stepKey(s)));
  let insertIndex = (firstXeq >= 0) ? firstXeq : steps.length;

  if (!KisZero && A.q !== 1) {
    const inv = norm(A.q, A.p);
    const invL = fracLatex(inv.p, inv.q);
    steps.splice(
      insertIndex++, 0,
      `${L(`x = ${fmtConstLatex(K)} \\times ${invL}`)} — Diviser par un nombre revient à multiplier par son inverse.`
    );
  }
  if (!KisZero && A.p < 0) {
    steps.splice(insertIndex, 0, L(`x = ${fracOf(fmtConstLatex(K), fmtConstLatex(A))}`));
  }
}



/* ===== Parsing / comparaison des réponses ===== */
function parseNumberOrFrac(str){
  if(!str) return null;
  let s = str.trim().replace(/\u2212/g,'-').replace(/^x\s*=\s*/i,'').trim();
  if(/^[-+]?(\d+([.,]\d+)?|\d*[.,]\d+)$/.test(s)){ s=s.replace(',','.'); return parseFloat(s); }
  const m = s.match(/^([-+]?\d+)\s*\/\s*([-+]?\d+)$/);
  if(m){ const p = parseInt(m[1],10), q = parseInt(m[2],10); if(q===0) return null; return p/q; }
  return null;
}
function sameNumber(a,b){
  const na = parseFloat(a), nb = parseFloat(b);
  if(Number.isNaN(na) || Number.isNaN(nb)) return false;
  return Math.abs(na-nb) < 1e-9;
}
function normalizeAnswer(s){
  if(!s) return "";
  const v = parseNumberOrFrac(s);
  if(v===null || Number.isNaN(v)) return s.trim();
  return String(v);
}
function renderSteps(host, steps){
  const res = $("#res", host);
  const box = document.createElement('div');
  box.className = 'steps';
  steps.forEach(t => {
    const line = document.createElement('div');
    line.className = 'step';
    line.innerHTML = t; // t contient déjà le LaTeX dans \( … \)
    box.appendChild(line);
  });
  res.innerHTML = '';
  res.appendChild(box);
  res.className = 'small';
  typesetAll(res); // MathJax
}

/* ======= Exercices ======= */
/* 1) ax + b = c (a,b,c entiers ; a ≠ 0) — éviter ENONCÉ “x = c” (a=1 & b=0) */
const ex1 = {
  id: "lin_simple",
  title: "Résoudre : ax + b = c",
  gen(){
    let a=0, b=0;
    while(a===0) a=rnd(-9,9);
    do { b=rnd(-12,12); } while (a===1 && b===0); // évite “x = c”
    const c=rnd(-12,12);
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1);
    const rhsExpr = subR(C, B);
    const S = divR(rhsExpr, A);
    const fracDirect = quotientRaw(rhsExpr, A);
    return {A,B,C,rhsExpr, S, fracDirect};
  },
  text(st){ return `${sideLatex(st.A, st.B)} = ${fmtConstLatex(st.C)}`; },
  render(host, st){
    host.innerHTML="";
    const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : Résoudre l’équation."; host.appendChild(hint);
    const off=document.createElement('div'); off.className="equ-offscreen";
    off.innerHTML='<div class="consigne">Résoudre l’équation.</div>' + `<div class="equation">${L(this.text(st))}</div>`;
    host.appendChild(off);

    const row=document.createElement("div"); row.className="row";
    const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(this.text(st)); row.appendChild(lab);
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="x = 3  ou  3  ou  7/3"; row.appendChild(inp);
    const res=document.createElement("div"); res.id="res"; row.appendChild(res);
    host.appendChild(row);
    typesetAll(row);
  },
  correct(host, st){
    const got = normalizeAnswer($("#reponse",host).value);
    const ok = sameNumber(got, toNumber(st.S));
    $("#res",host).innerHTML = ok ? "✔" : `✘&nbsp;&nbsp;(attendu : ${L(`x = ${fracLatex(st.S.p, st.S.q)}`)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    typesetAll($("#res",host));
    return {ok,total:1};
  },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove());
    $$(".equ-offscreen",host).forEach(n=>n.remove());

    let steps = [
      L(`${sideLatex(st.A, st.B)} = ${fmtConstLatex(st.C)}`),
      L(`${fmtCoeffXLatex(st.A)} = ${showDiffLatex(st.C, st.B)}`),
      L(`${fmtCoeffXLatex(st.A)} = ${fmtConstLatex(st.rhsExpr)}`)
    ];
    insertCoeffHints(steps, st.A, st.rhsExpr);
steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

    const zeroNum = (st.fracDirect.p === 0);
    steps.push( zeroNum ? L(`x = 0`) : L(`x = ${fracLatex(st.fracDirect.p, st.fracDirect.q)}`) );
    if (!zeroNum && needsSimplify(st.fracDirect)) steps.push(L(`x = ${fracLatex(st.S.p, st.S.q)}`));

    steps = finalizeSteps(steps);
    $("#reponse",host).value = (st.S.q===1? String(st.S.p) : `${st.S.p}/${st.S.q}`);
renderSteps(host, steps);
    $("#res",host).className = "small";
    typesetAll($("#res",host));
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 2) ax + b = cx + d (a,c ≠ 0 et a ≠ c ; entiers) */
const ex2 = {
  id: "lin_two_sides",
  title: "Résoudre : ax + b = cx + d",
  gen(){
    let a=0,c=0; while(a===0) a=rnd(-8,8); while(c===0||c===a) c=rnd(-8,8);
    const b=rnd(-12,12), d=rnd(-12,12);
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1), D=makeR(d,1);
    const Lhs = subR(A,C), Rhs = subR(D,B);
    const S = divR(Rhs, Lhs);
    const fracDirect = quotientRaw(Rhs, Lhs);
    return {A,B,C,D,L: Lhs, Rr: Rhs, S, fracDirect};
  },
  text(st){ return `${sideLatex(st.A,st.B)} = ${sideLatex(st.C,st.D)}`; },
  render(host, st){
    host.innerHTML="";
    const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : Résoudre l’équation."; host.appendChild(hint);
    const off=document.createElement('div'); off.className="equ-offscreen";
    off.innerHTML='<div class="consigne">Résoudre l’équation.</div>' + `<div class="equation">${L(this.text(st))}</div>`;
    host.appendChild(off);

    const row=document.createElement("div"); row.className="row";
    const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(this.text(st)); row.appendChild(lab);
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="x = …"; row.appendChild(inp);
    const res=document.createElement("div"); res.id="res"; row.appendChild(res);
    host.appendChild(row);
    typesetAll(row);
  },
  correct(host, st){
    const got = normalizeAnswer($("#reponse",host).value);
    const ok = sameNumber(got, toNumber(st.S));
    $("#res",host).innerHTML = ok ? "✔" : `✘&nbsp;&nbsp;(attendu : ${L(`x = ${fracLatex(st.S.p, st.S.q)}`)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko";
    typesetAll($("#res",host));
    return {ok,total:1};
  },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove());
    $$(".equ-offscreen",host).forEach(n=>n.remove());

    let steps = [
      L(`${sideLatex(st.A,st.B)} = ${sideLatex(st.C,st.D)}`),
L(`${fmtCoeffXLatex(st.A)} - ${fmtCoeffXLatex(st.C)} = ${showDiffLatex(st.D, st.B)}`),
      L(`${fmtCoeffXLatex(st.L)} = ${fmtConstLatex(st.Rr)}`)
    ];
    insertCoeffHints(steps, st.L, st.Rr);
steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

    const zeroNum = (st.fracDirect.p === 0);
    steps.push( zeroNum ? L(`x = 0`) : L(`x = ${fracLatex(st.fracDirect.p, st.fracDirect.q)}`) );
    if (!zeroNum && needsSimplify(st.fracDirect)) steps.push(L(`x = ${fracLatex(st.S.p, st.S.q)}`));

    steps = finalizeSteps(steps);
    $("#reponse",host).value = (st.S.q===1? String(st.S.p) : `${st.S.p}/${st.S.q}`);
renderSteps(host, steps);
    $("#res",host).className="small";
    typesetAll($("#res",host));
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 3) a(x+b)=c  ou  a(x+b)=c(x+d)+e (entiers ; a,c ≠ 0) */
const ex3 = {
  id: "lin_parentheses",
  title: "Résoudre avec parenthèses",
  gen(){
  const type = choice(["one_side","two_sides"]);

  if (type === "one_side") {
    // Contraintes : a ≠ 0, a ≠ 1 ; b ≠ 0
    let a; do { a = rnd(-6, 6); } while (a === 0 || a === 1);
    let b; do { b = rnd(-6, 6); } while (b === 0);
    const c = rnd(-18, 18);

    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1);
    const ab = mulR(A,B);
    const rhs = subR(C,ab);
    const S = divR(rhs,A);
    const fracDirect = quotientRaw(rhs,A);
    return {fmt:"one", A,B,C, ab, rhs, S, fracDirect};
  }

  // TWO_SIDES
  // Contraintes : a ≠ 0, a ≠ 1 ; c ≠ 0, c ≠ 1, c ≠ a ; b ≠ 0 ; d ≠ 0
  let a; do { a = rnd(-6, 6); } while (a === 0 || a === 1);
  let c; do { c = rnd(-6, 6); } while (c === 0 || c === 1 || c === a);
  let b; do { b = rnd(-6, 6); } while (b === 0);
  let d; do { d = rnd(-6, 6); } while (d === 0);
  const e = rnd(-10, 10);

  const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1), D=makeR(d,1), E=makeR(e,1);
  const cd   = mulR(C,D);
  const right= addR(cd,E);
  const left = mulR(A,B);
  const Rr   = subR(right,left);
  const L    = subR(A,C);
  const S    = divR(Rr,L);
  const fracDirect = quotientRaw(Rr,L);
  return {fmt:"two", A,B,C,D,E, cd, right, left, Rr, L, S, fracDirect};
},



  text(st){
    if(st.fmt==="one"){
      const left = (st.B.p===0? `${st.A.p}(x)` : `${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)})`);
      return `${left} = ${fmtConstLatex(st.C)}`;
    }
    const left = (st.B.p===0? `${st.A.p}(x)` : `${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)})`);
    const right= (st.D.p===0? `${st.C.p}(x)` : `${st.C.p}(x ${st.D.p>=0?'+':'-'} ${Math.abs(st.D.p)})`) + (st.E.p===0? "" : (st.E.p>0? " + "+st.E.p : " - "+Math.abs(st.E.p)));
    return `${left} = ${right}`;
  },
  render(host, st){
    host.innerHTML="";
    const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : Résoudre l’équation."; host.appendChild(hint);
    const off=document.createElement('div'); off.className="equ-offscreen";
    off.innerHTML='<div class="consigne">Résoudre l’équation.</div>' + `<div class="equation">${L(this.text(st))}</div>`;
    host.appendChild(off);

    const row=document.createElement("div"); row.className="row";
    const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(this.text(st)); row.appendChild(lab);
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="x = …"; row.appendChild(inp);
    const res=document.createElement("div"); res.id="res"; row.appendChild(res);
    host.appendChild(row);
    typesetAll(row);
  },
  correct(host, st){ const got=normalizeAnswer($("#reponse",host).value); const ok=sameNumber(got, toNumber(st.S));
    $("#res",host).innerHTML = ok ? "✔" : `✘&nbsp;&nbsp;(attendu : ${L(`x = ${fracLatex(st.S.p, st.S.q)}`)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko"; typesetAll($("#res",host)); return {ok,total:1}; },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove());
    $$(".equ-offscreen",host).forEach(n=>n.remove());

    let steps;
    if(st.fmt==="one"){
      steps = [
        L(`${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)}) = ${fmtConstLatex(st.C)}`),
        L(`${fmtCoeffXLatex(st.A)}${isZero(st.ab)?'':(' + '+fmtConstLatex(st.ab))} = ${fmtConstLatex(st.C)}`),
L(`${fmtCoeffXLatex(st.A)} = ${showDiffLatex(st.C, st.ab)}`),
L(`${fmtCoeffXLatex(st.A)} = ${fmtConstLatex(st.rhs)}`)
      ];
      insertCoeffHints(steps, st.A, st.rhs);
	  steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

   } else {
  // termes optionnels (protégés) ...
  const cdTerm = (!st.cd || isZero(st.cd)) ? '' :
    (st.cd.p > 0 ? ' + ' + fmtConstLatex(st.cd) : ' - ' + fmtConstLatex(absR(st.cd)));
  const eTerm  = (!st.E  || isZero(st.E))  ? '' :
    (st.E.p  > 0 ? ' + ' + fmtConstLatex(st.E)  : ' - ' + fmtConstLatex(absR(st.E)));
  const minusLeft = (!st.left || isZero(st.left)) ? '' : (' - ' + fmtConstLatex(st.left));

  // ⬇️ ICI : NE PAS redéclarer — pas de "let"
  steps = [
    L(`${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)}) = ${st.C.p}(x ${st.D.p>=0?'+':'-'} ${Math.abs(st.D.p)})${isZero(st.E)?'':(st.E.p>0?' + '+st.E.p:' - '+Math.abs(st.E.p))}`),
    L(`${fmtCoeffXLatex(st.A)} + ${fmtConstLatex(st.left)} = ${fmtCoeffXLatex(st.C)}${cdTerm}${eTerm}`),
    L(`${fmtCoeffXLatex(subR(st.A,st.C))} = ${fmtConstLatex(st.cd)}${eTerm}${minusLeft}`),
    L(`${fmtCoeffXLatex(st.L)} = ${fmtConstLatex(st.Rr)}`)
  ];

      insertCoeffHints(steps, st.L, st.Rr);
	  steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

    }

    const zeroNum = (st.fracDirect.p === 0);
    steps.push( zeroNum ? L(`x = 0`) : L(`x = ${fracLatex(st.fracDirect.p, st.fracDirect.q)}`) );
    if (!zeroNum && needsSimplify(st.fracDirect)) steps.push(L(`x = ${fracLatex(st.S.p, st.S.q)}`));

    steps = finalizeSteps(steps);
    $("#reponse",host).value=(st.S.q===1? String(st.S.p):`${st.S.p}/${st.S.q}`);
renderSteps(host, steps);
    $("#res",host).className="small";
    typesetAll($("#res",host));
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 4) (px+q)/m = (rx+s)/n — LaTeX */
const ex4 = {
  id: "lin_fractions",
  title: "Résoudre avec fractions (formes rationnelles)",
  gen(){
    const m = choice([2,3,4,5,6]), n = choice([2,3,4,5,6]);
    let p=0,r=0; while(p===0) p=rnd(-6,6); while(r===0) r=rnd(-6,6);
    const q=rnd(-8,8), s=rnd(-8,8);
    const M=makeR(m,1), N=makeR(n,1), P=makeR(p,1), Q=makeR(q,1), R=makeR(r,1), S0=makeR(s,1);
    let A = subR( mulR(N,P), mulR(M,R) ); if(isZero(A)){ R = makeR(r+1,1); A = subR( mulR(N,P), mulR(M,R) ); }
    const B = subR( mulR(M,S0), mulR(N,Q) );
    const Sol = divR(B,A);
    const fracDirect = quotientRaw(B, A);
    return {M,N,P,Q,R,S0, A,B, Sol, fracDirect};
  },
  text(st){
    const leftNum  = st.Q.p===0 ? fmtCoeffXLatex(st.P) : (fmtCoeffXLatex(st.P) + (st.Q.p>0? " + "+fmtConstLatex(st.Q) : " - "+fmtConstLatex(absR(st.Q))));
    const rightNum = st.S0.p===0? fmtCoeffXLatex(st.R) : (fmtCoeffXLatex(st.R) + (st.S0.p>0? " + "+fmtConstLatex(st.S0) : " - "+fmtConstLatex(absR(st.S0))));
    const left  = fracOf(leftNum, String(st.M.p));
    const right = fracOf(rightNum, String(st.N.p));
    return `${left} = ${right}`;
  },
  render(host, st){
    host.innerHTML="";
    const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : Résoudre l’équation."; host.appendChild(hint);
    const off=document.createElement('div'); off.className="equ-offscreen";
    off.innerHTML='<div class="consigne">Résoudre l’équation.</div>' + `<div class="equation">${L(this.text(st))}</div>`;
    host.appendChild(off);

    const row=document.createElement("div"); row.className="row";
    const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(this.text(st)); row.appendChild(lab);
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="x = …  (nombre ou fraction)"; row.appendChild(inp);
    const res=document.createElement("div"); res.id="res"; row.appendChild(res);
    host.appendChild(row);
    typesetAll(row);
  },
  correct(host, st){ const got=normalizeAnswer($("#reponse",host).value); const ok=sameNumber(got,toNumber(st.Sol));
    $("#res",host).innerHTML = ok ? "✔" : `✘&nbsp;&nbsp;(attendu : ${L(`x = ${fracLatex(st.Sol.p, st.Sol.q)}`)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko"; typesetAll($("#res",host)); return {ok,total:1}; },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove());
    $$(".equ-offscreen",host).forEach(n=>n.remove());

    let steps = [
      L(this.text(st)),
      L(`${st.N.p}\\,( ${fmtCoeffXLatex(st.P)} ${st.Q.p===0?'':(st.Q.p>0?' + ':' - ')+fmtConstLatex(absR(st.Q))} ) = ${st.M.p}\\,( ${fmtCoeffXLatex(st.R)} ${st.S0.p===0?'':(st.S0.p>0?' + ':' - ')+fmtConstLatex(absR(st.S0))} )`),
      L(`${fmtConstLatex(mulR(st.N,st.P))}x ${fmtSignedConstLatex(mulR(st.N,st.Q))} = ${fmtConstLatex(mulR(st.M,st.R))}x ${fmtSignedConstLatex(mulR(st.M,st.S0))}`),
      L(`${fmtCoeffXLatex(st.A)} = ${fmtConstLatex(st.B)}`)
    ];
    insertCoeffHints(steps, st.A, st.B);
steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

    const zeroNum = (st.fracDirect.p === 0);
    steps.push( zeroNum ? L(`x = 0`) : L(`x = ${fracLatex(st.fracDirect.p, st.fracDirect.q)}`) );
    if (!zeroNum && needsSimplify(st.fracDirect)) steps.push(L(`x = ${fracLatex(st.Sol.p, st.Sol.q)}`));

    steps = finalizeSteps(steps);
    $("#reponse",host).value=(st.Sol.q===1? String(st.Sol.p):`${st.Sol.p}/${st.Sol.q}`);
renderSteps(host, steps);
    $("#res",host).className="small";
    typesetAll($("#res",host));
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 5) ax + b = cx + d (coeffs rationnels : entiers OU fractions ; a≠c) */
const ex5 = {
  id: "lin_two_sides_rational",
  title: "ax + b = cx + d (coefficients entiers ou fractions)",
  gen(){
    function randIntNonZero(min,max){ let x=0; while(x===0){ x=rnd(min,max); } return x; }
    function randRational(opts={}){
      const {allowZero=true} = opts;
      const isFrac = Math.random()<0.4;
      if(!isFrac){
        let v = allowZero ? rnd(-9,9) : randIntNonZero(-9,9);
        return makeR(v,1);
      }
      const d = choice([2,3,4,5,6]);
      const n = allowZero ? rnd(-9,9) : randIntNonZero(-9,9);
      return makeR(n,d);
    }

    let A=randRational({allowZero:false}), C=randRational({allowZero:false});
    while(A.p===C.p && A.q===C.q){ C=randRational({allowZero:false}); }
    const B=randRational({allowZero:true}), D=randRational({allowZero:true});
    const Lhs = subR(A,C), Rhs = subR(D,B);
    const S = divR(Rhs, Lhs);
    const fracDirect = quotientRaw(Rhs, Lhs);
    return {A,B,C,D,L: Lhs, Rr: Rhs, S, fracDirect};
  },
  text(st){ return `${sideLatex(st.A,st.B)} = ${sideLatex(st.C,st.D)}`; },
  render(host, st){
    host.innerHTML="";
    const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : Résoudre l’équation."; host.appendChild(hint);
    const off=document.createElement('div'); off.className="equ-offscreen";
    off.innerHTML='<div class="consigne">Résoudre l’équation.</div>' + `<div class="equation">${L(this.text(st))}</div>`;
    host.appendChild(off);

    const row=document.createElement("div"); row.className="row";
    const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(this.text(st)); row.appendChild(lab);
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="x = …"; row.appendChild(inp);
    const res=document.createElement("div"); res.id="res"; row.appendChild(res);
    host.appendChild(row);
    typesetAll(row);
  },
  correct(host, st){ const got=normalizeAnswer($("#reponse",host).value); const ok=sameNumber(got,toNumber(st.S));
    $("#res",host).innerHTML = ok ? "✔" : `✘&nbsp;&nbsp;(attendu : ${L(`x = ${fracLatex(st.S.p, st.S.q)}`)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko"; typesetAll($("#res",host)); return {ok,total:1}; },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove());
    $$(".equ-offscreen",host).forEach(n=>n.remove());

    let steps = [
      L(`${sideLatex(st.A,st.B)} = ${sideLatex(st.C,st.D)}`),
L(`${fmtCoeffXLatex(st.A)} - ${fmtCoeffXLatex(st.C)} = ${showDiffLatex(st.D, st.B)}`),
      L(`${fmtCoeffXLatex(st.L)} = ${fmtConstLatex(st.Rr)}`)
    ];
    insertCoeffHints(steps, st.L, st.Rr);
steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

    const zeroNum = (st.fracDirect.p === 0);
    steps.push( zeroNum ? L(`x = 0`) : L(`x = ${fracLatex(st.fracDirect.p, st.fracDirect.q)}`) );
    if (!zeroNum && needsSimplify(st.fracDirect)) steps.push(L(`x = ${fracLatex(st.S.p, st.S.q)}`));

    steps = finalizeSteps(steps);
    $("#reponse",host).value=(st.S.q===1? String(st.S.p):`${st.S.p}/${st.S.q}`);
renderSteps(host, steps);
    $("#res",host).className="small";
    typesetAll($("#res",host));
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

/* 6) ax = b (a ≠ 0 ; a et b entiers ou fractions) — éviter ENONCÉ “x = b” (a=1) */
const ex6 = {
  id: "lin_ax_eq_b",
  title: "ax = b (a entier ou fraction, a ≠ 0)",
  gen(){
    function randIntNonZero(min,max){ let x=0; while(x===0){ x=rnd(min,max); } return x; }
    function randRational(opts={}){
      const {allowZero=true} = opts;
      const isFrac = Math.random()<0.4;
      if(!isFrac){
        let v = allowZero ? rnd(-9,9) : randIntNonZero(-9,9);
        return makeR(v,1);
      }
      const d = choice([2,3,4,5,6]);
      const n = allowZero ? rnd(-9,9) : randIntNonZero(-9,9);
      return makeR(n,d);
    }
    let A=randRational({allowZero:false}); // a ≠ 0
    // on refuse a = 1 pour éviter l’énoncé trivial x = b
    while (A.p === 1 && A.q === 1) { A = randRational({allowZero:false}); }
    const B=randRational({allowZero:true});
    const S = divR(B,A);
    const fracDirect = quotientRaw(B, A);
    return {A,B,S, fracDirect};
  },
  text(st){ return `${fmtCoeffXLatex(st.A)} = ${fmtConstLatex(st.B)}`; },
  render(host, st){
    host.innerHTML="";
    const hint=document.createElement('p'); hint.className="hint"; hint.textContent="Consigne : Résoudre l’équation."; host.appendChild(hint);
    const off=document.createElement('div'); off.className="equ-offscreen";
    off.innerHTML='<div class="consigne">Résoudre l’équation.</div>' + `<div class="equation">${L(this.text(st))}</div>`;
    host.appendChild(off);

    const row=document.createElement("div"); row.className="row";
    const lab=document.createElement("div"); lab.className="col-label"; lab.innerHTML=L(this.text(st)); row.appendChild(lab);
    const inp=document.createElement("input"); inp.type="text"; inp.id="reponse"; inp.placeholder="x = …  (nombre ou fraction)"; row.appendChild(inp);
    const res=document.createElement("div"); res.id="res"; row.appendChild(res);
    host.appendChild(row);
    typesetAll(row);
  },
  correct(host, st){ const got=normalizeAnswer($("#reponse",host).value); const ok=sameNumber(got,toNumber(st.S));
    $("#res",host).innerHTML = ok ? "✔" : `✘&nbsp;&nbsp;(attendu : ${L(`x = ${fracLatex(st.S.p, st.S.q)}`)})`;
    $("#res",host).className = ok ? "res-ok" : "res-ko"; typesetAll($("#res",host)); return {ok,total:1}; },
  solution(host, st){
    $$(".hint",host).forEach(n=>n.remove());
    $$(".equ-offscreen",host).forEach(n=>n.remove());

    let steps = [
      L(`${fmtCoeffXLatex(st.A)} = ${fmtConstLatex(st.B)}`)
    ];
    insertCoeffHints(steps, st.A, st.B);
steps = ensureArray(steps);  // <<--- NO CRASH si steps était undefined

    const zeroNum = (st.fracDirect.p === 0);
    steps.push( zeroNum ? L(`x = 0`) : L(`x = ${fracLatex(st.fracDirect.p, st.fracDirect.q)}`) );
    if (!zeroNum && needsSimplify(st.fracDirect)) steps.push(L(`x = ${fracLatex(st.S.p, st.S.q)}`));

    steps = finalizeSteps(steps);
    $("#reponse",host).value=(st.S.q===1? String(st.S.p):`${st.S.p}/${st.S.q}`);
renderSteps(host, steps);
    $("#res",host).className="small";
    typesetAll($("#res",host));
  },
  reset(host){ $("#reponse",host).value=""; $("#res",host).textContent=""; }
};

const REGISTRY = [ex1, ex2, ex3, ex4, ex5, ex6];
window.REGISTRY = REGISTRY;

/* ===== Score & Bootstrap ===== */
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function buildOne(){
  const sel=$("#exo-select");
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active = def.id;
  host.dataset.state = JSON.stringify(state);
  def.render(host, state);
  const inp = $("#reponse", host) || $("input[type=text]", host);
  if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const state=JSON.parse(host.dataset.state||"{}");
  const r = def.correct(host, state);
  if(r){ scoreOK += r.ok?1:0; scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const state=JSON.parse(host.dataset.state||"{}");
  def.solution(host, state);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def) def.reset(host);
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{
    const opt=document.createElement("option");
    opt.value=e.id; opt.textContent=e.title;
    sel.appendChild(opt);
  });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  sel.value = REGISTRY[0].id;
  buildOne();
  updateScore();

  // PDF hook (version LaTeX)
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde – Chapitre 1 – Équations du premier degré',
      max: 50,
      mountAfterSelector: '.card.small',
      beforeRender(def, st, withSolutions){
        try{
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          def.render(tmp, st);
          if(!withSolutions){
            const equ = tmp.querySelector('.equ-offscreen');
            if(equ) return equ.outerHTML;
            return tmp.innerHTML;
          }else{
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            const steps = tmp.querySelector('.steps');
            if(steps) return steps.outerHTML;
            return tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }

  // — Normalisation Unicode (−, ×…) après chargement des libs
  if (window.DevRules && DevRules.attachCleaner) DevRules.attachCleaner();
});
})();
</script>

<!-- Barre mobile + confort -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
