<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde â€“ Fonction inverse - DÃ©finition - Signe - Variations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  /* mini tableaux â€œPDF-likeâ€ (cadre extÃ©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + sÃ©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre extÃ©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* SÃ©paration verticale aprÃ¨s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* SÃ©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule flÃ¨che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la flÃ¨che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;
  text-align-last:center;
  appearance:none;
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* BÃ‚TONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;
  font-weight: 400;
  line-height: 1;
}
table.pdf-tbl td.zbar { font-weight:400 !important; }

/* Variante "grille complÃ¨te" pour les tableaux d'images f(x) */
table.pdf-tbl.fullgrid{
  border-collapse:collapse;
  border-spacing:0;
}

table.pdf-tbl.fullgrid th,
table.pdf-tbl.fullgrid td{
  border:1.5px solid #000;
  padding:8px 10px;
}
.graph svg.grid{
  width:100%;
  height:auto;
}
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde â€“ Fonction inverse - DÃ©finition - Signe - Variations</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>FlÃ¨ches : choisissez â†˜ ou â†—.</li>
        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, Ã©crire une liste. Exemple : -3;2</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* â€”â€”â€”â€”â€” Utils â€”â€”â€”â€”â€” */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='âˆ’';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

/* â€”â€”â€”â€”â€” (Fonctions de repÃ¨re inutilisÃ©es ici mais conservÃ©es) â€”â€”â€”â€”â€” */
/* â€¦ (on garde ton buildRepereSVG et le reste inchangÃ©, ils ne sont pas utilisÃ©s plus bas) â€¦ */

function buildRepereSVG(opts){
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;
  const { xmin, xmax, ymin, ymax } = opts;
  const subDivX = opts.subDivX || 1;
  const subDivY = opts.subDivY || 1;
  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  const Rx = xmax - xmin;
  const Ry = ymax - ymin;
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );
  const sX = cell * subDivX;
  const sY = cell * subDivY;
  const w = sX * Rx;
  const h = sY * Ry;
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
  svg.setAttribute('width', W);
  svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', 'âˆ’');

    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}

/* â€”â€”â€”â€”â€” Exercice 1 : images par la fonction inverse â€”â€”â€”â€”â€” */

const ex1 = {
  id: "images_fonction_inverse",
  title: "Images par la fonction inverse",

  randFracCoprime() {
    const gcd = (a,b)=>{
      a=Math.abs(a); b=Math.abs(b);
      while (b){ const t=b; b=a%b; a=t; }
      return a;
    };
    while (true) {
      const num = rint(1,9);
      const den = rint(2,9);
      if (gcd(num,den) === 1) return {num,den};
    }
  },

  gen() {
    const items = [];
    const isSquare = n => {
      const r = Math.sqrt(n);
      return Number.isInteger(r);
    };

    // 1) Fraction positive p/q -> image q/p
    const fp = this.randFracCoprime();
    items.push({
      kind:"fracPos",
      latex:`\\dfrac{${fp.num}}{${fp.den}}`,
      num:fp.num,
      den:fp.den,
      val:fp.den/fp.num,
      ansTex:`\\dfrac{${fp.den}}{${fp.num}}`
    });

    // 2) Fraction nÃ©gative -p/q -> image -q/p
    const fn = this.randFracCoprime();
    items.push({
      kind:"fracNeg",
      latex:`-\\dfrac{${fn.num}}{${fn.den}}`,
      num:fn.num,
      den:fn.den,
      val:-fn.den/fn.num,
      ansTex:`-\\dfrac{${fn.den}}{${fn.num}}`
    });

    // 3) Entier positif k -> 1/k
    const k1 = rint(2,9);
    items.push({
      kind:"entPos",
      latex:`${k1}`,
      k:k1,
      val:1/k1,
      ansTex:`\\dfrac{1}{${k1}}`
    });

    // 4) Entier nÃ©gatif -k -> -1/k
    const k2 = rint(2,9);
    items.push({
      kind:"entNeg",
      latex:`-${k2}`,
      k:k2,
      val:-1/k2,
      ansTex:`-\\dfrac{1}{${k2}}`
    });

    // 5) Puissance de 10
    const exps = [-4,-3,-2,-1,2,3,4];
    const e = choice(exps);
    items.push({
      kind:"pow10",
      latex:`10^{${e}}`,
      exp:e,
      powExp:-e,
      val:10**(-e),
      ansTex:`10^{${-e}}`
    });

    // 6) DÃ©cimal simple de la forme m/10
    const m = choice([2,3,4,5,8,9]);
    items.push({
      kind:"dec",
      latex:`0,${m}`,
      num:m,
      den:10,
      val:10/m,
      ansTex:`\\dfrac{10}{${m}}`
    });

    // 7) racine simple âˆša, avec a non carrÃ© parfait
    let a;
    do {
      a = rint(2,15);
    } while (isSquare(a));
    items.push({
      kind:"racSimple",
      latex:`\\sqrt{${a}}`,
      a,
      ansTex:`\\dfrac{1}{\\sqrt{${a}}}`
    });

    // 8) diffÃ©rence de racines âˆša - âˆšb, a et b non carrÃ©s parfaits, distincts
    let aa, bb;
    do {
      aa = rint(2,15);
      bb = rint(2,15);
    } while (aa === bb || isSquare(aa) || isSquare(bb));
    items.push({
      kind:"racDiff",
      latex:`\\sqrt{${aa}} - \\sqrt{${bb}}`,
      a: aa,
      b: bb,
      ansTex:`\\dfrac{1}{\\sqrt{${aa}}-\\sqrt{${bb}}}`
    });

    // MÃ©lange de lâ€™ordre des 8 nombres
    items.sort(()=>Math.random()-0.5);

    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>Calculer lâ€™image des nombres suivants par la fonction inverse \\(f(x)=\\dfrac{1}{x}\\) :</div>
      <div class="var-wrap">
        <table class="pdf-tbl fullgrid" style="width:100%;margin-top:8px">
          <tbody>
            ${[0,1].map(row => `
              <tr>
                ${[0,1,2,3].map(col => {
                  const idx = 4*row+col;
                  const it = st.items[idx];
                  return `
                  <td style="width:25%;vertical-align:top;padding:8px 10px">
                    <div>\\(${it.latex} :\\)</div>
                    <div style="margin-top:10px">
                      <input class="img" data-i="${idx}" type="text"
                             style="width:90%;max-width:180px;text-align:center">
                      <span class="tick nu"></span>
                    </div>
                  </td>`;
                }).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
      <div id="res" class="steps small"></div>
    `;
    host.querySelectorAll('input.img').forEach(ensureTickAfter);
    typesetAll(host);
  },

    correct(host, st) {
    const normBasic = s => (s||"")
      .trim()
      .replace(/\u2212/g,"-")
      .replace(/,/g,".")
      .replace(/\s+/g,"");

    // normalisation pour expressions avec racines / fractions
    const normRootExpr = s => {
      s = (s || "").trim();
      if (!s) return "";
      s = s
        .replace(/\u2212/g,"-")
        .replace(/\s+/g,"")
        .replace(/,/g,".")
        // \dfrac{a}{b}, \frac{a}{b} -> (a)/(b)
        .replace(/\\dfrac\{([^}]*)\}\{([^}]*)\}/g, "($1)/($2)")
        .replace(/\\frac\{([^}]*)\}\{([^}]*)\}/g, "($1)/($2)")
        // \sqrt{a} -> sqrt(a)
        .replace(/\\sqrt\{([^}]*)\}/g, "sqrt($1)")
        .replace(/\\sqrt/g,"sqrt")
        // rac(a) -> sqrt(a)
        .replace(/rac\(/gi,"sqrt(")
        // âˆša -> sqrt(a)
        .replace(/âˆš\(/g,"sqrt(")
        .replace(/âˆš([0-9]+)/g,"sqrt($1)");
      return s;
    };

    // Ã©val' numÃ©rique trÃ¨s restreinte : nombres, + - * /, (), sqrt(...)
    function evalRootExpr(str){
      let s = normRootExpr(str);
      if (!s) return NaN;
      // on n'autorise que chiffres, ., + - * / ( ) et lettres de "sqrt"
      if (!/^[0-9+\-*/().sqrt]+$/i.test(s)) return NaN;
      // sqrt(...) -> Math.sqrt(...)
      s = s.replace(/sqrt\(/g, "Math.sqrt(");
      try{
        // expression purement numÃ©rique â†’ on peut Ã©valuer
        const f = new Function('"use strict";return ('+s+');');
        const v = f();
        return (typeof v === "number" && Number.isFinite(v)) ? v : NaN;
      }catch(e){
        return NaN;
      }
    }

    const parseNum = s => {
      s = normBasic(s);
      if (!s) return NaN;
      if (s.includes("/")) {
        const [na,da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        return n/d;
      }
      const x = Number(s);
      return Number.isNaN(x) ? NaN : x;
    };

    let ok = 0, tot = 0;

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.img[data-i="${i}"]`);
      const raw = inp.value;
      const v = normBasic(raw);

      if (!v) {
        setTick(inp,"nu");
        return;
      }

      tot++;

      let good = false;

      if (it.kind === "fracPos" || it.kind === "fracNeg" ||
          it.kind === "entPos"  || it.kind === "entNeg"  ||
          it.kind === "dec") {
        const val = parseNum(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - it.val) < 1e-9;
        }
      } else if (it.kind === "pow10") {
        const val = parseNum(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - it.val) < 1e-9;
        } else {
          const w = normBasic(raw);
          if (w.startsWith("10^")) {
            let kStr = w.slice(3);
            if (kStr.startsWith("{") && kStr.endsWith("}")) {
              kStr = kStr.slice(1,-1);
            }
            const k = Number(kStr);
            if (Number.isInteger(k)) good = (k === it.powExp);
          }
        }
      } else if (it.kind === "racSimple") {
        // cible : 1/âˆša
        const target = 1 / Math.sqrt(it.a);
        const val = evalRootExpr(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - target) < 1e-9;
        }
      } else if (it.kind === "racDiff") {
        // cible : 1/(âˆša - âˆšb)
        const target = 1 / (Math.sqrt(it.a) - Math.sqrt(it.b));
        const val = evalRootExpr(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - target) < 1e-8; // un peu plus large, expression + compliquÃ©e
        }
      }

      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    $("#res",host).textContent = "";
    return { ok, total: tot };
  },


  solution(host, st) {
    const box = $("#res",host);

    const solTex = it => {
      if (it.kind === "fracPos") {
        const n = it.num, d = it.den;
        return `
\\[
\\begin{aligned}
f\\left(\\dfrac{${n}}{${d}}\\right)
&= \\dfrac{${d}}{${n}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "fracNeg") {
        const n = it.num, d = it.den;
        return `
\\[
\\begin{aligned}
f\\left(-\\dfrac{${n}}{${d}}\\right)
&= -\\dfrac{${d}}{${n}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "entPos") {
        const k = it.k;
        return `
\\[
\\begin{aligned}
f(${k}) &= \\dfrac{1}{${k}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "entNeg") {
        const k = it.k;
        return `
\\[
\\begin{aligned}
f(-${k}) &= \\dfrac{1}{- ${k}}\\\\
&= -\\dfrac{1}{${k}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "pow10") {
        const e = it.exp;
        const e2 = it.powExp;
        return `
\\[
\\begin{aligned}
f\\left(10^{${e}}\\right)
&= \\dfrac{1}{10^{${e}}}\\\\
&= 10^{${e2}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "dec") {
        const m = it.num;
        return `
\\[
\\begin{aligned}
f(0,${m})
&=f\\left(\\dfrac{${m}}{10}\\right)\\\\
&= \\dfrac{10}{${m}}
\\end{aligned}
\\]`;
      }

  // ----- âˆša -----
      if (it.kind === "racSimple") {
        const a = it.a;
        return `
\\[
\\begin{aligned}
f\\bigl(\\sqrt{${a}}\\bigr)
&= \\dfrac{1}{\\sqrt{${a}}}\\\\
&= \\dfrac{1}{\\sqrt{${a}}}\\times\\dfrac{\\sqrt{${a}}}{\\sqrt{${a}}}\\\\
&= \\dfrac{\\sqrt{${a}}}{(\\sqrt{${a}})^2}\\\\
&= \\dfrac{\\sqrt{${a}}}{${a}}
\\end{aligned}
\\]`;
      }

      // ----- âˆša âˆ’ âˆšb -----
      if (it.kind === "racDiff") {
        const a = it.a, b = it.b;
        const diff = a - b;

        // texte final selon la valeur de a-b
        let finalPart;
        if (diff === 1) {
          // pas de /1 Ã  la fin
          finalPart = `
&= \\sqrt{${a}} + \\sqrt{${b}}`;
        } else if (diff === -1) {
          // on Ã©vite aussi /(-1), on factorise le signe
          finalPart = `
&= \\dfrac{\\sqrt{${a}} + \\sqrt{${b}}}{-1}\\\\
&= -\\sqrt{${a}} - \\sqrt{${b}}`;
        } else {
          // cas gÃ©nÃ©ral
          finalPart = `
&= \\dfrac{\\sqrt{${a}} + \\sqrt{${b}}}{${a-b}}`;
        }

        return `
\\[
\\begin{aligned}
f\\bigl(\\sqrt{${a}} - \\sqrt{${b}}\\bigr)
&= \\dfrac{1}{\\sqrt{${a}} - \\sqrt{${b}}}\\\\[4pt]
&= \\dfrac{1}{\\sqrt{${a}} - \\sqrt{${b}}}
   \\times \\dfrac{\\sqrt{${a}} + \\sqrt{${b}}}{\\sqrt{${a}} + \\sqrt{${b}}}\\\\
&= \\dfrac{\\sqrt{${a}} + \\sqrt{${b}}}{%
(\\sqrt{${a}} - \\sqrt{${b}})(\\sqrt{${a}} + \\sqrt{${b}})}\\\\[4pt]
&= \\dfrac{\\sqrt{${a}} + \\sqrt{${b}}}{(\\sqrt{${a}})^2 - (\\sqrt{${b}})^2}\\\\
&= \\dfrac{\\sqrt{${a}} + \\sqrt{${b}}}{${a} - ${b}}\\\\
${finalPart}
\\end{aligned}
\\]
Remarque : on dit qu'on multiplie par le conjuguÃ©.
`;
      }


      return "";
    };

    const cells = idx => {
      const it = st.items[idx];
      return `
<td style="vertical-align:top;padding:8px 10px">
  <div style="margin-top:6px">${solTex(it)}</div>
</td>`;
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;margin-top:4px">
        <tbody>
          <tr>
            ${cells(0)}${cells(1)}${cells(2)}${cells(3)}
          </tr>
          <tr>
            ${cells(4)}${cells(5)}${cells(6)}${cells(7)}
          </tr>
        </tbody>
      </table>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.img").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};

/* â€”â€”â€”â€”â€” Exercice 2 : variations de la fonction inverse sur un intervalle â€”â€”â€”â€”â€” */

const ex2 = {
  id: "var_inverse_interval",
  title: "Tableau de variations de la fonction inverse sur un intervalle",

  gen() {
    // 50% intervalle >0, 50% intervalle <0, toujours sans 0
    const r = Math.random();
    let type, a, b;

    if (r < 0.5) {
      // [a;b] entiÃ¨rement positif
      type = "pos";
      a = rint(1, 5);
      b = rint(a + 1, Math.min(a + 4, 9));
    } else {
      // [a;b] entiÃ¨rement nÃ©gatif
      type = "neg";
      const A = rint(1, 5);
      const B = rint(A + 1, Math.min(A + 4, 9));
      b = -A;
      a = -B; // a < b < 0
    }

    return { type, a, b };
  },

  render(host, st) {
    const { type, a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;

    // Colonnes de x : toujours a -> b avec une colonne flÃ¨che
    const colsX = [a, null, b];

const rowX = `
  <tr>
    <th>\\(x\\)</th>
    ${colsX.map((x, idx, arr) => {
      if (x === null) return `<td></td>`;
      const isLeft  = idx === 0;
      const isRight = idx === arr.length - 1;
      const align = isLeft ? 'left' : (isRight ? 'right' : 'center');
      const pad   = isLeft
        ? 'padding-left:10px;'
        : (isRight ? 'padding-right:10px;' : '');
      return `<td style="text-align:${align};${pad}">\\(${x}\\)</td>`;
    }).join("")}
  </tr>`;

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        ${colsX.map((x, idx) => {
          if (x === null) {
            return `
              <td class="bigsel">
                <select class="dir" data-i="${idx}"
                        style="display:block;width:100%;height:100%">
                  <option value=""></option>
                  <option>â†˜</option>
                  <option>â†—</option>
                </select>
              </td>`;
          }
          return `
            <td>
              <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
                <input class="ymax" data-x="${x}" type="text" style="width:80px;text-align:center">
                <input class="ymin" data-x="${x}" type="text" style="width:80px;text-align:center">
              </div>
            </td>`;
        }).join("")}
      </tr>`;

    host.innerHTML = `
      <div><b>1.</b> Donner le <b>tableau de variations</b> de la fonction inverse dÃ©finie par : \\(f(x)=\\dfrac{1}{x}\\) sur \\(${Itex}\\).</div>

      <div class="var-wrap" style="margin-top:.6rem">
        <table class="var frame-only pdf-hide">
          <tbody>
            ${rowX}
            ${rowF}
          </tbody>
        </table>
      </div>

      <div style="margin-top:.6rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> Le <b>minimum</b> de la fonction inverse sur \\(${Itex}\\) est :</label>
          <input class="qminy" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qminx" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
        </div>
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>3.</b> Le <b>maximum</b> de la fonction inverse sur \\(${Itex}\\) est :</label>
          <input class="qmaxy" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qmaxx" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ymax,input.ymin,input.qminy,input.qminx,input.qmaxy,input.qmaxx,select.dir')
        .forEach(ensureTickAfter);

    typesetAll(host);
  },

  correct(host, st) {
    const { a, b } = st;

    const norm = s => (s || "").trim().replace(/\u2212/g, "-").replace(/,/g, ".");
    const num  = s => {
      const t = norm(s);
      if (!t) return null;
      if (t.includes("/")) {
        const [na,da] = t.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return null;
        return n/d;
      }
      const v = Number(t);
      return Number.isFinite(v) ? v : null;
    };

    // f(x)=1/x est strictement dÃ©croissante sur chaque intervalle ne contenant pas 0
    // Sur [a;b] avec a<b : maximum en x=a, minimum en x=b
    const maxX = a, maxVal = 1/a;
    const minX = b, minVal = 1/b;

    let ok = 0, tot = 0;

    // --- 1) Tableau : cases de f (ymax / ymin) ---
    host.querySelectorAll(".ycol").forEach(col => {
      const inpMax = col.querySelector("input.ymax");
      const inpMin = col.querySelector("input.ymin");
      if (!inpMax || !inpMin) return;

      const x = Number(inpMax.dataset.x || inpMin.dataset.x);
      const fX = 1 / x;
      const isMaxCol = (x === maxX);
      const isMinCol = (x === minX);

      // Case du haut : rÃ©servÃ©e au maximum
      const rawMax = inpMax.value.trim();
      if (!rawMax) {
        setTick(inpMax, "nu");
      } else {
        tot++;
        const vNum = num(rawMax);
        const good = isMaxCol && vNum !== null && Math.abs(vNum - fX) < 1e-9;
        setTick(inpMax, good ? "ok" : "ko");
        if (good) ok++;
      }

      // Case du bas : rÃ©servÃ©e au minimum
      const rawMin = inpMin.value.trim();
      if (!rawMin) {
        setTick(inpMin, "nu");
      } else {
        tot++;
        const vNum = num(rawMin);
        const good = isMinCol && vNum !== null && Math.abs(vNum - fX) < 1e-9;
        setTick(inpMin, good ? "ok" : "ko");
        if (good) ok++;
      }
    });

    // --- 2) Tableau : flÃ¨che de variation ---
    host.querySelectorAll("select.dir").forEach(sel => {
      const v = sel.value;
      if (!v) {
        setTick(sel, "nu");
        return;
      }
      tot++;
      const good = (v === "â†˜"); // toujours dÃ©croissante
      setTick(sel, good ? "ok" : "ko");
      if (good) ok++;
    });

    // --- 3) Questions 2 et 3 : min / max et abscisses ---
    const checkNumInput = (sel, expected) => {
      const inp = host.querySelector(sel);
      if (!inp) return;
      const v = inp.value.trim();
      if (!v) { setTick(inp,"nu"); return; }
      tot++;
      const n = num(v);
      const good = (n !== null && Math.abs(n - expected) < 1e-9);
      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    };

    checkNumInput('.qminy', minVal);
    checkNumInput('.qminx', minX);
    checkNumInput('.qmaxy', maxVal);
    checkNumInput('.qmaxx', maxX);

    return { ok, total: tot };
  },


  solution(host, st) {
    const { type, a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;

    const xs = [a, b];
    const dirs = ["â†˜"]; // toujours dÃ©croissante

const fracTex = x => {
  if (x === 1) {
    // f(1) = 1
    return "1";
  }
  if (x === -1) {
    // f(-1) = -1
    return "-1";
  }
  if (x > 0) {
    // x > 0, x â‰  1
    return `\\dfrac{1}{${x}}`;
  }
  if (x < 0) {
    // x < 0, x â‰  -1 : signe devant la fraction, dÃ©nominateur positif
    return `-\\dfrac{1}{${-x}}`;
  }
  // normalement x=0 nâ€™apparaÃ®t pas ici
  return "";
};

    const valBlock = (x, isLeft) => {
      const yTex = fracTex(x);
      const up = isLeft ? yTex : "&nbsp;";
      const dn = isLeft ? "&nbsp;" : yTex;
      return `
      <td>
        <div style="text-align:center">\\(${up}\\)</div>
        <div style="height:6px"></div>
        <div style="text-align:center">\\(${dn}\\)</div>
      </td>`;
    };

const rowX = `
  <tr>
    <th>\\(x\\)</th>
    <td style="text-align:left;padding-left:10px">\\(${a}\\)</td>
    <td></td>
    <td style="text-align:right;padding-right:10px">\\(${b}\\)</td>
  </tr>`;

    let rowF = '<tr><th>\\(f\\)</th>';
    xs.forEach((x, i) => {
      const isLeft = (i === 0);
      rowF += valBlock(x, isLeft);
      if (i < xs.length - 1) {
        rowF += `<td>${dirs[i]}</td>`;
      }
    });
    rowF += '</tr>';

    const maxTex = fracTex(a);
    const minTex = fracTex(b);

    const box = $("#res",host);
    box.innerHTML = `
      <div class="step">
        <b>1.</b> Tableau de variations de la fonction inverse dÃ©finie par : \\(f(x)=\\dfrac{1}{x}\\) sur \\(${Itex}\\) :
        <div class="var-wrap" style="margin-top:.4rem">
          <table class="pdf-tbl">
            <thead>${rowX}</thead>
            <tbody>
              ${rowF}
            </tbody>
          </table>
        </div>
      </div>
      <div class="step" style="margin-top:6px">
        <b>2.</b> Sur \\(${Itex}\\), le <b>minimum</b> de la fonction inverse est
        \\(${minTex}\\), atteint en \\(x=${b}\\).
      </div>
      <div class="step">
        <b>3.</b> Sur \\(${Itex}\\), le <b>maximum</b> de la fonction inverse est
        \\(${maxTex}\\), atteint en \\(x=${a}\\).
      </div>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ymax,input.ymin,input.qminy,input.qminx,input.qmaxy,input.qmaxx,select.dir")
        .forEach(el => {
          if (el.tagName === "INPUT") el.value = "";
          setTick(el,"nu");
        });
  }
};

/* â€”â€”â€”â€”â€” Registre & UI â€”â€”â€”â€”â€” */
const REGISTRY=[ex1,ex2];
window.REGISTRY = REGISTRY;

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde â€“ Fonction inverse - DÃ©finition - Signe - Variations',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
