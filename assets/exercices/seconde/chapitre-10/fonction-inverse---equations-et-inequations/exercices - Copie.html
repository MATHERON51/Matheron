<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde â€“ Fonction inverse â€“ Ã‰quations et inÃ©quations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  /* tableaux type PDF */
  table.pdf-tbl{
    border-collapse: separate;
    border-spacing: 0;
    border: none;
    margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none;
    padding: 6px 8px;
    text-align: center;
    vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }

  table.pdf-tbl.fullgrid{
    border-collapse:collapse;
    border-spacing:0;
  }
  table.pdf-tbl.fullgrid th,
  table.pdf-tbl.fullgrid td{
    border:1.5px solid #000;
    padding:8px 10px;
  }

  .graph svg.grid{
    width:100%;
    height:auto;
  }
</style>

<!-- MathJax -->
<script>
  window.MathJax={
    tex:{
      inlineMath:[['\\(','\\)'],['$','$']],
      displayMath:[['\\[','\\]'],['$$','$$']],
      processEscapes:true
    },
    chtml:{matchFontHeight:false},
    startup:{typeset:true}
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde â€“ Fonction inverse â€“ Ã‰quations et inÃ©quations</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>
          <b>Exercice 1 :</b> Ã©crire les solutions sous forme de nombre ou de fraction
          (par exemple <code>-6/7</code>, <code>10^-5</code>, <code>1/10^5</code>, <code>-1/(7/6)</code>â€¦).
        </li>
        <li>
          <b>Exercice 2 :</b> Ã©crire lâ€™ensemble des solutions sous forme dâ€™intervalle(s),
          par exemple <code>]-oo;0[</code>, <code>[1;3]</code> ou <code>]-oo;-4]U[4;+oo[</code>.
        </li>
        <li>
          Pour lâ€™infini, on peut taper <code>oo</code>, <code>+oo</code>, <code>-oo</code> ou utiliser le symbole âˆž.
        </li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ====== Outils gÃ©nÃ©riques ====== */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function ensureTickAfter(el){
  let s = el?.nextElementSibling;
  if(!s || !s.classList?.contains('tick')){
    s = document.createElement('span');
    s.className = 'tick nu';
    el.insertAdjacentElement('afterend', s);
  }
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className = 'tick ' + state;
}
function typesetAll(root){
  const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{});
  if(MathJax?.startup?.promise){
    MathJax.startup.promise.then(run);
  }else{
    const t=setInterval(()=>{
      if(MathJax?.typesetPromise){ clearInterval(t); run(); }
    },60);
  }
}
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

/* Petit PGCD pour simplifier les fractions */
function gcd(a,b){
  a=Math.abs(a); b=Math.abs(b);
  while(b){ const t=b; b=a%b; a=t; }
  return a||1;
}
function fracTexSigned(num, den){
  if(den===0) return "\\text{indÃ©fini}";
  let n=num, d=den;
  const g=gcd(n,d); n/=g; d/=g;
  let sign = 1;
  if(n<0){ sign*=-1; n=-n; }
  if(d<0){ sign*=-1; d=-d; }
  if(d===1) return (sign<0?'-':'')+n;
  return (sign<0?'-':'')+`\\dfrac{${n}}{${d}}`;
}

/* ====== Parseur de nombre pour 1/x = y ======
   â€“ accepte :
     3, -4, 5/7, -6/7, 10^5, 10^-3, 1/10^5, 1/10^(-3), 1/(7/6)â€¦
*/
function parseValueInverse(raw){
  let s = (raw||"")
    .trim()
    .replace(/\u2212/g,"-")   // moins unicode
    .replace(/,/g,".")        // virgule -> point
    .replace(/\s+/g,"");

  if(!s) return NaN;

  // signe global
  let sign=1;
  if(s[0]==="+"){ s=s.slice(1); }
  else if(s[0]==="-"){ sign=-1; s=s.slice(1); }

  // 10^k ou 10^(k)
  let m = s.match(/^10\^\(?(-?\d+)\)?$/);
  if(m){
    const exp=parseInt(m[1],10);
    return sign * Math.pow(10, exp);
  }

  // 1/10^k ou 1/10^(k)
  m = s.match(/^1\/10\^\(?(-?\d+)\)?$/);
  if(m){
    const exp=parseInt(m[1],10);
    return sign * (1/Math.pow(10, exp));
  }

  // 1/(a/b) ou 1/(-a/b)
  m = s.match(/^1\/\(?(-?\d+)\/(\d+)\)?$/);
  if(m){
    const a=parseInt(m[1],10);
    const b=parseInt(m[2],10);
    if(!b) return NaN;
    // 1 / (a/b) = b/a
    return sign * (b/a);
  }

  // retirer parenthÃ¨ses globales Ã©ventuelles
  if(s[0]==="(" && s[s.length-1]===")"){
    s = s.slice(1,-1);
  }

  // fraction simple
  if(s.includes("/")){
    const [na,da]=s.split("/");
    const n=Number(na), d=Number(da);
    if(!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
    return sign * (n/d);
  }

  const v=Number(s);
  return Number.isNaN(v) ? NaN : sign*v;
}

/* ====== Parseur d'intervalles pour les inÃ©quations ====== */
function parseIntervals(txt){
  if(!txt) return null;
  let s = txt.trim();

  s = s
    .replace(/\s+/g,"")
    .replace(/\u2212/g,"-")
    .replace(/âˆž/g,"oo")
    .replace(/\\,/g,"")
    .replace(/\\;/g,"");

  s = s.replace(/âˆª/gi,"U").replace(/u/g,"U");

  const parts = s.split(/U+/).filter(Boolean);
  if(!parts.length) return null;

  const parseBound = (t)=>{
    if(!t) return NaN;
    t = t.trim().replace(/\u2212/g,"-");
    const low = t.toLowerCase().replace(/,/g,".");

    // infinis
    if(low==="oo" || low==="+oo" || low==="inf" || low==="+inf") return +Infinity;
    if(low==="âˆ’oo" || low==="--oo" || low==="-oo") return -Infinity;
    if(low==="-oo" || low==="-inf" || low==="-âˆž" || low==="-inf") return -Infinity;

    const v = Number(low);
    return Number.isFinite(v) ? v : NaN;
  };

  const intervals=[];
  for(const part of parts){
    if(part.length<4) return null;
    const L = part[0];
    const R = part[part.length-1];
    if(!"[]()".includes(L) || !"[]()".includes(R)) return null;

    const inside = part.slice(1,-1);
    const sepIdx = inside.indexOf(";")>=0 ? inside.indexOf(";") : inside.indexOf(",");
    if(sepIdx<0) return null;

    const aStr = inside.slice(0,sepIdx);
    const bStr = inside.slice(sepIdx+1);
    const a = parseBound(aStr);
    const b = parseBound(bStr);
    if(Number.isNaN(a) || Number.isNaN(b)) return null;
    if(Number.isFinite(a) && Number.isFinite(b) && a>b+1e-9) return null;

    // [a; b] : fermÃ©, ]a; b[ : ouvert
    const openL = (L==='(' || L===']'); // [ fermÃ© ; ] / ( ouverts
    const openR = (R===')' || R==='['); // ] fermÃ© ; [ / ) ouverts

    intervals.push({a,b,openL,openR});
  }

  intervals.sort((u,v)=>{
    if(u.a===v.a){
      if(u.b===v.b) return 0;
      return u.b<v.b ? -1 : 1;
    }
    return u.a<v.a ? -1 : 1;
  });

  return intervals;
}

function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;

  const { xmin, xmax, ymin, ymax } = opts;

  // nombre de carreaux par unitÃ© (x et y peuvent Ãªtre diffÃ©rents)
  const subDivX = opts.subDivX || 1;   // ex : 3, 4 ou 5
  const subDivY = opts.subDivY || 1;   // ici : 1

  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  // 1) Ã‰tendue en unitÃ©s
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;

  // 2) Taille d'un carreau en pixels (mÃªme pour x et y â†’ carrÃ©s)
  //    Rx * subDivX = nb total de carreaux horizontaux
  //    Ry * subDivY = nb total de carreaux verticaux
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );

  // px par unitÃ© en x / y
  const sX = cell * subDivX;
  const sY = cell * subDivY;

  // 3) Taille de la zone de tracÃ© en pixels
  const w = sX * Rx;
  const h = sY * Ry;

  // 4) Centrage de la fenÃªtre de tracÃ©
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;

  // 5) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
svg.setAttribute('width', W);
svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  // flÃ¨ches
  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  // clip plot
  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  // conversions unitÃ©s â†’ pixels
  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  // cadre
  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // position des axes
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  // grille + graduations
  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', 'âˆ’');

    // pas en unitÃ©s pour dessiner chaque carreau
    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    // verticales tous les 1/subDivX
    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      // graduation uniquement si xv entier
      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    // horizontales tous les 1/subDivY
    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  // axes flÃ©chÃ©s
  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  // inverses (si tu en as besoin ailleurs)
  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}


// utilitaires tracÃ©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}


/* =====================================================
   EXERCICE 1 â€” AntÃ©cÃ©dents pour 1/x
   (entier positif, entier nÃ©gatif, puissance de 10,
    fraction positive, fraction nÃ©gative)
   ===================================================== */
const ex1 = {
  id: "inverse_eq_table",
  title: "Ã‰quations du type \\(\\dfrac{1}{x}=y\\) et \\(\\dfrac{1}{ax+b}=k\\)",

  gen() {
    const gcd = (a,b)=>{
      a = Math.abs(a); b = Math.abs(b);
      while(b){ const t=b; b=a%b; a=t; }
      return a || 1;
    };

    const fracTexSigned = (num, den)=>{
      if(den===0) return "\\text{indÃ©fini}";
      let n=num, d=den;
      const g=gcd(n,d); n/=g; d/=g;
      let sign = 1;
      if(n<0){ sign*=-1; n=-n; }
      if(d<0){ sign*=-1; d=-d; }
      if(d===1) return (sign<0?'-':'')+n;
      return (sign<0?'-':'')+`\\dfrac{${n}}{${d}}`;
    };

    const affineDenTex = (a,b)=>{
      // Ã©crit ax+b joliment pour le dÃ©nominateur
      let s = "";
      if (a === 1) s = "x";
      else if (a === -1) s = "-x";
      else s = `${a}x`;
      if (b > 0) s += `+${b}`;
      else if (b < 0) s += `${b}`; // ex : -3
      return s;
    };

    // 1) Entier positif
    const genEntierPos = () => {
      const y = rint(1, 10);
      return {
        kind:"entPos",
        y,
        latex:`${y}`,
        eqTex:`\\dfrac{1}{x}=${y}`
      };
    };

    // 2) Entier nÃ©gatif
    const genEntierNeg = () => {
      const y = -rint(1, 10);
      return {
        kind:"entNeg",
        y,
        latex:`${y}`,
        eqTex:`\\dfrac{1}{x}=${y}`
      };
    };

    // 3) Puissance de 10 (exposants non nuls)
    const genPuiss10 = () => {
      const exp = choice([-5,-4,-3,-2,2,3,4,5]);
      const y = Math.pow(10, exp);
      const latex = `10^{${exp}}`;
      return {
        kind:"p10",
        y,
        exp,
        latex,
        eqTex:`\\dfrac{1}{x}=${latex}`
      };
    };

    // 4) Fraction positive
    const genFracPos = () => {
      let a,b;
      do {
        a = rint(1,9);
        b = rint(2,9);
      } while (gcd(a,b) !== 1);
      return {
        kind:"fracPos",
        y: a/b,
        a, b,
        latex: `\\dfrac{${a}}{${b}}`,
        eqTex: `\\dfrac{1}{x}=\\dfrac{${a}}{${b}}`
      };
    };

    // 5) Fraction nÃ©gative
    const genFracNeg = () => {
      let a,b;
      do {
        a = rint(1,9);
        b = rint(2,9);
      } while (gcd(a,b) !== 1);
      return {
        kind:"fracNeg",
        y: -a/b,
        a, b,
        latex: `-\\dfrac{${a}}{${b}}`,
        eqTex: `\\dfrac{1}{x}=-\\dfrac{${a}}{${b}}`
      };
    };

    // 6) 1/(ax+b) = k avec k entier
    const genAffineInt = () => {
      let a;
      do {
        a = rint(-5,5);
      } while (a === 0); // pas de a=0
      const b = rint(-5,5);
      let k;
      do {
        k = rint(-5,5);
      } while (k === 0); // k â‰  0

      const denTex = affineDenTex(a,b);
      const kTex = `${k}`;

      return {
        kind:"affInt",
        a, b,
        k,
        kTex,
        denTex,
        eqTex: `\\dfrac{1}{${denTex}}=${kTex}`
      };
    };

// 7) 1/(ax+b) = k avec k fraction (simple)
const genAffineFrac = () => {
  let a;
  do {
    a = rint(-5,5);
  } while (a === 0);
  const b = rint(-5,5);

  let p,q;
  do {
    p = rint(1,5);
    q = rint(2,5);
  } while (gcd(p,q) !== 1);
  // on autorise Â±p/q
  if (Math.random() < 0.5) p = -p;

  const denTex = affineDenTex(a,b);
  const kVal = p/q;

  const absP = Math.abs(p);
  const kTex = (p < 0)
    ? `-\\dfrac{${absP}}{${q}}`
    : `\\dfrac{${absP}}{${q}}`;

  return {
    kind:"affFrac",
    a, b,
    kNum: p,
    kDen: q,
    kVal,
    kTex,
    denTex,
    eqTex: `\\dfrac{1}{${denTex}}=${kTex}`
  };
};


    const items = [
      genEntierPos(),
      genEntierNeg(),
      genPuiss10(),
      genFracPos(),
      genFracNeg(),
      genAffineInt(),
      genAffineFrac()
    ];

    // mÃ©lange des lignes
    items.sort(()=>Math.random()-0.5);

    return { items };
  },


  render(host, st) {
    host.innerHTML = `
      <div>
        RÃ©soudre les Ã©quations suivantes.<br>
        <em>Sâ€™il nâ€™y a aucune solution rÃ©elle, Ã©crire \\(\\varnothing\\) ou Â« aucun Â».</em>
      </div>

      <div class="var-wrap" style="margin-top:.5rem">
        <table class="pdf-tbl fullgrid" style="width:100%;max-width:700px">
          <thead>
            <tr>
              <th>Ã‰quation</th>
              <th>Solution(s) rÃ©elle(s)</th>
            </tr>
          </thead>
          <tbody>
            ${st.items.map((it,i)=>`
              <tr>
                <td style="width:40%">\\(${it.eqTex}\\)</td>
                <td>
                  <input class="solx" data-i="${i}" type="text"
                         style="width:95%;max-width:280px;text-align:center">
                  <span class="tick nu"></span>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>
      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;
    host.querySelectorAll('input.solx').forEach(ensureTickAfter);
    typesetAll(host);
  },


  correct(host, st) {
    const norm = s => (s || "")
      .trim()
      .replace(/\u2212/g,"-")   // moins unicode
      .replace(/,/g,".")        // virgule â†’ point
      .replace(/\s+/g,"");      // espaces

    // parse nombre, fraction, 10^k, 1/10^k, 1/(a/b)
    const parseValue = raw => {
      let s = norm(raw);
      if (!s) return NaN;

      // cas "aucun", "âˆ…"...
      const low = s.toLowerCase();
      if (low === "aucun" || low === "aucune" || low === "Ã¸" || low === "âˆ…") {
        return NaN; // ici, aucune Ã©quation n'a S = âˆ…, donc ce sera faux
      }

      // signe global
      let sign = 1;
      if (s[0] === "+") {
        s = s.slice(1);
      } else if (s[0] === "-") {
        sign = -1;
        s = s.slice(1);
      }

      // --- 10^k ou 10^(k) ---
      let m = s.match(/^10\^\(?(-?\d+)\)?$/);
      if (m) {
        const exp = parseInt(m[1],10);
        return sign * Math.pow(10, exp);
      }

      // --- 1/10^k ou 1/10^(k) ---
      m = s.match(/^1\/10\^\(?(-?\d+)\)?$/);
      if (m) {
        const exp = parseInt(m[1],10);
        return sign * (1 / Math.pow(10, exp));
      }

      // --- 1/(a/b) ou 1/(-a/b) ---
      m = s.match(/^1\/\(?(-?\d+)\/(\d+)\)?$/);
      if (m) {
        const a = parseInt(m[1],10);
        const b = parseInt(m[2],10);
        if (!b) return NaN;
        // 1 / (a/b) = b/a
        return sign * (b / a);
      }

      // enlever Ã©ventuelles parenthÃ¨ses globales : (7/6)
      if (s[0] === "(" && s[s.length-1] === ")") {
        s = s.slice(1, -1);
      }

      // --- fraction classique a/b ---
      if (s.includes("/")) {
        const [na,da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        return sign * (n/d);
      }

      // --- nombre simple ---
      const v = Number(s);
      return Number.isNaN(v) ? NaN : sign * v;
    };

    let ok = 0, tot = 0;
    const eps = 1e-6;

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.solx[data-i="${i}"]`);
      if (!inp) return;

      const raw = inp.value.trim();
      if (!raw) {
        setTick(inp,"nu");
        return;
      }

      tot++;
      const x = parseValue(raw);

      let good = false;

      if (it.kind === "affInt" || it.kind === "affFrac") {
        if (!Number.isFinite(x)) {
          good = false;
        } else {
          const denom = it.a * x + it.b;
          if (Math.abs(denom) < eps) {
            good = false; // interdit : dÃ©nominateur nul
          } else {
            const left = 1 / denom;
            const right = (it.kind === "affInt") ? it.k : it.kVal;
            good = Math.abs(left - right) < eps;
          }
        }
      } else {
        if (!Number.isFinite(x) || x === 0) {
          good = false;
        } else {
          good = Math.abs(1/x - it.y) < eps;
        }
      }

      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    const box = $("#res",host);
    if (box) {
      box.innerHTML = ``;
    }

    return { ok, total: tot };
  },

solution(host, st) {
  const box = $("#res",host);

  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a||1; }

  function reduce(num,den){
    if (den<0){ den=-den; num=-num; }
    const g=gcd(num,den);
    return { num:num/g, den:den/g };
  }

  // Ã©criture d'une fraction avec signe propre (jamais de "--")
  function texFrac(num, den){
    let sign = '';
    if (num < 0){
      sign = '-';
      num = -num;
    }
    if (den < 0){
      den = -den;
      sign = (sign === '-' ? '' : '-');
    }
    if (den === 1) {
      return sign + String(num);
    }
    return `${sign}\\dfrac{${num}}{${den}}`;
  }

  // Ã©criture de aÂ·x sans jamais afficher 1x ni -1x
  function texAX(a, v='x'){
    if (a === 1)  return v;
    if (a === -1) return `-${v}`;
    return `${a}${v}`;
  }

function solTex(it){
  /* ===== CAS 1/x = y (inchangÃ©, pas de 1x ici) ===== */
  if (it.kind === "entPos" || it.kind === "entNeg" ||
      it.kind === "p10" || it.kind === "fracPos" || it.kind === "fracNeg") {

    if (it.kind === "entPos" || it.kind === "entNeg") {
      const y = it.y;
      let num = 1, den = y;
      if (den<0){ den=-den; num=-num; }
      const fr = reduce(num,den);
      const texX = texFrac(fr.num, fr.den);

      if (it.kind === "entPos") {
        return `
\\[
\\begin{aligned}
\\frac{1}{x} &= ${it.latex} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else {
        return `
\\[
\\begin{aligned}
\\frac{1}{x} &= ${it.latex} \\\\
x &= \\frac{1}{${it.latex}} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      }
    }

    if (it.kind === "p10") {
      const e = it.exp;
      return `
\\[
\\begin{aligned}
\\frac{1}{x} &= 10^{${e}} \\\\
x &= \\frac{1}{10^{${e}}} \\\\
x &= 10^{${-e}}
\\end{aligned}
\\]`;
    }

    // fractions Â±a/b
    if (it.kind === "fracPos" || it.kind === "fracNeg") {
      const a = it.a, b = it.b;
      const sign = (it.kind === "fracNeg") ? -1 : +1;
      let num = sign * b;
      let den = a;
      const fr = reduce(num,den);
      const texX = texFrac(fr.num, fr.den);

      return `
\\[
\\begin{aligned}
\\frac{1}{x} &= ${it.latex} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
    }
  }

  /* ===== CAS 1/(ax+b) = k avec k entier ===== */
  if (it.kind === "affInt") {
    const a = it.a;
    const b = it.b;
    const denTex = it.denTex;   // ax+b bien Ã©crit sans 1x/-1x
    const kTex  = it.kTex;
    const isPlusMinusOne = (it.k === 1 || it.k === -1);  // NOUVEAU

    // 1/k en fraction simplifiÃ©e (pour l'Ã©tape "denTex = 1/k")
    let num1 = 1;
    let den1 = it.k;
    const fr1 = reduce(num1,den1);
    const texInvK = texFrac(fr1.num, fr1.den);   // 1/k

    // x interdit : -b/a (ensemble de def)
    let exNum = -b;
    let exDen = a;
    const exFr = reduce(exNum, exDen);
    const texXforbid = texFrac(exFr.num, exFr.den);

    // numÃ©riquement pour la simplification finale
    let num2 = num1 - b*den1;   // 1/k - b
    let den2 = den1;
    const frS = reduce(num2, den2);
    const texSomme = texFrac(frS.num, frS.den);

    let numX = num2;
    let denX = den2 * a;
    const frX = reduce(numX, denX);
    const texX = texFrac(frX.num, frX.den);

    // Ã©criture propre de texInvK - b (jamais "--")
    let texInvKminusB;
    if (b > 0) {
      texInvKminusB = `${texInvK} - ${b}`;
    } else if (b < 0) {
      const bp = -b;
      texInvKminusB = `${texInvK} + ${bp}`;
    } else {
      texInvKminusB = `${texInvK}`;
    }

    // ligne avec aÂ·x sans jamais Ã©crire 1x ou -1x
    const texAXline = texAX(a,'x');

    let resolution;

    if (b === 0) {
      // ===== CAS B = 0 : on Ã©vite les lignes doublons =====
      if (a === 1) {
        // 1/x = k
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else if (a === -1) {
        // 1/(-x) = k
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvK} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else {
        // 1/(ax) = k avec |a| â‰  1
        if (isPlusMinusOne) {
          // CAS PARTICULIER k = Â±1 : PAS de ligne "Ã— 1/a"
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        } else {
          // CAS GÃ‰NÃ‰RAL
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
x &= ${texInvK}\\times \\dfrac{1}{${a}} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        }
      }
    } else {
      // ===== CAS GÃ‰NÃ‰RAL b â‰  0 =====
      if (a === 1) {
        // x + b = 1/k - b
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
x &= ${texInvKminusB} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else if (a === -1) {
        // -x + b = 1/k
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
${texAXline} &= ${texSomme} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else {
        // |a| â‰  1 : ax + b = 1/k, puis somme
        if (isPlusMinusOne) {
          // CAS PARTICULIER k = Â±1 : PAS de ligne "Ã— 1/a"
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
${texAXline} &= ${texSomme} \\\\
x &= \\dfrac{${texSomme}}{${a}} \\\\

x &= ${texX}
\\end{aligned}
\\]`;
        } else {
          // CAS GÃ‰NÃ‰RAL
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
${texAXline} &= ${texSomme} \\\\
x &= ${texSomme}\\times \\dfrac{1}{${a}} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        }
      }
    }

    return `
<table class="pdf-tbl fullgrid" style="width:100%">
  <tr>
    <th>Ensemble de dÃ©finition</th>
    <th>RÃ©solution de lâ€™Ã©quation</th>
  </tr>
  <tr>
    <td style="vertical-align:top;padding:4px 6px">
	On cherche la valeur interdite en rÃ©solvant : <br>
      \\[
      \\begin{aligned}
      ${denTex} &= 0 \\\\
      x &= ${texXforbid}
      \\end{aligned}
      \\]<br>
	  La solution ne pourra donc pas Ãªtre \\(${texXforbid}\\).
    </td>
    <td style="vertical-align:top;padding:4px 6px">
      ${resolution}
    </td>
  </tr>
</table>
`;
  }

  /* ===== CAS 1/(ax+b) = num/den fraction ===== */
  if (it.kind === "affFrac") {
    const a = it.a;
    const b = it.b;
    const denTex = it.denTex;
    const kTex  = it.kTex;

    // 1/k en fraction simplifiÃ©e
    let num1 = it.kDen;
    let den1 = it.kNum;
    const fr1 = reduce(num1,den1);
    const texInvK = texFrac(fr1.num, fr1.den);   // 1/k
    const isPlusMinusOne = (Math.abs(it.kNum) === 1);  // prÃªt si un jour tu gÃ©nÃ¨res Â±1 en fraction

    // x interdit : -b/a
    let exNum = -b;
    let exDen = a;
    const exFr = reduce(exNum, exDen);
    const texXforbid = texFrac(exFr.num, exFr.den);

    // numÃ©riquement pour la simplification finale
    let num2 = num1 - b*den1;   // 1/k - b
    let den2 = den1;
    const frS = reduce(num2, den2);
    const texSomme = texFrac(frS.num, frS.den);

    let numX = num2;
    let denX = den2 * a;
    const frX = reduce(numX, denX);
    const texX = texFrac(frX.num, frX.den);

    // Ã©criture propre de texInvK - b (jamais "--")
    let texInvKminusB;
    if (b > 0) {
      texInvKminusB = `${texInvK} - ${b}`;
    } else if (b < 0) {
      const bp = -b;
      texInvKminusB = `${texInvK} + ${bp}`;
    } else {
      texInvKminusB = `${texInvK}`;
    }

    const texAXline = texAX(a,'x');

    let resolution;

    if (b === 0) {
      // ===== CAS B = 0 =====
      if (a === 1) {
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else if (a === -1) {
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvK} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else {
        // 1/(ax) = k avec |a| â‰  1
        if (isPlusMinusOne) {
          // CAS k = Â±1 : pas de "Ã— 1/a"
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvK} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        } else {
          // CAS gÃ©nÃ©ral
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvK} \\\\
x &= ${texInvK}\\times \\dfrac{1}{${a}} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        }
      }
    } else {
      // ===== CAS GÃ‰NÃ‰RAL b â‰  0 =====
      if (a === 1) {
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else if (a === -1) {
        resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
${texAXline} &= ${texSomme} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      } else {
        // |a| â‰  1
        if (isPlusMinusOne) {
          // k = Â±1 : pas de "Ã— 1/a"
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
${texAXline} &= ${texSomme} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        } else {
          // CAS gÃ©nÃ©ral
          resolution = `
\\[
\\begin{aligned}
\\frac{1}{${denTex}} &= ${kTex} \\\\
${denTex} &= ${texInvK} \\\\
${texAXline} &= ${texInvKminusB} \\\\
${texAXline} &= ${texSomme} \\\\
x &= ${texSomme}\\times \\dfrac{1}{${a}} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
        }
      }
    }

    return `
<table class="pdf-tbl fullgrid" style="width:100%">
  <tr>
    <th>Ensemble de dÃ©finition</th>
    <th>RÃ©solution de lâ€™Ã©quation</th>
  </tr>
  <tr>
    <td style="vertical-align:top;padding:4px 6px">
	On cherche la valeur interdite en rÃ©solvant : <br>
      \\[
      \\begin{aligned}
      ${denTex} &= 0 \\\\
      x &= ${texXforbid}
      \\end{aligned}
      \\]<br>
	  La solution ne pourra donc pas Ãªtre \\(${texXforbid}\\).
    </td>
    <td style="vertical-align:top;padding:4px 6px">
      ${resolution}
    </td>
  </tr>
</table>
`;
  }

  return "";
}


  box.innerHTML = `
    <table class="pdf-tbl fullgrid" style="width:100%;max-width:750px">
      <thead>
        <tr>
          <th>Ã‰quation</th>
          <th>Correction</th>
        </tr>
      </thead>
      <tbody>
        ${st.items.map(it => `
          <tr>
            <td style="width:30%">\\(${it.eqTex}\\)</td>
            <td style="vertical-align:top;padding:6px 10px">
              ${solTex(it)}
            </td>
          </tr>
        `).join("")}
      </tbody>
    </table>
  `;

  typesetAll(box);
},


  reset(host){
    const box=$("#res",host);
    if(box) box.textContent="";
    host.querySelectorAll("input.solx").forEach(inp=>{
      inp.value="";
      setTick(inp,"nu");
    });
  }
};


const ex2 = {
  id: "ineq_inv_graph",
  title: "InÃ©quations du type 1/x â€¦ (lecture graphique)",

  /* ========= 1. GÃ©nÃ©ration de lâ€™Ã©noncÃ© ========= */
  gen() {
    // familles :
    // a) 1/x < ou â‰¤ (nÃ©gatif)
    // b) a < ou â‰¤ 1/x < ou â‰¤ b   avec 0<a<b
    // c) 1/x < ou â‰¤ (positif)
    // d) 1/x > ou â‰¥ (nÃ©gatif)
    // e) a < ou â‰¤ 1/x < ou â‰¤ b   avec a<b<0
    // f) 1/x > ou â‰¥ (positif)
    const kind = choice([
      "lt_neg",
      "between_pos",
      "lt_pos",
      "geq_neg",
      "between_neg",
      "geq_pos"
    ]);

    const data = { kind };

    // petit helper pour choisir strict / large
    const pickLtOp = () => (Math.random() < 0.5 ? "<" : "\\le");
    const pickGtOp = () => (Math.random() < 0.5 ? ">" : "\\ge");

    if (kind === "lt_neg") {
      const c = -rint(2, 9);       // -2 â€¦ -9
      const op = pickLtOp();       // "<" ou "\le"
      data.c = c;
      data.op = op;
      data.ineqTex = `\\dfrac{1}{x} ${op} ${c}`;

        } else if (kind === "between_pos") {
      // 0 < a < b
      let a, b;
      do {
        a = rint(1, 5);           // 1..5
        b = rint(2, 9);           // 2..9
      } while (b <= a);

      const ops = ["<", "\\le"];
      const opL = choice(ops);   // pour a ? 1/x
      const opR = choice(ops);   // pour 1/x ? b

      data.a = a;
      data.b = b;
      data.opL = opL;
      data.opR = opR;
      data.ineqTex = `${a} ${opL} \\dfrac{1}{x} ${opR} ${b}`;

    } else if (kind === "between_neg") {
      // a < b < 0
      let A, B;
      do {
        A = rint(1, 5);
        B = rint(2, 9);
      } while (B <= A);
      const a = -B;
      const b = -A;

      const ops = ["<", "\\le"];
      const opL = choice(ops);   // pour a ? 1/x
      const opR = choice(ops);   // pour 1/x ? b

      data.a = a;
      data.b = b;
      data.opL = opL;
      data.opR = opR;
      data.ineqTex = `${a} ${opL} \\dfrac{1}{x} ${opR} ${b}`;


    } else if (kind === "lt_pos") {
      const c = rint(1, 9);
      const op = pickLtOp();
      data.c = c;
      data.op = op;
      data.ineqTex = `\\dfrac{1}{x} ${op} ${c}`;

    } else if (kind === "geq_pos") {
      const c = rint(1, 9);
      const op = pickGtOp();      // ">" ou "\ge"
      data.c = c;
      data.op = op;
      data.ineqTex = `\\dfrac{1}{x} ${op} ${c}`;

    } else { // geq_neg
      const c = -rint(1, 9);
      const op = pickGtOp();
      data.c = c;
      data.op = op;
      data.ineqTex = `\\dfrac{1}{x} ${op} ${c}`;
    }

    return data;
  },

  /* ========= 2. Petit repÃ¨re avec belle courbe 1/x, SANS GRILLE ========= */

  buildSketch(st, showSolution) {
    // repÃ¨re sans grille
    const rep = buildRepereSVG({
      xmin: -5, xmax: 5,
      ymin: -5, ymax: 5,
      grid: false,
      arrows: true,
      subDivX: 3,
      subDivY: 3
    });

    const NS = rep.svg.namespaceURI;

    /* ===== 1) Courbe f(x) = 1/x (2 branches) ===== */

    let d1 = "";
    for (let x = -5; x <= -0.25; x += 0.02) {
      const Xp = rep.X(x), Yp = rep.Y(1 / x);
      d1 += (d1 ? " L " : "M ") + Xp + " " + Yp;
    }
    addPath(rep.plot, d1, { stroke: '#15803d', 'stroke-width': 2.4 });

    let d2 = "";
    for (let x = 0.25; x <= 5; x += 0.02) {
      const Xp = rep.X(x), Yp = rep.Y(1 / x);
      d2 += (d2 ? " L " : "M ") + Xp + " " + Yp;
    }
    addPath(rep.plot, d2, { stroke: '#15803d', 'stroke-width': 2.4 });

    /* ===== 2) Axes & positions verticales possibles ===== */

    const yAxisX = rep.X(0);      // axe des ordonnÃ©es
    const y0Axis = rep.Y(0);      // niveau de 0 (axe des abscisses)

    const offsetSmall = 25;
    const offsetmil  = 35;
    const offsetBig  = 70;

    const fmtLabel = (val) => (val < 0 ? "âˆ’" + Math.abs(val) : String(val));

    // groupe pour les labels dâ€™ordonnÃ©es (affichÃ©s seulement en solution)
    const gLabels = document.createElementNS(NS, "g");
    gLabels.setAttribute("class", "y-labels");
    rep.axes.appendChild(gLabels);

    const drawYMark = (yPix, txt, isNeg = false) => {
      const tick = document.createElementNS(NS, "line");
      tick.setAttribute("x1", yAxisX - 5);
      tick.setAttribute("x2", yAxisX + 5);
      tick.setAttribute("y1", yPix);
      tick.setAttribute("y2", yPix);
      tick.setAttribute("stroke", "#111");
      tick.setAttribute("stroke-width", "1.4");
      gLabels.appendChild(tick);

      const t = document.createElementNS(NS, "text");
      t.textContent = txt;

      if (isNeg) {
        // labels nÃ©gatifs Ã  DROITE de lâ€™axe
        t.setAttribute("x", yAxisX + 8);
        t.setAttribute("text-anchor", "start");
      } else {
        // 0 et positifs Ã  GAUCHE de lâ€™axe
        t.setAttribute("x", yAxisX - 8);
        t.setAttribute("text-anchor", "end");
      }

      t.setAttribute("y", yPix + 4);
      t.setAttribute("font-size", "12");
      gLabels.appendChild(t);
    };

    /* ===== 3) Outils pour la solution (traits, points, segments, abscisses) ===== */

    // horizontales BLEUES (comme les verticales), Ã  une hauteur pixel donnÃ©e
    const addHorizPix = (yPix, color = "#2563eb") => {
      const L = document.createElementNS(NS, "line");
      L.setAttribute("x1", rep.X(rep.xmin));
      L.setAttribute("x2", rep.X(rep.xmax));
      L.setAttribute("y1", yPix);
      L.setAttribute("y2", yPix);
      L.setAttribute("stroke", color);
      L.setAttribute("stroke-width", "1.6");
      L.setAttribute("stroke-dasharray", "5 4");
      rep.plot.appendChild(L);
    };

    // verticales BLEUES depuis lâ€™intersection jusquâ€™Ã  lâ€™axe
    const addVertPix = (x, yPix, color = "#2563eb") => {
      const L = document.createElementNS(NS, "line");
      L.setAttribute("x1", rep.X(x));
      L.setAttribute("x2", rep.X(x));
      L.setAttribute("y1", y0Axis);
      L.setAttribute("y2", yPix);
      L.setAttribute("stroke", color);
      L.setAttribute("stroke-width", "1.6");
      L.setAttribute("stroke-dasharray", "5 4");
      rep.plot.appendChild(L);
    };

    // point dâ€™intersection sur la courbe
    const addDotPix = (x, yPix) => {
      const c = document.createElementNS(NS, "circle");
      c.setAttribute("cx", rep.X(x));
      c.setAttribute("cy", yPix);
      c.setAttribute("r", 3.2);
      c.setAttribute("fill", "#111");
      rep.plot.appendChild(c);
    };

    // segment solution ROUGE sur lâ€™axe des abscisses
    const addXAxisSegment = (xa, xb) => {
      const L = document.createElementNS(NS, "line");
      L.setAttribute("x1", rep.X(xa));
      L.setAttribute("x2", rep.X(xb));
      L.setAttribute("y1", y0Axis);
      L.setAttribute("y2", y0Axis);
      L.setAttribute("stroke", "#b91c1c"); // rouge
      L.setAttribute("stroke-width", "3");
      rep.plot.appendChild(L);
    };

    // antÃ©cÃ©dents sur lâ€™axe des abscisses
    const gXLabels = document.createElementNS(NS, "g");
    gXLabels.setAttribute("class", "x-labels");
    rep.axes.appendChild(gXLabels);

    // entier simple (0, Ã©ventuellement Â±1)
    const drawXIntMark = (x, txt) => {
      const xp = rep.X(x);
      const tick = document.createElementNS(NS, "line");
      tick.setAttribute("x1", xp);
      tick.setAttribute("x2", xp);
      tick.setAttribute("y1", y0Axis - 5);
      tick.setAttribute("y2", y0Axis + 5);
      tick.setAttribute("stroke", "#111");
      tick.setAttribute("stroke-width", "1.4");
      gXLabels.appendChild(tick);

const t = document.createElementNS(NS, "text");
t.textContent = txt;

const isZero = (Math.abs(x) < 1e-9);
if (isZero) {
  // le 0 de lâ€™axe des abscisses, un peu Ã  DROITE de lâ€™axe vertical
  t.setAttribute("x", xp + 5);
  t.setAttribute("text-anchor", "start");
} else {
  t.setAttribute("x", xp);
  t.setAttribute("text-anchor", "middle");
}

t.setAttribute("y", y0Axis + 12);
t.setAttribute("font-size", "12");
gXLabels.appendChild(t);
    };

    // fraction empilÃ©e num/den (avec signe devant)
    // signRef sert Ã  savoir si on place la fraction au-dessus (signRef<0)
    // ou en dessous (signRef>0) de l'axe des abscisses
    const drawXFracMark = (x, num, den, signRef) => {
      const xp = rep.X(x);

      // signe global : devant la fraction
      let signTxt = '';
      if (signRef < 0) signTxt = 'âˆ’';

      // numÃ©rateur / dÃ©nominateur toujours positifs
      num = Math.abs(num);
      den = Math.abs(den);

      // petit tick centrÃ© sur l'axe
      const tick = document.createElementNS(NS, "line");
      tick.setAttribute("x1", xp);
      tick.setAttribute("x2", xp);
      tick.setAttribute("y1", y0Axis - 6);
      tick.setAttribute("y2", y0Axis + 6);
      tick.setAttribute("stroke", "#111");
      tick.setAttribute("stroke-width", "1.4");
      gXLabels.appendChild(tick);

      // positions verticales : dÃ©pend du signe
      let numY, barY, denY;
      if (signRef > 0) {
        // fraction ENTIEREMENT sous l'axe, un peu plus BAS
        numY = y0Axis + 20;
        barY = numY + 5;
        denY = barY + 10;
      } else {
        // fraction ENTIEREMENT AU-DESSUS de l'axe
        denY = y0Axis - 10;
        barY = denY - 10;
        numY = barY - 5;
      }

      // signe Ã  gauche de la fraction (centrÃ© verticalement)
      let dx = 0;
      if (signTxt) {
        const signY = (numY + denY) / 2;
        const ts = document.createElementNS(NS, "text");
        ts.textContent = signTxt;
        ts.setAttribute("x", xp - 10);
        ts.setAttribute("y", signY);
        ts.setAttribute("font-size", "12");
        ts.setAttribute("text-anchor", "middle");
        gXLabels.appendChild(ts);
        dx = 4; // lÃ©ger dÃ©calage de la fraction vers la droite
      }

      // numÃ©rateur
      const tNum = document.createElementNS(NS, "text");
      tNum.textContent = String(num);
      tNum.setAttribute("x", xp + dx);
      tNum.setAttribute("y", numY);
      tNum.setAttribute("font-size", "11");
      tNum.setAttribute("text-anchor", "middle");
      gXLabels.appendChild(tNum);

      // barre de fraction
      const bar = document.createElementNS(NS, "line");
      bar.setAttribute("x1", xp - 7 + dx);
      bar.setAttribute("x2", xp + 7 + dx);
      bar.setAttribute("y1", barY);
      bar.setAttribute("y2", barY);
      bar.setAttribute("stroke", "#111");
      bar.setAttribute("stroke-width", "1");
      gXLabels.appendChild(bar);

      // dÃ©nominateur
      const tDen = document.createElementNS(NS, "text");
      tDen.textContent = String(den);
      tDen.setAttribute("x", xp + dx);
      tDen.setAttribute("y", denY);
      tDen.setAttribute("font-size", "11");
      tDen.setAttribute("text-anchor", "middle");
      gXLabels.appendChild(tDen);
    };

    /* ===== 4) Mise en Ã©vidence de S si showSolution ===== */

    if (showSolution) {
      const Yi = rep.Yi;

      // positions des horizontales selon le type
      let y0 = y0Axis;
      let yC = null;
      let yA = null, yB = null;

      if (st.kind === "between_pos") {
        // 0 < a < b, deux niveaux fixes AU-DESSUS de 0
        yA = y0Axis - offsetSmall;  // plus prÃ¨s de 0 (a)
        yB = y0Axis - offsetBig;    // plus haut (b)
      } else if (st.kind === "between_neg") {
        // a < b < 0, deux niveaux fixes EN-DESSOUS de 0
        // yA : plus prÃ¨s de 0 (pour b)
        // yB : plus bas (pour a)
        yA = y0Axis + offsetSmall-5;
        yB = y0Axis + offsetBig;
      } else {
        const c = st.c;
        // c>0 : au-dessus ; c<0 : au-dessous
        yC = (c > 0) ? y0Axis - offsetmil : y0Axis + offsetmil;
      }

      // on NE marque pas 0 sur lâ€™axe des ordonnÃ©es, il sera indiquÃ© seulement sur lâ€™axe des abscisses
if (st.kind === "between_pos" || st.kind === "between_neg") {
  drawYMark(yA, fmtLabel(st.a), st.a < 0);
  drawYMark(yB, fmtLabel(st.b), st.b < 0);
} else {
  drawYMark(yC, fmtLabel(st.c), st.c < 0);
}


      if (st.kind === "lt_neg") {
        const valC = Yi(yC);
        const x0 = 1 / valC;

        addHorizPix(yC);
        addVertPix(x0, yC);
        addDotPix(x0, yC);

        addXAxisSegment(x0, 0);
        drawXIntMark(0, "0");
        if (Math.abs(st.c) === 1) {
          drawXIntMark(x0, st.c < 0 ? "âˆ’1" : "1");
        } else {
          drawXFracMark(x0, 1, st.c, st.c);
        }

      } else if (st.kind === "lt_pos") {
        const valC = Yi(yC);
        const x0 = 1 / valC;

        addHorizPix(yC);
        addVertPix(x0, yC);
        addDotPix(x0, yC);

        addXAxisSegment(rep.xmin, 0);
        addXAxisSegment(x0, rep.xmax);
        drawXIntMark(0, "0");
        if (Math.abs(st.c) === 1) {
          drawXIntMark(x0, st.c < 0 ? "âˆ’1" : "1");
        } else {
          drawXFracMark(x0, 1, st.c, st.c);
        }

      } else if (st.kind === "geq_neg") {
        const valC = Yi(yC);
        const x0 = 1 / valC;

        addHorizPix(yC);
        addVertPix(x0, yC);
        addDotPix(x0, yC);

        addXAxisSegment(rep.xmin, x0);
        addXAxisSegment(0,        rep.xmax);
        drawXIntMark(0, "0");
        if (Math.abs(st.c) === 1) {
          drawXIntMark(x0, st.c < 0 ? "âˆ’1" : "1");
        } else {
          drawXFracMark(x0, 1, st.c, st.c);
        }

      } else if (st.kind === "geq_pos") {
        const valC = Yi(yC);
        const x0 = 1 / valC;

        addHorizPix(yC);
        addVertPix(x0, yC);
        addDotPix(x0, yC);

        addXAxisSegment(0, x0);
        drawXIntMark(0, "0");
        if (Math.abs(st.c) === 1) {
          drawXIntMark(x0, "1");
        } else {
          drawXFracMark(x0, 1, st.c, st.c);
        }

      } else if (st.kind === "between_pos") {
        const valA = Yi(yA);   // pour a
        const valB = Yi(yB);   // pour b
        const x1 = 1 / valB;   // 1/b (plus Ã  gauche)
        const x2 = 1 / valA;   // 1/a (plus Ã  droite)

        addHorizPix(yA);
        addHorizPix(yB);

        addVertPix(x1, yB);
        addVertPix(x2, yA);

        addDotPix(x1, yB);
        addDotPix(x2, yA);

        addXAxisSegment(x1, x2);

        if (Math.abs(st.b) === 1) {
          drawXIntMark(x1, "1");
        } else {
          drawXFracMark(x1, 1, st.b, st.b);
        }

        if (Math.abs(st.a) === 1) {
          drawXIntMark(x2, "1");
        } else {
          drawXFracMark(x2, 1, st.a, st.a);
        }

      } else { // between_neg : a < b < 0
        // yA -> b, yB -> a
        const valB = Yi(yA);
        const valA = Yi(yB);
        const x1 = 1 / valB;   // 1/b (plus Ã  gauche)
        const x2 = 1 / valA;   // 1/a (plus Ã  droite)

        addHorizPix(yA);
        addHorizPix(yB);

        addVertPix(x1, yA);
        addVertPix(x2, yB);

        addDotPix(x1, yA);
        addDotPix(x2, yB);

        addXAxisSegment(x1, x2);

        if (Math.abs(st.b) === 1) {
          drawXIntMark(x1, "âˆ’1");
        } else {
          drawXFracMark(x1, 1, st.b, st.b);
        }

        if (Math.abs(st.a) === 1) {
          drawXIntMark(x2, "âˆ’1");
        } else {
          drawXFracMark(x2, 1, st.a, st.a);
        }
      }
    }

    return rep.svg;
  },

  /* ========= 3. Render ========= */
  render(host, st) {
    const { ineqTex } = st;

    host.innerHTML = `
      <div>
        Ã€ l'aide de la reprÃ©sentation graphique de la fonction inverse \\(f(x)=\\dfrac{1}{x}\\),
        dÃ©terminer l'<b>ensemble des solutions</b> de lâ€™inÃ©quation suivante.
      </div>

      <div style="margin-top:.35rem">
        <b>InÃ©quation :</b> \\(${ineqTex}\\)
      </div>

      <div class="graph" style="margin-top:.45rem">
        <div class="ineq-g"></div>
      </div>

      <div style="margin-top:.6rem">
        <div style="margin-top:.4rem;display:flex;flex-wrap:wrap;gap:8px;align-items:center">
          <span>Ensemble des solutions : \\(S =\\)</span>
          <input class="ineq-set" type="text"
                 style="width:260px;max-width:90%;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.7rem"></div>
    `;

    const box = host.querySelector('.ineq-g');
    // courbe "vierge" : seulement le repÃ¨re + 1/x
    box.appendChild(this.buildSketch(st, false));

    host.querySelectorAll('input.ineq-set').forEach(ensureTickAfter);
    typesetAll(host);
  },

  /* ========= 4. Correction : parseur dâ€™intervalles (avec fractions) ========= */
  correct(host, st) {
    const inp = host.querySelector('.ineq-set');
    const tickEl = inp ? ensureTickAfter(inp) : null;
    const raw = (inp?.value || "").trim();

    if (!raw) {
      if (tickEl) tickEl.className = "tick nu";
      return { ok: 0, total: 0 };
    }

    function parseIntervals(txt) {
      if (!txt) return null;
      let s = txt.trim();

      s = s
        .replace(/\s+/g, "")
        .replace(/\u2212/g, "-")
        .replace(/âˆž/g, "oo")
        .replace(/\\,/g, "")
        .replace(/\\;/g, "");

      s = s.replace(/âˆª/gi, "U").replace(/u/g, "U");

      const parts = s.split(/U+/).filter(Boolean);
      if (!parts.length) return null;

      const parseBound = (t) => {
        if (!t) return NaN;
        t = t.trim().replace(/\u2212/g, "-");

        let low = t.toLowerCase().replace(/,/g, ".");
        if (low === "-oo" || low === "-inf") return -Infinity;
        if (low === "oo" || low === "+oo" || low === "inf" || low === "+inf") return +Infinity;

        // signe global
        let sign = 1;
        if (t[0] === "+") {
          t = t.slice(1);
        } else if (t[0] === "-") {
          sign = -1;
          t = t.slice(1);
        }

        let core = t.trim();
        let coreLower = core.toLowerCase().replace(/,/g, ".");

        // rac / sqrt / âˆš
        coreLower = coreLower.replace(/^rac\(/, "sqrt(").replace(/âˆš/g, "sqrt(");

        if (coreLower.startsWith("sqrt")) {
          if (!coreLower.includes("(")) coreLower = coreLower.replace(/^sqrt/, "sqrt(") + ")";
          if (!coreLower.endsWith(")")) coreLower += ")";
          if (coreLower.startsWith("sqrt(") && coreLower.endsWith(")")) {
            const inside = coreLower.slice(5, -1);
            let base;
            if (inside.includes("/")) {
              const [na, da] = inside.split("/");
              const n = Number(na), d = Number(da);
              if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
              base = n / d;
            } else {
              base = Number(inside);
              if (Number.isNaN(base)) return NaN;
            }
            if (base < 0) return NaN;
            return sign * Math.sqrt(base);
          }
        }

        // fraction simple a/b
        if (coreLower.includes("/")) {
          const [na, da] = coreLower.split("/");
          const n = Number(na);
          const d = Number(da);
          if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
          return sign * (n / d);
        }

        const v = Number(coreLower);
        return Number.isFinite(v) ? sign * v : NaN;
      };

      const intervals = [];
      for (const part of parts) {
        if (part.length < 4) return null;

        const L = part[0];
        const R = part[part.length - 1];
        if (!"[]()".includes(L) || !"[]()".includes(R)) return null;

        const inside = part.slice(1, -1);
        const sepIdx = inside.indexOf(";") >= 0 ? inside.indexOf(";") : inside.indexOf(",");
        if (sepIdx < 0) return null;

        const aStr = inside.slice(0, sepIdx);
        const bStr = inside.slice(sepIdx + 1);

        const a = parseBound(aStr);
        const b = parseBound(bStr);
        if (Number.isNaN(a) || Number.isNaN(b)) return null;

        if (Number.isFinite(a) && Number.isFinite(b) && a > b + 1e-9) return null;

        const openL = (L === ']' || L === '(');
        const openR = (R === '[' || R === ')');

        intervals.push({ a, b, openL, openR });
      }

      intervals.sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      return intervals;
    }

    /* ---------- 2) Ensemble attendu ---------- */
    const EPS = 1e-6;

    const expected = (() => {
      if (st.kind === "lt_neg") {
        const c = st.c;      // c < 0
        const x0 = 1 / c;    // nÃ©gatif
        const strict = (st.op === "<");
        return [
          { a: x0, b: 0, openL: strict, openR: true }   // (ou [)1/c ; 0[
        ];
      }
      if (st.kind === "lt_pos") {
        const c = st.c;
        const x0 = 1 / c;
        const strict = (st.op === "<");
        return [
          { a: -Infinity, b: 0, openL: true, openR: true }, // ]-oo ; 0[
          { a: x0, b: +Infinity, openL: strict, openR: true } // ]ou[1/c ; +oo[
        ];
      }
      if (st.kind === "geq_neg") {
        const c = st.c;
        const x0 = 1 / c;
        const strict = (st.op === ">");
        return [
          { a: -Infinity, b: x0, openL: true, openR: strict }, // ]-oo ; 1/c] ou [
          { a: 0,        b: +Infinity, openL: true, openR: true } // ]0 ; +oo[
        ];
      }
      if (st.kind === "geq_pos") {
        const c = st.c;
        const x0 = 1 / c;
        const strict = (st.op === ">");
        return [
          { a: 0, b: x0, openL: true, openR: strict } // ]0 ; 1/c] ou [
        ];
      }
            if (st.kind === "between_pos") {
        const a = st.a, b = st.b;
        const x1 = 1 / b;
        const x2 = 1 / a;

        const opL = st.opL || "<";
        const opR = st.opR || "<";

        const openL = (opR === "<"); // 1/b inclus si 1/x â‰¤ b
        const openR = (opL === "<"); // 1/a inclus si a â‰¤ 1/x

        return [
          { a: x1, b: x2, openL, openR }
        ];
      }
      // between_neg : a<b<0
      if (st.kind === "between_neg") {
        const a = st.a, b = st.b;
        const x1 = 1 / b;
        const x2 = 1 / a;

        const opL = st.opL || "<";
        const opR = st.opR || "<";

        const openL = (opR === "<");
        const openR = (opL === "<");

        return [
          { a: x1, b: x2, openL, openR }
        ];
      }

    })();

    const got = parseIntervals(raw);
    let ok = 0, tot = 1;
    let good = false;

    if (got && got.length === expected.length) {
      const numEq = (x, y) => {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return x === y;
        return Math.abs(x - y) < EPS;
      };
      const expSorted = expected.slice().sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      good = true;
      for (let i = 0; i < got.length; i++) {
        const g = got[i];
        const e = expSorted[i];
        if (!numEq(g.a, e.a) || !numEq(g.b, e.b) ||
            g.openL !== e.openL || g.openR !== e.openR) {
          good = false;
          break;
        }
      }
    }

    if (tickEl) tickEl.className = "tick " + (good ? "ok" : "ko");
    if (good) ok = 1;

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">
          On lit graphiquement les abscisses oÃ¹ la courbe de \\(f(x)=\\dfrac1x\\)
          coupe la (ou les) droite(s) horizontale(s) correspondant aux valeur(s)
          indiquÃ©e(s) sur lâ€™axe des ordonnÃ©es, puis on utilise le fait que \\(f\\)
          dÃ©croÃ®t strictement sur \\(]-\\infty;0[\\) et sur \\(]0;+\\infty[\\)
          pour Ã©crire lâ€™ensemble des solutions sous forme dâ€™intervalle(s).
        </div>
      `;
      typesetAll(box);
    }

    return { ok, total: tot };
  },

  /* ========= 5. Solution : mÃªme dessin avec traits + segment(s) ========= */
  solution(host, st) {
    const fracTex = (num, den) => {
      const g = (a, b) => {
        a = Math.abs(a); b = Math.abs(b);
        while (b) { const t = b; b = a % b; a = t; }
        return a || 1;
      };
      if (den === 0) return "\\text{indÃ©fini}";
      let n = num, d = den;
      const g0 = g(n, d);
      n /= g0; d /= g0;
      if (d === 1) return `${n}`;
      return `\\dfrac{${n}}{${d}}`;
    };

    const kind = st.kind;
    let solTex = "";

    if (kind === "lt_neg") {
      const c = st.c;
      const num = 1, den = -c; // -c>0
      const left = (st.op === "<") ? "]" : "["; // strict ou large cÃ´tÃ© 1/c
      solTex = `
\\[
\\dfrac{1}{x} ${st.op} ${c}
\\]
<br>
\\[
S = \\big${left}-${fracTex(num,den)};0\\big[
\\]`;

    } else if (kind === "lt_pos") {
      const c = st.c;
      const num = 1, den = c;
      const left2 = (st.op === "<") ? "]" : "["; // strict ou large Ã  1/c
      solTex = `
\\[
\\dfrac{1}{x} ${st.op} ${c}
\\]
<br>
\\[
S = ]-\\infty;0[\\cup\\big${left2}${fracTex(num,den)};+\\infty\\big[
\\]`;

    } else if (kind === "geq_neg") {
      const c = st.c;
      const num = 1, den = -c;
      const right = (st.op === ">") ? "[" : "]"; // strict ou large sur 1/c
      solTex = `
\\[
\\dfrac{1}{x} ${st.op} ${c}
\\]
<br>
\\[
S = ]-\\infty;-${fracTex(num,den)}${right}\\cup]0;+\\infty[
\\]`;

    } else if (kind === "geq_pos") {
      const c = st.c;
      const num = 1, den = c;
      const right = (st.op === ">") ? "[" : "]"; // strict ou large Ã  1/c
      solTex = `
\\[
\\dfrac{1}{x} ${st.op} ${c}
\\]
<br>
\\[
S = \\big]0;${fracTex(num,den)}\\big${right}
\\]`;

        } else if (kind === "between_pos") {
      const a = st.a, b = st.b;
      const x1 = fracTex(1, b);
      const x2 = fracTex(1, a);

      const opL = st.opL || "<";
      const opR = st.opR || "<";

      // crochets Ã  la franÃ§aise : ]a;b[ ouvert / [a;b] fermÃ©
      const leftBracket  = (opR === "<") ? "]" : "[";
      const rightBracket = (opL === "<") ? "[" : "]";

      solTex = `
\\[
${a} ${opL} \\dfrac{1}{x} ${opR} ${b}
\\]
<br>
\\[
S = \\big${leftBracket}${x1};${x2}\\big${rightBracket}
\\]`;


       } else { // between_neg
      const a = st.a, b = st.b;   // a<b<0
      const X1 = fracTex(1, -b);  // >0
      const X2 = fracTex(1, -a);  // >0

      const opL = st.opL || "<";
      const opR = st.opR || "<";

      const leftBracket  = (opR === "<") ? "]" : "[";
      const rightBracket = (opL === "<") ? "[" : "]";

      solTex = `
\\[
${a} ${opL} \\dfrac{1}{x} ${opR} ${b}
\\]
<br>
\\[
S = \\big${leftBracket}-${X1};-${X2}\\big${rightBracket}
\\]`;
    }


    const gHost = host.querySelector('.ineq-g');
    if (gHost) {
      gHost.innerHTML = "";
      gHost.appendChild(this.buildSketch(st, true));
    }

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">
        </div>
        <div class="step" style="margin-top:.4rem">
          <div class="graph" style="margin-bottom:.5rem">
            <div class="ineq-sol-graph"></div>
          </div>
          ${solTex}
        </div>
      `;

      const solG = box.querySelector('.ineq-sol-graph');
      if (solG) {
        solG.appendChild(this.buildSketch(st, true));
      }
    }
    typesetAll(box);
  },

  /* ========= 6. Reset ========= */
  reset(host) {
    const box = $("#res", host);
    if (box) box.textContent = "";
    const inp = host.querySelector('.ineq-set');
    if (inp) {
      inp.value = "";
      setTick(inp, "nu");
    }
    const gHost = host.querySelector('.ineq-g');
    if (gHost) gHost.innerHTML = "";
  }
};



/* ====== Registre & UI ====== */
const REGISTRY=[ex1,ex2];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if(window.ExoPDF && typeof ExoPDF.init==='function'){
    ExoPDF.init({
      title:'Seconde â€“ Fonction inverse â€“ Ã‰quations et inÃ©quations',
      mountAfterSelector:'.card.small',
    });
  }else{
    setTimeout(waitExoPDF,50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value);
  const host=$("#host");
  const st=def.gen();
  host.dataset.active=def.id;
  host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host); } }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value);
  const host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value);
  const host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value);
  const host=$("#host");
  def.reset(host);
  scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY
    .map((ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`)
    .join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();
})();
</script>
</body>
</html>
