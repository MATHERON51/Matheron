<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Fonction inverse - Parit√© et hyperbole</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* √©crase le gras inline sur les z√©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }


/* Variante "grille compl√®te" pour les tableaux d'images f(x) */
table.pdf-tbl.fullgrid{
  border-collapse:collapse;
  border-spacing:0;
}

table.pdf-tbl.fullgrid th,
table.pdf-tbl.fullgrid td{
  border:1.5px solid #000;      /* toutes les bordures visibles */
  padding:8px 10px;
}
.graph svg.grid{
  width:100%;
  height:auto;
}


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Fonction inverse - Parit√© et hyperbole</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;


function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;

  const { xmin, xmax, ymin, ymax } = opts;

  // nombre de carreaux par unit√© (x et y peuvent √™tre diff√©rents)
  const subDivX = opts.subDivX || 1;   // ex : 3, 4 ou 5
  const subDivY = opts.subDivY || 1;   // ici : 1

  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  // 1) √âtendue en unit√©s
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;

  // 2) Taille d'un carreau en pixels (m√™me pour x et y ‚Üí carr√©s)
  //    Rx * subDivX = nb total de carreaux horizontaux
  //    Ry * subDivY = nb total de carreaux verticaux
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );

  // px par unit√© en x / y
  const sX = cell * subDivX;
  const sY = cell * subDivY;

  // 3) Taille de la zone de trac√© en pixels
  const w = sX * Rx;
  const h = sY * Ry;

  // 4) Centrage de la fen√™tre de trac√©
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;

  // 5) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
svg.setAttribute('width', W);
svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  // fl√®ches
  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  // clip plot
  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  // conversions unit√©s ‚Üí pixels
  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  // cadre
  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // position des axes
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  // grille + graduations
  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', '‚àí');

    // pas en unit√©s pour dessiner chaque carreau
    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    // verticales tous les 1/subDivX
    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      // graduation uniquement si xv entier
      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    // horizontales tous les 1/subDivY
    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  // axes fl√©ch√©s
  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  // inverses (si tu en as besoin ailleurs)
  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}


// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}


function gcdInt(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a||1; }
function lcmInt(a,b){ return a / gcdInt(a,b) * b; }




const ex1 = {
  id: "trace_carre_reperes",
  title: "Tracer la fonction inverse dans un rep√®re",

gen() {
  // 3, 4 ou 5 carreaux par unit√© en abscisse
  const subDivX = choice([3,4,5]);
  const k = subDivX;

  // abscisse rationnelle x = ¬± a/k, |x| ‚â• ~1,2 pour rester loin de 0
  let a;
  do {
    a = rint(6, 3 * k);      // 6 .. 3k ‚Üí x entre ~1,2 et 3
  } while (a % k === 0);     // pas multiple de k

  const sign  = choice([-1, 1]);
  const xImg  = sign * (a / k);
  const yImg  = 1 / xImg;    // image par la fonction inverse

  // On veut un ant√©c√©dent de signe OPPOS√â √† l'image :
  // image < 0 ‚Üí ant√©c√©dent > 0
  // image > 0 ‚Üí ant√©c√©dent < 0
  const targetAnteSign = (yImg < 0) ? +1 : -1;

  let yAnte, xAnte;
  do {
    const n = rint(1, 4);          // 1,2,3 ou 4
    yAnte = targetAnteSign * n;    // signe impos√©
    xAnte = 1 / yAnte;
  } while (
    Math.abs(yAnte - yImg) < 0.5 ||   // √©viter un y trop proche de yImg
    Math.abs(xAnte) > 3.8             // ant√©c√©dent doit rester dans [-4 ; 4]
  );

  return {
    subDivX,
    k,
    a,
    sign,
    xImg,
    yImg,
    yAnte,
    points: [],
    imagePlaced: false,
    antePlaced: false
  };
},


  render(host, st) {
    const Itex = "[-4 ;4]"; // domaine graphiquement exploit√©
    const subDivX = st.subDivX || 3;
    const k       = st.k || subDivX;
    const a       = st.a;
    const sign    = st.sign;
    const xImg    = st.xImg;
    const yImg    = st.yImg;
    const yAnte   = st.yAnte;
    const xAnte   = 1 / yAnte;

    const fracTex = (sign < 0)
      ? `-\\dfrac{${a}}{${k}}`
      : `\\dfrac{${a}}{${k}}`;

    const decFR = x => String(x).replace('.',',');

    host.innerHTML = `
      <ol style="margin:0 0 .4rem 1.2rem;padding:0">
        <li>Dans le rep√®re ci-dessous, repr√©senter graphiquement sur \\(${Itex}\\) la fonction inverse d√©finie par :
            \\( f(x) = \\dfrac{1}{x} \\) .</li>
        <li>En laissant appara√Ætre les traits de construction, indiquer graphiquement&nbsp;:
          <ul style="margin:.3rem 0 .2rem 1.2rem">
            <li>comment d√©terminer l'image de \\(${fracTex}\\)&nbsp;;</li>
            <li>comment d√©terminer l‚Äôant√©c√©dent de \\(${decFR(yAnte)}\\).</li>
          </ul>
        </li>
      </ol>

      <div style="margin-top:.4rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label>3.a) L‚Äôant√©c√©dent de \\(${decFR(yAnte)}\\) est :</label>
          <input class="q3a" type="text" style="width:140px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div style="margin-top:.4rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label>3.b) Ce nombre est solution de l‚Äô√©quation :</label>
          <input class="q3b" type="text" style="width:200px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div class="graph" style="margin-top:.8rem">
        <div id="rep-trace-carre"></div>
      </div>

      <div style="text-align:center;margin-top:.4rem">
        <button type="button" class="btn btn-trace" disabled>Tracer la courbe</button>
        <button type="button" class="btn btn-clear">Enlever les points</button>
        <span class="pt-info" style="margin-left:.5rem;font-size:.9rem">
          Points plac√©s : 0
        </span>
      </div>

      <div style="text-align:center;margin-top:.3rem">
        <button type="button" class="btn btn-img">Placer l'image</button>
        <button type="button" class="btn btn-ante">Placer l'ant√©c√©dent</button>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    // ======= Construction du rep√®re =======
    const mount = $("#rep-trace-carre", host);
    const rep = buildRepereSVG({
      xmin: -4, xmax: 4,
      ymin: -6, ymax: 6,
      grid: true,
      arrows: true,
      subDivX: subDivX, // 3, 4 ou 5 carreaux / unit√© en x
      subDivY: 2        // 1 carreau / unit√© en y
    });
    mount.appendChild(rep.svg);
    // ======================================

    // √©tat interne
    st.points      = Array.isArray(st.points) ? st.points : [];
    st.imagePlaced = !!st.imagePlaced;
    st.antePlaced  = !!st.antePlaced;

    function syncState(){
      const light = {
        subDivX: st.subDivX,
        k:       st.k,
        a:       st.a,
        sign:    st.sign,
        xImg:    st.xImg,
        yImg:    st.yImg,
        yAnte:   st.yAnte,
        points:  st.points,
        imagePlaced: st.imagePlaced,
        antePlaced:  st.antePlaced
      };
      $("#host").dataset.state = JSON.stringify(light);
    }
    syncState();

    const svg      = rep.svg;
    const btnTrace = $(".btn-trace", host);
    const btnClear = $(".btn-clear", host);
    const btnImg   = $(".btn-img", host);
    const btnAnte  = $(".btn-ante", host);
    const ptInfo   = $(".pt-info", host);

// pas "commun" : multiples de 1/subDivX ET des quarts (1/4, 1/2, 3/4, ‚Ä¶)
const stepX = 1 / lcmInt(subDivX, 4);
    let mode   = "points";           // "points" | "img" | "ante"

    const gPoints = [];

    function updateInfo(){
      ptInfo.textContent = "Points plac√©s : " + st.points.length;
      btnTrace.disabled = st.points.length < 5;
    }
    updateInfo();

    // input ticks
    host.querySelectorAll("input.q3a,input.q3b").forEach(ensureTickAfter);

    // --- cr√©ation d‚Äôun point cliquable sur la courbe ---
    function addGraphPoint(x, y){
      const c = document.createElementNS(svg.namespaceURI,"circle");
      c.setAttribute("cx", rep.X(x));
      c.setAttribute("cy", rep.Y(y));
      c.setAttribute("r", 3);
      c.setAttribute("class","g-pt");
      rep.plot.appendChild(c);

      const pt = { x, y };
      st.points.push(pt);
      gPoints.push({ x, y, el: c });

      c.addEventListener("click", ev => {
        ev.stopPropagation();
        st.points = st.points.filter(p =>
          Math.abs(p.x - x) > 1e-9 || Math.abs(p.y - y) > 1e-9
        );
        const idx = gPoints.findIndex(p =>
          Math.abs(p.x - x) < 1e-9 && Math.abs(p.y - y) < 1e-9
        );
        if (idx >= 0) gPoints.splice(idx,1);
        c.remove();
        updateInfo();
        syncState();
      });

      updateInfo();
      syncState();
    }

    // --- bouton "Enlever les points" ---
    btnClear.addEventListener("click", () => {
      st.points = [];
      gPoints.splice(0, gPoints.length);
      rep.plot.querySelectorAll("circle.g-pt").forEach(c => c.remove());
      updateInfo();
      syncState();
    });

    // --- boutons de mode "image" / "ant√©c√©dent" ---
    btnImg.addEventListener("click", () => { mode = "img"; });
    btnAnte.addEventListener("click", () => { mode = "ante"; });

    // --- clic dans la zone du rep√®re ---
    rep.hit.addEventListener("click", e => {
      const rect = svg.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;

      const xReal = rep.Xi(px);
      const yReal = rep.Yi(py);

      // ------- MODE : Placer l'image -------
      if (mode === "img") {
        if (Math.abs(yReal - 0) <= 0.3 && Math.abs(xReal - xImg) <= 0.2) {
          const v = document.createElementNS(svg.namespaceURI,'line');
          v.setAttribute('x1', rep.X(xImg));
          v.setAttribute('x2', rep.X(xImg));
          v.setAttribute('y1', rep.Y(0));
          v.setAttribute('y2', rep.Y(yImg));
          v.setAttribute('stroke', '#1d4ed8');
          v.setAttribute('stroke-width', '1.8');
          v.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(v);

          const h = document.createElementNS(svg.namespaceURI,'line');
          h.setAttribute('x1', rep.X(0));
          h.setAttribute('x2', rep.X(xImg));
          h.setAttribute('y1', rep.Y(yImg));
          h.setAttribute('y2', rep.Y(yImg));
          h.setAttribute('stroke', '#1d4ed8');
          h.setAttribute('stroke-width', '1.8');
          h.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(h);

          st.imagePlaced = true;
          syncState();
        }
        mode = "points";
        return;
      }

      // ------- MODE : Placer l'ant√©c√©dent -------
      if (mode === "ante") {
        const tolY = 0.2;

        if (Math.abs(xReal - 0) <= 0.3 && Math.abs(yReal - yAnte) <= tolY) {
          const h = document.createElementNS(svg.namespaceURI,'line');
          h.setAttribute('x1', rep.X(0));
          h.setAttribute('x2', rep.X(xAnte));
          h.setAttribute('y1', rep.Y(yAnte));
          h.setAttribute('y2', rep.Y(yAnte));
          h.setAttribute('stroke', '#b91c1c');
          h.setAttribute('stroke-width', '1.8');
          h.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(h);

          const v = document.createElementNS(svg.namespaceURI,'line');
          v.setAttribute('x1', rep.X(xAnte));
          v.setAttribute('x2', rep.X(xAnte));
          v.setAttribute('y1', rep.Y(0));
          v.setAttribute('y2', rep.Y(yAnte));
          v.setAttribute('stroke', '#b91c1c');
          v.setAttribute('stroke-width', '1.8');
          v.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(v);

          st.antePlaced = true;
          syncState();
        }
        mode = "points";
        return;
      }

      // ------- MODE : Points de la courbe (trac√© de f(x)=1/x) -------
      const idxX  = Math.round(xReal / stepX);
// pas plus flexible : 0.5 pr√®s
const xSnap = idxX * stepX;

if (xSnap < -4 - 1e-9 || xSnap > 4 + 1e-9) return;

      if (Math.abs(xSnap) < 1e-6) return;  // pas de point en x=0 (asymptote)

      const yTarget = 1 / xSnap;
      if (yTarget < -5 || yTarget > 5) return;
      if (Math.abs(xReal - xSnap) > 0.2) return;
      if (Math.abs(yReal - yTarget) > 0.4) return;

      // toggle : si un point existe d√©j√† tr√®s proche, on le supprime
      const existing = gPoints.find(p =>
        Math.abs(p.x - xSnap) < stepX/2 &&
        Math.abs(p.y - yTarget) < 0.5
      );
      if (existing) {
        existing.el.remove();
        st.points = st.points.filter(p =>
          Math.abs(p.x - existing.x) > 1e-9 || Math.abs(p.y - existing.y) > 1e-9
        );
        const i2 = gPoints.indexOf(existing);
        if (i2 >= 0) gPoints.splice(i2,1);
        updateInfo();
        syncState();
        return;
      }

      addGraphPoint(xSnap, yTarget);
    });

    // bouton "Tracer la courbe" : on trace y = 1/x (deux branches)
btnTrace.addEventListener("click", () => {
  if (btnTrace.disabled) return;

  const xMin = rep.xmin;
  const xMax = rep.xmax;
  const yMax = rep.ymax;

  // on choisit un x "proche de 0" tel que 1/x ‚âà yMax
  const eps = 1 / yMax;            // ici ‚âà 1/6 ‚âÉ 0,166...

  // --- branche gauche ---
  let d = "";
  for (let x = xMin; x <= -eps; x += 0.03){
    const Xp = rep.X(x);
    const Yp = rep.Y(1/x);
    d += (d ? " L " : "M ") + Xp + " " + Yp;
  }
  addPath(rep.plot, d, { stroke:"#111", "stroke-width":2.2 });

  // --- branche droite ---
  let d2 = "";
  for (let x = eps; x <= xMax; x += 0.03){
    const Xp = rep.X(x);
    const Yp = rep.Y(1/x);
    d2 += (d2 ? " L " : "M ") + Xp + " " + Yp;
  }
  addPath(rep.plot, d2, { stroke:"#111", "stroke-width":2.2 });

  btnTrace.disabled = true;
});


    typesetAll(host);
  },

  correct(host, st) {
    const yAnte = st.yAnte;   // le nombre dont on cherche l‚Äôant√©c√©dent pour f(x)=1/x

    const norm = s => (s || "")
      .trim()
      .replace(/\s+/g,"")
      .replace(/\u2212/g,"-")   // moins unicode
      .replace(/,/g,".")        // virgule ‚Üí point
      .toLowerCase();

    // parse un nombre ou une fraction
    const parseNumberOrFrac = s => {
      s = norm(s);
      if (!s) return null;
      if (s.includes("/")) {
        const [na, da] = s.split("/");
        const n = parseFloat(na), d = parseFloat(da);
        if (!d || isNaN(n) || isNaN(d)) return null;
        return n / d;
      }
      const v = parseFloat(s);
      return isNaN(v) ? null : v;
    };

    // 3.b : tol√©rer "1/x = yAnte" ou "x = 1/yAnte" ou "y = yAnte"
    const checkEqInput = sel => {
      const inp = host.querySelector(sel);
      if (!inp) return { ok:false, counted:false };
      const raw = inp.value;
      if (!raw.trim()) { setTick(inp,"nu"); return {ok:false,counted:false}; }

      const s = norm(raw);
      const parts = s.split("=");
      if (parts.length !== 2) { setTick(inp,"ko"); return {ok:false,counted:true}; }

      const left = parts[0], right = parts[1];
      let good = false;

      // cas 1 : 1/x = yAnte
      if (left === "1/x") {
        const val = parseNumberOrFrac(right);
        if (val !== null && Math.abs(val - yAnte) < 1e-6) good = true;
      }

      // cas 2 : x = 1/yAnte
      if (left === "x") {
        const val = parseNumberOrFrac(right);
        if (val !== null && Math.abs(1/val - yAnte) < 1e-6) good = true;
      }

      // cas 3 : y = yAnte (on accepte aussi "y = ...")
      if (left === "y") {
        const val = parseNumberOrFrac(right);
        if (val !== null && Math.abs(val - yAnte) < 1e-6) good = true;
      }

      setTick(inp, good ? "ok" : "ko");
      return { ok:good, counted:true };
    };

    let ok = 0, tot = 0;

    // ========= 3a) ant√©c√©dent UNIQUE =========
    {
      const inp = host.querySelector(".q3a");
      if (inp) {
        const raw = inp.value.trim();
        if (!raw) {
          setTick(inp,"nu");
        } else {
          tot++;
          const v = parseNumberOrFrac(raw);
          let good = false;
          if (v !== null && Math.abs(1/v - yAnte) < 1e-6) {
            good = true;
          }
          setTick(inp, good ? "ok" : "ko");
          if (good) ok++;
        }
      }
    }

    // ========= 3b) √âQUATION =========
    {
      const r = checkEqInput(".q3b");
      if (r.counted) { tot++; if (r.ok) ok++; }
    }

    // ========= PARTIE GRAPHIQUE (points + traits) =========
    // 1 point si ‚â• 5 points sur la courbe
    if (Array.isArray(st.points)) {
      tot++;
      if (st.points.length >= 5) ok++;
    }
    // 1 point si image ET ant√©c√©dent plac√©s
    tot++;
    if (st.imagePlaced && st.antePlaced) ok++;

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">
          <b>Partie graphique :</b>
          ${st.points.length >= 5 ? "‚úì" : "‚úó"} au moins 5 points correctement plac√©s sur l‚Äôhyperbole,
          ${st.imagePlaced && st.antePlaced ? "‚úì" : "‚úó"} traits de construction de l'image et de l‚Äôant√©c√©dent plac√©s.
        </div>
      `;
    }

    return { ok, total: tot };
  },

  solution(host, st) {
  const Itex = "[-4\\,;\\,-1] \\cup [1\\,;\\,4]";

  const subDivX = st.subDivX || 3;
  const k       = st.k || subDivX;
  const a       = st.a;
  const sign    = st.sign;
  const xImg    = st.xImg;
  const yImg    = st.yImg;
  const yAnte   = st.yAnte;
  const xAnte   = 1 / yAnte;

  const antePos        = (yAnte > 0);
  const isAntePlusOne  = Math.abs(xAnte - 1)  < 1e-9;
  const isAnteMinusOne = Math.abs(xAnte + 1)  < 1e-9;

  const fracTex = (sign < 0)
    ? `-\\dfrac{${a}}{${k}}`
    : `\\dfrac{${a}}{${k}}`;

  const decFR = x => String(x).replace('.',',');

  function texFromNumberFr(x) {
    const rounded = Math.round(x * 10) / 10;
    const s = String(rounded);
    if (s.includes(".")) {
      const [A, B] = s.split(".");
      return `${A}{,}${B}`;
    }
    return s;
  }

  const yAnteTex = texFromNumberFr(yAnte);

  // image exacte : f(a/k) = 1/(¬±a/k) = ¬±k/a
  const numImg = k;
  const denImg = a;
  const fracImgOrd = (sign < 0)
    ? `-\\dfrac{${numImg}}{${denImg}}`
    : `\\dfrac{${numImg}}{${denImg}}`;

  // 3.a : bloc TeX adapt√© pour x = 1 ou x = -1
  const eqStepTex = (
    isAntePlusOne ? `
      \\[
        \\dfrac{1}{x} = ${decFR(yAnte)}
        \\quad \\Longleftrightarrow \\quad
        x = 1.
      \\]
    ` : isAnteMinusOne ? `
      \\[
        \\dfrac{1}{x} = ${decFR(yAnte)}
        \\quad \\Longleftrightarrow \\quad
        x = -1.
      \\]
    ` : `
      \\[
        \\dfrac{1}{x} = ${decFR(yAnte)}
        \\quad \\Longleftrightarrow \\quad
        x = \\dfrac{1}{${decFR(yAnte)}}.
      \\]
    `
  );

  const box = $("#res", host);
  box.innerHTML = `
    <div class="step">
      <b>1.</b> Courbe repr√©sentative de \\(f(x)=\\dfrac{1}{x}\\) sur \\(${Itex}\\), avec traits de construction :
      <div class="graph" style="margin-top:.4rem">
        <div id="rep-trace-carre-sol"></div>
      </div>
    </div>
    <div class="step" style="margin-top:.6rem">
      <b>2.a)</b> Pour d√©terminer \\(f\\left(${fracTex}\\right)\\), on place \\(${fracTex}\\) sur l'axe des abscisses,
      on monte ou descend verticalement jusqu'√† la courbe, puis on lit l'ordonn√©e du point obtenu :
      \\[
        f\\left(${fracTex}\\right)
        = \\dfrac{1}{${fracTex}}
        = ${fracImgOrd}.
      \\]
    </div>
    <div class="step">
      <b>2.b)</b> Pour d√©terminer l‚Äôant√©c√©dent de \\(${decFR(yAnte)}\\), on trace la droite horizontale d'ordonn√©e
      \\(${decFR(yAnte)}\\) ; elle coupe la courbe en un seul point. On lit son abscisse sur l'axe :
      c‚Äôest l‚Äôant√©c√©dent cherch√©.
    </div>
    <div class="step">
      <b>3.a)</b> L‚Äôant√©c√©dent ${antePos ? "positif" : "n√©gatif"} de \\(${decFR(yAnte)}\\) est le nombre \\(x\\) tel que
      \\(\\dfrac{1}{x} = ${decFR(yAnte)}\\). On obtient :
      ${eqStepTex}
    </div>
    <div class="step">
      <b>3.b)</b> Ce nombre est donc solution de l'√©quation
      \\[
        \\dfrac{1}{x} = ${decFR(yAnte)}.
      \\]      
    </div>
  `;

  // ----- Rep√®re de la solution : m√™me subDivX que dans le render -----
  const mount = $("#rep-trace-carre-sol", box);
  mount.style.position = "relative";

  const rep = buildRepereSVG({
    xmin: -4, xmax: 4,
    ymin: -6, ymax: 6,
    grid: true,
    arrows: true,
    subDivX: subDivX,
    subDivY: 2          // 2 carreaux / unit√© en ordonn√©e
  });
  mount.appendChild(rep.svg);

  // ----- Courbe f(x) = 1/x (deux branches) -----
  const xMin = rep.xmin;
  const xMax = rep.xmax;
  const yMax = rep.ymax;
  const eps  = 1 / (yMax * 1.05);   // proche de 0 pour atteindre ¬±6

  // branche gauche
  let d = "";
  for (let x = xMin; x <= -eps; x += 0.03){
    const Xp = rep.X(x), Yp = rep.Y(1/x);
    d += (d ? " L " : "M ") + Xp + " " + Yp;
  }
  addPath(rep.plot, d, { stroke:'#111', 'stroke-width':2.2 });

  // branche droite
  let d2 = "";
  for (let x = eps; x <= xMax; x += 0.03){
    const Xp = rep.X(x), Yp = rep.Y(1/x);
    d2 += (d2 ? " L " : "M ") + Xp + " " + Yp;
  }
  addPath(rep.plot, d2, { stroke:'#111', 'stroke-width':2.2 });

  // =========================
  //  Traits de construction
  // =========================

  // --- 1) Image de xImg : traits en BLEU ---
  (function drawImageConstruction(){
    const x = xImg;
    const y = yImg;

    const v = document.createElementNS(rep.svg.namespaceURI,'line');
    v.setAttribute('x1', rep.X(x));
    v.setAttribute('x2', rep.X(x));
    v.setAttribute('y1', rep.Y(0));
    v.setAttribute('y2', rep.Y(y));
    v.setAttribute('stroke', '#1d4ed8');
    v.setAttribute('stroke-width', '1.8');
    v.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(v);

    const h = document.createElementNS(rep.svg.namespaceURI,'line');
    h.setAttribute('x1', rep.X(0));
    h.setAttribute('x2', rep.X(x));
    h.setAttribute('y1', rep.Y(y));
    h.setAttribute('y2', rep.Y(y));
    h.setAttribute('stroke', '#1d4ed8');
    h.setAttribute('stroke-width', '1.8');
    h.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(h);
  })();

  // --- 2) Ant√©c√©dent de yAnte : traits en ROUGE ---
  (function drawAnteConstruction(){
    const y = yAnte;
    const x = xAnte;

    const h = document.createElementNS(rep.svg.namespaceURI,'line');
    h.setAttribute('x1', rep.X(0));
    h.setAttribute('x2', rep.X(x));
    h.setAttribute('y1', rep.Y(y));
    h.setAttribute('y2', rep.Y(y));
    h.setAttribute('stroke', '#b91c1c');
    h.setAttribute('stroke-width', '1.8');
    h.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(h);

    const v = document.createElementNS(rep.svg.namespaceURI,'line');
    v.setAttribute('x1', rep.X(x));
    v.setAttribute('x2', rep.X(x));
    v.setAttribute('y1', rep.Y(0));
    v.setAttribute('y2', rep.Y(y));
    v.setAttribute('stroke', '#b91c1c');
    v.setAttribute('stroke-width', '1.8');
    v.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(v);
  })();

  // =========================
  //  OVERLAY HTML AVEC VRAI LaTeX
  // =========================
  (function addLatexOverlay(){
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.pointerEvents = 'none';
    mount.appendChild(overlay);

    function addLabel(tex, xData, yData, opts = {}){
      const span = document.createElement('span');
      span.className = 'latex-overlay-label';
      span.style.position = 'absolute';
      span.style.fontSize = '12px';
      span.style.pointerEvents = 'none';
      span.innerHTML = `\\(${tex}\\)`;

      const pt = rep.svg.createSVGPoint();
      pt.x = rep.X(xData);
      pt.y = rep.Y(yData);
      const screen = pt.matrixTransform(rep.svg.getScreenCTM());

      const rect = mount.getBoundingClientRect();
      let x = screen.x - rect.left + (opts.offsetX || 0);
      let y = screen.y - rect.top  + (opts.offsetY || 0);

      span.style.left = x + 'px';
      span.style.top  = y + 'px';

      if (opts.align === 'below-center') {
        span.style.transform = 'translate(-50%, 0)';
      } else if (opts.align === 'above-center') {
        span.style.transform = 'translate(-50%, -100%)';
      } else if (opts.align === 'right-middle') {
        span.style.transform = 'translate(0, -50%)';
      }

      overlay.appendChild(span);
    }

    // 1) Abscisse de l‚Äôimage : ¬±a/k
    const fracImgTex = (sign < 0)
      ? `-\\dfrac{${a}}{${k}}`
      : `\\dfrac{${a}}{${k}}`;
    addLabel(fracImgTex, xImg, 0, {
      align: 'below-center',
      offsetY: 4
    });

    // 2) Ordonn√©e de l‚Äôimage : ¬±k/a √† droite de l‚Äôaxe des ordonn√©es
    addLabel(fracImgOrd, 0, yImg, {
      align: 'right-middle',
      offsetX: 6
    });

    // 3) Ant√©c√©dent de yAnte : x = 1/yAnte, au-dessus de l‚Äôaxe des abscisses
    let anteLabelTex;
    if (isAntePlusOne) {
      anteLabelTex = "1";
    } else if (isAnteMinusOne) {
      anteLabelTex = "-1";
    } else {
      anteLabelTex = `\\dfrac{1}{${yAnteTex}}`;
    }

    addLabel(anteLabelTex, xAnte, 0, {
      align: 'above-center',
      offsetY: -4
    });
  })();

  typesetAll(box);
},


  reset(host) {
    const box = $("#res", host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.q3a,input.q3b").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });

    const mount = $("#rep-trace-carre", host);
    if (mount) {
      mount.querySelectorAll("circle.g-pt").forEach(c => c.remove());
    }
    const s = JSON.parse(host.dataset.state || '{}');
    s.points = [];
    host.dataset.state = JSON.stringify(s);
  }
};


const ex2 = {
  id: "antecedents_carre", // tu peux garder l'id ou le renommer si tu veux
  title: "Ant√©c√©dents par la fonction inverse",

  gen() {
    const gcd = (a,b)=>{
      a = Math.abs(a); b = Math.abs(b);
      while(b){ const t=b; b=a%b; a=t; }
      return a || 1;
    };

    // 1) Entier positif
    const genEntierPos = () => {
      const y = rint(1, 10);
      return { kind:"entPos", y, latex:`${y}` };
    };

    // 2) Entier n√©gatif
    const genEntierNeg = () => {
      const y = -rint(1, 10);
      return { kind:"entNeg", y, latex:`${y}` };
    };

    // 3) Puissance de 10 (exposants non nuls)
    const genPuiss10 = () => {
      const exp = choice([-5,-4,-3,-2,2,3,4,5]);
      const y = Math.pow(10, exp);      // valeur num√©rique (pour le check)
      const latex = `10^{${exp}}`;
      return { kind:"p10", y, exp, latex };
    };

    // 4) Fraction positive
    const genFracPos = () => {
      let a,b;
      do {
        a = rint(1,9);
        b = rint(2,9);
      } while (gcd(a,b) !== 1);
      return {
        kind:"fracPos",
        y: a/b,
        a, b,
        latex: `\\dfrac{${a}}{${b}}`
      };
    };

    // 5) Fraction n√©gative
    const genFracNeg = () => {
      let a,b;
      do {
        a = rint(1,9);
        b = rint(2,9);
      } while (gcd(a,b) !== 1);
      return {
        kind:"fracNeg",
        y: -a/b,
        a, b,
        latex: `-\\dfrac{${a}}{${b}}`
      };
    };

    const items = [
      genEntierPos(),
      genEntierNeg(),
      genPuiss10(),
      genFracPos(),
      genFracNeg()
    ];

    // m√©lange des lignes
    items.sort(()=>Math.random()-0.5);

    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>
        On consid√®re la fonction inverse \\(f(x)=\\dfrac{1}{x}\\).
        Pour chacun des nombres suivants, donner <b>un ant√©c√©dent r√©el</b> par \\(f\\).<br>
        Autrement dit, on cherche \\(x\\) tel que \\(\\dfrac{1}{x}=y\\).<br>
        <em>√âcrire la r√©ponse sous forme de nombre ou de fraction (par exemple : \\(\\tfrac{2}{3}\\)).</em>
      </div>

      <div class="var-wrap" style="margin-top:.5rem">
        <table class="pdf-tbl fullgrid" style="width:100%;max-width:650px">
          <thead>
            <tr>
              <th>Nombre \\(y\\)</th>
              <th>Ant√©c√©dent r√©el \\(x\\) tel que \\(\\dfrac{1}{x}=y\\)</th>
            </tr>
          </thead>
          <tbody>
            ${st.items.map((it,i)=>`
              <tr>
                <td style="width:35%">\\(${it.latex}\\)</td>
                <td>
                  <input class="ante" data-i="${i}" type="text"
                         style="width:95%;max-width:280px;text-align:center">
                  <span class="tick nu"></span>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ante').forEach(ensureTickAfter);
    typesetAll(host);
  },

correct(host, st) {
  const norm = s => (s || "")
    .trim()
    .replace(/\u2212/g,"-")   // moins unicode
    .replace(/,/g,".")        // virgule ‚Üí point
    .replace(/\s+/g,"");      // espaces

  // parse nombre, fraction, 10^k, 1/10^k, 1/(a/b)
  const parseValue = raw => {
    let s = norm(raw);
    if (!s) return NaN;

    // signe global
    let sign = 1;
    if (s[0] === "+") {
      s = s.slice(1);
    } else if (s[0] === "-") {
      sign = -1;
      s = s.slice(1);
    }

    // --- 10^k ou 10^(k) ---
    let m = s.match(/^10\^\(?(-?\d+)\)?$/);
    if (m) {
      const exp = parseInt(m[1],10);
      return sign * Math.pow(10, exp);
    }

    // --- 1/10^k ou 1/10^(k) ---
    m = s.match(/^1\/10\^\(?(-?\d+)\)?$/);
    if (m) {
      const exp = parseInt(m[1],10);
      return sign * (1 / Math.pow(10, exp));
    }

    // --- 1/(a/b) ou 1/(-a/b) ---
    // ex : -1/(7/6), 1/(7/5)
    m = s.match(/^1\/\(?(-?\d+)\/(\d+)\)?$/);
    if (m) {
      const a = parseInt(m[1],10);  // num√©rateur de y
      const b = parseInt(m[2],10);  // d√©nominateur de y
      if (!b) return NaN;
      // 1 / (a/b) = b/a
      return sign * (b / a);
    }

    // enlever d‚Äô√©ventuelles parenth√®ses globales : (7/6)
    if (s[0] === "(" && s[s.length-1] === ")") {
      s = s.slice(1, -1);
    }

    // --- fraction classique a/b ---
    if (s.includes("/")) {
      const [na,da] = s.split("/");
      const n = Number(na), d = Number(da);
      if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
      return sign * (n/d);
    }

    // --- nombre simple ---
    const v = Number(s);
    return Number.isNaN(v) ? NaN : sign * v;
  };

  let ok = 0, tot = 0;

  st.items.forEach((it,i)=>{
    const inp = host.querySelector(`input.ante[data-i="${i}"]`);
    if (!inp) return;

    const raw = inp.value.trim();
    if (!raw) {
      setTick(inp,"nu");
      return;
    }

    tot++;
    const x = parseValue(raw);
    if (!Number.isFinite(x) || x === 0) {
      setTick(inp,"ko");
      return;
    }

    const eps = 1e-6;
    const good = Math.abs(1/x - it.y) < eps;

    setTick(inp, good ? "ok" : "ko");
    if (good) ok++;
  });

  const box = $("#res",host);
  if (box) {
    box.innerHTML = ``;
  }

  return { ok, total: tot };
},

  solution(host, st) {
    const box = $("#res",host);

    // outils fractions exactes
    function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a||1; }

    function reduce(num,den){
      if (den<0){ den=-den; num=-num; }
      const g = gcd(num,den);
      return { num:num/g, den:den/g };
    }

function texFrac(num, den){
  // signe s√©par√© pour √©crire - devant la fraction
  let sign = '';
  if (num < 0){
    sign = '-';
    num = -num;
  }
  if (den < 0){
    // au cas o√π : on remonte le signe dans num
    den = -den;
    sign = (sign === '-' ? '' : '-');
  }

  if (den === 1) {
    return sign + String(num);        // entier : -3, 5, ...
  }
  // fraction : -\dfrac{7}{4}
  return `${sign}\\dfrac{${num}}{${den}}`;
}


    function solTex(it){
      // cas par cas pour construire x = 1/y sous forme fraction & puissance de 10
      if (it.kind === "entPos") {
        const y = it.y;            // entier (¬±)
        let num = 1, den = y;      // 1/y
        if (den<0){ den=-den; num=-num; }
        const fr = reduce(num,den);
        const texX = texFrac(fr.num, fr.den);

        return `
\\[
\\begin{aligned}
\\frac{1}{x} &= ${it.latex} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      }
	  
	      if (it.kind === "entNeg") {
        const y = it.y;            // entier (¬±)
        let num = 1, den = y;      // 1/y
        if (den<0){ den=-den; num=-num; }
        const fr = reduce(num,den);
        const texX = texFrac(fr.num, fr.den);

        return `
\\[
\\begin{aligned}
\\frac{1}{x} &= ${it.latex} \\\\
x &= \\frac{1}{${it.latex}} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      }  
	  

      if (it.kind === "p10") {
        const e = it.exp;          // exposant de 10
        // x = 1 / 10^e = 10^{-e}
        return `
\\[
\\begin{aligned}
\\frac{1}{x} &= 10^{${e}} \\\\
x &= \\frac{1}{10^{${e}}} \\\\
x &= 10^{${-e}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "fracPos" || it.kind === "fracNeg") {
        const a = it.a, b = it.b;           // y = ¬± a/b
        const sign = (it.kind === "fracNeg") ? -1 : +1;

        // 1 / (sign * a/b) = (1 / (sign)) * (b/a) = sign * (b/a)
        let num = sign * b;
        let den = a;
        const fr = reduce(num,den);
        const texX = texFrac(fr.num, fr.den);

        // On garde la forme de y telle qu‚Äô√©crite dans latex (¬±a/b)
        return `
\\[
\\begin{aligned}
\\frac{1}{x} &= ${it.latex} \\\\
x &= ${texX}
\\end{aligned}
\\]`;
      }

      // par s√©curit√© (ne devrait pas arriver)
      return "";
    }

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;max-width:750px">
        <thead>
          <tr>
            <th>Nombre \\(y\\)</th>
            <th>Correction</th>
          </tr>
        </thead>
        <tbody>
          ${st.items.map(it => `
            <tr>
              <td style="width:30%">\\(${it.latex}\\)</td>
              <td style="vertical-align:top;padding:6px 10px">
                ${solTex(it)}
              </td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;

    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ante").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Fonction inverse - Parit√© et hyperbole',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
