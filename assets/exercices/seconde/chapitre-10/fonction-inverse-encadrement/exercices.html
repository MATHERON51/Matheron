<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Fonction inverse ‚Äì Encadrement</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* √©crase le gras inline sur les z√©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }


/* Variante "grille compl√®te" pour les tableaux d'images f(x) */
table.pdf-tbl.fullgrid{
  border-collapse:collapse;
  border-spacing:0;
}

table.pdf-tbl.fullgrid th,
table.pdf-tbl.fullgrid td{
  border:1.5px solid #000;      /* toutes les bordures visibles */
  padding:8px 10px;
}
.graph svg.grid{
  width:100%;
  height:auto;
}
/* DOUBLE BARRE ‚Äì cellule de discontinuit√© */
table.pdf-tbl td.dbar::before,
table.pdf-tbl td.dbar::after {
  content:'';
  position:absolute;
  top:-1.5px;
  bottom:-1.5px;
  width:0;
  border-left:2px solid #000;
}

table.pdf-tbl td.dbar::before { left:35%; }
table.pdf-tbl td.dbar::after  { left:65%; }


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Fonction inverse ‚Äì Encadrement</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, √©crire une liste. Exemple : -3;2</li>
        <li><b>R√©ponse attendue dans l'exercice 3:</b> √©crire l‚Äôensemble des solutions sous forme
        d‚Äôintervalle(s), par exemple :
        <div style="margin-top:4px;margin-left:10px">
           [-2;2] ou ]-oo;-4]U[4;+oo[.
        </div></li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;


function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;

  const { xmin, xmax, ymin, ymax } = opts;

  // nombre de carreaux par unit√© (x et y peuvent √™tre diff√©rents)
  const subDivX = opts.subDivX || 1;   // ex : 3, 4 ou 5
  const subDivY = opts.subDivY || 1;   // ici : 1

  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  // 1) √âtendue en unit√©s
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;

  // 2) Taille d'un carreau en pixels (m√™me pour x et y ‚Üí carr√©s)
  //    Rx * subDivX = nb total de carreaux horizontaux
  //    Ry * subDivY = nb total de carreaux verticaux
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );

  // px par unit√© en x / y
  const sX = cell * subDivX;
  const sY = cell * subDivY;

  // 3) Taille de la zone de trac√© en pixels
  const w = sX * Rx;
  const h = sY * Ry;

  // 4) Centrage de la fen√™tre de trac√©
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;

  // 5) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
svg.setAttribute('width', W);
svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  // fl√®ches
  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  // clip plot
  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  // conversions unit√©s ‚Üí pixels
  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  // cadre
  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // position des axes
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  // grille + graduations
  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', '‚àí');

    // pas en unit√©s pour dessiner chaque carreau
    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    // verticales tous les 1/subDivX
    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      // graduation uniquement si xv entier
      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    // horizontales tous les 1/subDivY
    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  // axes fl√©ch√©s
  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  // inverses (si tu en as besoin ailleurs)
  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}


// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}



/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 3 : encadrement de la fonction inverse sur un intervalle (avec ¬±‚àû) ‚Äî‚Äî‚Äî‚Äî‚Äî */

const ex1 = {
  id: "encadrement_inverse_interval",
  title: "Encadrement de la fonction inverse sur un intervalle",

  gen() {
    // 4 types √©quiprobables :
    //  - posFin : [a;b] avec 0 < a < b
    //  - negFin : [a;b] avec a < b < 0
    //  - posInf : [a; +‚àû[
    //  - negInf : ]-‚àû; b]
    const r = Math.random();
    let type, a, b;

    if (r < 0.25) {
      // [a;b] enti√®rement positif
      type = "posFin";
      a = rint(1, 5);
      b = rint(a + 1, Math.min(a + 4, 9));
    } else if (r < 0.5) {
      // [a;b] enti√®rement n√©gatif
      type = "negFin";
      const A = rint(1, 5);
      const B = rint(A + 1, Math.min(A + 4, 9));
      b = -A;
      a = -B; // a < b < 0
    } else if (r < 0.75) {
      // [a; +‚àû[
      type = "posInf";
      a = rint(1, 5);
      b = null; // pas utilis√© mais gard√© pour homog√©n√©it√©
    } else {
      // ]-‚àû; b]
      type = "negInf";
      b = -rint(1, 5);
      a = null;
    }

    return { type, a, b };
  },

  render(host, st) {
    const { type, a, b } = st;

    // Texte de l'intervalle I
    let Itex;
    if (type === "posFin" || type === "negFin") {
      Itex = `[${a}\\,;\\,${b}]`;
    } else if (type === "posInf") {
      Itex = `[${a}\\,;\\,+\\infty[`;
    } else { // "negInf"
      Itex = `]-\\infty\\,;\\,${b}]`;
    }

    // Ligne x du tableau
    const rowX = (() => {
      if (type === "posFin" || type === "negFin") {
        return `
  <tr>
    <th>\\(x\\)</th>
    <td style="text-align:left;padding-left:10px">\\(${a}\\)</td>
    <td></td>
    <td style="text-align:right;padding-right:10px">\\(${b}\\)</td>
  </tr>`;
      } else if (type === "posInf") {
        return `
  <tr>
    <th>\\(x\\)</th>
    <td style="text-align:left;padding-left:10px">\\(${a}\\)</td>
    <td></td>
    <td style="text-align:right;padding-right:10px">\\(+\\infty\\)</td>
  </tr>`;
      } else { // "negInf"
        return `
  <tr>
    <th>\\(x\\)</th>
    <td style="text-align:left;padding-left:10px">\\(-\\infty\\)</td>
    <td></td>
    <td style="text-align:right;padding-right:10px">\\(${b}\\)</td>
  </tr>`;
      }
    })();

    // Cl√©s pour data-x dans les cases de f :
    //  - "a" num√©rique
    //  - "b" num√©rique
    //  - "inf" pour +‚àû
    //  - "minf" pour -‚àû
    let leftKey, rightKey;
    if (type === "posFin" || type === "negFin") {
      leftKey = String(a);
      rightKey = String(b);
    } else if (type === "posInf") {
      leftKey = String(a);
      rightKey = "inf";
    } else { // "negInf"
      leftKey = "minf";
      rightKey = String(b);
    }

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        <td>
          <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
            <input class="ymax" data-x="${leftKey}" type="text" style="width:80px;text-align:center">
            <input class="ymin" data-x="${leftKey}" type="text" style="width:80px;text-align:center">
          </div>
        </td>
        <td class="bigsel">
          <select class="dir" data-i="1"
                  style="display:block;width:100%;height:100%">
            <option value=""></option>
            <option>‚Üò</option>
            <option>‚Üó</option>
          </select>
        </td>
        <td>
          <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
            <input class="ymax" data-x="${rightKey}" type="text" style="width:80px;text-align:center">
            <input class="ymin" data-x="${rightKey}" type="text" style="width:80px;text-align:center">
          </div>
        </td>
      </tr>`;

    // Bloc encadrement suivant le type
    let encadrementHTML;
    if (type === "posFin" || type === "negFin") {
      // cas fini : m ‚â§ 1/x ‚â§ M
      encadrementHTML = `
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> Compl√©ter l'encadrement : pour tout \\(x \\in ${Itex}\\),</label>
          <input class="qInf" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <span>\\(\\leq \\dfrac{1}{x} \\leq\\)</span>
          <input class="qSup" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
        </div>`;
    } else if (type === "posInf") {
      // [a; +‚àû[ : 0 < 1/x ‚â§ M
      encadrementHTML = `
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> Compl√©ter l'encadrement : pour tout \\(x \\in ${Itex}\\),</label>
          <span>\\(0 < \\dfrac{1}{x} \\leq\\)</span>
          <input class="qSup" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
        </div>`;
    } else {
      // ]-‚àû; b] : m ‚â§ 1/x < 0
      encadrementHTML = `
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> Compl√©ter l'encadrement : pour tout \\(x \\in ${Itex}\\),</label>
          <input class="qInf" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <span>\\(\\leq \\dfrac{1}{x} < 0\\)</span>
        </div>`;
    }

    host.innerHTML = `
      <div><b>1.</b> Donner le <b>tableau de variations</b> de la fonction inverse d√©finie par : \\(f(x)=\\dfrac{1}{x}\\) sur \\(${Itex}\\).</div>

      <div class="var-wrap" style="margin-top:.6rem">
        <table class="var frame-only pdf-hide">
          <tbody>
            ${rowX}
            ${rowF}
          </tbody>
        </table>
      </div>

      <div style="margin-top:.6rem">
        ${encadrementHTML}
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ymax,input.ymin,input.qInf,input.qSup,select.dir')
        .forEach(ensureTickAfter);

    typesetAll(host);
  },

  correct(host, st) {
    const { type, a, b } = st;

    const norm = s => (s || "").trim().replace(/\u2212/g, "-").replace(/,/g, ".");
    const num  = s => {
      const t = norm(s);
      if (!t) return null;
      if (t.includes("/")) {
        const [na,da] = t.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return null;
        return n/d;
      }
      const v = Number(t);
      return Number.isFinite(v) ? v : null;
    };

    // R√©f√©rences max/min sur I pour 1/x (d√©croissante sur chaque intervalle ne contenant pas 0)
    // Cas finis : [a;b]
    //   max en x=a, min en x=b
    // Cas posInf : [a;+‚àû[
    //   max en x=a, min = 0 (limite en +‚àû)
    // Cas negInf : ]-‚àû;b]
    //   max = 0 (limite en -‚àû), min en x=b
    const hasPosInf = (type === "posInf");
    const hasNegInf = (type === "negInf");
    const finite = (type === "posFin" || type === "negFin");

    let ok = 0, tot = 0;

    // --- 1) Tableau : cases de f (ymax / ymin) ---
    host.querySelectorAll(".ycol").forEach(col => {
      const inpMax = col.querySelector("input.ymax");
      const inpMin = col.querySelector("input.ymin");
      if (!inpMax || !inpMin) return;

      const key = inpMax.dataset.x || inpMin.dataset.x; // "a", "b", "inf", "minf"
      let expectTop = null;
      let expectBot = null;

      if (key === "inf") {
        // colonne x = +‚àû
        // [a;+‚àû[ : min = 0 en limite √† droite ‚Üí ligne du bas
        if (hasPosInf) {
          expectBot = 0;
        }
      } else if (key === "minf") {
        // colonne x = -‚àû
        // ]-‚àû;b] : max = 0 en limite √† gauche ‚Üí ligne du haut
        if (hasNegInf) {
          expectTop = 0;
        }
      } else {
        const x = Number(key);
        if (!Number.isFinite(x)) return;
        const y = 1 / x;

        // colonnes finies
        if (finite || hasPosInf || hasNegInf) {
          // max en a sauf cas negInf o√π le max est √† -‚àû
          if (finite && x === a) expectTop = y;
          if (hasPosInf && x === a) expectTop = y;
          // min en b sauf cas posInf o√π le min est √† +‚àû
          if (finite && x === b) expectBot = y;
          if (hasNegInf && x === b) expectBot = y;
        }
      }

      // --- case du haut (ymax) ---
      const rawMax = inpMax.value.trim();
      if (!rawMax) {
        setTick(inpMax, "nu");
      } else {
        tot++;
        const vNum = num(rawMax);
        const good = (expectTop !== null && vNum !== null && Math.abs(vNum - expectTop) < 1e-9);
        setTick(inpMax, good ? "ok" : "ko");
        if (good) ok++;
      }

      // --- case du bas (ymin) ---
      const rawMin = inpMin.value.trim();
      if (!rawMin) {
        setTick(inpMin, "nu");
      } else {
        tot++;
        const vNum = num(rawMin);
        const good = (expectBot !== null && vNum !== null && Math.abs(vNum - expectBot) < 1e-9);
        setTick(inpMin, good ? "ok" : "ko");
        if (good) ok++;
      }
    });

    // --- 2) Tableau : fl√®che de variation (toujours d√©croissante) ---
    host.querySelectorAll("select.dir").forEach(sel => {
      const v = sel.value;
      if (!v) {
        setTick(sel, "nu");
        return;
      }
      tot++;
      const good = (v === "‚Üò");
      setTick(sel, good ? "ok" : "ko");
      if (good) ok++;
    });

    // --- 3) Encadrement ---
    let lowerVal, upperVal;
    if (finite) {
      lowerVal = 1 / b;
      upperVal = 1 / a;
    } else if (hasPosInf) {
      lowerVal = 0;
      upperVal = 1 / a;
    } else { // negInf
      lowerVal = 1 / b;
      upperVal = 0;
    }

    const checkNumInput = (sel, expected) => {
      const inp = host.querySelector(sel);
      if (!inp) return;
      const v = inp.value.trim();
      if (!v) { setTick(inp,"nu"); return; }
      tot++;
      const n = num(v);
      const good = (n !== null && Math.abs(n - expected) < 1e-9);
      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    };

    if (finite) {
      checkNumInput('.qInf', lowerVal);
      checkNumInput('.qSup', upperVal);
    } else if (hasPosInf) {
      checkNumInput('.qSup', upperVal);
    } else { // negInf
      checkNumInput('.qInf', lowerVal);
    }

    return { ok, total: tot };
  },

  solution(host, st) {
    const { type, a, b } = st;

    let Itex;
    if (type === "posFin" || type === "negFin") {
      Itex = `[${a}\\,;\\,${b}]`;
    } else if (type === "posInf") {
      Itex = `[${a}\\,;\\,+\\infty[`;
    } else {
      Itex = `]-\\infty\\,;\\,${b}]`;
    }

    const fracTex = x => {
      if (x === 1) {
        return "1";
      }
      if (x === -1) {
        return "-1";
      }
      if (x > 0) {
        return `\\dfrac{1}{${x}}`;
      }
      if (x < 0) {
        return `-\\dfrac{1}{${-x}}`;
      }
      return "";
    };

    // Construction du tableau de variations (solution)
    let rowX, rowF, lowerTex, upperTex, encadrementTex, intervalTex;

    if (type === "posFin" || type === "negFin") {
      // [a;b] finis
      rowX = `
      <tr>
        <th>\\(x\\)</th>
        <td style="text-align:left;padding-left:10px">\\(${a}\\)</td>
        <td></td>
        <td style="text-align:right;padding-right:10px">\\(${b}\\)</td>
      </tr>`;

      const leftY  = fracTex(a); // max
      const rightY = fracTex(b); // min

      rowF = `
      <tr>
        <th>\\(f\\)</th>
        <td>
          <div style="text-align:center">\\(${leftY}\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(\\,\\)</div>
        </td>
        <td>‚Üò</td>
        <td>
          <div style="text-align:center">\\(\\,\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(${rightY}\\)</div>
        </td>
      </tr>`;

      lowerTex = fracTex(b);
      upperTex = fracTex(a);
      encadrementTex = `${lowerTex} \\leq \\dfrac{1}{x} \\leq ${upperTex}`;
      intervalTex = `\\bigl[${lowerTex}\\,;\\,${upperTex}\\bigr]`;
    } else if (type === "posInf") {
      // [a; +‚àû[
      rowX = `
      <tr>
        <th>\\(x\\)</th>
        <td style="text-align:left;padding-left:10px">\\(${a}\\)</td>
        <td></td>
        <td style="text-align:right;padding-right:10px">\\(+\\infty\\)</td>
      </tr>`;

      const leftY = fracTex(a); // max
      const rightY = "0";       // limite min

      rowF = `
      <tr>
        <th>\\(f\\)</th>
        <td>
          <div style="text-align:center">\\(${leftY}\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(\\,\\)</div>
        </td>
        <td>‚Üò</td>
        <td>
          <div style="text-align:center">\\(\\,\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(${rightY}\\)</div>
        </td>
      </tr>`;

      lowerTex = "0";
      upperTex = fracTex(a);
      encadrementTex = `0 < \\dfrac{1}{x} \\leq ${upperTex}`;
      intervalTex = `\\bigl]0\\,;\\,${upperTex}\\bigr]`;
    } else {
      // negInf : ]-‚àû; b]
      rowX = `
      <tr>
        <th>\\(x\\)</th>
        <td style="text-align:left;padding-left:10px">\\(-\\infty\\)</td>
        <td></td>
        <td style="text-align:right;padding-right:10px">\\(${b}\\)</td>
      </tr>`;

      const leftY  = "0";        // limite max
      const rightY = fracTex(b); // min

      rowF = `
      <tr>
        <th>\\(f\\)</th>
        <td>
          <div style="text-align:center">\\(${leftY}\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(\\,\\)</div>
        </td>
        <td>‚Üò</td>
        <td>
          <div style="text-align:center">\\(\\,\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(${rightY}\\)</div>
        </td>
      </tr>`;

      lowerTex = fracTex(b);
      upperTex = "0";
      encadrementTex = `${lowerTex} \\leq \\dfrac{1}{x} < 0`;
      intervalTex = `\\bigl[${lowerTex}\\,;\\,0\\bigr[`;
    }

    const box = $("#res",host);
    box.innerHTML = `
      <div class="step">
        <b>1.</b> Tableau de variations de la fonction inverse d√©finie par : \\(f(x)=\\dfrac{1}{x}\\) sur \\(${Itex}\\) :
        <div class="var-wrap" style="margin-top:.4rem">
          <table class="pdf-tbl">
            <thead>${rowX}</thead>
            <tbody>
              ${rowF}
            </tbody>
          </table>
        </div>
      </div>
      <div class="step" style="margin-top:6px">
        <b>2.</b> Encadrement de \\(\\dfrac{1}{x}\\) sur \\(${Itex}\\) :
        \\[
          \\forall x \\in ${Itex},\\quad ${encadrementTex}
        \\]
Ainsi, pour tout \\(x \\in ${Itex}\\), on a
\\[
  \\dfrac{1}{x} \\in ${intervalTex}
\\]
     
      </div>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ymax,input.ymin,input.qInf,input.qSup,select.dir")
        .forEach(el => {
          if (el.tagName === "INPUT") el.value = "";
          setTick(el,"nu");
        });
  }
};

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Exercice 5 : 1/x sur des intervalles traversant 0 (tableau + ensemble d‚Äôimages) ‚Äî‚Äî‚Äî‚Äî‚Äî */

const ex2 = {
  id: "encadrement_inverse_croise_zero",
  title: "Encadrement de la fonction inverse ‚Äì cas traversant 0",

gen() {
  // 3 types √©quiprobables :
  //  - crossFin      : [a;b]    avec a<0<b
  //  - crossLeftInf  : ]-‚àû;b]   avec b>0
  //  - crossRightInf : [a;+‚àû[   avec a<0
  const r = Math.random();
  let type, a = null, b = null;

  if (r < 1/3) {
    type = "crossFin";
    const A = rint(2,5);
    const B = rint(2,5);
    a = -A; b = B;
  } else if (r < 2/3) {
    type = "crossLeftInf";
    b = rint(2,6);
  } else {
    type = "crossRightInf";
    a = -rint(2,6);
  }
  return { type, a, b };
},


render(host, st) {
  const { type, a, b } = st;

  // D√©termination des labels xmin / xmax
  let xmin, xmax, Itex;

  if (type === "crossFin") {
    xmin = a;
    xmax = b;
    Itex = `[${a}\\,;\\,${b}]`;
  }
  else if (type === "crossLeftInf") {
    xmin = "-\\infty";
    xmax = b;
    Itex = `]-\\infty\\,;\\,${b}]`;
  }
  else if (type === "crossRightInf") {
    xmin = a;
    xmax = "+\\infty";
    Itex = `[${a}\\,;\\,+\\infty[`;
  }

  // ===== Ligne X ==========================================================
  const rowX = `
    <tr>
      <th>\\(x\\)</th>

      <td style="text-align:left">\\(${xmin}\\)</td>

      <td></td> <!-- var1, vide dans x -->

      <td></td> <!-- colonne vide gauche -->

      <td>0</td> <!-- 0 -->

      <td></td> <!-- colonne vide droite -->

      <td></td> <!-- var2, vide dans x -->

      <td style="text-align:right">\\(${xmax}\\)</td>

    </tr>`;

  // ===== Ligne f(x) =======================================================
  const rowF = `
    <tr>
      <th>\\(f\\)</th>

      <!-- xmin -->
      <td>
        <div class="ycol" style="display:flex;flex-direction:column;align-items:center;gap:4px">
          <input class="ymax" data-pos="xmin" style="width:70px;text-align:center">
          <input class="ymin" data-pos="xmin" style="width:70px;text-align:center">
        </div>
      </td>

      <!-- var1 -->
      <td style="text-align:center;vertical-align:middle">
        <select class="dir" data-pos="v1">
          <option value=""></option>
          <option>‚Üò</option>
          <option>‚Üó</option>
        </select>
      </td>

      <!-- colonne vide gauche (limites remplies par √©l√®ve) -->
      <td>
        <div class="ycol" style="display:flex;flex-direction:column;align-items:center;gap:4px">
          <input class="ymax" data-pos="left" style="width:70px;text-align:center">
          <input class="ymin" data-pos="left" style="width:70px;text-align:center">
        </div>
      </td>

      <!-- colonne 0 = double barre, aucun input -->
<td class="dbar" style="text-align:center">&nbsp;</td>

      <!-- colonne vide droite -->
      <td>
        <div class="ycol" style="display:flex;flex-direction:column;align-items:center;gap:4px">
          <input class="ymax" data-pos="right" style="width:70px;text-align:center">
          <input class="ymin" data-pos="right" style="width:70px;text-align:center">
        </div>
      </td>

      <!-- var2 -->
      <td style="text-align:center;vertical-align:middle">
        <select class="dir" data-pos="v2">
          <option value=""></option>
          <option>‚Üò</option>
          <option>‚Üó</option>
        </select>
      </td>

      <!-- xmax -->
      <td>
        <div class="ycol" style="display:flex;flex-direction:column;align-items:center;gap:4px">
          <input class="ymax" data-pos="xmax" style="width:70px;text-align:center">
          <input class="ymin" data-pos="xmax" style="width:70px;text-align:center">
        </div>
      </td>

    </tr>`;

  host.innerHTML = `
    <div><b>1.</b> Compl√©ter le tableau de variations de \\(f(x)=\\dfrac{1}{x}\\) sur \\(${Itex}\\).</div>

    <div class="var-wrap" style="margin-top:.6rem">
      <table class="pdf-tbl">
        <thead>${rowX}</thead>
        <tbody>${rowF}</tbody>
      </table>
    </div>

    <div style="margin-top:.8rem">
      <b>2.</b> Pour tout \\(x \\in ${Itex}\\), on a
      \\(\\dfrac{1}{x} \\in\\)
      <input class="qSet" style="width:240px;text-align:center">
      <span class="tick nu"></span>
    </div>

    <div id="res" class="steps small" style="margin-top:.6rem"></div>
  `;

  host.querySelectorAll("input,select").forEach(ensureTickAfter);
  typesetAll(host);
}
,

correct(host, st) {
  const { type, a, b } = st;

  const normBasic = s => (s || "")
    .trim()
    .replace(/\u2212/g,"-")
    .replace(/,/g,".")
    .replace(/\s+/g,"");

  const num = s => {
    const t = normBasic(s);
    if (!t) return null;
    if (t.includes("/")) {
      const [na,da] = t.split("/");
      const n = Number(na), d = Number(da);
      if (!d || Number.isNaN(n) || Number.isNaN(d)) return null;
      return n/d;
    }
    const v = Number(t);
    return Number.isFinite(v) ? v : null;
  };

  // parse valeur avec ¬±‚àû
const parseVal = s => {
  let t = normBasic(s)
    .replace(/\\infty/g, "oo")
    .replace(/‚àû/g, "oo");

  if (!t) return null;

  if (t === "oo" || t === "+oo") return Infinity;
  if (t === "-oo") return -Infinity;

  return num(t);
};


  let ok = 0, tot = 0;

  // valeurs attendues (haut = max, bas = min) suivant type d‚Äôintervalle
  function expectedAt(pos){
    let top = null, bottom = null;

    if (type === "crossFin") {
      // I = [a;b], a<0<b
      if (pos === "xmin")  top    = 1/a;        // max √† a
      if (pos === "left")  bottom = -Infinity;  // lim x‚Üí0‚àí
      if (pos === "right") top    = Infinity;   // lim x‚Üí0+
      if (pos === "xmax")  bottom = 1/b;        // min √† b

    } else if (type === "crossLeftInf") {
      // I = ]-‚àû;b], b>0
      if (pos === "xmin")  top    = 0;          // lim x‚Üí-‚àû
      if (pos === "left")  bottom = -Infinity;  // lim x‚Üí0‚àí
      if (pos === "right") top    = Infinity;   // lim x‚Üí0+
      if (pos === "xmax")  bottom = 1/b;        // min √† b

    } else if (type === "crossRightInf") {
      // I = [a;+‚àû[, a<0
      if (pos === "xmin")  top    = 1/a;        // max √† a
      if (pos === "left")  bottom = -Infinity;  // lim x‚Üí0‚àí
      if (pos === "right") top    = Infinity;   // lim x‚Üí0+
      if (pos === "xmax")  bottom = 0;          // lim x‚Üí+‚àû

    } else {
      // secours : ]-‚àû;+‚àû[
      if (pos === "xmin")  top    = 0;
      if (pos === "left")  bottom = -Infinity;
      if (pos === "right") top    = Infinity;
      if (pos === "xmax")  bottom = 0;
    }
    return { top, bottom };
  }

  // --- 1) V√©rif des 8 cases num√©riques du tableau ---
  host.querySelectorAll('.ycol').forEach(col => {
    const firstInput = col.querySelector('input');
    if (!firstInput) return;
    const pos = firstInput.dataset.pos; // "xmin","left","right","xmax"
    const { top: expTop, bottom: expBot } = expectedAt(pos);

    const inpTop = col.querySelector('input.ymax');
    const inpBot = col.querySelector('input.ymin');

    if (inpTop) {
      const raw = inpTop.value.trim();
      if (!raw) {
        setTick(inpTop, "nu");
      } else {
        tot++;
        const v = parseVal(raw);
        let good = false;
        if (expTop === null) {
          good = false;
        } else if (expTop === Infinity) {
          good = (v === Infinity);
        } else if (expTop === -Infinity) {
          good = (v === -Infinity);
        } else if (v !== null) {
          good = Math.abs(v - expTop) < 1e-9;
        }
        setTick(inpTop, good ? "ok" : "ko");
        if (good) ok++;
      }
    }

    if (inpBot) {
      const raw = inpBot.value.trim();
      if (!raw) {
        setTick(inpBot, "nu");
      } else {
        tot++;
        const v = parseVal(raw);
        let good = false;
        if (expBot === null) {
          good = false;
        } else if (expBot === Infinity) {
          good = (v === Infinity);
        } else if (expBot === -Infinity) {
          good = (v === -Infinity);
        } else if (v !== null) {
          good = Math.abs(v - expBot) < 1e-9;
        }
        setTick(inpBot, good ? "ok" : "ko");
        if (good) ok++;
      }
    }
  });

  // --- 2) Fl√®ches : toujours d√©croissant des deux c√¥t√©s ---
  host.querySelectorAll("select.dir").forEach(sel => {
    const v = sel.value;
    if (!v) {
      setTick(sel, "nu");
      return;
    }
    tot++;
    const good = (v === "‚Üò");
    setTick(sel, good ? "ok" : "ko");
    if (good) ok++;
  });

  // --- 3) Ensemble des valeurs J (qSet) ---
  const normSet = s => {
  let t = (s || "")
    .trim()
    .replace(/\s+/g,"")
    .replace(/\u2212/g,"-")
    .replace(/,/g,".")
    .replace(/‚à™/g,"U");

  // unifier les infinis : \infty, ‚àû, oo, +oo, -oo
  t = t.replace(/\\infty/g, "‚àû");
  t = t.replace(/-oo/g, "-‚àû");
  t = t.replace(/(?:\+)?oo/g, "+‚àû");
  t = t.replace(/‚àû/g, "+‚àû");   // tout ce qui reste devient +‚àû

  t = t.replace(/\+‚àû/g,"+‚àû")
       .replace(/-‚àû/g,"-‚àû");

  return t;
};


  let expected;
  if (type === "crossFin") {
    // J = ]-‚àû;1/a] U [1/b;+‚àû[
    const sL = `-1/${-a}`;   // 1/a < 0
    const sR = `1/${b}`;
    expected = `]-‚àû;${sL}]U[${sR};+‚àû[`;
  } else if (type === "crossLeftInf") {
    // J = ]-‚àû;0[ U [1/b;+‚àû[
    const sR = `1/${b}`;
    expected = `]-‚àû;0[U[${sR};+‚àû[`;
  } else if (type === "crossRightInf") {
    // J = ]-‚àû;1/a] U ]0;+‚àû[
    const sL = `-1/${-a}`;
    expected = `]-‚àû;${sL}]U]0;+‚àû[`;
  } else {
    // cas double inf si jamais
    expected = `]-‚àû;0[U]0;+‚àû[`;
  }

  const inpSet = host.querySelector('.qSet');
  if (inpSet) {
    const v = inpSet.value.trim();
    if (!v) {
      setTick(inpSet,"nu");
    } else {
      tot++;
      const good = normSet(v) === normSet(expected);
      setTick(inpSet, good ? "ok" : "ko");
      if (good) ok++;
    }
  }

  $("#res",host).textContent = "";
  return { ok, total: tot };
}
,

solution(host, st) {
  const { type, a, b } = st;

  const frac1OverTex = x => {
    if (x > 0) return `\\dfrac{1}{${x}}`;
    if (x < 0) return `-\\dfrac{1}{${-x}}`;
    return "0";
  };

  let Itex, Jtex;
  // m√™mes J que dans le correct
  if (type === "crossFin") {
    Itex = `[${a}\\,;\\,${b}]`;
    const sL = `-\\dfrac{1}{${-a}}`;
    const sR = `\\dfrac{1}{${b}}`;
    Jtex = `\\bigl]-\\infty\\,;\\,${sL}\\bigr] \\cup \\bigl[${sR}\\,;\\,+\\infty\\bigr[`;
  } else if (type === "crossLeftInf") {
    Itex = `]-\\infty\\,;\\,${b}]`;
    const sR = `\\dfrac{1}{${b}}`;
    Jtex = `\\bigl]-\\infty\\,;\\,0\\bigr[ \\cup \\bigl[${sR}\\,;\\,+\\infty\\bigr[`;
  } else if (type === "crossRightInf") {
    Itex = `[${a}\\,;\\,+\\infty[`;
    const sL = `-\\dfrac{1}{${-a}}`;
    Jtex = `\\bigl]-\\infty\\,;\\,${sL}\\bigr] \\cup \\bigl]0\\,;\\,+\\infty\\bigr[`;
  } else {
    Itex = `]-\\infty\\,;\\,+\\infty[`;
    Jtex = `\\bigl]-\\infty\\,;\\,0\\bigr[ \\cup \\bigl]0\\,;\\,+\\infty\\bigr[`;
  }

  // extr√©mums attendus (m√™me logique que dans correct)
  const E = {
    xmin:  { top: null,      bottom: null },
    left:  { top: null,      bottom: null },
    right: { top: null,      bottom: null },
    xmax:  { top: null,      bottom: null },
  };

  if (type === "crossFin") {
    E.xmin.top    = frac1OverTex(a);
    E.left.bottom = "-\\infty";
    E.right.top   = "+\\infty";
    E.xmax.bottom = frac1OverTex(b);
  } else if (type === "crossLeftInf") {
    E.xmin.top    = "0";
    E.left.bottom = "-\\infty";
    E.right.top   = "+\\infty";
    E.xmax.bottom = frac1OverTex(b);
  } else if (type === "crossRightInf") {
    E.xmin.top    = frac1OverTex(a);
    E.left.bottom = "-\\infty";
    E.right.top   = "+\\infty";
    E.xmax.bottom = "0";
  } else {
    E.xmin.top    = "0";
    E.left.bottom = "-\\infty";
    E.right.top   = "+\\infty";
    E.xmax.bottom = "0";
  }

  const texOrEmpty = v => v ? `\\(${v}\\)` : "\\(\\,\\)";

  // x : 7 colonnes (xmin, var1, left, 0, right, var2, xmax)
  const xLeftLabel = (type === "crossFin" || type === "crossRightInf")
    ? a
    : "-\\infty";

  const xRightLabel = (type === "crossFin" || type === "crossLeftInf")
    ? b
    : "+\\infty";

  const rowX = `
    <tr>
      <th>\\(x\\)</th>
      <td style="text-align:center">\\(${xLeftLabel}\\)</td>
      <td></td>
      <td></td>
      <td  style="text-align:center">0</td>
      <td></td>
      <td></td>
      <td style="text-align:center">\\(${xRightLabel}\\)</td>
    </tr>`;

  // f(x) : 2 lignes par colonne (haut = max, bas = min)
  const rowF = `
    <tr>
      <th>\\(f(x)\\)</th>

      <!-- xmin -->
      <td>
        <div style="text-align:center">${texOrEmpty(E.xmin.top)}</div>
        <div style="height:4px"></div>
        <div style="text-align:center">${texOrEmpty(E.xmin.bottom)}</div>
      </td>

      <!-- var1 -->
      <td style="text-align:center;vertical-align:middle">‚Üò</td>

      <!-- left (lim 0-) -->
      <td>
        <div style="text-align:center">${texOrEmpty(E.left.top)}</div>
        <div style="height:4px"></div>
        <div style="text-align:center">${texOrEmpty(E.left.bottom)}</div>
      </td>

      <!-- colonne 0 (double barre, pas de valeur) -->
      <td class="dbar"></td>

      <!-- right (lim 0+) -->
      <td>
        <div style="text-align:center">${texOrEmpty(E.right.top)}</div>
        <div style="height:4px"></div>
        <div style="text-align:center">${texOrEmpty(E.right.bottom)}</div>
      </td>

      <!-- var2 -->
      <td style="text-align:center;vertical-align:middle">‚Üò</td>

      <!-- xmax -->
      <td>
        <div style="text-align:center">${texOrEmpty(E.xmax.top)}</div>
        <div style="height:4px"></div>
        <div style="text-align:center">${texOrEmpty(E.xmax.bottom)}</div>
      </td>

    </tr>`;

  const box = $("#res",host);
  box.innerHTML = `
    <div class="step">
      <b>1.</b> Tableau de variations de la fonction inverse sur \\(${Itex}\\) :
      <div class="var-wrap" style="margin-top:.4rem">
        <table class="pdf-tbl">
          <thead>${rowX}</thead>
          <tbody>
            ${rowF}
          </tbody>
        </table>
      </div>
    </div>
    <div class="step" style="margin-top:6px">
      <b>2.</b> Ensemble des valeurs de \\(\\dfrac{1}{x}\\) sur \\(${Itex}\\) :
      \\[
        \\forall x \\in ${Itex},\\quad \\dfrac{1}{x} \\in ${Jtex}.
      \\]
    </div>
  `;
  typesetAll(box);
},


  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.yStart,input.yEnd,input.qSet").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};






/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Fonction inverse ‚Äì Encadrement',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
