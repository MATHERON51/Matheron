<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Fonction racine carr√©e</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}

  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
  table.var.frame-only{
    border-collapse: separate;
    border-spacing: 0;
  }
  table.var.frame-only th,
  table.var.frame-only td{
    border: none;
    padding: 6px 8px;
    text-align: center;
    vertical-align: middle;
  }
  table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
  table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
  table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }
  table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }
  table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }
  table.var.frame-only td.bigsel{ padding:0 }
  table.var.frame-only td.bigsel select{
    display:block;
    width:100%;
    height:100%;
    border:1;
    background:transparent;
    padding:0;
    margin:0;
    text-align:center;
    text-align-last:center;
    appearance:none;
    -webkit-appearance:none;
    -moz-appearance:none;
  }
  table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

  /* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
  table.pdf-tbl td.sbar,
  table.pdf-tbl td.zbar,
  table.pdf-tbl td.dbar { position: relative; }

  table.pdf-tbl td.sbar::before,
  table.pdf-tbl td.zbar::before{
    content:'';
    position:absolute;
    top:-1.5px;
    bottom:-1.5px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid #000;
  }

  table.pdf-tbl td.zbar,
  table.var td.zbar {
    font-size: 1.35em;
    font-weight: 400;
    line-height: 1;
  }
  table.pdf-tbl td.zbar { font-weight:400 !important; }

  /* Variante "grille compl√®te" pour les tableaux d'images f(x) */
  table.pdf-tbl.fullgrid{
    border-collapse:collapse;
    border-spacing:0;
  }
  table.pdf-tbl.fullgrid th,
  table.pdf-tbl.fullgrid td{
    border:1.5px solid #000;
    padding:8px 10px;
  }
  .graph svg.grid{
    width:100%;
    height:auto;
  }
</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Fonction racine carr√©e</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
        <li>Pour une racine carr√©e, on peut √©crire <code>rac(a)</code>.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const isSquare = n => {
  const r = Math.round(Math.sqrt(n));
  return r*r === n;
};

/* === EXERCICE 1 ‚Äì Images par la fonction racine carr√©e === */

/* === EXERCICE 1 ‚Äì Images par la fonction racine carr√©e === */

const ex1 = {
  id: "images_racine_carree",
  title: "Images par la fonction racine carr√©e",

  gen() {
    const items = [];

    /* 1) Carr√© parfait */
    const a1 = rint(2,12);
    items.push({
      kind:"carre_parfait",
      latex:`${a1*a1}`,
      x:a1*a1,
      a:a1,
      val:a1
    });

    /* 2) Entier d√©composable : a¬≤ * k avec k non carr√© parfait */
    let a2 = rint(2,10);
    let k2;
    do { k2 = rint(2,10); } while (isSquare(k2));
    const n2 = a2*a2*k2;
    items.push({
      kind:"a2k",
      latex:`${n2}`,
      x:n2,
      a:a2,
      k:k2,
      val:a2*Math.sqrt(k2)
    });

/* 3) Fraction de carr√© parfait : (p¬≤)/(q¬≤) avec p ‚â† q */
let p3, q3;
do {
  p3 = rint(2,10);
  q3 = rint(2,10);
} while (p3 === q3);   // on refuse p = q

items.push({
  kind:"frac_carre",
  latex:`\\dfrac{${p3*p3}}{${q3*q3}}`,
  x:(p3*p3)/(q3*q3),
  p:p3,
  q:q3,
  val:p3/q3
});

    /* 4) Puissance de 10 paire : 10^(2n) */
    const exp4 = choice([2,4,6,8]);
    items.push({
      kind:"pow10",
      latex:`10^{${exp4}}`,
      x:10**exp4,
      e:exp4,
      val:10**(exp4/2)
    });

    /* 5) D√©cimal carr√© parfait : (m/10)¬≤ */
    const m5 = rint(1,9);
    const x5 = (m5*m5)/100;
    items.push({
      kind:"dec_carre",
      latex:`${String(x5).replace('.',',')}`,
      x:x5,
      m:m5,
      val:m5/10
    });

    /* 6) Fraction avec num√©rateur ou d√©nominateur carr√© parfait */
    let num6, den6, r6, mode6;
    if (Math.random() < 0.5) {
      // num√©rateur carr√© parfait
      r6 = rint(2,10);
      num6 = r6*r6;
      do { den6 = rint(2,20); } while (isSquare(den6));
      mode6 = "numCarre";
    } else {
      // d√©nominateur carr√© parfait
      r6 = rint(2,10);
      den6 = r6*r6;
      do { num6 = rint(2,20); } while (isSquare(num6));
      mode6 = "denCarre";
    }
    items.push({
      kind:"frac_mixed",
      latex:`\\dfrac{${num6}}{${den6}}`,
      x:num6/den6,
      num:num6,
      den:den6,
      r:r6,
      mode:mode6,
      val:Math.sqrt(num6/den6)
    });

    // on m√©lange les 6
    items.sort(()=>Math.random()-0.5);
    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>Calculer l‚Äôimage des nombres suivants par la fonction racine carr√©e \\(f(x)=\\sqrt{x}\\) :</div>
      <div class="var-wrap">
        <table class="pdf-tbl fullgrid" style="width:100%;margin-top:8px">
          <tbody>
            ${[0,1].map(row => `
              <tr>
                ${[0,1,2].map(col => {
                  const idx = 3*row+col;
                  const it = st.items[idx];
                  return `
                  <td style="width:33%;vertical-align:top;padding:8px 10px">
                    <div>\\(${it.latex} :\\)</div>
                    <div style="margin-top:10px">
                      <input class="img" data-i="${idx}" type="text"
                             style="width:90%;max-width:180px;text-align:center">
                      <span class="tick nu"></span>
                    </div>
                  </td>`;
                }).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
      <div id="res" class="steps small"></div>
    `;
    host.querySelectorAll('input.img').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const normBasic = s => (s || "")
      .trim()
      .replace(/\u2212/g,"-")   // moins unicode ‚Üí '-'
      .replace(/,/g,".")        // virgule ‚Üí point
      .replace(/\s+/g,"");      // supprime les espaces

    // parse nombre, fraction ou k¬∑sqrt(a) avec rac / ‚àö / \sqrt
const parseVal = raw => {
  let s = (raw || "").trim();
  if (!s) return NaN;

  // normalisation globale
  s = normBasic(s);

  // unifier toutes les notations racine ‚Üí sqrt(...)
  s = s
    .replace(/rac\(/gi, "sqrt(")             // rac(6) -> sqrt(6)
    .replace(/‚àö\(/g, "sqrt(")                // ‚àö(6)  -> sqrt(6)
    .replace(/‚àö(\d+)/g, "sqrt($1)")          // ‚àö6    -> sqrt(6)
    .replace(/\\sqrt\{([^}]*)\}/g, "sqrt($1)") // \sqrt{6} -> sqrt(6)
    .replace(/\\sqrt([^({ ]+)/g, "sqrt($1)")   // \sqrt6   -> sqrt(6)
    .replace(/\\sqrt\(/g, "sqrt(");          // \sqrt(6)  -> sqrt(6)

  // signe global
  let sign = 1;
  if (s[0] === "+") {
    s = s.slice(1);
  } else if (s[0] === "-") {
    sign = -1;
    s = s.slice(1);
  }

  // parse un "atome" SANS fraction principale : nombre simple ou k*sqrt(a)
  const parseAtom = t => {
    t = t.trim();
    if (!t) return NaN;

    // k*sqrt(a) ou sqrt(a)
    let m = t.match(/^(\d+(?:\.\d+)?)?\*?sqrt\((.+)\)$/);
    if (m) {
      const coefStr   = m[1];
      const insideStr = m[2];

      const coef = coefStr ? Number(coefStr) : 1;
      if (Number.isNaN(coef)) return NaN;

      let base;
      if (insideStr.includes("/")) {
        const [na, da] = insideStr.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        base = n / d;
      } else {
        base = Number(insideStr);
        if (Number.isNaN(base)) return NaN;
      }
      if (base < 0) return NaN;
      return coef * Math.sqrt(base);
    }

    // sinon : nombre simple
    const x = Number(t);
    return Number.isFinite(x) ? x : NaN;
  };

  // cherche une barre de fraction AU NIVEAU 0 (pas √† l'int√©rieur des parenth√®ses)
  const topSlashIndex = (() => {
    let depth = 0;
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (ch === "(") depth++;
      else if (ch === ")") depth = Math.max(0, depth - 1);
      else if (ch === "/" && depth === 0) return i;
    }
    return -1;
  })();

  // cas fraction globale : num/den avec √©ventuellement des sqrt dans chaque morceau
  if (topSlashIndex >= 0) {
    const left  = s.slice(0, topSlashIndex);
    const right = s.slice(topSlashIndex + 1);
    const num = parseAtom(left);
    const den = parseAtom(right);
    if (!Number.isFinite(num) || !Number.isFinite(den) || !den) return NaN;
    return sign * num / den;
  }

  // sinon : un seul atome
  const val = parseAtom(s);
  return Number.isFinite(val) ? sign * val : NaN;
};



    let ok = 0, tot = 0;

    st.items.forEach((it,i)=>{
  const inp = host.querySelector(`input.img[data-i="${i}"]`);
  if (!inp) return;
  const raw = inp.value;
  const v   = normBasic(raw);

  if (!v) {
    setTick(inp,"nu");
    return;
  }
  tot++;

  let good = false;

  // 1) comparaison num√©rique (100, 0.1, etc.)
  let val = parseVal(raw);
  if (!Number.isNaN(val)) {
    if (Math.abs(val - it.val) < 1e-9) {
      good = true;
    }
  }

  // 2) CAS SP√âCIAL : puissance de 10 √©crite 10^k ou 10^{k}
  if (!good && it.kind === "pow10") {
    const w = normBasic(raw);    // ex : "10^2" ou "10^{2}"
    if (w.startsWith("10^")) {
      let kStr = w.slice(3);     // enl√®ve "10^"
      if (kStr.startsWith("{") && kStr.endsWith("}")) {
        kStr = kStr.slice(1,-1); // enl√®ve les accolades
      }
      const k = Number(kStr);
      const expectedExp = it.e / 2;  // ‚àö(10^{2n}) = 10^n
      if (Number.isInteger(k) && k === expectedExp) {
        good = true;
      }
    }
  }

  setTick(inp, good ? "ok" : "ko");
  if (good) ok++;
});



    $("#res",host).textContent = "";
    return { ok, total: tot };
  },

  solution(host, st) {
    const box = $("#res",host);

    const solTex = it => {
      if (it.kind === "carre_parfait") {
        const a = it.a;
        const n2 = a*a;
        return `
\\[
\\begin{aligned}
f(${n2}) &= \\sqrt{${n2}}\\\\
         &= ${a}
\\end{aligned}
\\]`;
      }

      if (it.kind === "a2k") {
        const a = it.a, k = it.k;
        const n = a*a*k;
        return `
\\[
\\begin{aligned}
f(${n}) &= \\sqrt{${n}}\\\\
       &= \\sqrt{${a*a}\\times ${k}}\\\\
       &= \\sqrt{${a*a}}\\times\\sqrt{${k}}\\\\
       &= ${a}\\sqrt{${k}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "frac_carre") {
        const p = it.p, q = it.q;
        const num = p*p, den = q*q;
        return `
\\[
\\begin{aligned}
f\\left(\\dfrac{${num}}{${den}}\\right)
&= \\sqrt{\\dfrac{${num}}{${den}}}\\\\
&= \\dfrac{\\sqrt{${num}}}{\\sqrt{${den}}}\\\\
&= \\dfrac{${p}}{${q}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "pow10") {
        const e = it.e;
		const e2=e/2;
		const rep=10**(e2);
        return `
\\[
\\begin{aligned}
f\\left(10^{${e}}\\right)
&= \\sqrt{10^{${e}}}\\\\
&= (10^{${e}})^{\\tfrac{1}{2}}\\\\
&= 10^{${e}\\times \\tfrac{1}{2}}\\\\
&= 10^{${e/2}}\\\\
&= ${rep}
\\end{aligned}
\\]`;
      }

      if (it.kind === "dec_carre") {
        const m = it.m;
        const x = it.x;
        const xStr = String(x).replace('.',',');
        return `
\\[
\\begin{aligned}
f(${xStr}) &= \\sqrt{${xStr}}\\\\
           &= \\sqrt{\\dfrac{${m*m}}{100}}\\\\
           &= \\dfrac{\\sqrt{${m*m}}}{\\sqrt{100}}\\\\

           &= \\dfrac{${m}}{10}
\\end{aligned}
\\]`;
      }

      if (it.kind === "frac_mixed") {
        const num = it.num, den = it.den, r = it.r, mode = it.mode;

        if (mode === "numCarre") {
          // num = r¬≤
          return `
\\[
\\begin{aligned}
f\\left(\\dfrac{${num}}{${den}}\\right)
&= \\sqrt{\\dfrac{${num}}{${den}}}\\\\
&= \\dfrac{\\sqrt{${num}}}{\\sqrt{${den}}}\\\\
&= \\dfrac{${r}}{\\sqrt{${den}}}\\\\
\\end{aligned}
\\]`;
        } else {
          // den = r¬≤
          return `
\\[
\\begin{aligned}
f\\left(\\dfrac{${num}}{${den}}\\right)
&= \\sqrt{\\dfrac{${num}}{${den}}}\\\\
&= \\dfrac{\\sqrt{${num}}}{\\sqrt{${den}}}\\\\
&= \\dfrac{\\sqrt{${num}}}{${r}}
\\end{aligned}
\\]`;
        }
      }

      return "";
    };

    const cells = idx => {
      const it = st.items[idx];
      return `
<td style="vertical-align:top;padding:8px 10px">
  <div style="margin-top:6px">${solTex(it)}</div>
</td>`;
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;margin-top:4px">
        <tbody>
          <tr>
            ${cells(0)}${cells(1)}${cells(2)}
          </tr>
          <tr>
            ${cells(3)}${cells(4)}${cells(5)}
          </tr>
        </tbody>
      </table>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.img").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};



/* === EXERCICE 2 ‚Äì Tableau de variations de ‚àöx sur un intervalle === */

const ex2 = {
  id: "var_racine_interval",
  title: "Tableau de variations de la fonction racine carr√©e",

  gen() {
    // on prend a=k1¬≤, b=k2¬≤ pour avoir f(a), f(b) entiers
    const k1 = rint(0,4);
    const k2 = rint(k1+1, Math.min(k1+4, 9));
    const a  = k1*k1;
    const b  = k2*k2;

    const fa = Math.sqrt(a); // = k1
    const fb = Math.sqrt(b); // = k2

    return { a, b, fa, fb };
  },

  render(host, st) {
    const { a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;

    const colsX = [a, null, b];

    const rowX = `
      <tr>
        <th>\\(x\\)</th>
        ${colsX.map((x, idx, arr) => {
          if (x === null) return `<td></td>`;
          const isLeft  = idx === 0;
          const isRight = idx === arr.length - 1;
          const align = isLeft ? 'left' : (isRight ? 'right' : 'center');
          const pad   = isLeft
            ? 'padding-left:10px;'
            : (isRight ? 'padding-right:10px;' : '');
          return `<td style="text-align:${align};${pad}">\\(${x}\\)</td>`;
        }).join("")}
      </tr>`;

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        ${colsX.map((x, idx) => {
          if (x === null) {
            return `
              <td class="bigsel">
                <select class="dir" data-i="${idx}"
                        style="display:block;width:100%;height:100%">
                  <option value=""></option>
                  <option>‚Üò</option>
                  <option>‚Üó</option>
                </select>
              </td>`;
          }
          const y = Math.sqrt(x);
          return `
            <td>
              <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
                <input class="ymax" data-x="${x}" type="text"
                       style="width:80px;text-align:center"
                       placeholder="">
                <input class="ymin" data-x="${x}" type="text"
                       style="width:80px;text-align:center"
                       placeholder="">
              </div>
            </td>`;
        }).join("")}
      </tr>`;

    host.innerHTML = `
      <div><b>1.</b> Donner le <b>tableau de variations</b> de la fonction racine carr√©e d√©finie sur \\([0;+\\infty[\\) par : \\(f(x)=\\sqrt{x}\\) sur \\(${Itex}\\).</div>

      <div class="var-wrap" style="margin-top:.5rem">
          <table class="pdf-tbl pdf-hide">
            <thead>${rowX}</thead>
            <tbody>
              ${rowF}
            </tbody>
          </table>
      </div>

      <div style="margin-top:.6rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> En d√©duire un <b>encadrement</b> de \\(\\sqrt{x}\\) sur \\(${Itex}\\) :</label>
        </div>
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <span>Pour tout \\(x\\in ${Itex}\\),</span>
          <input class="qEncMin" type="text" style="width:90px;text-align:center">
          <span>\\(\\le \\sqrt{x} \\le\\)</span>
          <input class="qEncMax" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll(
      'input.ymax,input.ymin,input.qEncMin,input.qEncMax,select.dir'
    ).forEach(ensureTickAfter);

    typesetAll(host);
  },

  correct(host, st) {
    const { a, b } = st;

    const norm = s => (s || "").trim().replace(/\u2212/g, "-").replace(/,/g, ".");
    const num  = s => {
      const v = Number(norm(s));
      return Number.isFinite(v) ? v : null;
    };

    const minVal = Math.sqrt(a);
    const maxVal = Math.sqrt(b);

    let ok = 0, tot = 0;

    const checkNumInput = (inp, expected) => {
      if (!inp) return;
      const v = inp.value.trim();
      if (!v) {
        setTick(inp, "nu");
        return;
      }
      tot++;
      const n = num(v);
      const good = (n !== null && Math.abs(n - expected) < 1e-9);
      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    };

    // encadrement
    const iMin = host.querySelector('.qEncMin');
    const iMax = host.querySelector('.qEncMax');
    checkNumInput(iMin, minVal);
    checkNumInput(iMax, maxVal);

    // fl√®che
    const selDir = host.querySelector('select.dir');
    if (selDir) {
      const v = selDir.value.trim();
      if (!v) {
        setTick(selDir, "nu");
      } else {
        tot++;
        const good = (v === "‚Üó");
        setTick(selDir, good ? "ok" : "ko");
        if (good) ok++;
      }
    }

    // valeurs tableau
    const ymaxA = host.querySelector(`input.ymax[data-x="${a}"]`);
    const yminA = host.querySelector(`input.ymin[data-x="${a}"]`);
    const ymaxB = host.querySelector(`input.ymax[data-x="${b}"]`);
    const yminB = host.querySelector(`input.ymin[data-x="${b}"]`);

    // en x=a : min en bas
    checkNumInput(yminA, minVal);
    checkNumInput(ymaxA, minVal);

    // en x=b : max en haut
    checkNumInput(ymaxB, maxVal);
    checkNumInput(yminB, maxVal);

    return { ok, total: tot };
  },

  solution(host, st) {
    const { a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;
    const fa = Math.sqrt(a);
    const fb = Math.sqrt(b);

    const rowX = `
      <tr>
        <th>\\(x\\)</th>
        <td style="text-align:left;padding-left:10px">\\(${a}\\)</td>
        <td></td>
        <td style="text-align:right;padding-right:10px">\\(${b}\\)</td>
      </tr>`;

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        <td>
          <div style="text-align:center">&nbsp;</div>
          <div style="height:6px"></div>
          <div style="text-align:center">\\(${fa}\\)</div>
        </td>
        <td>‚Üó</td>
        <td>
          <div style="text-align:center">\\(${fb}\\)</div>
          <div style="height:6px"></div>
          <div style="text-align:center">&nbsp;</div>
        </td>
      </tr>`;

    const box = $("#res",host);
    box.innerHTML = `
      <div class="step">
        <b>1.</b> Tableau de variations de la fonction racine carr√©e \\(f(x)=\\sqrt{x}\\) sur \\(${Itex}\\) :
        <div class="var-wrap" style="margin-top:.4rem">
          <table class="pdf-tbl">
            <thead>${rowX}</thead>
            <tbody>
              ${rowF}
            </tbody>
          </table>
        </div>
      </div>
      <div class="step" style="margin-top:6px">
        <b>2.</b> La fonction racine carr√©e est strictement croissante sur \\([0;+\\infty[\\).<br>
        Sur l‚Äôintervalle \\(${Itex}\\) avec \\(${a} < ${b}\\), on a donc :
        \\(f(${a}) = ${fa}\\) est le minimum, et \\(f(${b}) = ${fb} \\) est le maximum.<br>
        On en d√©duit l'encadrement :
        \\[
          \\forall x \\in ${Itex},\\quad ${fa} \\le  \\sqrt{x} \\le ${fb}.
        \\]
      </div>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ymax,input.ymin,input.qEncMin,input.qEncMax,select.dir")
        .forEach(el => {
          if (el.tagName === "INPUT") el.value = "";
          setTick(el,"nu");
        });
  }
};


/* === EXERCICE 3 ‚Äì Ant√©c√©dents par la fonction racine carr√©e === */

const ex3 = {
  id: "antecedents_racine",
  title: "Ant√©c√©dents par la fonction racine carr√©e",

  gen() {
    const gcd = (a,b)=>{
      a = Math.abs(a); b = Math.abs(b);
      while(b){ const t=b; b=a%b; a=t; }
      return a || 1;
    };

    // 1) y entier positif
    const y1 = rint(1,10);
    const x1 = y1*y1;

    // 2) y entier positif diff√©rent
    let y2;
    do { y2 = rint(2,12); } while (y2 === y1);
    const x2 = y2*y2;

    // 3) y fraction p/q (en fraction irr√©ductible)
    let p,q;
    do {
      p = rint(1,8);
      q = rint(2,8);
    } while (gcd(p,q) !== 1);
    const y3 = p/q;
    const x3 = (p*p)/(q*q);

    // 4) y d√©cimal (m/10)
    const m = rint(1,9);
    const y4 = m/10;
    const x4 = (m*m)/100;

    // 5) y n√©gatif : pas d‚Äôant√©c√©dent r√©el
    const y5 = -rint(1,10);

    const items = [
      { kind:"int1",  y:y1,  ant:x1, latex:`${y1}` },
      { kind:"int2",  y:y2,  ant:x2, latex:`${y2}` },
      { kind:"frac",  y:y3,  ant:x3, p, q, latex:`\\dfrac{${p}}{${q}}` },
      { kind:"dec",   y:y4,  ant:x4, latex:`${String(y4).replace('.',',')}` },
      { kind:"neg",   y:y5,  latex:`${y5}` }
    ];

    items.sort(()=>Math.random()-0.5);
    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>
        On consid√®re la fonction racine carr√©e \\(f(x)=\\sqrt{x}\\) d√©finie sur \\([0;+\\infty[\\).<br>
        Pour chacun des nombres suivants, donner <b>un ant√©c√©dent r√©el</b> par \\(f\\), c‚Äôest-√†-dire un nombre r√©el \\(x\\ge 0\\) tel que \\(f(x)=y\\).<br>
        <em>On √©crira un seul nombre r√©el (entier, d√©cimal ou fraction). S'il n'y a pas d'ant√©c√©dent √©crire : ‚àÖ, aucun ou vide</em>
      </div>

      <div class="var-wrap" style="margin-top:.5rem">
        <table class="pdf-tbl fullgrid" style="width:100%;max-width:650px">
          <thead>
            <tr>
              <th>Nombre \\(y\\)</th>
              <th>Ant√©c√©dent r√©el par \\(f(x)=\\sqrt{x}\\)</th>
            </tr>
          </thead>
          <tbody>
            ${st.items.map((it,i)=>`
              <tr>
                <td style="width:35%">\\(${it.latex}\\)</td>
                <td>
                  <input class="ante" data-i="${i}" type="text"
                         style="width:95%;max-width:280px;text-align:center">
                  <span class="tick nu"></span>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ante').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const norm = s => (s || "")
      .trim()
      .replace(/\u2212/g,"-")
      .replace(/,/g,".")
      .replace(/\s+/g,"");

    const parseValue = raw => {
      let s = (raw || "").trim();
      if (!s) return NaN;

      s = norm(s);

      if (s.includes(";")) {
        s = s.split(";")[0];
      }

      let sign = 1;
      if (s[0] === "+") {
        s = s.slice(1);
      } else if (s[0] === "-") {
        sign = -1;
        s = s.slice(1);
      }

      // fraction
      if (s.includes("/")) {
        const [na, da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        return sign * (n / d);
      }

      const x = Number(s);
      return Number.isNaN(x) ? NaN : sign * x;
    };

    let ok = 0, tot = 0;

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.ante[data-i="${i}"]`);
      if (!inp) return;
      const raw = inp.value.trim();

      if (!raw) {
        setTick(inp,"nu");
        return;
      }

      tot++;
      let good = false;

      if (it.kind === "neg") {
        // y < 0 : aucune solution r√©elle
        const txt = norm(raw).toLowerCase();
        if (
          txt === "‚àÖ" || txt === "√∏" ||
          txt === "aucunesolution" ||
          txt === "pasdesolution" ||
          txt === "pasdesolutions" ||
          txt === "ensemblevide" ||
		            txt === "aucun" ||
          txt === "vide"
        ) {
          good = true;
        }
      } else {
        const x = parseValue(raw);
        if (!Number.isNaN(x) && x >= -1e-9) {
          const y = it.y;
          const eps = 1e-6;
          good = Math.abs(Math.sqrt(x) - y) < eps;
        }
      }

      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    const box = $("#res",host);
    if (box) {
      box.innerHTML = `<div class="step"></div>`;
    }

    return { ok, total: tot };
  },

  solution(host, st) {
    const box = $("#res",host);

    const solTex = it => {
      const y = it.y;

      if (it.kind === "int1" || it.kind === "int2") {
        const x = it.ant;
        return `
\\[
\\begin{aligned}
\\sqrt{x} &= ${y} \\; \\text{avec} \\; x \\ge 0\\\\
x &= ${y}^2\\\\
x &= ${x}
\\end{aligned}
\\]`;
      }

      if (it.kind === "frac") {
        const p = it.p, q = it.q;
        const xNum = p*p, xDen = q*q;
        return `
\\[
\\begin{aligned}
\\sqrt{x} &= \\dfrac{${p}}{${q}} \\; \\text{avec} \\; x \\ge 0\\\\
x &= \\left(\\dfrac{${p}}{${q}}\\right)^2\\\\
x &= \\dfrac{${xNum}}{${xDen}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "dec") {
        const yStr = String(y).replace('.',',');
        const xStr = String(it.ant).replace('.',',');
        return `
\\[
\\begin{aligned}
\\sqrt{x} &= ${yStr}  \\; \\text{avec} \\; x \\ge 0\\\\
x &= (${yStr})^2\\\\
x &= ${xStr}
\\end{aligned}
\\]`;
      }

      if (it.kind === "neg") {
        const yStr = String(y).replace('.',',');
        return `
\\[
\\begin{aligned}
\\sqrt{x} &= ${yStr}\\\\
\\end{aligned}
\\]
Or \\(\\sqrt{x} \\ge 0 \\) pour tout  \\(x \\ge 0\\)<br>
Il n'existe donc aucun r√©el  \\(x \\ge 0\\)  tel que \\(\\sqrt{x} = ${yStr}\\)<br>
\\(f\\) n'admet donc aucun ant√©c√©dent.
`;
      }

      return "";
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;max-width:750px">
        <thead>
          <tr>
            <th>Nombre \\(y\\)</th>
            <th>Correction</th>
          </tr>
        </thead>
        <tbody>
          ${st.items.map(it => `
            <tr>
              <td style="width:30%">\\(${it.latex}\\)</td>
              <td style="vertical-align:top;padding:6px 10px">
                ${solTex(it)}
              </td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;

    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ante").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};



/* === EXERCICE 4 ‚Äì In√©quations du type ‚àöx ‚Ä¶ (lecture graphique) === */

const ex4 = {
  id: "ineq_sqrt_graph",
  title: "In√©quations du type ‚àöx ‚Ä¶ (lecture graphique)",

  gen() {
    // c entier de 0 √† 10 : beaucoup plus de nombres possibles
    const c = rint(0, 10);
    const rel = choice(["<=","<",">=",">"]);

    let relTex;
    if (rel === "<=") relTex = "\\le";
    else if (rel === "<") relTex = "<";
    else if (rel === ">=") relTex = "\\ge";
    else relTex = ">";

    return {
      c,
      rel,
      ineqTex: `\\sqrt{x} ${relTex} ${c}`
    };
  },

  buildSketch(st, showSolution) {
    const NS  = "http://www.w3.org/2000/svg";
    const W   = 260;
    const H   = 260;
    const m   = 24;

    // Fen√™tre "math" pour dessiner une courbe de ‚àöx correcte,
    // mais l'√©chelle verticale ne sera PAS respect√©e pour y=c.
    const xMin = 0;
    const xMax = 16;   // on voit au moins un bout de courbe
    const yMin = 0;
    const yMax = 4;    // valeur arbitraire, juste pour la forme

    const X = x => m + (x - xMin) / (xMax - xMin) * (W - 2*m);
    const Y = y => H - m - (y - yMin) / (yMax - yMin) * (H - 2*m);

    const svg = document.createElementNS(NS, "svg");
    svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    svg.setAttribute("width", W);
    svg.setAttribute("height", H);
    svg.setAttribute("class", "grid");

    const x0 = X(0);
    const y0 = Y(0);
    const yTop = Y(yMax);

    // Axes
    const axY = document.createElementNS(NS, "line");
    axY.setAttribute("x1", x0);
    axY.setAttribute("x2", x0);
    axY.setAttribute("y1", yTop);
    axY.setAttribute("y2", y0);
    axY.setAttribute("stroke", "#555");
    axY.setAttribute("stroke-width", "1.6");
    svg.appendChild(axY);

    const axX = document.createElementNS(NS, "line");
    axX.setAttribute("x1", X(xMin));
    axX.setAttribute("x2", X(xMax));
    axX.setAttribute("y1", y0);
    axX.setAttribute("y2", y0);
    axX.setAttribute("stroke", "#555");
    axX.setAttribute("stroke-width", "1.6");
    svg.appendChild(axX);

    // Courbe y = sqrt(x) (dessin√©e "vraiment", mais l'√©chelle
    // ne sera pas utilis√©e pour placer la droite y=c)
// Courbe y = 0.4¬∑sqrt(x) : m√™me forme mais plus ‚Äúcoll√©e‚Äù √† l‚Äôaxe des x
const yFunc = x => 0.4 * Math.sqrt(x);
    const curve = document.createElementNS(NS, "path");
    const n = 200;
    let d = "";
    for (let i = 0; i <= n; i++) {
      const x = xMin + (xMax - xMin) * i / n;
      const y = yFunc(x);
      const Xp = X(x);
      const Yp = Y(y);
      d += (i === 0 ? "M " : " L ") + Xp + " " + Yp;
    }
    curve.setAttribute("d", d);
    curve.setAttribute("stroke", "#e11d48");
    curve.setAttribute("stroke-width", "2.3");
    curve.setAttribute("fill", "none");
    svg.appendChild(curve);

    if (!showSolution) return svg;

    const c   = st.c;
    const rel = st.rel;

    // ===== Position de la "droite y=c" SANS √âCHELLE VERTICALE =====
    let yCscreen;
    if (c === 0) {
      // cas particulier : y=0 sur l'axe des abscisses
      yCscreen = y0;
    } else {
      // pour n'importe quel c‚â†0, on place l'image AU MILIEU
      // de la partie positive de l'axe des ordonn√©es
      yCscreen = 3*(yTop + y0) / 4;
    }

    // On cherche un x (dans [0, xMax]) tel que la courbe coupe
    // la horizontale de niveau yCscreen EN COORDONN√âES √âCRAN.
    // => la position de l'intersection NE D√âPEND PAS de c,
    //    c'est juste un dessin "pour se repr√©senter".
    const findXForYscreen = (targetY) => {
      let lo = xMin;
      let hi = xMax;
      for (let k = 0; k < 40; k++) {
        const mid = 0.5 * (lo + hi);
        const YsMid = Y(yFunc(mid));
        const YsLo  = Y(yFunc(lo));
        if ((YsMid - targetY) * (YsLo - targetY) <= 0) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      return 0.5 * (lo + hi);
    };

    let xRootWorld;
    if (c === 0) {
      xRootWorld = 0; // sqrt(x)=0 ‚áî x=0
    } else {
      xRootWorld = findXForYscreen(yCscreen);
    }
    const xRoot = X(xRootWorld);

    // horizontale "y=c" (sch√©matique)
    const hSeg = document.createElementNS(NS, "line");
    hSeg.setAttribute("x1", x0);
    hSeg.setAttribute("x2", X(xMax));
    hSeg.setAttribute("y1", yCscreen);
    hSeg.setAttribute("y2", yCscreen);
    hSeg.setAttribute("stroke", "#2563eb");
    hSeg.setAttribute("stroke-width", "2.2");
    svg.appendChild(hSeg);

    // verticale de l'intersection jusqu'√† l'axe des x
    const vSeg = document.createElementNS(NS, "line");
    vSeg.setAttribute("x1", xRoot);
    vSeg.setAttribute("x2", xRoot);
    vSeg.setAttribute("y1", yCscreen);
    vSeg.setAttribute("y2", y0);
    vSeg.setAttribute("stroke", "#2563eb");
    vSeg.setAttribute("stroke-width", "2.2");
    svg.appendChild(vSeg);

    // intervalle solution sur l'axe des x
    const segSol = document.createElementNS(NS, "line");
    let x1s, x2s;

    if (rel === "<=" || rel === "<") {
      x1s = x0;
      x2s = xRoot;
    } else {
      x1s = xRoot;
      x2s = X(xMax);
    }

    segSol.setAttribute("x1", x1s);
    segSol.setAttribute("x2", x2s);
    segSol.setAttribute("y1", y0);
    segSol.setAttribute("y2", y0);
    segSol.setAttribute("stroke", "#16a34a");
    segSol.setAttribute("stroke-width", "3");
    svg.appendChild(segSol);

    // point plein / vide au seuil
    const dot = document.createElementNS(NS,"circle");
    dot.setAttribute("cx", xRoot);
    dot.setAttribute("cy", y0);
    dot.setAttribute("r", 4);
    dot.setAttribute("stroke", "#16a34a");
    dot.setAttribute("stroke-width", "2");
    dot.setAttribute(
      "fill",
      (rel === "<=" || rel === ">=") ? "#16a34a" : "#fff"
    );
    svg.appendChild(dot);

    // label y = c (plac√© au milieu, l'√©chelle n'est pas respect√©e)
    const ty = document.createElementNS(NS,"text");
    ty.setAttribute("x", x0 + 4);
    ty.setAttribute("y", yCscreen - 4);
    ty.setAttribute("font-size", "11");
    ty.setAttribute("text-anchor", "start");
    ty.setAttribute("fill", "#2563eb");
    ty.textContent = String(c);
    svg.appendChild(ty);

    // label x = c¬≤ sur l'axe des abscisses (math√©matiquement correct,
    // m√™me si la position de la verticale provient du dessin sch√©matique)
    const alpha = c * c;
    const tx = document.createElementNS(NS,"text");
    tx.setAttribute("x", xRoot + 10);
    tx.setAttribute("y", y0 - 10);
    tx.setAttribute("font-size", "11");
    tx.setAttribute("text-anchor", "middle");
    tx.setAttribute("fill", "#2563eb");
    tx.textContent = String(alpha);
    svg.appendChild(tx);

    return svg;
  },

  render(host, st) {
    const { ineqTex } = st;

    host.innerHTML = `
      <div>
        √Ä l'aide de la repr√©sentation graphique de la fonction racine carr√©e \\(f(x)=\\sqrt{x}\\),
        d√©terminer l'<b>ensemble des solutions</b> de l‚Äôin√©quation suivante.
      </div>

      <div style="margin-top:.35rem">
        <b>In√©quation :</b> \\(${ineqTex}\\)
      </div>

      <div class="graph" style="margin-top:.45rem">
        <div class="ineq-g"></div>
      </div>

      <div style="margin-top:.6rem">
        <div style="margin-top:.4rem;display:flex;flex-wrap:wrap;gap:8px;align-items:center">
          <span>Ensemble des solutions : \\(S =\\)</span>
          <input class="ineq-set" type="text"
                 style="width:230px;max-width:90%;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.7rem"></div>
    `;

    const box = host.querySelector('.ineq-g');
    box.appendChild(this.buildSketch(st, false));

    host.querySelectorAll('input.ineq-set').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const inp = host.querySelector('.ineq-set');
    const tickEl = inp ? ensureTickAfter(inp) : null;
    const raw = (inp?.value || "").trim();

    if (!raw) {
      if (tickEl) tickEl.className = "tick nu";
      return { ok: 0, total: 0 };
    }

    function parseIntervals(txt) {
      if (!txt) return null;

      let s = txt.trim();
      s = s
        .replace(/\s+/g, "")
        .replace(/\u2212/g, "-")
        .replace(/‚àû/g, "oo")
        .replace(/\\,/g, "")
        .replace(/\\;/g, "");

      s = s.replace(/‚à™/gi, "U").replace(/u/g, "U");

      const parts = s.split(/U+/).filter(Boolean);
      if (!parts.length) return null;

      const parseBound = (t) => {
        if (!t) return NaN;
        t = t.trim().replace(/\u2212/g, "-");

        let low = t.toLowerCase().replace(/,/g, ".");
        if (low === "oo" || low === "inf" || low === "+oo" || low === "+inf") return +Infinity;

        let sign = 1;
        if (t[0] === "+") {
          t = t.slice(1);
        } else if (t[0] === "-") {
          sign = -1;
          t = t.slice(1);
        }

        let core = t.trim().replace(/\u2212/g, "-");
        let coreLower = core.toLowerCase().replace(/,/g, ".");

        const mRac = coreLower.match(/^rac\((.+)\)$/);
        const mSqrt = coreLower.match(/^sqrt\((.+)\)$/);
        const mInside = mRac || mSqrt;

        if (mInside) {
          let inside = mInside[1];

          let base;
          if (inside.includes("/")) {
            const [na, da] = inside.split("/");
            const n = Number(na), d = Number(da);
            if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
            base = n / d;
          } else {
            base = Number(inside);
            if (Number.isNaN(base)) return NaN;
          }
          // sqrt(a)^2 => a, mais ici on veut juste une borne num√©rique :
          return sign * base;
        }

        const v = Number(coreLower);
        return Number.isFinite(v) ? sign * v : NaN;
      };

      const intervals = [];

      for (const part of parts) {
        if (part.length < 4) return null;

        const L = part[0];
        const R = part[part.length - 1];
        if (!"[]()".includes(L) || !"[]()".includes(R)) return null;

        const inside = part.slice(1, -1);
        const sepIdx = inside.indexOf(";") >= 0 ? inside.indexOf(";") : inside.indexOf(",");
        if (sepIdx < 0) return null;

        const aStr = inside.slice(0, sepIdx);
        const bStr = inside.slice(sepIdx + 1);

        const a = parseBound(aStr);
        const b = parseBound(bStr);
        if (Number.isNaN(a) || Number.isNaN(b)) return null;

        if (Number.isFinite(a) && Number.isFinite(b) && a > b + 1e-9) return null;

        const openL = (L === ']' || L === '(');
        const openR = (R === '[' || R === ')');

        intervals.push({ a, b, openL, openR });
      }

      intervals.sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      return intervals;
    }

    const c = st.c;
    const alpha = c * c;

    const expected = (() => {
      switch(st.rel){
        case "<=": // sqrt(x) <= c  => 0 <= x <= c¬≤
          return [{
            a: 0,
            b: alpha,
            openL: false,
            openR: false
          }];
        case "<": // sqrt(x) < c  => 0 <= x < c¬≤
          return [{
            a: 0,
            b: alpha,
            openL: false,
            openR: true
          }];
        case ">=": // sqrt(x) >= c  => x >= c¬≤
          return [{
            a: alpha,
            b: +Infinity,
            openL: false,
            openR: true
          }];
        case ">": // sqrt(x) > c   => x > c¬≤
        default:
          return [{
            a: alpha,
            b: +Infinity,
            openL: true,
            openR: true
          }];
      }
    })();

    const got = parseIntervals(raw);
    let ok = 0, tot = 1;
    let good = false;

    if (got && got.length === expected.length) {
      const EPS = 1e-6;
      const numEq = (x, y) => {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return x === y;
        return Math.abs(x - y) < EPS;
      };

      const expSorted = expected.slice().sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      good = true;
      for (let i = 0; i < got.length; i++) {
        const g = got[i];
        const e = expSorted[i];
        if (!numEq(g.a, e.a) || !numEq(g.b, e.b) ||
            g.openL !== e.openL || g.openR !== e.openR) {
          good = false;
          break;
        }
      }
    }

    if (tickEl) tickEl.className = "tick " + (good ? "ok" : "ko");
    if (good) ok = 1;

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `<div class="step"></div>`;
      typesetAll(box);
    }

    return { ok, total: tot };
  },

  solution(host, st) {
    const c   = st.c;
    const rel = st.rel;
    const a   = c * c;

    let Itex   = "";
    let solTex = "";

    if (rel === "<=") {
      Itex = `[0;${a}]`;
      solTex = `
\\[
\\sqrt{x} \\le ${c}
\\iff 0 \\le x \\le ${c}^2
\\iff 0 \\le x \\le ${a}
\\]
L‚Äôensemble des solutions est donc : \\(${Itex}\\).`;
    } else if (rel === "<") {
      Itex = `[0;${a}[`;
      solTex = `
\\[
\\sqrt{x} < ${c}
\\iff 0 \\le x < ${c}^2
\\iff 0 \\le x < ${a}
\\]
L‚Äôensemble des solutions est donc : \\(${Itex}\\).`;
    } else if (rel === ">=") {
      Itex = `[${a};+\\infty[`;
      solTex = `
\\[
\\sqrt{x} \\ge ${c}
\\iff x \\ge ${c}^2
\\iff x \\ge ${a}
\\]
L‚Äôensemble des solutions est donc : \\(${Itex}\\).`;
    } else {
      Itex = `]${a};+\\infty[`;
      solTex = `
\\[
\\sqrt{x} > ${c}
\\iff x > ${c}^2
\\iff x > ${a}
\\]
L‚Äôensemble des solutions est donc : \\(${Itex}\\).`;
    }

    const gHost = host.querySelector('.ineq-g');
    if (gHost) {
      gHost.innerHTML = "";
      gHost.appendChild(this.buildSketch(st, true));
    }

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step"></div>
        <div class="step" style="margin-top:.4rem">
          <div class="graph" style="margin-bottom:.5rem">
            <div class="ineq-sol-graph"></div>
          </div>
          ${solTex}
        </div>
      `;

      const solG = box.querySelector('.ineq-sol-graph');
      if (solG) {
        solG.appendChild(this.buildSketch(st, true));
      }
    }
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res", host);
    if (box) box.textContent = "";
    const inp = host.querySelector('.ineq-set');
    if (inp) {
      inp.value = "";
      setTick(inp, "nu");
    }
    const gHost = host.querySelector('.ineq-g');
    if (gHost) gHost.innerHTML = "";
  }
};



/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2,ex3,ex4];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Fonction racine carr√©e',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
