<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Seconde – Chapitre 2 – Images et antécédents – Exercices</title>
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:nowrap;gap:8px;align-items:center;overflow-x:auto}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#666}

/* grille */
.row{
  display:grid;
  grid-template-columns:1fr minmax(240px,320px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px;
  align-items:start;
}
.row .col-label{grid-area:lab}
.row input[type=text]{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.equ{font-weight:600}
.hint{opacity:.85;margin:.2rem 0 .6rem}

/* Fractions “pile” (sans LaTeX) */
.frac{display:inline-flex;flex-direction:column;align-items:center;vertical-align:middle;line-height:1}
.frac .num,.frac .den{padding:0 .2em; white-space:nowrap}
.frac .bar{border-top:1.6px solid currentColor;align-self:stretch;margin:.06em 0}
.frac-sign{margin-right:.15em}

/* Bloc étapes */
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0; white-space:nowrap}

/* === Bloc .equ-offscreen pour PDF === */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;}
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
}
.equ-offscreen .consigne{margin-bottom:6px;font-weight:600}

/* Annule l'ancien “inserteur d’espaces” global */
.equ > *::before,
.consigne > *::before,
#host .lead > *::before,
.equ > :first-child::before,
.consigne > :first-child::before,
#host .lead > :first-child::before { content: normal !important; }

/* PDF : masquer la saisie */
.equ-offscreen input,
.equ-offscreen textarea,
.equ-offscreen select,
.equ-offscreen .input,
.equ-offscreen .inputs,
.equ-offscreen .reponse,
.equ-offscreen .reponses,
.equ-offscreen .answer,
.equ-offscreen .answers,
.equ-offscreen .field,
.equ-offscreen .fields { display:none !important; }

.small{ color:#111 !important; }

</style>

<!-- MathJax -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">Seconde – Chapitre 2 – <strong>Images et antécédents</strong></h1>
</div>

<div class="wrap">
  <div class="controls card">
    <label for="exo-select"><strong>Type d’exercice :</strong></label>
    <select id="exo-select"></select>
    <button class="btn" id="btn-new" title="Générer un nouvel énoncé">🔄 Nouvel énoncé</button>
    <button class="btn" id="btn-check" title="Vérifier votre réponse (Entrée ⏎)">✅ Vérifier</button>
    <button class="btn" id="btn-solution" title="Afficher la solution détaillée">💡 Solution</button>
    <button class="btn" id="btn-reset" title="Réinitialiser et remettre le score à zéro">🧹 Réinitialiser</button>
    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <div class="card" id="host"></div>

  <div class="card small">
    <strong>Saisie &amp; réponses acceptées :</strong>
    <ul style="margin:8px 0 0 18px">
      <li><strong>Entrée ⏎</strong> déclenche <em>Vérifier</em>.</li>
      <li><strong>Décimales :</strong> virgule <code class="code">,</code> ou point <code class="code">.</code>.</li>
      <li><strong>Fractions :</strong> taper <code class="code">a/b</code> (affichage en fraction verticale).</li>
      <li><strong>Équations / antécédents :</strong> répondre au format <code class="code">S = { a ; b }</code> (ou <code class="code">S = ∅</code> si aucune solution).</li>
      <li><strong>Domaines :</strong> écrire <code class="code">ℝ</code>, <code class="code">]-\infty ; +\infty[</code>, <code class="code">[a ; b]</code>, <code class="code">]a ; b[</code>, unions avec <code class="code">∪</code>.</li>
      <li><strong>Plusieurs éléments :</strong> séparer par <code class="code">;</code> (ordre indifférent).</li>
    </ul>
  </div>

  <div class="card">
    <div data-math-kbd="" style="display:flex; justify-content:center"></div>
  </div>
</div>

<!-- libs -->
<script defer src="../../../../js/dev-rules-clean.dedup.js"></script>
<script defer src="../../../../js/math-kbd.js"></script>
<script defer src="../../../../js/exo-pdf-kit.multiplicatif.js"></script>
<script defer src="../../../../js/algebra-eval-patch.multiplicatif.js"></script>

<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);

/* ===== utilitaires ===== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];
const wrap = tex => `\\(${tex}\\)`;
function retypeset(scope){ try{ if(window.MathJax && MathJax.typeset) MathJax.typeset([scope||document.getElementById('host')]); }catch(_){} }
function dedupe(arr){ const out=[]; for(const x of arr){ if(!out.length || out[out.length-1]!==x) out.push(x); } return out; }

/* rationnels */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function norm(p,q){ if(q===0) throw new Error('denominator 0'); let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; } return {p,q}; }
function makeR(p,q){ return norm(p,q||1); }
function addR(A,B){ return norm(A.p*B.q + B.p*A.q, A.q*B.q); }
function subR(A,B){ return norm(A.p*B.q - B.p*A.q, A.q*B.q); }
function mulR(A,B){ return norm(A.p*B.p, A.q*B.q); }
function divR(A,B){ if(B.p===0) throw new Error('div by 0'); return norm(A.p*B.q, A.q*B.p); }
function toNumber(R){ return R.p/R.q; }

function fracHTML(p,q){
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg?'-':'')+String(p);
  return (neg?'-':'')+`\\dfrac{${p}}{${q}}`;
}
function fmtConstHTML(R){ return (R.q===1? String(R.p) : fracHTML(R.p,R.q)); }
function Q(numTex, denTex){ const d=String(denTex).trim(); return (d==='1') ? numTex : `\\dfrac{${numTex}}{${denTex}}`; }
function asFracPlain(R){ return (R.q===1? String(R.p) : R.p+'/'+R.q); }

/* affichage fonctions */
function fmtCoeffXHTML(A){ if(A.p===A.q) return 'x'; if(A.p===-A.q) return '−x'; return fmtConstHTML(A)+'x'; }
function fmtSignedCoeffXHTML(B){
  if(B.p===0) return '';
  const sign=(B.p>0?' + ':' - '), abs={p:Math.abs(B.p),q:B.q};
  if(abs.p===abs.q) return sign+'x';
  return sign+fmtConstHTML(abs)+'x';
}
function fmtSignedConstHTML(B){
  if(B.p===0) return '';
  const sign=(B.p>0?' + ':' - '), abs={p:Math.abs(B.p),q:B.q};
  return sign+fmtConstHTML(abs);
}
function sideHTML(A,B){ return fmtCoeffXHTML(A)+fmtSignedConstHTML(B); }
// x^n sans montrer 1 (ni -1 correctement signé)
function fmtCoeffPowHTML(A, pow){
  if (A.p === 0) return '0';
  if (A.p === A.q)   return `x^{${pow}}`;
  if (A.p === -A.q)  return '−' + `x^{${pow}}`;
  return fmtConstHTML(A) + `x^{${pow}}`;
}
function fmtSignedCoeffPowHTML(B, pow){
  if (B.p === 0) return '';
  const sign = (B.p > 0 ? ' + ' : ' − ');
  const abs = {p: Math.abs(B.p), q: B.q};
  if (abs.p === abs.q) return sign + `x^{${pow}}`;
  return sign + fmtConstHTML(abs) + `x^{${pow}}`;
}
// Coefficients NUMÉRIQUES (pas objets rationnels) — pour les étapes en brut/TeX
function nCoefX(a){ return (a===1 ? 'x' : (a===-1 ? '−x' : a+'x')); }
function nCoefX2(a){ return (a===1 ? 'x^{2}' : (a===-1 ? '−x^{2}' : a+'x^{2}')); }

// ax + b en TeX, sans montrer 1 ni −1
function linTeX(a,b){
  const A = (a===1 ? 'x' : (a===-1 ? '−x' : a+'x'));
  const B = (b===0 ? '' : (b>0 ? ' + '+Math.abs(b) : ' − '+Math.abs(b)));
  return A + B;
}
function normDom(s){
  return String(s||'')
    .replace(/\s+/g,'')          // supprime les espaces
    .replace(/[−–—]/g,'-')       // minuscules Unicode → '-'
    .replace(/ℝ/gi,'r')          // ℝ ou R → r
    .replace(/∪/g,'u')           // union symbole → 'u'
    .replace(/-∞/gi,'-oo')       // -∞ → -oo
    .replace(/\+?∞/gi,'+oo')     // ∞ ou +∞ → +oo
    .toLowerCase();
}


/* helpers format + nettoyage */
function normalizeSigns(s){
  return s.replace(/\+\s*-\s*/g,' - ')
          .replace(/-\s*\+\s*/g,' - ')
          .replace(/-\s*-\s*/g,' + ')
          .replace(/\s{2,}/g,' ')
          .trim();
}
function removePlusZero(s){ return s.replace(/\s[+−]\s0(?![0-9])/g,''); }
function fmtAfterTimes(n,isFirst=false){ return (n<0 && !isFirst) ? '('+n+')' : String(n); }

/* parsing réponses */
function normText(s){ return String(s||'').replace(/−/g,'-').replace(/∞/g,'oo').replace(/ℝ/g,'R').replace(/∪/g,'U').replace(/\s+/g,' ').trim(); }
function numberFromText(s){
  const t=normText(s);
  const mFrac=t.match(/([-+]?\d+)\s*\/\s*([-+]?\d+)/);
  if(mFrac){ const p=+mFrac[1], q=+mFrac[2]; if(q!==0) return p/q; }
  const mDec=t.match(/[-+]?\d+(?:[.,]\d+)?/);
  return mDec? parseFloat(mDec[0].replace(',','.')) : NaN;
}
function parseSet(input){
  let t=normText(input).toLowerCase().replace(/\s+/g,'').replace(/,/g,';');
  if(t==='s=∅'||t==='∅'||t==='s={}'||t==='aucunesolution'||t==='pasdesolution'||t==='vide') return {empty:true, list:[]};
  t=t.replace(/^s=/,'').replace(/^\{/,'').replace(/\}$/,'').replace(/^x=/,'');
  if(!t) return {empty:false, list:[]};
  const parts=t.split(';').filter(Boolean);
  const list=parts.map(numberFromText).filter(v=>!Number.isNaN(v));
  return {empty:false, list};
}
function sameSetAnswer(user, expected){
  const p=parseSet(user);
  if(expected.length===0) return p.empty || p.list.length===0;
  if(p.list.length!==expected.length) return false;
  const a=[...p.list].sort((x,y)=>x-y), b=[...expected].sort((x,y)=>x-y);
  for(let i=0;i<a.length;i++) if(Math.abs(a[i]-b[i])>1e-9) return false;
  return true;
}
function fmtSetHTML(arr){
  if(!arr || arr.length===0) return 'S = \\varnothing';
  const items = arr.map(v=>{
    if(typeof v==='number') return fmtConstHTML({p:v,q:1});
    if(v && typeof v==='object' && 'p' in v && 'q' in v) return fmtConstHTML(v);
    return String(v);
  }).join(' ; ');
  return 'S = \\{ '+items+' \\}';
}

/* ===== Exercices ===== */

/* A1 — Image f(x)=ax+b */
const exA1 = {
  id:'img_affine', title:'Image : f(x)=ax+b → f(x₀)',
  gen(){ let a=0; while(a===0) a=rnd(-5,5); const b=rnd(-9,9), x0=rnd(-6,6);
    const A=makeR(a,1), B=makeR(b,1), X0=makeR(x0,1);
    const val=addR(mulR(A,X0),B);
    return {A,B,X0,val}; },
  text(s){
    return 'Soit <strong>'+wrap('f(x) = '+sideHTML(s.A,s.B))+'</strong>. Calculer <strong>'+wrap('f('+s.X0.p+')')+'</strong>.';
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.val)]) ||
               (numberFromText($('#reponse',host).value)===toNumber(s.val));
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const a=s.A.p,b=s.B.p,x0=s.X0.p, ax=a*x0, sum=ax+b;
	const aStr = (a===1? '' : (a===-1? '−' : a+'×'));

    let steps=[
      wrap(  `f(${fmtAfterTimes(x0,true)}) = ${aStr}${fmtAfterTimes(x0,false)} ${(b>=0?'+':'−')} ${Math.abs(b)}`,),
      wrap(`f(${fmtAfterTimes(x0,true)}) = ${ax} ${(b>=0?'+':'−')} ${Math.abs(b)}`),
      wrap(`f(${fmtAfterTimes(x0,true)}) = ${sum}`)
    ].map(t=>removePlusZero(normalizeSigns(t)));
    steps = dedupe(steps);
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value=String(sum);
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* A2 — Image P(x)=ax²+bx+c */
const exA2 = {
  id:'img_poly', title:'Image : P(x)=ax²+bx+c → P(x₀)',
  gen(){ let a=0; while(a===0) a=rnd(-3,3); const b=rnd(-5,5), c=rnd(-6,6), x0=rnd(-4,4);
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1), X0=makeR(x0,1);
    const x02=makeR(x0*x0,1), val=addR(addR(mulR(A,x02),mulR(B,X0)),C);
    return {A,B,C,X0,x02,val}; },
  text(s){
  // Affiche P(x) = ax² + bx + c sans montrer 1 devant x²
  return 'Soit <strong>' + wrap(
    'P(x) = ' + fmtCoeffPowHTML(s.A, 2) + 
    fmtSignedCoeffXHTML(s.B) + 
    fmtSignedConstHTML(s.C)
  ) + '</strong>. Calculer <strong>' + wrap('P('+s.X0.p+')') + '</strong>.';
},

  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.val)]) ||
               (numberFromText($('#reponse',host).value)===toNumber(s.val));
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
  const a=s.A.p, b=s.B.p, c=s.C.p, x0=s.X0.p;
  const x0Pow = (x0<0? '('+x0+')' : x0); // pas de parenthèses si positif
  const ax2 = a*(x0*x0);
  const bx  = b*x0;
  const sum = ax2 + bx + c;

  // --- Étape 1 : substitution sans « 1× » et en omettant les termes nuls ---
  const parts1 = [];
  // terme a·x0²
  const aHead = (a===1 ? '' : (a===-1 ? '−' : a+'×'));
  parts1.push(`${aHead}${x0Pow}²`);
  // terme b·x0 si b≠0
  if (b !== 0){
    const sign = (b>0 ? ' + ' : ' − ');
    const coef = (Math.abs(b)===1 ? '' : Math.abs(b)+'×');
    parts1.push(`${sign}${coef}${fmtAfterTimes(x0,false)}`);
  }
  // terme c si c≠0
  if (c !== 0){
    const sign = (c>0 ? ' + ' : ' − ');
    parts1.push(`${sign}${Math.abs(c)}`);
  }
  const line1 = `P(${fmtAfterTimes(x0,true)}) = ` + parts1.join('');

  // --- Étape 2 : calcul intermédiaire (mêmes règles) ---
  const parts2 = [];
  parts2.push(String(ax2));
  if (b !== 0) parts2.push((bx>=0?' + ':' − ') + Math.abs(bx));
  if (c !== 0) parts2.push((c>=0?' + ':' − ') + Math.abs(c));
  const line2 = `P(${fmtAfterTimes(x0,true)}) = ` + parts2.join('');

  // --- Étape 3 : résultat ---
  const line3 = `P(${fmtAfterTimes(x0,true)}) = ${sum}`;

  const steps = [wrap(line1), wrap(line2), wrap(line3)];
  $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
  $('#reponse',host).value=String(sum);
  $('#res',host).className='small';
  try{ if(window.MathJax && MathJax.typeset) MathJax.typeset([host]); }catch(_){}
},

  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* B1 — Antécédent affine */
const exB1 = {
  id:'ant_affine', title:'Antécédent : f(x)=ax+b, résoudre f(x)=y₀',
  gen(){ let a=0; while(a===0) a=rnd(-9,9); const b=rnd(-12,12), y0=rnd(-12,12);
    const A=makeR(a,1), B=makeR(b,1), Y=makeR(y0,1);
    const rhs=subR(Y,B), S=divR(rhs,A), raw={p:rhs.p*A.q,q:rhs.q*A.p};
    return {A,B,Y,rhs,S,raw}; },
  text(s){
    return 'Antécédent de <strong>'+wrap(fmtConstHTML(s.Y))+'</strong> pour <strong>'+wrap('f(x) = '+sideHTML(s.A,s.B))+'</strong>.';
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.S)]);
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    let lines = [
      wrap(sideHTML(s.A,s.B)+' = '+fmtConstHTML(s.Y)),
      wrap(fmtCoeffXHTML(s.A)+' = '+fmtConstHTML(s.Y)+' - '+fmtConstHTML(s.B)),
      wrap(fmtCoeffXHTML(s.A)+' = '+fmtConstHTML(s.rhs)),
      wrap('x = '+fracHTML(s.raw.p,s.raw.q))
    ];
    const same = (s.raw.p*s.S.q === s.S.p*s.raw.q);
    if(!same) lines.push(wrap('x = '+fmtConstHTML(s.S)));
    lines.push(wrap(fmtSetHTML([s.S])));
    lines = lines.map(t=>removePlusZero(normalizeSigns(t)));
    lines = dedupe(lines);
    $('#res',host).innerHTML = '<div class="steps">'+lines.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value = 'S={ '+asFracPlain(s.S)+' }';
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* B2 — Antécédents de c pour g(x)=ax²+bx+c */
const exB2 = {
  id:'ant_quad_c', title:'Antécédents de c pour g(x)=ax²+bx+c (factorisation)',
  gen(){ 
    let a=0; while(a===0) a=rnd(-5,5);
    let b=0; while(b===0) b=rnd(-9,9);
    const c=rnd(-6,6);
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1);
    const X2=divR(makeR(-b,1),makeR(a,1)); // -b/a
    return {A,B,C,X2};
    },
  text(s){
return 'Antécédents de <strong>'+wrap(fmtConstHTML(s.C))+
       '</strong> pour <strong>'+wrap('g(x) = '+fmtCoeffPowHTML(s.A,2)+
       fmtSignedCoeffXHTML(s.B)+fmtSignedConstHTML(s.C))+'</strong>.';
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [0, toNumber(s.X2)]);
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, s){
  // -- helpers d’affichage (locaux pour être autonomes)
  function nCoefX(a){ return a===1 ? 'x' : (a===-1 ? '−x' : a+'x'); }
  function nCoefX2(a){ return a===1 ? 'x²' : (a===-1 ? '−x²' : a+'x²'); }
  const clean = t => removePlusZero(normalizeSigns(t));
  const W = t => wrap(clean(t));

  const a = s.A.p, b = s.B.p, c = s.C.p;
  const signBx = (b>=0 ? ' + ' : ' − ');

  // 1) Mise en équation puis factorisation (sans "1x" / "1x²")
  const linesTop = [
    W(`${nCoefX2(a)}${signBx}${Math.abs(b)}x ${(c>=0?'+':'−')} ${Math.abs(c)} = ${c}`),
    W(`${nCoefX2(a)}${signBx}${Math.abs(b)}x = 0`),
    W(`x(${nCoefX(a)}${signBx}${Math.abs(b)}) = 0`)
  ];

  // 2) Côté droit du produit nul : ax + b = 0  →  …
  //    (jamais (-b)/1 ; ajouter la forme simplifiée seulement si différente)
  const rawNum  = -b;
  const rawDen  = a;
  const rawTex  = fracHTML(rawNum, rawDen);           // x = (-b)/a
  const simpR   = makeR(rawNum, rawDen);              // fraction réduite
  const simpTex = fmtConstHTML(simpR);                // ex. -1
  const needSimp = (rawTex !== simpTex);

  const rightSteps = [];
  rightSteps.push(W(`${nCoefX(a)}${signBx}${Math.abs(b)} = 0`));

  if (a === 1){
    // éviter "x = (-b)/1"
    rightSteps.push(W(`x = ${-b}`));
  } else {
    rightSteps.push(W(`${nCoefX(a)} = ${-b}`));
    rightSteps.push(W(`x = ${rawTex}`));          // ex. x = -4/4
    if (needSimp) rightSteps.push(W(`x = ${simpTex}`)); // ex. x = -1
  }

  // 3) Tableau « produit nul »
  const sTable = 'style="border-collapse:collapse;width:100%;margin:.25rem 0"';
  const sCell  = 'style="border:none;padding:.1rem .6rem;vertical-align:top;"';
  const sOr    = 'style="border:none;padding:.1rem .4rem;vertical-align:middle;text-align:center;font-weight:700;white-space:nowrap;"';
  const sSpan  = 'style="display:block;margin:.15rem 0"';

  const tableHTML = [
    `<table role="presentation" ${sTable}><tr>`,
      `<td ${sCell}><span ${sSpan}>${wrap('x = 0')}</span></td>`,
      `<td ${sOr}>ou</td>`,
      `<td ${sCell}>`,
        rightSteps.map(t => `<span ${sSpan}>${t}</span>`).join(''),
      `</td>`,
    `</tr></table>`
  ].join('');

  // 4) Ligne ensemble des solutions (0 et -b/a)
  const setLine = wrap(fmtSetHTML([{p:0,q:1}, makeR(-b, a)]));

  // 5) Rendu
  $('#res',host).innerHTML =
    '<div class="steps">' +
      linesTop.map(t=>`<div class="step">${t}</div>`).join('') +
      `<div class="step">${tableHTML}</div>` +
      `<div class="step">${setLine}</div>` +
    '</div>';

  $('#reponse',host).value = 'S={ 0 ; '+asFracPlain(makeR(-b,a))+' }';
  $('#res',host).className='small';
  try{ if(window.MathJax && MathJax.typeset) MathJax.typeset([host]); }catch(_){}
},


  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* B4 — Antécédent homographique */
const exB4 = {
  id:'ant_homo', title:'Antécédent : (ax+b)/(cx+d) = k (dénominateur non nul)',
  gen(){
    let a=0,c=0; while(a===0) a=rnd(-6,6); while(c===0) c=rnd(-6,6);
    const b=rnd(-8,8), d=rnd(-8,8), k=choice([-2,-1,1,2,3]);
    const num=k*d - b, den=a - k*c; if(den===0) return this.gen();
    const sol=makeR(num,den), pole=makeR(-d,c);
    if(Math.abs(toNumber(sol)-toNumber(pole))<1e-9) return this.gen();
    return {a,b,c,d,k,sol,pole};
  },
  text(s){
  const N = linTeX(s.a, s.b);
  const D = linTeX(s.c, s.d);
  return 'Pour <strong>'+wrap('p(x)='+Q(N,D))+
         '</strong>, déterminer l’antécédent de <strong>'+wrap(String(s.k))+'</strong>.';
},

  render(host, s, def){
  const txt = (def && typeof def.text === 'function') ? def.text(s) : '';
  host.innerHTML = `
    <div class="row">
      <div class="equ">
        ${txt}
        <div class="hint">Les antécédents de <strong>${s.k}</strong> par la fonction sont :</div>
      </div>
      <input id="reponse" type="text" placeholder="S = { … }">
      <div id="res"></div>
    </div>`;
  $('#reponse',host).focus();
},

  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.sol)]);
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
      const a=s.a,b=s.b,c=s.c,d=s.d,k=s.k;

    const N = linTeX(a,b), D = linTeX(c,d);
const lhs3 = nCoefX(a)+' '+(b>=0?'+':'−')+' '+Math.abs(b);
const rhs3 = nCoefX(k*c)+' '+((k*d)>=0?'+':'−')+' '+Math.abs(k*d);
const lhs4 = nCoefX(a - k*c);

let steps=[
    'Condition : '+wrap(''+D+' \\ne 0')+'  donc  '+wrap('x \\ne '+fracHTML(-d,c)),
  wrap(Q(N,D)+' = '+k),
  wrap(N+' = '+k+'('+D+')'),
  wrap(`${lhs3} = ${rhs3}`),
  wrap(`${lhs4} = ${k*d - b}`),
  wrap(`x = ${fracHTML(k*d - b, a - k*c)}`),
  wrap(`x = ${fmtConstHTML(makeR(k*d - b, a - k*c))}`),
  wrap(fmtSetHTML([makeR(k*d - b, a - k*c)]))
].map(t=> (typeof t==='string'? t : removePlusZero(normalizeSigns(t))));

    steps = dedupe(steps);
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value = 'S={ '+asFracPlain(s.sol)+' }';
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* C1 — Domaine : affine */
const exC1 = {
  id:'dom_affine', title:'Ensemble de définition : affine',
  gen(){ let a=rnd(-9,9); if(a===0) a=1; const b=rnd(-9,9); return {a,b}; },
  text(s){
  const fx = linTeX(s.a, s.b);
  return 'Donner l’ensemble de définition de <strong>'+wrap('f(x) = '+fx)+'</strong>.';
},

  correct(host){
  const t = normDom($('#reponse',host).value);
  const ok = (t==='r' || t===']-oo;+oo[');
  $('#res',host).innerHTML = ok? '✔' : '✘';
  $('#res',host).className = ok? 'res-ok':'res-ko';
  return {ok,total:1};
},

  solution(host){
    const steps=[
      'Une fonction affine est définie pour tout réel.',
      wrap('D = \\mathbb{R}')+' (ou '+wrap(']-\\infty; +\\infty[')+')'
    ];
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value='ℝ';
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* C2 — Domaine : √(ax+b) */
const exC2 = {
  id:'dom_sqrt', title:'Ensemble de définition : √(ax+b)',
  gen(){ let a=0; while(a===0) a=rnd(-5,5); const b=rnd(-9,9); return {a,b}; },
  text(s){
  return 'Donner l’ensemble de définition de <strong>'+wrap('g(x) = \\sqrt{'+linTeX(s.a,s.b)+'}')+'</strong>.';
},

  correct(host,s){
    const thr=divR(makeR(-s.b,1),makeR(s.a,1)), t=toNumber(thr), n = normDom($('#reponse',host).value);
    let ok=false;
    if(s.a>0){ ok = n===`[${thr.p}/${thr.q};+oo[` || n===`[${t};+oo[` || n===`x>=${t}`; }
    else{ ok = n===`]-oo;${thr.p}/${thr.q}]` || n===`]-oo;${t}]` || n===`x<=${t}`; }
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const thr=divR(makeR(-s.b,1),makeR(s.a,1)), tStr=fmtConstHTML(thr);
    const rhs = fmtConstHTML(makeR(-s.b,1));
    let steps;
    if(s.a>0){
  steps=[
    wrap(`${nCoefX(s.a)} ${(s.b>=0?'+':'−')} ${Math.abs(s.b)} \\geq 0`),
    wrap(`${nCoefX(s.a)} \\geq ${rhs}`),
    wrap(`x \\geq ${tStr}`),
    'Donc '+wrap('D = ['+tStr+' ; +\\infty[')
  ];
}else{
  steps=[
    wrap(`${nCoefX(s.a)} ${(s.b>=0?'+':'−')} ${Math.abs(s.b)} \\geq 0`),
    wrap(`${nCoefX(s.a)} \\geq ${rhs}`),
    wrap(`x \\leq ${tStr}`)+' (division par un nombre négatif)',
    'Donc '+wrap('D = ]-\\infty ; '+tStr+']')
  ];
}

    steps = steps.map(t => (typeof t==='string'? t : removePlusZero(normalizeSigns(t))));
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value = (s.a>0? '['+asFracPlain(thr)+' ; +\infty[' : ']-\infty ; '+asFracPlain(thr)+']');
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* C3 — Domaine : (ax+b)/(cx+d) */
const exC3 = {
  id:'dom_homo', title:'Ensemble de définition : (ax+b)/(cx+d)',
  gen(){ let c=0; while(c===0) c=rnd(-6,6); const a=rnd(-6,6), b=rnd(-8,8), d=rnd(-8,8);
    const pole=divR(makeR(-d,1),makeR(c,1)); return {a,b,c,d,pole}; },
  text(s){
  const N = linTeX(s.a, s.b), D = linTeX(s.c, s.d);
  return 'Donner l’ensemble de définition de <strong>'+wrap('h(x) = '+Q(N,D))+'</strong>.';
},

  render(host, s, def){
  const txt = (def && typeof def.text === 'function') ? def.text(s) : '';
  host.innerHTML = `
    <div class="row">
      <div class="equ">${txt}</div>
      <input id="reponse" type="text" placeholder="">
      <div id="res"></div>
    </div>`;
  $('#reponse',host).focus();
},

  correct(host,s){
    const x0=toNumber(s.pole), x0s=asFracPlain(s.pole);
const t = normDom($('#reponse',host).value);
    const ok = t===`r\\{${x0s}}` || t===`r\\{${x0}}` || t===`]-oo;${x0s}[u]${x0s};+oo[` || t===`]-oo;${x0}[u]${x0};+oo[`;
$('#res',host).innerHTML = ok
  ? '✔'
  : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const x0=fmtConstHTML(s.pole);
const cX = nCoefX(s.c);
const steps=[
  'On cherche les valeurs interdites : résoudre le dénominateur = 0.',
  wrap(`${cX} ${(s.d>=0?'+':'−')} ${Math.abs(s.d)} = 0`),
  wrap(`${cX} = ${-s.d}`),
  wrap(`x = ${x0}`),
'Réponse : ' + wrap('\\mathbb{R} \\setminus \\{'+x0+'\\}')
+ ' (ou ' + wrap(']-\\infty ; '+x0+'[') + ' ∪ ' + wrap(']'+x0+' ; +\\infty[') + ')'
].map(t => (typeof t==='string'? t : removePlusZero(normalizeSigns(t))));

    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value='ℝ\\{'+asFracPlain(s.pole)+'}';
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* E — Formats à trous (mix) */
const exE = {
  id:'mini', title:'Formats à trous (mix)',
  gen(){ const t=choice([1,2,3,4,5,6]);
    if(t===1){ const a=rnd(1,5)*choice([1,-1]), b=rnd(-6,6), x0=rnd(-4,4); return {fmt:1,a,b,x0,val:a*x0+b}; }
    if(t===2){ return {fmt:2}; }
    if(t===3){ return {fmt:3}; }
    if(t===4){ const n=rnd(1,5); return {fmt:4,n}; }
    if(t===5){ return {fmt:5}; }
    if(t===6){ return {fmt:6}; }
  },
  text(s){
if(s.fmt===1) return 'Soit <strong>'+wrap('f(x)='+linTeX(s.a,s.b))+
                    '</strong>. Calculer <strong>'+wrap('f('+s.x0+')')+'</strong>.';
    if(s.fmt===2) return 'Pour <strong>'+wrap('g(x)=x^{2}-1')+'</strong>, antécédents de <strong>'+wrap('0')+'</strong>.';
    if(s.fmt===3) return 'Pour <strong>'+wrap('h(x)=\\sqrt{x+4}')+'</strong>, donner <strong>\\(D_h\\)</strong>.';
    if(s.fmt===4) return 'Pour <strong>'+wrap('p(x)='+Q('x - 3','x + '+s.n))+'</strong>, donner <strong>\\(D_p\\)</strong>.';
    if(s.fmt===5) return 'Résoudre <strong>'+wrap(Q('x - 3','x + 2')+' = 1')+'</strong>.';
    if(s.fmt===6) return 'Pour <strong>'+wrap('k(x)='+Q('\\sqrt{4 - x}','x - 3'))+'</strong>, donner <strong>\\(D_k\\)</strong>.';
  },
  correct(host,s){
    const val=$('#reponse',host).value;
    let ok=false, exp='';
    if(s.fmt===1){ ok = (numberFromText(val)===s.val) || sameSetAnswer(val,[s.val]); exp=String(s.val); }
    if(s.fmt===2){ ok = sameSetAnswer(val,[-1,1]); exp=wrap(fmtSetHTML([{p:-1,q:1},{p:1,q:1}])); }
    if(s.fmt===3){ const thr=divR(makeR(-4,1),makeR(1,1)); const n = normDom(val);
ok = (n==='[-2;+oo[' || n==='x>=-2'); }
    if(s.fmt===4){ const n=s.n; const t = normDom(val);
ok = (t===`r\\{-${s.n}}` || t===`]-oo;-${s.n}[u]-${s.n};+oo[`); }
    if(s.fmt===5){ ok = parseSet(val).empty; exp='S = ∅'; }
    if(s.fmt===6){ const t = normDom(val);
ok = (t===']-oo;3[u]3;4]'); }
    $('#res',host).innerHTML = ok? '✔' : '✘ ';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    let steps=[];
    if(s.fmt===1){
  const a=s.a,b=s.b,x0=s.x0, ax=a*x0, sum=ax+b;
  const aStr = (a===1? '' : (a===-1? '−' : a+'×'));
  steps=[
    wrap(`f(${fmtAfterTimes(x0,true)}) = ${aStr}${fmtAfterTimes(x0,false)} ${(b>=0?'+':'−')} ${Math.abs(b)}`),
    wrap(`f(${fmtAfterTimes(x0,true)}) = ${ax} ${(b>=0?'+':'−')} ${Math.abs(b)}`),
    wrap(`f(${fmtAfterTimes(x0,true)}) = ${sum}`)
  ];
}

    if(s.fmt===2){ steps=[ wrap('x^{2} - 1 = 0'), wrap('(x - 1)(x + 1) = 0'), wrap(fmtSetHTML([{p:-1,q:1},{p:1,q:1}])) ]; }
    if(s.fmt===3){ steps=['On impose le radicande positif :', wrap('x + 4 \\geq 0'), wrap('x \\geq -2'), 'Donc '+wrap('D = [-2 ; +\\infty[')]; }
    if(s.fmt===4){ steps=['Dénominateur non nul :', wrap('x + '+s.n+' \\ne 0'), wrap('x \\ne '+(-s.n)), 'Donc ' + wrap('D = \\mathbb{R} \\setminus \\{'+(-s.n)+'\\}')
+ ' (ou ' + wrap(']-\\infty ; '+(-s.n)+'[') + ' ∪ ' + wrap(']'+(-s.n)+' ; +\\infty[') + ')']; }
    if(s.fmt===5){ steps=[ wrap(Q('x - 3','x + 2')+' = 1'), wrap('x - 3 = x + 2'), 'Impossible : '+wrap('0 = 5')+' ⇒ '+wrap('S = \\varnothing') ]; }
    if(s.fmt===6){ steps=['Conditions :', wrap('4 - x \\geq 0  \\Rightarrow  x \\leq 4'), wrap('x - 3 \\ne 0  \\Rightarrow  x \\ne 3'), 'Donc '+wrap('D = ]-\\infty ; 3[ ∪ ]3 ; 4]')]; }
    steps = steps.map(t => (typeof t==='string'? t : removePlusZero(normalizeSigns(t))));
    steps = dedupe(steps);
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#res',host).className='small';
    retypeset(host);
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* ===== REGISTRY ===== */
const REGISTRY=[exA1,exA2,exB1,exB2,exB4,exC1,exC2,exC3,exE];
window.REGISTRY=REGISTRY;

/* ===== Bootstrap commun ===== */
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

/* Rendu par défaut si pas de .render */
function defaultRender(host, state, def){
  const txt = (def && typeof def.text === 'function') ? def.text(state) : '';
  const placeholder =
    def && /^dom_/.test(def.id) ? 'D = …'
    : def && /^img_/.test(def.id) ? 'réponse numérique'
    : 'S = { … }';

  host.innerHTML = `
    <div class="equ-offscreen">${txt||''}</div>
    <div class="row">
      <div class="equ">${txt||''}</div>
      <input id="reponse" type="text" placeholder="${placeholder}">
      <div id="res"></div>
    </div>
  `;
  const inp = host.querySelector('#reponse');
  if (inp){
    inp.addEventListener('keydown', e=>{
      if(e.key === 'Enter'){ e.preventDefault(); check(); }
    }, {passive:true});
    inp.focus();
  }
}

function buildOne(){
  const sel=$("#exo-select");
  const host=$("#host");
  host.classList.remove('sol-mode');               // <— reset l’affichage solution

  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active = def.id;
  host.dataset.state = JSON.stringify(state);
  (def.render && typeof def.render === 'function' ? def.render : defaultRender)(host, state, def);
  const inp = $("#reponse", host) || $("input[type=text]", host);
  if(inp) inp.focus();
  retypeset(host);
}

function check(){
  const host=$("#host");
  host.classList.remove('sol-mode');               // <— on ré-affiche la saisie si besoin
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const state=JSON.parse(host.dataset.state||"{}");
  const r = def.correct(host, state);
  if(r){ scoreOK += r.ok?1:0; scoreTot += (r.total||1); updateScore(); }
  retypeset(host);
}

function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const state=JSON.parse(host.dataset.state||"{}");

  // On affiche la solution telle que définie par l’exo…
  def.solution(host, state);

  // …mais on NE REMPLIT PLUS la saisie et on la MASQUE
  host.classList.add('sol-mode');
  host.querySelectorAll('input, textarea, select').forEach(el=>{
    if(el.tagName==='INPUT' && el.type==='text') el.value='';
  });

  retypeset(host);
}

function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  host.classList.remove('sol-mode');               // <— reset
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def) def.reset(host);
}


document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{
    const opt=document.createElement("option");
    opt.value=e.id; opt.textContent=e.title;
    sel.appendChild(opt);
  });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  sel.value = REGISTRY[0].id;
  buildOne();
  updateScore();

  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde – Chapitre 2 – Images et antécédents',
      max: 50,
      mountAfterSelector: '.card.small',
      beforeRender(def, st, withSolutions){
        try{
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          const renderFn = (def && typeof def.render === 'function') ? def.render : defaultRender;
          renderFn(tmp, st, def);
          if(!withSolutions){
            const root = tmp.querySelector('.equ-offscreen') || tmp;
            root.querySelectorAll('input, select, textarea, button').forEach(el=>el.remove());
            root.querySelectorAll('.input, .inputs, .reponse, .reponses, .answer, .answers, .field, .fields').forEach(el=>el.remove());
            root.querySelectorAll('*').forEach(function(n){
              if(n.childNodes) Array.from(n.childNodes).forEach(function(c){
                if(c.nodeType===3){
                  c.nodeValue = c.nodeValue.replace(/\s*\(\s*/g,'(').replace(/\s*\)\s*/g,')');
                }
              });
            });
            return root.innerHTML;
          }else{
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            const steps = tmp.querySelector('.steps');
            if(steps) return steps.outerHTML;
            return tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }
});
})();
</script>

<script>
/* Quelques conforts UI (pas liés au bug) */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        }
      });
      document.body.appendChild(bar);
    }
  }

  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
