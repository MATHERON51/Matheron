<html lang="fr">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Seconde – Chapitre 2 – Images et antécédents – Exercices</title>
<link href="../../../../css/math-kbd.css" rel="stylesheet"/>
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:nowrap;gap:8px;align-items:center;overflow-x:auto}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#666}

/* grille : énoncé + saisie en ligne 1, corrigé plein largeur en dessous */
.row{
  display:grid;
  grid-template-columns:1fr minmax(240px,320px);
  grid-template-areas:
    'lab inp'
    'res res';
  gap:10px;
  align-items:start;
}
.row .col-label{grid-area:lab}
.row input[type=text]{grid-area:inp}
.row #res{grid-area:res;margin-top:2px}

.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.equ{font-weight:600}
.hint{opacity:.85;margin:.2rem 0 .6rem}

/* Fractions “pile” (sans LaTeX) */
.frac{display:inline-flex;flex-direction:column;align-items:center;vertical-align:middle;line-height:1}
.frac .num,.frac .den{padding:0 .2em; white-space:nowrap}
.frac .bar{border-top:1.6px solid currentColor;align-self:stretch;margin:.06em 0}
.frac-sign{margin-right:.15em}

/* Bloc étapes : lignes simples, éviter les retours qui cassent l'alignement du signe = */
.steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0; white-space:nowrap}

/* === Bloc .equ-offscreen : ENONCÉ complet (consigne + équation) pour le PDF === */
@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; top:auto !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;} /* pas de doublon de consigne */
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
}
.equ-offscreen .consigne{margin-bottom:6px;font-weight:600}


/* --- Correctif "espaces collés" (écran) ---
   Ajoute un espace visuel avant chaque fragment inline (strong/em/span/etc.)
   quand ils sont des enfants directs des blocs d'énoncé/consigne.
   N'affecte pas le bloc offscreen utilisé pour le PDF. */
.equ > *::before,
.consigne > *::before,
#host .lead > *::before { content: " "; }
.equ > :first-child::before,
.consigne > :first-child::before,
#host .lead > :first-child::before { content: none; }
/* Ne pas injecter ces espaces dans la version offscreen (PDF) */
.equ-offscreen > *::before,
.equ-offscreen .consigne > *::before { content: normal !important; content: none !important; }

/* Override: disable generic ::before spacing (screen) */
.equ > *::before,
.consigne > *::before,
#host .lead > *::before,
.equ > :first-child::before,
.consigne > :first-child::before,
#host .lead > :first-child::before { content: normal !important; }

/* PDF/Offscreen : ne pas afficher la barre de saisie dans l'énoncé */
.equ-offscreen input,
.equ-offscreen textarea,
.equ-offscreen select,
.equ-offscreen .input,
.equ-offscreen .inputs,
.equ-offscreen .reponse,
.equ-offscreen .reponses,
.equ-offscreen .answer,
.equ-offscreen .answers,
.equ-offscreen .field,
.equ-offscreen .fields { display:none !important; }

</style>
</head>
<body>
<div class="header">
<h1 style="margin:0;font-size:1.1rem">Seconde – Chapitre 2 – <strong>Images et antécédents</strong></h1>
</div>
<div class="wrap">
<div class="controls card">
<label for="exo-select"><strong>Type d’exercice :</strong></label>
<select id="exo-select"></select>
<button class="btn" id="btn-new" title="Générer un nouvel énoncé">🔄 Nouvel énoncé</button>
<button class="btn" id="btn-check" title="Vérifier votre réponse (Entrée ⏎)">✅ Vérifier</button>
<button class="btn" id="btn-solution" title="Afficher la solution détaillée">💡 Solution</button>
<button class="btn" id="btn-reset" title="Réinitialiser et remettre le score à zéro">🧹 Réinitialiser</button>
<span class="score">Score : <span id="score">0 / 0</span></span>
</div>
<div class="card" id="host"></div>
<div class="card small">
<strong>Saisie &amp; réponses acceptées :</strong>
<ul style="margin:8px 0 0 18px">
<li><strong>Entrée ⏎</strong> déclenche <em>Vérifier</em>.</li>
<li><strong>Décimales :</strong> virgule <code class="code">,</code> ou point <code class="code">.</code>.</li>
<li><strong>Fractions :</strong> taper <code class="code">a/b</code> (affichage en fraction verticale).</li>
<li><strong>Équations / antécédents :</strong> répondre au format <code class="code">S = { a ; b }</code> (ou <code class="code">S = ∅</code> si aucune solution).</li>
<li><strong>Domaines :</strong> écrire <code class="code">ℝ</code>, <code class="code">]-∞ ; +∞[</code>, <code class="code">[a ; b]</code>, <code class="code">]a ; b[</code>, unions avec <code class="code">∪</code>. <em>∞</em> accepté sous forme <code class="code">∞</code>, <code class="code">-∞</code>, <code class="code">+∞</code>.</li>
<li><strong>Plusieurs éléments :</strong> séparer par <code class="code">;</code> (ordre indifférent).</li>
</ul>
</div>
<!-- Clavier math, centré -->
<div class="card">
<div data-math-kbd="" style="display:flex; justify-content:center"></div>
</div>
</div>
<!-- libs (multiplicatif) -->
<script defer="" src="../../../../js/dev-rules-clean.dedup.js"></script>
<script defer="" src="../../../../js/math-kbd.js"></script>
<script defer="" src="../../../../js/exo-pdf-kit.multiplicatif.js"></script>
<script defer="" src="../../../../js/algebra-eval-patch.multiplicatif.js"></script>
<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
/* ===== utilitaires ===== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ===== rationnels / affichage jolies fractions ===== */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function norm(p,q){ if(q===0) throw new Error('denominator 0'); let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; } return {p,q}; }
function makeR(p,q){ return norm(p,q||1); }
function addR(A,B){ return norm(A.p*B.q + B.p*A.q, A.q*B.q); }
function subR(A,B){ return norm(A.p*B.q - B.p*A.q, A.q*B.q); }
function mulR(A,B){ return norm(A.p*B.p, A.q*B.q); }
function divR(A,B){ if(B.p===0) throw new Error('div by 0'); return norm(A.p*B.q, A.q*B.p); }
function toNumber(R){ return R.p/R.q; }

function fracHTML(p,q){
  // Jamais "/1"
  const neg = (p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg? '−':'')+String(p);
  return (neg?'<span class="frac-sign">−</span>':'')+
    '<span class="frac"><span class="num">'+p+'</span><span class="bar"></span><span class="den">'+q+'</span></span>';
}
function fmtConstHTML(R){ return (R.q===1? String(R.p) : fracHTML(R.p,R.q)); }
/* Quotient joli de deux expressions HTML (ne renvoie pas de "/1") */
function Q(numHTML, denHTML){
  const d = String(denHTML).trim();
  if(d==='1') return numHTML;
  return '<span class="frac"><span class="num">'+numHTML+'</span><span class="bar"></span><span class="den">'+denHTML+'</span></span>';
}
function asFracPlain(R){ return (R.q===1? String(R.p) : R.p+'/'+R.q); } // pour l’input S={...}

/* ===== affichage fonctions ===== */
function fmtCoeffXHTML(A){
  if(A.p===A.q) return 'x';
  if(A.p===-A.q) return '−x';
  return fmtConstHTML(A)+'x';
}
function fmtSignedCoeffXHTML(B){
  if(B.p===0) return '';
  const sign=(B.p>0?' + ':' − '), abs={p:Math.abs(B.p),q:B.q};
  if(abs.p===abs.q) return sign+'x';
  return sign+fmtConstHTML(abs)+'x';
}
function fmtSignedConstHTML(B){
  if(B.p===0) return '';
  const sign=(B.p>0?' + ':' − '), abs={p:Math.abs(B.p),q:B.q};
  return sign+fmtConstHTML(abs);
}
function sideHTML(A,B){ return fmtCoeffXHTML(A)+fmtSignedConstHTML(B); }

/* ===== nettoyage signes & format nombres après "×" ===== */
function normalizeSigns(s){
  return s.replace(/\+\s*-\s*/g,' − ')
          .replace(/-\s*\+\s*/g,' − ')
          .replace(/-\s*-\s*/g,' + ')
          .replace(/\s{2,}/g,' ')
          .trim();
}

/* Supprimer toute apparition de "+ 0" ou "− 0" (mais laisser "= 0") */
function removePlusZero(s){
  return s.replace(/\s[+−]\s0(?![0-9])/g,'');
}
function fmtAfterTimes(n,isFirst=false){ return (n<0 && !isFirst) ? '('+n+')' : String(n); }

/* ===== parsing réponses ===== */
function normText(s){
  return String(s||'').replace(/\u2212/g,'-').replace(/∞/g,'oo').replace(/ℝ/g,'R').replace(/∪/g,'U').replace(/\s+/g,' ').trim();
}
function numberFromText(s){
  const t=normText(s);
  const mFrac=t.match(/([-+]?\d+)\s*\/\s*([-+]?\d+)/);
  if(mFrac){ const p=+mFrac[1], q=+mFrac[2]; if(q!==0) return p/q; }
  const mDec=t.match(/[-+]?\d+(?:[.,]\d+)?/);
  return mDec? parseFloat(mDec[0].replace(',','.')) : NaN;
}
function parseSet(input){
  let t=normText(input).toLowerCase().replace(/\s+/g,'').replace(/,/g,';');
  if(t==='s=∅'||t==='∅'||t==='s={}'||t==='aucunesolution'||t==='pasdesolution'||t==='vide') return {empty:true, list:[]};
  t=t.replace(/^s=/,'').replace(/^\{/,'').replace(/\}$/,'').replace(/^x=/,'');
  if(!t) return {empty:false, list:[]};
  const parts=t.split(';').filter(Boolean);
  const list=parts.map(numberFromText).filter(v=>!Number.isNaN(v));
  return {empty:false, list};
}
function sameSetAnswer(user, expected){
  const p=parseSet(user);
  if(expected.length===0) return p.empty || p.list.length===0;
  if(p.list.length!==expected.length) return false;
  const a=[...p.list].sort((x,y)=>x-y), b=[...expected].sort((x,y)=>x-y);
  for(let i=0;i<a.length;i++) if(Math.abs(a[i]-b[i])>1e-9) return false;
  return true;
}
function fmtSetHTML(arr){
  if(!arr || arr.length===0) return 'S = ∅';
  const items = arr.map(v=>{
    if(typeof v==='number') return fmtConstHTML({p:v,q:1});
    if(v && typeof v==='object' && 'p' in v && 'q' in v) return fmtConstHTML(v);
    return String(v);
  }).join(' ; ');
  return 'S = { '+items+' }';
}

/* ===== Exercices ===== */

/* A1 — Image f(x)=ax+b */
const exA1 = {
  id:'img_affine', title:'Image : f(x)=ax+b → f(x₀)',
  gen(){ let a=0; while(a===0) a=rnd(-5,5); const b=rnd(-9,9), x0=rnd(-6,6);
    const A=makeR(a,1), B=makeR(b,1), X0=makeR(x0,1);
    const val=addR(mulR(A,X0),B);
    return {A,B,X0,val}; },
  text(s){ return 'Soit <strong>f(x) = '+sideHTML(s.A,s.B)+'</strong>. Calculer <strong>f('+s.X0.p+')</strong>.'; },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">${this.text(s)}</div>
        <input id="reponse" type="text" placeholder="nombre">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.val)]) ||
               (numberFromText($('#reponse',host).value)===toNumber(s.val));
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+fmtConstHTML(s.val)+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const a=s.A.p,b=s.B.p,x0=s.X0.p, ax=a*x0, sum=ax+b;
    const steps=[
      `f(${fmtAfterTimes(x0,true)}) = ${a}×${fmtAfterTimes(x0,false)} ${(b>=0?'+':'−')} ${Math.abs(b)}`,
      `f(${fmtAfterTimes(x0,true)}) = ${ax} ${(b>=0?'+':'−')} ${Math.abs(b)}`,
      `f(${fmtAfterTimes(x0,true)}) = ${sum}`
    ].map(function(t){return removePlusZero(normalizeSigns(t));});
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value=String(sum);
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* A2 — Image P(x)=ax²+bx+c */
const exA2 = {
  id:'img_poly', title:'Image : P(x)=ax²+bx+c → P(x₀)',
  gen(){ let a=0; while(a===0) a=rnd(-3,3); const b=rnd(-5,5), c=rnd(-6,6), x0=rnd(-4,4);
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1), X0=makeR(x0,1);
    const x02=makeR(x0*x0,1), val=addR(addR(mulR(A,x02),mulR(B,X0)),C);
    return {A,B,C,X0,x02,val}; },
  text(s){ return 'Soit <strong>P(x) = '+fmtConstHTML(s.A)+'x²'+fmtSignedCoeffXHTML(s.B)+fmtSignedConstHTML(s.C)+'</strong>. Calculer <strong>P('+s.X0.p+')</strong>.'; },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">${this.text(s)}</div>
        <input id="reponse" type="text" placeholder="nombre">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.val)]) ||
               (numberFromText($('#reponse',host).value)===toNumber(s.val));
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+fmtConstHTML(s.val)+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const a=s.A.p,b=s.B.p,c=s.C.p,x0=s.X0.p, ax2=a*(x0*x0), bx=b*x0, sum=ax2+bx+c;
    const steps=[
      `P(${fmtAfterTimes(x0,true)}) = ${a}×(${fmtAfterTimes(x0,true)})² ${(b>=0?'+':'−')} ${Math.abs(b)}×${fmtAfterTimes(x0,false)} ${(c>=0?'+':'−')} ${Math.abs(c)}`,
      `P(${fmtAfterTimes(x0,true)}) = ${ax2} ${(bx>=0?'+':'−')} ${Math.abs(bx)} ${(c>=0?'+':'−')} ${Math.abs(c)}`,
      `P(${fmtAfterTimes(x0,true)}) = ${sum}`
    ].map(function(t){return removePlusZero(normalizeSigns(t));});
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value=String(sum);
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* B1 — Antécédent : f(x)=ax+b, f(x)=y0  → S={…} */
const exB1 = {
  id:'ant_affine', title:'Antécédent : f(x)=ax+b, résoudre f(x)=y₀',
  gen(){ let a=0; while(a===0) a=rnd(-9,9); const b=rnd(-12,12), y0=rnd(-12,12);
    const A=makeR(a,1), B=makeR(b,1), Y=makeR(y0,1);
    const rhs=subR(Y,B), S=divR(rhs,A), raw={p:rhs.p*A.q,q:rhs.q*A.p};
    return {A,B,Y,rhs,S,raw}; },
  text(s){ return 'Antécédent de <strong>'+fmtConstHTML(s.Y)+'</strong> pour <strong>f(x) = '+sideHTML(s.A,s.B)+'</strong>.'; },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">
          ${this.text(s)}
          <div class="hint">Les antécédents de <strong>${fmtConstHTML(s.Y)}</strong> par la fonction sont :</div>
        </div>
        <input id="reponse" type="text" placeholder="S = { … }">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.S)]);
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+fmtSetHTML([s.S])+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const lines = [
      sideHTML(s.A,s.B)+' = '+fmtConstHTML(s.Y),
      fmtCoeffXHTML(s.A)+' = '+fmtConstHTML(s.Y)+' − '+fmtConstHTML(s.B),
      fmtCoeffXHTML(s.A)+' = '+fmtConstHTML(s.rhs),
    ];
    // Afficher "x = p/q" brut puis (si différent) "x = forme irréductible"
    const rawHTML = 'x = '+fracHTML(s.raw.p,s.raw.q);
    const simpHTML = 'x = '+fmtConstHTML(s.S);
    const same = (s.raw.p*s.S.q === s.S.p*s.raw.q); // égalité numérique p1/q1 == p2/q2
    lines.push(rawHTML);
    if(!same) lines.push(simpHTML);
    lines.push(fmtSetHTML([s.S]));

    const steps = lines.map(function(t){return removePlusZero(normalizeSigns(t));});
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value = 'S={ '+asFracPlain(s.S)+' }';
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};


/* B2 — Antécédents de c pour g(x)=ax²+bx+c (produit nul en TABLE inline, inside .steps) */
const exB2 = {
  id:'ant_quad_c', title:'Antécédents de c pour g(x)=ax²+bx+c (factorisation)',
  gen(){ 
    let a=0; while(a===0) a=rnd(-5,5);
    let b=0; while(b===0) b=rnd(-9,9);
    const c=rnd(-6,6);
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1);
    const X2=divR(makeR(-b,1),makeR(a,1)); // -b/a
    return {A,B,C,X2};
    },
  text(s){ return 'Antécédents de <strong>'+fmtConstHTML(s.C)+'</strong> pour <strong>g(x) = '+fmtConstHTML(s.A)+'x²'+fmtSignedCoeffXHTML(s.B)+fmtSignedConstHTML(s.C)+'</strong>.'; },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">
          ${this.text(s)}
          <div class="hint">Les antécédents de <strong>${fmtConstHTML(s.C)}</strong> par la fonction sont :</div>
        </div>
        <input id="reponse" type="text" placeholder="S = { 0 ; … }">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [0, toNumber(s.X2)]);
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+fmtSetHTML([{p:0,q:1}, s.X2])+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const a=s.A.p, b=s.B.p, c=s.C.p;
    const plus = (b>=0? ' + ' : ' − ');
    const linesTop=[
      `${a}x²${plus}${Math.abs(b)}x ${(c>=0?'+':'−')} ${Math.abs(c)} = ${c}`,
      `${a}x²${plus}${Math.abs(b)}x = 0`,
      `x(${a}x${plus}${Math.abs(b)}) = 0`
    ].map(function(t){return removePlusZero(normalizeSigns(t));});

    // TABLE "produit nul" 100% inline styles (PDF-safe)
    const tableHTML =
      `<table role="presentation" style="border-collapse:collapse;width:100%;margin:.25rem 0">
        <tr>
          <td style="border:none;padding:.1rem .6rem;vertical-align:top;">
            <span style="display:block;margin:.15rem 0">x = 0</span>
          </td>
          <td style="border:none;padding:.1rem .4rem;vertical-align:middle;text-align:center;font-weight:700;white-space:nowrap;">ou</td>
          <td style="border:none;padding:.1rem .6rem;vertical-align:top;">
            <span style="display:block;margin:.15rem 0">${a}x${plus}${Math.abs(b)} = 0</span>
            <span style="display:block;margin:.15rem 0">${a}x = ${-b}</span>
            <span style="display:block;margin:.15rem 0">x = ${fracHTML(-b,a)}</span>
          </td>
        </tr>
      </table>`.replace(/\s+\n/g,'\n');

    const setLine = fmtSetHTML([{p:0,q:1}, s.X2]);

    // ====> tout est dans .steps (copié tel quel par le PDF)
    $('#res',host).innerHTML =
      '<div class="steps">' +
        linesTop.map(t=>`<div class="step">${t}</div>`).join('') +
        `<div class="step">${tableHTML}</div>` +
        `<div class="step">${setLine}</div>` +
      '</div>';

    $('#reponse',host).value = 'S={ 0 ; '+asFracPlain(s.X2)+' }';
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};



/* B4 — Antécédent homographique (quotient joli, pas de "/1")  → S={…} */
const exB4 = {
  id:'ant_homo', title:'Antécédent : (ax+b)/(cx+d) = k (dénominateur non nul)',
  gen(){
    let a=0,c=0; while(a===0) a=rnd(-6,6); while(c===0) c=rnd(-6,6);
    const b=rnd(-8,8), d=rnd(-8,8), k=choice([-2,-1,1,2,3]);
    const num=k*d - b, den=a - k*c; if(den===0) return this.gen();
    const sol=makeR(num,den), pole=makeR(-d,c);
    if(Math.abs(toNumber(sol)-toNumber(pole))<1e-9) return this.gen();
    return {a,b,c,d,k,sol,pole};
  },
  text(s){
    const N = s.a+'x '+(s.b>=0?'+':'−')+' '+Math.abs(s.b);
    const D = s.c+'x '+(s.d>=0?'+':'−')+' '+Math.abs(s.d);
    return 'Pour <strong>p(x)='+Q(N,D)+'</strong>, déterminer l’antécédent de <strong>'+s.k+'</strong>.';
  },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">
          ${this.text(s)}
          <div class="hint">Les antécédents de <strong>${s.k}</strong> par la fonction sont :</div>
        </div>
        <input id="reponse" type="text" placeholder="S = { … }">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const ok = sameSetAnswer($('#reponse',host).value, [toNumber(s.sol)]);
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+fmtSetHTML([s.sol])+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const a=s.a,b=s.b,c=s.c,d=s.d,k=s.k;
    const N=a+'x '+(b>=0?'+':'−')+' '+Math.abs(b);
    const D=c+'x '+(d>=0?'+':'−')+' '+Math.abs(d);

    const rawNum = k*d - b, rawDen = a - k*c;
    const rawLine = `x = ${fracHTML(rawNum, rawDen)}`;
    const simpLine = `x = ${fmtConstHTML(makeR(rawNum, rawDen))}`;

    const steps=[
      Q(N,D)+' = '+k,
      N+' = '+k+'('+D+')',
      `${a}x ${(b>=0?'+':'−')} ${Math.abs(b)} = ${(k*c)}x ${((k*d)>=0?'+':'−')} ${Math.abs(k*d)}`,
      `${a - k*c}x = ${k*d - b}`,
      rawLine,
      simpLine,                            // résultat irréductible AVANT la condition
      `Condition : (${D}) ≠ 0  ⇒  x ≠ ${fracHTML(-d,c)}`, // pas de Q(...,'1')
      fmtSetHTML([s.sol])
    ].map(function(t){return removePlusZero(normalizeSigns(t));});

    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value = 'S={ '+asFracPlain(s.sol)+' }';
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* C1 — Domaine : affine */
const exC1 = {
  id:'dom_affine', title:'Ensemble de définition : affine',
  gen(){ let a=rnd(-9,9); if(a===0) a=1; const b=rnd(-9,9); return {a,b}; },
  text(s){ return 'Donner l’ensemble de définition de <strong>f(x) = '+s.a+'x '+(s.b>=0?'+':'−')+' '+Math.abs(s.b)+'</strong>.'; },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">${this.text(s)}</div>
        <input id="reponse" type="text" placeholder="ℝ  ou  ]-∞; +∞[">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host){
    const t=String($('#reponse',host).value).replace(/\s+/g,'').toLowerCase().replace(/∞/g,'oo').replace(/ℝ/g,'r');
    const ok = (t==='r'||t===']-oo;+oo[');
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : ℝ  ou  ]-∞; +∞[';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host){
    const steps=['Une affine est définie pour tout réel.','D = ℝ (ou ]-∞; +∞[)'];
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value='ℝ';
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* C2 — Domaine : √(ax+b) */
const exC2 = {
  id:'dom_sqrt', title:'Ensemble de définition : √(ax+b)',
  gen(){ let a=0; while(a===0) a=rnd(-5,5); const b=rnd(-9,9); return {a,b}; },
  text(s){ return 'Donner l’ensemble de définition de <strong>g(x) = √('+s.a+'x '+(s.b>=0?'+':'−')+' '+Math.abs(s.b)+')</strong>.'; },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">${this.text(s)}</div>
        <input id="reponse" type="text" placeholder="${s.a>0? '[ '+(-s.b)+'/'+s.a+' ; +∞[' : ']-∞ ; '+(-s.b)+'/'+s.a+']'}">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const thr=divR(makeR(-s.b,1),makeR(s.a,1)), t=toNumber(thr), n=String($('#reponse',host).value).replace(/\s+/g,'').toLowerCase().replace(/∞/g,'oo');
    let ok=false;
    if(s.a>0){ ok = n===`[${thr.p}/${thr.q};+oo[` || n===`[${t};+oo[` || n===`x>=${t}`; }
    else{ ok = n===`]-oo;${thr.p}/${thr.q}]` || n===`]-oo;${t}]` || n===`x<=${t}`; }
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+(s.a>0? '['+asFracPlain(thr)+' ; +∞[' : ']-∞ ; '+asFracPlain(thr)+']')+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const thr=divR(makeR(-s.b,1),makeR(s.a,1)), tStr=fmtConstHTML(thr);
    const steps = (s.a>0)
      ? [ `${s.a}x ${(s.b>=0?'+':'−')} ${Math.abs(s.b)} ≥ 0`, `x ≥ ${tStr}`, `D = [${tStr} ; +∞[` ]
      : [ `${s.a}x ${(s.b>=0?'+':'−')} ${Math.abs(s.b)} ≥ 0`, `x ≤ ${tStr}`, `D = ]-∞ ; ${tStr}]` ];
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(normalizeSigns).map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value = (s.a>0? '['+asFracPlain(thr)+' ; +∞[' : ']-∞ ; '+asFracPlain(thr)+']');
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* C3 — Domaine : (ax+b)/(cx+d) – quotient joli */
const exC3 = {
  id:'dom_homo', title:'Ensemble de définition : (ax+b)/(cx+d)',
  gen(){ let c=0; while(c===0) c=rnd(-6,6); const a=rnd(-6,6), b=rnd(-8,8), d=rnd(-8,8);
    const pole=divR(makeR(-d,1),makeR(c,1)); return {a,b,c,d,pole}; },
  text(s){
    const N = s.a+'x '+(s.b>=0?'+':'−')+' '+Math.abs(s.b);
    const D = s.c+'x '+(s.d>=0?'+':'−')+' '+Math.abs(s.d);
    return 'Donner l’ensemble de définition de <strong>h(x) = '+Q(N,D)+'</strong>.';
  },
  render(host,s){
    host.innerHTML='';
    host.innerHTML = `
      <div class="row">
        <div class="equ">${this.text(s)}</div>
        <input id="reponse" type="text" placeholder="ℝ\\{x₀}  ou  ]-∞ ; x₀[ ∪ ]x₀ ; +∞[">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const x0=toNumber(s.pole), x0s=asFracPlain(s.pole);
    const t=String($('#reponse',host).value).replace(/\s+/g,'').replace(/∞/g,'oo').toLowerCase();
    const ok = t===`r\\{${x0s}}` || t===`r\\{${x0}}` || t===`]-oo;${x0s}[u]${x0s};+oo[` || t===`]-oo;${x0}[u]${x0};+oo[`;
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : ℝ\\{'+fmtConstHTML(s.pole)+'}  ou  ]-∞ ; '+fmtConstHTML(s.pole)+'[ ∪ ]'+fmtConstHTML(s.pole)+' ; +∞[';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    const x0=fmtConstHTML(s.pole);
    const steps=[
      'On cherche les valeurs interdites en résolvant l’équation <em>dénominateur</em> = 0 :',
      `${s.c}x ${(s.d>=0?'+':'−')} ${Math.abs(s.d)} = 0`,
      `${s.c}x = ${-s.d}`,
      `x = ${x0}`,
      `Réponse : ℝ\\{${x0}}  (ou  ]-∞ ; ${x0}[ ∪ ]${x0} ; +∞[)`
    ].map(function(t){return removePlusZero(normalizeSigns(t));});
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#reponse',host).value='ℝ\\{'+asFracPlain(s.pole)+'}';
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* E — Formats à trous (mix) */
const exE = {
  id:'mini', title:'Formats à trous (mix)',
  gen(){ const t=choice([1,2,3,4,5,6]);
    if(t===1){ const a=rnd(1,5)*choice([1,-1]), b=rnd(-6,6), x0=rnd(-4,4); return {fmt:1,a,b,x0,val:a*x0+b}; }
    if(t===2){ return {fmt:2}; } // antécédents de 0 pour x²-1
    if(t===3){ return {fmt:3}; } // domaine sqrt
    if(t===4){ const n=rnd(1,5); return {fmt:4,n}; } // domaine quotient
    if(t===5){ return {fmt:5}; } // équation (x-3)/(x+2)=1
    if(t===6){ return {fmt:6}; } // domaine mixte
  },
  text(s){
    if(s.fmt===1) return 'Soit <strong>f(x)='+s.a+'x '+(s.b>=0?'+':'−')+' '+Math.abs(s.b)+'</strong>. Calculer <strong>f('+s.x0+')</strong>.';
    if(s.fmt===2) return 'Pour <strong>g(x)=x²−1</strong>, antécédents de <strong>0</strong>.';
    if(s.fmt===3) return 'Pour <strong>h(x)=√(x+4)</strong>, donner <strong>D_h</strong>.';
    if(s.fmt===4) return 'Pour <strong>p(x)='+Q('x − 3','x + '+s.n)+'</strong>, donner <strong>D_p</strong>.';
    if(s.fmt===5) return 'Résoudre <strong>'+Q('x − 3','x + 2')+' = 1</strong>.';
    if(s.fmt===6) return 'Pour <strong>k(x)='+Q('√(4−x)','x − 3')+'</strong>, donner <strong>D_k</strong>.'; },
  render(host,s){
    host.innerHTML='';
    const hint = (s.fmt===2)? `<div class="hint">Les antécédents de <strong>0</strong> par la fonction sont :</div>` : '';
    const ph = (s.fmt===1? 'nombre'
              : s.fmt===2? 'S = { … ; … }'
              : s.fmt===3? '[-2 ; +∞['
              : s.fmt===4? 'ℝ\\{-'+s.n+'}  ou  ]-∞ ; -'+s.n+'[ ∪ ]-'+s.n+' ; +∞['
              : s.fmt===5? 'S = ∅'
              : ']-∞ ; 3[ ∪ ]3 ; 4]');
    host.innerHTML = `
      <div class="row">
        <div class="equ">${this.text(s)}${hint}</div>
        <input id="reponse" type="text" placeholder="${ph}">
        <div id="res"></div>
      </div>`;
    $('#reponse',host).focus();
  },
  correct(host,s){
    const val=$('#reponse',host).value;
    let ok=false, exp='';
    if(s.fmt===1){ ok = (numberFromText(val)===s.val) || sameSetAnswer(val,[s.val]); exp=String(s.val); }
    if(s.fmt===2){ ok = sameSetAnswer(val,[-1,1]); exp=fmtSetHTML([{p:-1,q:1},{p:1,q:1}]); }
    if(s.fmt===3){ const thr=divR(makeR(-4,1),makeR(1,1)); const n=String(val).replace(/\s+/g,'').toLowerCase().replace(/∞/g,'oo'); ok=(n==='[-2;+oo['||n==='x>=-2'); exp='[-2 ; +∞['; }
    if(s.fmt===4){ const n=s.n; const t=String(val).replace(/\s+/g,'').toLowerCase().replace(/∞/g,'oo'); ok=(t===`r\\{-${n}}`||t===`]-oo;-${n}[u]-${n};+oo[`); exp='ℝ\\{-'+n+'}  (ou  ]-∞ ; -'+n+'[ ∪ ]-'+n+' ; +∞[)'; }
    if(s.fmt===5){ ok = parseSet(val).empty; exp='S = ∅'; }
    if(s.fmt===6){ const t=String(val).replace(/\s+/g,'').toLowerCase().replace(/∞/g,'oo'); ok=(t===']-oo;3[u]3;4]'); exp=']-∞ ; 3[ ∪ ]3 ; 4]'; }
    $('#res',host).innerHTML = ok? '✔' : '✘ (attendu : '+exp+')';
    $('#res',host).className = ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host,s){
    let steps=[];
    if(s.fmt===1){ const a=s.a,b=s.b,x0=s.x0, ax=a*x0, sum=ax+b;
      steps=[ `f(${fmtAfterTimes(x0,true)}) = ${a}×${fmtAfterTimes(x0,false)} ${(b>=0?'+':'−')} ${Math.abs(b)}`,
              `f(${fmtAfterTimes(x0,true)}) = ${ax} ${(b>=0?'+':'−')} ${Math.abs(b)}`,
              `f(${fmtAfterTimes(x0,true)}) = ${sum}` ];
      $('#reponse',host).value=String(sum);
    }
    if(s.fmt===2){ steps=[ 'x² − 1 = 0', '(x − 1)(x + 1) = 0', fmtSetHTML([{p:-1,q:1},{p:1,q:1}]) ]; $('#reponse',host).value='S={ -1 ; 1 }'; }
    if(s.fmt===3){ steps=['x + 4 ≥ 0','x ≥ −2','D = [-2 ; +∞[']; $('#reponse',host).value='[-2 ; +∞['; }
    if(s.fmt===4){ steps=['Dénominateur : x + '+s.n+' ≠ 0','x ≠ '+(s.n>0? '−'+s.n : s.n),'D = ℝ\\{−'+s.n+'} (ou ]-∞ ; −'+s.n+'[ ∪ ]−'+s.n+' ; +∞[)']; $('#reponse',host).value='ℝ\\{-'+s.n+'}'; }
    if(s.fmt===5){ steps=[ Q('x − 3','x + 2')+' = 1','x − 3 = x + 2','0 = 5  ⇒  '+fmtSetHTML([]) ]; $('#reponse',host).value='S=∅'; }
    if(s.fmt===6){ steps=['4 − x ≥ 0  ⇒  x ≤ 4','x − 3 ≠ 0  ⇒  x ≠ 3','D = ]-∞ ; 3[ ∪ ]3 ; 4]']; $('#reponse',host).value=']-∞ ; 3[ ∪ ]3 ; 4]'; }
    steps=steps.map(function(t){return removePlusZero(normalizeSigns(t));});
    $('#res',host).innerHTML = '<div class="steps">'+steps.map(t=>`<div class="step">${t}</div>`).join('')+'</div>';
    $('#res',host).className='small';
  },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; }
};

/* ===== REGISTRY ===== */
const REGISTRY=[exA1,exA2,exB1,exB2,exB4,exC1,exC2,exC3,exE];
window.REGISTRY=REGISTRY; // pour le générateur PDF


/* ===== Bootstrap commun (hérité d’« équations.html ») ===== */
/* ===== Bootstrap commun ===== */
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function buildOne(){
  const sel=$("#exo-select");
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const state=def.gen();
  host.dataset.active = def.id;
  host.dataset.state = JSON.stringify(state);
  def.render(host, state);
  const inp = $("#reponse", host) || $("input[type=text]", host);
  if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const state=JSON.parse(host.dataset.state||"{}");
  const r = def.correct(host, state);
  if(r){ scoreOK += r.ok?1:0; scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(!def) return;
  const state=JSON.parse(host.dataset.state||"{}");
  def.solution(host, state);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def) def.reset(host);
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{
    const opt=document.createElement("option");
    opt.value=e.id; opt.textContent=e.title;
    sel.appendChild(opt);
  });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);

  sel.value = REGISTRY[0].id;
  buildOne();
  updateScore();

  // Initialisation PDF (version “multiplicatif” avec hook)
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: 'Seconde – Chapitre 2 – Images et antécédents',
      max: 50,
      mountAfterSelector: '.card.small', // après le clavier
      
beforeRender(def, st, withSolutions){
        try{
          // Re-render offscreen pour récupérer l'énoncé
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          def.render(tmp, st);
          if(!withSolutions){
            // Cibler l'énoncé complet
            const root = tmp.querySelector('.equ-offscreen') || tmp;
            // 1) Retirer toute saisie (inputs/select/textarea, boutons)
            root.querySelectorAll('input, select, textarea, button').forEach(el=>el.remove());
            // 2) Retirer blocs de saisie si présents
            root.querySelectorAll('.input, .inputs, .reponse, .reponses, .answer, .answers, .field, .fields').forEach(el=>el.remove());
            // 3) Nettoyer petits espaces autour des parenthèses
            root.querySelectorAll('*').forEach(function(n){
              if(n.childNodes) Array.from(n.childNodes).forEach(function(c){
                if(c.nodeType===3){
                  c.nodeValue = c.nodeValue.replace(/\s*\(\s*/g,'(').replace(/\s*\)\s*/g,')');
                }
              });
            });
            return root.innerHTML;
          }else{
            // Solution: récupérer bloc .steps propre
            if(typeof def.solution==='function'){ def.solution(tmp, st); }
            // Souvent les pages rangent la solution dans .steps
            const steps = tmp.querySelector('.steps');
            if(steps) return steps.outerHTML;
            return tmp.innerHTML;
          }
        }catch(e){ return null; }
      }
    });
  }

  // — Activer la normalisation Unicode des signes (−, ×…) après chargement des libs
  if (window.DevRules && DevRules.attachCleaner) DevRules.attachCleaner();
});
})();
</script>

<script>
// Smart space normalizer: inserts a single space only between word/digit runs.
// Avoids adding spaces inside math like f(x) or f(-3).
(function(){
  function isAlphaNum(ch) {
    return /[A-Za-zÀ-ÖØ-öø-ÿ0-9]/.test(ch);
  }
  function firstChar(node) {
    let t = (node.textContent || '').replace(/^\s+/, '');
    return t.charAt(0);
  }
  function lastChar(node) {
    let t = (node.textContent || '').replace(/\s+$/, '');
    return t.charAt(t.length - 1);
  }
  function needsSpace(prev, cur) {
    if (!prev || !cur) return false;
    const a = lastChar(prev);
    const b = firstChar(cur);
    if (!a || !b) return false;
    // Only add when both sides are alphanumeric (word/digit), not punctuation like '('
    return isAlphaNum(a) && isAlphaNum(b);
  }
  function alreadySeparated(prev, cur) {
    const a = (prev.textContent || '');
    const b = (cur.textContent || '');
    return /\s$/.test(a) || /^\s/.test(b);
  }
  function normalize(container) {
    if (!container) return;
    const nodes = Array.from(container.childNodes);
    for (let i = 1; i < nodes.length; i++) {
      const prev = nodes[i - 1];
      const cur  = nodes[i];
      if (alreadySeparated(prev, cur)) continue;
      if (needsSpace(prev, cur)) {
        cur.parentNode.insertBefore(document.createTextNode(' '), cur);
      }
    }
    // Recurse into element children to catch nested inline wrappers
    nodes.forEach(n => { if (n.nodeType === 1) normalize(n); });
  }
  window.addEventListener('DOMContentLoaded', function(){
    document.querySelectorAll('.consigne, .equ, #host .lead').forEach(normalize);
  });
})();
</script>



<script>
/* Protect visible consignes and solutions from global cleaner and repair spacing to match PDF output. */
(function(){
  function protect(el){
    if (!el) return;
    if (el.dataset.protected === '1') return;
    el.contentEditable = 'true';
    el.dataset.protected = '1';
  }
  function repairText(el){
    if (!el) return;
    var tw = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
    var node;
    while ((node = tw.nextNode())){
      var t = node.nodeValue;
      if (!t) continue;
      var fixed = t.replace(/\s*\(\s*/g,'(').replace(/\s*\)\s*/g,')');
      if (fixed !== t) node.nodeValue = fixed;
    }
    Array.from(el.childNodes).forEach(function(n,i,arr){
      if (i===0) return;
      var prev = arr[i-1], cur = n;
      function endChar(n){ var s=(n.textContent||'').replace(/\s+$/,''); return s.charAt(s.length-1); }
      function startChar(n){ var s=(n.textContent||'').replace(/^\s+/,''); return s.charAt(0); }
      var a=endChar(prev), b=startChar(cur);
      if (a && b && /[A-Za-zÀ-ÖØ-öø-ÿ0-9]/.test(a) && /[A-Za-zÀ-ÖØ-öø-ÿ]/.test(b)){
        if (!(/\s$/.test(prev.textContent||'') || /^\s/.test(cur.textContent||''))){
          el.insertBefore(document.createTextNode(' '), cur);
        }
      }
    });
  }
  function apply(root){
    var scope = root || document;
    scope.querySelectorAll('#host .equ, #host .consigne, #host .lead, #host .steps, #host .step').forEach(function(el){
      protect(el);
      repairText(el);
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ apply(document); });
  } else { apply(document); }
  var host = document.getElementById('host');
  if (host){
    var mo = new MutationObserver(function(){ setTimeout(function(){ apply(host); }, 0); });
    mo.observe(host, {subtree:true, childList:true});
  }
  ['#btn-new','#btn-check','#btn-reset','#btn-solution'].forEach(function(sel){
    var b = document.querySelector(sel);
    if (b){ b.addEventListener('click', function(){ setTimeout(function(){ apply(document); }, 0); }, true); }
  });
})();
</script>



<script>
/* Dédoublonnage + tri croissant pour S = { ... } (écran + PDF) — anti-freeze */
(function(){
  var UMINUS = '−';
  function normalizeSpaces(s){ return (s||'').replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim(); }
  function textFromHTML(html){
    var d=document.createElement('div'); d.innerHTML=html; return d.textContent||'';
  }
  function parseNumeric(text){
    // return a numeric value or NaN if not numeric
    if (!text) return NaN;
    var t = text.replace(new RegExp(UMINUS,'g'), '-').replace(',', '.').trim();
    // fraction a/b
    var m = t.match(/^\s*([+-]?\d+(?:\.\d+)?)\s*\/\s*([+-]?\d+(?:\.\d+)?)\s*$/);
    if (m){ var a=parseFloat(m[1]), b=parseFloat(m[2]); if(b===0) return NaN; return a/b; }
    // plain number
    var n = Number(t);
    return isFinite(n) ? n : NaN;
  }
  function tokenKey(htmlFrag){
    var txt = normalizeSpaces(textFromHTML(htmlFrag));
    // Map common fraction markup to a/b for a stable key
    try{
      var d=document.createElement('div'); d.innerHTML=htmlFrag;
      var frac=d.querySelector('.frac');
      if(frac){
        var spans=frac.querySelectorAll('span'); if(spans.length>=2){
          var a=normalizeSpaces(spans[0].textContent||'');
          var b=normalizeSpaces(spans[spans.length-1].textContent||'');
          if(a && b) txt = a + '/' + b;
        }
      }
    }catch(e){}
    // Normalize signs
    txt = txt.replace(new RegExp(UMINUS,'g'), '-');
    txt = txt.replace(/^\+/, '');
    txt = txt.replace(/^-0(?:([.,]0+)?)?$/, '0');
    return txt;
  }
  function valueFor(htmlFrag){
    // Compute numeric value used for sorting if possible
    var key = tokenKey(htmlFrag).replace(',', '.');
    return parseNumeric(key);
  }
  function dedupeAndSort(inner){
    // inner = raw HTML between { and }
    // Split with semicolons that separate items
    var parts = inner.split(';');
    var seen = Object.create(null);
    var items = [];
    for (var i=0;i<parts.length;i++){
      var frag = parts[i];
      var html = frag.replace(/^\s+|\s+$/g,'');
      if (!html) continue;
      var key = tokenKey(html);
      if (!key) continue;
      if (!seen[key]){
        seen[key] = { html: html, key: key, val: valueFor(html) };
        items.push(seen[key]);
      }
    }
    // Sort by numeric value when both comparable, else by key (localeCompare)
    items.sort(function(a,b){
      var an=isFinite(a.val), bn=isFinite(b.val);
      if(an && bn){
        if(a.val < b.val) return -1;
        if(a.val > b.val) return 1;
        // Tiebreaker: shorter / simpler key first
        if(a.key.length !== b.key.length) return a.key.length - b.key.length;
        return a.key.localeCompare(b.key);
      }
      if(an && !bn) return -1;  // numbers before non-numbers
      if(!an && bn) return 1;
      return a.key.localeCompare(b.key);
    });
    return items.map(it=>it.html).join(' ; ');
  }
  function processElement(el){
    // Replace every S = { ... } block inside this element
    var html = el.innerHTML;
    if(!html || html.indexOf('S')===-1 || html.indexOf('{')===-1) return false;
    var changed = false;
    var out = html.replace(/S\s*=\s*\{([\s\S]*?)\}/g, function(m, inner){
      var ds = dedupeAndSort(inner);
      if (ds !== inner){ changed = true; }
      return 'S = { ' + ds + ' }';
    });
    if(changed){ el.innerHTML = out; }
    return changed;
  }

  var busy = false, needsRun = false, mo=null;
  function run(root){
    if(busy){ needsRun = true; return; }
    busy = true;
    if(mo){ try{ mo.disconnect(); }catch(e){} }
    try{
      var scope = root || document;
      var list = scope.querySelectorAll('.steps, .step, .equ, .lead, .equ-offscreen');
      for(var i=0;i<list.length;i++){ processElement(list[i]); }
    } finally {
      busy = false;
      if(needsRun){ needsRun=false; run(root); }
      // Reconnect observer
      if(!mo){
        var host = document.getElementById('host');
        if(host){
          mo = new MutationObserver(function(){ run(host); });
          mo.observe(host, {subtree:true, childList:true});
        }
      } else {
        var host = document.getElementById('host');
        if(host){ mo.observe(host, {subtree:true, childList:true}); }
      }
    }
  }

  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', function(){ run(document); }); }
  else { run(document); }

  // Also trigger after clicking "Solution" or "Nouvel énoncé"
  ['#btn-solution','#btn-new'].forEach(function(sel){
    var b = document.querySelector(sel);
    if(b){ b.addEventListener('click', function(){ setTimeout(function(){ run(document); }, 0); }, true); }
  });
})();
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d’actions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on déclenche .click() sur eux)
[['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l’original est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si présent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s’ouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>