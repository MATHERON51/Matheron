<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seconde ‚Äî Repr√©sentation graphique</title>

<!-- m√™mes d√©pendances que ton exemple -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="courbes-print-fix.css">

<style>
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:12px 16px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:12px;box-shadow:0 1px 2px rgba(0,0,0,.04)}

  .controls{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .btn{padding:6px 10px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .row{display:grid;grid-template-columns:560px 1fr;gap:12px;align-items:start}
  .row.single{grid-template-columns:1fr}
  @media (max-width:980px){ .row{grid-template-columns:1fr} }

  .statement{font-size:18px}
  .consigne{opacity:.9;margin-bottom:6px}

  /* SVGs */
  svg.repere{display:block;margin:.25rem auto;width:min(560px,100%);height:auto;aspect-ratio:560/360}
  /* quand on ouvre la correction on r√©duit juste un peu pour √©viter ‚Äúrep√®res trop grands‚Äù */
  body.solution-active svg.repere{width:min(520px,100%)}

  .qa{display:grid;grid-template-columns:26px 1fr;gap:8px;align-items:start}
  .qmark{min-width:1.2em;text-align:center;font-weight:700}

  /* Espaces automatiques autour des nombres affich√©s */
  .num::before{content:" ";} .num::after{content:" ";}
  .input-wrap input[type="text"], .tbl input[type="text"]{margin:0 6px}

  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}

  .tbl{border-collapse:collapse;margin:.3rem 0;max-width:100%}
  .tbl th,.tbl td{border:1px solid #000;padding:3px 4px;text-align:center}
  .tbl input{width:6ch}

  /* Ex.5 ‚Äì tuiles */
  .mini-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:14px}
  @media (max-width:980px){ .mini-grid{grid-template-columns:repeat(2,minmax(0,1fr))} }
  @media (max-width:640px){ .mini-grid{grid-template-columns:1fr} }
  .mini{background:#fff;border:1px solid #e6e6e6;border-radius:10px;padding:8px;overflow:hidden}
  .mini .title{font-weight:600;margin-bottom:6px;text-align:center}
  .badge{display:inline-block;font-size:.8rem;border-radius:999px;padding:2px 8px;margin-left:6px}
  .ok{background:#e6f4ea;color:#14532d;border:1px solid #b7e0c2}
  .ko{background:#fee2e2;color:#991b1b;border:1px solid #f6b3b3}

  /* Ex.3 : labels plus visibles */
  svg.repere[data-heavylabels="1"] text{font-size:12.5px;font-weight:600}
  .thin-grid{opacity:.6}
  .heavy-grid{opacity:.78}

  @media print{ .tbl{border-collapse:collapse} .tbl th,.tbl td{border:1px solid #000 !important;padding:2px 6px} 
    .header,.controls{display:none !important}
    .wrap{max-width:100%}
    .card{border:none;box-shadow:none;padding:0}
    .row{grid-template-columns:1fr}
    svg.repere{height:auto}
  
  }

/* --- Hide interactive UI in PDF/print --- */
@media print {
  #themeSel { display:none !important; }
  select#themeSel { display:none !important; }
}


  .helper-line{ vector-effect: non-scaling-stroke; stroke-linecap: butt; }

/* Arrondir les extr√©mit√©s/joints de la courbe */
.plot path {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Traits d'aide, non d√©pendants du zoom */
.helper-line {
  vector-effect: non-scaling-stroke;
  stroke-linecap: butt;
}

<style media="print">
  /* R√©duit tous les SVG de courbe en PDF */
  .repere svg { width: 340px !important; height: 230px !important; }
  .repere text { font-size: 10pt !important; }
  .repere .grid line { stroke-width: .4 !important; }
  .repere .axis line, .repere .axis path { stroke-width: .8 !important; }
</style>

</style>
<style>

/* Widen columns for tables (notably Ex.4) */
.tbl { table-layout: auto; border-collapse: collapse; }
.tbl th, .tbl td { padding: 6px 10px; }
.tbl td { min-width: 120px; }

</style>
</head>
<body>
<script>

// Guard: limit antecedents selector to max 5 everywhere
(function(){
  const sel = document.getElementById('cfg-ant');
  if(sel){
    // If it's a number input
    if(sel.type === 'number'){
      if(!sel.max || parseInt(sel.max,10) > 5) sel.max = '5';
      if(parseInt(sel.value||'0',10) > 5) sel.value = '5';
    }
    // If it's a select, drop options >5 at runtime (in case of cached markup)
    if(sel.tagName === 'SELECT'){
      Array.from(sel.options).forEach(op=>{
        var v = parseInt(op.value,10);
        if(v>5) op.remove();
      });
      if(parseInt(sel.value||'0',10) > 5) sel.value = '5';
    }
  }
})();

</script>

  <div class="header">
    <h1 style="margin:0;font-size:1.05rem">Seconde ‚Äî <strong>Repr√©sentation graphique</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <!-- Amplitude pour Ex.1, 2, 4 -->
    <div class="controls card" id="ampbar">
      <strong>Amplitude (max ¬±12)&nbsp;:</strong>
      x ‚àà [&nbsp;<input id="xmin" type="number" value="-5" min="-12" max="12" step="1">&nbsp;;&nbsp;
      <input id="xmax" type="number" value="6"  min="-12" max="12" step="1">&nbsp;],
      y ‚àà [&nbsp;<input id="ymin" type="number" value="-6" min="-12" max="12" step="1">&nbsp;;&nbsp;
      <input id="ymax" type="number" value="6"  min="-12" max="12" step="1">&nbsp;]
      <button id="amp-apply" class="btn">‚Ü¥ Appliquer</button>

      <span style="margin-left:12px"></span>
      <label><small># images</small> <input id="cfg-img" type="number" min="1" max="10" value="2" style="width:64px"></label>
      <label class="small" style="margin-left:12px"><input id="pdfRandAmp" type="checkbox"> PDF : amplitude al√©atoire</label>
      <label class="small" style="margin-left:10px"><input id="pdfRandNA" type="checkbox"> PDF : nombre images al√©atoire</label>
      <label class="small" style="margin-left:10px"><input id="pdfRandTheme" type="checkbox"> PDF : th√®me al√©atoire (exo&nbsp;3)</label>
    </div>

    <div class="card" id="host"></div>
    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:8px 0 0 18px">
        <li><b>Ensemble de d√©finition</b> : format <span class="code">[a ; b]</span> ‚Äî ex. <span class="code">[‚àí6 ; 6]</span>. Espaces facultatifs¬†: <span class="code">[‚àí6;6]</span> accept√©.</li>
        <li><b>Image</b> (valeur de <span class="code">f(x)</span>) : nombre entier ou d√©cimal ‚Äî virgule <span class="code">2,5</span> ou point <span class="code">2.5</span> accept√©s ; signe ¬´ ‚àí ¬ª normalis√©.</li>
        <li><b>Ant√©c√©dent(s)</b> : liste s√©par√©e par points-virgules ‚Äî ex. ‚àí4 ; 0 ; 3. L‚Äôordre n‚Äôa pas d‚Äôimportance.</li>
      </ul>
    </div>


    <!-- emplacement UI PDF (identique √† l‚Äôexemple) -->
    <div class="card small" id="pdf-slot"></div>

    <!-- Clavier maths (pilot√© par la lib) -->
    <div class="card" data-math-kbd></div>
  </div>

<!-- m√™mes libs que ton projet -->

<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.multiplicatif.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js"></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>


<script>
(function(){
'use strict';

/* =================== Helpers & Format FR (virgule) =================== */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function uniq(arr,eq=(a,b)=>a===b){ const out=[]; arr.forEach(v=>{ if(!out.some(u=>eq(u,v))) out.push(v); }); return out; }
function shuffle(a){ a = Array.isArray(a) ? [...a] : []; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
const FRfmt = new Intl.NumberFormat('fr-FR',{maximumFractionDigits:2, useGrouping:false});
const fmtFR = n => FRfmt.format(n).replace('-', '‚àí');                // 1,5 et signe ‚àí
const fmtNum = n => `<span class="num">${fmtFR(n)}</span>`;          // espaces auto autour
const fmtUnit = (n,u)=> `${fmtNum(n)}&nbsp;${u||''}`;                 // espace ins√©cable entre nombre et unit√©
const parseNumFR = s => Number(String(s||'').replace(/\u2212/g,'-').replace(',','.').trim());
const parseListFR = s => !s ? [] : String(s).replace(/[{}()[\]]/g,'').split(/[;:,]/).map(parseNumFR).filter(Number.isFinite);

/* ========= Amplitudes contr√¥lables (Exos 1,2,4) ========= */
let AMP={ xmin:-5,xmax:6,ymin:-6,ymax:6 };
function applyAMP(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  if(!(xi<=xa)) [xi,xa]=[xa,xi];
  if(!(yi<=ya)) [yi,ya]=[ya,yi];
  xi=clamp(xi,-12,12); xa=clamp(xa,-12,12);
  yi=clamp(yi,-12,12); ya=clamp(ya,-12,12);
  if(xi===xa) xa=xi+1; if(yi===ya) ya=yi+1;
  AMP={ xmin:xi,xmax:xa,ymin:yi,ymax:ya };
  document.body.classList.remove('solution-active');
  buildOne();
}

/* =================== Rep√®res =================== */
/* TOUTES LES GRADUATIONS coll√©es AUX AXES (y √† gauche de l‚Äôaxe ; x sous l‚Äôaxe) + fl√®ches */
let __clipId=0;
function buildRepereSVG(opts){
  const W0=560, H0=360; const mLeft=28, mTop=6, mRight=6, mBottom=24; const W=W0+mLeft+mRight, H=H0+mTop+mBottom;
  const xmin=opts.xmin, xmax=opts.xmax, ymin=opts.ymin, ymax=opts.ymax;

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.classList.add('repere');

  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const clip=document.createElementNS(svg.namespaceURI,'clipPath'); const cid='clip'+(++__clipId);
  clip.setAttribute('id',cid); const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',mLeft);
  crect.setAttribute('y',mTop);
  crect.setAttribute('width',W0);
  crect.setAttribute('height',H0); clip.appendChild(crect);
  const marker=document.createElementNS(svg.namespaceURI,'marker'); marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d','M0,0 L6,3 L0,6 Z'); tri.setAttribute('fill','#111'); marker.appendChild(tri);
  defs.appendChild(marker); defs.appendChild(clip); svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g'); const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot'); plot.setAttribute('clip-path','url(#'+cid+')'); svg.appendChild(axes); svg.appendChild(plot);

  const X=x=>mLeft + (x-xmin)*W0/(xmax-xmin);
  const Y=y=>mTop + H0 - (y-ymin)*H0/(ymax-ymin);

  // cadre
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',mLeft); frame.setAttribute('y',mTop); frame.setAttribute('width',W0); frame.setAttribute('height',H0);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); axes.appendChild(frame);
  // clipPath pour forcer l'affichage entier de la courbe dans le cadre
  frame.setAttribute('class','frame');
  const clipId = 'clip-'+Math.random().toString(36).slice(2);
  const cp=document.createElementNS(svg.namespaceURI,'clipPath'); cp.setAttribute('id',clipId);
  const r2=document.createElementNS(svg.namespaceURI,'rect');
  r2.setAttribute('x',mLeft); r2.setAttribute('y',mTop); r2.setAttribute('width',W0); r2.setAttribute('height',H0);
  cp.appendChild(r2); defs.appendChild(cp);
  plot.setAttribute('clip-path','url(#'+clipId+')');


  // axes -> positions ; clamp pour rester visibles pour les labels
  const yAxisY = clamp(Y(0), mTop+10, mTop+H0-10);
  const xAxisX = clamp(X(0), mLeft+10, mLeft+W0-10);

  // grille + labels coll√©s AUX AXES
  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7'); g.setAttribute('class','thin-grid');
    const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');

    const stepX=(opts.ticks && opts.ticks.x)||1;
    for(let xv=Math.ceil(xmin/stepX)*stepX; xv<=xmax+1e-9; xv+=stepX){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',0); l.setAttribute('x2',xx); l.setAttribute('y2',H); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(xv);
      t.setAttribute('x', clamp(xx, mLeft+14, mLeft+W0-14) );
      t.setAttribute('y', clamp(yAxisY+14, mTop+14, mTop+H0+12) );      // SOUS l‚Äôaxe des abscisses
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }

    const stepY=(opts.ticks && opts.ticks.y)||1;
    for(let yv=Math.ceil(ymin/stepY)*stepY; yv<=ymax+1e-9; yv+=stepY){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',0); l.setAttribute('y1',yy); l.setAttribute('x2',W); l.setAttribute('y2',yy); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(yv);
      t.setAttribute('x', clamp(xAxisX-6, mLeft+6, mLeft+W0-8) );        // √Ä GAUCHE de l‚Äôaxe des ordonn√©es
      t.setAttribute('y', clamp(yy+4, mTop+10, mTop+H0-6) );
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }

    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }

  // axes avec fl√®ches
  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',mLeft); axX.setAttribute('x2',mLeft+W0-8);
  axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY);
  axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','3'); if(opts.arrows){ axX.setAttribute('marker-end','url(#arrow)'); } axes.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX);
  axY.setAttribute('y1',mTop+H0); axY.setAttribute('y2',mTop+8);
  axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','3'); if(opts.arrows){ axY.setAttribute('marker-end','url(#arrow)'); } axes.appendChild(axY);

  return {svg,plot,axes,X,Y,xmin,xmax,ymin,ymax,W,H};
}

/* Rep√®re orthonorm√© (Ex.5) ‚Äî amplitude sym√©trique et quadrillage complet */
function buildRepereOrtho(opts){
  const W=560,H=360;
  const xmin=opts.xmin, xmax=opts.xmax, ymin=opts.ymin, ymax=opts.ymax;
  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox','0 0 560 360'); svg.classList.add('repere');

  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const marker=document.createElementNS(svg.namespaceURI,'marker'); marker.setAttribute('id','arrow_o'); marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d','M0,0 L6,3 L0,6 Z'); tri.setAttribute('fill','#111'); marker.appendChild(tri);
  defs.appendChild(marker); svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g'); const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot'); svg.appendChild(axes); svg.appendChild(plot);

  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',0); frame.setAttribute('y',0); frame.setAttribute('width',W); frame.setAttribute('height',H);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); axes.appendChild(frame);

  const sx=W/(xmax-xmin), sy=H/(ymax-ymin), s=Math.min(sx,sy);
  const cx=W/2, cy=H/2;
  const X=x=>cx + s*x, Y=y=>cy - s*y;

  const yAxisY = Y(0), xAxisX = X(0);

  // grille + labels (coll√©s aux axes)
  const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7'); g.setAttribute('class','heavy-grid');
  const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');
  const stepX=(opts.ticks&&opts.ticks.x)||1;
  for(let xv=Math.ceil(xmin/stepX)*stepX; xv<=xmax+1e-9; xv+=stepX){
    const xx=X(xv);
    const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',0); l.setAttribute('x2',xx); l.setAttribute('y2',H); g.appendChild(l);
    const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(xv);
    t.setAttribute('x', clamp(xx,14,W-14) ); t.setAttribute('y', clamp(yAxisY+14,14,H-4) );
    t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle'); tx.appendChild(t);
  }
  const stepY=(opts.ticks&&opts.ticks.y)||1;
  for(let yv=Math.ceil(ymin/stepY)*stepY; yv<=ymax+1e-9; yv+=stepY){
    const yy=Y(yv);
    const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',0); l.setAttribute('y1',yy); l.setAttribute('x2',W); l.setAttribute('y2',yy); g.appendChild(l);
    const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(yv);
    t.setAttribute('x', clamp(xAxisX-6,8,W-8) ); t.setAttribute('y', clamp(yy+4,10,H-6) );
    t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end'); ty.appendChild(t);
  }
  axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);

  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',0); axX.setAttribute('x2',W-8); axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY);
  axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','3'); axX.setAttribute('marker-end','url(#arrow_o)'); axes.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX); axY.setAttribute('y1',H); axY.setAttribute('y2',8);
  axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','3'); axY.setAttribute('marker-end','url(#arrow_o)'); axes.appendChild(axY);

  return {svg,plot,axes,X,Y,xmin,xmax,ymin,ymax,W,H};
}

/* ========== Courbes utilitaires (Ex.1/2/4) ========== */
function catmullRomPath(points){
  if(points.length<2) return '';
  const P=i=>points[Math.max(0,Math.min(points.length-1,i))];
  let d=`M ${points[0].x} ${points[0].y}`;
  for(let i=0;i<points.length-1;i++){
    const p0=P(i-1), p1=P(i), p2=P(i+1), p3=P(i+2);
    const c1x=p1.x+(p2.x-p0.x)/6, c1y=p1.y+(p2.y-p0.y)/6;
    const c2x=p2.x-(p3.x-p1.x)/6, c2y=p2.y-(p3.y-p1.y)/6;
    d+=` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
  }
  return d;
}
function addPath(g,d,st){ const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#000'); p.setAttribute('stroke-width',st?.['stroke-width']||2.2);
  if(st?.['stroke-dasharray']) p.setAttribute('stroke-dasharray',st['stroke-dasharray']);
  if(st?.['stroke-opacity']) p.setAttribute('stroke-opacity',st['stroke-opacity']);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
function addLine(g,x1,y1,x2,y2,st){ const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
  l.setAttribute('stroke',st?.stroke||'#000'); l.setAttribute('stroke-width',st?.['stroke-width']||2); if(st?.['stroke-dasharray']) l.setAttribute('stroke-dasharray',st['stroke-dasharray']); if(st?.['stroke-opacity']) l.setAttribute('stroke-opacity',st['stroke-opacity']);
  g.appendChild(l); return l; }

function genCurveIntegerGrid(R, forceCross=true){
  const xs=[], ys=[];
  for(let x=R.xmin; x<=R.xmax; x++){
    ys.push(rnd(R.ymin+1,R.ymax-1)); xs.push(x);
  }
  if(forceCross){
    ys[Math.floor(xs.length/4)]=rnd(-3,-1);
    ys[Math.floor(xs.length/2)]=rnd(1,3);
    ys[Math.floor(3*xs.length/4)]=rnd(-3,-1);
    if(xs.includes(0)) ys[xs.indexOf(0)]=rnd(R.ymin+1,R.ymax-1);
  }
  return { Xs: xs, Ys: ys };
}


function buildGridWithConstraints(R, nbAnt, Yask){
  // Construit une grille enti√®re telle que, pour chaque y ‚àà Yask,
  // les seules solutions de f(x)=y soient des x entiers impos√©s.
  nbAnt = clamp(parseInt(nbAnt||1,10),1,10);
  const xs=[], ys=[];
  for(let x=R.xmin; x<=R.xmax; x++) xs.push(x);

  const YsAsk = (Yask||[]).filter(y=>Number.isFinite(y));
  const minY = Math.min(...YsAsk, R.ymax);
  const maxY = Math.max(...YsAsk, R.ymin);

  const roomBelow = (minY - (R.ymin+1)) >= 1;
  const roomAbove = ((R.ymax-1) - maxY) >= 1;

  let baselineRange;
  if(roomBelow){ baselineRange = [R.ymin+1, Math.floor(minY)-1]; }
  else if(roomAbove){ baselineRange = [Math.ceil(maxY)+1, R.ymax-1]; }
  else { baselineRange = [R.ymin+1, R.ymin+1]; }

  // baseline enti√®re, d'un seul c√¥t√© de tous les y demand√©s
  for(let i=0;i<xs.length;i++){
    const a = baselineRange[0], b = baselineRange[1];
    ys.push(a===b? a : rnd(a,b));
  }

  const taken = new Set();
  (YsAsk||[]).forEach(y=>{
    let k=0, guard=0;
    while(k<nbAnt && guard<5000){
      const x = rnd(R.xmin, R.xmax);
      guard++;
      const idx = x - R.xmin;
      const key = y+':'+idx;
      if(taken.has(key)) continue;
      taken.add(key);
      ys[idx] = y;
      if(idx>0 && ys[idx-1]===y) ys[idx-1] += (roomBelow? -1 : +1);
      if(idx<ys.length-1 && ys[idx+1]===y) ys[idx+1] += (roomBelow? -1 : +1);
      k++;
    }
  });

  return { Xs: xs, Ys: ys };
}
const pathFromGrid = (rep, grid) => {
  const pts = grid.Xs.map((x,i)=>({x:rep.X(x), y:rep.Y(grid.Ys[i])}));
  if(pts.length===0) return '';
  let d = 'M '+pts[0].x+' '+pts[0].y;
  for(let i=1;i<pts.length;i++){
    d += ' L '+pts[i].x+' '+pts[i].y;
  }
  return d;
};

const pathFromGridSmooth = (rep, grid) => {
  const X = rep.X, Y = rep.Y, Xs = grid.Xs, Ys = grid.Ys;
  const n = Xs.length; if(n < 2) return '';
  const forced = new Set((grid.Forced||[]).map(i=>i));

  // slopes on grid (h=1)
  const s = new Array(n-1);
  for(let i=0;i<n-1;i++) s[i] = Ys[i+1]-Ys[i];

  // Steffen-like monotone slopes with zero slope at extrema
  const d = new Array(n);
  d[0] = s[0]; d[n-1] = s[n-2];
  for(let i=1;i<n-1;i++){
    const s0=s[i-1], s1=s[i];
    if(s0*s1 <= 0){ d[i] = 0; }
    else{
      const a=Math.abs(s0), b=Math.abs(s1);
      d[i] = (Math.sign(s0)+Math.sign(s1)) * Math.min(a,b,0.5*(a+b));
    }
  }

  // soften globally and near forced points
  const scale = 0.60;
  for(let i=0;i<n;i++){
    if(forced.has(i)){
      d[i] = 0;
      if(i>0) d[i-1] *= 0.4;
      if(i<n-1) d[i+1] *= 0.4;
    } else {
      d[i] *= scale;
    }
  }

  // Hermite -> cubic B√©zier segments
  let dstr = `M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){
    const x0=Xs[i], x1=Xs[i+1], y0=Ys[i], y1=Ys[i+1], h=x1-x0; // h=1
    const c1x=X(x0 + h/3), c1y=Y(y0 + d[i]*h/3);
    const c2x=X(x1 - h/3), c2y=Y(y1 - d[i+1]*h/3);
    dstr += ` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return dstr;
};

function interpAtGrid(grid, x){
  const {Xs,Ys}=grid;
  if(x<Xs[0] || x> Xs[Xs.length-1]) return null;
  const i=Math.floor(x - Xs[0]);
  if(Math.abs(x - Math.round(x))<1e-9) return Ys[i];
  const k=Math.floor(x), idx=k - Xs[0];
  const y1=Ys[idx], y2=Ys[idx+1];
  return y1 + 0.5*(y2-y1);
}

function pickYsIntOrHalf(R, count){
  const vals=[];
  for(let y=R.ymin+1; y<=R.ymax-1; y++){
    vals.push(y);
    if(y+0.5 < R.ymax) vals.push(y+0.5);
  }
  return uniq(shuffle(vals)).slice(0,count);
}
function pickXsIntOrHalf(R, count){
  const vals=[];
  for(let x=R.xmin+1; x<=R.xmax-1; x++){
    vals.push(x);
    if(x+0.5 < R.xmax) vals.push(x+0.5);
  }
  return uniq(shuffle(vals)).slice(0,count);
}


function approxEqualList(found, expected, tol=0.2){
  if(found.length!==expected.length) return false;
  const F = found.slice().sort((a,b)=>a-b);
  const E = expected.slice().sort((a,b)=>a-b);
  for(let i=0;i<F.length;i++){
    if(Math.abs(F[i]-E[i])>tol) return false;
  }
  return true;
}

function antecedentsOfGrid(grid, y){
  const out=[];
  for(let i=0;i<grid.Xs.length-1;i++){
    const x1=grid.Xs[i], x2=grid.Xs[i+1], y1=grid.Ys[i], y2=grid.Ys[i+1];
    if(y===y1) out.push(x1);
    if(y===y2) out.push(x2);
    if((y1<y && y<y2) || (y2<y && y<y1)){
      const t=(y-y1)/((y2-y1)||1e-9); const x=x1+t*(x2-x1); out.push(x);
    }
  }
    // Snap x very close to integers to avoid tiny offsets (overlap with image helpers)
  const snapped = out.map(x => (Math.abs(x - Math.round(x)) < 1e-6 ? Math.round(x) : x));
  return uniq(snapped, (a,b)=>Math.abs(a-b)<1e-9);

}

/* ========== Vues g√©n√©riques ========== */
function mkRow(host,consigneHTML){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const st=document.createElement('div'); st.className='statement';
  st.innerHTML='<div class="consigne">'+(consigneHTML||'')+'</div>';
  const form=document.createElement('div'); form.className='input-wrap';
  const res=document.createElement('div'); res.id='res';
  row.appendChild(st); row.appendChild(form); row.appendChild(res);
  host.appendChild(row);
  try { __forceWordParenSpaces(form); __forceWordParenSpaces(st); } catch(e) {}
  return {row,st,form,res};
}
function showSteps(host, steps){   try{ let r=$('#res',host); if(!r){ r=document.createElement('div'); r.id='res'; host.appendChild(r);} }catch(e){}
$('#res',host).innerHTML = '<div class="steps">'+steps.map(s=>'<div class="step">'+s+'</div>').join('')+'</div>';
  try { __forceWordParenSpaces($('#res',host)); } catch(e) {} }
function clearMarks(host){ host.querySelectorAll('.qmark').forEach(m=>m.textContent=''); (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = ('');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })(); const plot=host.querySelector('.plot'); if(plot){ plot.querySelectorAll('line[stroke-dasharray]').forEach(n=>n.remove()); } }


function __forceWordParenSpaces(root){
  if(!root) return;
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  const reAfter = /(\))([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø])/g;
  const reBefore = /([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]{2,})(\()/g;
  let n;
  while((n = walker.nextNode())){
    const s = n.nodeValue;
    const t = s.replace(reAfter, '$1\u00A0$2').replace(reBefore, '$1\u00A0$2');
    if(t !== s) n.nodeValue = t;
  }
}

/* ========================== EXERCICE 1 ========================== */
const ex1 = {
  id:'rg1',
  title:`Lecture graphique (x entiers)`,
  gen(){
    const R={...AMP};

    // nombre de questions demand√© par les s√©lecteurs
    const qImg = clamp(parseInt($('#cfg-img')?.value||2,10),1,10);
    const qAnt = 3;

    // pools d'entiers visibles
    const Xpool=[]; for(let x=R.xmin+1; x<=R.xmax-1; x++) Xpool.push(x);
    const Ypool=[]; for(let y=R.ymin+1; y<=R.ymax-1; y++) Ypool.push(y);

    let grid=null, Ximg=null, Yimg=null, Ysolv=null, yNone=null, Yask=null;

    outer: for(let attempt=0; attempt<300; attempt++){
      // 1) base grid
      grid = genCurveIntegerGrid(R, true);

      // 2) IMAGES ‚Äî choisir qImg abscisses enti√®res telles que les images soient toutes distinctes
      let okImg=false;
      for(let t=0; t<200; t++){
        const xs = uniq(shuffle(Xpool)).slice(0,qImg).sort((a,b)=>a-b);
        const ys = xs.map(x=>interpAtGrid(grid,x));
        const uniqY = uniq(ys,(a,b)=>Math.abs(a-b)<1e-9);
        if (uniqY.length===ys.length){ Ximg=xs; Yimg=ys; okImg=true; break; }
      }
      if(!okImg) continue;

      // 3) ANT√âC√âDENTS ‚Äî on veut (qAnt-1) y avec 1..3 solutions enti√®res + 1 y inexistant
      const wantAntPerY =  Math.min(3, 3); // borne haute 3
      let okAnt=false, gForced=null, ysChosen=[];

      for(let t=0; t<400; t++){
        // choisir (qAnt-1) y distincts √† l'int√©rieur
        const ysTry = uniq(shuffle(Ypool)).slice(0, Math.max(0,qAnt-1));
        // forcer la grille pour ces y avec <=3 ant√©c√©dents
        gForced = buildGridWithConstraints(R, wantAntPerY, ysTry);
        // v√©rif: chaque yTry doit avoir entre 1 et 3 solutions enti√®res
        const allOk = ysTry.every(y=>{
  const A = antecedentsOfGrid(gForced, y);
  const Ai = A.filter(x=>Math.abs(x - Math.round(x))<1e-9);
  const An = A.filter(x=>Math.abs(x - Math.round(x))>=1e-9);
  return Ai.length>=1 && Ai.length<=3 && An.length===0;
});
        if(allOk){ ysChosen = ysTry; okAnt=true; break; }
      }
      if(!okAnt) continue;

      // y inexistant : prioritairement un y int√©rieur sans intersection sur gForced
      const zeroInside = Ypool.filter(y => !ysChosen.includes(y) && antecedentsOfGrid(gForced, y).length===0);
      yNone = zeroInside.length ? zeroInside[0] : (Math.random()<0.5 ? (R.ymax+1) : (R.ymin-1));

      grid = gForced;
      Ysolv = ysChosen;
      Yask = [...Ysolv, yNone];
      break outer;
    }

    return { R, grid, Ximg, Yask };



  },
  render(host,st){
    const ui=mkRow(host,'Lecture graphique.');
    const rep=buildRepereSVG({xmin:st.R.xmin,xmax:st.R.xmax,ymin:st.R.ymin,ymax:st.R.ymax,grid:true,arrows:true});
    addPath(rep.plot, pathFromGridSmooth(rep, st.grid), {stroke:'#c00','stroke-width':3.2});
    ui.st.appendChild(rep.svg);

    let html = `<div class="qa"><div class="q">1.</div><div class="a">Ensemble de d√©finition&nbsp;:&nbsp;<input id="aD" type="text"><span id="aDm" class="qmark"></span></div></div>`;
    st.Ximg.forEach((x,i)=>{
      html+=`<div class="qa"><div class="q">${i+2}.</div><div class="a">Image de ${fmtNum(x)}:&nbsp;<input id="aI${i}" type="text"><span id="aI${i}m" class="qmark"></span></div></div>`;
    });
    st.Yask.forEach((y,j)=>{
      const k=2+st.Ximg.length+j;
      html+=`<div class="qa"><div class="q">${k}.</div><div class="a">Ant√©c√©dent(s) de ${fmtNum(y)}:&nbsp;<input id="aA${j}" type="text"><span id="aA${j}m" class="qmark"></span></div></div>`;
    });
    ui.form.innerHTML=html;
    host.dataset.state=JSON.stringify(st); host.dataset.active='rg1';
  
    
    // Clear prefilled Domaine input for Ex.1
    (function(){ const aD = $('#aD',host); if(aD) aD.value=''; })();
// INLINE_COLORIZED: appliquer couleurs directement dans l‚Äô√©nonc√©
    try {
      const paletteI = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e'];
      const paletteA = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f'];
      if (Array.isArray(st.Ximg)) st.Ximg.forEach((x,i)=>{
        const input = host.querySelector('#aI'+i);
        if(input && input.parentElement) {
          const a = input.parentElement;
          const needle = 'Image de ' + fmtNum(x) + ':';
          const repl = 'Image de <span style="color:'+paletteI[i%5]+';font-weight:700">'+fmtNum(x)+'</span> :';
          a.innerHTML = a.innerHTML.replace(needle, repl);
        }
      });
      if (Array.isArray(st.Yask)) st.Yask.forEach((y,j)=>{
        const input = host.querySelector('#aA'+j);
        if(input && input.parentElement) {
          const a = input.parentElement;
          const needle = 'Ant√©c√©dent(s) de ' + fmtNum(y) + ':';
          const repl = 'Ant√©c√©dent(s) de <span style="color:'+paletteA[j%5]+';font-weight:700">'+fmtNum(y)+'</span> :';
          a.innerHTML = a.innerHTML.replace(needle, repl);
        }
      });
    } catch(e){}
    },
  solution(host,st){
  const rep = host.querySelector('svg.repere');
const plot = rep.querySelector('.plot');
// Aligner les pointill√©s exactement sur le cadre interne du rep√®re
const frame = rep.querySelector('rect.frame');
const mLeft = +frame.getAttribute('x');
const mTop  = +frame.getAttribute('y');
const W0    = +frame.getAttribute('width');
const H0    = +frame.getAttribute('height');
const X = x => mLeft + (x - st.R.xmin) * W0 / (st.R.xmax - st.R.xmin);
const Y = y => mTop + H0 - (y - st.R.ymin) * H0 / (st.R.ymax - st.R.ymin);

  // axes visibles ?
  const hasXaxis = (st.R.ymin <= 0 && 0 <= st.R.ymax); // axe des abscisses (y=0)
  const hasYaxis = (st.R.xmin <= 0 && 0 <= st.R.xmax); // axe des ordonn√©es (x=0)

  // --- Images : traits vers les AXES ---
  st.Ximg.forEach((x,i)=>{
    const col = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e'][i%5];
    const y  = interpAtGrid(st.grid, x);

    // vertical : (x,y) ‚Üí (x, 0) si l‚Äôaxe x existe, sinon fallback bas (ymin)
    addLine(plot,
      X(x), Y(y),
      X(x), hasXaxis ? Y(0) : (hasXaxis ? Y(0) : Y(st.R.ymin)),
      { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-dashoffset': 0, 'stroke-opacity': 0.95, 'class': 'helper-line' }
    );

    // horizontal : (x,y) ‚Üí (0,y) si l‚Äôaxe y existe, sinon fallback bord gauche (xmin)
    addLine(plot,
      hasYaxis ? X(0) : (hasYaxis ? X(0) : X(st.R.xmin)), Y(y),
      X(x), Y(y),
      { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-dashoffset': 0, 'stroke-opacity': 0.95, 'class': 'helper-line' }
    );
  });

  // --- Ant√©c√©dents : traits vers les AXES ---
  st.Yask.forEach((y,j)=>{
    const col = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f'][j%5];
    antecedentsOfGrid(st.grid, y).forEach(x=>{
      // vertical : (x,y) ‚Üí (x, 0) si axe x visible, sinon bas
      addLine(plot,
        X(x), Y(y),
        X(x), hasXaxis ? Y(0) : (hasXaxis ? Y(0) : Y(st.R.ymin)),
        { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-dashoffset': 0, 'stroke-opacity': 0.95, 'class': 'helper-line' }
      );
      // horizontal : (x,y) ‚Üí (0,y) si axe y visible, sinon gauche
      addLine(plot,
        hasYaxis ? X(0) : (hasYaxis ? X(0) : X(st.R.xmin)), Y(y),
        X(x), Y(y),
        { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-dashoffset': 0, 'stroke-opacity': 0.95, 'class': 'helper-line' }
      );
    });
  });

  const steps=[`Ensemble de d√©finition : [${fmtFR(st.R.xmin)} ; ${fmtFR(st.R.xmax)}]`];
  st.Ximg.forEach(x=>steps.push(`f(${fmtFR(x)}) = ${fmtFR(interpAtGrid(st.grid,x))}`));
  st.Yask.forEach(y=>{
    const A=antecedentsOfGrid(st.grid,y)
      .filter(v=>Math.abs(v-Math.round(v))<1e-9)
      .map(v=>fmtFR(Math.round(v)));
    steps.push(`Ant√©c√©dent(s) de ${fmtFR(y)} : ${A.length?A.join(' ; '):'aucun'}`);
  });
  showSteps(host,steps);
  document.body.classList.add('solution-active');
},
  correct(host,st){
    clearMarks(host);
    let okAll=true;

    const v=$('#aD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
    const okDom=(v.length===2 && v[0]!=='' && v[1]!=='' ? (+v[0]===st.R.xmin && +v[1]===st.R.xmax) : true);
    $('#aDm',host).textContent = okDom?'‚úî':'‚úò'; $('#aDm',host).style.color=okDom?'#14532d':'#991b1b'; okAll&=okDom;

    st.Ximg.forEach((x,i)=>{
      const want=interpAtGrid(st.grid,x), got=parseInt($('#aI'+i,host).value.replace(/\u2212/g,'-').replace(',','.'),10);
      const ok=(String($('#aI'+i,host).value).trim()==='' ? true : (Number.isInteger(got)&&got===want));
      const m=$('#aI'+i+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });
    st.Yask.forEach((y,j)=>{
      const t=$('#aA'+j,host).value.trim().toLowerCase();
      const A=antecedentsOfGrid(st.grid,y).filter(v=>Math.abs(v-Math.round(v))<1e-9).map(v=>Math.round(v));
      let ok=false;
      if(!t || t==='aucun'){ ok=(A.length===0); }
      else{
        const L=uniq(parseListFR(t)).map(v=>Math.round(v));
        ok=(L.length===A.length) && L.every(v=>A.includes(v));
      }
      const m=$('#aA'+j+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });
    (function(){
      const anyEmpty = Array.from(host.querySelectorAll('input[type="text"]')).some(i=>i.value.trim()==='');
      const okFlag = true; /* placeholder; will be set below by previous code */
    })();
    return {ok:okAll,total:1};
  },
  reset(host){ host.querySelectorAll('input').forEach(i=>i.value=''); clearMarks(host); document.body.classList.remove('solution-active'); },
  pdfStatement(s){ return buildPDFStatementFromRender(ex1, s); }
};

/* ========================== EXERCICE 2 (x entiers/0,5) ========================== */
const ex2={
  id:'rg2',
  title:`Lecture graphique (x √† 0,5 pr√®s)`,
  gen(){
    const R={...AMP};
    const qImg = clamp(parseInt($('#cfg-img')?.value||2,10),1,10);
    const qAnt = 3;

    // Candidate abscissas for images: int or half
    let okImg=false, Ximg=null, Yimg=null, grid=null;
    for(let attempt=0; attempt<200; attempt++){
      grid = genCurveIntegerGrid(R, true);
      for(let t=0; t<200; t++){
        const xs = pickXsIntOrHalf(R, qImg).sort((a,b)=>a-b);
        const ys = xs.map(x=>interpAtGrid(grid,x));
        // results should be integer or .5
        const okVals = ys.every(v=>Math.abs(v - Math.round(v))<1e-9 || Math.abs(v*2 - Math.round(v*2))<1e-9);
        if(okVals){
          // Ensure distinct images
          const uniqY = uniq(ys,(a,b)=>Math.abs(a-b)<1e-9);
          if(uniqY.length===ys.length){ Ximg=xs; Yimg=ys; okImg=true; break; }
        }
      }
      if(okImg) break;
    }

    // Antecedents: choose (qAnt-1) y (int or half) with 1..3 integer solutions; + one y inexistant
const wantPerY = 3;
let okAnt=false, gForced=null, ysChosen=[];

// Larger candidate pool + more attempts for robustness at qAnt=5
const Ycand = pickYsIntOrHalf(R, Math.max(5*qAnt, 20));
for(let t=0; t<1200; t++){
  const trial = uniq(shuffle(Ycand)).slice(0, Math.max(0,qAnt-1));
  gForced = buildGridWithConstraints(R, wantPerY, trial);
  const good = trial.every(y=>{
    const A = antecedentsOfGrid(gForced, y);
    const Ai = A.filter(x=>Math.abs(x - Math.round(x))<1e-9);
    const An = A.filter(x=>Math.abs(x - Math.round(x))>=1e-9);
    return Ai.length>=1 && Ai.length<=3 && An.length===0;
  });
  if(good){ ysChosen=trial; okAnt=true; break; }
}

// Fallback: scan more candidates on a fresh grid until enough Ys found
if(!okAnt){
  gForced = genCurveIntegerGrid(R, true);
  const allCand = pickYsIntOrHalf(R, Math.max(8*qAnt, 32));
  const goodYs = allCand.filter(y=>{
    const A = antecedentsOfGrid(gForced, y);
    const Ai = A.filter(x=>Math.abs(x - Math.round(x))<1e-9);
    const An = A.filter(x=>Math.abs(x - Math.round(x))>=1e-9);
    return Ai.length>=1 && Ai.length<=3 && An.length===0;
  });
  ysChosen = uniq(goodYs).slice(0, Math.max(0,qAnt-1));
  okAnt = ysChosen.length >= Math.max(0,qAnt-1);
}

let yNone=null;
if(okAnt){
  // choose an inexistant y inside amplitude if possible (no solution)
  const candidates=[];
  for(let y=R.ymin+1; y<=R.ymax-1; y+=0.5){
    const A=antecedentsOfGrid(gForced,y);
    if(A.length===0) candidates.push(y);
  }
  const zeroInside = uniq(candidates,(a,b)=>Math.abs(a-b)<1e-9);
  yNone = zeroInside.length ? zeroInside[0] : (Math.random()<0.5 ? (R.ymax+1) : (R.ymin-1));
  grid = gForced;
}

const Yask = okAnt ? [...ysChosen, yNone] : [];
return { R, grid, Ximg, Yask };
    
      },
  render(host,st){
    const ui=mkRow(host,'Lecture graphique.');
    const rep=buildRepereSVG({xmin:st.R.xmin,xmax:st.R.xmax,ymin:st.R.ymin,ymax:st.R.ymax,grid:true,arrows:true});
    addPath(rep.plot, pathFromGridSmooth(rep, st.grid), {stroke:'#c00','stroke-width':3.2});
    ui.st.appendChild(rep.svg);

    let html = `<div class="qa"><div class="q">1.</div><div class="a">Ensemble de d√©finition&nbsp;:&nbsp;<input id="bD" type="text"><span id="bDm" class="qmark"></span></div></div>`;
    st.Ximg.forEach((x,i)=>{
      html+=`<div class="qa"><div class="q">${i+2}.</div><div class="a">Image de ${fmtNum(x)}:&nbsp;<input id="bI${i}" type="text"><span id="bI${i}m" class="qmark"></span></div></div>`;
    });
    st.Yask.forEach((y,j)=>{
      const k=2+st.Ximg.length+j;
      html+=`<div class="qa"><div class="q">${k}.</div><div class="a">Ant√©c√©dent(s) de ${fmtNum(y)}:&nbsp;<input id="bA${j}" type="text"><span id="bA${j}m" class="qmark"></span></div></div>`;
    });
    ui.form.innerHTML=html;
    host.dataset.state=JSON.stringify(st); host.dataset.active='rg2';
  
    // INLINE_COLORIZED: appliquer couleurs directement dans l‚Äô√©nonc√©
    try {
      const paletteI = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e'];
      const paletteA = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f'];
      if (Array.isArray(st.Ximg)) st.Ximg.forEach((x,i)=>{
        const input = host.querySelector('#bI'+i);
        if(input && input.parentElement) {
          const a = input.parentElement;
          const needle = 'Image de ' + fmtNum(x) + ':';
          const repl = 'Image de <span style="color:'+paletteI[i%5]+';font-weight:700">'+fmtNum(x)+'</span> :';
          a.innerHTML = a.innerHTML.replace(needle, repl);
        }
      });
      if (Array.isArray(st.Yask)) st.Yask.forEach((y,j)=>{
        const input = host.querySelector('#bA'+j);
        if(input && input.parentElement) {
          const a = input.parentElement;
          const needle = 'Ant√©c√©dent(s) de ' + fmtNum(y) + ':';
          const repl = 'Ant√©c√©dent(s) de <span style="color:'+paletteA[j%5]+';font-weight:700">'+fmtNum(y)+'</span> :';
          a.innerHTML = a.innerHTML.replace(needle, repl);
        }
      });
    } catch(e){}
    },
  
  solution(host,st){
    const rep = host.querySelector('svg.repere');
    const plot = rep ? rep.querySelector('.plot') : null;
    const frame = rep ? (rep.querySelector('rect.frame') || rep.querySelector('rect')) : null;
    let X,Y,hasXaxis=false,hasYaxis=false;
    if(frame){
      const mLeft = +frame.getAttribute('x'), mTop = +frame.getAttribute('y');
      const W0 = +frame.getAttribute('width'), H0 = +frame.getAttribute('height');
      X = x => mLeft + (x - st.R.xmin) * W0 / (st.R.xmax - st.R.xmin);
      Y = y => mTop + H0 - (y - st.R.ymin) * H0 / (st.R.ymax - st.R.ymin);
      hasXaxis = (st.R.ymin <= 0 && 0 <= st.R.ymax);
      hasYaxis = (st.R.xmin <= 0 && 0 <= st.R.xmax);
    }

    // Color palettes (enough colors even si compteur augmente)
    const paletteI = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e','#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f'];
    const paletteA = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f','#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e'];

    // Helper to add a line into plot
    function addLine(g,x1,y1,x2,y2,st={}){
      if(!g) return;
      const l=document.createElementNS(g.namespaceURI,'line');
      l.setAttribute('x1',x1); l.setAttribute('y1',y1);
      l.setAttribute('x2',x2); l.setAttribute('y2',y2);
      for(const k in st){ if(Object.prototype.hasOwnProperty.call(st,k)) l.setAttribute(k, st[k]); }
      g.appendChild(l);
    }

    // Draw helper lines for images
    if(rep && plot){
      (st.Ximg||[]).forEach((x,i)=>{
        const y = interpAtGrid(st.grid, x);
        const col = paletteI[i % paletteI.length];
        addLine(plot, X(x), Y(y), X(x), hasXaxis? Y(0) : Y(st.R.ymin),
          { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray':'6 5', 'stroke-opacity':0.95, 'class':'helper-line' });
        addLine(plot, hasYaxis? X(0) : X(st.R.xmin), Y(y), X(x), Y(y),
          { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray':'6 5', 'stroke-opacity':0.95, 'class':'helper-line' });
      });
      // Draw helper lines for antecedents (only those inside amplitude)
      (st.Yask||[]).forEach((y,j)=>{
        if(y < st.R.ymin || y > st.R.ymax) return;
        const col = paletteA[j % paletteA.length];
        antecedentsOfGrid(st.grid, y).forEach(x=>{
          addLine(plot, X(x), Y(y), X(x), hasXaxis? Y(0) : Y(st.R.ymin),
            { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray':'6 5', 'stroke-opacity':0.95, 'class':'helper-line' });
          addLine(plot, hasYaxis? X(0) : X(st.R.xmin), Y(y), X(x), Y(y),
            { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray':'6 5', 'stroke-opacity':0.95, 'class':'helper-line' });
        });
      });
    }

    const fAt=x=>interpAtGrid(st.grid,x);
    // Build answers (case grise)
    const imgRows = st.Ximg.map((x,i)=>{
      return `<div class="qa"><div class="q">${i+1}.</div><div class="a">Image de ${fmtNum(x)} : <b>${fmtNum(fAt(x))}</b></div></div>`;
    }).join('');
    const antRows = (st.Yask||[]).map((y,j)=>{
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      const txt = A.length ? A.map(fmtNum).join(' ; ') : 'aucun';
      return `<div class="qa"><div class="q">${j+1+st.Ximg.length}.</div><div class="a">Ant√©c√©dent(s) de ${fmtNum(y)} : <b>${txt}</b></div></div>`;
    }).join('');
    showSteps(host, ['R√©ponses attendues :<br>'+imgRows+antRows]);
  },

  correct(host,st){
    clearMarks(host);
    let okAll=true;

    const v=$('#bD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
    const okDom=(v.length===2 && v[0]!=='' && v[1]!=='' ? (+v[0]===st.R.xmin && +v[1]===st.R.xmax) : true);
    $('#bDm',host).textContent = okDom?'‚úî':'‚úò'; $('#bDm',host).style.color=okDom?'#14532d':'#991b1b'; okAll&=okDom;

    st.Ximg.forEach((x,i)=>{
      const want=Math.round(interpAtGrid(st.grid,x)*2)/2;
      const got=parseNumFR($('#bI'+i,host).value);
      const ok=(Number.isFinite(got) && Math.abs(got-want)<=0.25);
      const m=$('#bI'+i+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });
    st.Yask.forEach((y,j)=>{
      const t=$('#bA'+j,host).value.trim().toLowerCase();
      const A=antecedentsOfGrid(st.grid,y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(!t || t==='aucun'){ ok=(A.length===0); }
      else{
        const L=uniq(parseListFR(t)).map(v=>Math.round(v*10)/10);
        ok=(L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      const m=$('#bA'+j+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });
    (function(){
      const anyEmpty = Array.from(host.querySelectorAll('input[type="text"]')).some(i=>i.value.trim()==='');
      const okFlag = true; /* placeholder; will be set below by previous code */
    })();
    return {ok:okAll,total:1};
  },
  reset(host){ host.querySelectorAll('input').forEach(i=>i.value=''); clearMarks(host); document.body.classList.remove('solution-active'); },
  pdfStatement(s){ return buildPDFStatementFromRender(ex2, s); }
};

/* ========================== EXERCICE 3 ‚Äî images/ant√©c√©dents ENTIERs ========================== */
/* Helpers de formatage (fallback) */
if (typeof window.fmtFR!=='function') window.fmtFR = n => String(Number(n)).replace('.',',');
if (typeof window.fmtNum!=='function') window.fmtNum = n => String(Math.round(Number(n)));
if (typeof window.fmtUnit!=='function') window.fmtUnit = (n,u) => fmtFR(n)+'\u00A0'+u;

/* Maths utils */
function lerp(a,b,t){ return a+(b-a)*t; }
function clampv(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rand(a,b){ return a + Math.random()*(b-a); }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

/* Courbes synth√©tiques */
function makeShape(kind, th){
  const [xmin,xmax]=th.x,[ymin,ymax]=th.y; const H=ymax-ymin, W=xmax-xmin;
  switch(kind){
    case 'exp_decay':{const A=Math.max(0.4*H,rand(0.55,0.85)*H),k=rand(0.25,0.6),base=Math.max(0,ymin+0.01*H); return x=>Math.max(0, base+A*Math.exp(-k*(x-xmin))); }
    case 'damped_sine':{const A=rand(0.25,0.45)*H,k=rand(0.12,0.3),w=rand(1.6,2.6),phi=rand(-Math.PI,Math.PI),base=ymin+0.02*H; return x=>base+A*Math.exp(-k*(x-xmin))*Math.abs(Math.sin(w*(x-xmin)+phi));}
    case 'sine_mix':{const A=rand(0.25,0.4)*H,base=ymin+0.06*H,w1=rand(0.4,0.7),w2=rand(0.9,1.3),p1=rand(-Math.PI,Math.PI),p2=rand(-Math.PI,Math.PI); return x=>clampv(base+A*(0.6*Math.sin(w1*x+p1)+0.4*Math.sin(w2*x+p2)+1.2),Math.max(0,ymin+0.01*H),ymax-0.01*H); }
    case 'piecewise_linear':{const K=6,xs=Array.from({length:K},(_,i)=>xmin+i*(W/(K-1))),ys=xs.map(()=>ymin+0.1*H+rand(0.1,0.85)*H); return x=>{let j=0; while(j<xs.length-1&&x>xs[j+1]) j++; if(j>=xs.length-1) return ys[ys.length-1]; const t=(x-xs[j])/(xs[j+1]-xs[j]); return lerp(ys[j],ys[j+1],t);} }
    case 'piecewise_linear_up':{const baseUp=rand(0.35,0.6)*H; return x=>ymin+0.02*H+(baseUp*(x-xmin)/W)+0.08*H*Math.sin(1.1*x+0.7*Math.sin(2.2*x));}
    case 'monotone_up':{const A=rand(0.45,0.75)*H,k=rand(0.4,0.8); return x=>clampv(ymin+A*(1-Math.exp(-k*(x-xmin)/W)),Math.max(0,ymin+0.01*H),ymax-0.01*H);}
    case 'logistic':{const L=rand(0.45,0.8)*H,k=rand(4,8)/W,x0=xmin+rand(0.35,0.65)*W,base=ymin+0.05*H; return x=>clampv(base+L/(1+Math.exp(-k*(x-x0))),Math.max(0,ymin+0.01*H),ymax-0.01*H);}
    case 'bell':{const A=rand(0.45,0.8)*H,sigma=rand(0.18,0.28)*W,x0=xmin+rand(0.35,0.65)*W,base=ymin+0.02*H; return x=>base+A*Math.exp(-((x-x0)*(x-x0))/(2*sigma*sigma));}
    case 'seasonal':{const A=rand(0.35,0.5)*H,base=ymin+0.06*H; return x=>clampv(base+A*(1.05*Math.sin((x-3)*2*Math.PI/12)+0.15*Math.sin((x-3)*4*Math.PI/12)),Math.max(0,ymin+0.01*H),ymax-0.01*H);}
    case 'seasonal_soft':{const A=rand(0.25,0.35)*H,base=ymin+0.5*H; return x=>base+A*Math.sin((x-3)*2*Math.PI/12);}
    case 'pure_sine':{const A5=rand(0.35,0.45)*H,base6=ymin+0.5*H,w=2*Math.PI/W,phi2=rand(-Math.PI,Math.PI); return x=>base6+A5*Math.sin(w*(x-xmin)+phi2);}
    default: return x=>ymin+0.5*H;
  }
}
function makeCurveForTheme(th){
  const [xmin,xmax]=th.x,[ymin,ymax]=th.y;
  const f=makeShape(pick(th.shapes), th), n=Math.max(60,(xmax-xmin)*12);
  const xs=Array.from({length:n+1},(_,k)=>xmin+k*(xmax-xmin)/n);
  let ys=xs.map(x=>f(x));
  if(th.y[0]===0){ const eps=0.01*(th.y[1]-th.y[0]); ys=ys.map(y=>Math.max(eps,y)); }
  return {xs,ys};
}

/* Th√®mes + √©nonc√©s Q2/Q3 adapt√©s (‚Äúr√©pondre par un entier‚Äù) */
const THEMES = [
  {
    id: 'tension',
    title: `Tension d‚Äôune lampe`,
    x: [0, 10, 1],
    y: [0, 300, 50],
    shapes: ['exp_decay', 'damped_sine'],
    xUnit: `ms`,
    yUnit: `V`,
    context: `On allume une lampe et l‚Äôon suit au laboratoire l‚Äô√©volution de la tension √† ses bornes pendant les 10 premi√®res millisecondes. Les mesures, arrondies pour faciliter la lecture, sont report√©es sur le graphique ci‚Äëdessous (temps en ms, tension en V).`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Tension d‚Äôune lampe ¬ª, donner la tension (en V) √† ${fmtUnit(r1,'ms')} et √† ${fmtUnit(r2,'ms')} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Tension d‚Äôune lampe ¬ª, pour quels instants la tension vaut ${fmtUnit(y,'V')} ? (donner des ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'petrole',
    title: `Prix du p√©trole`,
    x: [2000, 2010, 1],
    y: [0, 150, 20],
    shapes: ['sine_mix', 'piecewise_linear'],
    yUnit: `USD`,
    context: `Le graphique pr√©sente une mod√©lisation (donn√©es simplifi√©es) du prix moyen annuel du baril de p√©trole, exprim√© en dollars USD, entre 2000 et 2010. On suppose l‚Äô√©volution continue d‚Äôune ann√©e √† l‚Äôautre, les valeurs rep√©r√©es sur les graduations √©tant lisibles.`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Prix du p√©trole ¬ª, donner le prix (en USD) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Prix du p√©trole ¬ª, pour quelle(s) ann√©e(s) le prix vaut ${fmtNum(y)} USD ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'naiss',
    title: `Naissances`,
    x: [2005, 2017, 1],
    y: [0, 900, 100],
    shapes: ['piecewise_linear', 'sine_mix'],
    yUnit: `milliers`,
    context: `On √©tudie, pour un pays, le nombre de naissances par ann√©e (en milliers) entre 2005 et 2017. Le trac√© ci‚Äëdessous synth√©tise des donn√©es arrondies ; il permet de lire des valeurs enti√®res aux ann√©es indiqu√©es.`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Naissances ¬ª, donner le nombre (en milliers) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Naissances ¬ª, pour quelle(s) ann√©e(s) le nombre vaut ${fmtNum(y)} milliers ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'co2',
    title: `√âmissions de CO‚ÇÇ`,
    x: [1995, 2007, 1],
    y: [0, 900, 100],
    shapes: ['piecewise_linear', 'sine_mix'],
    yUnit: `Mt`,
    context: `Dans un pays, on suit les √©missions annuelles de dioxyde de carbone (CO‚ÇÇ) entre 1995 et 2007. Le graphique (en millions de tonnes, Mt) est une approximation lisible destin√©e √† des lectures enti√®res.`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ √âmissions de CO‚ÇÇ ¬ª, donner les √©missions (en Mt) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ √âmissions de CO‚ÇÇ ¬ª, pour quelle(s) ann√©e(s) les √©missions valent ${fmtNum(y)} Mt ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'temperature',
    title: `Temp√©rature d‚Äôune journ√©e`,
    x: [0, 24, 2],
    y: [-10, 40, 5],
    shapes: ['seasonal', 'seasonal_soft'],
    xUnit: `h`,
    yUnit: `¬∞C`,
    context: `Dans une ville, la temp√©rature ext√©rieure (en ¬∞C) est relev√©e toutes les deux heures pendant une journ√©e compl√®te. Le graphique fournit une mod√©lisation r√©guli√®re permettant des lectures enti√®res aux heures impaires/paires indiqu√©es.`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Temp√©rature d‚Äôune journ√©e ¬ª, donner la temp√©rature (en ¬∞C) √† ${fmtUnit(r1,'h')} et √† ${fmtUnit(r2,'h')} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Temp√©rature d‚Äôune journ√©e ¬ª, √† quelle(s) heure(s) la temp√©rature vaut ${fmtUnit(y,'¬∞C')} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'achat',
    xLabel: `ann√©e`,
    yLabel: `indice du pouvoir d‚Äôachat`,
    yName: `le pouvoir d‚Äôachat`,
    context: `On consid√®re l‚Äôindice (sans unit√©) du pouvoir d‚Äôachat d‚Äôun pays entre 2010 et 2020. Le graphique, construit pour des lectures enti√®res, traduit une tendance globale tout en autorisant de l√©g√®res variations annuelles.`,
    title: `Pouvoir d‚Äôachat`,
    x: [2010, 2020, 1],
    y: [0, 140, 10],
    shapes: ['monotone_up', 'piecewise_linear_up'],
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Pouvoir d‚Äôachat ¬ª, donner l‚Äôindice en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Pouvoir d‚Äôachat ¬ª, pour quelle(s) ann√©e(s) l‚Äôindice vaut ${fmtNum(y)} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'incendies',
    xLabel: `ann√©e`,
    yLabel: `nombre d‚Äôincendies`,
    yName: `le nombre d‚Äôincendies`,
    context: `Le nombre d‚Äôincendies de for√™t recens√©s chaque ann√©e dans une r√©gion est suivi de 2010 √† 2022. Le trac√© ci‚Äëdessous est une synth√®se simplifi√©e destin√©e √† des lectures enti√®res (unit√©s : ¬´ nombre d‚Äôincendies ¬ª).`,
    title: `Incendies de for√™t`,
    x: [2010, 2022, 1],
    y: [0, 1200, 100],
    shapes: ['sine_mix', 'piecewise_linear'],
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Incendies de for√™t ¬ª, donner le nombre d‚Äôincendies en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Incendies de for√™t ¬ª, pour quelle(s) ann√©e(s) le nombre d‚Äôincendies vaut ${fmtNum(y)} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'population',
    xLabel: `ann√©e`,
    yLabel: `population (en millions)`,
    yName: `la population`,
    context: `La population (en millions d‚Äôhabitants) d‚Äôune grande ville est √©tudi√©e de 2000 √† 2015. Les valeurs sont arrondies pour permettre une lecture directe sur les graduations en millions.`,
    title: `Population (ville)`,
    x: [2000, 2015, 1],
    y: [5, 20, 1],
    shapes: ['logistic', 'monotone_up'],
    yUnit: `millions`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Population (ville) ¬ª, donner la population (en millions) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Population (ville) ¬ª, pour quelle(s) ann√©e(s) la population vaut ${fmtNum(y)} millions ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'vitesse',
    xLabel: `temps (en s)`,
    yLabel: `vitesse (en m/s)`,
    yName: `la vitesse du mobile`,
    context: `Un mobile se d√©place en ligne droite ; sa vitesse instantan√©e (en m/s) est relev√©e chaque seconde pendant 10 s. La courbe fournie est une mod√©lisation liss√©e permettant des lectures enti√®res.`,
    title: `Vitesse d‚Äôun mobile`,
    x: [0, 10, 1],
    y: [0, 50, 5],
    shapes: ['bell', 'piecewise_linear'],
    xUnit: `s`,
    yUnit: `m/s`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Vitesse d‚Äôun mobile ¬ª, donner la vitesse (en m/s) √† ${fmtUnit(r1,'s')} et √† ${fmtUnit(r2,'s')} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Vitesse d‚Äôun mobile ¬ª, au bout de combien de secondes la vitesse vaut ${fmtUnit(y,'m/s')} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'luminosite',
    xLabel: `temps`,
    yLabel: `luminosit√©`,
    yName: `la luminosit√© de l‚Äô√©toile`,
    context: `Des astronomes observent une √©toile variable sur 12 jours. La luminosit√© relative (sans unit√©) est not√©e quotidiennement. La courbe ci‚Äëdessous propose une √©volution simplifi√©e, lisible √† chaque jour entier.`,
    title: `Luminosit√© d‚Äôune √©toile`,
    x: [0, 12, 1],
    y: [0, 10, 1],
    shapes: ['pure_sine', 'seasonal_soft'],
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Luminosit√© d‚Äôune √©toile ¬ª, donner la luminosit√© (valeur relative) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Luminosit√© d‚Äôune √©toile ¬ª, pour quel(s) jour(s) la luminosit√© vaut ${fmtNum(y)} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'seismes',
    xLabel: `mois`,
    yLabel: `nombre d‚Äô√©v√©nements`,
    yName: `le nombre d‚Äô√©v√©nements sismiques`,
    context: `Dans une r√©gion, on recense le nombre d‚Äô√©v√©nements sismiques chaque mois sur une ann√©e. Le graphique fournit une lecture directe mois par mois, en nombres entiers.`,
    title: `Activit√© sismique`,
    x: [1, 12, 1],
    y: [0, 60, 5],
    shapes: ['sine_mix', 'piecewise_linear'],
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Activit√© sismique ¬ª, donner le nombre d‚Äô√©v√©nements en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Activit√© sismique ¬ª, pour quel(s) mois le nombre d‚Äô√©v√©nements vaut ${fmtNum(y)} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'reaction',
    xLabel: `temps (en s)`,
    yLabel: `concentration (en mol¬∑L‚Åª¬π)`,
    yName: `la concentration du r√©actif`,
    context: `Lors d‚Äôune exp√©rience de chimie, on suit la concentration d‚Äôun r√©actif (en mol¬∑L‚Åª¬π) pendant 10 s. Le mod√®le retenu d√©cro√Æt de mani√®re r√©guli√®re ; les lectures demand√©es se font sur des secondes enti√®res.`,
    title: `Concentration d‚Äôun r√©actif`,
    x: [0, 10, 1],
    y: [0, 3, 0.5],
    shapes: ['exp_decay'],
    xUnit: `s`,
    yUnit: `mol¬∑L‚Åª¬π`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Concentration d‚Äôun r√©actif ¬ª, donner la concentration (en mol¬∑L‚Åª¬π) √† ${fmtUnit(r1,'s')} et √† ${fmtUnit(r2,'s')} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Concentration d‚Äôun r√©actif ¬ª, au bout de combien de secondes la concentration vaut ${fmtUnit(y,'mol¬∑L‚Åª¬π')} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'debit',
    xLabel: `mois`,
    yLabel: `d√©bit (en m¬≥/s)`,
    yName: `le d√©bit du fleuve`,
    context: `Le d√©bit moyen d‚Äôun fleuve (en m¬≥/s) est mesur√© pour chacun des 12 mois d‚Äôune m√™me ann√©e. Le trac√© propos√© est une √©volution saisonni√®re simplifi√©e con√ßue pour des lectures enti√®res.`,
    title: `D√©bit d‚Äôun fleuve`,
    x: [1, 12, 1],
    y: [0, 2000, 200],
    shapes: ['seasonal'],
    yUnit: `m¬≥/s`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ D√©bit d‚Äôun fleuve ¬ª, donner le d√©bit (en m¬≥/s) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ D√©bit d‚Äôun fleuve ¬ª, pour quel(s) mois le d√©bit vaut ${fmtUnit(y,'m¬≥/s')} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'niveau',
    title: `Niveau d‚Äôun lac`,
    x: [1, 12, 1],
    y: [10, 30, 2],
    shapes: ['seasonal_soft'],
    yUnit: `m`,
    context: `On suit le niveau d‚Äôun lac (en m√®tres au‚Äëdessus d‚Äôune cote de r√©f√©rence) chaque mois pendant un an. Les donn√©es, liss√©es pour la lisibilit√©, se lisent aux mois entiers.`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Niveau d‚Äôun lac ¬ª, donner le niveau (en m) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Niveau d‚Äôun lac ¬ª, pour quel(s) mois le niveau vaut ${fmtUnit(y,'m')} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  },

  {
    id: 'panier',
    title: `Prix d‚Äôun panier`,
    x: [1, 12, 1],
    y: [0, 200, 20],
    shapes: ['monotone_up', 'piecewise_linear_up'],
    yUnit: `‚Ç¨`,
    context: `Un m√©nage suit, mois par mois, le prix d‚Äôun m√™me panier de produits de consommation courante sur une ann√©e. Le graphique ci‚Äëdessous donne une √©volution simplifi√©e (valeurs arrondies) permettant des lectures enti√®res.`,
    q2: (r1, r2) => `D‚Äôapr√®s la courbe ¬´ Prix d‚Äôun panier ¬ª, donner le prix (en ‚Ç¨) en ${fmtNum(r1)} et en ${fmtNum(r2)} (r√©pondre par un entier). <input id="c2a" type="text"> / <input id="c2b" type="text">`,
    q3: y => `D‚Äôapr√®s la courbe ¬´ Prix d‚Äôun panier ¬ª, pour quel(s) mois le prix vaut ${fmtUnit(y,'‚Ç¨')} ? (ant√©c√©dents entiers) <input id="c3a" type="text">`
  }
];


/* G√©n√©ration d‚Äôun √©tat garantissant les contraintes ENTIERES pour Q2/Q3 */
function makeCurveState(th){
  const [xmin,xmax,stepX]=th.x, [ymin,ymax,stepY]=th.y;
  const gx=[]; for(let v=xmin; v<=xmax+1e-9; v+=stepX) gx.push(v);
  const gy=[]; for(let v=ymin; v<=ymax+1e-9; v+=stepY) gy.push(v);

  // 1) courbe continue
  const base = makeCurveForTheme(th);
  const xsC = base.xs, ysC = base.ys;

  // 2) projection sur la grille : X = abscisses de la grille, Y = multiples de stepY
  const X = []; for (let v = xmin; v <= xmax + 1e-9; v += stepX) X.push(v);

  function interp(x){
    let i = 0;
    while (i < xsC.length - 1 && xsC[i+1] < x) i++;
    const x1 = xsC[i],   x2 = xsC[i+1];
    const y1 = ysC[i],   y2 = ysC[i+1];
    const t  = (x - x1) / (x2 - x1);
    return y1 + (y2 - y1) * t;
  }
  const Y = X.map(x => {
    const y  = interp(x);
    const k  = Math.round((y - ymin) / stepY);       // entier
    const yq = ymin + k * stepY;                      // multiple exact du pas
    return Math.min(ymax, Math.max(ymin, yq));        // clamp
  });

  // 3) choisir les points Q2/Q3 **uniquement** sur la grille projet√©e
  const idx1 = (Math.random() * X.length) | 0;
  let   idx2 = (Math.random() * X.length) | 0; if (idx2 === idx1) idx2 = (idx1 + 1) % X.length;

  const read1  = X[idx1], read2  = X[idx2];   // abscisses enti√®res/grille
  const y1Int  = Y[idx1], y2Int  = Y[idx2];   // images EXACTES (multiples du pas)
  const yTarget = Y[(Math.random() * Y.length) | 0];
  const rootsInt = X.filter((x, i) => Y[i] === yTarget);  // ant√©c√©dents EXACTS sur la grille

  // 4) on remplace la courbe par la version **projet√©e**
  const xs = X, ys = Y;

  return {
    th, xmin, xmax, stepX, ymin, ymax, stepY,
    xs, ys, gx: X, gy: gy,
    read1, read2, y1Int, y2Int, yTarget, rootsInt
  };
}

/* Q1 : tol√©rance + libell√©s pour contextualiser */
function _norm(s){ return String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/\s+/g,' ').trim(); }
function _stripArt(s){ return s.replace(/^l['‚Äô]?\s*|^les?\s+/,'').trim(); }
function _withPlurals(list){ const out=new Set(); list.forEach(w=>{ const n=_norm(w); out.add(n); if(/^[a-z]+$/.test(n)){ out.add(n+'s'); out.add(n.replace(/al$/,'aux')); } }); return Array.from(out); }

const EX3_Q1_SPEC = {
  tension:   { q1Line:"1) En abscisse : temps ; en ordonn√©e : tension", xAccept:_withPlurals(["temps"]), yAccept:_withPlurals(["tension"]), xNoun:"temps", yNoun:"la tension" },
  petrole:   { q1Line:"1) En abscisse : ann√©es ; en ordonn√©e : Prix du p√©trole (prix accept√©)", xAccept:_withPlurals(["annee","annees","ans"]), yAccept:_withPlurals(["prix du petrole","prix"]), xNoun:"ann√©es", yNoun:"le prix du p√©trole" },
  naiss:     { q1Line:"1) En abscisse : ann√©es; en ordonn√©e : le nombre de naissances (naissances accept√©)", xAccept:_withPlurals(["annee","annees","ans"]), yAccept:_withPlurals(["nombre de naissances","naissances"]), xNoun:"ann√©es", yNoun:"le nombre de naissances" },
  co2:       { q1Line:"1) En abscisse : ann√©es; en ordonn√©e : √âmissions de CO‚ÇÇ (√©missions accept√©)", xAccept:_withPlurals(["annee","annees","ans"]), yAccept:_withPlurals(["emissions de co2","emissions","co2"]), xNoun:"ann√©es", yNoun:"les √©missions de CO‚ÇÇ" },
  temperature:{q1Line:"1) En abscisse : heures; en ordonn√©e : Temp√©rature d‚Äôune journ√©e (Temp√©rature accept√©)", xAccept:_withPlurals(["heure","heures"]), yAccept:_withPlurals(["temperature d une journee","temperature"]), xNoun:"heures", yNoun:"la temp√©rature" },
  achat:     { q1Line:"1) En abscisse : ann√©es; en ordonn√©e : Pouvoir d‚Äôachat (achat accept√©)", xAccept:_withPlurals(["annee","annees","ans"]), yAccept:_withPlurals(["pouvoir d achat","achat"]), xNoun:"ann√©es", yNoun:"le pouvoir d‚Äôachat" },
  incendies: { q1Line:"1) En abscisse : ann√©es; en ordonn√©e : Incendies de for√™t (Incendies accept√©)", xAccept:_withPlurals(["annee","annees","ans"]), yAccept:_withPlurals(["incendies de foret","incendies","foret"]), xNoun:"ann√©es", yNoun:"les incendies de for√™t" },
  population:{ q1Line:"1) En abscisse : ann√©es; en ordonn√©e : Population", xAccept:_withPlurals(["annee","annees","ans"]), yAccept:_withPlurals(["population","habitants"]), xNoun:"ann√©es", yNoun:"la population" },
  vitesse:   { q1Line:"1) En abscisse : temps; en ordonn√©e : Vitesse d‚Äôun mobile (Vitesse accept√©)", xAccept:_withPlurals(["temps"]), yAccept:_withPlurals(["vitesse d un mobile","vitesse"]), xNoun:"temps", yNoun:"la vitesse du mobile" },

  // ‚¨áÔ∏è ADAPTATION ICI : temps ‚Üí jours
  luminosite:{ q1Line:"1) En abscisse : jours; en ordonn√©e : Luminosit√© d‚Äôune √©toile (Luminosit√© ou √©toile accept√©)", xAccept:_withPlurals(["jour"]), yAccept:_withPlurals(["luminosite d une etoile","luminosite","etoile"]), xNoun:"jours", yNoun:"la luminosit√© de l‚Äô√©toile" },

  seismes:   { q1Line:"1) En abscisse : mois; en ordonn√©e : le nombre d‚Äô√©v√©nements (√©v√©nements accept√©)", xAccept:_withPlurals(["mois"]), yAccept:_withPlurals(["nombre d evenements","evenements"]), xNoun:"mois", yNoun:"le nombre d‚Äô√©v√©nements sismiques" },
  reaction:  { q1Line:"1) En abscisse : temps; en ordonn√©e : Concentration d‚Äôun r√©actif (Concentration ou r√©actif accept√©)", xAccept:_withPlurals(["temps"]), yAccept:_withPlurals(["concentration d un reactif","concentration","reactif"]), xNoun:"temps", yNoun:"la concentration du r√©actif" },
  debit:     { q1Line:"1) En abscisse : mois; en ordonn√©e : D√©bit d‚Äôun fleuve (D√©bit ou fleuve accept√©)", xAccept:_withPlurals(["mois"]), yAccept:_withPlurals(["debit d un fleuve","debit","fleuve"]), xNoun:"mois", yNoun:"le d√©bit du fleuve" },
  niveau:    { q1Line:"1) En abscisse : mois; en ordonn√©e : Niveau d‚Äôun lac (Niveau ou lac accept√©)", xAccept:_withPlurals(["mois"]), yAccept:_withPlurals(["niveau d un lac","niveau","lac"]), xNoun:"mois", yNoun:"le niveau du lac" },
  panier:    { q1Line:"1) En abscisse : mois; en ordonn√©e : Prix d‚Äôun panier (prix ou panier accept√©)", xAccept:_withPlurals(["mois"]), yAccept:_withPlurals(["prix d un panier","prix","panier"]), xNoun:"mois", yNoun:"le prix du panier" }
};



function ex3_validateQ1(themeId, userX, userY){
  const sp = EX3_Q1_SPEC[themeId];
  if(!sp) return {okX:false, okY:false};

  // normalisation renforc√©e : accents, espaces, articles, ponctuation, chiffres en indice
  const subMap = { '‚ÇÄ':'0','‚ÇÅ':'1','‚ÇÇ':'2','‚ÇÉ':'3','‚ÇÑ':'4','‚ÇÖ':'5','‚ÇÜ':'6','‚Çá':'7','‚Çà':'8','‚Çâ':'9' };
  const deSub = s => s.replace(/[‚ÇÄ-‚Çâ]/g, m=>subMap[m]||m);

  const clean = s => deSub(String(s||'').toLowerCase())
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')     // accents
    .replace(/^l['‚Äô]\s*/,'')                             // l', l‚Äô
    .replace(/^(?:le|la|les)\s+/,'')                     // articles
    .replace(/[^\p{L}\s0-9]/gu,' ')                      // ponctuation ‚Üí espace
    .replace(/\s+/g,' ').trim();                         // espaces

  const singularize = w => w
    .replace(/aux$/,'al')     // aux ‚Üí al (chevaux ‚Üí cheval, etc.)
    .replace(/s$/,'');        // pluriel simple

  const eqWord = (refList, given) => {
    const g = clean(given);
    if(g.length<=1) return false;
    // EXACTEMENT un seul mot/r√©sultat attendu (pas de phrase)
    if(/\s/.test(g)) return false;

    // on accepte : mot tel quel, version singulier, version pluriel simple
    const set = new Set(refList.map(clean));
    const gSing = singularize(g);
    return set.has(g) || set.has(g+'s') || set.has(gSing);
  };

  return {
    okX: eqWord(sp.xAccept, userX),
    okY: eqWord(sp.yAccept, userY)
  };
}


/* Parsing & tol√©rances */
function parseNumberList(s){
  s = String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,' ');
  s = s.replace(/[^0-9,.;:\-+ e]/g,' ');
  s = s.replace(/\b(\d+)\s*(?:eme|√®me|er|e)\b/g,'$1'); // 2√®me -> 2
  return s.split(/[\s,;:]+/).filter(Boolean)
          .map(p=>parseFloat(p.replace(',','.'))).filter(n=>!isNaN(n));
}
function withinTol(a,b,t){ return Math.abs(a-b) <= t; }

/* Fran√ßais humain pour Q3 */
function frOrdinal(n){ n=Math.round(Number(n)); return !isFinite(n)?String(n):(n===1?'1er':(n+'√®me')); }
function joinHuman(arr){ arr=arr.filter(v=>v!=='' && v!=null); if(arr.length<=1) return arr.join(''); if(arr.length===2) return arr[0]+' et '+arr[1]; return arr.slice(0,-1).join(', ')+' et '+arr[arr.length-1]; }
function q3_wherePhrase(sp, xs, th){
  const xN = (sp && sp.xNoun) || 'abscisse';
  const unit = th && th.xUnit ? '\u00A0'+th.xUnit : '';
  if(!xs || xs.length===0){
    if(xN==='ann√©es') return 'pour aucune ann√©e';
    if(xN==='heures') return '√† aucune heure';
    if(xN==='mois')   return 'pour aucun mois';
    if(xN==='jours')  return 'pour aucun jour';
    if(xN==='temps')  return '√† aucun instant';
    return 'pour aucune valeur de '+xN;
  }
  if(xN==='ann√©es'){ return 'en '+ joinHuman(xs.map(fmtNum)); }
  if(xN==='heures'){ return '√† '+ joinHuman(xs.map(x=>fmtUnit(x,'h'))); }
  if(xN==='mois'){ const list = joinHuman(xs.map(x=>frOrdinal(x))); const prep = xs.length>1?'aux ':'au '; return prep+list+' mois'; }
  if(xN==='jours'){ const list = joinHuman(xs.map(x=>frOrdinal(x))); const prep = xs.length>1?'aux ':'au '; return prep+list+' jour(s)'; }
  if(xN==='temps'){ return 'au bout de '+ joinHuman(xs.map(x=>fmtFR(x)+unit)); }
  return 'pour x = '+ joinHuman(xs.map(fmtFR));
}

function ctxX_single(sp, th, xv){
  const xname = sp.xNoun || 'abscisse';
  if(xname==='ann√©es') return `en ${fmtNum(xv)}`;
  if(xname==='heures') return `√† ${fmtUnit(xv,'h')}`;
  if(xname==='mois')   return `au ${fmtNum(xv)}√®me mois`;
  if(xname==='jours')  return `au ${fmtNum(xv)}√®me jour`;
  if(xname==='temps')  return `au bout de ${fmtFR(xv)}${th.xUnit?'\u00A0'+th.xUnit:''}`;
  return `pour x = ${fmtFR(xv)}`;
}


/* Objet exercice 3 */
const ex3={
  id:'rg3',
  title:`Utiliser une courbe repr√©sentative (th√®mes)`,
  gen(){
    const lock = !(document.getElementById('pdfRandTheme')?.checked);
    const last = lock ? window.__rg3_last_theme : null;
    const th = last ? THEMES.find(t=>t.id===last) : pick(THEMES);
    return makeCurveState(th);
  },
  render(host,st){
    host.innerHTML=''; const row=document.createElement('div'); row.className='row single'; host.appendChild(row);
    const box=document.createElement('div'); box.className='statement'; row.appendChild(box);

    const sel=document.createElement('select'); sel.id='themeSel';
    THEMES.forEach(t=>{ const o=document.createElement('option'); o.value=t.id; o.textContent=t.title; sel.appendChild(o); });
    sel.value=st.th.id; window.__rg3_last_theme = st.th.id;

    const p=document.createElement('p'); p.textContent = st.th.context || st.th.title;
    const cons=document.createElement('div'); cons.className='consigne'; cons.appendChild(p); cons.appendChild(sel); box.appendChild(cons);

    const rep=buildRepereSVG({ xmin:st.xmin,xmax:st.xmax,ymin:st.ymin,ymax:st.ymax, grid:true, arrows:true, ticks:{x:st.stepX,y:st.stepY} });
    rep.svg.setAttribute('data-heavylabels','1');
    const pts = st.xs.map((x,i)=>({x:rep.X(x), y:rep.Y(st.ys[i])}));
    addPath(rep.plot, catmullRomPath(pts), {'stroke':'#000','stroke-width':2.6});
    box.appendChild(rep.svg);

    const form=document.createElement('div'); form.className='input-wrap'; row.appendChild(form);
    const q1 = `Quelles l√©gendes placer au bout des fl√®ches&nbsp;?
      abscisses&nbsp;:&nbsp;<input id="c1x" type="text" placeholder="‚Ä¶">
      ordonn√©es&nbsp;:&nbsp;<input id="c1y" type="text" placeholder="‚Ä¶">`;
    const q2 = st.th.q2(st.read1, st.read2);
    const q3 = st.th.q3(st.yTarget);
    form.innerHTML=
      `<div class="qa"><div class="q">1.</div><div class="a">${q1}</div></div>`+
      `<div class="qa"><div class="q">2.</div><div class="a">${q2}</div></div>`+
      `<div class="qa"><div class="q">3.</div><div class="a">${q3}</div></div>`;

    // Marqueurs ‚úì/‚úó (cr√©ation)
    ['c1x','c1y','c2a','c2b','c3a'].forEach(function(id){
      var el = host.querySelector('#'+id);
      if(el && !document.getElementById(id+'m')){
        var sp = document.createElement('span'); sp.id = id+'m'; sp.className='qmark';
        el.insertAdjacentElement('afterend', sp);
      }
    });

    // Helpers marquage : pas d‚Äôauto-validation, on efface seulement pendant la saisie
    function clearMark(el){
      const m = el && host.querySelector('#'+el.id+'m');
      if(!m) return;
      m.textContent = '';
      m.style.color = '';
    }
    // (version utilis√©e par correct()) ‚Äì si vide, ne montre rien
    function mark(el, ok){
      const m = el && host.querySelector('#'+el.id+'m');
      if(!m) return;
      const val = (el.value || '').trim();
      if(!val){ m.textContent=''; m.style.color=''; return; }
      m.textContent = ok ? ' ‚úì' : ' ‚úó';
      m.style.color = ok ? '#15803d' : '#b91c1c';
    }
    // brancher les effaceurs sur la saisie
    const xEl = host.querySelector('#c1x'), yEl = host.querySelector('#c1y');
    if(xEl) xEl.addEventListener('input', ()=>clearMark(xEl));
    if(yEl) yEl.addEventListener('input', ()=>clearMark(yEl));
    const aEl = host.querySelector('#c2a'), bEl = host.querySelector('#c2b');
    if(aEl) aEl.addEventListener('input', ()=>clearMark(aEl));
    if(bEl) bEl.addEventListener('input', ()=>clearMark(bEl));
    const cEl = host.querySelector('#c3a');
    if(cEl) cEl.addEventListener('input', ()=>clearMark(cEl));

    const res=document.createElement('div'); res.id='res'; row.appendChild(res);
    host.dataset.state=JSON.stringify(st); host.dataset.active='rg3';

    sel.addEventListener('change',function(){
      window.__rg3_last_theme = sel.value;
      const th2 = THEMES.find(t=>t.id===sel.value);
      const st2 = makeCurveState(th2);
      ex3.render(host,st2);
    });
  },
  solution(host,st){
    function interp(x){ let i=0; while(i<st.xs.length-1 && st.xs[i+1]<x) i++; const x1=st.xs[i],x2=st.xs[i+1],y1=st.ys[i],y2=st.ys[i+1]; const t=(x-x1)/(x2-x1); return y1+(y2-y1)*t; }
    const sp = EX3_Q1_SPEC[st.th.id] || { q1Line:"1) En abscisse : x ; en ordonn√©e : y", xNoun:"abscisse", yNoun:"la grandeur" };

    // Q1
    const q1Line = sp.q1Line;

    // Q2 (images enti√®res aux abscisses enti√®res choisies)
    const q2Line =
      `2) D‚Äôapr√®s la courbe ¬´ ${st.th.title} ¬ª, ${sp.yNoun} ${ctxX_single(sp, st.th, st.read1)} vaut ${fmtFR(st.y1Int)}${st.th.yUnit?'\u00A0'+st.th.yUnit:''} ; `+
      `${sp.yNoun} ${ctxX_single(sp, st.th, st.read2)} vaut ${fmtFR(st.y2Int)}${st.th.yUnit?'\u00A0'+st.th.yUnit:''}.`;

    // Q3 (ant√©c√©dents ENTIERs)
    const where = q3_wherePhrase(sp, st.rootsInt, st.th);
    const q3Line =
      `3) D‚Äôapr√®s la courbe ¬´ ${st.th.title} ¬ª, ${sp.yNoun} vaut ${fmtFR(st.yTarget)}${st.th.yUnit?'\u00A0'+st.th.yUnit:''} ${where}.`;

    showSteps(host,[ q1Line, q2Line, q3Line ]);
    document.body.classList.add('solution-active');
  },
  correct(){
    const host = document.querySelector('[data-active="rg3"]');
    if(!host) return { ok:false, score:0, total:3 };
    let st=null; try{ st = JSON.parse(host.dataset.state||'{}'); }catch(e){}
    if(!st) return { ok:false, score:0, total:3 };

    function mark(el, ok){
      if(!el) return;
      let m = host.querySelector('#'+el.id+'m');
      if(!m){ m=document.createElement('span'); m.id=el.id+'m'; m.className='qmark'; el.insertAdjacentElement('afterend', m); }
      const val = (el.value||'').trim();
      if(!val){ m.textContent=''; m.style.color=''; return; }
      m.textContent = ok ? ' ‚úì' : ' ‚úó';
      m.style.color = ok ? '#15803d' : '#b91c1c';
    }

// Q1 ‚Äî validation stricte (un seul mot attendu)
const xEl = host.querySelector('#c1x'), yEl = host.querySelector('#c1y');
if (xEl && yEl){
  const { okX, okY } = ex3_validateQ1(st.th.id, xEl.value, yEl.value);
  mark(xEl, okX);
  mark(yEl, okY);
  if (okX && okY) score++; // Q1 compte pour 1 point si les deux sont justes
}





    // Q2 : comparer aux entiers attendus
    const aEl = host.querySelector('#c2a'), bEl = host.querySelector('#c2b');
    if(aEl && bEl){
      const yTol = 0.5 * st.stepY;
      const av = parseNumberList(aEl.value)[0], bv = parseNumberList(bEl.value)[0];
      const aOK = (typeof av==='number' && withinTol(av, st.y1Int, yTol));
      const bOK = (typeof bv==='number' && withinTol(bv, st.y2Int, yTol));
      mark(aEl, !!aOK); mark(bEl, !!bOK);
      if(aOK && bOK) score++;
    }

    // Q3 : ant√©c√©dents ENTIERs (ensemble √©gal)
    const cEl = host.querySelector('#c3a');
    if(cEl){
      const typed = parseNumberList(cEl.value).map(n=>Math.round(n));
      const expected = st.rootsInt.map(n=>Math.round(n));
      const setT = new Set(typed), setE = new Set(expected);
      let okQ3 = typed.length>0 && setT.size===setE.size;
      if(okQ3){ for(const v of setE){ if(!setT.has(v)) {okQ3=false; break;} } }
      mark(cEl, okQ3);
      if(okQ3) score++;
    }

    return { ok:(score===total), score, total };
  },
  reset(host){
    host.querySelectorAll('input').forEach(i=>i.value='');
    document.body.classList.remove('solution-active');
    ['c1x','c1y','c2a','c2b','c3a'].forEach(id=>{ const m=host.querySelector('#'+id+'m'); if(m) m.textContent=''; });
  },
  pdfStatement(s){ return buildPDFStatementFromRender(ex3, s); }
};

// Exposer l'exo 3 pour les handlers globaux √©ventuels
window.REGISTRY = Object.assign(window.REGISTRY||{}, { rg3: ex3 });

// D√©l√©gation de clics : V√©rifier / Solution / R√©initialiser
document.addEventListener('click', (e)=>{
  const is = sel=>e.target.closest(sel);
  if(is('#btn-check,[data-action="check"]')){
    e.preventDefault();
    const res = ex3.correct();
    const host = document.querySelector('[data-active="rg3"]');
    const box  = host && host.querySelector('#res');
    if(box) box.textContent = `Score : ${res.score}/${res.total}`;
  }
  if(is('#btn-solution,[data-action="solution"]')){
    const host = document.querySelector('[data-active="rg3"]');
    if(!host) return;
    let st=null; try{ st = JSON.parse(host.dataset.state||'{}'); }catch(_){}
    if(st) ex3.solution(host,st);
  }
  if(is('#btn-reset,[data-action="reset"]')){
    const host = document.querySelector('[data-active="rg3"]');
    if(host) ex3.reset(host);
  }
});



/* ========================== EXERCICE 4 : tableaux ========================== */
const ex4={
  id:'rg4',
  title: `Tableaux images & ant√©c√©dents`,
  gen(){
    const R={...AMP};
    const qImg = Math.max(5, clamp(parseInt($('#cfg-img')?.value||5,10),1,10));
    const qAnt = 3;

    // Grid + images (table 1): X int or half, distinct images integer or .5
    let ok=false, grid=null, Xs=null;
    for(let attempt=0; attempt<300; attempt++){
      grid = genCurveIntegerGrid(R, true);
      const xs = pickXsIntOrHalf(R, qImg).sort((a,b)=>a-b);
      const ys = xs.map(x=>interpAtGrid(grid,x));
      const okVals = ys.every(v=>Math.abs(v - Math.round(v))<1e-9 || Math.abs(v*2 - Math.round(v*2))<1e-9);
      const uniqY = uniq(ys,(a,b)=>Math.abs(a-b)<1e-9);
      if(okVals && uniqY.length===ys.length){ Xs=xs; ok=true; break; }
    }

    // Ant√©c√©dents (table 2): choose (qAnt-1) Y int or half with 1..3 integer solutions + 1 inexistant
    let okAnt=false, gForced=null, Ys=null, yNone=null;
    const Ycand = pickYsIntOrHalf(R, Math.max(2*qAnt, 10));
    for(let t=0; t<400; t++){
      const trial = uniq(shuffle(Ycand)).slice(0, Math.max(0,qAnt-1));
      gForced = buildGridWithConstraints(R, 3, trial);
      const good = trial.every(y=>{
        const A = antecedentsOfGrid(gForced, y);
        const Ai = A.filter(x=>Math.abs(x - Math.round(x))<1e-9);
        const An = A.filter(x=>Math.abs(x - Math.round(x))>=1e-9);
        return Ai.length>=1 && Ai.length<=3 && An.length===0;
      });
      if(good){ Ys=trial.sort((a,b)=>a-b); okAnt=true; break; }
    }
    if(okAnt){
      const allY=[]; for(let y=R.ymin+1; y<=R.ymax-1; y++){ allY.push(y); if(y+0.5<R.ymax) allY.push(y+0.5); }
      const zeroInside = allY.filter(y=>!Ys.includes(y) && antecedentsOfGrid(gForced, y).length===0);
      yNone = zeroInside.length ? zeroInside[0] : (Math.random()<0.5 ? (R.ymax+1) : (R.ymin-1));
      Ys=[...Ys, yNone];
      grid = gForced;
    }

    return { R, grid, Xs, Ys };
    

      },
  solution(host,st){
    const fAt=x=>interpAtGrid(st.grid,x);
    const Aofy=y=>antecedentsOfGrid(st.grid,y);
    const t1='<table class="tbl"><tbody><tr><th>x</th>'+st.Xs.map(x=>'<td>'+fmtFR(x)+'</td>').join('')+'</tr>'+
             '<tr><th>f(x)</th>'+st.Xs.map(x=>'<td>'+fmtFR(fAt(x))+'</td>').join('')+'</tr></tbody></table>';
    const t2='<table class="tbl"><tbody><tr><th>y</th>'+st.Ys.map(y=>'<td>'+fmtFR(y)+'</td>').join('')+'</tr>'+
             '<tr><th>Ant√©c√©dent(s)</th>'+st.Ys.map(y=>{ const A=Aofy(y).map(fmtFR); return '<td>'+(A.length?A.join(' ; '):'aucun')+'</td>'; }).join('')+'</tr></tbody></table>';
    showSteps(host,[`Ensemble de d√©finition : [${fmtFR(st.R.xmin)} ; ${fmtFR(st.R.xmax)}]`,'Tableau images :<br>'+t1,'Ant√©c√©dents :<br>'+t2]);
  },
  render(host,st){
    host.innerHTML='';
    const row1=document.createElement('div'); row1.className='row single'; host.appendChild(row1);
    const stBox=document.createElement('div'); stBox.className='statement'; row1.appendChild(stBox);
    stBox.innerHTML='<div class="consigne">Compl√©ter les tableaux par lecture graphique.</div>';
    const rep=buildRepereSVG({xmin:st.R.xmin,xmax:st.R.xmax,ymin:st.R.ymin,ymax:st.R.ymax,grid:true,arrows:true});
    addPath(rep.plot, pathFromGridSmooth(rep, st.grid), {'stroke':'#c00','stroke-width':3.2});
    stBox.appendChild(rep.svg);

    const row2=document.createElement('div'); row2.className='row single'; host.appendChild(row2);
    const box=document.createElement('div'); row2.appendChild(box);
    const t1=`<table class="tbl"><thead><tr><th>x</th>${st.Xs.map(x=>`<th>${fmtFR(x)}</th>`).join('')}</tr></thead>
              <tbody><tr><th>f(x)</th>${st.Xs.map(()=>`<td><input class="c1" type="text"></td>`).join('')}</tr></tbody></table>`;
    const t2=`<table class="tbl"><thead><tr><th>y</th>${st.Ys.map(y=>`<th>${fmtFR(y)}</th>`).join('')}</tr></thead>
              <tbody><tr><th>Ant√©c√©dent(s)</th>${st.Ys.map(()=>`<td><input class="c2" type="text"></td>`).join('')}</tr></tbody></table>`;
    box.innerHTML = `<div class="qa"><div class="q">1.</div><div class="a">Ensemble de d√©finition&nbsp;:&nbsp;<input id="dD" type="text"><span id="dDm" class="qmark"></span></div></div>
                     <div class="qa"><div class="q">2.</div><div class="a">${t1}</div></div>
                     <div class="qa"><div class="q">3.</div><div class="a">${t2}</div></div>`;

    
    // Assign ids and add mark spans for each input in tables
    (box.querySelectorAll('input.c1')||[]).forEach((el,i)=>{
      if(!el.id) el.id = 'dI'+i;
      if(!document.getElementById(el.id+'m')){
        const sp = document.createElement('span'); sp.id = el.id+'m'; sp.className='qmark';
        el.insertAdjacentElement('afterend', sp);
      }
    });
    (box.querySelectorAll('input.c2')||[]).forEach((el,j)=>{
      if(!el.id) el.id = 'dA'+j;
      if(!document.getElementById(el.id+'m')){
        const sp = document.createElement('span'); sp.id = el.id+'m'; sp.className='qmark';
        el.insertAdjacentElement('afterend', sp);
      }
    });
host.dataset.state=JSON.stringify(st); host.dataset.active='rg4';
  
    
    // Clear prefilled Domaine input for Ex.4
    (function(){ const dD = $('#dD',host); if(dD) dD.value=''; })();
// Ensure result container for solutions
    const res=document.createElement('div'); res.id='res'; 
    if (row2) { row2.appendChild(res); } else { host.appendChild(res); }
    },
  solution(host,st){
    const fAt=x=>interpAtGrid(st.grid,x);
    const Aofy=y=>antecedentsOfGrid(st.grid,y);
    const t1='<table class="tbl"><tbody><tr><th>x</th>'+st.Xs.map(x=>'<td>'+fmtFR(x)+'</td>').join('')+'</tr>'+
             '<tr><th>f(x)</th>'+st.Xs.map(x=>'<td>'+fmtFR(fAt(x))+'</td>').join('')+'</tr></tbody></table>';
    const t2='<table class="tbl"><tbody><tr><th>y</th>'+st.Ys.map(y=>'<td>'+fmtFR(y)+'</td>').join('')+'</tr>'+
             '<tr><th>Ant√©c√©dent(s)</th>'+st.Ys.map(y=>{ const A=Aofy(y).map(fmtFR); return '<td>'+(A.length?A.join(' ; '):'aucun')+'</td>'; }).join('')+'</tr></tbody></table>';
    showSteps(host,[`Ensemble de d√©finition : [${fmtFR(st.R.xmin)} ; ${fmtFR(st.R.xmax)}]`,'Tableau images :<br>'+t1,'Ant√©c√©dents :<br>'+t2]);
  },
  correct(host,st){
    const v=$('#dD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
    const okDom=(v.length===2 && v[0]!=='' && v[1]!=='' ? (+v[0]===st.R.xmin && +v[1]===st.R.xmax) : true);
    $('#dDm',host).textContent = okDom?'‚úî':'‚úò'; $('#dDm',host).style.color=okDom?'#14532d':'#991b1b';
    (function(){
      const anyEmpty = Array.from(host.querySelectorAll('input[type="text"]')).some(i=>i.value.trim()==='');
      const okFlag = true; /* placeholder; will be set below by previous code */
    })();
    return {ok:okDom,total:1}; // empties ignored
  },
  reset(host){ host.querySelectorAll('input').forEach(i=>i.value=''); clearMarks(host); document.body.classList.remove('solution-active'); },
  pdfStatement(s){ return buildPDFStatementFromRender(ex4, s); }
};

/* ========================== EXERCICE 5 : Fonction ou pas ? ========================== */
function addMiniPath(g,d){ addPath(g.plot,d,{'stroke':'#000','stroke-width':2}); }
function drawParab(g){ const pts=[]; for(let x=-4;x<=4;x+=0.05) pts.push({x:g.X(x),y:g.Y(0.5*x*x-2)}); addMiniPath(g,catmullRomPath(pts)); }
function drawAbs(g){ const pts=[]; for(let x=-4;x<=4;x+=0.05) pts.push({x:g.X(x),y:g.Y(Math.abs(x)-1)}); addMiniPath(g,catmullRomPath(pts)); }
function drawSigm(g){ const pts=[]; for(let x=-4;x<=4;x+=0.05) pts.push({x:g.X(x),y:g.Y(3/(1+Math.exp(-x))-1.5)}); addMiniPath(g,catmullRomPath(pts)); }
function drawLineC(g){ addLine(g.plot, g.X(-4), g.Y(-2), g.X(4), g.Y(2), {'stroke':'#000','stroke-width':2}); }

function drawCircle(g){ const pts=[]; for(let t=0;t<=2*Math.PI+0.01;t+=0.02){ const x=2.6*Math.cos(t), y=2.0*Math.sin(t); pts.push({x:g.X(x),y:g.Y(y)});} addMiniPath(g,catmullRomPath(pts)); }
function drawEllipse(g){ const a=3,b=1.6,ang=Math.PI/6,pts=[]; for(let t=0;t<=2*Math.PI+0.001;t+=0.02){ const x=a*Math.cos(t), y=b*Math.sin(t); const xr=x*Math.cos(ang)-y*Math.sin(ang), yr=x*Math.sin(ang)+y*Math.cos(ang); pts.push({x:g.X(xr),y:g.Y(yr)});} addMiniPath(g,catmullRomPath(pts)); }
function drawRect(g){ const r=[[-2.8,-1.8],[2.8,-1.8],[2.8,1.8],[-2.8,1.8],[-2.8,-1.8]]; addMiniPath(g,catmullRomPath(r.map(([x,y])=>({x:g.X(x),y:g.Y(y)})))); }
function drawDiamond(g){ const r=[[0,3],[-3,0],[0,-3],[3,0],[0,3]]; addMiniPath(g,catmullRomPath(r.map(([x,y])=>({x:g.X(x),y:g.Y(y)})))); }
function drawStar5(g){ const R=3,r=1.3,pts=[]; for(let k=0;k<10;k++){ const a=(Math.PI/5)*k - Math.PI/2; const rad=(k%2? r : R); pts.push({x:g.X(rad*Math.cos(a)),y:g.Y(rad*Math.sin(a))}); } pts.push(pts[0]); addMiniPath(g,catmullRomPath(pts)); }
function drawInfinity(g){ const pts=[]; for(let t=-Math.PI;t<=Math.PI+0.001;t+=0.02){ const x=3*Math.sin(t), y=2*Math.sin(2*t)/1.5; pts.push({x:g.X(x),y:g.Y(y)});} addMiniPath(g,catmullRomPath(pts)); }
function drawFlower(g){ const pts=[]; for(let t=0; t<=2*Math.PI+0.001; t+=0.012){ const r = 2 + 1.2*Math.cos(4*t); const x = 0.9*r*Math.cos(t); const y = 0.9*r*Math.sin(t); pts.push({x:g.X(x), y:g.Y(y)});} addMiniPath(g, catmullRomPath(pts)); }
function drawCrescent(g){ const outer=[], inner=[]; const R=3, r=2; for(let a=-0.6*Math.PI;a<=0.6*Math.PI;a+=0.02){ outer.push({x:g.X(R*Math.cos(a)), y:g.Y(R*Math.sin(a))}); } for(let a=0.6*Math.PI; a>=-0.6*Math.PI; a-=0.02){ inner.push({x:g.X(1+ r*Math.cos(a)), y:g.Y(r*Math.sin(a))}); } addMiniPath(g,catmullRomPath([...outer,...inner, outer[0]])); }
function drawXLetter(g){ addLine(g.plot, g.X(-3), g.Y(3), g.X(3), g.Y(-3), {'stroke':'#000','stroke-width':2}); addLine(g.plot, g.X(-3), g.Y(-3), g.X(3), g.Y(3), {'stroke':'#000','stroke-width':2}); }
function drawSLetter(g){ const pts1=[], pts2=[]; for(let t=-3.2; t<=0; t+=0.2){ pts1.push({ x: g.X(t), y: g.Y(1.3*Math.sin(-t) + 1.2) }); } for(let t=0; t<=3.2; t+=0.2){ pts2.push({ x: g.X(t), y: g.Y(1.3*Math.sin(-t) - 1.2) }); } addMiniPath(g, catmullRomPath(pts1)); addMiniPath(g, catmullRomPath(pts2)); }
// üîß Remplacer totalement les versions actuelles par celles-ci

function drawHeart(g){
  const pts=[];
  for(let t=0;t<=2*Math.PI+0.001;t+=0.02){
    const x=0.16*(16*Math.sin(t)**3)*1.6;
    const y=0.16*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
    pts.push({ x:g.X(x), y:g.Y(y) });
  }
  addMiniPath(g, catmullRomPath(pts));
}

function drawSpiral(g){
  const pts=[];
  for(let t=0;t<=4*Math.PI+0.001;t+=0.03){
    const r=0.3*t, x=r*Math.cos(t), y=r*Math.sin(t);
    pts.push({ x:g.X(x), y:g.Y(y) });
  }
  addMiniPath(g, catmullRomPath(pts));
}

function drawClover3(g){
  const pts=[];
  for(let t=0;t<=2*Math.PI+0.001;t+=0.02){
    const r=2.2*Math.cos(3*t);
    const x=r*Math.cos(t), y=r*Math.sin(t);
    pts.push({ x:g.X(x), y:g.Y(y) });
  }
  addMiniPath(g, catmullRomPath(pts));
}

function drawClover4(g){
  const pts=[];
  for(let t=0;t<=2*Math.PI+0.001;t+=0.02){
    const r=2.2*Math.cos(2*t);
    const x=r*Math.cos(t), y=r*Math.sin(t);
    pts.push({ x:g.X(x), y:g.Y(y) });
  }
  addMiniPath(g, catmullRomPath(pts));
}

function drawTeardrop(g){
  const pts=[];
  for(let t=0;t<=2*Math.PI+0.001;t+=0.02){
    const rr=1.8*(1+Math.sin(t));
    const x=rr*Math.cos(t), y=rr*Math.sin(t)-1.2;
    pts.push({ x:g.X(x), y:g.Y(y) });
  }
  addMiniPath(g, catmullRomPath(pts));
}

/* banques */
const FUN_BANK=[
  {name:'Parabole',draw:drawParab,isFn:true},
  {name:'Valeur absolue',draw:drawAbs,isFn:true},
  {name:'Sigmo√Øde (S)',draw:drawSigm,isFn:true},
  {name:'Droite',draw:drawLineC,isFn:true},
];
const NON_BANK=[
  {name:'Cercle',draw:drawCircle,isFn:false},
  {name:'Ellipse',draw:drawEllipse,isFn:false},
  {name:'Rectangle',draw:drawRect,isFn:false},
  {name:'Losange',draw:drawDiamond,isFn:false},
  {name:'√âtoile',draw:drawStar5,isFn:false},
  {name:'Infini',draw:drawInfinity,isFn:false},
  {name:'C≈ìur',draw:drawHeart,isFn:false},
  {name:'Spirale',draw:drawSpiral,isFn:false},
  {name:'Fleur (rosace)',draw:drawFlower,isFn:false},
  {name:'Tr√®fle (3)',draw:drawClover3,isFn:false},
  {name:'Tr√®fle (4)',draw:drawClover4,isFn:false},
  {name:'Croissant',draw:drawCrescent,isFn:false},
  {name:'Goutte',draw:drawTeardrop,isFn:false},
  {name:'Lettre X',draw:drawXLetter,isFn:false},
  {name:'Lettre S',draw:drawSLetter,isFn:false},
];

const ex5={
  id:'rg5',
  title:`Pour chaque courbe, dire si elle repr√©sente une fonction`,
  gen(){
    const tiles = shuffle( shuffle(FUN_BANK).slice(0,2).concat( shuffle(NON_BANK).slice(0,3) ) );
    return {tiles};
  },
  render(host,st){
    const row=document.createElement('div'); row.className='row single'; host.innerHTML=''; host.appendChild(row);
    const s=document.createElement('div'); s.className='statement'; row.appendChild(s);
    s.innerHTML='<div class="consigne">Pour chaque courbe, dire si elle repr√©sente une fonction.</div>';
    const grid=document.createElement('div'); grid.className='mini-grid';
    st.tiles.forEach((m,i)=>{
      const r = buildRepereOrtho({ xmin:-4, xmax:4, ymin:-4, ymax:4, ticks:{x:1,y:1} });
      m.draw(r);

      const box=document.createElement('div'); box.className='mini';
      const title=document.createElement('div'); title.className='title'; title.textContent='Courbe '+String.fromCharCode(65+i);
      const ans=document.createElement('div'); ans.innerHTML='R√©ponse&nbsp;: <select class="yesno"><option value="">‚Äî</option><option>Oui</option><option>Non</option></select>';
      r.svg.dataset.ok=m.isFn?'Oui':'Non'; r.svg.dataset.real=m.name;
      box.appendChild(title); box.appendChild(r.svg); box.appendChild(ans);
      grid.appendChild(box);
    });
    s.appendChild(grid);
    host.dataset.active='rg5'; host.dataset.state=JSON.stringify(st);
  },
  /* Correction : affiche ‚úì/‚úó par tuile + petit test de la droite verticale */
  solution(host){
    const minis = Array.from(host.querySelectorAll('.mini'));
    minis.forEach((box,i)=>{
      const svg=box.querySelector('svg'); const want=svg.dataset.ok; const model=svg.dataset.real;
      const select=box.querySelector('.yesno'); const got=select.value||'‚Äî';
      const good = (got!=='' && got===want);
      box.querySelector('.title').innerHTML = `Courbe ${String.fromCharCode(65+i)} ‚Äî ${model} <span class="badge ${good?'ok':'ko'}">${got||'‚Äî'} / ${want}</span>`;

      // lignes verticales de test : 1 si fonction, 2 croisements si non-fonction
      const W=560,H=360; const g=svg.querySelector('.plot');
      if(want==='Oui'){ const x= (W/2)+80; addLine(g,x,10,x,H-10,{stroke:'#22c55e','stroke-dasharray':'6 6','stroke-width':2}); }
      else{ const x1=(W/2)-70, x2=(W/2)+70; addLine(g,x1,10,x1,H-10,{stroke:'#ef4444','stroke-dasharray':'6 6','stroke-width':2}); addLine(g,x2,10,x2,H-10,{stroke:'#ef4444','stroke-dasharray':'6 6','stroke-width':2}); }
    });
    showSteps(host,['Rappel : une courbe repr√©sente une fonction quand toute droite verticale la coupe au plus une fois.']);
    document.body.classList.add('solution-active');
  },
  correct(host){
    let ok=true;
    host.querySelectorAll('.mini').forEach(box=>{
      const want=(box.querySelector('svg').dataset.ok||'').toLowerCase();
      const got=(box.querySelector('.yesno').value||'').toLowerCase();
      if(!want || want!==got) ok=false;
    });
    (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = (ok?'‚úî':'‚úò');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })();
    return {ok,total:1};
  },
  reset(host){ host.querySelectorAll('.yesno').forEach(s=>s.value=''); clearMarks(host); document.body.classList.remove('solution-active'); },
  pdfStatement(s){ return buildPDFStatementFromRender(ex5, s); }
};

/* ========== Registry & moteur ========== */
const REGISTRY=[ex1,ex2,ex3,ex4,ex5];
window.REGISTRY = REGISTRY; // expose for exo-pdf-kit
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host"), def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  
  // Adjust antecedents selector limit depending on exercise (rg2 & rg4 -> max 3, others -> max 5)
  try{
    const ant = document.getElementById('cfg-ant');
    if(ant){
      const maxVal = (def.id==='rg2' || def.id==='rg4') ? 3 : 5;
      ant.setAttribute('max', String(maxVal));
      if(ant.tagName === 'SELECT'){
        Array.from(ant.options).forEach(op=>{
          const v = parseInt(op.value,10);
          if(v>maxVal) op.remove();
        });
        if(parseInt(ant.value||'0',10) > maxVal) ant.value = String(maxVal);
      } else {
        if(parseInt(ant.value||'0',10) > maxVal) ant.value = String(maxVal);
      }
    }
  }catch(e){ console && console.warn && console.warn('cfg-ant adjust failed', e); }
const st=def.gen?def.gen():{};
  host.dataset.state=JSON.stringify(st); host.dataset.active=def.id;
  def.render(host,st); 
  (function(){ let r=$('#res',host); if(!r){ r=document.createElement('div'); r.id='res'; host.appendChild(r);} })();
  (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = ('');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })();
  document.body.classList.remove('solution-active');
}

function check(){
  const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  let okAll=true, total=0, okCount=0;

  function mark(id, ok){
    const m = host.querySelector('#'+id);
    if(!m) return;
    m.textContent = ok ? '‚úî' : '‚úò';
    m.style.color = ok ? '#14532d' : '#991b1b';
  }
  function isEmpty(v){ return !v || v.trim()===''; }
  function normToken(tok){
    return tok.replace(/\u00A0/g,' ')  // NBSP -> space
              .replace(/\u2212/g,'-')  // Unicode minus -> hyphen
              .replace(/\s+/g,' ')     // collapse spaces
              .trim();
  }

  if(def.id==='rg2'){
    // domain (ensemble de d√©finition)
    const dRaw = ($('#bD',host)?.value||'');
    const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++;
      const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('bDm', okD); okAll &= okD; if(okD) okCount++;
    }

    // images
    (st.Ximg||[]).forEach((x,i)=>{
      const raw = ($('#bI'+i,host)?.value||'');
      const t = normToken(raw);
      if(isEmpty(t)) return;
      total++;
      const v = Math.round(interpAtGrid(st.grid, x)*10)/10;
      const ans = t.replace(',', '.'); // allow decimal comma
      const ok = Math.abs(parseFloat(ans) - v) <= 0.2;
      mark('bI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // antecedents ‚Äî semicolon-separated only; accept 'aucun'
    (st.Yask||[]).forEach((y,j)=>{
      const raw = ($('#bA'+j,host)?.value||'');
      const t = normToken(raw).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseFloat(s.replace(',', '.')));
        ok = (L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      mark('bA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  } else if(def.id==='rg1'){
    // domaine
    const dRaw = ($('#aD',host)?.value||'');
    const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++;
      const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('aDm', okD); okAll &= okD; if(okD) okCount++;
    }
    // images
    (st.Ximg||[]).forEach((x,i)=>{
      const raw = ($('#aI'+i,host)?.value||'');
      const t = normToken(raw);
      if(isEmpty(t)) return;
      total++;
      const ok = (parseInt(t,10)===interpAtGrid(st.grid,x));
      mark('aI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // antecedents ‚Äî semicolon only; accept 'aucun'
    (st.Yask||[]).forEach((y,j)=>{
      const raw = ($('#aA'+j,host)?.value||'');
      const t = normToken(raw).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v));
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseInt(s,10));
        ok = (L.length===A.length) && L.every(v=>A.includes(v));
      }
      mark('aA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  } 
  else if (def.id === 'rg3') {
  // Q1 ‚Äî mots attendus (tol√©rance accents/majuscules/pluriels/espaces)
  const xVal = ($('#c1x',host)?.value || '');
  const yVal = ($('#c1y',host)?.value || '');
  const { okX, okY } = ex3_validateQ1(st.th.id, xVal, yVal);
  if (!isEmpty(xVal)) { total++; mark('c1xm', okX); okAll &= okX; if (okX) okCount++; }
  if (!isEmpty(yVal)) { total++; mark('c1ym', okY); okAll &= okY; if (okY) okCount++; }

  // Q2 ‚Äî images ENTIERES projet√©es sur la grille (tol√©rance = ¬Ω pas vertical)
  const t2a = ($('#c2a',host)?.value || '').trim();
  const t2b = ($('#c2b',host)?.value || '').trim();
  const yTol = 0.5 * st.stepY;
  const toNum = s => { const n = parseFloat(String(s).replace(',','.')); return Number.isFinite(n) ? n : NaN; };

  if (!isEmpty(t2a)) {
    total++;
    const av = toNum(t2a);
    const ok = Number.isFinite(av) && Math.abs(av - st.y1Int) <= yTol;
    mark('c2am', ok); okAll &= ok; if (ok) okCount++;
  }
  if (!isEmpty(t2b)) {
    total++;
    const bv = toNum(t2b);
    const ok = Number.isFinite(bv) && Math.abs(bv - st.y2Int) <= yTol;
    mark('c2bm', ok); okAll &= ok; if (ok) okCount++;
  }

  // Q3 ‚Äî ant√©c√©dents ENTIERs (√©galit√© d‚Äôensembles)
  const t3 = ($('#c3a',host)?.value || '').trim();
  if (!isEmpty(t3)) {
    total++;
    const typed = parseNumberList(t3).map(n => Math.round(n));
    const expected = st.rootsInt.map(n => Math.round(n));
    const setEq = (A,B) => {
      if (A.length !== B.length) return false;
      const SA = new Set(A), SB = new Set(B);
      for (const v of SA) if (!SB.has(v)) return false;
      return true;
    };
    const ok = typed.length > 0 && setEq(typed, expected);
    mark('c3am', ok); okAll &= ok; if (ok) okCount++;
  }
}

else if(def.id==='rg4'){
    // domain
    const dRaw = ($('#dD',host)?.value||''); const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++; const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('dDm', okD); okAll &= okD; if(okD) okCount++;
    }
    // table images (c1 / dI*)
    const fAt = x=>Math.round(interpAtGrid(st.grid,x)*10)/10;
    (st.Xs||[]).forEach((x,i)=>{
      const el = $('#dI'+i, host) || host.querySelectorAll('input.c1')[i];
      if(!el) return;
      const t = normToken(el.value);
      if(isEmpty(t)) return;
      total++;
      const ans = t.replace(',', '.');
      const ok = Math.abs(parseFloat(ans) - fAt(x)) <= 0.2;
      mark('dI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // table ant√©c√©dents (c2 / dA*) ‚Äî semicolon-only; accept 'aucun'
    (st.Ys||[]).forEach((y,j)=>{
      const el = $('#dA'+j, host) || host.querySelectorAll('input.c2')[j];
      if(!el) return;
      const t = normToken(el.value).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseFloat(s.replace(',', '.')));
        ok = (L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      mark('dA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  }

  // update global score (count only filled inputs)
  scoreTot += (total||1);
  scoreOK += (okCount||0);
  updateScore();
  document.body.classList.remove('solution-active');
}


function solution(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

/* ==== Init ==== */
document.addEventListener('DOMContentLoaded',()=>{
  $('#amp-apply').addEventListener('click',applyAMP);
  const sel=$("#exo-select"); REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change',buildOne);
  $("#btn-new").addEventListener('click', buildOne);      // Ex.3 : reste sur le th√®me courant
  $("#btn-check").addEventListener('click', check);
  // Enter triggers check
  document.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); check(); } }, {capture:true});
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  sel.value=REGISTRY[0].id; buildOne(); updateScore();
});
})();



</script>

<script>

// === Helper for PDF: build statement HTML exactly like screen, then freeze rep√®re size to screen width ===
function buildPDFStatementFromRender(def, st){
  const tmp=document.createElement('div');
  def.render(tmp, st);
  const stEl = tmp.querySelector('.statement') || tmp;
  // remove interactive controls if any
  stEl.querySelectorAll('select,button,.optionline,.controls').forEach(el=>el.remove());
  // keep questions: replace inputs with a small square
  stEl.querySelectorAll('input[type="text"]').forEach(inp=>{
    const span=document.createElement('span'); span.textContent='‚ñ¢';
    inp.replaceWith(span);
  });
  // lock SVG size to on-screen statement width (base design is 560px)
  const wScreen = (document.querySelector('.statement svg.repere')?.getBoundingClientRect().width) || 560;
  stEl.querySelectorAll('svg.repere').forEach(svg=>{
    svg.style.width = Math.round(wScreen) + 'px';
    svg.style.height = 'auto';
    svg.style.maxWidth = 'none';
    svg.style.display = 'block';
    svg.style.margin = '.25rem auto';
  });
  return stEl.outerHTML;
}
</script>

<script>
window.addEventListener('load',function(){
  if(window.ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title: `Seconde ‚Äî Repr√©sentation graphique`,
      max: 50,
      lead: '',
      leadByDefId: { rg1:'', rg2:'', rg3:'', rg4:'', rg5:'' },
      mountAfterSelector: '.card.small'
      ,
      beforeRender(def, st, withSolutions){
        try{
          const tmp=document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
          tmp.style.width='0'; tmp.style.height='0'; tmp.style.overflow='hidden';
          document.body.appendChild(tmp);

          if(typeof def.render==='function'){ def.render(tmp, st); }

          const wRef = (document.querySelector('.statement svg.repere')?.getBoundingClientRect().width) || 560;
          tmp.querySelectorAll('svg.repere').forEach(svg=>{
            svg.style.width = Math.round(wRef) + 'px';
            svg.style.height = 'auto';
            svg.style.maxWidth = 'none';
            svg.style.display = 'block';
            svg.style.margin = '.25rem auto';
          });

          if(!withSolutions){
            const row = tmp.querySelector('.row') || tmp;
            row.querySelectorAll('#res,.optionline,.controls,.kbd-host,button').forEach(n=>n.remove());
            // keep questions: replace inputs with a small square
            row.querySelectorAll('input[type="text"]').forEach(inp=>{
              const span=document.createElement('span'); span.textContent='‚ñ¢';
              inp.replaceWith(span);
            });
            const stEl = row.querySelector('.statement') || row;
            const html = stEl.outerHTML || row.outerHTML || tmp.innerHTML;
            tmp.remove();
            return {statement: html};
          }

          if(typeof def.solution==='function'){
            try{ def.solution(tmp, st); }catch(_){}
          }else if(typeof def.correct==='function'){
            try{ def.correct(tmp, st); }catch(_){}
          }
          tmp.querySelectorAll('input#reponse,input[name=reponse]').forEach(n=>n.remove());
          const sol = tmp.querySelector('.steps') || tmp.querySelector('.solution') || tmp.querySelector('#res') || tmp;
          const html = sol.outerHTML || sol.innerHTML || tmp.innerHTML || '';
          tmp.remove();
          return {solution: html};
        }catch(e){ /* let kit fallback */ }
      }
    ,
      beforeGen(def, st, ctx){
        try{
          const ampRnd = document.getElementById('pdfRandAmp')?.checked;
          const naRnd  = document.getElementById('pdfRandNA')?.checked;

          const xminEl=document.getElementById('xmin'), xmaxEl=document.getElementById('xmax');
          const yminEl=document.getElementById('ymin'), ymaxEl=document.getElementById('ymax');
          const imgEl = document.getElementById('cfg-img'), antEl=document.getElementById('cfg-ant');

          const thRnd = document.getElementById('pdfRandTheme')?.checked;
          if(def && def.id==='rg3'){
            if(thRnd){ window.__rg3_last_theme = null; }
            else{
              const sel = document.getElementById('themeSel');
              if(sel){ window.__rg3_last_theme = sel.value; }
            }
          }

          const save = {
            AMP: {...AMP},
            xmin: xminEl && xminEl.value, xmax: xmaxEl && xmaxEl.value,
            ymin: yminEl && yminEl.value, ymax: ymaxEl && ymaxEl.value,
            img: imgEl && imgEl.value, ant: antEl && antEl.value
          };

          const seed = (ctx && (ctx.index||0)) * 2654435761 ^ Date.now();
          let t = Math.imul(1779033703 ^ seed, 3432918353); t=(t<<13)|(t>>>19);
          function rng(){ t=Math.imul(t^(t>>>16),2246822507); t=Math.imul(t^(t>>>13),3266489909); t^=t>>>16; return (t>>>0)/4294967296; }
          function ri(a,b){ return a + Math.floor(rng()*(b-a+1)); }

          if (ampRnd){
            const xi = ri(-12, -2), xa = ri(2, 12);
            const yi = ri(-12, -2), ya = ri(2, 12);
            AMP = { xmin: Math.min(xi,xa), xmax: Math.max(xi,xa), ymin: Math.min(yi,ya), ymax: Math.max(yi,ya) };
            if (xminEl) xminEl.value = AMP.xmin;
            if (xmaxEl) xmaxEl.value = AMP.xmax;
            if (yminEl) yminEl.value = AMP.ymin;
            if (ymaxEl) ymaxEl.value = AMP.ymax;
          }

          if (naRnd && (def && (def.id==='rg1' || def.id==='rg2' || def.id==='rg4'))){
            const rImg = ri(2,10), rAnt = ri(2,10);
            if (imgEl) imgEl.value = String(rImg);
            if (antEl) antEl.value = String(rAnt);
          }

          return function restore(){
            AMP = save.AMP;
            if (xminEl) xminEl.value = save.xmin;
            if (xmaxEl) xmaxEl.value = save.xmax;
            if (yminEl) yminEl.value = save.ymin;
            if (ymaxEl) ymaxEl.value = save.ymax;
            if (imgEl) imgEl.value = save.img;
            if (antEl) antEl.value = save.ant;
          };
        }catch(e){ /* silent */ }
      }
    });
  }else{
    const slot=document.querySelector('.card.small');
    const div=document.createElement('div'); div.className='controls';
    div.innerHTML='<button id="btn-print" class="btn">üñ®Ô∏è G√©n√©rer un PDF</button><small style="opacity:.7;margin-left:8px">Choisissez ¬´ Enregistrer au format PDF ¬ª.</small>';
    slot.appendChild(div);
    document.getElementById('btn-print').addEventListener('click',()=>window.print());
  }
});
</script>


<script>
(function(){
  if(window.__patched_ex4) return;
  try{
    ex4.correct = function(host, st){
      const v=$('#dD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
      const okDom=(v.length===2 && +v[0]===st.R.xmin && +v[1]===st.R.xmax);
      $('#dDm',host).textContent = okDom?'‚úî':'‚úò';
      $('#dDm',host).style.color=okDom?'#14532d':'#991b1b';
      const c1 = Array.from(host.querySelectorAll('table input.c1'));
      const c2 = Array.from(host.querySelectorAll('table input.c2'));
      let okTables = true;
      c1.forEach((inp, idx)=>{
        const want = Math.round(interpAtGrid(st.grid, st.Xs[idx]) * 10)/10;
        const got  = Number(String(inp.value).replace(',', '.').replace(/\u2212/g,'-'));
        const ok = Number.isFinite(got) && Math.abs(got - want) < 0.15;
        inp.style.background = ok ? '#e6ffed' : '#ffecec';
        okTables = okTables && ok;
      });
      c2.forEach((inp, idx)=>{
        const wantA = antecedentsOfGrid(st.grid, st.Ys[idx]).map(v=>Math.round(v*10)/10);
        const gotA = (String(inp.value||'').trim().toLowerCase()==='aucun') ? [] :
                     Array.from(new Set(String(inp.value||'').replace(/[()[\]{}]/g,'').split(/[;:,]/)
                     .map(s=>Number(s.replace(',', '.').replace(/\u2212/g,'-'))).filter(n=>!isNaN(n)).map(n=>Math.round(n*10)/10)));
        const ok = wantA.length===gotA.length && wantA.every(v=>gotA.some(u=>Math.abs(u-v)<=0.2));
        inp.style.background = ok ? '#e6ffed' : '#ffecec';
        okTables = okTables && ok;
      });
      const allOk = okDom && okTables;
      (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = (allOk ? '‚úî' : '‚úò');
      $('#res',host).textContent = okFlag ? (anyEmpty ? '' : '‚úî') : '‚úò';
    })();
      return {ok:allOk,total:1};
    };
    window.__patched_ex4 = true;
  }catch(e){}
})();
</script>

<script>
function checkDomainInput(str, xmin, xmax){
  try{
    if(str==null) return false;
    var s = String(str).replace(/\u00A0/g,' ').replace(/\u2212/g,'-');
    s = s.replace(/[\(\)\[\]]/g,'').replace(/\s+/g,'');
    var parts = s.split(/[;:,]/).filter(Boolean);
    if(parts.length!==2) return false;
    var a = parseFloat(parts[0].replace(',', '.'));
    var b = parseFloat(parts[1].replace(',', '.'));
    if(!isFinite(a) || !isFinite(b)) return false;
    return Math.abs(a - xmin) < 1e-9 && Math.abs(b - xmax) < 1e-9;
  }catch(e){ return false; }
}
</script>
</body>
</html>