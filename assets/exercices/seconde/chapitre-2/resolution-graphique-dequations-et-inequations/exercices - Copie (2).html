<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seconde ‚Äî Repr√©sentation graphique</title>

<!-- m√™mes d√©pendances que ton exemple -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">


<style>
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:12px 16px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:12px;box-shadow:0 1px 2px rgba(0,0,0,.04)}

  .controls{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .btn{padding:6px 10px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .row{display:grid;grid-template-columns:560px 1fr;gap:12px;align-items:start}
  .row.single{grid-template-columns:1fr}
  @media (max-width:980px){ .row{grid-template-columns:1fr} }

  .statement{font-size:18px}
  .consigne{opacity:.9;margin-bottom:6px}

  /* SVGs */
  svg.repere{display:block;margin:.25rem auto;width:min(560px,100%);height:auto;aspect-ratio:560/360}
  /* quand on ouvre la correction on r√©duit juste un peu pour √©viter ‚Äúrep√®res trop grands‚Äù */
  body.solution-active svg.repere{width:min(520px,100%)}

  .qa{display:grid;grid-template-columns:26px 1fr;gap:8px;align-items:start}
  .qmark{min-width:1.2em;text-align:center;font-weight:700}

  /* Espaces automatiques autour des nombres affich√©s */
  .num::before{content:" ";} .num::after{content:" ";}
  .input-wrap input[type="text"], .tbl input[type="text"]{margin:0 6px}

  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}

  .tbl{border-collapse:collapse;margin:.3rem 0;max-width:100%}
  .tbl th,.tbl td{border:1px solid #000;padding:3px 4px;text-align:center}
  .tbl input{width:6ch}

  /* Ex.5 ‚Äì tuiles */
  .mini-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:14px}
  @media (max-width:980px){ .mini-grid{grid-template-columns:repeat(2,minmax(0,1fr))} }
  @media (max-width:640px){ .mini-grid{grid-template-columns:1fr} }
  .mini{background:#fff;border:1px solid #e6e6e6;border-radius:10px;padding:8px;overflow:hidden}
  .mini .title{font-weight:600;margin-bottom:6px;text-align:center}
  .badge{display:inline-block;font-size:.8rem;border-radius:999px;padding:2px 8px;margin-left:6px}
  .ok{background:#e6f4ea;color:#14532d;border:1px solid #b7e0c2}
  .ko{background:#fee2e2;color:#991b1b;border:1px solid #f6b3b3}

  /* Ex.3 : labels plus visibles */
  svg.repere[data-heavylabels="1"] text{font-size:12.5px;font-weight:600}
  .thin-grid{opacity:.6}
  .heavy-grid{opacity:.78}

  @media print{ .tbl{border-collapse:collapse} .tbl th,.tbl td{border:1px solid #000 !important;padding:2px 6px} 
    .header,.controls{display:none !important}
    .wrap{max-width:100%}
    .card{border:none;box-shadow:none;padding:0}
    .row{grid-template-columns:1fr}
    svg.repere{height:auto}
  
  }

/* --- Hide interactive UI in PDF/print --- */
@media print {
  #themeSel { display:none !important; }
  select#themeSel { display:none !important; }
}


  .helper-line{ vector-effect: non-scaling-stroke; stroke-linecap: butt; }

/* Arrondir les extr√©mit√©s/joints de la courbe */
.plot path {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Traits d'aide, non d√©pendants du zoom */
.helper-line {
  vector-effect: non-scaling-stroke;
  stroke-linecap: butt;
}

<style media="print">
  /* R√©duit tous les SVG de courbe en PDF */
  .repere svg { width: 340px !important; height: 230px !important; }
  .repere text { font-size: 10pt !important; }
  .repere .grid line { stroke-width: .4 !important; }
  .repere .axis line, .repere .axis path { stroke-width: .8 !important; }
</style>

</style>
<style>

/* Widen columns for tables (notably Ex.4) */
.tbl { table-layout: auto; border-collapse: collapse; }
.tbl th, .tbl td { padding: 6px 10px; }
.tbl td { min-width: 120px; }


</style>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<script>

// Guard: limit antecedents selector to max 5 everywhere
(function(){
  const sel = document.getElementById('cfg-ant');
  if(sel){
    // If it's a number input
    if(sel.type === 'number'){
      if(!sel.max || parseInt(sel.max,10) > 5) sel.max = '5';
      if(parseInt(sel.value||'0',10) > 5) sel.value = '5';
    }
    // If it's a select, drop options >5 at runtime (in case of cached markup)
    if(sel.tagName === 'SELECT'){
      Array.from(sel.options).forEach(op=>{
        var v = parseInt(op.value,10);
        if(v>5) op.remove();
      });
      if(parseInt(sel.value||'0',10) > 5) sel.value = '5';
    }
  }
})();

</script>

  <div class="header">
    <h1 style="margin:0;font-size:1.05rem">Seconde ‚Äî <strong>Repr√©sentation graphique</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <!-- Amplitude pour Ex.1, 2, 4 -->
    <div class="controls card" id="ampbar">
      <strong>Amplitude (max ¬±12)&nbsp;:</strong>
      x ‚àà [&nbsp;<input id="xmin" type="number" value="-5" min="-12" max="12" step="1">&nbsp;;&nbsp;
      <input id="xmax" type="number" value="6"  min="-12" max="12" step="1">&nbsp;],
      y ‚àà [&nbsp;<input id="ymin" type="number" value="-6" min="-12" max="12" step="1">&nbsp;;&nbsp;
      <input id="ymax" type="number" value="6"  min="-12" max="12" step="1">&nbsp;]
      <button id="amp-apply" class="btn">‚Ü¥ Appliquer</button>

      <span style="margin-left:12px"></span>
      <label><small># images</small> <input id="cfg-img" type="number" min="1" max="10" value="2" style="width:64px"></label>
      <label class="small" style="margin-left:12px"><input id="pdfRandAmp" type="checkbox"> PDF : amplitude al√©atoire</label>
      <label class="small" style="margin-left:10px"><input id="pdfRandNA" type="checkbox"> PDF : nombre images al√©atoire</label>
      <label class="small" style="margin-left:10px"><input id="pdfRandTheme" type="checkbox"> PDF : th√®me al√©atoire (exo&nbsp;3)</label>
    </div>

    <div class="card" id="host"></div>
    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:8px 0 0 18px">
        <li><b>Ensemble de d√©finition</b> : format <span class="code">[a ; b]</span> ‚Äî ex. <span class="code">[‚àí6 ; 6]</span>. Espaces facultatifs¬†: <span class="code">[‚àí6;6]</span> accept√©.</li>
        <li><b>Image</b> (valeur de <span class="code">f(x)</span>) : nombre entier ou d√©cimal ‚Äî virgule <span class="code">2,5</span> ou point <span class="code">2.5</span> accept√©s ; signe ¬´ ‚àí ¬ª normalis√©.</li>
        <li><b>Ant√©c√©dent(s)</b> : liste s√©par√©e par points-virgules ‚Äî ex. ‚àí4 ; 0 ; 3. L‚Äôordre n‚Äôa pas d‚Äôimportance.</li>
      </ul>
    </div>


    <!-- emplacement UI PDF (identique √† l‚Äôexemple) -->
    <div class="card small" id="pdf-slot"></div>

        <!-- Clavier math, centr√© -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>

<!-- m√™mes libs que ton projet -->

<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js"></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>


<script>
(function(){
'use strict';

/* =================== Helpers & Format FR (virgule) =================== */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function uniq(arr,eq=(a,b)=>a===b){ const out=[]; arr.forEach(v=>{ if(!out.some(u=>eq(u,v))) out.push(v); }); return out; }
function shuffle(a){ a = Array.isArray(a) ? [...a] : []; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
const FRfmt = new Intl.NumberFormat('fr-FR',{maximumFractionDigits:2, useGrouping:false});
const fmtFR = n => FRfmt.format(n).replace('-', '‚àí');                // 1,5 et signe ‚àí
const fmtNum = n => `<span class="num">${fmtFR(n)}</span>`;          // espaces auto autour
const fmtUnit = (n,u)=> `${fmtNum(n)}&nbsp;${u||''}`;                 // espace ins√©cable entre nombre et unit√©
const parseNumFR = s => Number(String(s||'').replace(/\u2212/g,'-').replace(',','.').trim());
const parseListFR = s => !s ? [] : String(s).replace(/[{}()[\]]/g,'').split(/[;:,]/).map(parseNumFR).filter(Number.isFinite);
function MJ(el){ // re-typeset MathJax apr√®s injection
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}
/* ========= Amplitudes contr√¥lables (Exos 1,2,4) ========= */
let AMP={ xmin:-5,xmax:6,ymin:-6,ymax:6 };
function applyAMP(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  if(!(xi<=xa)) [xi,xa]=[xa,xi];
  if(!(yi<=ya)) [yi,ya]=[ya,yi];
  xi=clamp(xi,-12,12); xa=clamp(xa,-12,12);
  yi=clamp(yi,-12,12); ya=clamp(ya,-12,12);
  if(xi===xa) xa=xi+1; if(yi===ya) ya=yi+1;
  AMP={ xmin:xi,xmax:xa,ymin:yi,ymax:ya };
  document.body.classList.remove('solution-active');
  buildOne();
}

/* =================== Rep√®res =================== */
/* TOUTES LES GRADUATIONS coll√©es AUX AXES (y √† gauche de l‚Äôaxe ; x sous l‚Äôaxe) + fl√®ches */
let __clipId=0;
function buildRepereSVG(opts){
  const W0=560, H0=360; const mLeft=28, mTop=6, mRight=6, mBottom=24; const W=W0+mLeft+mRight, H=H0+mTop+mBottom;
  const xmin=opts.xmin, xmax=opts.xmax, ymin=opts.ymin, ymax=opts.ymax;

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.classList.add('repere');

  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const clip=document.createElementNS(svg.namespaceURI,'clipPath'); const cid='clip'+(++__clipId);
  clip.setAttribute('id',cid); const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',mLeft);
  crect.setAttribute('y',mTop);
  crect.setAttribute('width',W0);
  crect.setAttribute('height',H0); clip.appendChild(crect);
  const marker=document.createElementNS(svg.namespaceURI,'marker'); marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d','M0,0 L6,3 L0,6 Z'); tri.setAttribute('fill','#111'); marker.appendChild(tri);
  defs.appendChild(marker); defs.appendChild(clip); svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g'); const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot'); plot.setAttribute('clip-path','url(#'+cid+')'); svg.appendChild(axes); svg.appendChild(plot);

  const X=x=>mLeft + (x-xmin)*W0/(xmax-xmin);
  const Y=y=>mTop + H0 - (y-ymin)*H0/(ymax-ymin);

  // cadre
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',mLeft); frame.setAttribute('y',mTop); frame.setAttribute('width',W0); frame.setAttribute('height',H0);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); axes.appendChild(frame);
  // clipPath pour forcer l'affichage entier de la courbe dans le cadre
  frame.setAttribute('class','frame');
  const clipId = 'clip-'+Math.random().toString(36).slice(2);
  const cp=document.createElementNS(svg.namespaceURI,'clipPath'); cp.setAttribute('id',clipId);
  const r2=document.createElementNS(svg.namespaceURI,'rect');
  r2.setAttribute('x',mLeft); r2.setAttribute('y',mTop); r2.setAttribute('width',W0); r2.setAttribute('height',H0);
  cp.appendChild(r2); defs.appendChild(cp);
  plot.setAttribute('clip-path','url(#'+clipId+')');


  // axes -> positions ; clamp pour rester visibles pour les labels
  const yAxisY = clamp(Y(0), mTop+10, mTop+H0-10);
  const xAxisX = clamp(X(0), mLeft+10, mLeft+W0-10);

  // grille + labels coll√©s AUX AXES
  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7'); g.setAttribute('class','thin-grid');
    const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');

    const stepX=(opts.ticks && opts.ticks.x)||1;
    for(let xv=Math.ceil(xmin/stepX)*stepX; xv<=xmax+1e-9; xv+=stepX){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',0); l.setAttribute('x2',xx); l.setAttribute('y2',H); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(xv);
      t.setAttribute('x', clamp(xx, mLeft+14, mLeft+W0-14) );
      t.setAttribute('y', clamp(yAxisY+14, mTop+14, mTop+H0+12) );      // SOUS l‚Äôaxe des abscisses
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }

    const stepY=(opts.ticks && opts.ticks.y)||1;
    for(let yv=Math.ceil(ymin/stepY)*stepY; yv<=ymax+1e-9; yv+=stepY){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',0); l.setAttribute('y1',yy); l.setAttribute('x2',W); l.setAttribute('y2',yy); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(yv);
      t.setAttribute('x', clamp(xAxisX-6, mLeft+6, mLeft+W0-8) );        // √Ä GAUCHE de l‚Äôaxe des ordonn√©es
      t.setAttribute('y', clamp(yy+4, mTop+10, mTop+H0-6) );
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }

    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }

  // axes avec fl√®ches
  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',mLeft); axX.setAttribute('x2',mLeft+W0-8);
  axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY);
  axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','3'); if(opts.arrows){ axX.setAttribute('marker-end','url(#arrow)'); } axes.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX);
  axY.setAttribute('y1',mTop+H0); axY.setAttribute('y2',mTop+8);
  axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','3'); if(opts.arrows){ axY.setAttribute('marker-end','url(#arrow)'); } axes.appendChild(axY);

  return {svg,plot,axes,X,Y,xmin,xmax,ymin,ymax,W,H};
}

/* Rep√®re orthonorm√© (Ex.5) ‚Äî amplitude sym√©trique et quadrillage complet */
function buildRepereOrtho(opts){
  const W=560,H=360;
  const xmin=opts.xmin, xmax=opts.xmax, ymin=opts.ymin, ymax=opts.ymax;
  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox','0 0 560 360'); svg.classList.add('repere');

  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const marker=document.createElementNS(svg.namespaceURI,'marker'); marker.setAttribute('id','arrow_o'); marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d','M0,0 L6,3 L0,6 Z'); tri.setAttribute('fill','#111'); marker.appendChild(tri);
  defs.appendChild(marker); svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g'); const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot'); svg.appendChild(axes); svg.appendChild(plot);

  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',0); frame.setAttribute('y',0); frame.setAttribute('width',W); frame.setAttribute('height',H);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); axes.appendChild(frame);

  const sx=W/(xmax-xmin), sy=H/(ymax-ymin), s=Math.min(sx,sy);
  const cx=W/2, cy=H/2;
  const X=x=>cx + s*x, Y=y=>cy - s*y;

  const yAxisY = Y(0), xAxisX = X(0);

  // grille + labels (coll√©s aux axes)
  const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7'); g.setAttribute('class','heavy-grid');
  const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');
  const stepX=(opts.ticks&&opts.ticks.x)||1;
  for(let xv=Math.ceil(xmin/stepX)*stepX; xv<=xmax+1e-9; xv+=stepX){
    const xx=X(xv);
    const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',0); l.setAttribute('x2',xx); l.setAttribute('y2',H); g.appendChild(l);
    const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(xv);
    t.setAttribute('x', clamp(xx,14,W-14) ); t.setAttribute('y', clamp(yAxisY+14,14,H-4) );
    t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle'); tx.appendChild(t);
  }
  const stepY=(opts.ticks&&opts.ticks.y)||1;
  for(let yv=Math.ceil(ymin/stepY)*stepY; yv<=ymax+1e-9; yv+=stepY){
    const yy=Y(yv);
    const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',0); l.setAttribute('y1',yy); l.setAttribute('x2',W); l.setAttribute('y2',yy); g.appendChild(l);
    const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(yv);
    t.setAttribute('x', clamp(xAxisX-6,8,W-8) ); t.setAttribute('y', clamp(yy+4,10,H-6) );
    t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end'); ty.appendChild(t);
  }
  axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);

  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',0); axX.setAttribute('x2',W-8); axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY);
  axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','3'); axX.setAttribute('marker-end','url(#arrow_o)'); axes.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX); axY.setAttribute('y1',H); axY.setAttribute('y2',8);
  axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','3'); axY.setAttribute('marker-end','url(#arrow_o)'); axes.appendChild(axY);

  return {svg,plot,axes,X,Y,xmin,xmax,ymin,ymax,W,H};
}

/* ========== Courbes utilitaires (Ex.1/2/4) ========== */
function catmullRomPath(points){
  if(points.length<2) return '';
  const P=i=>points[Math.max(0,Math.min(points.length-1,i))];
  let d=`M ${points[0].x} ${points[0].y}`;
  for(let i=0;i<points.length-1;i++){
    const p0=P(i-1), p1=P(i), p2=P(i+1), p3=P(i+2);
    const c1x=p1.x+(p2.x-p0.x)/6, c1y=p1.y+(p2.y-p0.y)/6;
    const c2x=p2.x-(p3.x-p1.x)/6, c2y=p2.y-(p3.y-p1.y)/6;
    d+=` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
  }
  return d;
}
function addPath(g,d,st){ const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#000'); p.setAttribute('stroke-width',st?.['stroke-width']||2.2);
  if(st?.['stroke-dasharray']) p.setAttribute('stroke-dasharray',st['stroke-dasharray']);
  if(st?.['stroke-opacity']) p.setAttribute('stroke-opacity',st['stroke-opacity']);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
function addLine(g,x1,y1,x2,y2,st){ const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
  l.setAttribute('stroke',st?.stroke||'#000'); l.setAttribute('stroke-width',st?.['stroke-width']||2); if(st?.['stroke-dasharray']) l.setAttribute('stroke-dasharray',st['stroke-dasharray']); if(st?.['stroke-opacity']) l.setAttribute('stroke-opacity',st['stroke-opacity']);
  g.appendChild(l); return l; }

function genCurveIntegerGrid(R, forceCross=true){
  const xs=[], ys=[];
  for(let x=R.xmin; x<=R.xmax; x++){
    ys.push(rnd(R.ymin+1,R.ymax-1)); xs.push(x);
  }
  if(forceCross){
    ys[Math.floor(xs.length/4)]=rnd(-3,-1);
    ys[Math.floor(xs.length/2)]=rnd(1,3);
    ys[Math.floor(3*xs.length/4)]=rnd(-3,-1);
    if(xs.includes(0)) ys[xs.indexOf(0)]=rnd(R.ymin+1,R.ymax-1);
  }
  return { Xs: xs, Ys: ys };
}
// Interpolation cubique monotone (Fritsch‚ÄìCarlson) ‚Üí pas d'overshoot
function monotoneBezierPathXY(rep, xs, ys, ymin, ymax){
  const X=rep.X, Y=rep.Y, n=xs.length;
  if(n<2) return '';
  const h=new Array(n-1), s=new Array(n-1);
  for(let i=0;i<n-1;i++){ h[i]=xs[i+1]-xs[i]; s[i]=(ys[i+1]-ys[i])/h[i]; }

  const d=new Array(n);
  d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){
    if(s[i-1]*s[i] <= 0){ d[i]=0; }
    else{
      const w1 = 2*h[i] + h[i-1], w2 = h[i] + 2*h[i-1];
      d[i] = (w1+w2)/((w1/s[i-1]) + (w2/s[i]));   // tangente FC
    }
  }

  let dstr = `M ${X(xs[0])} ${Y(ys[0])}`;
  for(let i=0;i<n-1;i++){
    const x0=xs[i], x1=xs[i+1], y0=ys[i], y1=ys[i+1], hi=h[i];
    const c1x = X(x0 + hi/3), c1y = Y(Math.min(ymax, Math.max(ymin, y0 + d[i]   * hi/3)));
    const c2x = X(x1 - hi/3), c2y = Y(Math.min(ymax, Math.max(ymin, y1 - d[i+1] * hi/3)));
    dstr += ` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return dstr;
}


function buildGridWithConstraints(R, nbAnt, Yask){
  // Construit une grille enti√®re telle que, pour chaque y ‚àà Yask,
  // les seules solutions de f(x)=y soient des x entiers impos√©s.
  nbAnt = clamp(parseInt(nbAnt||1,10),1,10);
  const xs=[], ys=[];
  for(let x=R.xmin; x<=R.xmax; x++) xs.push(x);

  const YsAsk = (Yask||[]).filter(y=>Number.isFinite(y));
  const minY = Math.min(...YsAsk, R.ymax);
  const maxY = Math.max(...YsAsk, R.ymin);

  const roomBelow = (minY - (R.ymin+1)) >= 1;
  const roomAbove = ((R.ymax-1) - maxY) >= 1;

  let baselineRange;
  if(roomBelow){ baselineRange = [R.ymin+1, Math.floor(minY)-1]; }
  else if(roomAbove){ baselineRange = [Math.ceil(maxY)+1, R.ymax-1]; }
  else { baselineRange = [R.ymin+1, R.ymin+1]; }

  // baseline enti√®re, d'un seul c√¥t√© de tous les y demand√©s
  for(let i=0;i<xs.length;i++){
    const a = baselineRange[0], b = baselineRange[1];
    ys.push(a===b? a : rnd(a,b));
  }

  const taken = new Set();
  (YsAsk||[]).forEach(y=>{
    let k=0, guard=0;
    while(k<nbAnt && guard<5000){
      const x = rnd(R.xmin, R.xmax);
      guard++;
      const idx = x - R.xmin;
      const key = y+':'+idx;
      if(taken.has(key)) continue;
      taken.add(key);
      ys[idx] = y;
      if(idx>0 && ys[idx-1]===y) ys[idx-1] += (roomBelow? -1 : +1);
      if(idx<ys.length-1 && ys[idx+1]===y) ys[idx+1] += (roomBelow? -1 : +1);
      k++;
    }
  });

  return { Xs: xs, Ys: ys };
}
const pathFromGrid = (rep, grid) => {
  const pts = grid.Xs.map((x,i)=>({x:rep.X(x), y:rep.Y(grid.Ys[i])}));
  if(pts.length===0) return '';
  let d = 'M '+pts[0].x+' '+pts[0].y;
  for(let i=1;i<pts.length;i++){
    d += ' L '+pts[i].x+' '+pts[i].y;
  }
  return d;
};

const pathFromGridSmooth = (rep, grid) => {
  const X = rep.X, Y = rep.Y, Xs = grid.Xs, Ys = grid.Ys;
  const n = Xs.length; if(n < 2) return '';
  const forced = new Set((grid.Forced||[]).map(i=>i));

  // slopes on grid (h=1)
  const s = new Array(n-1);
  for(let i=0;i<n-1;i++) s[i] = Ys[i+1]-Ys[i];

  // Steffen-like monotone slopes with zero slope at extrema
  const d = new Array(n);
  d[0] = s[0]; d[n-1] = s[n-2];
  for(let i=1;i<n-1;i++){
    const s0=s[i-1], s1=s[i];
    if(s0*s1 <= 0){ d[i] = 0; }
    else{
      const a=Math.abs(s0), b=Math.abs(s1);
      d[i] = (Math.sign(s0)+Math.sign(s1)) * Math.min(a,b,0.5*(a+b));
    }
  }

  // soften globally and near forced points
  const scale = 0.60;
  for(let i=0;i<n;i++){
    if(forced.has(i)){
      d[i] = 0;
      if(i>0) d[i-1] *= 0.4;
      if(i<n-1) d[i+1] *= 0.4;
    } else {
      d[i] *= scale;
    }
  }

  // Hermite -> cubic B√©zier segments
  let dstr = `M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){
    const x0=Xs[i], x1=Xs[i+1], y0=Ys[i], y1=Ys[i+1], h=x1-x0; // h=1
    const c1x=X(x0 + h/3), c1y=Y(y0 + d[i]*h/3);
    const c2x=X(x1 - h/3), c2y=Y(y1 - d[i+1]*h/3);
    dstr += ` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return dstr;
};

function interpAtGrid(grid, x){
  const {Xs,Ys}=grid;
  if(x<Xs[0] || x> Xs[Xs.length-1]) return null;
  const i=Math.floor(x - Xs[0]);
  if(Math.abs(x - Math.round(x))<1e-9) return Ys[i];
  const k=Math.floor(x), idx=k - Xs[0];
  const y1=Ys[idx], y2=Ys[idx+1];
  return y1 + 0.5*(y2-y1);
}

function pickYsIntOrHalf(R, count){
  const vals=[];
  for(let y=R.ymin+1; y<=R.ymax-1; y++){
    vals.push(y);
    if(y+0.5 < R.ymax) vals.push(y+0.5);
  }
  return uniq(shuffle(vals)).slice(0,count);
}
function pickXsIntOrHalf(R, count){
  const vals=[];
  for(let x=R.xmin+1; x<=R.xmax-1; x++){
    vals.push(x);
    if(x+0.5 < R.xmax) vals.push(x+0.5);
  }
  return uniq(shuffle(vals)).slice(0,count);
}


function approxEqualList(found, expected, tol=0.2){
  if(found.length!==expected.length) return false;
  const F = found.slice().sort((a,b)=>a-b);
  const E = expected.slice().sort((a,b)=>a-b);
  for(let i=0;i<F.length;i++){
    if(Math.abs(F[i]-E[i])>tol) return false;
  }
  return true;
}

function antecedentsOfGrid(grid, y){
  const out=[];
  for(let i=0;i<grid.Xs.length-1;i++){
    const x1=grid.Xs[i], x2=grid.Xs[i+1], y1=grid.Ys[i], y2=grid.Ys[i+1];
    if(y===y1) out.push(x1);
    if(y===y2) out.push(x2);
    if((y1<y && y<y2) || (y2<y && y<y1)){
      const t=(y-y1)/((y2-y1)||1e-9); const x=x1+t*(x2-x1); out.push(x);
    }
  }
    // Snap x very close to integers to avoid tiny offsets (overlap with image helpers)
  const snapped = out.map(x => (Math.abs(x - Math.round(x)) < 1e-6 ? Math.round(x) : x));
  return uniq(snapped, (a,b)=>Math.abs(a-b)<1e-9);

}

/* ========== Vues g√©n√©riques ========== */
function mkRow(host,consigneHTML){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const st=document.createElement('div'); st.className='statement';
  st.innerHTML='<div class="consigne">'+(consigneHTML||'')+'</div>';
  const form=document.createElement('div'); form.className='input-wrap';
  const res=document.createElement('div'); res.id='res';
  row.appendChild(st); row.appendChild(form); row.appendChild(res);
  host.appendChild(row);
  try { __forceWordParenSpaces(form); __forceWordParenSpaces(st); } catch(e) {}
  return {row,st,form,res};
}
function showSteps(host, steps){   try{ let r=$('#res',host); if(!r){ r=document.createElement('div'); r.id='res'; host.appendChild(r);} }catch(e){}
$('#res',host).innerHTML = '<div class="steps">'+steps.map(s=>'<div class="step">'+s+'</div>').join('')+'</div>';
  try { __forceWordParenSpaces($('#res',host)); } catch(e) {} }
function clearMarks(host){ host.querySelectorAll('.qmark').forEach(m=>m.textContent=''); (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = ('');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })(); const plot=host.querySelector('.plot'); if(plot){ plot.querySelectorAll('line[stroke-dasharray]').forEach(n=>n.remove()); } }


function __forceWordParenSpaces(root){
  if(!root) return;
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  const reAfter = /(\))([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø])/g;
  const reBefore = /([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]{2,})(\()/g;
  let n;
  while((n = walker.nextNode())){
    const s = n.nodeValue;
    const t = s.replace(reAfter, '$1\u00A0$2').replace(reBefore, '$1\u00A0$2');
    if(t !== s) n.nodeValue = t;
  }
}
/* === Helpers manquants pour l‚Äôex.1 : courbe secondaire + petite √©tiquette === */

/* ===== Helpers Hermite (m√™mes pentes que pathFromGridSmooth) ===== */
/* ===== Slopes Hermite identiques au lissage ===== */
function _hermiteSlopes(Ys, forcedIdxSet, scale=0.55){
  const n=Ys.length, s=new Array(n-1), d=new Array(n);
  for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){
    const s0=s[i-1], s1=s[i];
    d[i]=(s0*s1<=0)?0:(Math.sign(s0)+Math.sign(s1))*Math.min(Math.abs(s0),Math.abs(s1),0.5*(Math.abs(s0)+Math.abs(s1)));
  }
  for(let i=0;i<n;i++){
    if(forcedIdxSet && forcedIdxSet.has(i)){
      d[i]=0; if(i>0) d[i-1]*=0.4; if(i<n-1) d[i+1]*=0.4;
    }else d[i]*=scale;
  }
  return d;
}

/* ===== Test ultra-strict : aucun z√©ro Bezier interne =====
   Sur [i,i+1], Œî(t) (en Bezier cubique) a des contr√¥les :
   B0 = Œîy0, B1 = Œîy0 + Œîm0/3, B2 = Œîy1 - Œîm1/3, B3 = Œîy1.
   Si B0..B3 ne sont pas tous du m√™me signe (en ignorant z√©ro aux extr√©mit√©s forc√©es), on REJette. */
function _noInteriorZeroBezier(YsF, YsG, forcedIdx){
  const n=YsF.length, Z=new Set(forcedIdx||[]);
  const dF=_hermiteSlopes(YsF,Z,0.55), dG=_hermiteSlopes(YsG,Z,0.55);

  const sameSign = (arr)=>{
    let s=0;
    for(const v of arr){
      if(v===0) continue;
      const sv=Math.sign(v);
      if(s===0) s=sv;
      else if(sv!==s) return false;
    }
    return s!==0; // au moins un strictement non nul
  };

  for(let i=0;i<n-1;i++){
    const endIsRoot = (Z.has(i)||Z.has(i+1));
    const dy0 = YsF[i]-YsG[i];
    const dy1 = YsF[i+1]-YsG[i+1];
    // Si extr√©mit√©s non forc√©es et signes oppos√©s, il y a d√©j√† une racine ‚Üí rejet
    if(!endIsRoot && dy0*dy1<0) return false;

    const dm0 = dF[i]-dG[i];
    const dm1 = dF[i+1]-dG[i+1];
    // Bezier controls of Œî
    const B0 = dy0;
    const B1 = dy0 + dm0/3;
    const B2 = dy1 - dm1/3;
    const B3 = dy1;

    // si tous m√™me signe (en ignorant les z√©ros), OK ; sinon ‚Üí racine possible ‚Üí rejet
    if(!sameSign([B0,B1,B2,B3])){
      // tol√®re z√©ro exactement au n≈ìud forc√© (contact entier), sinon on refuse
      // si un seul z√©ro ET il correspond √† B0 (i forc√©) ou B3 (i+1 forc√©) et le reste m√™me signe ‚Üí ok, sinon ko
      const zeros = [B0,B1,B2,B3].map((v,k)=>({k,v})).filter(o=>o.v===0).map(o=>o.k);
      const rest = [B0,B1,B2,B3].filter(v=>v!==0);
      const endsForced = (Z.has(i) && zeros.includes(0)) || (Z.has(i+1) && zeros.includes(3));
      if(!(endsForced && rest.length && rest.every(v=>Math.sign(v)===Math.sign(rest[0])))){
        return false; // on refuse large : plus d‚Äôintersections non enti√®res
      }
    }
  }
  return true;
}

function _evalHermite(Ys, d, i, t){ // t in [0,1]
  const y0=Ys[i], y1=Ys[i+1], m0=d[i], m1=d[i+1];
  const t2=t*t, t3=t2*t;
  const h00 =  2*t3 - 3*t2 + 1;
  const h10 =      t3 - 2*t2 + t;
  const h01 = -2*t3 + 3*t2;
  const h11 =      t3 -    t2;
  return h00*y0 + h10*m0 + h01*y1 + h11*m1;
}
/* contr√¥le robuste de l‚Äôabsence de croisement interne */
function _noInteriorCrossSmooth(YsF, YsG, forcedIdx){
  const n = YsF.length, Z=new Set(forcedIdx||[]);
  const dF=_hermiteSlopes(YsF,Z,0.55), dG=_hermiteSlopes(YsG,Z,0.55);
  for(let i=0;i<n-1;i++){
    if(Z.has(i)||Z.has(i+1)) continue;           // autoris√© : √©galit√© aux n≈ìuds
    const d0=YsF[i]-YsG[i], d1=YsF[i+1]-YsG[i+1];
    if(d0===0 || d1===0) continue;
    const s0=Math.sign(d0), s1=Math.sign(d1);
    if(s0*s1<0) return false;                    // d√©j√† oppos√©s aux extr√©mit√©s ‚Üí croisement certain
    for(let k=1;k<=7;k++){                       // √©chantillonnage interne (m√™me Hermite)
      const t=k/8;
      const diff=_evalHermite(YsF,dF,i,t)-_evalHermite(YsG,dG,i,t);
      if(Math.sign(diff) && Math.sign(diff)!==s0) return false;
    }
  }
  return true;
}

/* ====================== genSecondaryGrid ‚Äî V2 ====================== */
/**
 * Construit une grille enti√®re pour Cg, obtenue par translation (dx,dy) puis sym√©trie d‚Äôaxe des abscisses,
 * telle que Cf et Cg aient **exactement 2** intersections **sur des abscisses enti√®res**,
 * sans autre croisement entre deux entiers.
 *
 * @param {Object} R     {xmin,xmax,ymin,ymax}
 * @param {Object} main  {Xs, Ys} pour Cf (Xs entiers cons√©cutifs)
 * @param {Object} opts  {minK,maxK,preferK,maxDx,gapMin}
 */
function genSecondaryGrid(R, main, opts){
  opts = opts || {};
const n = main.Xs.length;
const maxDx = Math.min(Math.max(1, opts.maxDx ?? (n-2)), n-2);
  const gapMin0= opts.gapMin ?? 3;

  const Xs = main.Xs.slice();
  const YsF = main.Ys.slice();
  const yMinIn = R.ymin + 1, yMaxIn = R.ymax - 1;

  const buildYsG = (dx, dy)=>{
    const YsG = new Array(n);
    for(let i=0;i<n;i++){
      const j = (i - dx >= 0) ? (i - dx) : i;
      YsG[i] = -(YsF[j] + dy);
    }
    return YsG;
  };
  const countRootsInt = YsG => {
    const idx=[]; for(let i=0;i<n;i++) if(YsF[i]===YsG[i]) idx.push(i);
    return idx;
  };
  const inside = YsG => YsG.every(y => yMinIn <= y && y <= yMaxIn);
  const gapOK = (YsG, idxZero, gapMin)=>{
    const Z=new Set(idxZero);
    for(let i=0;i<n;i++){
      if(Z.has(i)) continue;
      if(Math.abs(YsF[i]-YsG[i]) < gapMin) return false;
    }
    return true;
  };
const validPair = (YsG, idx, gapMin)=>{
  if(idx.length!==2) return false;
  if(idx.some(i=>i<=0 || i>=n-1)) return false;
  if(idx[1]-idx[0] < 2) return false;
  if(!inside(YsG)) return false;
  if(!gapOK(YsG, idx, gapMin)) return false;
  if(!_noInteriorZeroBezier(YsF, YsG, idx)) return false;
  if(!_noInteriorCrossSmooth(YsF, YsG, idx)) return false;   // ‚Üê AJOUT
  return true;
};


  // 1) Strat√©gie ‚Äúsomme √©gale‚Äù
  const cands=[];
  for(let dx=1; dx<=Math.min(maxDx, n-1); dx++){
    const hist=new Map();
    for(let i=dx;i<n;i++){
      const s = YsF[i] + YsF[i-dx];
      (hist.get(s) || hist.set(s,[]), hist.get(s)).push(i);
    }
    for(const [Sval, idxs] of hist.entries()){
      if(idxs.length!==2) continue;
      const spacing = idxs[1]-idxs[0];
      cands.push({dx, Sval, idxs: idxs.slice(), spacing});
    }
  }
  cands.sort((a,b)=> (b.spacing!==a.spacing) ? b.spacing-a.spacing : a.dx-b.dx);

  for(const gapMin of [gapMin0, 2, 1]){
    for(const c of cands){
      const dy = -c.Sval;
      const YsG = buildYsG(c.dx, dy);
      if(validPair(YsG, c.idxs, gapMin)) return { Xs, Ys: YsG, Forced: c.idxs };
    }
  }

  // 2) Miroir y=c (dx=0)
  const hist = new Map();
  for(let i=0;i<n;i++){
    const s = 2*YsF[i];
    (hist.get(s) || hist.set(s,[]), hist.get(s)).push(i);
  }
  const mCands = Array.from(hist.entries())
    .filter(([,idxs]) => idxs.length===2)
    .map(([Sval, idxs])=>({ dy: -Sval, idxs: idxs.slice(), spacing: idxs[1]-idxs[0] }))
    .sort((a,b)=> b.spacing-a.spacing);

  for(const gapMin of [gapMin0, 2, 1]){
    for(const c of mCands){
      const YsG = YsF.map(y => -(y + c.dy));
      if(validPair(YsG, c.idxs, gapMin)) return { Xs, Ys: YsG, Forced: c.idxs };
    }
  }

  // 3) Balayage born√© (filet)
  for(const gapMin of [gapMin0, 2, 1]){
    for(let dx=1; dx<=Math.min(maxDx, n-1); dx++){
      const minDy = Math.max(...YsF.slice(dx).map(y=> -(y) - yMaxIn));
      const maxDy = Math.min(...YsF.slice(dx).map(y=> -(y) - yMinIn));
      for(let dy=minDy; dy<=maxDy; dy++){
        const YsG = buildYsG(dx, dy);
        const idx = countRootsInt(YsG);
        if(validPair(YsG, idx, gapMin)) return { Xs, Ys: YsG, Forced: idx };
      }
    }
  }

  // 4) Ultra-fallback
  for(let t=-6; t<=6; t++){
    const YsG = YsF.map(y => -(y + 2*t));
    const idx = countRootsInt(YsG);
    if(validPair(YsG, idx, 1)) return { Xs, Ys: YsG, Forced: idx };
  }

  const mid=Math.floor(n/2);
  const YsG = YsF.map(y => -y);
  const forced=[Math.max(1, mid-2), Math.min(n-2, mid+2)];
  return { Xs, Ys: YsG, Forced: forced };
}





/**
 * Ajoute un petit texte (ex: "Cf", "Cg") dans un <g> SVG.
 */
function addText(g, x, y, txt, style){
  const t=document.createElementNS(g.namespaceURI,'text');
  t.setAttribute('x', x); t.setAttribute('y', y);
  t.textContent = txt;
  if(style) for(const k in style){ t.setAttribute(k, style[k]); }
  t.setAttribute('font-size','13'); t.setAttribute('font-weight','700');
  g.appendChild(t);
  return t;
}



/* ========================== EXERCICE 1 ========================== */
const ex1 = {
  id:'rg1',
  title:`Lecture graphique (x entiers)`,
  gen(){
    const R={...AMP};

    // nombre de questions demand√© par les s√©lecteurs
    const qImg = clamp(parseInt($('#cfg-img')?.value||2,10),1,10);
    const qAnt = 3;

    // pools d'entiers visibles
    const Xpool=[]; for(let x=R.xmin+1; x<=R.xmax-1; x++) Xpool.push(x);
    const Ypool=[]; for(let y=R.ymin+1; y<=R.ymax-1; y++) Ypool.push(y);

    let grid=null, Ximg=null, Yimg=null, Ysolv=null, yNone=null, Yask=null;

    outer: for(let attempt=0; attempt<300; attempt++){
      // 1) base grid
      grid = genCurveIntegerGrid(R, true);

      // 2) IMAGES ‚Äî choisir qImg abscisses enti√®res telles que les images soient toutes distinctes
      let okImg=false;
      for(let t=0; t<200; t++){
        const xs = uniq(shuffle(Xpool)).slice(0,qImg).sort((a,b)=>a-b);
        const ys = xs.map(x=>interpAtGrid(grid,x));
        const uniqY = uniq(ys,(a,b)=>Math.abs(a-b)<1e-9);
        if (uniqY.length===ys.length){ Ximg=xs; Yimg=ys; okImg=true; break; }
      }
      if(!okImg) continue;

      // 3) ANT√âC√âDENTS ‚Äî on veut (qAnt-1) y avec 1..3 solutions enti√®res + 1 y inexistant
      const wantAntPerY =  Math.min(3, 3);
      let okAnt=false, gForced=null, ysChosen=[];

      for(let t=0; t<400; t++){
        const ysTry = uniq(shuffle(Ypool)).slice(0, Math.max(0,qAnt-1));
        gForced = buildGridWithConstraints(R, wantAntPerY, ysTry);
        const allOk = ysTry.every(y=>{
          const A = antecedentsOfGrid(gForced, y);
          const Ai = A.filter(x=>Math.abs(x - Math.round(x))<1e-9);
          const An = A.filter(x=>Math.abs(x - Math.round(x))>=1e-9);
          return Ai.length>=1 && Ai.length<=3 && An.length===0;
        });
        if(allOk){ ysChosen = ysTry; okAnt=true; break; }
      }
      if(!okAnt) continue;

      // y inexistant
      const zeroInside = Ypool.filter(y => !ysChosen.includes(y) && antecedentsOfGrid(gForced, y).length===0);
      yNone = zeroInside.length ? zeroInside[0] : (Math.random()<0.5 ? (R.ymax+1) : (R.ymin-1));

      grid = gForced;
      Ysolv = ysChosen;
      Yask = [...Ysolv, yNone];
      break outer;
    }

    return { R, grid, Ximg, Yask };
  },

  render(host,st){
    const ui = mkRow(host,'Lecture graphique.');
const rep = buildRepereSVG({ xmin:st.R.xmin, xmax:st.R.xmax, ymin:st.R.ymin, ymax:st.R.ymax, grid:true, arrows:true });

// Cf (liss√©e) ‚Äî on force la pente nulle aux n≈ìuds d‚Äôintersection
let gridG = st.gridG || (st.gridG = genSecondaryGrid(
  st.R, st.grid,
  { maxDx: 999, gapMin: 4 }   // ‚Üê √©cart vertical >= 4 hors n≈ìuds
));

const pathF = pathFromGridSmooth(rep, Object.assign({}, st.grid, { Forced: (gridG.Forced||[]) }));
const pathG = pathFromGridSmooth(rep, gridG);

// Dessin
addPath(rep.plot, pathF, { stroke:'#1f6feb', 'stroke-width':3.2 });                                 // Cf
addPath(rep.plot, pathG, { stroke:'#d62728', 'stroke-width':3.2, 'stroke-dasharray':'6 5' });       // Cg

addText(rep.axes, rep.X(st.R.xmin)+10, rep.Y(st.R.ymax)+20, 'Cf', {fill:'#1f6feb'});
addText(rep.axes, rep.X(st.R.xmin)+50, rep.Y(st.R.ymax)+20, 'Cg', {fill:'#d62728'});
 ui.st.appendChild(rep.svg);

  // √ânonc√© 100% LaTeX (y compris les nombres)
  let html = `
    <div class="qa">
      <div class="q">1.</div>
      <div class="a">Ensemble de d√©finition&nbsp;:&nbsp;<input id="aD" type="text"><span id="aDm" class="qmark"></span></div>
    </div>`;

  st.Ximg.forEach((x,i)=>{
    html += `
      <div class="qa">
        <div class="q">${i+2}.</div>
        <div class="a">Image de \\(${fmtFR(x)}\\)&nbsp;:&nbsp;<input id="aI${i}" type="text"><span id="aI${i}m" class="qmark"></span></div>
      </div>`;
  });

  st.Yask.forEach((y,j)=>{
    const k = 2 + st.Ximg.length + j;
    html += `
      <div class="qa">
        <div class="q">${k}.</div>
        <div class="a">Ant√©c√©dent(s) de \\(${fmtFR(y)}\\)&nbsp;:&nbsp;<input id="aA${j}" type="text"><span id="aA${j}m" class="qmark"></span></div>
      </div>`;
  });

  ui.form.innerHTML = html;

  // √âtat
  host.dataset.state = JSON.stringify(st);
  host.dataset.active = 'rg1';

  // Vider l‚Äôentr√©e du domaine
  (function(){ const aD = $('#aD',host); if (aD) aD.value=''; })();

  // === Couleurs inline compatibles LaTeX ===
  try{
    const paletteI = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e']; // images
    const paletteA = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f']; // ant√©c√©dents

    // Colorer ¬´ Image de \(x\) ¬ª en conservant le LaTeX
    if (Array.isArray(st.Ximg)) st.Ximg.forEach((x,i)=>{
      const input = host.querySelector('#aI'+i);
      if (!input || !input.parentElement) return;
      const a = input.parentElement;
      // motif EXACT tel qu‚Äô√©crit plus haut (avec &nbsp;)
      const needle = `Image de \\(${fmtFR(x)}\\)&nbsp;:`;
      const repl   = `Image de <span style="color:${paletteI[i%5]};font-weight:700">\\(${fmtFR(x)}\\)</span>&nbsp;:`;
      a.innerHTML = a.innerHTML.replace(needle, repl);
    });

    // Colorer ¬´ Ant√©c√©dent(s) de \(y\) ¬ª
    if (Array.isArray(st.Yask)) st.Yask.forEach((y,j)=>{
      const input = host.querySelector('#aA'+j);
      if (!input || !input.parentElement) return;
      const a = input.parentElement;
      const needle = `Ant√©c√©dent(s) de \\(${fmtFR(y)}\\)&nbsp;:`;
      const repl   = `Ant√©c√©dent(s) de <span style="color:${paletteA[j%5]};font-weight:700">\\(${fmtFR(y)}\\)</span>&nbsp;:`;
      a.innerHTML = a.innerHTML.replace(needle, repl);
    });
  }catch(e){ /* silencieux */ }

  // Typeset MathJax apr√®s injection et recoloration
  MJ(host);
  },

  solution(host,st){
    const rep = host.querySelector('svg.repere');
    const plot = rep.querySelector('.plot');
    const frame = rep.querySelector('rect.frame');
    const mLeft = +frame.getAttribute('x');
    const mTop  = +frame.getAttribute('y');
    const W0    = +frame.getAttribute('width');
    const H0    = +frame.getAttribute('height');
    const X = x => mLeft + (x - st.R.xmin) * W0 / (st.R.xmax - st.R.xmin);
    const Y = y => mTop + H0 - (y - st.R.ymin) * H0 / (st.R.ymax - st.R.ymin);

    const hasXaxis = (st.R.ymin <= 0 && 0 <= st.R.ymax);
    const hasYaxis = (st.R.xmin <= 0 && 0 <= st.R.xmax);

    // Traits d'aide (inchang√©)
    st.Ximg.forEach((x,i)=>{
      const col = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e'][i%5];
      const y  = interpAtGrid(st.grid, x);
      addLine(plot, X(x), Y(y), X(x), hasXaxis ? Y(0) : Y(st.R.ymin),
        { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-opacity': 0.95, 'class': 'helper-line' });
      addLine(plot, hasYaxis ? X(0) : X(st.R.xmin), Y(y), X(x), Y(y),
        { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-opacity': 0.95, 'class': 'helper-line' });
    });

    st.Yask.forEach((y,j)=>{
      const col = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f'][j%5];
      antecedentsOfGrid(st.grid, y).forEach(x=>{
        addLine(plot, X(x), Y(y), X(x), hasXaxis ? Y(0) : Y(st.R.ymin),
          { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-opacity': 0.95, 'class': 'helper-line' });
        addLine(plot, hasYaxis ? X(0) : X(st.R.xmin), Y(y), X(x), Y(y),
          { stroke: col, 'stroke-width': 2.6, 'stroke-dasharray': '6 5', 'stroke-opacity': 0.95, 'class': 'helper-line' });
      });
    });

    // √âtapes en LaTeX
    const steps = [
      `Ensemble de d√©finition : \\([${fmtFR(st.R.xmin)}\\; ;\\; ${fmtFR(st.R.xmax)}]\\)`
    ];

    st.Ximg.forEach(x=>{
      const fx = fmtFR(interpAtGrid(st.grid,x));
      steps.push(`\\( f(${fmtFR(x)}) = ${fx} \\)`);
    });

    st.Yask.forEach(y=>{
      const Aint = antecedentsOfGrid(st.grid,y)
        .filter(v=>Math.abs(v - Math.round(v))<1e-9)
        .map(v=>fmtFR(Math.round(v)));
      const rhs = Aint.length ? Aint.map(v=>`\\(${v}\\)`).join(' ; ') : 'aucun';
      steps.push(`Ant√©c√©dent(s) de \\(${fmtFR(y)}\\) : ${rhs}`);
    });

    showSteps(host, steps);
    MJ(host);
    document.body.classList.add('solution-active');
  },

  correct(host,st){
    clearMarks(host);
    let okAll=true;

    const v=$('#aD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
    const okDom=(v.length===2 && v[0]!=='' && v[1]!=='' ? (+v[0]===st.R.xmin && +v[1]===st.R.xmax) : true);
    $('#aDm',host).textContent = okDom?'‚úî':'‚úò'; $('#aDm',host).style.color=okDom?'#14532d':'#991b1b'; okAll&=okDom;

    st.Ximg.forEach((x,i)=>{
      const want=interpAtGrid(st.grid,x), got=parseInt($('#aI'+i,host).value.replace(/\u2212/g,'-').replace(',','.'),10);
      const ok=(String($('#aI'+i,host).value).trim()==='' ? true : (Number.isInteger(got)&&got===want));
      const m=$('#aI'+i+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });

    st.Yask.forEach((y,j)=>{
      const t=$('#aA'+j,host).value.trim().toLowerCase();
      const A=antecedentsOfGrid(st.grid,y).filter(v=>Math.abs(v-Math.round(v))<1e-9).map(v=>Math.round(v));
      let ok=false;
      if(!t || t==='aucun'){ ok=(A.length===0); }
      else{
        const L=uniq(parseListFR(t)).map(v=>Math.round(v));
        ok=(L.length===A.length) && L.every(v=>A.includes(v));
      }
      const m=$('#aA'+j+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });

    (function(){
      const anyEmpty = Array.from(host.querySelectorAll('input[type="text"]')).some(i=>i.value.trim()==='');
      const okFlag = true;
    })();

    return {ok:okAll,total:1};
  },

  reset(host){ host.querySelectorAll('input').forEach(i=>i.value=''); clearMarks(host); document.body.classList.remove('solution-active'); },

  pdfStatement(s){ return buildPDFStatementFromRender(ex1, s); }
};


/* ========== Registry & moteur ========== */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // expose for exo-pdf-kit
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host"), def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  
  // Adjust antecedents selector limit depending on exercise (rg2 & rg4 -> max 3, others -> max 5)
  try{
    const ant = document.getElementById('cfg-ant');
    if(ant){
      const maxVal = (def.id==='rg2' || def.id==='rg4') ? 3 : 5;
      ant.setAttribute('max', String(maxVal));
      if(ant.tagName === 'SELECT'){
        Array.from(ant.options).forEach(op=>{
          const v = parseInt(op.value,10);
          if(v>maxVal) op.remove();
        });
        if(parseInt(ant.value||'0',10) > maxVal) ant.value = String(maxVal);
      } else {
        if(parseInt(ant.value||'0',10) > maxVal) ant.value = String(maxVal);
      }
    }
  }catch(e){ console && console.warn && console.warn('cfg-ant adjust failed', e); }
const st=def.gen?def.gen():{};
  host.dataset.state=JSON.stringify(st); host.dataset.active=def.id;
  def.render(host,st); 
  (function(){ let r=$('#res',host); if(!r){ r=document.createElement('div'); r.id='res'; host.appendChild(r);} })();
  (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = ('');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })();
  document.body.classList.remove('solution-active');
}

function check(){
  const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  let okAll=true, total=0, okCount=0;

  function mark(id, ok){
    const m = host.querySelector('#'+id);
    if(!m) return;
    m.textContent = ok ? '‚úî' : '‚úò';
    m.style.color = ok ? '#14532d' : '#991b1b';
  }
  function isEmpty(v){ return !v || v.trim()===''; }
  function normToken(tok){
    return tok.replace(/\u00A0/g,' ')  // NBSP -> space
              .replace(/\u2212/g,'-')  // Unicode minus -> hyphen
              .replace(/\s+/g,' ')     // collapse spaces
              .trim();
  }

  if(def.id==='rg2'){
    // domain (ensemble de d√©finition)
    const dRaw = ($('#bD',host)?.value||'');
    const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++;
      const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('bDm', okD); okAll &= okD; if(okD) okCount++;
    }

    // images
    (st.Ximg||[]).forEach((x,i)=>{
      const raw = ($('#bI'+i,host)?.value||'');
      const t = normToken(raw);
      if(isEmpty(t)) return;
      total++;
      const v = Math.round(interpAtGrid(st.grid, x)*10)/10;
      const ans = t.replace(',', '.'); // allow decimal comma
      const ok = Math.abs(parseFloat(ans) - v) <= 0.2;
      mark('bI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // antecedents ‚Äî semicolon-separated only; accept 'aucun'
    (st.Yask||[]).forEach((y,j)=>{
      const raw = ($('#bA'+j,host)?.value||'');
      const t = normToken(raw).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseFloat(s.replace(',', '.')));
        ok = (L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      mark('bA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  } else if(def.id==='rg1'){
    // domaine
    const dRaw = ($('#aD',host)?.value||'');
    const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++;
      const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('aDm', okD); okAll &= okD; if(okD) okCount++;
    }
    // images
    (st.Ximg||[]).forEach((x,i)=>{
      const raw = ($('#aI'+i,host)?.value||'');
      const t = normToken(raw);
      if(isEmpty(t)) return;
      total++;
      const ok = (parseInt(t,10)===interpAtGrid(st.grid,x));
      mark('aI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // antecedents ‚Äî semicolon only; accept 'aucun'
    (st.Yask||[]).forEach((y,j)=>{
      const raw = ($('#aA'+j,host)?.value||'');
      const t = normToken(raw).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v));
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseInt(s,10));
        ok = (L.length===A.length) && L.every(v=>A.includes(v));
      }
      mark('aA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  } 
  else if (def.id === 'rg3') {
  // Q1 ‚Äî mots attendus (tol√©rance accents/majuscules/pluriels/espaces)
  const xVal = ($('#c1x',host)?.value || '');
  const yVal = ($('#c1y',host)?.value || '');
  const { okX, okY } = ex3_validateQ1(st.th.id, xVal, yVal);
  if (!isEmpty(xVal)) { total++; mark('c1xm', okX); okAll &= okX; if (okX) okCount++; }
  if (!isEmpty(yVal)) { total++; mark('c1ym', okY); okAll &= okY; if (okY) okCount++; }

  // Q2 ‚Äî images ENTIERES projet√©es sur la grille (tol√©rance = ¬Ω pas vertical)
  const t2a = ($('#c2a',host)?.value || '').trim();
  const t2b = ($('#c2b',host)?.value || '').trim();
  const yTol = 0.5 * st.stepY;
  const toNum = s => { const n = parseFloat(String(s).replace(',','.')); return Number.isFinite(n) ? n : NaN; };

  if (!isEmpty(t2a)) {
    total++;
    const av = toNum(t2a);
    const ok = Number.isFinite(av) && Math.abs(av - st.y1Int) <= yTol;
    mark('c2am', ok); okAll &= ok; if (ok) okCount++;
  }
  if (!isEmpty(t2b)) {
    total++;
    const bv = toNum(t2b);
    const ok = Number.isFinite(bv) && Math.abs(bv - st.y2Int) <= yTol;
    mark('c2bm', ok); okAll &= ok; if (ok) okCount++;
  }

  // Q3 ‚Äî ant√©c√©dents ENTIERs (√©galit√© d‚Äôensembles)
  const t3 = ($('#c3a',host)?.value || '').trim();
  if (!isEmpty(t3)) {
    total++;
    const typed = parseNumberList(t3).map(n => Math.round(n));
    const expected = st.rootsInt.map(n => Math.round(n));
    const setEq = (A,B) => {
      if (A.length !== B.length) return false;
      const SA = new Set(A), SB = new Set(B);
      for (const v of SA) if (!SB.has(v)) return false;
      return true;
    };
    const ok = typed.length > 0 && setEq(typed, expected);
    mark('c3am', ok); okAll &= ok; if (ok) okCount++;
  }
}

else if(def.id==='rg4'){
    // domain
    const dRaw = ($('#dD',host)?.value||''); const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++; const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('dDm', okD); okAll &= okD; if(okD) okCount++;
    }
    // table images (c1 / dI*)
    const fAt = x=>Math.round(interpAtGrid(st.grid,x)*10)/10;
    (st.Xs||[]).forEach((x,i)=>{
      const el = $('#dI'+i, host) || host.querySelectorAll('input.c1')[i];
      if(!el) return;
      const t = normToken(el.value);
      if(isEmpty(t)) return;
      total++;
      const ans = t.replace(',', '.');
      const ok = Math.abs(parseFloat(ans) - fAt(x)) <= 0.2;
      mark('dI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // table ant√©c√©dents (c2 / dA*) ‚Äî semicolon-only; accept 'aucun'
    (st.Ys||[]).forEach((y,j)=>{
      const el = $('#dA'+j, host) || host.querySelectorAll('input.c2')[j];
      if(!el) return;
      const t = normToken(el.value).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseFloat(s.replace(',', '.')));
        ok = (L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      mark('dA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  }

  // update global score (count only filled inputs)
  scoreTot += (total||1);
  scoreOK += (okCount||0);
  updateScore();
  document.body.classList.remove('solution-active');
}


function solution(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

/* ==== Init ==== */
document.addEventListener('DOMContentLoaded',()=>{
  $('#amp-apply').addEventListener('click',applyAMP);
  const sel=$("#exo-select"); REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change',buildOne);
  $("#btn-new").addEventListener('click', buildOne);      // Ex.3 : reste sur le th√®me courant
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  sel.value=REGISTRY[0].id; buildOne(); updateScore();
});
})();
</script>

<script>

// === Helper for PDF: build statement HTML exactly like screen, then freeze rep√®re size to screen width ===
function buildPDFStatementFromRender(def, st){
  const tmp=document.createElement('div');
  def.render(tmp, st);
  const stEl = tmp.querySelector('.statement') || tmp;
  // remove interactive controls if any
  stEl.querySelectorAll('select,button,.optionline,.controls').forEach(el=>el.remove());
  // keep questions: replace inputs with a small square
  stEl.querySelectorAll('input[type="text"]').forEach(inp=>{
    const span=document.createElement('span'); span.textContent='‚ñ¢';
    inp.replaceWith(span);
  });
  // lock SVG size to on-screen statement width (base design is 560px)
  const wScreen = (document.querySelector('.statement svg.repere')?.getBoundingClientRect().width) || 560;
  stEl.querySelectorAll('svg.repere').forEach(svg=>{
    svg.style.width = Math.round(wScreen) + 'px';
    svg.style.height = 'auto';
    svg.style.maxWidth = 'none';
    svg.style.display = 'block';
    svg.style.margin = '.25rem auto';
  });
  return stEl.outerHTML;
}
</script>

<script>
/* ==== PDF ‚Äî Ex.1‚Üí4 : √ânonc√© 2 colonnes ; Ex.4 : tables sans inputs ==== */
window.addEventListener('load', function () {
  if (!(window.ExoPDF && ExoPDF.init)) return;

  ExoPDF.init({
    title: `Seconde ‚Äî Repr√©sentation graphique`,
    max: 50,
    lead: '',
    leadByDefId: { rg1:'', rg2:'', rg3:'', rg4:'', rg5:'' },
    mountAfterSelector: '.card.small',

    beforeRender(def, st, withSolutions){
      try{
        const isTarget = def && ['rg1','rg2','rg3','rg4'].includes(def.id);

        const mkTmp = () => {
          const tmp = document.createElement('div');
          Object.assign(tmp.style, { position:'fixed', left:'-10000px', top:'-10000px', width:'0', height:'0', overflow:'hidden' });
          document.body.appendChild(tmp);
          return tmp;
        };

        const freezeSVG = (root)=>{
          const wRef = (document.querySelector('.statement svg.repere')?.getBoundingClientRect().width) || 560;
          root.querySelectorAll('svg.repere').forEach(svg=>{
            svg.style.width = Math.round(wRef) + 'px';
            svg.style.height = 'auto';
            svg.style.maxWidth = 'none';
            svg.style.display = 'block';
            svg.style.margin = '.25rem auto';
          });
        };

  const TABLE_STYLE = `
  <style>
    /* Grille √©nonc√© en 2 colonnes */
    table.pdf-two-col{ width:100%; border-collapse:collapse; table-layout:fixed; }
    table.pdf-two-col th, table.pdf-two-col td{
      border:1px solid #000; vertical-align:top; padding:6px 8px;
    }
    .pdf-curves{ text-align:center; }

    /* Largeurs par d√©faut (Ex.1‚Äì3) */
    table.pdf-two-col col.curves{ width:42%; }
    table.pdf-two-col col.enonce{ width:58%; }

    /* Sp√©cifique Ex.4 (d√©j√† en place) */
    table.pdf-two-col.ex4 col.curves{ width:35%; }
    table.pdf-two-col.ex4 col.enonce{ width:65%; }

    /* ‚úÖ Tous exos : les courbes remplissent la colonne (√©cran + impression) */
    .pdf-curves svg.repere{
      width:100% !important;
      height:auto !important;
      max-width:100% !important;
      box-sizing:border-box;
      display:block;
      margin:.25rem auto;
    }
    @media print{
      .pdf-curves svg.repere{
        width:100% !important; height:auto !important; max-width:100% !important;
      }
    }

    /* Bordures noires pour tous les tableaux */
    .tbl{ border-collapse:collapse !important; }
    .tbl th,.tbl td{ border:1px solid #000 !important; }

    /* Ex.4 : tables plein-largeur dans la colonne (comme d√©j√† souhait√©) */
    table.pdf-two-col.ex4 .pdf-enonce .tbl{
      width:100% !important; table-layout:auto; font-size:12px;
    }
    table.pdf-two-col.ex4 .pdf-enonce .tbl th,
    table.pdf-two-col.ex4 .pdf-enonce .tbl td{
      padding:4px 6px; min-width:0; word-break:break-word;
    }
    table.pdf-two-col.ex4 .pdf-enonce .tbl-wrap{ transform:none !important; }
	table.pdf-two-col.ex4 .pdf-enonce .tbl-wrap{
    display: flex;               /* empile les tableaux verticalement */
    flex-direction: column;
    gap: 12px;                   /* ‚Üê espace entre les tableaux (ajuste si besoin) */
  }

  /* Fallback au cas o√π le wrapper ne serait pas pr√©sent */
  table.pdf-two-col.ex4 .pdf-enonce .tbl + .tbl{
    margin-top: 12px !important;
  }
  .pdf-solution .tbl{
    width:100% !important;
    max-width:100% !important;
    table-layout:auto;          /* laisse les colonnes s'√©tirer naturellement */
    font-size:14px;             /* ‚Üê agrandit le texte des tableaux en correction */
    border-collapse:collapse !important;
  }
  .pdf-solution .tbl th,
  .pdf-solution .tbl td{
    border:1px solid #000 !important;
    padding:6px 10px;           /* un peu plus d‚Äôair */
    min-width:0;                /* √©vite les d√©bordements */
    word-break:break-word;
  }

  /* Ex.4 seulement : titres un poil plus visibles dans la correction */
  .pdf-solution .tbl th{ font-weight:700; }
  </style>`;

const TILES_STYLE_RG5 = `
  <style>
    table.pdf-tiles { width:100%; border-collapse:collapse; table-layout:fixed; }
    table.pdf-tiles td { width:33.333%; border:1px solid #000; padding:8px; vertical-align:top; }
    .pdf-tiles .tile .title { text-align:center; font-weight:600; margin-bottom:6px; }
    .pdf-tiles svg.repere { width:100% !important; height:auto !important; display:block; margin:0 auto; }
    .pdf-tiles .tile.empty { min-height:120px; }
  </style>`;
        // supprime toutes les saisies (partout dans un sous-arbre)
        const stripInputs = (root)=>{
          root.querySelectorAll('input, textarea, select, button').forEach(n=>n.remove());
          root.querySelectorAll('.qmark').forEach(n=>n.remove());
        };
if (def && def.id === 'rg5') {
  const mkTmp = () => { const t=document.createElement('div'); Object.assign(t.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',overflow:'hidden'}); document.body.appendChild(t); return t; };

  const tmp = mkTmp();
  if (typeof def.render === 'function') def.render(tmp, st);
  if (withSolutions && typeof def.solution === 'function') { try{ def.solution(tmp, st); }catch(_){} }

  const minis = Array.from(tmp.querySelectorAll('.mini')).slice(0,5);

  const tileHTML = (miniEl)=>{
    const c = miniEl.cloneNode(true);
    const yn = c.querySelector('.yesno'); if (yn) (yn.closest('div') || yn).remove();
    const svg = c.querySelector('svg.repere'); if (svg){ svg.removeAttribute('width'); svg.removeAttribute('height'); svg.style.width='100%'; svg.style.height='auto'; }
    const title = c.querySelector('.title') ? c.querySelector('.title').outerHTML : '';
    const svgHTML = svg ? svg.outerHTML : '';
    return `<div class="tile">${title}${svgHTML}</div>`;
  };

  const cells = minis.map(tileHTML);
  while (cells.length < 6) cells.push('<div class="tile empty"></div>');

  const rows = `
    <tr>${cells.slice(0,3).map(h=>`<td>${h}</td>`).join('')}</tr>
    <tr>${cells.slice(3,6).map(h=>`<td>${h}</td>`).join('')}</tr>
  `;

  const tableHTML = `
    ${TILES_STYLE_RG5}
    <table class="pdf-tiles"><tbody>${rows}</tbody></table>
  `;

  const QUESTION_RG5 = `<div class="pdf-q">Pour chaque courbe, dire si elle repr√©sente une fonction.</div>`;

  tmp.remove();
  return withSolutions
    ? { solution: tableHTML }                       // corrig√© : m√™me grille, droites & badges d√©j√† trac√©s
    : { statement: QUESTION_RG5 + tableHTML };     // √©nonc√© : ajoute la question au-dessus
}
        if (!withSolutions && isTarget){
          // ===== √âNONC√â =====
          const tmp = mkTmp();
          if (typeof def.render==='function') def.render(tmp, st);

          // Colonne COURBES
          freezeSVG(tmp);
          const svgs = Array.from(tmp.querySelectorAll('.statement svg.repere, svg.repere'));
          // ‚úÖ Rendre les SVG responsive (√©crase largeur/hauteur fig√©es)
svgs.forEach(s=>{
  s.removeAttribute('width');
  s.removeAttribute('height');
  s.style.width = '100%';
  s.style.height = 'auto';
});
const curvesHTML = svgs.map(s=>s.outerHTML).join('');


          // Colonne √âNONC√â
          const right = document.createElement('div');

          // consigne
          const cons = tmp.querySelector('.consigne');
          if (cons) right.appendChild(cons.cloneNode(true));

          // EXERCICE 4 : cloner les tableaux ET ENLEVER LES INPUTS √† l'int√©rieur
          if (def.id==='rg4'){
            const wrap = document.createElement('div');
            tmp.querySelectorAll('.tbl').forEach(t => {
              const clone = t.cloneNode(true);
              // ‚ö†Ô∏è suppression totale des champs dans les cellules des tableaux
              clone.querySelectorAll('input, textarea, select, button').forEach(n=>n.remove());
              clone.querySelectorAll('.qmark').forEach(n=>n.remove());
              wrap.appendChild(clone);
            });
            // bloc pour mise √† l‚Äô√©chelle si besoin (CSS d√©j√† d√©fini)
            wrap.className = 'tbl-wrap';
            right.appendChild(wrap);
          }

          // questions (sans champs)
          const form = tmp.querySelector('.input-wrap');
          if (form){
            const clone = form.cloneNode(true);
            stripInputs(clone);
            right.appendChild(clone);
          }

          // Ex.3 : retirer le s√©lecteur de th√®me
          if (def.id === 'rg3') {
            right.querySelectorAll('#themeSel, select').forEach(n => n.remove());
          }

          const isEx4 = def.id==='rg4';
          const colgroup = isEx4 ? `<colgroup><col class="curves"><col class="enonce"></colgroup>` : '';
          const tableClass = 'pdf-two-col' + (isEx4 ? ' ex4' : '');

          const statementHTML = `
            ${TABLE_STYLE}
            <table class="${tableClass}">
              ${colgroup}
              <thead><tr><th>Courbes</th><th>√ânonc√©</th></tr></thead>
              <tbody>
                <tr>
                  <td class="pdf-curves">${curvesHTML||''}</td>
                  <td class="pdf-enonce">${right.innerHTML||''}</td>
                </tr>
              </tbody>
            </table>`;

          tmp.remove();
          return { statement: statementHTML };
        }

        if (withSolutions && isTarget){
          // ===== CORRIG√â : uniquement les √©tapes, sans courbes ni √©nonc√© =====
          const tmp = mkTmp();
          if (typeof def.render==='function') def.render(tmp, st);
          if (typeof def.solution==='function') def.solution(tmp, st);

          const steps = tmp.querySelector('.steps') || tmp.querySelector('.solution') || tmp.querySelector('#res') || tmp;
          const out = document.createElement('div');
          out.innerHTML = steps.outerHTML || steps.innerHTML;

          stripInputs(out);
          out.querySelectorAll('svg.repere').forEach(n=>n.remove());
          out.querySelectorAll('.tbl').forEach(t=>{
            t.style.borderCollapse = 'collapse';
            t.querySelectorAll('th,td').forEach(c=>{ c.style.border = '1px solid #000'; });
          });

          const solHTML = TABLE_STYLE + out.innerHTML;
          tmp.remove();
return { solution: TABLE_STYLE + '<div class="pdf-solution">' + solHTML + '</div>' };
        }

        // ===== Fallback autres exos =====
        const tmp = mkTmp();
        if (typeof def.render==='function') def.render(tmp, st);

        if (!withSolutions){
          stripInputs(tmp); freezeSVG(tmp);
          const html = tmp.innerHTML; tmp.remove();
          return { statement: html };
        }else{
          if (typeof def.solution==='function') def.solution(tmp, st);
          const steps = tmp.querySelector('.steps') || tmp;
          const out = document.createElement('div');
          out.innerHTML = steps.outerHTML || steps.innerHTML;
          stripInputs(out);
          out.querySelectorAll('.tbl').forEach(t=>{
            t.style.borderCollapse='collapse';
            t.querySelectorAll('th,td').forEach(c=>{ c.style.border='1px solid #000'; });
          });
          const html = TABLE_STYLE + out.innerHTML;
          tmp.remove();
return { solution: TABLE_STYLE + '<div class="pdf-solution">' + solHTML + '</div>' };
        }
      }catch(e){ /* fallback g√©r√© par le kit */ }
    },

    // (inchang√©) al√©as / amplitude / th√®mes
    beforeGen(def, st, ctx){
      try{
        const ampRnd = document.getElementById('pdfRandAmp')?.checked;
        const naRnd  = document.getElementById('pdfRandNA')?.checked;

        const xminEl=document.getElementById('xmin'), xmaxEl=document.getElementById('xmax');
        const yminEl=document.getElementById('ymin'), ymaxEl=document.getElementById('ymax');
        const imgEl = document.getElementById('cfg-img'), antEl=document.getElementById('cfg-ant');

        const thRnd = document.getElementById('pdfRandTheme')?.checked;
        if(def && def.id==='rg3'){
          if(thRnd){ window.__rg3_last_theme = null; }
          else{
            const sel = document.getElementById('themeSel');
            if(sel){ window.__rg3_last_theme = sel.value; }
          }
        }

        const save = {
          AMP: {...AMP},
          xmin: xminEl && xminEl.value, xmax: xmaxEl && xmaxEl.value,
          ymin: yminEl && yminEl.value, ymax: ymaxEl && ymaxEl.value,
          img: imgEl && imgEl.value, ant: antEl && antEl.value
        };

        const seed = (ctx && (ctx.index||0)) * 2654435761 ^ Date.now();
        let t = Math.imul(1779033703 ^ seed, 3432918353); t=(t<<13)|(t>>>19);
        function rng(){ t=Math.imul(t^(t>>>16),2246822507); t=Math.imul(t^(t>>>13),3266489909); t^=t>>>16; return (t>>>0)/4294967296; }
        function ri(a,b){ return a + Math.floor(rng()*(b-a+1)); }

        if (ampRnd){
          const xi = ri(-12, -2), xa = ri(2, 12);
          const yi = ri(-12, -2), ya = ri(2, 12);
          AMP = { xmin: Math.min(xi,xa), xmax: Math.max(xi,xa), ymin: Math.min(yi,ya), ymax: Math.max(yi,ya) };
          if (xminEl) xminEl.value = AMP.xmin;
          if (xmaxEl) xmaxEl.value = AMP.xmax;
          if (yminEl) yminEl.value = AMP.ymin;
          if (ymaxEl) yminEl.value = AMP.ymin;
        }

        if (naRnd && (def && (def.id==='rg1' || def.id==='rg2' || def.id==='rg4'))){
          const rImg = ri(2,10), rAnt = ri(2,10);
          if (imgEl) imgEl.value = String(rImg);
          if (antEl) antEl.value = String(rAnt);
        }

        return function restore(){
          AMP = save.AMP;
          if (xminEl) xminEl.value = save.xmin;
          if (xmaxEl) xmaxEl.value = save.xmax;
          if (yminEl) yminEl.value = save.ymin;
          if (ymaxEl) ymaxEl.value = save.ymax;
          if (imgEl) imgEl.value = save.img;
          if (antEl) antEl.value = save.ant;
        };
      }catch(e){ /* silent */ }
    }
  });
});
</script>





<script>
(function(){
  if(window.__patched_ex4) return;
  try{
    ex4.correct = function(host, st){
      const v=$('#dD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
      const okDom=(v.length===2 && +v[0]===st.R.xmin && +v[1]===st.R.xmax);
      $('#dDm',host).textContent = okDom?'‚úî':'‚úò';
      $('#dDm',host).style.color=okDom?'#14532d':'#991b1b';
      const c1 = Array.from(host.querySelectorAll('table input.c1'));
      const c2 = Array.from(host.querySelectorAll('table input.c2'));
      let okTables = true;
      c1.forEach((inp, idx)=>{
        const want = Math.round(interpAtGrid(st.grid, st.Xs[idx]) * 10)/10;
        const got  = Number(String(inp.value).replace(',', '.').replace(/\u2212/g,'-'));
        const ok = Number.isFinite(got) && Math.abs(got - want) < 0.15;
        inp.style.background = ok ? '#e6ffed' : '#ffecec';
        okTables = okTables && ok;
      });
      c2.forEach((inp, idx)=>{
        const wantA = antecedentsOfGrid(st.grid, st.Ys[idx]).map(v=>Math.round(v*10)/10);
        const gotA = (String(inp.value||'').trim().toLowerCase()==='aucun') ? [] :
                     Array.from(new Set(String(inp.value||'').replace(/[()[\]{}]/g,'').split(/[;:,]/)
                     .map(s=>Number(s.replace(',', '.').replace(/\u2212/g,'-'))).filter(n=>!isNaN(n)).map(n=>Math.round(n*10)/10)));
        const ok = wantA.length===gotA.length && wantA.every(v=>gotA.some(u=>Math.abs(u-v)<=0.2));
        inp.style.background = ok ? '#e6ffed' : '#ffecec';
        okTables = okTables && ok;
      });
      const allOk = okDom && okTables;
      (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = (allOk ? '‚úî' : '‚úò');
      $('#res',host).textContent = okFlag ? (anyEmpty ? '' : '‚úî') : '‚úò';
    })();
      return {ok:allOk,total:1};
    };
    window.__patched_ex4 = true;
  }catch(e){}
})();
</script>
<script>
function checkDomainInput(str, xmin, xmax){
  try{
    if(str==null) return false;
    var s = String(str).replace(/\u00A0/g,' ').replace(/\u2212/g,'-');
    s = s.replace(/[\(\)\[\]]/g,'').replace(/\s+/g,'');
    var parts = s.split(/[;:,]/).filter(Boolean);
    if(parts.length!==2) return false;
    var a = parseFloat(parts[0].replace(',', '.'));
    var b = parseFloat(parts[1].replace(',', '.'));
    if(!isFinite(a) || !isFinite(b)) return false;
    return Math.abs(a - xmin) < 1e-9 && Math.abs(b - xmax) < 1e-9;
  }catch(e){ return false; }
}
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on d√©clenche .click() sur eux)
[['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l‚Äôoriginal est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s‚Äôouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>