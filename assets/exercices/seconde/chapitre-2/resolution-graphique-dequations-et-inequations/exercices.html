<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seconde ‚Äî Repr√©sentation graphique</title>

<!-- m√™mes d√©pendances que ton exemple -->
<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">


<style>
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:12px 16px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px}
  .card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:12px;box-shadow:0 1px 2px rgba(0,0,0,.04)}

  .controls{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .btn{padding:6px 10px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}

  .row{display:grid;grid-template-columns:560px 1fr;gap:12px;align-items:start}
  .row.single{grid-template-columns:1fr}
  @media (max-width:980px){ .row{grid-template-columns:1fr} }

  .statement{font-size:18px}
  .consigne{opacity:.9;margin-bottom:6px}

  /* SVGs */
  svg.repere{display:block;margin:.25rem auto;width:min(560px,100%);height:auto;aspect-ratio:560/360}
  /* quand on ouvre la correction on r√©duit juste un peu pour √©viter ‚Äúrep√®res trop grands‚Äù */
  body.solution-active svg.repere{width:min(520px,100%)}

  .qa{display:grid;grid-template-columns:26px 1fr;gap:8px;align-items:start}
  .qmark{min-width:1.2em;text-align:center;font-weight:700}

  /* Espaces automatiques autour des nombres affich√©s */
  .num::before{content:" ";} .num::after{content:" ";}
  .input-wrap input[type="text"], .tbl input[type="text"]{margin:0 6px}

  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
  .step{margin:.2rem 0}

  .tbl{border-collapse:collapse;margin:.3rem 0;max-width:100%}
  .tbl th,.tbl td{border:1px solid #000;padding:3px 4px;text-align:center}
  .tbl input{width:6ch}

  /* Ex.5 ‚Äì tuiles */
  .mini-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:14px}
  @media (max-width:980px){ .mini-grid{grid-template-columns:repeat(2,minmax(0,1fr))} }
  @media (max-width:640px){ .mini-grid{grid-template-columns:1fr} }
  .mini{background:#fff;border:1px solid #e6e6e6;border-radius:10px;padding:8px;overflow:hidden}
  .mini .title{font-weight:600;margin-bottom:6px;text-align:center}
  .badge{display:inline-block;font-size:.8rem;border-radius:999px;padding:2px 8px;margin-left:6px}
  .ok{background:#e6f4ea;color:#14532d;border:1px solid #b7e0c2}
  .ko{background:#fee2e2;color:#991b1b;border:1px solid #f6b3b3}

  /* Ex.3 : labels plus visibles */
  svg.repere[data-heavylabels="1"] text{font-size:12.5px;font-weight:600}
  .thin-grid{opacity:.6}
  .heavy-grid{opacity:.78}

  @media print{ .tbl{border-collapse:collapse} .tbl th,.tbl td{border:1px solid #000 !important;padding:2px 6px} 
    .header,.controls{display:none !important}
    .wrap{max-width:100%}
    .card{border:none;box-shadow:none;padding:0}
    .row{grid-template-columns:1fr}
    svg.repere{height:auto}
  
  }

/* --- Hide interactive UI in PDF/print --- */
@media print {
  #themeSel { display:none !important; }
  select#themeSel { display:none !important; }
}


  .helper-line{ vector-effect: non-scaling-stroke; stroke-linecap: butt; }

/* Arrondir les extr√©mit√©s/joints de la courbe */
.plot path {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Traits d'aide, non d√©pendants du zoom */
.helper-line {
  vector-effect: non-scaling-stroke;
  stroke-linecap: butt;
}
</style>
<style media="print">
  /* R√©duit tous les SVG de courbe en PDF */
  .repere svg { width: 340px !important; height: 230px !important; }
  .repere text { font-size: 10pt !important; }
  .repere .grid line { stroke-width: .4 !important; }
  .repere .axis line, .repere .axis path { stroke-width: .8 !important; }
</style>


<style>

/* Widen columns for tables (notably Ex.4) */
.tbl { table-layout: auto; border-collapse: collapse; }
.tbl th, .tbl td { padding: 6px 10px; }
.tbl td { min-width: 120px; }

/* fond des √©tiquettes : plus opaque √† l'impression */
@media print {
  .label-bg { fill-opacity: 1 !important; }
}

</style>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
<script>

// Guard: limit antecedents selector to max 5 everywhere
(function(){
  const sel = document.getElementById('cfg-ant');
  if(sel){
    // If it's a number input
    if(sel.type === 'number'){
      if(!sel.max || parseInt(sel.max,10) > 5) sel.max = '5';
      if(parseInt(sel.value||'0',10) > 5) sel.value = '5';
    }
    // If it's a select, drop options >5 at runtime (in case of cached markup)
    if(sel.tagName === 'SELECT'){
      Array.from(sel.options).forEach(op=>{
        var v = parseInt(op.value,10);
        if(v>5) op.remove();
      });
      if(parseInt(sel.value||'0',10) > 5) sel.value = '5';
    }
  }
})();

</script>

  <div class="header">
    <h1 style="margin:0;font-size:1.05rem">Seconde ‚Äî <strong>Repr√©sentation graphique</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <!-- Amplitude pour Ex.1, 2, 4 -->
    <div class="controls card" id="ampbar">
      <strong>Amplitude (max ¬±12)&nbsp;:</strong>
      x ‚àà [&nbsp;<input id="xmin" type="number" value="-5" min="-12" max="12" step="1">&nbsp;;&nbsp;
      <input id="xmax" type="number" value="6"  min="-12" max="12" step="1">&nbsp;],
      y ‚àà [&nbsp;<input id="ymin" type="number" value="-6" min="-12" max="12" step="1">&nbsp;;&nbsp;
      <input id="ymax" type="number" value="6"  min="-12" max="12" step="1">&nbsp;]
      <button id="amp-apply" class="btn">‚Ü¥ Appliquer</button>

      <span style="margin-left:12px"></span>
      <label><small># images</small> <input id="cfg-img" type="number" min="1" max="10" value="2" style="width:64px"></label>
      <label class="small" style="margin-left:12px"><input id="pdfRandAmp" type="checkbox"> PDF : amplitude al√©atoire</label>
      <label class="small" style="margin-left:10px"><input id="pdfRandNA" type="checkbox"> PDF : nombre images al√©atoire</label>
      <label class="small" style="margin-left:10px"><input id="pdfRandTheme" type="checkbox"> PDF : th√®me al√©atoire (exo&nbsp;3)</label>
    </div>

    <div class="card" id="host"></div>
    <div class="card small">
      <strong>Saisie & r√©ponses accept√©es :</strong>
      <ul style="margin:8px 0 0 18px">
	          <li><b>ATTENTION : Le fichier n'est pas stable : il y a souvent des courbes non utilisables. Il faut alors appeler un nouvel √©nonc√©.</b></li>
        <li><b>Ensemble de d√©finition</b> : format <span class="code">[a ; b]</span> ‚Äî ex. <span class="code">[‚àí6 ; 6]</span>. Espaces facultatifs¬†: <span class="code">[‚àí6;6]</span> accept√©.</li>
        <li><b>Image : </b> nombre entier ou d√©cimal ‚Äî virgule <span class="code">2,5</span> ou point <span class="code">2.5</span> accept√©s.</li>
        <li><b>Solution d'une √©quation :</b> : liste s√©par√©e par points-virgules ‚Äî ex. ‚àí4 ; 0 ; 3. L‚Äôordre n‚Äôa pas d‚Äôimportance. Vous pouvez mettre S={a;b}</li>
              <li><b>Solution d'une in√©quation :</b>  On peut obtenir des intervalles, des r√©unions d'intervalles (avec aussi des listes de nombres).</li>
 <li><b>Ensemble vide :</b>  Vous pouvez √©crire : aucun/vide/‚àÖ (disponible dans la clavier maths).</li>
	  </ul>
    </div>


    <!-- emplacement UI PDF (identique √† l‚Äôexemple) -->
    <div class="card small" id="pdf-slot"></div>

        <!-- Clavier math, centr√© -->
    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>

<!-- m√™mes libs que ton projet -->

<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif-latex.js"></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>


<script>
(function(){
'use strict';

/* =================== Helpers & Format FR (virgule) =================== */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function uniq(arr,eq=(a,b)=>a===b){ const out=[]; arr.forEach(v=>{ if(!out.some(u=>eq(u,v))) out.push(v); }); return out; }
function shuffle(a){ a = Array.isArray(a) ? [...a] : []; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
const FRfmt = new Intl.NumberFormat('fr-FR',{maximumFractionDigits:2, useGrouping:false});
const fmtFR = n => FRfmt.format(n).replace('-', '‚àí');                // 1,5 et signe ‚àí
const fmtNum = n => `<span class="num">${fmtFR(n)}</span>`;          // espaces auto autour
const fmtUnit = (n,u)=> `${fmtNum(n)}&nbsp;${u||''}`;                 // espace ins√©cable entre nombre et unit√©
const parseNumFR = s => Number(String(s||'').replace(/\u2212/g,'-').replace(',','.').trim());
const parseListFR = s =>
  !s ? [] :
  String(stripS(s)).replace(/[{}()[\]]/g,'')
    .split(/[;:,]/).map(parseNumFR).filter(Number.isFinite);
	function MJ(el){ // re-typeset MathJax apr√®s injection
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}
const stripS = s => String(s||'').replace(/^\s*s\s*=?\s*/i, ''); // enl√®ve un √©ventuel "S=" (ou "S =")

// ‚Äî‚Äî‚Äî "Pas de solution" : tokens accept√©s ‚Äî‚Äî‚Äî
function isNoSolToken(str){
  if(str==null) return false;
  const s = stripS(String(str))
              .replace(/\u2212/g,'-')     // minus Unicode ‚Üí hyphen
              .replace(/\s+/g,' ')        // espaces
              .trim()
              .toLowerCase();
  return s==='aucun' || s==='vide' || s==='‚àÖ' || s==='{}' || s==='{ }';
}

// -- Helpers TeX (toujours produire du TeX et l'encadrer par \( ‚Ä¶ \))
const tex = s => `\\(${s}\\)`;                       // met en mode math
const fmtPointTeX = v => `\\{ ${fmtFR(v)} \\}`;      // {a}
const fmtSetTeX = A => (A && A.length)               // {a ; b ; c} ou ‚àÖ
  ? `\\{ ${A.map(fmtFR).join(' \\; ;\\; ')} \\}`
  : '‚àÖ';

// Union d‚Äôintervalles/points ‚Üí TeX : ]a ; b[ ‚à™ {c} ‚à™ [d ; e]
function unionFmtTeX(U){
  if(!U || !U.length) return '‚àÖ';
  const L = ch => ch==='[' ? '[' : ']';   // '(' -> ']'
  const R = ch => ch===']' ? ']' : '[';   // ')' -> '['
  return U.map(I=>{
    if(I.a===I.b && I.left==='[' && I.right===']') return fmtPointTeX(I.a);
    return `${L(I.left)}${fmtFR(I.a)}\\; ;\\; ${fmtFR(I.b)}${R(I.right)}`;
  }).join(' \\cup ');
}
// Version "intelligente" : si l'union ne contient que des points -> {a ; b ; ...}
// sinon, on affiche : (intervalles) ‚à™ {points}
// Union ‚Üí TeX avec tri global (points et intervalles m√©lang√©s)
function unionFmtSmartTeX(U){
  if(!U || !U.length) return '‚àÖ';

  const L = ch => ch==='[' ? '[' : ']';  // '(' -> ']'
  const R = ch => ch===']' ? ']' : '[';  // ')' -> '['

  // on trie par borne gauche croissante ; √† a √©gal, les points avant les intervalles
  const parts = U.slice().sort((u,v)=>{
    if(u.a !== v.a) return u.a - v.a;
    const uPt = (u.a===u.b && u.left==='[' && u.right===']');
    const vPt = (v.a===v.b && v.left==='[' && v.right===']');
    return (uPt===vPt) ? ((u.b||0)-(v.b||0)) : (uPt ? -1 : 1);
  });

  return parts.map(I=>{
    if(I.a===I.b && I.left==='[' && I.right===']'){
      return `\\{ ${fmtFR(I.a)} \\}`;
    }
    return `${L(I.left)}${fmtFR(I.a)}\\; ;\\; ${fmtFR(I.b)}${R(I.right)}`;
  }).join(' \\cup ');
}


/* ========= Amplitudes contr√¥lables (Exos 1,2,4) ========= */
let AMP={ xmin:-5,xmax:6,ymin:-6,ymax:6 };
function applyAMP(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  if(!(xi<=xa)) [xi,xa]=[xa,xi];
  if(!(yi<=ya)) [yi,ya]=[ya,yi];
  xi=clamp(xi,-12,12); xa=clamp(xa,-12,12);
  yi=clamp(yi,-12,12); ya=clamp(ya,-12,12);
  if(xi===xa) xa=xi+1; if(yi===ya) ya=yi+1;
  AMP={ xmin:xi,xmax:xa,ymin:yi,ymax:ya };
  document.body.classList.remove('solution-active');
  buildOne();
}

/* =================== Rep√®res =================== */
/* TOUTES LES GRADUATIONS coll√©es AUX AXES (y √† gauche de l‚Äôaxe ; x sous l‚Äôaxe) + fl√®ches */
let __clipId=0;
function buildRepereSVG(opts){
  const W0=560, H0=360; const mLeft=28, mTop=6, mRight=6, mBottom=24; const W=W0+mLeft+mRight, H=H0+mTop+mBottom;
  const xmin=opts.xmin, xmax=opts.xmax, ymin=opts.ymin, ymax=opts.ymax;

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.classList.add('repere');

  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const clip=document.createElementNS(svg.namespaceURI,'clipPath'); const cid='clip'+(++__clipId);
  clip.setAttribute('id',cid); const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',mLeft);
  crect.setAttribute('y',mTop);
  crect.setAttribute('width',W0);
  crect.setAttribute('height',H0); clip.appendChild(crect);
  const marker=document.createElementNS(svg.namespaceURI,'marker'); marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d','M0,0 L6,3 L0,6 Z'); tri.setAttribute('fill','#111'); marker.appendChild(tri);
  defs.appendChild(marker); defs.appendChild(clip); svg.appendChild(defs);

const axes = document.createElementNS(svg.namespaceURI,'g');
axes.classList.add('axes');         // <-- AJOUT
const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot'); plot.setAttribute('clip-path','url(#'+cid+')'); svg.appendChild(axes); svg.appendChild(plot);

  const X=x=>mLeft + (x-xmin)*W0/(xmax-xmin);
  const Y=y=>mTop + H0 - (y-ymin)*H0/(ymax-ymin);

  // cadre
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',mLeft); frame.setAttribute('y',mTop); frame.setAttribute('width',W0); frame.setAttribute('height',H0);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); axes.appendChild(frame);
  // clipPath pour forcer l'affichage entier de la courbe dans le cadre
  frame.setAttribute('class','frame');
  const clipId = 'clip-'+Math.random().toString(36).slice(2);
  const cp=document.createElementNS(svg.namespaceURI,'clipPath'); cp.setAttribute('id',clipId);
  const r2=document.createElementNS(svg.namespaceURI,'rect');
  r2.setAttribute('x',mLeft); r2.setAttribute('y',mTop); r2.setAttribute('width',W0); r2.setAttribute('height',H0);
  cp.appendChild(r2); defs.appendChild(cp);
  plot.setAttribute('clip-path','url(#'+clipId+')');


  // axes -> positions ; clamp pour rester visibles pour les labels
  const yAxisY = clamp(Y(0), mTop+10, mTop+H0-10);
  const xAxisX = clamp(X(0), mLeft+10, mLeft+W0-10);

  // grille + labels coll√©s AUX AXES
  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7'); g.setAttribute('class','thin-grid');
    const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');

    const stepX=(opts.ticks && opts.ticks.x)||1;
    for(let xv=Math.ceil(xmin/stepX)*stepX; xv<=xmax+1e-9; xv+=stepX){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',0); l.setAttribute('x2',xx); l.setAttribute('y2',H); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(xv);
      t.setAttribute('x', clamp(xx, mLeft+14, mLeft+W0-14) );
      t.setAttribute('y', clamp(yAxisY+14, mTop+14, mTop+H0+12) );      // SOUS l‚Äôaxe des abscisses
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }

    const stepY=(opts.ticks && opts.ticks.y)||1;
    for(let yv=Math.ceil(ymin/stepY)*stepY; yv<=ymax+1e-9; yv+=stepY){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',0); l.setAttribute('y1',yy); l.setAttribute('x2',W); l.setAttribute('y2',yy); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(yv);
      t.setAttribute('x', clamp(xAxisX-6, mLeft+6, mLeft+W0-8) );        // √Ä GAUCHE de l‚Äôaxe des ordonn√©es
      t.setAttribute('y', clamp(yy+4, mTop+10, mTop+H0-6) );
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }

    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }

  // axes avec fl√®ches
  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',mLeft); axX.setAttribute('x2',mLeft+W0-8);
  axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY);
  axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','3'); if(opts.arrows){ axX.setAttribute('marker-end','url(#arrow)'); } axes.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX);
  axY.setAttribute('y1',mTop+H0); axY.setAttribute('y2',mTop+8);
  axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','3'); if(opts.arrows){ axY.setAttribute('marker-end','url(#arrow)'); } axes.appendChild(axY);

  return {svg,plot,axes,X,Y,xmin,xmax,ymin,ymax,W,H};
}

/* Rep√®re orthonorm√© (Ex.5) ‚Äî amplitude sym√©trique et quadrillage complet */
function buildRepereOrtho(opts){
  const W=560,H=360;
  const xmin=opts.xmin, xmax=opts.xmax, ymin=opts.ymin, ymax=opts.ymax;
  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox','0 0 560 360'); svg.classList.add('repere');

  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const marker=document.createElementNS(svg.namespaceURI,'marker'); marker.setAttribute('id','arrow_o'); marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d','M0,0 L6,3 L0,6 Z'); tri.setAttribute('fill','#111'); marker.appendChild(tri);
  defs.appendChild(marker); svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g'); 
  axes.classList.add('axes');         // <-- AJOUT
  const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot'); svg.appendChild(axes); svg.appendChild(plot);

  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',0); frame.setAttribute('y',0); frame.setAttribute('width',W); frame.setAttribute('height',H);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); axes.appendChild(frame);

  const sx=W/(xmax-xmin), sy=H/(ymax-ymin), s=Math.min(sx,sy);
  const cx=W/2, cy=H/2;
  const X=x=>cx + s*x, Y=y=>cy - s*y;

  const yAxisY = Y(0), xAxisX = X(0);

  // grille + labels (coll√©s aux axes)
  const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7'); g.setAttribute('class','heavy-grid');
  const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');
  const stepX=(opts.ticks&&opts.ticks.x)||1;
  for(let xv=Math.ceil(xmin/stepX)*stepX; xv<=xmax+1e-9; xv+=stepX){
    const xx=X(xv);
    const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',0); l.setAttribute('x2',xx); l.setAttribute('y2',H); g.appendChild(l);
    const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(xv);
    t.setAttribute('x', clamp(xx,14,W-14) ); t.setAttribute('y', clamp(yAxisY+14,14,H-4) );
    t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle'); tx.appendChild(t);
  }
  const stepY=(opts.ticks&&opts.ticks.y)||1;
  for(let yv=Math.ceil(ymin/stepY)*stepY; yv<=ymax+1e-9; yv+=stepY){
    const yy=Y(yv);
    const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',0); l.setAttribute('y1',yy); l.setAttribute('x2',W); l.setAttribute('y2',yy); g.appendChild(l);
    const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmtFR(yv);
    t.setAttribute('x', clamp(xAxisX-6,8,W-8) ); t.setAttribute('y', clamp(yy+4,10,H-6) );
    t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end'); ty.appendChild(t);
  }
  axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);

  const axX=document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1',0); axX.setAttribute('x2',W-8); axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY);
  axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','3'); axX.setAttribute('marker-end','url(#arrow_o)'); axes.appendChild(axX);

  const axY=document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX); axY.setAttribute('y1',H); axY.setAttribute('y2',8);
  axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','3'); axY.setAttribute('marker-end','url(#arrow_o)'); axes.appendChild(axY);

  return {svg,plot,axes,X,Y,xmin,xmax,ymin,ymax,W,H};
}

/* ========== Courbes utilitaires (Ex.1/2/4) ========== */
function catmullRomPath(points){
  if(points.length<2) return '';
  const P=i=>points[Math.max(0,Math.min(points.length-1,i))];
  let d=`M ${points[0].x} ${points[0].y}`;
  for(let i=0;i<points.length-1;i++){
    const p0=P(i-1), p1=P(i), p2=P(i+1), p3=P(i+2);
    const c1x=p1.x+(p2.x-p0.x)/6, c1y=p1.y+(p2.y-p0.y)/6;
    const c2x=p2.x-(p3.x-p1.x)/6, c2y=p2.y-(p3.y-p1.y)/6;
    d+=` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
  }
  return d;
}
function addPath(g,d,st){ const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#000'); p.setAttribute('stroke-width',st?.['stroke-width']||2.2);
  if(st?.['stroke-dasharray']) p.setAttribute('stroke-dasharray',st['stroke-dasharray']);
  if(st?.['stroke-opacity']) p.setAttribute('stroke-opacity',st['stroke-opacity']);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
function addLine(g,x1,y1,x2,y2,st){ const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
  l.setAttribute('stroke',st?.stroke||'#000'); l.setAttribute('stroke-width',st?.['stroke-width']||2); if(st?.['stroke-dasharray']) l.setAttribute('stroke-dasharray',st['stroke-dasharray']); if(st?.['stroke-opacity']) l.setAttribute('stroke-opacity',st['stroke-opacity']);
  g.appendChild(l); return l; }

function genCurveIntegerGrid(R, forceCross=true){
  const xs=[], ys=[];
  for(let x=R.xmin; x<=R.xmax; x++){
    ys.push(rnd(R.ymin+1,R.ymax-1)); xs.push(x);
  }
  if(forceCross){
    ys[Math.floor(xs.length/4)]=rnd(-3,-1);
    ys[Math.floor(xs.length/2)]=rnd(1,3);
    ys[Math.floor(3*xs.length/4)]=rnd(-3,-1);
    if(xs.includes(0)) ys[xs.indexOf(0)]=rnd(R.ymin+1,R.ymax-1);
  }
  return { Xs: xs, Ys: ys };
}
// Interpolation cubique monotone (Fritsch‚ÄìCarlson) ‚Üí pas d'overshoot
function monotoneBezierPathXY(rep, xs, ys, ymin, ymax){
  const X=rep.X, Y=rep.Y, n=xs.length;
  if(n<2) return '';
  const h=new Array(n-1), s=new Array(n-1);
  for(let i=0;i<n-1;i++){ h[i]=xs[i+1]-xs[i]; s[i]=(ys[i+1]-ys[i])/h[i]; }

  const d=new Array(n);
  d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){
    if(s[i-1]*s[i] <= 0){ d[i]=0; }
    else{
      const w1 = 2*h[i] + h[i-1], w2 = h[i] + 2*h[i-1];
      d[i] = (w1+w2)/((w1/s[i-1]) + (w2/s[i]));   // tangente FC
    }
  }

  let dstr = `M ${X(xs[0])} ${Y(ys[0])}`;
  for(let i=0;i<n-1;i++){
    const x0=xs[i], x1=xs[i+1], y0=ys[i], y1=ys[i+1], hi=h[i];
    const c1x = X(x0 + hi/3), c1y = Y(Math.min(ymax, Math.max(ymin, y0 + d[i]   * hi/3)));
    const c2x = X(x1 - hi/3), c2y = Y(Math.min(ymax, Math.max(ymin, y1 - d[i+1] * hi/3)));
    dstr += ` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return dstr;
}


function buildGridWithConstraints(R, nbAnt, Yask){
  // Construit une grille enti√®re telle que, pour chaque y ‚àà Yask,
  // les seules solutions de f(x)=y soient des x entiers impos√©s.
  nbAnt = clamp(parseInt(nbAnt||1,10),1,10);
  const xs=[], ys=[];
  for(let x=R.xmin; x<=R.xmax; x++) xs.push(x);

  const YsAsk = (Yask||[]).filter(y=>Number.isFinite(y));
  const minY = Math.min(...YsAsk, R.ymax);
  const maxY = Math.max(...YsAsk, R.ymin);

  const roomBelow = (minY - (R.ymin+1)) >= 1;
  const roomAbove = ((R.ymax-1) - maxY) >= 1;

  let baselineRange;
  if(roomBelow){ baselineRange = [R.ymin+1, Math.floor(minY)-1]; }
  else if(roomAbove){ baselineRange = [Math.ceil(maxY)+1, R.ymax-1]; }
  else { baselineRange = [R.ymin+1, R.ymin+1]; }

  // baseline enti√®re, d'un seul c√¥t√© de tous les y demand√©s
  for(let i=0;i<xs.length;i++){
    const a = baselineRange[0], b = baselineRange[1];
    ys.push(a===b? a : rnd(a,b));
  }

  const taken = new Set();
  (YsAsk||[]).forEach(y=>{
    let k=0, guard=0;
    while(k<nbAnt && guard<5000){
      const x = rnd(R.xmin, R.xmax);
      guard++;
      const idx = x - R.xmin;
      const key = y+':'+idx;
      if(taken.has(key)) continue;
      taken.add(key);
      ys[idx] = y;
      if(idx>0 && ys[idx-1]===y) ys[idx-1] += (roomBelow? -1 : +1);
      if(idx<ys.length-1 && ys[idx+1]===y) ys[idx+1] += (roomBelow? -1 : +1);
      k++;
    }
  });

  return { Xs: xs, Ys: ys };
}
const pathFromGrid = (rep, grid) => {
  const pts = grid.Xs.map((x,i)=>({x:rep.X(x), y:rep.Y(grid.Ys[i])}));
  if(pts.length===0) return '';
  let d = 'M '+pts[0].x+' '+pts[0].y;
  for(let i=1;i<pts.length;i++){
    d += ' L '+pts[i].x+' '+pts[i].y;
  }
  return d;
};

const pathFromGridSmooth = (rep, grid) => {
  const X = rep.X, Y = rep.Y, Xs = grid.Xs, Ys = grid.Ys;
  const n = Xs.length; if(n < 2) return '';
  const forced = new Set((grid.Forced||[]).map(i=>i));

  // slopes on grid (h=1)
  const s = new Array(n-1);
  for(let i=0;i<n-1;i++) s[i] = Ys[i+1]-Ys[i];

  // Steffen-like monotone slopes with zero slope at extrema
  const d = new Array(n);
  d[0] = s[0]; d[n-1] = s[n-2];
  for(let i=1;i<n-1;i++){
    const s0=s[i-1], s1=s[i];
    if(s0*s1 <= 0){ d[i] = 0; }
    else{
      const a=Math.abs(s0), b=Math.abs(s1);
      d[i] = (Math.sign(s0)+Math.sign(s1)) * Math.min(a,b,0.5*(a+b));
    }
  }

  // soften globally and near forced points ‚Äî **m√™me facteur partout**
  for(let i=0;i<n;i++){
    if(forced.has(i)){
      d[i] = 0;
      if(i>0) d[i-1] *= 0.4;
      if(i<n-1) d[i+1] *= 0.4;
    } else {
      d[i] *= HERMITE_SCALE;
    }
  }

  // Hermite -> cubic B√©zier
  let dstr = `M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){
    const x0=Xs[i], x1=Xs[i+1], y0=Ys[i], y1=Ys[i+1], h=x1-x0; // h=1
    const c1x=X(x0 + h/3), c1y=Y(y0 + d[i]*h/3);
    const c2x=X(x1 - h/3), c2y=Y(y1 - d[i+1]*h/3);
    dstr += ` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return dstr;
};


function interpAtGrid(grid, x){
  const {Xs,Ys}=grid;
  if(x<Xs[0] || x> Xs[Xs.length-1]) return null;
  const i=Math.floor(x - Xs[0]);
  if(Math.abs(x - Math.round(x))<1e-9) return Ys[i];
  const k=Math.floor(x), idx=k - Xs[0];
  const y1=Ys[idx], y2=Ys[idx+1];
  return y1 + 0.5*(y2-y1);
}

function pickYsIntOrHalf(R, count){
  const vals=[];
  for(let y=R.ymin+1; y<=R.ymax-1; y++){
    vals.push(y);
    if(y+0.5 < R.ymax) vals.push(y+0.5);
  }
  return uniq(shuffle(vals)).slice(0,count);
}
function pickXsIntOrHalf(R, count){
  const vals=[];
  for(let x=R.xmin+1; x<=R.xmax-1; x++){
    vals.push(x);
    if(x+0.5 < R.xmax) vals.push(x+0.5);
  }
  return uniq(shuffle(vals)).slice(0,count);
}


function approxEqualList(found, expected, tol=0.2){
  if(found.length!==expected.length) return false;
  const F = found.slice().sort((a,b)=>a-b);
  const E = expected.slice().sort((a,b)=>a-b);
  for(let i=0;i<F.length;i++){
    if(Math.abs(F[i]-E[i])>tol) return false;
  }
  return true;
}

function antecedentsOfGrid(grid, y){
  const out=[];
  for(let i=0;i<grid.Xs.length-1;i++){
    const x1=grid.Xs[i], x2=grid.Xs[i+1], y1=grid.Ys[i], y2=grid.Ys[i+1];
    if(y===y1) out.push(x1);
    if(y===y2) out.push(x2);
    if((y1<y && y<y2) || (y2<y && y<y1)){
      const t=(y-y1)/((y2-y1)||1e-9); const x=x1+t*(x2-x1); out.push(x);
    }
  }
    // Snap x very close to integers to avoid tiny offsets (overlap with image helpers)
  const snapped = out.map(x => (Math.abs(x - Math.round(x)) < 1e-6 ? Math.round(x) : x));
  return uniq(snapped, (a,b)=>Math.abs(a-b)<1e-9);

}
// ==== R√©solution sur grille enti√®re (m√™mes valeurs que les ant√©c√©dents) ====

// racines enti√®res de f(x)=y sur la grille (pas d'intersection √† l'int√©rieur par construction)
function rootsEqInt(grid, y){
  return antecedentsOfGrid(grid, y)
    .filter(x => Math.abs(x - Math.round(x)) < 1e-9)
    .map(x => Math.round(x));
}

// √©value f (ou g) √† x (entier ou demi-entier)
const gridVal = (grid,x) => interpAtGrid(grid,x);

// Union d‚Äôintervalles sur [xmin;xmax] obtenue par un pr√©dicat vrai au milieu de chaque case (i,i+1)
// et, si includeEqPoints=true, on ajoute les points entiers i o√π le pr√©dicat est vrai.
// add 4th param: splitAt = integers where we must split the run
function unionFromPredicate(R, pred, includeEqPoints, splitAt){
  const a=R.xmin, b=R.xmax;
  const cells = new Set(), pts = new Set();
  const splits = new Set(splitAt || []);

  for(let i=a; i<b; i++) if (pred(i+0.5)) cells.add(i);
  if (includeEqPoints){
    for(let i=a; i<=b; i++) if (pred(i)) pts.add(i);
  }

  const U=[];
  let i=a;
  while(i<b){
    if(!cells.has(i)){ i++; continue; }
    let j=i+1;
    while(j<=b-1 && cells.has(j)) j++;

    // split inside [i, j] at any integer s that is in "splits"
    let start = i;
    for(let s=i+1; s<=j-1; s++){
      if(splits.has(s)){
        U.push({ a:start, b:s, left: pts.has(start)?'[':'(', right: pts.has(s)?']':')' });
        start = s;
      }
    }
    U.push({ a:start, b:j, left: pts.has(start)?'[':'(', right: pts.has(j)?']':')' });
    i=j;
  }

  // isolated points (only when includeEqPoints === true)
  for(const p of pts){
    if( (p>a && cells.has(p-1)) || (p<b && cells.has(p)) ) continue;
    U.push({a:p,b:p,left:'[',right:']'});
  }

  U.sort((u,v)=> u.a===v.a ? u.b-v.b : u.a-v.a);
  return U;
}


// affichage FR : [a ; b] ‚à™ ...
function unionFmtFR(U){
  if(!U || !U.length) return '‚àÖ';

  const L = ch => ch==='[' ? '[' : ']'; // '(' -> ']'
  const R = ch => ch===']' ? ']' : '['; // ')' -> '['

  return U.map(I=>{
    // point isol√© : {a}
    if(I.a===I.b && I.left==='[' && I.right===']'){
      return `{${fmtFR(I.a)}}`;
    }
    return `${L(I.left)}${fmtFR(I.a)} ; ${fmtFR(I.b)}${R(I.right)}`;
  }).join(' ‚à™ ');
}



// parse ¬´ [a ; b] ‚à™ ]c ; d[ ¬ª  (accepte virgule ou point ; "‚àÖ"/"vide"/"aucun")
// parse ¬´ [a ; b] ‚à™ ]c ; d[ ¬ª + {points} + listes simples ; accepte aussi S=... et ¬´ aucun/vide/‚àÖ ¬ª
function parseUnionFR(str){
  let raw0 = String(str||'').trim();
  let s = stripS(raw0)
            .replace(/\u2212/g,'-')
            .replace(/,/g,'.')
            .toLowerCase().trim();

  // explicites : "aucun", "vide", "‚àÖ"
  if(s==='aucun' || s==='vide' || s==='‚àÖ') return [];

  // autoriser () comme bornes ouvertes
  s = s.replace(/\(/g,']').replace(/\)/g,'[');

  const out = [];

  // 1) intervalles
  const re = /([\[\]])\s*([-+]?\d+(?:\.\d+)?)\s*[;:,]\s*([-+]?\d+(?:\.\d+)?)\s*([\[\]])/g;
  let m;
  while((m = re.exec(s))){
    let a = Math.round(parseFloat(m[2]));
    let b = Math.round(parseFloat(m[3]));
    if(!Number.isFinite(a) || !Number.isFinite(b)) continue;
    if(a>b) [a,b] = [b,a];
    const left  = (m[1]==='[' ? '[' : '(');
    const right = (m[4]===']' ? ']' : ')');
    out.push({a,b,left,right});
  }

  // 2) points { ‚Ä¶ }
  const rePts = /\{([^}]*)\}/g;
  let ms;
  while((ms = rePts.exec(s))){
    const nums = String(ms[1]).split(/[;:,]/)
      .map(t => Math.round(parseFloat(t))).filter(Number.isFinite);
    nums.forEach(v => out.push({a:v,b:v,left:'[',right:']'}));
  }

  // 3) fallback : simple liste de nombres "a;b;c"
  if(out.length===0){
    const plain = s.replace(/[^0-9+.\-;:,]/g,'');
    if(/^-?\d+(?:\.\d+)?(\s*[;:,]\s*-?\d+(?:\.\d+)?)*$/.test(plain)){
      plain.split(/[;:,]/)
        .map(t => Math.round(parseFloat(t)))
        .filter(Number.isFinite)
        .forEach(v => out.push({a:v,b:v,left:'[',right:']'}));
    }
  }

  // üîí STRICT : si rien n‚Äôa √©t√© compris ET que ce n‚Äôest pas un token "aucun/vide/‚àÖ", on renvoie null (invalide)
  if(out.length===0){
    return null;
  }
  return out;
}




// comparaison "discr√®te" (par cases enti√®res et points)
function unionEqual(U1,U2){
  const raster = (U)=>{
    const cells=new Set(), pts=new Set();
    for(const I of U){
      for(let k=I.a; k<I.b; k++) cells.add(k);      // (k,k+1) ‚Äî on ne g√®re pas l'ouverture ici, inutile sur grille enti√®re
      if(I.a===I.b && I.left==='[' && I.right===']') pts.add(I.a);
      if(I.left==='[') pts.add(I.a);
      if(I.right===']') pts.add(I.b);
    }
    return {cells,pts};
  };
  const A=raster(U1), B=raster(U2);
  if(A.cells.size!==B.cells.size || A.pts.size!==B.pts.size) return false;
  for(const k of A.cells) if(!B.cells.has(k)) return false;
  for(const p of A.pts)   if(!B.pts.has(p))   return false;
  return true;
}

/* ========== Vues g√©n√©riques ========== */
function mkRow(host,consigneHTML){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const st=document.createElement('div'); st.className='statement';
  st.innerHTML='<div class="consigne">'+(consigneHTML||'')+'</div>';
  const form=document.createElement('div'); form.className='input-wrap';
  const res=document.createElement('div'); res.id='res';
  row.appendChild(st); row.appendChild(form); row.appendChild(res);
  host.appendChild(row);
  try { __forceWordParenSpaces(form); __forceWordParenSpaces(st); } catch(e) {}
  return {row,st,form,res};
}
function showSteps(host, steps){
  try{
    let r = $('#res', host);
    if(!r){
      r = document.createElement('div');
      r.id = 'res';
      host.appendChild(r);
    }
  }catch(e){}

  $('#res',host).innerHTML =
    '<div class="steps">' + steps.map(s => '<div class="step">'+s+'</div>').join('') + '</div>';

  try { __forceWordParenSpaces($('#res',host)); } catch(e) {}
}

function clearMarks(host){ host.querySelectorAll('.qmark').forEach(m=>m.textContent=''); (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = ('');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })(); const plot=host.querySelector('.plot'); if(plot){ plot.querySelectorAll('line[stroke-dasharray]').forEach(n=>n.remove()); } }


function __forceWordParenSpaces(root){
  if(!root) return;
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  const reAfter = /(\))([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø])/g;
  const reBefore = /([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]{2,})(\()/g;
  let n;
  while((n = walker.nextNode())){
    const s = n.nodeValue;
    const t = s.replace(reAfter, '$1\u00A0$2').replace(reBefore, '$1\u00A0$2');
    if(t !== s) n.nodeValue = t;
  }
}
/* === Helpers manquants pour l‚Äôex.1 : courbe secondaire + petite √©tiquette === */
// ---- m√™me facteur de lissage partout (trac√© + contr√¥les) ----
const HERMITE_SCALE = 0.56;   // 0.55‚Äì0.58 marche bien ; 0.56 = s√ªr

/* ===== Helpers Hermite (m√™mes pentes que pathFromGridSmooth) ===== */
/* ===== Slopes Hermite identiques au lissage ===== */



function _evalHermite(Ys, d, i, t){ // t in [0,1]
  const y0=Ys[i], y1=Ys[i+1], m0=d[i], m1=d[i+1];
  const t2=t*t, t3=t2*t;
  const h00 =  2*t3 - 3*t2 + 1;
  const h10 =      t3 - 2*t2 + t;
  const h01 = -2*t3 + 3*t2;
  const h11 =      t3 -    t2;
  return h00*y0 + h10*m0 + h01*y1 + h11*m1;
}
function __hermiteSlopesScaled(Ys, forcedIdxSet){
  const n=Ys.length, s=new Array(n-1), d=new Array(n);
  for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){
    const s0=s[i-1], s1=s[i];
    d[i]=(s0*s1<=0)?0:(Math.sign(s0)+Math.sign(s1)) * Math.min(Math.abs(s0),Math.abs(s1),0.5*(Math.abs(s0)+Math.abs(s1)));
  }
  for(let i=0;i<n;i++){
    if(forcedIdxSet && forcedIdxSet.has(i)){
      d[i]=0; if(i>0) d[i-1]*=0.4; if(i<n-1) d[i+1]*=0.4;
    } else d[i]*=HERMITE_SCALE;          // **m√™me facteur**
  }
  return d;
}
// Est-ce que y = k coupe la courbe UNIQUEMENT sur des n≈ìuds entiers ?
function levelHasOnlyIntegerSolutions(grid, k){
  const Ys = grid.Ys, n = Ys.length;
  const forced = new Set(grid.Forced||[]);
  const d = __hermiteSlopesScaled(Ys, forced);   // m√™mes pentes que le trac√©

  // il faut au moins un n≈ìud √©gal √† k
  let hasNode=false;
  for(let i=0;i<n;i++) if(Ys[i]===k) hasNode=true;
  if(!hasNode) return false;

  for(let i=0;i<n-1;i++){
    const a = Ys[i]   - k;
    const b = Ys[i+1] - k;

    // palier complet y=k sur [i,i+1] ‚Üí on rejette (√ßa ferait un intervalle d‚Äôant√©c√©dents)
    if(a===0 && b===0) return false;

    // changement de signe aux bornes ‚Üí racine int√©rieure non enti√®re
    if(a*b < 0) return false;

    // ceinture + bretelles : on √©chantillonne l‚ÄôHermite √† l‚Äôint√©rieur
    const m = 16;
    const s0 = Math.sign(a || b || 1);           // signe aux bornes (hors z√©ros)
    for(let t=1;t<m;t++){
      const y = _evalHermite(Ys, d, i, t/m);
      const s = Math.sign(y - k);
      if(s!==0 && s!==s0) return false;          // un changement de signe appara√Æt
    }
  }
  return true;
}

// renvoie une liste de niveaux k s√ªrs (parmi les entiers visibles qui EXISTENT sur des n≈ìuds)
function pickSafeLevelsEq(grid, R, count=1){
  const present = new Set(grid.Ys);              // valeurs effectivement atteintes aux n≈ìuds
  const pool=[];
  for(let y=R.ymin+1; y<=R.ymax-1; y++) if(present.has(y)) pool.push(y);
  const safe = pool.filter(k => levelHasOnlyIntegerSolutions(grid, k));
  return shuffle(safe).slice(0, count);
}

// Rejette si Œî(t) change de signe √† l'int√©rieur d'un segment [i,i+1]
// (√©chantillonnage dense + test sur les coefficients de Bezier).
function noInteriorCross_STRICT(YsF, YsG, forcedIdx){
  const n=YsF.length, Z=new Set(forcedIdx||[]);
  const dF=__hermiteSlopesScaled(YsF,Z), dG=__hermiteSlopesScaled(YsG,Z);

  for(let i=0;i<n-1;i++){
    const endForced = Z.has(i) || Z.has(i+1);
    const dy0 = YsF[i]-YsG[i];
    const dy1 = YsF[i+1]-YsG[i+1];

    // si pas forc√© et d√©j√† signes contraires aux bornes -> croisement certain
    if(!endForced && dy0*dy1<0) return false;

    // Bezier (Bernstein) de Œî : B0..B3
    const dm0 = dF[i]-dG[i];
    const dm1 = dF[i+1]-dG[i+1];
    const B0=dy0, B1=dy0+dm0/3, B2=dy1-dm1/3, B3=dy1;

    // tous m√™me signe (en ignorant z√©ro aux extr√©mit√©s forc√©es) ?
    const sameSign = arr=>{
      let sgn=0;
      for(const v of arr){
        if(v===0) continue;
        const s=Math.sign(v);
        if(sgn===0) sgn=s; else if(s!==sgn) return false;
      }
      return sgn!==0;
    };
    if(!sameSign([B0,B1,B2,B3])){
      // tol√©rer le z√©ro seulement au n≈ìud forc√©
      const zeros=[B0,B1,B2,B3].map((v,k)=>v===0?k:-1).filter(k=>k!==-1);
      const endsOK = (Z.has(i) && zeros.includes(0)) || (Z.has(i+1) && zeros.includes(3));
      if(!endsOK) return false;
    }

    // √©chantillonnage interne tr√®s dense (s√©curit√© num√©rique)
    const m=32;                           // 1/32 d‚Äôunit√©
    const sign0 = Math.sign(dy0 || (endForced? (dy1||1) : 1));
    for(let k=1;k<m;k++){
      const t=k/m, t2=t*t, t3=t2*t;
      const h00= 2*t3-3*t2+1, h10=t3-2*t2+t, h01=-2*t3+3*t2, h11=t3-t2;
      const yF = h00*YsF[i] + h10*dF[i] + h01*YsF[i+1] + h11*dF[i+1];
      const yG = h00*YsG[i] + h10*(dG[i]) + h01*YsG[i+1] + h11*(dG[i+1]);
      const diff = yF - yG;
      if(Math.sign(diff)!==0 && Math.sign(diff)!==Math.sign(sign0)) return false;
    }
  }
  return true;
}
// abscisses enti√®res o√π F et G co√Øncident (√©galit√© sur n≈ìuds)
function intIntersections(F, G){
  const out=[];
  for(let i=0;i<F.Xs.length;i++){
    if(F.Ys[i]===G.Ys[i]) out.push(F.Xs[i]);
  }
  return out;
}

// m√™mes pentes Hermite que le trac√© (d√©j√† dans ton code)
function _hermiteSlopes(Ys, forcedIdx){
  return __hermiteSlopesScaled(Ys, new Set(forcedIdx||[])); // r√©utilise ta version
}
function _hermiteEval(Ys, d, i, t){ // t in [0,1]
  const y0=Ys[i], y1=Ys[i+1], m0=d[i], m1=d[i+1];
  const t2=t*t, t3=t2*t;
  const h00=2*t3-3*t2+1, h10=t3-2*t2+t, h01=-2*t3+3*t2, h11=t3-t2;
  return h00*y0 + h10*m0 + h01*y1 + h11*m1;
}

// racines r√©elles de f-g par bisection Hermite (tol√©rance ~1e-3)
function realIntersectionsHermite(F, G, forcedIdx){
  const n=F.Xs.length, Z=new Set(forcedIdx||[]);
  const dF=_hermiteSlopes(F.Ys,Z), dG=_hermiteSlopes(G.Ys,Z);
  const roots=[];
  for(let i=0;i<n-1;i++){
    const a=F.Ys[i]-G.Ys[i], b=F.Ys[i+1]-G.Ys[i+1];
    // si √©galit√© exactement au n≈ìud : prends l‚Äôentier, pas besoin de bisection
    if(a===0){ roots.push(F.Xs[i]); continue; }
    if(b===0){ roots.push(F.Xs[i+1]); continue; }
    // changement de signe ‚Üí racine interne
    if(a*b<0){
      let lo=0, hi=1;
      for(let it=0; it<32; it++){
        const mid=(lo+hi)/2;
        const yF=_hermiteEval(F.Ys,dF,i,mid);
        const yG=_hermiteEval(G.Ys,dG,i,mid);
        const s = (yF-yG);
        const sa = ( (lo===0) ? a : (_hermiteEval(F.Ys,dF,i,lo)-_hermiteEval(G.Ys,dG,i,lo)) );
        if(sa*s<=0) hi=mid; else lo=mid;
      }
      const x = F.Xs[i] + (lo+hi)/2;          // pas = 1
      roots.push(x);
    }
  }
  // d√©doublonnage
  const uniq=[]; roots.sort((u,v)=>u-v).forEach(r=>{
    if(!uniq.length || Math.abs(r-uniq[uniq.length-1])>1e-6) uniq.push(r);
  });
  return uniq;
}
// f et g sont-ils "assez diff√©rents" ?
// On exige qu'au moins 35% des cases (i+0.5) aient |f-g| ‚â• 0.8
// Are f and g far apart everywhere (no vertical overlap)?
function hasVerticalOverlap(F, G, margin=0.5){
  const minF = Math.min(...F.Ys), maxF = Math.max(...F.Ys);
  const minG = Math.min(...G.Ys), maxG = Math.max(...G.Ys);
  // overlap iff neither interval sits fully above the other
  return !(maxF < minG + margin || maxG < minF + margin);
}

// Do we have at least one real crossing (or ‚â•2 integer-node crossings)?
function haveCrossings(F, G){
  const zi = intIntersections(F, G);
  if (zi.length >= 2) return true;
  const roots = realIntersectionsHermite(F, G, F.Forced || G.Forced || []);
  return roots.length >= 1;
}

// Keep: already given previously
function curvesDistinctEnough(R, F, G, gap=0.8, minShare=0.35){
  const a=R.xmin, b=R.xmax;
  let tot=0, sep=0;
  for(let i=a;i<b;i++){
    const f=gridVal(F,i+0.5), g=gridVal(G,i+0.5);
    if(f==null || g==null) continue;
    tot++; if(Math.abs(f-g) >= gap) sep++;
  }
  return tot>0 && (sep/tot >= minShare);
}


// ==== Courbe secondaire par "d√©calage par blocs" (2 intersections enti√®res garanties) ====
function genSecondaryGridPiecewiseShift(R, main, opts){
  opts = opts || {};
  const Xs  = main.Xs.slice();
  const YsF = main.Ys.slice();
  const n   = Xs.length;
  const yMinIn = R.ymin + 1;
  const yMaxIn = R.ymax - 1;
  const gapMin = Math.max(2, opts.gapMin || 4);
  const maxShiftCap = Number.isFinite(opts.maxShift) ? opts.maxShift : 999;

  // marge disponible pour monter/descendre sur un bloc d‚Äôindices [lo..hi]
  function marginBlock(lo, hi){
    if (lo > hi) return { up: Infinity, down: Infinity, empty:true };
    let up = Infinity, down = Infinity;
    for (let k = lo; k <= hi; k++){
      up   = Math.min(up,   yMaxIn - YsF[k]);
      down = Math.min(down, YsF[k]  - yMinIn);
    }
    return { up, down, empty:false };
  }

  // choisit un d√©calage vertical (signe + amplitude) compatible avec la marge
  function chooseShift(M){
    if (M.empty) return { sign:+1, M: gapMin };
    const cands = [];
    if (M.up   >= gapMin) cands.push({ sign:+1, M: Math.min(M.up,   maxShiftCap) });
    if (M.down >= gapMin) cands.push({ sign:-1, M: Math.min(M.down, maxShiftCap) });
    if (!cands.length) return null;
    return cands.length === 2 ? (Math.random() < .5 ? cands[0] : cands[1]) : cands[0];
  }

  // teste qu‚Äôil n‚Äôy a pas de croisement √† l‚Äôint√©rieur des cases (i,i+1)
  function noInteriorCross_STRICT(YsG, forcedIdx){
    const n = YsF.length;
    const Z = new Set(forcedIdx || []);
    const dF = __hermiteSlopesScaled(YsF, Z);
    const dG = __hermiteSlopesScaled(YsG, Z);

    for (let i = 0; i < n - 1; i++){
      const endForced = Z.has(i) || Z.has(i+1);
      const dy0 = YsF[i]   - YsG[i];
      const dy1 = YsF[i+1] - YsG[i+1];

      if (!endForced && dy0 * dy1 < 0) return false; // changement de signe aux bornes

      // B√©zier de la diff√©rence pour renforcer le test
      const dm0 = dF[i]   - dG[i];
      const dm1 = dF[i+1] - dG[i+1];
      const B0 = dy0, B1 = dy0 + dm0/3, B2 = dy1 - dm1/3, B3 = dy1;

      const sameSign = (arr)=>{
        let sgn = 0;
        for (const v of arr){
          if (v === 0) continue;
          const s = Math.sign(v);
          if (sgn === 0) sgn = s; else if (s !== sgn) return false;
        }
        return sgn !== 0;
      };
      if (!sameSign([B0,B1,B2,B3])){
        const zeros = [B0,B1,B2,B3].map((v,k)=>v===0?k:-1).filter(k=>k!==-1);
        const endsOK = (Z.has(i) && zeros.includes(0)) || (Z.has(i+1) && zeros.includes(3));
        if (!endsOK) return false;
      }

      // √©chantillonnage interne
      const m = 32;
      const sign0 = Math.sign(dy0 || (endForced ? (dy1||1) : 1));
      for (let k = 1; k < m; k++){
        const t = k/m, t2 = t*t, t3 = t2*t;
        const h00 =  2*t3 - 3*t2 + 1;
        const h10 =      t3 - 2*t2 + t;
        const h01 = -2*t3 + 3*t2;
        const h11 =      t3 -    t2;
        const yF = h00*YsF[i] + h10*dF[i] + h01*YsF[i+1] + h11*dF[i+1];
        const yG = h00*YsG[i] + h10*dG[i] + h01*YsG[i+1] + h11*dG[i+1];
        const diff = yF - yG;
        if (Math.sign(diff) !== 0 && Math.sign(diff) !== Math.sign(sign0)) return false;
      }
    }
    return true;
  }

  // essaie toutes les paires (i,j) bien espac√©es et construit G par blocs
  const pairs = [];
  for (let i = 1; i <= n - 2; i++){
    for (let j = i + 2; j <= n - 2; j++){
      pairs.push([i,j]);
    }
  }
  pairs.sort((a,b)=> (b[1]-b[0]) - (a[1]-a[0])); // pr√©f√©rer grands espacements

  for (const [i,j] of pairs){
    const L = marginBlock(0,   i-1);
    const M = marginBlock(i+1, j-1);
    const Rr= marginBlock(j+1, n-1);

    const sL = chooseShift(L);
    const sM = chooseShift(M);
    const sR = chooseShift(Rr);
    if (!sL || !sM || !sR) continue;

    // alternance : signe du bloc central, gauche/droite oppos√©s
    let sMsign = sM.sign;
    let sLsign = -sMsign;
    let sRsign = -sMsign;

    // si les marges imposent un signe √©gal, on retourne tout
    if (sL.sign === sMsign || sR.sign === sMsign){
      sMsign *= -1; sLsign *= -1; sRsign *= -1;
    }

    // construit YsG avec amplitudes fix√©es (√©carts forts partout sauf sur i,j)
    const YsG = YsF.map((y, idx)=>{
      if (idx === i || idx === j) return y;
      if (idx < i)  return y + sLsign * sL.M;
      if (idx > j)  return y + sRsign * sR.M;
      return y + sMsign * sM.M;
    });

    const forced = [i,j];
    const inside = YsG.every(y => yMinIn <= y && y <= yMaxIn);
    if (!inside) continue;
    if (!noInteriorCross_STRICT(YsG, forced)) continue;

    return { Xs, Ys: YsG, Forced: forced };
  }

  // Fallback : miroir simple
  const mid = Math.floor(n/2);
  const YsG = YsF.map(y=>-y);
  return { Xs, Ys: YsG, Forced: [Math.max(1, mid-2), Math.min(n-2, mid+2)] };
}



  






function genSecondaryGrid(R, main, opts){
  opts = opts || {};
const n = main.Xs.length;
const maxDx = Math.min(Math.max(1, opts.maxDx ?? (n-2)), n-2);
  const gapMin0= opts.gapMin ?? 3;

  const Xs = main.Xs.slice();
  const YsF = main.Ys.slice();
  const yMinIn = R.ymin + 1, yMaxIn = R.ymax - 1;

  const buildYsG = (dx, dy)=>{
    const YsG = new Array(n);
    for(let i=0;i<n;i++){
      const j = (i - dx >= 0) ? (i - dx) : i;
      YsG[i] = -(YsF[j] + dy);
    }
    return YsG;
  };
  const countRootsInt = YsG => {
    const idx=[]; for(let i=0;i<n;i++) if(YsF[i]===YsG[i]) idx.push(i);
    return idx;
  };
  const inside = YsG => YsG.every(y => yMinIn <= y && y <= yMaxIn);
  const gapOK = (YsG, idxZero, gapMin)=>{
    const Z=new Set(idxZero);
    for(let i=0;i<n;i++){
      if(Z.has(i)) continue;
      if(Math.abs(YsF[i]-YsG[i]) < gapMin) return false;
    }
    return true;
  };
const validPair = (YsG, idx, gapMin)=>{
  if(idx.length!==2) return false;
  if(idx.some(i=>i<=0 || i>=n-1)) return false;
  if(idx[1]-idx[0] < 2) return false;
  if(!inside(YsG)) return false;
  if(!gapOK(YsG, idx, gapMin)) return false;
  if(!_noInteriorZeroBezier(YsF, YsG, idx)) return false;
  if(!_noInteriorCrossSmooth(YsF, YsG, idx)) return false;   // ‚Üê AJOUT
  return true;
};


  // 1) Strat√©gie ‚Äúsomme √©gale‚Äù
  const cands=[];
  for(let dx=1; dx<=Math.min(maxDx, n-1); dx++){
    const hist=new Map();
    for(let i=dx;i<n;i++){
      const s = YsF[i] + YsF[i-dx];
      (hist.get(s) || hist.set(s,[]), hist.get(s)).push(i);
    }
    for(const [Sval, idxs] of hist.entries()){
      if(idxs.length!==2) continue;
      const spacing = idxs[1]-idxs[0];
      cands.push({dx, Sval, idxs: idxs.slice(), spacing});
    }
  }
  cands.sort((a,b)=> (b.spacing!==a.spacing) ? b.spacing-a.spacing : a.dx-b.dx);

  for(const gapMin of [gapMin0, 2, 1]){
    for(const c of cands){
      const dy = -c.Sval;
      const YsG = buildYsG(c.dx, dy);
      if(validPair(YsG, c.idxs, gapMin)) return { Xs, Ys: YsG, Forced: c.idxs };
    }
  }

  // 2) Miroir y=c (dx=0)
  const hist = new Map();
  for(let i=0;i<n;i++){
    const s = 2*YsF[i];
    (hist.get(s) || hist.set(s,[]), hist.get(s)).push(i);
  }
  const mCands = Array.from(hist.entries())
    .filter(([,idxs]) => idxs.length===2)
    .map(([Sval, idxs])=>({ dy: -Sval, idxs: idxs.slice(), spacing: idxs[1]-idxs[0] }))
    .sort((a,b)=> b.spacing-a.spacing);

  for(const gapMin of [gapMin0, 2, 1]){
    for(const c of mCands){
      const YsG = YsF.map(y => -(y + c.dy));
      if(validPair(YsG, c.idxs, gapMin)) return { Xs, Ys: YsG, Forced: c.idxs };
    }
  }

  // 3) Balayage born√© (filet)
  for(const gapMin of [gapMin0, 2, 1]){
    for(let dx=1; dx<=Math.min(maxDx, n-1); dx++){
      const minDy = Math.max(...YsF.slice(dx).map(y=> -(y) - yMaxIn));
      const maxDy = Math.min(...YsF.slice(dx).map(y=> -(y) - yMinIn));
      for(let dy=minDy; dy<=maxDy; dy++){
        const YsG = buildYsG(dx, dy);
        const idx = countRootsInt(YsG);
        if(validPair(YsG, idx, gapMin)) return { Xs, Ys: YsG, Forced: idx };
      }
    }
  }

  // 4) Ultra-fallback
  for(let t=-6; t<=6; t++){
    const YsG = YsF.map(y => -(y + 2*t));
    const idx = countRootsInt(YsG);
    if(validPair(YsG, idx, 1)) return { Xs, Ys: YsG, Forced: idx };
  }

  const mid=Math.floor(n/2);
  const YsG = YsF.map(y => -y);
  const forced=[Math.max(1, mid-2), Math.min(n-2, mid+2)];
  return { Xs, Ys: YsG, Forced: forced };
}

// ==== Variante "√©quilibr√©e" pour Cg : vise ~50/50 de zones f‚â•g et f<g ====
// - Essaie la grille par d√©faut (piecewise shift) ; si trop d√©s√©quilibr√©e,
//   retente en miroir vertical de Cf, puis miroir autour de yMid.
// - Retourne la version la plus "balance" (proche de 0.5).
// ==== G√©n√©ration "√©quilibr√©e" de Cg ====
// Cherche une configuration o√π la proportion des cases (i+0.5) v√©rifiant f‚â•g
// est proche de 50% (plus "mordant" pour les in√©quations).
function buildBalancedSecondary(R, main, opts){
  const TARGET_MAX_IMBAL = 0.56;   // existant
  const PREF_ALT_BIAS    = 0.95;   // existant
  const GAP_BUMP         = 0.5;    // existant

  function scoreBalance(F, G, onlyBetweenIJ){
  const a = F.Xs[0], b = F.Xs[F.Xs.length-1];
  let ge = 0, tot = 0;
  const i1 = Math.min(...(G.Forced||[a+1])), i2 = Math.max(...(G.Forced||[b-1]));
  for(let i=a; i<b; i++){
    if (onlyBetweenIJ && !(i>=i1 && i<i2)) continue;
    const x = i + 0.5;
    const f = gridVal(F,x), g = gridVal(G,x);
    if (f==null || g==null) continue;
    tot++; if (f >= g) ge++;
  }
  return tot ? ge/tot : 0.5;
}

  function mirrorGridAround(grid, c){
    return { Xs:grid.Xs.slice(), Ys:grid.Ys.map(y=>2*c - y), Forced:grid.Forced?.slice()||[] };
  }
  function makeCand(Fbase, addGap){
    const opt2 = Object.assign({}, opts||{}, { gapMin: (opts?.gapMin||3) + (addGap? GAP_BUMP:0) });
    const G = genSecondaryGridPiecewiseShift(R, Fbase, opt2);
    return { F:Fbase, G,
      pGlobal:  scoreBalance(Fbase, G, false),
      pBetween: scoreBalance(Fbase, G, true)
    };
  }

  // ===== nouvelles tentatives jusqu'√† obtenir une vraie diff√©rence =====
  const tries = [];
  // v0 : original
  tries.push(makeCand(main, false));

  // variantes probables
  const mid = (R.ymin + R.ymax)/2;
  tries.push(makeCand(mirrorGridAround(main, 0),   true));
  tries.push(makeCand(mirrorGridAround(main, mid), true));

  // si besoin, r√©p√®te avec un gapMin plus costaud
  for(let bump=1; bump<=2; bump++){
    tries.push(makeCand(main, true));
  }

  // trie d'abord par √©quilibre "entre racines", puis global
  tries.sort((a,b)=>{
    const da = Math.abs(a.pBetween-0.5), db = Math.abs(b.pBetween-0.5);
    if(da!==db) return da-db;
    return Math.abs(a.pGlobal-0.5) - Math.abs(b.pGlobal-0.5);
  });

  // prends la premi√®re qui est suffisamment distincte ; sinon refabrique en miroir dur
 // pick the first candidate that is: overlapping, crossing, and distinct
  for (const t of tries){
    if (hasVerticalOverlap(t.F, t.G, 0.5) &&
        haveCrossings(t.F, t.G) &&
        curvesDistinctEnough(R, t.F, t.G, 0.8, 0.35)) {
      return t.G;
    }
  }

  // FINAL fallback: r√©essaye jusqu‚Äô√† obtenir overlap + croisement (borne dure)
  for (let t = 0; t < 40; t++){
    const retry = genSecondaryGridPiecewiseShift(
      R, main,
      { gapMin: Math.max(3, (opts?.gapMin || 3) + (t % 3)), maxShift: 999 }
    );
    if (hasVerticalOverlap(main, retry, 0.5) && haveCrossings(main, retry)) {
      return retry;
    }
  }

  // Derni√®re cartouche: comprimer autour du milieu puis reg√©n√©rer (√ßa force l‚Äôoverlap)
  const squeeze = y => Math.round((y - mid) * 0.65 + mid);
  const squeezedF = { Xs: main.Xs.slice(), Ys: main.Ys.map(squeeze), Forced: [] };
  const last = genSecondaryGridPiecewiseShift(R, squeezedF, { gapMin: 3, maxShift: 999 });
  // Si malgr√© tout √ßa reste s√©par√©, on pr√©f√®re encore renvoyer 'last' UNIQUEMENT s'il overlappe.
  if (hasVerticalOverlap(main, last, 0.5) && haveCrossings(main, last)) return last;

  // Si on arrive ici, on reprend la meilleure tentative ant√©rieure (tries[0]) m√™me si un poil d√©s√©quilibr√©e.
  return tries[0].G;


}




/**
 * Ajoute un petit texte (ex: "Cf", "Cg") dans un <g> SVG.
 */
function addText(g, x, y, txt, style){
  const t=document.createElementNS(g.namespaceURI,'text');
  t.setAttribute('x', x); t.setAttribute('y', y);
  t.textContent = txt;
  if(style) for(const k in style){ t.setAttribute(k, style[k]); }
  t.setAttribute('font-size','13'); t.setAttribute('font-weight','700');
  g.appendChild(t);
  return t;
}
/**
 * Place un label (texte) au voisinage d'un point de la courbe (grid),
 * choisi pour √™tre lisible (pas trop pr√®s du bord).
 */
function addCurveLabel(rep, R, grid, txt, color, opts = {}){
  // ‚Äî Choix de x : si demand√©, positionner √† x_min
  let x;
  if (opts.atXMin) {
    x = R.xmin; // exactement x_min de l‚Äôamplitude
  } else {
    const cand = [];
    for(let k=R.xmin+1; k<=Math.min(R.xmin+4, R.xmax-1); k++) cand.push(k);
    cand.push(Math.round((R.xmin + R.xmax)/2));
    x = cand.find(xx => {
      const y = gridVal(grid, xx);
      return y!=null && y > R.ymin+1 && y < R.ymax-1;
    });
    if(x == null) x = Math.round((R.xmin + R.xmax)/2);
  }
  const y = gridVal(grid, x);

  const g = document.createElementNS(rep.svg.namespaceURI, 'g');
  rep.plot.appendChild(g);

  // Si on est coll√© au bord gauche, d√©cale l√©ger vers l‚Äôint√©rieur
  const padIn = (opts.padIn != null ? opts.padIn : 8); // px
  const px = rep.X(x) + (opts.atXMin ? padIn : 0);
  const py = rep.Y(y);

  // Texte
  const t = document.createElementNS(rep.svg.namespaceURI, 'text');
  t.setAttribute('x', px);
  t.setAttribute('y', py);
  t.textContent = txt;
  t.setAttribute('fill', color);
  t.setAttribute('font-size', opts.fontSize || 13);
  t.setAttribute('font-weight', '700');
  t.setAttribute('text-anchor', opts.atXMin ? 'start' : 'middle');   // ‚Üê important
  t.setAttribute('dominant-baseline', 'central');
  t.setAttribute('stroke', '#fff');
  t.setAttribute('stroke-width', 3);
  t.setAttribute('stroke-opacity', 0.9);
  t.style.paintOrder = 'stroke';
  g.appendChild(t);

  // Fond arrondi semi-transparent
  const bb = t.getBBox();
  const padX = opts.padX ?? 6, padY = opts.padY ?? 2;
  const r = document.createElementNS(rep.svg.namespaceURI, 'rect');
  r.setAttribute('x', bb.x - padX);
  r.setAttribute('y', bb.y - padY);
  r.setAttribute('width',  bb.width  + 2*padX);
  r.setAttribute('height', bb.height + 2*padY);
  r.setAttribute('rx', opts.radius ?? 6);
  r.setAttribute('ry', opts.radius ?? 6);
  r.setAttribute('fill', opts.bg ?? '#fff');
  r.setAttribute('fill-opacity', opts.bgOpacity ?? 0.65);
  r.setAttribute('stroke', color);
  r.setAttribute('stroke-opacity', 0.6);
  r.setAttribute('stroke-width', 1);
  r.setAttribute('class', 'label-bg');
  g.insertBefore(r, t);

  return g;
}





/* ========================== EXERCICE 1 ========================== */
const ex1 = {
  id:'rg1',
  title:`Lecture graphique (x entiers)`,
  gen(){
    const R={...AMP};

    // nombre de questions demand√© par les s√©lecteurs
    const qImg = clamp(parseInt($('#cfg-img')?.value||2,10),1,10);
    const qAnt = 3;

    // pools d'entiers visibles
    const Xpool=[]; for(let x=R.xmin+1; x<=R.xmax-1; x++) Xpool.push(x);
    const Ypool=[]; for(let y=R.ymin+1; y<=R.ymax-1; y++) Ypool.push(y);

    let grid=null, Ximg=null, Yimg=null, Ysolv=null, yNone=null, Yask=null;

    outer: for(let attempt=0; attempt<300; attempt++){
      // 1) base grid
      grid = genCurveIntegerGrid(R, true);

      // 2) IMAGES ‚Äî choisir qImg abscisses enti√®res telles que les images soient toutes distinctes
      let okImg=false;
      for(let t=0; t<200; t++){
        const xs = uniq(shuffle(Xpool)).slice(0,qImg).sort((a,b)=>a-b);
        const ys = xs.map(x=>interpAtGrid(grid,x));
        const uniqY = uniq(ys,(a,b)=>Math.abs(a-b)<1e-9);
        if (uniqY.length===ys.length){ Ximg=xs; Yimg=ys; okImg=true; break; }
      }
      if(!okImg) continue;

      // 3) ANT√âC√âDENTS ‚Äî on veut (qAnt-1) y avec 1..3 solutions enti√®res + 1 y inexistant
      const wantAntPerY =  Math.min(3, 3);
      let okAnt=false, gForced=null, ysChosen=[];

      for(let t=0; t<400; t++){
        const ysTry = uniq(shuffle(Ypool)).slice(0, Math.max(0,qAnt-1));
        gForced = buildGridWithConstraints(R, wantAntPerY, ysTry);
        const allOk = ysTry.every(y=>{
          const A = antecedentsOfGrid(gForced, y);
          const Ai = A.filter(x=>Math.abs(x - Math.round(x))<1e-9);
          const An = A.filter(x=>Math.abs(x - Math.round(x))>=1e-9);
          return Ai.length>=1 && Ai.length<=3 && An.length===0;
        });
        if(allOk){ ysChosen = ysTry; okAnt=true; break; }
      }
      if(!okAnt) continue;

      // y inexistant
      const zeroInside = Ypool.filter(y => !ysChosen.includes(y) && antecedentsOfGrid(gForced, y).length===0);
      yNone = zeroInside.length ? zeroInside[0] : (Math.random()<0.5 ? (R.ymax+1) : (R.ymin-1));

      grid = gForced;
      Ysolv = ysChosen;
      Yask = [...Ysolv, yNone];
      break outer;
    }

    return { R, grid, Ximg, Yask };
  },

  render(host,st){
    const ui = mkRow(host);
const rep = buildRepereSVG({ xmin:st.R.xmin, xmax:st.R.xmax, ymin:st.R.ymin, ymax:st.R.ymax, grid:true, arrows:true });

let gridG = st.gridG || (st.gridG = buildBalancedSecondary(
  st.R, st.grid, { gapMin: 3, maxShift: 999 }   // ‚Üê gapMin un peu plus fort = alternance visuelle plus nette
));

// filet: si par malchance pas d'overlap/croisement, on reg√©n√®re 6 fois max
for (let t = 0;
     t < 6 && (!hasVerticalOverlap(st.grid, gridG, 0.5) || !haveCrossings(st.grid, gridG));
     t++){
  gridG = buildBalancedSecondary(st.R, st.grid, { gapMin: 3 + (t % 2), maxShift: 999 });
}
st.gridG = gridG;


const LVL_COLORS = ['#00897b','#ef6c00','#6a1b9a','#2e7d32','#ad1457','#283593'];

// --- Choix des niveaux s√ªrs kF et kG (solutions uniquement enti√®res) ---
let kF = pickSafeLevelsEq(st.grid,  st.R, 1)[0];
let kG = pickSafeLevelsEq(gridG,    st.R, 1)[0];

// petits filets de s√©curit√© si jamais la liste est vide
if (kF == null) kF = (st.Yask || []).find(y => levelHasOnlyIntegerSolutions(st.grid,  y));
if (kG == null) kG = (st.Yask || []).find(y => levelHasOnlyIntegerSolutions(gridG,    y));

st.kEqF = kF;
st.kEqG = kG;

const safeG = pickSafeLevelsEq(gridG, st.R, 3).filter(y => y !== kG);
const kLtG = safeG[0] != null ? safeG[0] : kG;   // pour g(x) < k
const kGeG = safeG[1] != null ? safeG[1] : kG;   // pour g(x) ‚â• k (si besoin)

// lisser Cf et Cg avec pentes nulles aux 2 n≈ìuds d‚Äôintersection
const pathF = pathFromGridSmooth(rep, Object.assign({}, st.grid, { Forced: (gridG.Forced||[]) }));
const pathG = pathFromGridSmooth(rep, Object.assign({}, gridG,    { Forced: (gridG.Forced||[]) }));

// Dessin
// 1) phrase au-dessus du graphique
const cap = document.createElement('div');
cap.className = 'graph-caption';
cap.innerHTML = 'On donne ci-dessous les courbes des fonctions : <br>\\(f\\) (en bleue) et \\(g\\) \\( \\) (en pointill√©s rouges).';
ui.st.appendChild(cap);
MJ(cap); // re-typeset MathJax pour ce noeud


// 2) courbes
addPath(rep.plot, pathF, { stroke:'#1f6feb', 'stroke-width':3.2 });                          // f
addPath(rep.plot, pathG, { stroke:'#d62728', 'stroke-width':3.2, 'stroke-dasharray':'6 5' }); // g

// 3) √©tiquettes ‚Äúsur‚Äù la courbe
addCurveLabel(rep, st.R, st.grid, 'Cf', '#1f6feb', { atXMin:true, padIn:8 });
addCurveLabel(rep, st.R, gridG,   'Cg', '#d62728', { atXMin:true, padIn:8 });

ui.st.appendChild(rep.svg);


  // √ânonc√© 100% LaTeX (y compris les nombres)
  let html = `
    <div class="qa">
      <div class="q">1.</div>
      <div class="a">Ensemble de d√©finition&nbsp;:&nbsp;<input id="aD" type="text"><span id="aDm" class="qmark"></span></div>
    </div>`;

  st.Ximg.forEach((x,i)=>{
    html += `
      <div class="qa">
        <div class="q">${i+2}.</div>
        <div class="a">Image de \\(${fmtFR(x)}\\)&nbsp; par la fonction \\(f\\):&nbsp;<input id="aI${i}" type="text"><span id="aI${i}m" class="qmark"></span></div>
      </div>`;
  });

// ==== Comparaisons f et g : exclusion par d√©faut si pas d'intersections enti√®res ====
// ==== Comparaisons f et g : bascule "flottant" si une seule intersection est non enti√®re ====
const F = st.grid, G = st.gridG;
const forcedFG = (G.Forced || F.Forced || []);
const Zint = intIntersections(F, G);              // √©galit√©s sur n≈ìuds entiers

// 1) y a-t-il un croisement √† l‚Äôint√©rieur d‚Äôun intervalle [i,i+1] ?
const hasInteriorCross = !noInteriorCross_STRICT(F.Ys, G.Ys, forcedFG);

// 2) ou bien des racines r√©elles, mais pas toutes sur des abscisses enti√®res ?
const rootsFG = realIntersectionsHermite(F, G, forcedFG);
const allRootsInteger = rootsFG.length > 0 && rootsFG.every(x => Math.abs(x - Math.round(x)) < 1e-6);

// -> Mode "flottant" s‚Äôil n‚Äôy a aucune intersection enti√®re OU si l‚Äôune d‚Äôelles est non enti√®re
const useFloatFG = (Zint.length === 0) || hasInteriorCross || !allRootsInteger;

// si tu veux exclure ces questions quand c‚Äôest non entier, laisse false :
const ALLOW_FLOAT_FG = false;
  // ---- Bloc "R√©soudre graphiquement" (r√©utilise les m√™mes y que pour les ant√©c√©dents) ----
  const YsIneq = (st.Yask||[]).filter(y => Number.isFinite(y)).slice(0,4); // 3‚Äì4 valeurs
  // garde en m√©moire ce qu'on pose comme questions
st.solverQ = [];

// a) f(x)=kF
if (st.kEqF != null) {
  st.solverQ.push({
    id: 'seF', kind: 'eqF', y: st.kEqF,
    label: `R√©soudre \\( f(x)=${fmtFR(st.kEqF)} \\)`
  });
}

// b) g(x)=kG  (‚ö†Ô∏è le label utilisait par erreur kF)
if (st.kEqG != null) {
  st.solverQ.push({
    id: 'seG', kind: 'eqG', y: st.kEqG,
    label: `R√©soudre \\( g(x)=${fmtFR(st.kEqG)} \\)`
  });
}

// c) f(x)=g(x)
// f(x) = g(x)
if (!useFloatFG || ALLOW_FLOAT_FG){
  st.solverQ.push({ id:'seFG', kind:'eqFG', floatOK:useFloatFG, label:`R√©soudre \\( f(x)=g(x) \\)` });
}

  // in√©quations avec les m√™mes y
  if (YsIneq[0]!=null) st.solverQ.push({ id:'sg1', kind:'geF', y:YsIneq[0], label:`R√©soudre \\( f(x)\\ge ${fmtFR(YsIneq[0])} \\)` });
  if (YsIneq[1]!=null) st.solverQ.push({ id:'slF', kind:'leF', y:YsIneq[1], label:`R√©soudre \\( f(x)\\le ${fmtFR(YsIneq[1])} \\)` });
  if (YsIneq[2]!=null) st.solverQ.push({ id:'slG', kind:'ltG', y:kLtG, label:`R√©soudre \\( g(x)\\lt ${fmtFR(kLtG)} \\)` });
  if (YsIneq[3]!=null) st.solverQ.push({ id:'sgG', kind:'geG', y:kGeG, label:`R√©soudre \\( g(x)\\ge ${fmtFR(kGeG)} \\)` });

  // comparaisons f et g
if (!useFloatFG || ALLOW_FLOAT_FG){
  st.solverQ.push({ id:'sFG1', kind:'geFG', floatOK:useFloatFG, label:`R√©soudre \\( f(x)\\ge g(x) \\)` });
}
  
 if (!useFloatFG || ALLOW_FLOAT_FG){
  st.solverQ.push({ id:'sFG2', kind:'ltFG', floatOK:useFloatFG, label:`R√©soudre \\( f(x)\\lt g(x) \\)` });
}

  // UI
  html += `<div style="margin:.6rem 0 .3rem;font-weight:700">R√©soudre graphiquement :</div>`;
  st.solverQ.forEach((q,ii)=>{
    const idx = 2 + st.Ximg.length  + ii ;
    const ph = (q.kind==='eqF'||q.kind==='eqG'||q.kind==='eqFG') ? 'ex. ‚àí4 ; 0 ; 3 ou ¬´ aucun ¬ª'
             : 'ex. [‚àí5 ; ‚àí2] ‚à™ [3 ; 6] ou ¬´ aucun ¬ª';
    html += `
      <div class="qa">
        <div class="q">${idx}.</div>
        <div class="a">${q.label}&nbsp;:&nbsp;
          <input id="${q.id}" type="text" placeholder="">
          <span id="${q.id}m" class="qmark"></span>
        </div>
      </div>`;
  });

  ui.form.innerHTML = html;

  // √âtat
  host.dataset.state = JSON.stringify(st);
  host.dataset.active = 'rg1';

  // Vider l‚Äôentr√©e du domaine
  (function(){ const aD = $('#aD',host); if (aD) aD.value=''; })();

  // === Couleurs inline compatibles LaTeX ===
  try{
    const paletteI = ['#1f77b4','#d62728','#2ca02c','#9467bd','#ff7f0e']; // images
    const paletteA = ['#17becf','#8c564b','#e377c2','#bcbd22','#7f7f7f']; // ant√©c√©dents


  }catch(e){ /* silencieux */ }
// Attribue une couleur aux questions y=k dans l‚Äô√©nonc√© (AUCUNE droite trac√©e ici)
const lvlQs = (st.solverQ||[]).filter(q => Number.isFinite(q.y));
lvlQs.forEach((q, idx) => {
  q.color = LVL_COLORS[idx % LVL_COLORS.length];
  const input = host.querySelector('#' + q.id);
  if (input && input.parentElement) {
    const a = input.parentElement;
    const needle = `${q.label}&nbsp;:&nbsp;`;
    const repl   = `<span style="color:${q.color};font-weight:700">${q.label}</span>&nbsp;:&nbsp;`;
    a.innerHTML = a.innerHTML.replace(needle, repl);
  }
});
// ‚Üí pas de addLine() / addText() ici

  // Typeset MathJax apr√®s injection et recoloration
  MJ(host);
  },

  solution(host,st){
const rep = host.querySelector('svg.repere');
if(!rep) return;                           // garde-fou
const plot = rep.querySelector('.plot');
 if(!plot) return;
    const frame = rep.querySelector('rect.frame');
if(!frame) return;

const axes = rep.querySelector('g.axes') || rep.querySelector('g'); // <-- AJOUT

    const mLeft = +frame.getAttribute('x');
    const mTop  = +frame.getAttribute('y');
    const W0    = +frame.getAttribute('width');
    const H0    = +frame.getAttribute('height');
    const X = x => mLeft + (x - st.R.xmin) * W0 / (st.R.xmax - st.R.xmin);
    const Y = y => mTop + H0 - (y - st.R.ymin) * H0 / (st.R.ymax - st.R.ymin);

    const hasXaxis = (st.R.ymin <= 0 && 0 <= st.R.ymax);
    const hasYaxis = (st.R.xmin <= 0 && 0 <= st.R.xmax);



// --- Droites y = k : visibles UNIQUEMENT en mode solution ---
const LVL_COLORS = ['#00897b','#ef6c00','#6a1b9a','#2e7d32','#ad1457','#283593'];

// Nettoyer un √©ventuel affichage pr√©c√©dent de la solution
plot.querySelectorAll('.lvl-line').forEach(n=>n.remove());
rep.querySelectorAll('.lvl-label').forEach(n=>n.remove());

// Questions de niveau (celles qui portent un nombre k)
const lvlQs = (st.solverQ||[]).filter(q => Number.isFinite(q.y));

lvlQs.forEach((q, idx) => {
  q.color = LVL_COLORS[idx % LVL_COLORS.length];

  // 1) droite horizontale y = k (dans le cadre)
  const line = addLine(plot, X(st.R.xmin), Y(q.y), X(st.R.xmax), Y(q.y), {
    stroke: q.color, 'stroke-width': 2, 'stroke-dasharray': '5 5', 'stroke-opacity': 0.9
  });
  line.classList.add('lvl-line');

  // 2) √©tiquette "y = k" √† droite
 // √©tiquette : utiliser "axes" au lieu de "rep.axes"
const lbl = addText(axes, X(st.R.xmax) - 10, Y(q.y) - 4, `y=${fmtFR(q.y)}`, {
  fill: q.color, 'text-anchor': 'end'
});
lbl.classList.add('lvl-label');
});
const colorize = (latex, q) =>
  (q && q.color) ? `<span style="color:${q.color};font-weight:700">${latex}</span>` : latex;


    // √âtapes en LaTeX
   // ‚Äî‚Äî‚Äî √âtapes en LaTeX (NUM√âROT√âES comme dans l‚Äô√©nonc√©) ‚Äî‚Äî‚Äî
const steps = [];

// 1) Domaine
steps.push(`1. Ensemble de d√©finition : \\([${fmtFR(st.R.xmin)}\\; ;\\; ${fmtFR(st.R.xmax)}]\\)`);

// 2..(1+nbImages) : images f(x)
st.Ximg.forEach((x,i)=>{
  const fx = fmtFR(interpAtGrid(st.grid,x));
  steps.push(`${2+i}. \\( \\) \\( f(${fmtFR(x)}) = ${fx} \\)`);
});

// Suite : bloc ‚ÄúR√©soudre graphiquement‚Äù
const F = st.grid, G = st.gridG;
const base = 2 + st.Ximg.length;  // m√™me point de d√©part que dans render()

(st.solverQ||[]).forEach((q,ii)=>{
  const no = base + ii;

  // √âquations
  if(q.kind==='eqF'){
    const R = rootsEqInt(F, q.y);
    const expr = `\\( \\)\\( f(x)=${fmtFR(q.y)} \\)`;
   steps.push(`${no}. \\( \\)${colorize(expr,q)} \\( \\): \\( \\)\\(S=\\)${tex(fmtSetTeX(R))}`);
  }
  else if(q.kind==='eqG'){
    const R = rootsEqInt(G, q.y);
    const expr = `\\( \\)\\( g(x)=${fmtFR(q.y)} \\)`;
   steps.push(`${no}. \\( \\)${colorize(expr,q)} \\( \\): \\( \\)\\(S=\\) ${tex(fmtSetTeX(R))}`);
  }
  else if(q.kind==='eqFG'){
  let X;
  if (q.floatOK){
    X = realIntersectionsHermite(F, G, F.Forced||G.Forced||[]);
  } else {
    X = F.Xs.map((_,i)=> (F.Ys[i]===G.Ys[i])?F.Xs[i]:null).filter(x=>x!=null);
  }
  const S = q.floatOK
    ? `\\{ ${X.map(v=>fmtFR(Math.round(v*10)/10)).join(' \\; ;\\; ')} \\}` // arrondi 0,1 en affichage
    : fmtSetTeX(X);
  steps.push(`${no}. \\( \\) \\( f(x)=g(x) \\) \\( \\): \\( \\)\\(S=\\) ${tex(S)}`);
}
  // In√©quations / comparaisons
  else if(q.kind==='geF'){
    const U = unionFromPredicate(st.R, x => gridVal(F,x) >= q.y, true);
     const expr = `\\( \\)\\( f(x)\\ge ${fmtFR(q.y)} \\)`;
   steps.push(`${no}. ${colorize(expr,q)} \\( \\): \\( \\)\\(S=\\) ${tex(unionFmtSmartTeX(U))}`);
  }
  else if(q.kind==='leF'){
    const U = unionFromPredicate(st.R, x => gridVal(F,x) <= q.y, true);
    const expr = `\\( \\)\\( f(x)\\le ${fmtFR(q.y)} \\)`;
   steps.push(`${no}. ${colorize(expr,q)} \\( \\): \\( \\)\\(S=\\) ${tex(unionFmtSmartTeX(U))}`);
  }
  else if(q.kind==='ltG'){
    const splits = st.gridG.Xs.filter((x,i)=> st.gridG.Ys[i] === q.y); // integers where g(x)=k
  const U = unionFromPredicate(st.R, x => gridVal(st.gridG,x) < q.y, true, splits);
    const expr = `\\( \\)\\( g(x)\\lt ${fmtFR(q.y)} \\)`;
   steps.push(`${no}. ${colorize(expr,q)} \\( \\): \\( \\)\\(S=\\)  ${tex(unionFmtSmartTeX(U))}`);
  }
  else if(q.kind==='geG'){
    const U = unionFromPredicate(st.R, x => gridVal(G,x) >= q.y, true);
    const expr = `\\( \\)\\( g(x)\\ge ${fmtFR(q.y)} \\)`;
   steps.push(`${no}. ${colorize(expr,q)} \\( \\): \\( \\)\\(S=\\) ${tex(unionFmtSmartTeX(U))}`);
  }
 else if(q.kind==='geFG'){
  let U;
  if (q.floatOK){
    U = unionFromPredicate(st.R, x => gridVal(F,x) >= gridVal(G,x), true, []); // pas de splits impos√©s
  } else {
    U = unionFromPredicate(st.R, x => gridVal(F,x) >= gridVal(G,x), true);
  }
  steps.push(`${no}. \\( \\) \\( f(x)\\ge g(x) \\) \\( \\): \\( \\)\\(S=\\) ${tex(unionFmtSmartTeX(U))}`);
}
  else if(q.kind==='ltFG'){
  let U;
  if (q.floatOK){
    U = unionFromPredicate(st.R, x => gridVal(F,x) < gridVal(G,x), true, []);  // continu
  } else {
    const splits = F.Xs.filter((x,i)=> F.Ys[i] === G.Ys[i]);                    // entiers
    U = unionFromPredicate(st.R, x => gridVal(F,x) < gridVal(G,x), true, splits);
  }
  steps.push(`${no}. \\( \\) \\( f(x)\\lt g(x) \\) \\( \\): \\( \\)\\(S=\\) ${tex(unionFmtSmartTeX(U))}`);
}
});




    showSteps(host, steps);
    MJ(host);
    document.body.classList.add('solution-active');
  },

  correct(host,st){
    clearMarks(host);
    let okAll=true;

    const v=$('#aD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
    const okDom=(v.length===2 && v[0]!=='' && v[1]!=='' ? (+v[0]===st.R.xmin && +v[1]===st.R.xmax) : true);
    $('#aDm',host).textContent = okDom?'‚úî':'‚úò'; $('#aDm',host).style.color=okDom?'#14532d':'#991b1b'; okAll&=okDom;

    st.Ximg.forEach((x,i)=>{
      const want=interpAtGrid(st.grid,x), got=parseInt($('#aI'+i,host).value.replace(/\u2212/g,'-').replace(',','.'),10);
      const ok=(String($('#aI'+i,host).value).trim()==='' ? true : (Number.isInteger(got)&&got===want));
      const m=$('#aI'+i+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });

    st.Yask.forEach((y,j)=>{
      const t=$('#aA'+j,host).value.trim().toLowerCase();
      const A=antecedentsOfGrid(st.grid,y).filter(v=>Math.abs(v-Math.round(v))<1e-9).map(v=>Math.round(v));
      let ok=false;
      if(!t || t==='aucun'){ ok=(A.length===0); }
      else{
        const L=uniq(parseListFR(t)).map(v=>Math.round(v));
        ok=(L.length===A.length) && L.every(v=>A.includes(v));
      }
      const m=$('#aA'+j+'m',host); m.textContent=ok?'‚úî':'‚úò'; m.style.color=ok?'#14532d':'#991b1b'; okAll&=ok;
    });

    (function(){
      const anyEmpty = Array.from(host.querySelectorAll('input[type="text"]')).some(i=>i.value.trim()==='');
      const okFlag = true;
    })();
	
	function rootsIntEq(grid, k){
  return grid.Xs.filter((x,i)=>grid.Ys[i]===k);
}




const solsF = rootsIntEq(st.grid,  st.kEqF);
const solsG = rootsIntEq(st.gridG, st.kEqG);
    // ---- contr√¥le du bloc "R√©soudre" ----
  

    return {ok:okAll,total:1};
  },

  reset(host){ host.querySelectorAll('input').forEach(i=>i.value=''); clearMarks(host); document.body.classList.remove('solution-active'); },

  pdfStatement(s){ return buildPDFStatementFromRender(ex1, s); }
};


/* ========== Registry & moteur ========== */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // expose for exo-pdf-kit
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function buildOne(){
  const sel=$("#exo-select"), host=$("#host"), def=REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  
  // Adjust antecedents selector limit depending on exercise (rg2 & rg4 -> max 3, others -> max 5)
  try{
    const ant = document.getElementById('cfg-ant');
    if(ant){
      const maxVal = (def.id==='rg2' || def.id==='rg4') ? 3 : 5;
      ant.setAttribute('max', String(maxVal));
      if(ant.tagName === 'SELECT'){
        Array.from(ant.options).forEach(op=>{
          const v = parseInt(op.value,10);
          if(v>maxVal) op.remove();
        });
        if(parseInt(ant.value||'0',10) > maxVal) ant.value = String(maxVal);
      } else {
        if(parseInt(ant.value||'0',10) > maxVal) ant.value = String(maxVal);
      }
    }
  }catch(e){ console && console.warn && console.warn('cfg-ant adjust failed', e); }
const st=def.gen?def.gen():{};
  host.dataset.state=JSON.stringify(st); host.dataset.active=def.id;
  def.render(host,st); 
  (function(){ let r=$('#res',host); if(!r){ r=document.createElement('div'); r.id='res'; host.appendChild(r);} })();
  (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = ('');
      $('#res',host).textContent = anyEmpty ? '' : okFlag;
    })();
  document.body.classList.remove('solution-active');
}

function check(){
  const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  let okAll=true, total=0, okCount=0;

  function mark(id, ok){
    const m = host.querySelector('#'+id);
    if(!m) return;
    m.textContent = ok ? '‚úî' : '‚úò';
    m.style.color = ok ? '#14532d' : '#991b1b';
  }
  function isEmpty(v){ return !v || v.trim()===''; }
  function normToken(tok){
    return tok.replace(/\u00A0/g,' ')  // NBSP -> space
              .replace(/\u2212/g,'-')  // Unicode minus -> hyphen
              .replace(/\s+/g,' ')     // collapse spaces
              .trim();
  }

  if(def.id==='rg2'){
    // domain (ensemble de d√©finition)
    const dRaw = ($('#bD',host)?.value||'');
    const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++;
      const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('bDm', okD); okAll &= okD; if(okD) okCount++;
    }

    // images
    (st.Ximg||[]).forEach((x,i)=>{
      const raw = ($('#bI'+i,host)?.value||'');
      const t = normToken(raw);
      if(isEmpty(t)) return;
      total++;
      const v = Math.round(interpAtGrid(st.grid, x)*10)/10;
      const ans = t.replace(',', '.'); // allow decimal comma
      const ok = Math.abs(parseFloat(ans) - v) <= 0.2;
      mark('bI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // antecedents ‚Äî semicolon-separated only; accept 'aucun'
    (st.Yask||[]).forEach((y,j)=>{
      const raw = ($('#bA'+j,host)?.value||'');
      const t = normToken(raw).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseFloat(s.replace(',', '.')));
        ok = (L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      mark('bA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  } else if(def.id==='rg1'){
    // domaine
    const dRaw = ($('#aD',host)?.value||'');
    const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++;
      const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('aDm', okD); okAll &= okD; if(okD) okCount++;
    }
    // images
    (st.Ximg||[]).forEach((x,i)=>{
      const raw = ($('#aI'+i,host)?.value||'');
      const t = normToken(raw);
      if(isEmpty(t)) return;
      total++;
      const ok = (parseInt(t,10)===interpAtGrid(st.grid,x));
      mark('aI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // antecedents ‚Äî semicolon only; accept 'aucun'
    (st.Yask||[]).forEach((y,j)=>{
      const raw = ($('#aA'+j,host)?.value||'');
      const t = normToken(raw).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v));
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseInt(s,10));
        ok = (L.length===A.length) && L.every(v=>A.includes(v));
      }
      mark('aA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
	
	// ===== R√©soudre graphiquement (Q4‚Ä¶): coche √† c√¥t√© de chaque r√©ponse =====
(st.solverQ||[]).forEach(q=>{
  const raw = ($('#'+q.id,host)?.value || '');
  const t = normToken(stripS(raw));
  if(!t) return;                    // vide = on ne compte pas
  total++;

  let ok = false;

  if(q.kind==='eqF'){                          // f(x)=k (entiers)
    const want = rootsEqInt(st.grid, q.y);     // entiers attendus
const got  = isNoSolToken(t) ? [] : uniq(parseListFR(t)).map(v=>Math.round(v));
    ok = (got.length===want.length) && got.every(v=>want.includes(v));
  }
  else if(q.kind==='eqG'){                     // g(x)=k (entiers)
    const want = rootsEqInt(st.gridG, q.y);
const got  = isNoSolToken(t) ? [] : uniq(parseListFR(t)).map(v=>Math.round(v));
    ok = (got.length===want.length) && got.every(v=>want.includes(v));
  }
  else if(q.kind==='eqFG'){                    // f(x)=g(x)
    if(q.floatOK){                             // cas non-entier : tol√©rance 0,2
      const want = realIntersectionsHermite(st.grid, st.gridG, st.grid.Forced||st.gridG.Forced||[]);
      if(isNoSolToken(t)){
  ok = (want.length === 0);
} else {
  const got  = uniq(t.replace(/,/g,'.').split(/[;:,]/)
                     .map(s=>parseFloat(s)).filter(Number.isFinite));
  ok = approxEqualList(got, want, 0.2);
}
    }else{                                     // entiers
      const want = st.grid.Xs.filter((x,i)=> st.grid.Ys[i]===st.gridG.Ys[i]);
      const got  = uniq(parseListFR(t)).map(v=>Math.round(v));
      ok = (got.length===want.length) && got.every(v=>want.includes(v));
    }
  }
  else{
    // In√©quations -> unions
    let want=[];
    if(q.kind==='geF')  want = unionFromPredicate(st.R, x=>gridVal(st.grid,  x) >= q.y, true);
    if(q.kind==='leF')  want = unionFromPredicate(st.R, x=>gridVal(st.grid,  x) <= q.y, true);
    if(q.kind==='ltG'){
      const splits = st.gridG.Xs.filter((x,i)=> st.gridG.Ys[i] === q.y);
      want = unionFromPredicate(st.R, x=>gridVal(st.gridG,x) < q.y, true, splits);
    }
    if(q.kind==='geG')  want = unionFromPredicate(st.R, x=>gridVal(st.gridG, x) >= q.y, true);
    if(q.kind==='geFG') want = unionFromPredicate(st.R, x=>gridVal(st.grid,  x) >= gridVal(st.gridG,x), true);
    if(q.kind==='ltFG'){
      const splits = st.grid.Xs.filter((x,i)=> st.grid.Ys[i] === st.gridG.Ys[i]); // entiers o√π f=g
      want = unionFromPredicate(st.R, x=>gridVal(st.grid,x) < gridVal(st.gridG,x), true, splits);
    }
    const got = parseUnionFR(t);
ok = (got !== null) && unionEqual(got, want);

  }

  const mk = $('#'+q.id+'m',host);
  mk.textContent = ok ? '‚úî' : '‚úò';
  mk.style.color = ok ? '#14532d' : '#991b1b';
  okAll &= ok; if(ok) okCount++;
});

  } 
  else if (def.id === 'rg3') {
  // Q1 ‚Äî mots attendus (tol√©rance accents/majuscules/pluriels/espaces)
  const xVal = ($('#c1x',host)?.value || '');
  const yVal = ($('#c1y',host)?.value || '');
  const { okX, okY } = ex3_validateQ1(st.th.id, xVal, yVal);
  if (!isEmpty(xVal)) { total++; mark('c1xm', okX); okAll &= okX; if (okX) okCount++; }
  if (!isEmpty(yVal)) { total++; mark('c1ym', okY); okAll &= okY; if (okY) okCount++; }

  // Q2 ‚Äî images ENTIERES projet√©es sur la grille (tol√©rance = ¬Ω pas vertical)
  const t2a = ($('#c2a',host)?.value || '').trim();
  const t2b = ($('#c2b',host)?.value || '').trim();
  const yTol = 0.5 * st.stepY;
  const toNum = s => { const n = parseFloat(String(s).replace(',','.')); return Number.isFinite(n) ? n : NaN; };

  if (!isEmpty(t2a)) {
    total++;
    const av = toNum(t2a);
    const ok = Number.isFinite(av) && Math.abs(av - st.y1Int) <= yTol;
    mark('c2am', ok); okAll &= ok; if (ok) okCount++;
  }
  if (!isEmpty(t2b)) {
    total++;
    const bv = toNum(t2b);
    const ok = Number.isFinite(bv) && Math.abs(bv - st.y2Int) <= yTol;
    mark('c2bm', ok); okAll &= ok; if (ok) okCount++;
  }

  // Q3 ‚Äî ant√©c√©dents ENTIERs (√©galit√© d‚Äôensembles)
  const t3 = ($('#c3a',host)?.value || '').trim();
  if (!isEmpty(t3)) {
    total++;
    const typed = parseNumberList(t3).map(n => Math.round(n));
    const expected = st.rootsInt.map(n => Math.round(n));
    const setEq = (A,B) => {
      if (A.length !== B.length) return false;
      const SA = new Set(A), SB = new Set(B);
      for (const v of SA) if (!SB.has(v)) return false;
      return true;
    };
    const ok = typed.length > 0 && setEq(typed, expected);
    mark('c3am', ok); okAll &= ok; if (ok) okCount++;
  }
}

else if(def.id==='rg4'){
    // domain
    const dRaw = ($('#dD',host)?.value||''); const d = normToken(dRaw);
    if(!isEmpty(d)){
      total++; const okD = checkDomainInput(d, st.R.xmin, st.R.xmax);
      mark('dDm', okD); okAll &= okD; if(okD) okCount++;
    }
    // table images (c1 / dI*)
    const fAt = x=>Math.round(interpAtGrid(st.grid,x)*10)/10;
    (st.Xs||[]).forEach((x,i)=>{
      const el = $('#dI'+i, host) || host.querySelectorAll('input.c1')[i];
      if(!el) return;
      const t = normToken(el.value);
      if(isEmpty(t)) return;
      total++;
      const ans = t.replace(',', '.');
      const ok = Math.abs(parseFloat(ans) - fAt(x)) <= 0.2;
      mark('dI'+i+'m', ok); okAll &= ok; if(ok) okCount++;
    });
    // table ant√©c√©dents (c2 / dA*) ‚Äî semicolon-only; accept 'aucun'
    (st.Ys||[]).forEach((y,j)=>{
      const el = $('#dA'+j, host) || host.querySelectorAll('input.c2')[j];
      if(!el) return;
      const t = normToken(el.value).toLowerCase();
      if(isEmpty(t)) return;
      total++;
      const A = antecedentsOfGrid(st.grid, y).map(v=>Math.round(v*10)/10);
      let ok=false;
      if(t==='aucun'){
        ok = (A.length===0);
      }else{
        const L = t.split(';').map(s=>normToken(s)).filter(Boolean).map(s=>parseFloat(s.replace(',', '.')));
        ok = (L.length===A.length) && L.every(u=>A.some(v=>Math.abs(u-v)<=0.2));
      }
      mark('dA'+j+'m', ok); okAll &= ok; if(ok) okCount++;
    });
  }

  // update global score (count only filled inputs)
  scoreTot += (total||1);
  scoreOK += (okCount||0);
  updateScore();
  document.body.classList.remove('solution-active');
}


function solution(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ const host=$("#host"); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; def.reset(host); scoreOK=0; scoreTot=0; updateScore(); }

/* ==== Init ==== */
document.addEventListener('DOMContentLoaded',()=>{
  $('#amp-apply').addEventListener('click',applyAMP);
  const sel=$("#exo-select"); REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change',buildOne);
  $("#btn-new").addEventListener('click', buildOne);      // Ex.3 : reste sur le th√®me courant
  $("#btn-check").addEventListener('click', check);
  $("#btn-solution").addEventListener('click', solution);
  $("#btn-reset").addEventListener('click', resetAll);
  sel.value=REGISTRY[0].id; buildOne(); updateScore();
});
})();
</script>

<script>

// === Helper for PDF: build statement HTML exactly like screen, then freeze rep√®re size to screen width ===
function buildPDFStatementFromRender(def, st){
  const tmp=document.createElement('div');
  def.render(tmp, st);
  const stEl = tmp.querySelector('.statement') || tmp;
  // remove interactive controls if any
  stEl.querySelectorAll('select,button,.optionline,.controls').forEach(el=>el.remove());
  // keep questions: replace inputs with a small square
  stEl.querySelectorAll('input[type="text"]').forEach(inp=>{
    const span=document.createElement('span'); span.textContent='‚ñ¢';
    inp.replaceWith(span);
  });
  // lock SVG size to on-screen statement width (base design is 560px)
  const wScreen = (document.querySelector('.statement svg.repere')?.getBoundingClientRect().width) || 560;
  stEl.querySelectorAll('svg.repere').forEach(svg=>{
    svg.style.width = Math.round(wScreen) + 'px';
    svg.style.height = 'auto';
    svg.style.maxWidth = 'none';
    svg.style.display = 'block';
    svg.style.margin = '.25rem auto';
  });
  return stEl.outerHTML;
}
</script>

<script>
/* ==== PDF ‚Äî Ex.1‚Üí4 : √ânonc√© 2 colonnes ; Ex.4 : tables sans inputs ==== */
window.addEventListener('load', function () {
  if (!(window.ExoPDF && ExoPDF.init)) return;

  ExoPDF.init({
    title: `Seconde ‚Äî Repr√©sentation graphique`,
    max: 50,
    lead: '',
    leadByDefId: { rg1:'', rg2:'', rg3:'', rg4:'', rg5:'' },
    mountAfterSelector: '.card.small',

    beforeRender(def, st, withSolutions){
      try{
        const isTarget = def && ['rg1','rg2','rg3','rg4'].includes(def.id);

        const mkTmp = () => {
          const tmp = document.createElement('div');
          Object.assign(tmp.style, { position:'fixed', left:'-10000px', top:'-10000px', width:'0', height:'0', overflow:'hidden' });
          document.body.appendChild(tmp);
          return tmp;
        };

        const freezeSVG = (root)=>{
          const wRef = (document.querySelector('.statement svg.repere')?.getBoundingClientRect().width) || 560;
          root.querySelectorAll('svg.repere').forEach(svg=>{
            svg.style.width = Math.round(wRef) + 'px';
            svg.style.height = 'auto';
            svg.style.maxWidth = 'none';
            svg.style.display = 'block';
            svg.style.margin = '.25rem auto';
          });
        };

  const TABLE_STYLE = `
  <style>
    /* Grille √©nonc√© en 2 colonnes */
    table.pdf-two-col{ width:100%; border-collapse:collapse; table-layout:fixed; }
    table.pdf-two-col th, table.pdf-two-col td{
      border:1px solid #000; vertical-align:top; padding:6px 8px;
    }
    .pdf-curves{ text-align:center; }

    /* Largeurs par d√©faut (Ex.1‚Äì3) */
    table.pdf-two-col col.curves{ width:42%; }
    table.pdf-two-col col.enonce{ width:58%; }

    /* Sp√©cifique Ex.4 (d√©j√† en place) */
    table.pdf-two-col.ex4 col.curves{ width:35%; }
    table.pdf-two-col.ex4 col.enonce{ width:65%; }

    /* ‚úÖ Tous exos : les courbes remplissent la colonne (√©cran + impression) */
    .pdf-curves svg.repere{
      width:100% !important;
      height:auto !important;
      max-width:100% !important;
      box-sizing:border-box;
      display:block;
      margin:.25rem auto;
    }
    @media print{
      .pdf-curves svg.repere{
        width:100% !important; height:auto !important; max-width:100% !important;
      }
    }

    /* Bordures noires pour tous les tableaux */
    .tbl{ border-collapse:collapse !important; }
    .tbl th,.tbl td{ border:1px solid #000 !important; }

    /* Ex.4 : tables plein-largeur dans la colonne (comme d√©j√† souhait√©) */
    table.pdf-two-col.ex4 .pdf-enonce .tbl{
      width:100% !important; table-layout:auto; font-size:12px;
    }
    table.pdf-two-col.ex4 .pdf-enonce .tbl th,
    table.pdf-two-col.ex4 .pdf-enonce .tbl td{
      padding:4px 6px; min-width:0; word-break:break-word;
    }
    table.pdf-two-col.ex4 .pdf-enonce .tbl-wrap{ transform:none !important; }
	table.pdf-two-col.ex4 .pdf-enonce .tbl-wrap{
    display: flex;               /* empile les tableaux verticalement */
    flex-direction: column;
    gap: 12px;                   /* ‚Üê espace entre les tableaux (ajuste si besoin) */
  }

  /* Fallback au cas o√π le wrapper ne serait pas pr√©sent */
  table.pdf-two-col.ex4 .pdf-enonce .tbl + .tbl{
    margin-top: 12px !important;
  }
  .pdf-solution .tbl{
    width:100% !important;
    max-width:100% !important;
    table-layout:auto;          /* laisse les colonnes s'√©tirer naturellement */
    font-size:14px;             /* ‚Üê agrandit le texte des tableaux en correction */
    border-collapse:collapse !important;
  }
  .pdf-solution .tbl th,
  .pdf-solution .tbl td{
    border:1px solid #000 !important;
    padding:6px 10px;           /* un peu plus d‚Äôair */
    min-width:0;                /* √©vite les d√©bordements */
    word-break:break-word;
  }

  /* Ex.4 seulement : titres un poil plus visibles dans la correction */
  .pdf-solution .tbl th{ font-weight:700; }
  </style>`;

const TILES_STYLE_RG5 = `
  <style>
    table.pdf-tiles { width:100%; border-collapse:collapse; table-layout:fixed; }
    table.pdf-tiles td { width:33.333%; border:1px solid #000; padding:8px; vertical-align:top; }
    .pdf-tiles .tile .title { text-align:center; font-weight:600; margin-bottom:6px; }
    .pdf-tiles svg.repere { width:100% !important; height:auto !important; display:block; margin:0 auto; }
    .pdf-tiles .tile.empty { min-height:120px; }
  </style>`;
        // supprime toutes les saisies (partout dans un sous-arbre)
        const stripInputs = (root)=>{
          root.querySelectorAll('input, textarea, select, button').forEach(n=>n.remove());
          root.querySelectorAll('.qmark').forEach(n=>n.remove());
        };
if (def && def.id === 'rg5') {
  const mkTmp = () => { const t=document.createElement('div'); Object.assign(t.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',overflow:'hidden'}); document.body.appendChild(t); return t; };

  const tmp = mkTmp();
  if (typeof def.render === 'function') def.render(tmp, st);
  if (withSolutions && typeof def.solution === 'function') { try{ def.solution(tmp, st); }catch(_){} }

  const minis = Array.from(tmp.querySelectorAll('.mini')).slice(0,5);

  const tileHTML = (miniEl)=>{
    const c = miniEl.cloneNode(true);
    const yn = c.querySelector('.yesno'); if (yn) (yn.closest('div') || yn).remove();
    const svg = c.querySelector('svg.repere'); if (svg){ svg.removeAttribute('width'); svg.removeAttribute('height'); svg.style.width='100%'; svg.style.height='auto'; }
    const title = c.querySelector('.title') ? c.querySelector('.title').outerHTML : '';
    const svgHTML = svg ? svg.outerHTML : '';
    return `<div class="tile">${title}${svgHTML}</div>`;
  };

  const cells = minis.map(tileHTML);
  while (cells.length < 6) cells.push('<div class="tile empty"></div>');

  const rows = `
    <tr>${cells.slice(0,3).map(h=>`<td>${h}</td>`).join('')}</tr>
    <tr>${cells.slice(3,6).map(h=>`<td>${h}</td>`).join('')}</tr>
  `;

  const tableHTML = `
    ${TILES_STYLE_RG5}
    <table class="pdf-tiles"><tbody>${rows}</tbody></table>
  `;

  const QUESTION_RG5 = `<div class="pdf-q">Pour chaque courbe, dire si elle repr√©sente une fonction.</div>`;

  tmp.remove();
  return withSolutions
    ? { solution: tableHTML }                       // corrig√© : m√™me grille, droites & badges d√©j√† trac√©s
    : { statement: QUESTION_RG5 + tableHTML };     // √©nonc√© : ajoute la question au-dessus
}
        if (!withSolutions && isTarget){
          // ===== √âNONC√â =====
          const tmp = mkTmp();
          if (typeof def.render==='function') def.render(tmp, st);

          // Colonne COURBES
          freezeSVG(tmp);
          const svgs = Array.from(tmp.querySelectorAll('.statement svg.repere, svg.repere'));
          // ‚úÖ Rendre les SVG responsive (√©crase largeur/hauteur fig√©es)
svgs.forEach(s=>{
  s.removeAttribute('width');
  s.removeAttribute('height');
  s.style.width = '100%';
  s.style.height = 'auto';
});
const curvesHTML = svgs.map(s=>s.outerHTML).join('');


          // Colonne √âNONC√â
          const right = document.createElement('div');

          // consigne
          const cons = tmp.querySelector('.consigne');
          if (cons) right.appendChild(cons.cloneNode(true));

          // EXERCICE 4 : cloner les tableaux ET ENLEVER LES INPUTS √† l'int√©rieur
          if (def.id==='rg4'){
            const wrap = document.createElement('div');
            tmp.querySelectorAll('.tbl').forEach(t => {
              const clone = t.cloneNode(true);
              // ‚ö†Ô∏è suppression totale des champs dans les cellules des tableaux
              clone.querySelectorAll('input, textarea, select, button').forEach(n=>n.remove());
              clone.querySelectorAll('.qmark').forEach(n=>n.remove());
              wrap.appendChild(clone);
            });
            // bloc pour mise √† l‚Äô√©chelle si besoin (CSS d√©j√† d√©fini)
            wrap.className = 'tbl-wrap';
            right.appendChild(wrap);
          }

          // questions (sans champs)
          const form = tmp.querySelector('.input-wrap');
          if (form){
            const clone = form.cloneNode(true);
            stripInputs(clone);
            right.appendChild(clone);
          }

          // Ex.3 : retirer le s√©lecteur de th√®me
          if (def.id === 'rg3') {
            right.querySelectorAll('#themeSel, select').forEach(n => n.remove());
          }

          const isEx4 = def.id==='rg4';
          const colgroup = isEx4 ? `<colgroup><col class="curves"><col class="enonce"></colgroup>` : '';
          const tableClass = 'pdf-two-col' + (isEx4 ? ' ex4' : '');

          const statementHTML = `
            ${TABLE_STYLE}
            <table class="${tableClass}">
              ${colgroup}
              <thead><tr><th>Courbes</th><th>√ânonc√©</th></tr></thead>
              <tbody>
                <tr>
                  <td class="pdf-curves">${curvesHTML||''}</td>
                  <td class="pdf-enonce">${right.innerHTML||''}</td>
                </tr>
              </tbody>
            </table>`;

          tmp.remove();
          return { statement: statementHTML };
        }

        if (withSolutions && isTarget){
          // ===== CORRIG√â : uniquement les √©tapes, sans courbes ni √©nonc√© =====
          const tmp = mkTmp();
          if (typeof def.render==='function') def.render(tmp, st);
          if (typeof def.solution==='function') def.solution(tmp, st);

          const steps = tmp.querySelector('.steps') || tmp.querySelector('.solution') || tmp.querySelector('#res') || tmp;
          const out = document.createElement('div');
          out.innerHTML = steps.outerHTML || steps.innerHTML;

          stripInputs(out);
          out.querySelectorAll('svg.repere').forEach(n=>n.remove());
          out.querySelectorAll('.tbl').forEach(t=>{
            t.style.borderCollapse = 'collapse';
            t.querySelectorAll('th,td').forEach(c=>{ c.style.border = '1px solid #000'; });
          });

          const solHTML = TABLE_STYLE + out.innerHTML;
          tmp.remove();
return { solution: TABLE_STYLE + '<div class="pdf-solution">' + solHTML + '</div>' };
        }

        // ===== Fallback autres exos =====
        const tmp = mkTmp();
        if (typeof def.render==='function') def.render(tmp, st);

        if (!withSolutions){
          stripInputs(tmp); freezeSVG(tmp);
          const html = tmp.innerHTML; tmp.remove();
          return { statement: html };
        }else{
          if (typeof def.solution==='function') def.solution(tmp, st);
          const steps = tmp.querySelector('.steps') || tmp;
          const out = document.createElement('div');
          out.innerHTML = steps.outerHTML || steps.innerHTML;
          stripInputs(out);
          out.querySelectorAll('.tbl').forEach(t=>{
            t.style.borderCollapse='collapse';
            t.querySelectorAll('th,td').forEach(c=>{ c.style.border='1px solid #000'; });
          });
          const html = TABLE_STYLE + out.innerHTML;
          tmp.remove();
return { solution: TABLE_STYLE + '<div class="pdf-solution">' + solHTML + '</div>' };
        }
      }catch(e){ /* fallback g√©r√© par le kit */ }
    },

    // (inchang√©) al√©as / amplitude / th√®mes
    beforeGen(def, st, ctx){
      try{
        const ampRnd = document.getElementById('pdfRandAmp')?.checked;
        const naRnd  = document.getElementById('pdfRandNA')?.checked;

        const xminEl=document.getElementById('xmin'), xmaxEl=document.getElementById('xmax');
        const yminEl=document.getElementById('ymin'), ymaxEl=document.getElementById('ymax');
        const imgEl = document.getElementById('cfg-img'), antEl=document.getElementById('cfg-ant');

        const thRnd = document.getElementById('pdfRandTheme')?.checked;
        if(def && def.id==='rg3'){
          if(thRnd){ window.__rg3_last_theme = null; }
          else{
            const sel = document.getElementById('themeSel');
            if(sel){ window.__rg3_last_theme = sel.value; }
          }
        }

        const save = {
          AMP: {...AMP},
          xmin: xminEl && xminEl.value, xmax: xmaxEl && xmaxEl.value,
          ymin: yminEl && yminEl.value, ymax: ymaxEl && ymaxEl.value,
          img: imgEl && imgEl.value, ant: antEl && antEl.value
        };

        const seed = (ctx && (ctx.index||0)) * 2654435761 ^ Date.now();
        let t = Math.imul(1779033703 ^ seed, 3432918353); t=(t<<13)|(t>>>19);
        function rng(){ t=Math.imul(t^(t>>>16),2246822507); t=Math.imul(t^(t>>>13),3266489909); t^=t>>>16; return (t>>>0)/4294967296; }
        function ri(a,b){ return a + Math.floor(rng()*(b-a+1)); }

        if (ampRnd){
          const xi = ri(-12, -2), xa = ri(2, 12);
          const yi = ri(-12, -2), ya = ri(2, 12);
          AMP = { xmin: Math.min(xi,xa), xmax: Math.max(xi,xa), ymin: Math.min(yi,ya), ymax: Math.max(yi,ya) };
          if (xminEl) xminEl.value = AMP.xmin;
          if (xmaxEl) xmaxEl.value = AMP.xmax;
          if (yminEl) yminEl.value = AMP.ymin;
          if (ymaxEl) yminEl.value = AMP.ymin;
        }

        if (naRnd && (def && (def.id==='rg1' || def.id==='rg2' || def.id==='rg4'))){
          const rImg = ri(2,10), rAnt = ri(2,10);
          if (imgEl) imgEl.value = String(rImg);
          if (antEl) antEl.value = String(rAnt);
        }

        return function restore(){
          AMP = save.AMP;
          if (xminEl) xminEl.value = save.xmin;
          if (xmaxEl) xmaxEl.value = save.xmax;
          if (yminEl) yminEl.value = save.ymin;
          if (ymaxEl) ymaxEl.value = save.ymax;
          if (imgEl) imgEl.value = save.img;
          if (antEl) antEl.value = save.ant;
        };
      }catch(e){ /* silent */ }
    }
  });
});
</script>





<script>
(function(){
  if(window.__patched_ex4) return;
  try{
    ex4.correct = function(host, st){
      const v=$('#dD',host).value.replace(/\s/g,'').replace(/\u2212/g,'-').replace(/[()[\]]/g,'').split(/[;:,]/);
      const okDom=(v.length===2 && +v[0]===st.R.xmin && +v[1]===st.R.xmax);
      $('#dDm',host).textContent = okDom?'‚úî':'‚úò';
      $('#dDm',host).style.color=okDom?'#14532d':'#991b1b';
      const c1 = Array.from(host.querySelectorAll('table input.c1'));
      const c2 = Array.from(host.querySelectorAll('table input.c2'));
      let okTables = true;
      c1.forEach((inp, idx)=>{
        const want = Math.round(interpAtGrid(st.grid, st.Xs[idx]) * 10)/10;
        const got  = Number(String(inp.value).replace(',', '.').replace(/\u2212/g,'-'));
        const ok = Number.isFinite(got) && Math.abs(got - want) < 0.15;
        inp.style.background = ok ? '#e6ffed' : '#ffecec';
        okTables = okTables && ok;
      });
      c2.forEach((inp, idx)=>{
        const wantA = antecedentsOfGrid(st.grid, st.Ys[idx]).map(v=>Math.round(v*10)/10);
        const gotA = (String(inp.value||'').trim().toLowerCase()==='aucun') ? [] :
                     Array.from(new Set(String(inp.value||'').replace(/[()[\]{}]/g,'').split(/[;:,]/)
                     .map(s=>Number(s.replace(',', '.').replace(/\u2212/g,'-'))).filter(n=>!isNaN(n)).map(n=>Math.round(n*10)/10)));
        const ok = wantA.length===gotA.length && wantA.every(v=>gotA.some(u=>Math.abs(u-v)<=0.2));
        inp.style.background = ok ? '#e6ffed' : '#ffecec';
        okTables = okTables && ok;
      });
      const allOk = okDom && okTables;
      (function(){
      const inputs = Array.from(host.querySelectorAll('input[type="text"]'));
      const anyEmpty = inputs.some(i=>i.value.trim()==='');
      const okFlag = (allOk ? '‚úî' : '‚úò');
      $('#res',host).textContent = okFlag ? (anyEmpty ? '' : '‚úî') : '‚úò';
    })();
      return {ok:allOk,total:1};
    };
    window.__patched_ex4 = true;
  }catch(e){}
})();
</script>
<script>
function checkDomainInput(str, xmin, xmax){
  try{
    if(str==null) return false;
    var s = String(str).replace(/\u00A0/g,' ').replace(/\u2212/g,'-');
    s = s.replace(/[\(\)\[\]]/g,'').replace(/\s+/g,'');
    var parts = s.split(/[;:,]/).filter(Boolean);
    if(parts.length!==2) return false;
    var a = parseFloat(parts[0].replace(',', '.'));
    var b = parseFloat(parts[1].replace(',', '.'));
    if(!isFinite(a) || !isFinite(b)) return false;
    return Math.abs(a - xmin) < 1e-9 && Math.abs(b - xmax) < 1e-9;
  }catch(e){ return false; }
}
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux (on d√©clenche .click() sur eux)
[['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');        // id doit rester unique
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    // fallback si jamais l‚Äôoriginal est absent (rare)
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    // Scroll au centre quand le clavier s‚Äôouvre
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>