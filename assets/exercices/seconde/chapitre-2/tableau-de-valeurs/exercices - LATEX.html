<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Seconde – Chapitre 2 – Tableau de valeurs (LaTeX)</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer}
.btn:hover{background:#efefef}
.score{font-weight:700}
.small{font-size:.92rem;color:#666}

/* Tableaux d’exercice */
.tbl{border-collapse:collapse;width:100%;margin:8px 0}
.tbl th,.tbl td{border:1px solid #e6e6e6;padding:8px 10px;text-align:center;vertical-align:top;position:relative}
.tbl input{width:100%;text-align:center;padding:.35rem .4rem;border:1px solid #ddd;border-radius:8px}
.pretty{display:none}
.cell-solved input{display:none}
.cell-solved .pretty{display:block}

/* Ticks ✓ / ✗ */
.tick{position:absolute;right:6px;top:6px;font-weight:700;font-size:14px;line-height:1;user-select:none}
.is-ok .tick{color:var(--ok,#11823b)}
.is-ko .tick{color:var(--ko,#b00020)}
.cell-solved .tick{display:none} /* on masque les ticks quand la solution est affichée */

/* PDF-only helper */
.pdf-only{display:none}
@media print{ .pdf-only{display:block} }

/* Zone Solution (corrigé) */
.steps{margin:.6rem 0 0 .1rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.solbox h4{margin:.2rem 0 .4rem 0;font-size:1rem}
.solbox table.tbl{margin-top:.2rem}

/* Tableau des détails — identique écran ↔ PDF (barres verticales noires + espacement) */
.sol-table{border-collapse:collapse;width:100%}
.sol-table td{
  border-left:3px solid #000;
  padding:.25rem 1rem;
  vertical-align:top;
}
.sol-table td:last-child{border-right:3px solid #000}
.sol-table tr+tr td{border-top:1px solid #e3e3e3}
</style>

<!-- MathJax -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']}
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde – Chapitre 2 – <strong>Tableau de valeurs</strong></h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
      <span id="status" class="small"></span>
    </div>

    <div class="card" id="host" aria-live="polite"></div>

    <div class="card small">
      <strong>Saisie :</strong>
      <ul style="margin:8px 0 0 18px">
        <li>Dans le tableau, écris uniquement le <code>nombre</code> (ou <code>ND</code> si non défini).</li>
        <li>Tu peux taper <code>a/b</code> ; en « Solution », les fractions s’affichent en \\(\\dfrac{a}{b}\\).</li>
        <li>Décimaux : virgule ou point ; le signe « − » est accepté.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<!-- libs -->
<script src="../../../../js/math-kbd.js" defer></script>
<script defer src="../../../../js/exo-pdf-kit.multiplicatif-latex.js"></script>

<script>
(function(){'use strict';

/* ===== utilitaires ===== */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const pick=a=>a[Math.floor(Math.random()*a.length)];
const shuffle=a=>a.sort(()=>Math.random()-.5);
const UMINUS='−';
const wrap = tex => `\\(${tex}\\)`;
function retypeset(scope){ try{ if(window.MathJax && MathJax.typesetPromise){ MathJax.typesetPromise([scope||document.getElementById('host')]); } }catch(_){} }
// helpers validation / score
const isBlank = s => String(s||'').trim()==='';

/* ===== rationnels / quotients (LaTeX) ===== */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function norm(p,q){ if(q===0) throw new Error('denominator 0'); let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; } return {p,q}; }
function makeR(p,q){ return norm(p,q||1); }

/* \dfrac{…}{…} avec signe séparé */
function fracTex(p,q){
  const neg=(p<0)!==(q<0); p=Math.abs(p); q=Math.abs(q);
  if(q===1) return (neg?UMINUS:'')+String(p);
  return (neg?UMINUS:'') + `\\dfrac{${p}}{${q}}`;
}
function Q(numTex, denTex){
  const d=String(denTex).trim();
  return (d==='1') ? numTex : `\\dfrac{${numTex}}{${denTex}}`;
}
function toTexNumber(val){
  if(val===null) return '\\mathrm{ND}';
  if(typeof val==='number'){
    const k=1000, num=Math.round(val*k);
    if(Math.abs(num/k - val) <= 1e-9){
      const r=norm(num,k);
      return fracTex(r.p,r.q);
    }
    return String(val);
  }
  const r=norm(val.p,val.q);
  return fracTex(r.p,r.q);
}

/* ===== parsing cellule & comparaison ===== */
function parseCell(s){
  const t=String(s||'').trim().replace(/\u2212/g,'-').replace(/,/,'.');
  if(/^nd$/i.test(t)) return {type:'nd'};
  const m=t.match(/^([-+]?\d+)\s*\/\s*([-+]?\d+)$/);
  if(m){ const p=+m[1], q=+m[2]; if(q!==0) return {type:'rat', p, q}; }
  const v=Number(t); if(Number.isFinite(v)) return {type:'real', v};
  return null;
}
function eqVal(given, expected){
  if(expected===null) return /^nd$/i.test(String(given||'').trim());
  const g=parseCell(given); if(!g) return false;
  const ex=(typeof expected==='number')? expected : expected.p/expected.q;
  if(g.type==='nd') return expected===null;
  if(g.type==='real') return Math.abs(g.v-ex)<=1e-9;
  if(g.type==='rat'){ const G=gcd(g.p,g.q); const p=g.p/G,q=g.q/G; return Math.abs(p/q-ex)<=1e-9; }
  return false;
}

/* ===== affichage — ENONCÉS (texte + LaTeX pour f) ===== */
const signStr = v => v>=0 ? ' + ' : ' − ';
function termAxTex(a){ if(a===1) return 'x'; if(a===-1) return UMINUS+'x'; return String(a)+'x'; }
function termAx2Tex(a){ if(a===1) return 'x^{2}'; if(a===-1) return UMINUS+'x^{2}'; return String(a)+'x^{2}'; }
function fmtAffineLatex(a,b){ let s = termAxTex(a); if(b!==0) s += signStr(b) + Math.abs(b); return s; }
function fmtQuadLatex(a,b,c){ let s = termAx2Tex(a); if(b!==0) s += signStr(b) + Math.abs(b) + 'x'; if(c!==0) s += signStr(c) + Math.abs(c); return s; }
function fmtLinNoTimesTex(a,b){ let s = (a!==0)? termAxTex(a) : ''; if(b!==0){ s += (s? signStr(b) : (b<0? UMINUS+' ' : '')) + Math.abs(b); } return s || '0'; }

/* ===== affichage — CALCULS ===== */
const pDisp = n => n<0 ? `(${UMINUS}${Math.abs(n)})` : String(n);
const nDisp = n => n<0 ? `${UMINUS}${Math.abs(n)}` : String(n);
function mulStr(a, s){ if(a===1) return s; if(a===-1) return UMINUS+s; return a+'×'+s; }
function monoAx(a){ return (a===1)?'x' : (a===-1? UMINUS+'x' : a+'x'); }
function joinTerms(first, ...rest){ let out = first || ''; for(const t of rest){ if(!t || !t.text) continue; out += (t.sign>0?' + ':' − ')+t.text; } return out || '0'; }

/* ===== helpers tableaux (inputs + ticks) ===== */
function ensureTick(td){
  let t = td.querySelector('.tick');
  if(!t){ t = document.createElement('span'); t.className='tick'; t.setAttribute('aria-hidden','true'); td.appendChild(t); }
  return t;
}
function clearTick(td){
  td.classList.remove('is-ok','is-ko');
  const t = td.querySelector('.tick'); if(t) t.textContent='';
}

function buildFxTable(model){
  const th = model.xs.map(x=>`<th>${wrap(toTexNumber(x))}</th>`).join('');
  const row = model.rows.map(r=>`<td><div class="pretty"></div><input data-id="${r.id}" inputmode="text" autocomplete="off"><span class="tick"></span></td>`).join('');
  return `<table class="tbl"><thead><tr><th>${wrap('x')}</th>${th}</tr></thead><tbody><tr><td>${wrap('f(x)')}</td>${row}</tr></tbody></table>`;
}
function buildXTable(model){
  const th = model.rows.map(r=>`<th><div class="pretty"></div><input data-id="${r.id}" inputmode="text" autocomplete="off"><span class="tick"></span></th>`).join('');
  const fy = model.ys.map(y=>`<td>${wrap(toTexNumber(y))}</td>`).join('');
  return `<table class="tbl"><thead><tr><th>${wrap('x')}</th>${th}</tr></thead><tbody><tr><td>${wrap('f(x)')}</td>${fy}</tr></tbody></table>`;
}

/* ===== tableaux corrigés (statique, pour la zone Solution) ===== */
function buildSolvedFxTable(s){
  const th = s.xs.map(x=>`<th>${wrap(toTexNumber(x))}</th>`).join('');
  const tds = s.rows.map(r=>`<td>${wrap(toTexNumber(r.val))}</td>`).join('');
  return `<div class="solbox"><h4>Tableau corrigé</h4>
  <table class="tbl"><thead><tr><th>${wrap('x')}</th>${th}</tr></thead>
  <tbody><tr><td>${wrap('f(x)')}</td>${tds}</tr></tbody></table></div>`;
}
function buildSolvedXTable(s){
  // entête = x (solutions), corps = f(x) (valeurs données)
  const th = s.rows.map(r=>`<th>${wrap(toTexNumber(r.val))}</th>`).join('');
  const fy = s.ys.map(y=>`<td>${wrap(toTexNumber(y))}</td>`).join('');
  return `<div class="solbox"><h4>Tableau corrigé</h4>
  <table class="tbl"><thead><tr><th>${wrap('x')}</th>${th}</tr></thead>
  <tbody><tr><td>${wrap('f(x)')}</td>${fy}</tr></tbody></table></div>`;
}

/* ===== rendu “pretty” (solution interactive) ===== */
function showPrettyInCell(container, tex){
  const td = container.closest('td,th'); if(!td) return;
  td.classList.add('cell-solved');
  const box = td.querySelector('.pretty') || (()=>{ const d=document.createElement('div'); d.className='pretty'; td.prepend(d); return d; })();
  box.innerHTML = wrap(tex);
  retypeset(td);
}
function clearPretty(host){ host.querySelectorAll('.cell-solved').forEach(td=>td.classList.remove('cell-solved')); }

/* ===== validation avec ticks ===== */
function expectedById(s, id){
  const r = (s.rows||[]).find(r=>r.id===id);
  return r ? r.val : undefined;
}
function gradeOneInput(inp, expected){
  const td = inp.closest('td,th'); if(!td) return {graded:false, ok:false};
  const raw = inp.value;
  if(isBlank(raw)){ clearTick(td); return {graded:false, ok:false}; }
  const okOne = (expected===null) ? /^nd$/i.test(raw.trim()) : eqVal(raw, expected);
  td.classList.toggle('is-ok', okOne);
  td.classList.toggle('is-ko', !okOne);
  ensureTick(td).textContent = okOne ? '✓' : '✗';
  return {graded:true, ok:okOne};
}
function gradeAllInHost(host, s){
  let ok=0,total=0;
  host.querySelectorAll('input[data-id]').forEach(inp=>{
    const exp = expectedById(s, inp.dataset.id);
    const r = gradeOneInput(inp, exp);
    if(r.graded){ total++; if(r.ok) ok++; }
  });
  $('#score').textContent = `${ok} / ${total}`;
  return {ok,total};
}

/* ===== tableau des détails (styles inline → écran = PDF) ===== */
function detailsTable(columns){
  const height = Math.max(...columns.map(col=>col.length));
  const ncol = columns.length;
  const base = 'border-left:3px solid #000;padding:.25rem 1rem;vertical-align:top;border-top:1px solid #e3e3e3;';
  const rows=[];
  for(let r=0;r<height;r++){
    let tds='';
    for(let c=0;c<ncol;c++){
      const right = (c===ncol-1)?'border-right:3px solid #000;':'';
      const html = (columns[c][r]||'').replace(/\n/g,'<br>');
      tds += `<td style="${base}${right}">${html}</td>`;
    }
    rows.push(`<tr>${tds}</tr>`);
  }
  return `<table class="sol-table" style="border-collapse:collapse;width:100%"><tbody>${rows.join('')}</tbody></table>`;
}

/* ===== déduplication ===== */
function _normDedup(s){ return String(s??'').replace(/-/g, UMINUS).replace(/\s+/g,' ').trim(); }
function dedupeConsecutive(lines){
  const out=[]; let prev=null;
  for(const L of lines){
    const N=_normDedup(L);
    if(prev!==null && N===prev) continue;
    out.push(L);
    prev=N;
  }
  return out;
}
function dedupeTail(lines){
  for (let i=lines.length-1;i>0;i--){
    if(_normDedup(lines[i])===_normDedup(lines[i-1])) lines.splice(i,1); else break;
  }
  return lines;
}
function dedupeAll(lines){ return dedupeTail(dedupeConsecutive(lines)); }

/* ===== construit le tableau d’ÉNONCÉ vide (PDF-only) ===== */
function insertEnoncePDFTable(host){
  host.querySelectorAll('.enonce-pdf-table').forEach(n=>n.remove());
  const src = host.querySelector('.tbl');
  const equ = host.querySelector('.equ');
  if(!src || !equ) return;

  const clone = src.cloneNode(true);
  // vide les réponses
  clone.querySelectorAll('input').forEach(inp=>inp.remove());
  clone.querySelectorAll('.pretty').forEach(p=>p.remove());
  clone.querySelectorAll('.cell-solved').forEach(td=>td.classList.remove('cell-solved'));
  clone.querySelectorAll('.tick').forEach(t=>t.remove()); // pas de ticks dans l’énoncé PDF
  // styles inline pour contours visibles dans le PDF
  clone.style.borderCollapse='collapse';
  clone.style.width='100%';
  clone.style.tableLayout='fixed';
  clone.style.border='2px solid #000';
  clone.querySelectorAll('th,td').forEach(cell=>{
    cell.style.border='1px solid #000';
    cell.style.padding='8px 10px';
    cell.style.textAlign='center';
    cell.style.verticalAlign='top';
  });

  const wrapDiv = document.createElement('div');
  wrapDiv.className='pdf-only enonce-pdf-table';
  wrapDiv.style.margin='6px 0 10px 0';
  wrapDiv.appendChild(clone);
  equ.appendChild(wrapDiv);
}
function insertSolutionPDFTable(host, s, mode){
  // Nettoie les anciennes versions
  host.querySelectorAll('.solution-pdf-table').forEach(n=>n.remove());

 // on vise la table interactive (celle juste après .equ), pour garder le même gabarit
 const src = host.querySelector('.equ + .tbl') || host.querySelector('.tbl');
  const steps = host.querySelector('#steps');
  if(!src || !steps) return;

  // Clone structure pour garder exactement le même gabarit/largeur
  const clone = src.cloneNode(true);

  // Retire tout l'interactif
  clone.querySelectorAll('input,.pretty,.tick').forEach(el=>el.remove());
  clone.querySelectorAll('.cell-solved').forEach(td=>td.classList.remove('cell-solved'));

  // Styles inline (mêmes que l’énoncé) → largeur identique + bordures noires
  clone.style.borderCollapse='collapse';
  clone.style.width='100%';
  clone.style.tableLayout='fixed';
  clone.style.border='2px solid #000';
  clone.querySelectorAll('th,td').forEach(cell=>{
    cell.style.border='1px solid #000';
    cell.style.padding='8px 10px';
    cell.style.textAlign='center';
    cell.style.verticalAlign='top';
  });

  // Remplissage des valeurs corrigées
  if(mode==='fx'){
    // en-têtes x conservés ; on remplit la ligne f(x)
    const tds = clone.querySelectorAll('tbody tr td');
    for(let i=1;i<tds.length;i++){
      const v = s.rows[i-1].val; // valeur f(x_i)
      tds[i].innerHTML = wrap(toTexNumber(v));
    }
  }else if(mode==='x'){
    // on met les x (solutions) dans l'en-tête ; la ligne f(x) = y est fixe
    const ths = clone.querySelectorAll('thead tr th');
    for(let i=1;i<ths.length;i++){
      ths[i].innerHTML = wrap(toTexNumber(s.rows[i-1].val)); // x_i
    }
    const tds = clone.querySelectorAll('tbody tr td');
    for(let i=1;i<tds.length;i++){
      tds[i].innerHTML = wrap(toTexNumber(s.ys[i-1])); // y_i donnés
    }
  }

  // Conteneur PDF-only
  const wrapDiv = document.createElement('div');
  wrapDiv.className='pdf-only solution-pdf-table';
  wrapDiv.style.margin='10px 0';

  const title = document.createElement('div');
  title.textContent = 'Tableau corrigé';
  title.style.fontWeight = '600';
  title.style.margin = '6px 0 6px 0';

  wrapDiv.appendChild(title);
  wrapDiv.appendChild(clone);
  steps.prepend(wrapDiv); // avant les étapes détaillées

  retypeset(wrapDiv);
}

/* ===== EXERCICES ===== */

/* TV1 — f(x)=ax+b → f(x) */
const exTV1 = {
  id:'tv_affine_fx', title:'Tableau : f(x)=ax+b → f(x)',
  gen(){
    let a=0; while(a===0) a=rnd(-5,5); const b=rnd(-8,8);
    const xs=shuffle([-3,-2,-1,0,1,2,3,4,5]).slice(0,5).sort((x,y)=>x-y);
    const rows=xs.map((x,i)=>({x, id:'y'+i, val: a*x + b}));
    return {a,b,xs,rows};
  },
  render(host,s){
    const fTex = 'f(x) = ' + fmtAffineLatex(s.a,s.b);
    host.innerHTML =
      '<div class="equ">Soit ' + wrap(fTex) + '. Compléter le tableau :</div>'
    + buildFxTable(s)
    + '<div class="steps" id="steps"></div>';
    insertEnoncePDFTable(host);
    retypeset(host);

    // Entrée → valider seulement la case courante
    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown',e=>{
        if(e.key==='Enter'){ e.preventDefault();
          const exp = expectedById(s, inp.dataset.id);
          gradeOneInput(inp, exp);
          gradeAllInHost(host, s); // maj score
        }
      });
    });
  },
  correct(host,s){
    return gradeAllInHost(host, s); // ignore les vides
  },
  solution(host,s){
    // 1) Ne rien remplir dans la table interactive : on nettoie juste les ticks
    host.querySelectorAll('td,th').forEach(c=>clearTick(c));
    // 2) Ajouter le tableau corrigé + les étapes
    const solved = buildSolvedFxTable(s);

    const cols = s.rows.map(r=>{
      const left = `f(${nDisp(r.x)})`;
      const L0 = wrap('f(x) = '+fmtAffineLatex(s.a,s.b));
      const L1 = '';
      const L2 = wrap(left + ' = ' + (s.b!==0 ? (mulStr(s.a, pDisp(r.x)) + (s.b>0?' + ':' − ') + Math.abs(s.b)) : mulStr(s.a, pDisp(r.x))));
      const prod = s.a*r.x;
      const L3 = wrap(left + ' = ' + (s.b!==0 ? (nDisp(prod) + (s.b>0?' + ':' − ') + Math.abs(s.b)) : nDisp(prod)));
      const L4 = wrap(left + ' = ' + nDisp(prod + s.b));
      return dedupeAll([L0,L1,L2,L3,L4]);
    });

    $('#steps',host).innerHTML =  detailsTable(cols);
	insertSolutionPDFTable(host, s, 'fx');
    retypeset(host);
  },
  reset(host){
    host.querySelectorAll('input').forEach(i=>i.value='');
    host.querySelectorAll('td,th').forEach(c=>c.classList.remove('is-ok','is-ko','cell-solved'));
    host.querySelectorAll('.tick').forEach(t=>t.textContent='');
    clearPretty(host); $('#steps',host).innerHTML=''; insertEnoncePDFTable(host); retypeset(host);
  }
};

/* TV2 — f(x)=ax²+bx+c → f(x) */
const exTV2 = {
  id:'tv_quad_fx', title:'Tableau : f(x)=ax²+bx+c → f(x)',
  gen(){
    const a = pick([-2,-1,1,2]); const b=rnd(-4,4), c=rnd(-6,6);
    const xs=shuffle([-3,-2,-1,0,1,2,3]).slice(0,5).sort((x,y)=>x-y);
    const rows=xs.map((x,i)=>({x, id:'y'+i, val: a*x*x + b*x + c}));
    return {a,b,c,xs,rows};
  },
  render(host,s){
    const head = 'f(x) = ' + fmtQuadLatex(s.a,s.b,s.c);
    host.innerHTML =
      '<div class="equ">Soit ' + wrap(head) + '. Compléter le tableau :</div>'
    + buildFxTable(s)
    + '<div class="steps" id="steps"></div>';
    insertEnoncePDFTable(host);
    retypeset(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown',e=>{
        if(e.key==='Enter'){ e.preventDefault();
          const exp = expectedById(s, inp.dataset.id);
          gradeOneInput(inp, exp);
          gradeAllInHost(host, s);
        }
      });
    });
  },
  correct(host,s){ return gradeAllInHost(host, s); },
  solution(host,s){
    host.querySelectorAll('td,th').forEach(c=>clearTick(c));
    const solved = buildSolvedFxTable(s);

    const cols = s.rows.map(r=>{
      const x=r.x, left=`f(${nDisp(x)})`;
      const L0 = wrap('f(x) = '+fmtQuadLatex(s.a,s.b,s.c));
      const L1 = '';
      const L2 = wrap(left + ' = ' + joinTerms(
        mulStr(s.a, pDisp(x)+'^{2}'),
        (s.b!==0 ? {sign:Math.sign(s.b), text:Math.abs(s.b)+'×'+pDisp(x)} : null),
        (s.c!==0 ? {sign:Math.sign(s.c), text:String(Math.abs(s.c))} : null)
      ));
      const x2 = x*x, bx = s.b*x;
      const L3 = wrap(left + ' = ' + joinTerms(
        mulStr(s.a, String(x2)),
        (bx!==0 ? {sign:Math.sign(bx), text:String(Math.abs(bx))} : null),
        (s.c!==0 ? {sign:Math.sign(s.c), text:String(Math.abs(s.c))} : null)
      ));
      const sc = bx + s.c;
      const L4 = wrap(left + ' = ' + joinTerms(
        mulStr(s.a, String(x2)),
        (sc!==0 ? {sign:Math.sign(sc), text:String(Math.abs(sc))} : null)
      ));
      const ax2 = s.a*x2;
      const L5 = wrap(left + ' = ' + joinTerms(
        nDisp(ax2),
        (sc!==0 ? {sign:Math.sign(sc), text:String(Math.abs(sc))} : null)
      ));
      const L6 = wrap(left + ' = ' + nDisp(ax2 + sc));
      return dedupeAll([L0,L1,L2,L3,L4,L5,L6]);
    });

    $('#steps',host).innerHTML =  detailsTable(cols);
	insertSolutionPDFTable(host, s, 'fx');
    retypeset(host);
  },
  reset(host){
    host.querySelectorAll('input').forEach(i=>i.value='');
    host.querySelectorAll('td,th').forEach(c=>c.classList.remove('is-ok','is-ko','cell-solved'));
    host.querySelectorAll('.tick').forEach(t=>t.textContent='');
    clearPretty(host); $('#steps',host).innerHTML=''; insertEnoncePDFTable(host); retypeset(host);
  }
};

/* TV3 — f(x)=(ax+b)/(cx+d) → f(x) (ND possible) */
const exTV3 = {
  id:'tv_homo_fx', title:'Tableau : f(x)=(ax+b)/(cx+d) → f(x) (ND possible)',
  gen(){
    let c=0; while(c===0) c=rnd(-3,3);
    const CAND=[-4,-3,-2,-1,0,1,2,3,4,5];
    const xPole = pick(CAND);
    const d = -c * xPole;
    const a=rnd(-4,4), b=rnd(-6,6);
    const others = shuffle(CAND.filter(x=>x!==xPole)).slice(0,4);
    const xs = [...others, xPole].sort((x,y)=>x-y);
    const rows = xs.map((x,i)=>{
      if(x===xPole) return {x, id:'y'+i, val:null};
      const den=c*x+d;
      const num=a*x+b, g=gcd(num,den);
      return {x, id:'y'+i, val:{p:num/g,q:den/g}};
    });
    return {a,b,c,d,xs,rows};
  },
  render(host,s){
    const N = fmtLinNoTimesTex(s.a,s.b);
    const D = fmtLinNoTimesTex(s.c,s.d);
    const fTex = 'f(x) = ' + Q(N,D);
    host.innerHTML =
      '<div class="equ">Soit ' + wrap(fTex) + '. Compléter le tableau <em>(écrire ND si nécessaire)</em> :</div>'
    + buildFxTable(s)
    + '<div class="steps" id="steps"></div>';
    insertEnoncePDFTable(host);
    retypeset(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown',e=>{
        if(e.key==='Enter'){ e.preventDefault();
          const exp = expectedById(s, inp.dataset.id);
          gradeOneInput(inp, exp);
          gradeAllInHost(host, s);
        }
      });
    });
  },
  correct(host,s){ return gradeAllInHost(host, s); },
  solution(host,s){
    host.querySelectorAll('td,th').forEach(c=>clearTick(c));
    const solved = buildSolvedFxTable(s);

    const cols = s.rows.map(r=>{
      const x=r.x, left = `f(${nDisp(x)})`;
      if(r.val===null){
        const sub = (s.c!==0? s.c+'×'+pDisp(x) : '0') + (s.d!==0 ? (s.d>0?' + ':' − ') + Math.abs(s.d) : '');
        const L1 = wrap(`\\text{Pour }x=${nDisp(x)}\\, :\\; ${sub} = 0`);
        const L2 = `Conclusion : ${wrap(left)} est non définie (ND).`;
        return [L1,L2];
      }else{
        const p=s.a*x+s.b, q=s.c*x+s.d, nn=norm(p,q);
        const L0 = wrap('f(x) = '+Q(fmtLinNoTimesTex(s.a,s.b), fmtLinNoTimesTex(s.c,s.d)));
        const L1 = '';
        const numSub = (s.a!==0? s.a+'×'+pDisp(x) : (s.b===0?'0':'')) + (s.b!==0? (s.a!==0? signStr(s.b): (s.b<0?' − ':' + ')) + Math.abs(s.b) : '');
        const denSub = (s.c!==0? s.c+'×'+pDisp(x) : (s.d===0?'0':'')) + (s.d!==0? (s.c!==0? signStr(s.d): (s.d<0?' − ':' + ')) + Math.abs(s.d) : '');
        const L2 = wrap(`${left} = ${Q(numSub, denSub)}`);
        const L3 = wrap(`${left} = ${Q(String(p), String(q))}`);
        const L4 = wrap(`${left} = ${toTexNumber(nn)}`);
        return dedupeAll([L0,L1,L2,L3,L4]);
      }
    });

    $('#steps',host).innerHTML =  detailsTable(cols);
	insertSolutionPDFTable(host, s, 'fx');
    retypeset(host);
  },
  reset(host){
    host.querySelectorAll('input').forEach(i=>i.value='');
    host.querySelectorAll('td,th').forEach(c=>c.classList.remove('is-ok','is-ko','cell-solved'));
    host.querySelectorAll('.tick').forEach(t=>t.textContent='');
    clearPretty(host); $('#steps',host).innerHTML=''; insertEnoncePDFTable(host); retypeset(host);
  }
};

/* TV4 — f(x)=ax+b → chercher x (antécédents) */
const exTV4 = {
  id:'tv_affine_x', title:'Tableau : f(x)=ax+b → trouver x (antécédents)',
  gen(){
    let a=0; while(a===0) a=rnd(-6,6); const b=rnd(-8,8);
    const xs=shuffle([-4,-3,-2,-1,0,1,2,3,4]).slice(0,5).sort((x,y)=>x-y);
    const ys=xs.map(x=>a*x+b);
    const rows=xs.map((x,i)=>({ id:'x'+i, val: makeR(x,1) }));
    return {a,b,xs,ys,rows};
  },
  render(host,s){
    const fTex = 'f(x) = ' + fmtAffineLatex(s.a,s.b);
    host.innerHTML =
      '<div class="equ">Soit ' + wrap(fTex) + '. Compléter le tableau en trouvant x :</div>'
    + buildXTable(s)
    + '<div class="steps" id="steps"></div>';
    insertEnoncePDFTable(host);
    retypeset(host);

    host.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('keydown',e=>{
        if(e.key==='Enter'){ e.preventDefault();
          const exp = expectedById(s, inp.dataset.id);
          gradeOneInput(inp, exp);
          gradeAllInHost(host, s);
        }
      });
    });
  },
  correct(host,s){ return gradeAllInHost(host, s); },
  solution(host,s){
    host.querySelectorAll('td,th').forEach(c=>clearTick(c));
    const solved = buildSolvedXTable(s);

    const cols = s.ys.map((y)=>{
      const kTex = toTexNumber(y);
      const L0 = wrap('f(x) = '+fmtAffineLatex(s.a,s.b));
      const L1 = '';
      const L2 = wrap('f(x) = '+kTex);
      const L3 = wrap(monoAx(s.a) + (s.b!==0 ? (s.b>0?' + ':' − ') + Math.abs(s.b) : '') + ' = ' + kTex);
      const L4 = (s.b!==0) ? wrap((monoAx(s.a) + ' = ' + kTex + (s.b>0?' − ':' + ') + Math.abs(s.b))) : null;
      const ymb = (typeof y==='number') ? makeR(y - s.b,1) : makeR(y.p - s.b*y.q, y.q);
      const L5 = wrap('x = ' + (s.b!==0 ? Q(String(ymb.p), String(s.a*ymb.q))
                                   : Q(String((typeof y==='number')?y: y.p), String(s.a*((typeof y==='number')?1: y.q)))));
      const fin = norm(ymb.p, s.a*ymb.q);
      const L6 = wrap('x = ' + toTexNumber(fin));
      return dedupeAll(s.b!==0 ? [L0,L1,L2,L3,L4,L5,L6] : [L0,L1,L2,L3,L5,L6]);
    });

    $('#steps',host).innerHTML =  detailsTable(cols);
	insertSolutionPDFTable(host, s, 'x');
    retypeset(host);
  },
  reset(host){
    host.querySelectorAll('input').forEach(i=>i.value='');
    host.querySelectorAll('td,th').forEach(c=>c.classList.remove('is-ok','is-ko','cell-solved'));
    host.querySelectorAll('.tick').forEach(t=>t.textContent='');
    clearPretty(host); $('#steps',host).innerHTML=''; insertEnoncePDFTable(host); retypeset(host);
  }
};

/* ===== REGISTRY/UI ===== */
const REGISTRY=[exTV1,exTV2,exTV3,exTV4];
window.REGISTRY=REGISTRY;

function buildOne(){
  const sel=$('#exo-select'), host=$('#host');
  const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def){ host.textContent='(Aucun exercice)'; return; }
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st);
  $('#score').textContent='0 / 0';
}
function check(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}');
  def.correct(host,st); // recalcul ok/total courants, ignore vides
}
function solution(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def) def.reset(host);
  $('#score').textContent='0 / 0';
}

document.addEventListener('DOMContentLoaded', function(){
  try{
    const sel=$('#exo-select');
    REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
    sel.addEventListener('change', buildOne);
    $('#btn-new').addEventListener('click', buildOne);
    $('#btn-check').addEventListener('click', check);
    // éviter que le clic enlève le focus de la case active
    $('#btn-check').addEventListener('mousedown', e=>e.preventDefault());
    $('#btn-solution').addEventListener('click', solution);
    $('#btn-reset').addEventListener('click', resetAll);

    // Entrée → valider la case courante (le render de chaque ex a déjà l'écouteur)
    sel.value=REGISTRY[0].id; buildOne(); $('#status').textContent='';
  }catch(err){ console.error(err); $('#status').textContent='(Erreur d’init : voir la console)'; }
});

/* ===== PDF ===== */
window.addEventListener('load', function () {
  if (window.ExoPDF && ExoPDF.init) {
    ExoPDF.init({
      title:'Seconde – Chapitre 2 – Tableau de valeurs (LaTeX)',
      lead:'Compléter le tableau.',
      max:50,
	        mountAfterSelector: '.card.small',

      leadByDefId:{
        'tv_affine_fx':'Compléter le tableau de valeurs pour \\(f(x)=ax+b\\).',
        'tv_quad_fx':'Compléter le tableau de valeurs pour \\(f(x)=ax^{2}+bx+c\\).',
        'tv_homo_fx':'Compléter le tableau de valeurs pour \\(f(x)=\\dfrac{ax+b}{cx+d}\\). Écrire « ND » si nécessaire.',
        'tv_affine_x':'Compléter le tableau : trouver \\(x\\) à partir de \\(f(x)\\) (affine).'
      }
    });
  }
});
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d’actions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux
[['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
  const src = document.querySelector(sel);
  if (src) {
    const clone = src.cloneNode(true);
    clone.classList.add('btn');
    clone.type = 'button';
    clone.removeAttribute('id');
    clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
    bar.appendChild(clone);
  } else {
    const fallback = document.createElement('button');
    fallback.className = 'btn';
    fallback.type = 'button';
    fallback.textContent = label;
    fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
    bar.appendChild(fallback);
  }
});
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si présent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points à déplacer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
