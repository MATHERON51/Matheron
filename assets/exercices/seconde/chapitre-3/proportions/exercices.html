<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seconde ‚Äì Proportion & pourcentages</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #ddd;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap;margin-left:auto}
.small{font-size:.92rem;color:#666}

.hint{opacity:.9;margin:.2rem 0 .6rem}
.consigne .c-label{font-weight:600; margin-right:.35em}

/* Layout: en colonne (saisie en dessous) */
.row{
  display:grid;
  grid-template-columns:1fr;
  grid-template-areas:
    'lab'
    'inp'
    'res';
  gap:10px; align-items:start;
}
.row .col-label{grid-area:lab}
.row .input-line{grid-area:inp}
.row .input-line input[type=text]{width:100%}
.row .res{grid-area:res; padding:12px;border-radius:10px;background:#f7f7f7}
.res-ok{background:#ecfdf5;border:1px solid #a7f3d0}
.res-ko{background:#fef2f2;border:1px solid #fecaca}

#host .steps .step{white-space:nowrap}

/* (anciens styles fraction HTML conserv√©s mais non utilis√©s) */
.frac{display:inline-flex;flex-direction:column;align-items:center;vertical-align:middle;line-height:1}
.frac .num,.frac .den{padding:0 .2em;white-space:nowrap}
.frac .bar{border-top:1.6px solid currentColor;align-self:stretch;margin:.06em 0}
.frac-sign{margin-right:.15em}

/* Table exo 1 & 6 */
.tbl{border-collapse:collapse; border:1px solid #bbb}
.tbl td,.tbl th{border:1px solid #bbb; padding:6px; text-align:center}
@media print{
  .tbl{border:1px solid #000}
  .tbl td,.tbl th{border:1px solid #000}
}
.tbl input[type=text]{width:90px;text-align:center}

/* petit espace garanti autour des lettres en italique dans les √©quations (h√©rit√©) */
.eq em { margin: 0 .28em; }

/* variante si tu pr√©f√®res encapsuler (voir JS plus bas) */
.mx { display:inline-block; margin:0 .28em; }

/* indices lisibles, m√™me si un reset CSS les neutralise */
sub { font-size: .8em; vertical-align: -0.25em; }

/* air autour des fractions dans une √©quation */
.eq .frac{ margin: 0 .2em; }
/* espace visible apr√®s "1)" / "2)" dans les solutions */
.qno{ display:inline-block; margin-right:.45em }

/* "ainsi" soulign√© + espace de chaque c√¥t√© */
.ainsi{
  text-decoration: underline;
  display:inline-block;
  margin: 0 .45em;
}

/* lignes de solution plus lisibles */
#res .sol p{ margin:.25rem 0; }

@media screen{
  .equ-offscreen{position:absolute !important; left:-10000px !important; width:1px !important; height:1px !important; overflow:hidden !important;}
}
@media print{
  .hint{display:none !important;}
  .equ-offscreen{position:static !important; width:auto !important; height:auto !important; overflow:visible !important;}
  .equ-offscreen .c-label{display:none !important;}
}

/* Variante : saisie √† droite de la question (pour ex6 & ex7) */
.row.right{
  display:grid;
  grid-template-columns: 1fr minmax(220px, 320px);
  grid-template-areas:
    "lab inp"
    "res res";
  gap:10px 14px;
  align-items:center;
}
.row.right .col-label{ grid-area:lab; }
.row.right .input-line{ grid-area:inp; display:flex; justify-content:flex-end; }
.row.right .input-line input[type=text]{ width:100% }

/* Mobile : repasse en colonne */
@media (max-width:680px){
  .row.right{
    grid-template-columns:1fr;
    grid-template-areas:
      "lab"
      "inp"
      "res";
  }
}

/* Tick √† droite de chaque champ */
.tick{display:inline-block;min-width:1.2em;margin-left:8px;font-weight:700}
.tick.ok{color:#059669}   /* V vert */
.tick.ko{color:#dc2626}   /* X rouge */
</style>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: {'[+]': ['bbox']},
      macros: { frac: ['\\dfrac{#1}{#2}', 2] }
    },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
</head>
<body>
  <div class="header">
    <div class="wrap" style="padding:0 18px">
      <div class="controls">
        <label for="exo-select">Type d‚Äôexercice :</label>
        <select id="exo-select"></select>
        <button id="btn-new" class="btn">üîÄ Nouvel √©nonc√©</button>
        <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
        <button id="btn-solution" class="btn">üí° Solution</button>
        <button id="btn-reset" class="btn">‚ôªÔ∏è R√©initialiser</button>
        <div class="score" id="score">Score : 0 / 0</div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div id="host"></div>
    </div>
	
    <div class="card small">
      <div><strong>Saisie & r√©ponses accept√©es :</strong></div>
      <ul class="tips">
        <li>D√©cimaux : virgule <em>ou</em> point (ex. <code>0,175</code> ou <code>0.175</code>).</li>
        <li><strong>Pourcentages</strong> : quand l‚Äô√©nonc√© exige un ¬´ % ¬ª, la forme d√©cimale de proportion est <strong>refus√©e</strong> (ex. <code>0,43</code> refus√© ‚Üí saisir <code>43</code> ou <code>43&nbsp;%</code>). Sinon, on accepte proportion / d√©cimal / %.</li>
        <li>Fractions : forme <code>a/b</code>. On accepte les proportions au format <code>a/b</code>, d√©cimal <code>0,7</code> ou pourcentage <code>70%</code>.</li>
        <li>Quand la question demande un <strong>nombre de personnes/objets</strong>, le r√©sultat attendu est un <strong>entier</strong>.</li>
        <li>Entr√©e ‚èé d√©clenche ¬´ V√©rifier ¬ª depuis une barre de saisie de l‚Äô√©nonc√©.</li>
      </ul>
    </div>

    <div class="card">
      <div data-math-kbd style="display:flex; justify-content:center"></div>
    </div>

  </div>

<script>
(() => {
/* ================== Outils g√©n√©riques ================== */
const $  = (sel,root=document)=>root.querySelector(sel);
const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = L => L[rnd(0,L.length-1)];
const UMINUS = '‚àí';

function innerHost(host){ if(!host.dataset.active){ host.dataset.active=''; host.innerHTML='<div class="inner"></div>'; } return host.querySelector('.inner'); }

/* ================== Formats & parse ================== */
const fmtDecFR = (x, digits=3) => {
  const s = String(Math.round(x*10**digits)/10**digits);
  return s.replace('.',',');
};
const stripSignUnicode = s => String(s||'').replace(/‚àí/g,'-');
function retypeset(root=document){
  try {
    if (window.MathJax?.typesetPromise) return MathJax.typesetPromise([root]);
    if (window.MathJax?.typeset) MathJax.typeset([root]);
  } catch(_) {}
}

function parseNumberFR(s){
  s = stripSignUnicode(String(s||'').trim()).replace(/\s+/g,' ');
  if(!s) return NaN;
  const pct = s.match(/^([-+]?[0-9]+(?:[.,][0-9]+)?)\s*%$/);
  if(pct) return parseFloat(pct[1].replace(',', '.'))/100; // "43%" -> 0.43
  return parseFloat(s.replace(',', '.'));
}
// D√©cimal strict : refuse toute cha√Æne contenant un symbole %
function parseNumberFR_noPct(s){
  s = stripSignUnicode(String(s||'').trim());
  if (/%/.test(s)) return NaN;                 // ex. "22%" -> refus√©
  return parseFloat(s.replace(',', '.'));      // ex. "0,22" -> 0.22
}

function parsePercent(s){
  const v = parseNumberFR(s);
  return isFinite(v) ? v*100 : NaN; // "43%" -> 43 ; "43" -> 4300 (h√©rit√©)
}
/* === STRICT % : refuse les formes d√©cimales de proportion quand un % est exig√© === */
function parsePercentStrict(s){
  const raw = String(s||'').trim();
  if (/%/.test(raw)) return parsePercent(raw);  // "43%" -> 43
  const v = parseNumberFR(raw);                 // "43"  -> 43
  if (!isFinite(v)) return NaN;
  if (Math.abs(v) > 0 && Math.abs(v) < 1) return NaN; // refuse "0,43"
  return v;
}

function sameFloat(a,b,eps=1e-6){ return Math.abs(a-b) <= eps; }
function parsePercentRequireSign(s){
  const raw = String(s||'').trim();
  if (!/%/.test(raw)) return NaN;        // refuse si pas de symbole %
  const v = parsePercent(raw);           // -> en points de %
  return Number.isFinite(v) ? v : NaN;
}

// Entier strict : uniquement chiffres (et signe) ‚Äî refuse "12%", "12.0", "12a"
function parseIntStrict(s){
  s = stripSignUnicode(String(s||'').trim());
  if (!/^-?\d+$/.test(s)) return NaN;
  return parseInt(s,10);
}

// D√©cimal FR strict (sans %) ni fraction ‚Äî refuse "3/4", "12 %"
function parseNumberStrictFR(s){
  s = stripSignUnicode(String(s||'').trim());
  if (/%/.test(s) || /\//.test(s)) return NaN;
  if (!/^-?\d+(?:[.,]\d+)?$/.test(s)) return NaN;
  return parseFloat(s.replace(',', '.'));
}

// Fraction "a/b" strictement irr√©ductible
function parseIrreducibleFraction(s){
  s = stripSignUnicode(String(s||'').trim());
  const m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
  if(!m) return null;
  const a = parseInt(m[1],10), b = parseInt(m[2],10);
  if(!Number.isInteger(a) || !Number.isInteger(b) || b<=0) return null;
  return (gcd(a,b)===1) ? {a,b} : null;
}
// ===== Accord FR : articles & pluriels =====
const GROUP_GENDER = {
  'classe':'f',
  'groupe d‚Äôatelier':'m','groupe d\'atelier':'m',
  '√©quipe':'f',
  'chorale':'f',
  'groupe de stage':'m',
  'club de lecture':'m',
  'groupe de randonneurs':'m',
  'promo':'f',
  'groupe d‚Äô√©l√®ves':'m','groupe d\'√©l√®ves':'m',
  'groupe de b√©n√©voles':'m'
};
function groupGender(name){ return GROUP_GENDER[name] || 'm'; }
function startsWithVowelLike(s){
  const V='a√¢√†√§e√©√®√™√´i√Æ√Øo√¥√∂u√π√ª√ºyhA√Ç√Ä√ÑE√â√à√ä√ãI√é√èO√î√ñU√ô√õ√úYH';
  s = String(s||'').trim(); return s && V.includes(s[0]);
}
// D√©terminant d√©fini "le/la/l‚Äô" coll√© au nom (ex: "l‚Äô√©quipe", "la classe", "le groupe ‚Ä¶")
function defDet(name){
  const g = groupGender(name);
  if (startsWithVowelLike(name)) return "l‚Äô"+name;
  return (g==='f' ? "la " : "le ") + name;
}
// D√©terminant ind√©fini "Un/Une" (ex: "Une classe", "Un groupe ‚Ä¶")
function indefDet(name){
  const g = groupGender(name);
  return (g==='f' ? "Une " : "Un ") + name;
}
// Pluriel/singulier
function s(n, one, many){ return Math.abs(n)===1 ? one : many; }
function vAvoir(n){ return Math.abs(n)===1 ? 'a' : 'ont'; }     // a/ont

/* ================== Fractions & √©galit√©/approx ================== */
const gcd = (a,b)=> b ? gcd(b, a%b) : Math.abs(a);

function intRat(x, den=1){
  const s = String(x).replace(',', '.').trim();
  if (/^[-+]?\d+$/.test(s)) return { n: parseInt(s,10), d: den };
  const k = (s.split('.')[1]||'').length;
  return { n: Math.round(parseFloat(s)*10**k), d: den*10**k };
}
function reduceRat(n,d){ const g = gcd(n,d)||1; return { n:n/g, d:d/g }; }
function minTerminatingDecimals(n,d){
  ({n,d} = reduceRat(n,d));
  let a=0,b=0; while(d%2===0){d/=2;a++;} while(d%5===0){d/=5;b++;}
  return d===1 ? Math.max(a,b) : Infinity;
}
function eqOrApproxSymbol(n,d,digits){ return (minTerminatingDecimals(n,d) <= digits) ? '=' : '‚âà'; }
function eqOrApproxPercentSymbol(n,d,digits){ return eqOrApproxSymbol(n*100, d, digits); }

// Retourne la fraction irr√©ductible de (a/b) avec a,b entiers
// (tu as d√©j√† gcd/reduceRat ; je les r√©utilise)
function toIrreducible(a, b){
  const r = reduceRat(a, b);  // {n,d}
  // force signes "propres" (ici tout est positif dans l‚Äôexo 7)
  return { n: r.n, d: r.d };
}

// Parse strict "a/b" ET v√©rifie irr√©ductible
function parseIrreducibleFraction(s){
  s = stripSignUnicode(String(s||'').trim());
  const m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
  if(!m) return null;
  const a = parseInt(m[1],10), b = parseInt(m[2],10);
  if(!Number.isInteger(a) || !Number.isInteger(b) || b<=0) return null;
  if(gcd(a,b)!==1) return null;           // doit √™tre irr√©ductible
  return {a,b};
}

/* ================== === LaTeX helpers (nouveau) ================== */
const L = s => `\\(${s}\\)`;                  // inline math wrapper
const texFrac = (num, den) => `\\dfrac{${num}}{${den}}`;
const texNum = (v, digits=3) => {
  // Nombres FR dans le LaTeX inline
  const s = fmtDecFR(v, digits);
  return s;
};
const texPct = (v, digits=2) => `${texNum(v, digits)}\\,\\%`;
// ‚úÖ approx correct (un seul antislash)
const symTex = s => (s==='=' ? '=' : '\\approx');

// ‚úÖ nombres & % en LaTeX partout
const NI = v => L(String(v));                               // entier ‚Üí \(12\)
const N  = (v, d=3) => L(tidyDecFR(v, d));                  // r√©el fr ‚Üí \(0,375\)
const PCT = (v, d=2) => L(`${tidyDecFR(v, d)}\\,\\%`);      // pourcentage ‚Üí \(37,5\,\%\)

/* ================== Rendu utils ================== */
function fracHTML(n, d){
  // remplac√© par LaTeX inline
  return L(texFrac(String(n).replace('.',','), String(d)));
}
const EMX = s => L(String(s)); // ex: A,E,p ‚Üí \(A\) etc.

function tidyDecFR(v, digits=3){
  let s = fmtDecFR(v, digits);
  if (s.includes(',')) s = s.replace(/0+$/,'').replace(/[,]$/,'');
  return s;
}
function fmtIntOrDec(v, digits=3){
  return Number.isInteger(v) ? String(v) : tidyDecFR(v, digits);
}
function Q(n, sub){
  let s;
  if (typeof n === 'number') s = String(n) + (sub ? String(sub) : '');
  else s = String(n || '');
  s = s.trim().replace(/\)$/, '');
  return `<span class="qno">${s})</span>`;
}

// --- helper : rationnel exact de (num / den) m√™me si num/den ont des d√©cimales
function ratFromQuot(num, den){
  const a = intRat(String(num).replace(',', '.')); // {n,d} pour num
  const b = intRat(String(den).replace(',', '.')); // {n,d} pour den
  // num/den = (a.n/a.d) / (b.n/b.d) = (a.n*b.d) / (a.d*b.n)
  return reduceRat(a.n * b.d, a.d * b.n);
}


function chainFracToDec(num, den, decDigits=4){
  const r = reduceRat(num, den);         // {n,d} irr√©ductible
  const exact = (minTerminatingDecimals(r.n, r.d) <= decDigits);
  const REL = exact ? '=' : '\\approx';
  const frac = texFrac(num, den);
  const dec  = tidyDecFR(num/den, decDigits);
  return L(`${frac} ${REL} ${dec}`);
}

function chainFracDecPct(numDisplay, denDisplay, digitsPct){
  const decDigits = digitsPct + 2;

  // valeurs num√©riques pour l‚Äôaffichage d√©cimal/% (FR)
  const numVal = parseFloat(String(numDisplay).replace(',', '.'));
  const denVal = parseFloat(String(denDisplay).replace(',', '.'));

  // forme rationnelle exacte de num/den
  let {n, d} = ratFromQuot(numVal, denVal);        // n/d est la fraction irr√©ductible

  // exactitudes (d√©cimal et %)
  const exactDec = (minTerminatingDecimals(n, d) <= decDigits);
  const exactPct = (minTerminatingDecimals(n*100, d) <= digitsPct);

  // r√®gle : s'il y a la moindre approx, utiliser "‚âà" partout (aucun "=")
  const REL = (exactDec && exactPct) ? '=' : '\\approx';

  // affichages
  const frac = texFrac(String(numDisplay).replace('.',','), String(denDisplay));
  const dec  = texNum(numVal/denVal, decDigits);
  const pct  = texPct(100*numVal/denVal, digitsPct);

  return L(`${frac} ${REL} ${dec} ${REL} ${pct}`);
}


/* ================== Rendu des rang√©es ================== */
function renderRow(host, consigneText, labelHTML, hasInput=true, placeholder=''){
  const root=innerHost(host); root.innerHTML='';
  const hint=document.createElement('div'); hint.className='hint consigne';
  hint.innerHTML='<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
  root.appendChild(hint);

  const off=document.createElement('div'); off.className='equ-offscreen';
  off.innerHTML='<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div><div class="equation">'+stripHints(labelHTML)+'</div>';
  root.appendChild(off);

  const row=document.createElement('div'); row.className='row';
  const lab=document.createElement('div'); lab.className='col-label'; lab.innerHTML=labelHTML; row.appendChild(lab);
  const incol=document.createElement('div'); incol.className='input-line';
  if(hasInput){
    incol.innerHTML='<input id="reponse" type="text" placeholder="'+placeholder+'">';
  } else {
    incol.innerHTML='';
  }
  row.appendChild(incol);
  row.appendChild(Object.assign(document.createElement('div'),{className:'res', id:'res'}));
  root.appendChild(row);
    retypeset(root);   // <<< NEW

}

function renderRowsUnderQuestions(host, consigneText, blocks){
  const root = innerHost(host); root.innerHTML = '';

  const hint = document.createElement('div');
  hint.className = 'hint consigne';
  hint.innerHTML = '<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
  root.appendChild(hint);

  const off = document.createElement('div');
  off.className = 'equ-offscreen';
  off.innerHTML =
    '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div>'
  + blocks.map(b => '<div class="equation">'+ stripHints(b.labelHTML||'') +'</div>').join('');
  root.appendChild(off);

  blocks.forEach(b => {
    const row = document.createElement('div'); row.className = 'row';
    const lab = document.createElement('div'); lab.className = 'col-label';
    lab.innerHTML = b.labelHTML||'';
    row.appendChild(lab);

    const incol = document.createElement('div'); incol.className = 'input-line';
    if (b.id) incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
    row.appendChild(incol);

    root.appendChild(row);

  });

  root.appendChild(Object.assign(document.createElement('div'), { className:'res', id:'res' }));
  	  retypeset(root);   // <<< NEW

}

function renderRowsInputRight(host, consigneText, blocks){
  const root = innerHost(host); root.innerHTML = '';

  const hint = document.createElement('div');
  hint.className = 'hint consigne';
  hint.innerHTML = '<span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span>';
  root.appendChild(hint);

  const off = document.createElement('div');
  off.className = 'equ-offscreen';
  off.innerHTML =
    '<div class="consigne"><span class="c-label">Consigne :</span> <span class="c-text">'+consigneText+'</span></div>'
    + blocks.map(b => '<div class="equation">'+ stripHints(b.labelHTML||'') +'</div>').join('');
  root.appendChild(off);

  blocks.forEach(b => {
    const row = document.createElement('div'); row.className = 'row right';
    const lab = document.createElement('div'); lab.className = 'col-label';
    lab.innerHTML = b.labelHTML || '';
    row.appendChild(lab);

    const incol = document.createElement('div'); incol.className = 'input-line';
    if (b.rightHTML !== undefined) {
      incol.innerHTML = b.rightHTML;
    } else if (b.id) {
      incol.innerHTML = '<input id="'+b.id+'" type="text" placeholder="'+(b.placeholder||'')+'">';
    }
    row.appendChild(incol);

    root.appendChild(row);
  });

  root.appendChild(Object.assign(document.createElement('div'), { className:'res', id:'res' }));
  	  retypeset(root);   // <<< NEW

}

// Retire les aides de saisie (<small>‚Ä¶</small>) pour le rendu PDF / offscreen
// Retire aides + INPUTS pour le rendu PDF/offscreen
function stripHints(html){
  if(!html) return '';
  let s = String(html);

  // <br><small>‚Ä¶</small>
  s = s.replace(/<br\s*\/?>\s*<small[\s\S]*?<\/small>/gi, '');
  s = s.replace(/<small[\s\S]*?<\/small>/gi, '');

  // cas "(‚Ä¶ arrondir au % pr√®s ‚Ä¶)" √©ventuellement avec <em>‚Ä¶</em>
  s = s.replace(/<em[^>]*>\s*(arrondi[\s\S]*?)<\/em>/gi, '$1');
  const kw = '(?:arrondi|arrondir|%\\s*pr√®s|deux\\s+d√©cimales|0,0+1\\s*%|0,01\\s*%|0,0001|entier\\s*\\(arrondi\\)|entier\\s*arrondi)';
  const reParenHints = new RegExp('\\s*\\((?:[^()]*'+kw+'[^()]*)\\)\\s*','gi');
  let prev; do { prev = s; s = s.replace(reParenHints, ' '); } while (s !== prev);

  // üîë remplace tout <input ‚Ä¶> par un espace visuel pour garder la hauteur des cases
  s = s.replace(/<input\b[^>]*>/gi, '<span class="pdf-blank">&nbsp;</span>');

  return s;
}


/* ================== Ticks & validation progressive ================== */
function addTicks(host){
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    const next = inp.nextElementSibling;
    if(!next || !next.classList || !next.classList.contains('tick')){
      inp.insertAdjacentHTML('afterend','<span class="tick"></span>');
    }
  });
}
function setTickForInput(inp, state){
  const tick = inp.nextElementSibling && inp.nextElementSibling.classList.contains('tick')
    ? inp.nextElementSibling : null;
  if(!tick) return;
  if(state===null){ tick.textContent=''; tick.classList.remove('ok','ko'); return; }
  if(state===true){ tick.textContent='‚úî'; tick.classList.add('ok'); tick.classList.remove('ko'); }
  else            { tick.textContent='‚úò'; tick.classList.add('ko'); tick.classList.remove('ok'); }
}

/* ================== Validation par champ ================== */
function validateOneInput(inp, st, exId){
  const valRaw = (inp.value||'').trim();
  if(valRaw==='') return null;

  function asInt(s){ return parseIntStrict(s);  const n=parseInt(s,10); return Number.isInteger(n)?n:NaN; }
  const id = inp.id||'';
  const valPct = parsePercentRequireSign(valRaw); // pour les champs % stricts
  const valNum = parseNumberFR(valRaw);

  switch(exId){
    /* ===== Ex.1 : tableaux %/dec ===== */
    case 'pct_tableaux':{
      if(!inp.classList.contains('ans')) return false;
      const kind = inp.dataset.kind;
      const ident = inp.dataset.i||'';
      let expected;
      if(ident.startsWith('p')){ expected = (JSON.parse($("#host").dataset.state).P)[+ident.slice(1)].sol; }
      else{                      expected = (JSON.parse($("#host").dataset.state).Q)[+ident.slice(1)].sol; }
      if(kind==='dec'){
        const v = parseNumberStrictFR(valRaw);
        return isFinite(v) && sameFloat(v, expected, 1e-3);
      } else {
        const v=parsePercentRequireSign(valRaw); return isFinite(v)&&sameFloat(v, expected, 1e-3);
      }
    }

    /* ===== Ex.2 : deux % ===== */
    case 'frac_to_pct':{
  if(id==='q1'){
    const p = parsePercentRequireSign(valRaw);          // % OBLIGATOIRE
    const exp = st.A.pct;                               // 100 * num/den
    return Number.isFinite(p) && (Math.round(p*100) === Math.round(exp*100)); // ‚Üê √† 0,01 %
  }
  if(id==='q2'){
    const p = parsePercentRequireSign(valRaw);
    const exp = st.B.pct;
    return Number.isFinite(p) && (Math.round(p*100) === Math.round(exp*100)); // ‚Üê √† 0,01 %
  }
  return false;
}


    /* ===== Ex.3 : proportion libre + entier ===== */
    case 'sondage':{
      if(id==='p1'){
        let v=NaN; const m=valRaw.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
        if(m){ v=parseInt(m[1],10)/parseInt(m[2],10); }
        else {
          const d=parseNumberFR(valRaw);
          v = Number.isFinite(d)?d:(Number.isFinite(parsePercent(valRaw))?parsePercent(valRaw)/100:NaN);
        }
        return Number.isFinite(v) && sameFloat(v, st.have/st.N, 1e-3);
      }
      if(id==='p2'){ const n=asInt(valRaw); return Number.isInteger(n) && n===st.usbCount; }
      return false;
    }

    /* ===== Ex.4 : p libre + deux entiers ===== */
    case 'souspop':{
     if(id==='r1'){
  const v = parseNumberStrictFR(valRaw);    // d√©cimal strict : pas de %, pas de fraction
  if(!Number.isFinite(v)) return false;
  const tgt = st.nA1 / st.nE1;
  return Math.round(v*1000) === Math.round(tgt*1000); // √† 0,001 pr√®s
}

      if(id==='r2'){ const n=asInt(valRaw); return Number.isInteger(n) && n===st.nA2; }
      if(id==='r3'){ const n=asInt(valRaw); return Number.isInteger(n) && n===st.nE3; }
      return false;
    }

    /* ===== Ex.5 : % strict (√† 0,01 %) + entier arrondi ===== */
    case 'masses':{
      if(id==='m1'){
        const exp=100*st.c1/st.M;
        const p = parsePercentRequireSign(valRaw);
        return Number.isFinite(p) && (Math.round(p*100)===Math.round(exp*100));
      }
      if(id==='m2'){ const n=asInt(valRaw); return Number.isInteger(n) && n===Math.round(st.q2); }
      return false;
    }

    /* ===== Ex.6 : tableau + % strict ===== */
    case 'pme':{
      if(inp.classList.contains('c-ans')){
        const k=inp.dataset.k, exp = {CT:st.CT, TH:st.TH, TF:st.TF, TT:st.TT, TOT_F:st.TOT_F}[k];
        const n=asInt(valRaw); return Number.isInteger(n) && n===exp;
      }
      if(id==='q2a'){ const n=asInt(valRaw); const exp=(st.gAsk==='H'?st.TOT_H:st.TOT_F); return Number.isInteger(n)&&n===exp; }
      if(id==='q2b'){ const n=asInt(valRaw); return Number.isInteger(n)&&n===st.CT; }
      if(id==='q2c'){ const n=asInt(valRaw); return Number.isInteger(n)&&n===st.CH; }
      if(id==='q3a'){ const p=parsePercentRequireSign(valRaw); const exp=Math.round(100*(st.gAsk==='H'?st.TOT_H:st.TOT_F)/st.TOT); return Number.isFinite(p)&&Math.round(p)===exp; }
      if(id==='q3b'){ const p=parsePercentRequireSign(valRaw); const exp=Math.round(100*st.CT/st.TOT); return Number.isFinite(p)&&Math.round(p)===exp; }
      if(id==='q4a'){ const p=parsePercentRequireSign(valRaw); const exp=Math.round(100*st.CH/st.TOT_H); return Number.isFinite(p)&&Math.round(p)===exp; }
      if(id==='q4b'){ const p=parsePercentRequireSign(valRaw); const exp=Math.round(100*st.CF/st.TOT_F); return Number.isFinite(p)&&Math.round(p)===exp; }
      return false;
    }

    /* ===== Ex.7 : % strict pour 1b/2b/4b ===== */
    case 'bilan':{
      function parsePropFlexible(s){
        let v=NaN; const m=s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
        if(m){ v=parseInt(m[1],10)/parseInt(m[2],10); }
        else { const d=parseNumberFR(s); v=Number.isFinite(d)?d:(Number.isFinite(parsePercent(s))?parsePercent(s)/100:NaN); }
        return v;
      }
      function sameDec4(a,b){return Math.round(a*1e4)===Math.round(b*1e4);}
      function samePct2(a,b){return Math.round(a*100)===Math.round(b*100);}

      if(id==='b1a'){ const v=parsePropFlexible(valRaw); return Number.isFinite(v) && sameDec4(v, st.G/st.N); }
      if(id==='b1b'){ const p=parsePercentRequireSign(valRaw); return Number.isFinite(p) && samePct2(p, 100*st.G/st.N); }
      if(id==='b2a'){ const v=parsePropFlexible(valRaw); return Number.isFinite(v) && sameDec4(v, st.G17/st.G); }
      if(id==='b2b'){ const p=parsePercentRequireSign(valRaw); return Number.isFinite(p) && samePct2(p, 100*st.G17/st.G); }
      if(id==='b3'){ const a=valRaw.toLowerCase().replace(/\s+/g,' ').trim(); return a.includes(st.group.split(' ')[0].toLowerCase()) && a.includes('fille'); }
      if(id==='b4a'){ const n=asInt(valRaw); return Number.isInteger(n)&&n===st.n18; }
      if(id==='b4b'){
        const p=parsePercentRequireSign(valRaw);
        const exp = 100 - Math.round(100*st.N17/st.N) - st.U18;
        return Number.isFinite(p) && Math.round(p*100)===Math.round(exp*100);
      }
      return false;
    }

    default: return false;
  }
}

/* Valide tous les champs remplis du host (sans toucher au score) */
function progressiveValidate(host){
  const exId = host.dataset.active;
  const st = JSON.parse(host.dataset.state||'{}');
  let blanks=0;
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    const state = validateOneInput(inp, st, exId);
    setTickForInput(inp, state);
    if(state===null) blanks++;
  });
  return blanks;
}
function allInputsFilled(host){
  let ok=true;
  $$('#host input[type=text]').forEach(inp=>{
    if(inp.closest('.equ-offscreen')) return;
    if((inp.value||'').trim()==='') ok=false;
  });
  return ok;
}
// D√©tecte voyelle ou h muet pour l'√©lision (m√™me logique que pour l/la/l‚Äô)
function startsWithVowelLike(s){
  const V = 'a√¢√†√§e√©√®√™√´i√Æ√Øo√¥√∂u√π√ª√ºyhA√Ç√Ä√ÑE√â√à√ä√ãI√é√èO√î√ñU√ô√õ√úYH';
  s = String(s||'').trim();
  return s && V.includes(s[0]);
}
// "de" ‚Üí "d‚Äô" si besoin
function deElide(word){
  word = String(word||'').trim();
  return startsWithVowelLike(word) ? "d‚Äô"+word : "de "+word;
}

/* ================== EXERCICES ================== */
/* 1 ‚Äî Tableaux % ‚Üî d√©cimaux */
const ex1={
  id:'pct_tableaux', title:'Compl√©ter les tableaux (pourcentages ‚Üî d√©cimaux)',
  gen(){
    const cols = 5;
    const percInts = [3,7,12,22,37,41,55,87,92];
    const percDecs = [0.5, 1.2, 2.5, 12.5, 7.5, 0.2];
    const decs = [0.43,0.52,0.175,0.2,0.006,0.34,0.875,0.025];
    const P = [];
    while(P.length<cols){
      const useDecPct = Math.random()<0.4;
      if(useDecPct){
  const v = choice(percDecs);
  if(!P.some(x=>x.type==='pct' && x.v===v)){
    P.push({type:'pct', v:v, label:PCT(v, (v%1)?1:0), want:'dec', sol: v/100});
  }
}else{
  const v = choice(percInts);
  if(!P.some(x=>x.type==='pct' && x.v===v)){
    P.push({type:'pct', v:v, label:PCT(v,0), want:'dec', sol: v/100});
  }
}
    }
    const Q = [];
    while(Q.length<cols){
      const v = choice(decs);
if(!Q.some(x=>x.v===v)){
  Q.push({type:'dec', v:v, label:N(v,3), want:'pct', sol: v*100});
}
    }
    return {P,Q};
  },
  text(st){
    function buildRow(arr, showWhat){
      return arr.map((cell,i)=>{
        if(showWhat==='given') return '<td>'+cell.label+'</td>';
        return '<td><input class="ans" data-kind="'+cell.want+'" data-i="'+showWhat+String(i)+'" type="text" placeholder="'+'"></td>';
      }).join('');
    }
    const tbl1 = '<table class="tbl"><tbody><tr>'+buildRow(st.P,'given')+'</tr><tr>'+buildRow(st.P,'p')+'</tr></tbody></table>';
    const tbl2 = '<table class="tbl" style="margin-top:8px"><tbody><tr>'+buildRow(st.Q,'q')+'</tr><tr>'+buildRow(st.Q,'given')+'</tr></tbody></table>';
    return tbl1 + tbl2;
  },
  render(host, st){ renderRow(host, "Transformer les % en nombres d√©cimaux et inversement", this.text(st), false); $("#host").dataset.state = JSON.stringify(st); },
  correct(host, st){
    const inputs = $$(".ans", host);
    let ok=true;
    inputs.forEach(inp=>{
      const kind = inp.dataset.kind;
      const id = inp.dataset.i;
      let expected;
      if(id.startsWith('p')){ const i=+id.slice(1); expected = st.P[i].sol; }
      else { const i=+id.slice(1); expected = st.Q[i].sol; }
      const raw = (inp.value||'').trim();
      let good=false;
      if(kind==='dec'){
        const v = parseNumberStrictFR(raw);
        good = isFinite(v) && sameFloat(v, expected, 1e-3);
      }else{
        const v=parsePercentRequireSign(raw);
        good = isFinite(v) && sameFloat(v, expected, 1e-3);
      }
      if(!good) ok=false;
    });
    $("#res",host).innerHTML = ok ? "‚úî" : "‚úò Certaines cases sont incorrectes.";
    $("#res",host).className= ok ? "res-ok" : "res-ko";
    return {ok,total:1};
  },
  solution(host, st){
    const tidy = (v,d=3)=>{ let s=fmtDecFR(v,d); s=s.replace(/0+$/,'').replace(/[,]$/,''); return s; };
   const t1_top = st.P.map(c=>`<td>${c.label}</td>`).join('');
const t1_bot = st.P.map(c=>`<td>${N(c.sol,3)}</td>`).join('');
const tbl1 = `<table class="tbl"><tbody><tr>${t1_top}</tr><tr>${t1_bot}</tr></tbody></table>`;

const t2_top = st.Q.map(c=>`<td>${PCT(c.sol,3)}</td>`).join('');
const t2_bot = st.Q.map(c=>`<td>${c.label}</td>`).join('');
const tbl2 = `<table class="tbl" style="margin-top:8px"><tbody><tr>${t2_top}</tr><tr>${t2_bot}</tr></tbody></table>`;
 $("#res",host).innerHTML = `<div style="margin-bottom:6px"><strong>Tableaux compl√©t√©s :</strong></div>${tbl1}${tbl2}`;
    $("#res",host).className = "res-ok";
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* 2 ‚Äî Proportion -> % (2 questions) */
const ex2={
  id:'frac_to_pct', title:'Proportion ‚Üí pourcentage (2 questions)',
  gen(){
    function makeCase(){
      const den = choice([8,10,12,16,20,25,40,50,80,100]);
      const num = rnd(1, den-1);
      return {num, den, pct: 100*num/den};
    }
    const ctxA = choice([
      {who:'Les footballeurs', where:'dans un club amateur'},
      {who:'Les lecteurs assidus', where:'dans une biblioth√®que'},
      {who:'Les √©l√®ves inscrits √† l‚Äôatelier th√©√¢tre', where:'dans un lyc√©e'},
      {who:'Les voyageurs abonn√©s', where:'dans un bus'},
      {who:'Les supporters munis d‚Äôun drapeau', where:'au stade'},
      {who:'Les licenci√©s en judo', where:'au club omnisports'},
      {who:'Les abonn√©s internet fibre', where:'dans un immeuble'},
      {who:'Les joueurs d‚Äô√©checs', where:'dans une salle des f√™tes'},
      {who:'Les cyclistes casqu√©s', where:'sur une randonn√©e'},
      {who:'Les votants', where:'dans une assembl√©e'}
    ]);
    const ctxB = choice([
      {who:'Les footballeurs', where:'dans un club amateur'},
      {who:'Les lecteurs assidus', where:'dans une biblioth√®que'},
      {who:'Les √©l√®ves inscrits √† l‚Äôatelier th√©√¢tre', where:'dans un lyc√©e'},
      {who:'Les voyageurs abonn√©s', where:'dans un bus'},
      {who:'Les supporters munis d‚Äôun drapeau', where:'au stade'},
      {who:'Les licenci√©s en judo', where:'au club omnisports'},
      {who:'Les abonn√©s internet fibre', where:'dans un immeuble'},
      {who:'Les joueurs d‚Äô√©checs', where:'dans une salle des f√™tes'},
      {who:'Les cyclistes casqu√©s', where:'sur une randonn√©e'},
      {who:'les votants', where:'dans une assembl√©e'}
    ]);
    return {A:makeCase(), B:makeCase(), ctxA, ctxB};
  },
  text(st){
    const fA = L(`${texFrac(st.A.num, st.A.den)}`);
    const fB = L(`${texFrac(st.B.num, st.B.den)}`);
    return '<div>1) '+st.ctxA.who+' repr√©sentent '+fA+' '+st.ctxA.where+'. Donner le pourcentage correspondant (<em>√† 0,01% pr√®s, si n√©cessaire</em>).</div>'+
           '<div style="margin-top:6px">2) '+st.ctxB.who+' repr√©sentent '+fB+' '+st.ctxB.where+'. Donner le pourcentage correspondant (<em>√† 0,01% pr√®s, si n√©cessaire</em>).</div>';
  },
  render(host, st){
    renderRowsUnderQuestions(host,
      'Convertir une proportion en pourcentage (√©crire √©ventuellement avec une virgule) :',
      [
        { labelHTML: '1) '+st.ctxA.who+' repr√©sentent '+L(`${texFrac(st.A.num, st.A.den)}`)+' '+st.ctxA.where+'. Donner le pourcentage correspondant (<em>√† 0,01% pr√®s, si n√©cessaire</em>).',
          id:'q1'},
        { labelHTML: '2) '+st.ctxB.who+' repr√©sentent '+L(`${texFrac(st.B.num, st.B.den)}`)+' '+st.ctxB.where+'. Donner le pourcentage correspondant (<em>√† 0,01% pr√®s, si n√©cessaire</em>).',
          id:'q2'}
      ]
    );
  },
correct(host, st){
  const p1 = parsePercentRequireSign($('#q1',host).value);
  const p2 = parsePercentRequireSign($('#q2',host).value);
  const ok = Number.isFinite(p1) && Number.isFinite(p2)
          && (Math.round(p1*100) === Math.round(st.A.pct*100))
          && (Math.round(p2*100) === Math.round(st.B.pct*100));
  $('#res',host).innerHTML = ok
    ? '‚úî'
    : '‚úò';
  $('#res',host).className = ok ? 'res-ok' : 'res-ko';
  return {ok,total:1};
},

  solution(host, st){
    const L1 = `${Q(1)} ${chainFracDecPct(st.A.num, st.A.den, 2)}`;
    const L2 = `${Q(2)} ${chainFracDecPct(st.B.num, st.B.den, 2)}`;
$('#res',host).innerHTML = `<p>${L1}</p><p>${L2}</p>`;
    $('#res',host).className='res-ok';
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* 3 ‚Äî Sondage (proportion + effectif) */
const ex3={
  id:'sondage', title:'Sondage : proportion & effectif',
  gen(){
    const N   = choice([60,70,80,90,100,120]);
    const have = rnd(Math.floor(N*0.5), Math.floor(N*0.95));
    const step = 1000 / gcd(N, 1000);
    const kMin = Math.ceil(100 / step) * step;
    const kMax = Math.floor(600 / step) * step;
    const possibles = [];
    for (let k=kMin; k<=kMax; k+=step) possibles.push(k);
    const K = choice(possibles);
    const usbPct   = K / 10;
    const usbCount = (N * K) / 1000;
    const who = choice(['√©l√®ves','apprenants','adh√©rents','participants','stagiaires','coll√©giens','lyc√©ens','√©tudiants','internautes','habitants']);
    const own = choice(['une adresse √©lectronique','un v√©lo','une carte de biblioth√®que','une calculatrice scientifique','un smartphone','une tablette','un casque audio','un abonnement aux transports','un ordinateur portable','une gourde r√©utilisable']);
    const use = choice(['une cl√© USB','une messagerie instantan√©e','un ENT','une application de r√©vision','un casque audio','un service de cloud','un agenda num√©rique','un lecteur MP3','une liseuse','un traitement de texte']);
    return { N, have, usbPct, usbCount, who, own, use };
  },
  render(host, st){
  renderRowsUnderQuestions(host,
    'R√©pondre en proportion (ex. 31/40 ou 0,775 ou 77,5%) puis en entier :',
    [
      { labelHTML:
        'Un sondage portant sur '+NI(st.N)+' '+st.who+' indique que '+NI(st.have)+' poss√®dent '+st.own
        +' et que '+PCT(st.usbPct,1)+' utilisent r√©guli√®rement '+st.use+'.<br>'
        +'1) Quelle est la proportion des '+st.who+' poss√©dant '+st.own+' ?',
        id:'p1'},
      { labelHTML:
  '2) Combien ' + deElide(st.who) + ' utilisent r√©guli√®rement ' + st.use + ' ?',
  id:'p2'}
    ]
  );
},

  correct(host, st){
    const r1 = ($('#p1',host).value||'').trim();
    let val1 = NaN;
    const m = r1.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
    if(m){ val1 = parseInt(m[1],10)/parseInt(m[2],10); }
    else {
      const v = parseNumberFR(r1);
      if(isFinite(v)) val1 = v; else {
        const p = parsePercent(r1); if(isFinite(p)) val1 = p/100;
      }
    }
    const ok1 = isFinite(val1) && sameFloat(val1, st.have/st.N, 1e-3);
    const n2 = parseInt(stripSignUnicode($('#p2',host).value||'').trim(),10);
    const ok2 = Number.isInteger(n2) && n2===st.usbCount;
    const ok = ok1 && ok2;
    $('#res',host).innerHTML = ok? '‚úî' : '‚úò Attendu : '+fmtDecFR(st.have/st.N,3)+' (ou '+st.have+'/'+st.N+' ou '+fmtDecFR(100*st.have/st.N,1)+' %) et '+st.usbCount;
    $('#res',host).className= ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const line1 = `${Q(1)} ${chainFracDecPct(st.have, st.N, 1)}`;
    const fracPct = texFrac(fmtDecFR(st.usbPct,1), 100);
    const line2 = `${Q(2)} ${L(`${fracPct} \\times ${st.N} = ${st.usbCount}`)}`;
    const line3 = `Il y a ${st.usbCount} ${st.who} qui utilisent r√©guli√®rement ${st.use}.`;
$('#res',host).innerHTML = `<p>${line1}</p><p>${line2}</p><p>${line3}</p>`;
    $('#res',host).className = 'res-ok';
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* 4 ‚Äî Proportion d‚Äôune sous-population (p = nA / nE) */
const ex4={
  id:'souspop', title:'Proportion d‚Äôune sous-population (p = n_A / n_E)',
  gen(){
    const nE1 = choice([240, 360, 480, 600, 800, 1200, 2400]);
    const nA1 = rnd(Math.floor(nE1*0.2), Math.floor(nE1*0.8));
    const fracs = [{n:1,d:10},{n:1,d:8},{n:1,d:5},{n:1,d:4},{n:2,d:5},{n:3,d:10},{n:3,d:8},{n:3,d:5},{n:1,d:2},{n:3,d:4}];
    const f2 = choice(fracs); const k2 = choice([18,20,27,30,36,40,45,54,60]); const nE2 = k2 * f2.d; const p2 = f2.n / f2.d; const nA2 = k2 * f2.n;
    const f3 = choice(fracs); const k3 = choice([20,24,30,32,36,40,45,50,60,72]); const nA3 = k3 * f3.n; const p3 = f3.n / f3.d; const nE3 = k3 * f3.d;
    return { nE1, nA1, nE2, p2, nA2, nA3, p3, nE3 };
  },
  render(host, st){
    const intro =
  `\\(A\\) est une partie de \\(E\\), \\(n_A\\) est l‚Äôeffectif de \\(A\\), `
+ `\\(n_E\\) celui de \\(E\\) et \\(p\\) la proportion de \\(A\\) dans \\(E\\).`;

renderRowsUnderQuestions(host,
  '',
  [
    { labelHTML:intro },

    { labelHTML:
        `${Q(1)}On donne ${L(`n_A = ${st.nA1}`)} et ${L(`n_E = ${st.nE1}`)}. `
      + `Calculer ${L('p')} (arrondir √† ${L('0{,}001')} pr√®s).`,
      id:'r1' },

    { labelHTML:
        `${Q(2)}On donne ${L(`p = ${fmtDecFR(st.p2,3)}`)} et ${L(`n_E = ${st.nE2}`)}. `
      + `Calculer ${L('n_A')}.`,
      id:'r2' },

    { labelHTML:
        `${Q(3)}On donne ${L(`n_A = ${st.nA3}`)} et ${L(`p = ${fmtDecFR(st.p3,3)}`)}. `
      + `Calculer ${L('n_E')}.`,
      id:'r3'}
  ]
);

  },
  correct(host, st){
    const s1 = ($('#r1',host).value||'').trim();
  const v1 = parseNumberStrictFR($('#r1',host).value);
const target = st.nA1 / st.nE1;
const ok1 = Number.isFinite(v1) && (Math.round(v1*1000) === Math.round(target*1000));

const r2 = parseIntStrict($('#r2',host).value);
    const ok2 = Number.isInteger(r2) && r2===st.nA2;
const r3 = parseIntStrict($('#r3',host).value);
    const ok3 = Number.isInteger(r3) && r3===st.nE3;
    const ok = ok1 && ok2 && ok3;
    $('#res',host).innerHTML = ok? '‚úî' :
    '‚úò';
    $('#res',host).className= ok? 'res-ok':'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const r1 = intRat(st.nA1, st.nE1);
    const sDec = symTex(eqOrApproxSymbol(r1.n, r1.d, 3));
    const sPct = symTex(eqOrApproxPercentSymbol(r1.n, r1.d, 1));

    const line1 = `${Q(1)} ${L(`p = ${texFrac('n_A','n_E')} = ${texFrac(st.nA1, st.nE1)} ${sDec} ${fmtDecFR(st.nA1/st.nE1,3)} ${sPct} ${fmtDecFR(100*st.nA1/st.nE1,1)}\\,\\%`)}`;
    const line2 = `${Q(2)} ${L(`p = ${texFrac('n_A','n_E')}`)} <span class="ainsi">ainsi</span> ${L(`n_A = n_E \\times p = ${st.nE2} \\times ${fmtDecFR(st.p2,3)} = ${fmtIntOrDec(st.nA2)}`)}`;
    const line3 = `${Q(3)} ${L(`p = ${texFrac('n_A','n_E')}`)} <span class="ainsi">ainsi</span> ${L(`n_E = ${texFrac('n_A','p')} = ${texFrac(st.nA3, fmtDecFR(st.p3,3))} = ${fmtIntOrDec(st.nE3)}`)}`;

    $('#res',host).innerHTML = `<div class="sol"><p>${line1}</p><p>${line2}</p><p>${line3}</p></div>`;
    $('#res',host).className = 'res-ok';
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* 5 ‚Äî Masses & % (avec arrondis) */
const ex5 = {
  id:'masses',
  title:'Proportion d‚Äôune sous-population (conservation / % / masse)',
  gen(){
    const CTX5=[
      {thing:'maquereaux en bo√Æte', unit:'g', c1:'prot√©ines', c2:'lipides'},
      {thing:'mueslis', unit:'g', c1:'fibres', c2:'sucre'},
      {thing:'jus d‚Äôorange', unit:'mL', c1:'vitamine C (en g)', c2:'sucre'},
      {thing:'chocolats noirs', unit:'g', c1:'cacao (en g)', c2:'mati√®res grasses'},
      {thing:'boissons √©nergisantes', unit:'mL', c1:'caf√©ine (en g)', c2:'sucre'},
      {thing:'alliages m√©talliques', unit:'g', c1:'cuivre (en g)', c2:'zinc'},
      {thing:'yaourts', unit:'g', c1:'prot√©ines', c2:'lipides'},
      {thing:'fromages', unit:'g', c1:'prot√©ines', c2:'mati√®res grasses'},
      {thing:'m√©langes de fruits secs', unit:'g', c1:'amandes (en g)', c2:'noisettes'},
      {thing:'boissons au soja', unit:'mL', c1:'prot√©ines', c2:'sucre'}
    ];
    const ctx = choice(CTX5);
    const M   = choice([140,150,160,170,175,180,200,250]);
    const c1  = rnd(Math.max(5, Math.round(M*0.05)), Math.max(10, Math.round(M*0.35)));
    const p2  = choice([4.5,6.2,7.2,8.4,9.5,10,12.5,15,20]);
    const q2  = M * p2 / 100;
    return {ctx, M, c1, p2, q2};
  },
  render(host, st){
const intro = `On consid√®re des ${st.ctx.thing} de ${NI(st.M)} ${st.ctx.unit}. `;
    renderRowsUnderQuestions(host,
      'R√©pondre : Q1 ‚Üí pourcentage <em>(arrondir √† 0,01&nbsp;% pr√®s si besoin)</em> ; Q2 ‚Üí quantit√© <em>(arrondir √† l‚Äôunit√©)</em> :',
      [
        { labelHTML: intro },
        { labelHTML:
  '1) Il y a '+N(st.c1,1)+' '+st.ctx.unit+' ' + deElide(st.ctx.c1) + '. ' +
  'Quel est le pourcentage correspondant&nbsp;?<br><small>(arrondir √† 0,01&nbsp;% pr√®s)</small>',
  id:'m1'},

{ labelHTML:
  '2) Il y a '+PCT(st.p2,1)+' ' + deElide(st.ctx.c2) + '. ' +
  'Quelle est la quantit√© (en '+st.ctx.unit+') ' + deElide(st.ctx.c2) + ' ?<br><small>(arrondir √† l‚Äôunit√©)</small>',
  id:'m2'}


      ]
    );
  },
  correct(host, st){
    const pUser = parsePercentRequireSign($('#m1',host).value);
    const qUser = parseNumberFR($('#m2',host).value);
    const pExp  = 100*st.c1/st.M;
    const ok1 = Number.isFinite(pUser) && (Math.round(pUser*100) === Math.round(pExp*100));
    const qExpInt = Math.round(st.q2);
    const ok2 = Number.isFinite(qUser) && Number.isInteger(qUser) && (qUser === qExpInt);
    const ok = ok1 && ok2;
    $('#res',host).innerHTML = ok
      ? '‚úî'
      : '‚úò Attendu : '+fmtDecFR(pExp,2)+' % (arrondi √† 0,01 %) et '+qExpInt+' '+st.ctx.unit+' (arrondi √† l‚Äôunit√©).';
    $('#res',host).className = ok ? 'res-ok' : 'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const L1 = `${Q(1)} ${chainFracDecPct(fmtDecFR(st.c1,1), st.M, 2)}`;
const qExact = st.q2, qRound = Math.round(qExact);
const unitTX = st.ctx.unit; // "g", "mL", ...
const exactTX = `${tidyDecFR(qExact,3)}\\,\\mathrm{${unitTX}}`;
const roundTX = `${qRound}\\,\\mathrm{${unitTX}}`;
    const showApprox = !Number.isInteger(qExact);
const L2 = `${Q(2)} ${L(
  `${texFrac(fmtDecFR(st.p2,1),100)} \\times ${st.M} = ` +
  (showApprox ? `${exactTX} \\approx ${roundTX}` : `${roundTX}`)
)}`;
const S1 = `Il y a ${PCT(100*st.c1/st.M,2)} de ${st.ctx.c1} dans les ${st.ctx.thing}.`;
const S2 = `Il y a ${NI(qRound)} ${unitTX} de ${st.ctx.c2} dans les ${st.ctx.thing}.`;
$('#res',host).innerHTML = `<p>${L1}</p><p>${S1}</p><p>${L2}</p><p>${S2}</p>`;
    $('#res',host).className = 'res-ok';
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* 6 ‚Äî Tableau + questions (r√©partition) */
const ex6 = {
  id:'pme',
  title:'Tableau √† compl√©ter & questions (r√©partition)',
  gen(){
    const CTX6 = [
      { r1:'Cadres',        r2:'Techniciens',             where:'dans une entreprise' },
      { r1:'Enseignants',   r2:"Assistants d‚Äô√©ducation",  where:'dans un lyc√©e' },
      { r1:'M√©decins',      r2:'Infirmiers',              where:'dans un h√¥pital' },
      { r1:'Chercheurs',    r2:'Ing√©nieurs',              where:'dans un centre de recherche' },
      { r1:'B√©n√©voles',      r2:'Organisateurs',           where:'dans une association' },
      { r1:'D√©veloppeurs',  r2:'Designers',               where:'dans une agence web' },
      { r1:'Pilotes',       r2:'M√©caniciens',             where:'dans un a√©roport' },
      { r1:'Vendeurs',      r2:'Magasiniers',             where:'dans un magasin' },
      { r1:'Serveurs',      r2:'Cuisiniers',              where:'dans un restaurant' },
      { r1:'Commerciaux',   r2:'Techniciens',             where:'dans une entreprise' }
    ];

    const TOT = choice([32,36,38,40,42,48,50]);
    const ctx = choice(CTX6);

    const CH = rnd(6, 14);
    const CF = rnd(5, 14);

    let TOT_H = rnd(CH+2, Math.max(CH+2, TOT - CF));
    if (TOT_H > TOT - CF) TOT_H = TOT - CF;
    const TOT_F = TOT - TOT_H;

    const CT = CH + CF;
    const TH = TOT_H - CH;
    const TF = TOT_F - CF;
    const TT = TH + TF;

    const gAsk = choice(['H','F']);

    return { TOT, CH, CF, CT, TOT_H, TOT_F, TH, TF, TT, ctx, gAsk };
  },
  render(host, st){
    const who = `${st.ctx.r1.toLowerCase()} et ${st.ctx.r2.toLowerCase()}`;
    const tableHTML =
  '<div>Le tableau ci-dessous indique la r√©partition des '+who+' '+st.ctx.where+'.</div>'+
  '<table class="tbl" style="margin-top:8px"><thead><tr><th></th><th>Hommes</th><th>Femmes</th><th>Total</th></tr></thead>'+
  '<tbody>'+
  '<tr><td>'+st.ctx.r1+'</td><td>'+NI(st.CH)+'</td><td>'+NI(st.CF)+'</td><td><input class="c-ans" data-k="CT" type="text" placeholder=""></td></tr>'+
  '<tr><td>'+st.ctx.r2+'</td><td><input class="c-ans" data-k="TH" type="text" placeholder=""></td><td><input class="c-ans" data-k="TF" type="text" placeholder=""></td><td><input class="c-ans" data-k="TT" type="text" placeholder=""></td></tr>'+
  '<tr><td>Total</td><td>'+NI(st.TOT_H)+'</td><td><input class="c-ans" data-k="TOT_F" type="text" placeholder=""></td><td>'+NI(st.TOT)+'</td></tr>'+
  '</tbody></table>';


    const libG    = (st.gAsk==='H') ? 'hommes' : 'femmes';
    const LibGCap = (st.gAsk==='H') ? 'Hommes' : 'Femmes';
    const deG     = (st.gAsk==='H') ? 'd‚Äôhommes' : 'de femmes';
    const propG   = (st.gAsk==='H') ? 'des hommes' : 'des femmes';

    renderRowsInputRight(host,
      'Compl√©ter le tableau puis r√©pondre (entiers pour les effectifs ; pourcentages <strong>arrondis au % pr√®s</strong>) :',
      [
        { labelHTML: tableHTML, rightHTML:'' },
        { labelHTML: '2a) Combien y a-t-il '+deG+' ?', id:'q2a' },
       { labelHTML: '2b) Combien ' + deElide(st.ctx.r1.toLowerCase()) + ' ?',
  id:'q2b' },
{ labelHTML: '2c) Combien ' + deElide(st.ctx.r1.toLowerCase()) + ' hommes ?',
  id:'q2c'},
        { labelHTML: '3a) Quelle est la proportion '+propG+' ? (<em>au % pr√®s</em>)', id:'q3a'},
        { labelHTML: '3b) Quelle est la proportion des '+st.ctx.r1+' ? (<em>au % pr√®s</em>)', id:'q3b'},
        { labelHTML: '4a) Parmi les hommes, quel est le pourcentage de '+st.ctx.r1+' ? (<em>au % pr√®s</em>)', id:'q4a' },
        { labelHTML: '4b) Parmi les femmes, quel est le pourcentage de '+st.ctx.r1+' ? (<em>au % pr√®s</em>)', id:'q4b'}
      ]
    );
  },
  correct(host, st){
    const expect = {CT:st.CT, TH:st.TH, TF:st.TF, TT:st.TT, TOT_F:st.TOT_F};
    let okTable = true;
   $$('.c-ans',host).forEach(inp=>{
  const k = inp.dataset.k;
  const v = parseIntStrict((inp.value||'').trim());
  if(!Number.isInteger(v) || v!==expect[k]) okTable=false;
});

const v2a = parseIntStrict(($('#q2a',host).value||'').trim());
    const totG = (st.gAsk==='H') ? st.TOT_H : st.TOT_F;
    const ok2a = Number.isInteger(v2a) && v2a===totG;

    const ok2b = parseInt(stripSignUnicode(($('#q2b',host).value||'').trim()),10) === st.CT;
    const ok2c = parseInt(stripSignUnicode(($('#q2c',host).value||'').trim()),10) === st.CH;

    const p3a = parsePercentRequireSign($('#q3a',host).value);
    const exp3a = Math.round(100 * ((st.gAsk==='H') ? st.TOT_H : st.TOT_F) / st.TOT);
    const ok3a = Number.isFinite(p3a) && Math.round(p3a) === exp3a;

    const p3b = parsePercentRequireSign($('#q3b',host).value);
    const exp3b = Math.round(100 * st.CT / st.TOT);
    const ok3b = Number.isFinite(p3b) && Math.round(p3b) === exp3b;

    const p4a = parsePercentRequireSign($('#q4a',host).value);
    const exp4a = Math.round(100 * st.CH / st.TOT_H);
    const ok4a = Number.isFinite(p4a) && Math.round(p4a) === exp4a;

    const p4b = parsePercentRequireSign($('#q4b',host).value);
    const exp4b = Math.round(100 * st.CF / st.TOT_F);
    const ok4b = Number.isFinite(p4b) && Math.round(p4b) === exp4b;

    const ok = okTable && ok2a && ok2b && ok2c && ok3a && ok3b && ok4a && ok4b;
    $('#res',host).innerHTML = ok ? '‚úî' :
      '‚úò Pourcentages attendus au % pr√®s : '+exp3a+' %, '+exp3b+' %, '+exp4a+' %, '+exp4b+' %.';
    $('#res',host).className = ok ? 'res-ok' : 'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const solTable =
  `<table class="tbl"><thead><tr><th></th><th>Hommes</th><th>Femmes</th><th>Total</th></tr></thead>
    <tbody>
      <tr><td>${st.ctx.r1}</td><td>${NI(st.CH)}</td><td>${NI(st.CF)}</td><td>${NI(st.CT)}</td></tr>
      <tr><td>${st.ctx.r2}</td><td>${NI(st.TH)}</td><td>${NI(st.TF)}</td><td>${NI(st.TT)}</td></tr>
      <tr><td>Total</td><td>${NI(st.TOT_H)}</td><td>${NI(st.TOT_F)}</td><td>${NI(st.TOT)}</td></tr>
    </tbody></table>`;


    const r1low = st.ctx.r1.toLowerCase();
    const libG  = (st.gAsk==='H') ? 'hommes' : 'femmes';
    const propG = (st.gAsk==='H') ? 'des hommes' : 'des femmes';
    const totG  = (st.gAsk==='H') ? st.TOT_H : st.TOT_F;

const chain = (a,b) => L(`${texFrac(a,b)} = ${fmtDecFR(a/b,2)} = ${Math.round(100*a/b)}\\,\\%`);



const L2b = `${Q(2,'b')} ${L(`${st.CH} + ${st.CF} = ${st.CT}`)}`;
const S2a = `${Q(2,'a')} D‚Äôapr√®s le tableau, il y a ${NI(totG)} ${libG}.`;
const S2b = `Il y a ${NI(st.CT)} ${r1low}.`;
const S2c = `${Q(2,'c')}D‚Äôapr√®s le tableau, il y a ${NI(st.CH)} ${r1low} hommes.`;

const L3a = `${Q(3,'a')} ${chainFracDecPct(totG, st.TOT, 0)}`;
const S3a = `La proportion ${propG} est ${PCT(Math.round(100*totG/st.TOT),0)}.`;
const L3b = `${Q(3,'b')} ${chainFracDecPct(st.CT, st.TOT, 0)}`;
const S3b = `La proportion des ${r1low} est ${PCT(Math.round(100*st.CT/st.TOT),0)}.`;
const L4a = `${Q(4,'a')} ${chainFracDecPct(st.CH, st.TOT_H, 0)}`;
const S4a = `Parmi les hommes, le pourcentage de ${r1low} est ${PCT(Math.round(100*st.CH/st.TOT_H),0)}.`;
const L4b = `${Q(4,'b')} ${chainFracDecPct(st.CF, st.TOT_F, 0)}`;
const S4b = `Parmi les femmes, le pourcentage de ${r1low} est ${PCT(Math.round(100*st.CF/st.TOT_F),0)}.`;

    $('#res',host).innerHTML = `
      <div style="margin-bottom:6px"><strong>Tableau compl√©t√© :</strong></div>
      ${solTable}
      <div style="margin-top:10px"></div>
      <p>${S2a}</p><p>${L2b}</p><p>${S2b}</p><p>${S2c}</p>
      <p>${L3a}</p><p>${S3a}</p>
      <p>${L3b}</p><p>${S3b}</p>
      <p>${L4a}</p><p>${S4a}</p>
      <p>${L4b}</p><p>${S4b}</p>`;
    $('#res',host).className='res-ok';
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* 7 ‚Äî Bilan (groupe) */
/* 7 ‚Äî Bilan (groupe) */
const ex7 = {
  id:'bilan',
  title:'Bilan (groupe : filles/√¢ges)',
  gen(){
  const group = choice([
    'classe','groupe d‚Äôatelier','√©quipe','chorale','groupe de stage',
    'club de lecture','groupe de randonneurs','promo','groupe d‚Äô√©l√®ves','groupe de b√©n√©voles'
  ]);

  const N = choice([28,30,32,34,36]);

  // 1) Choisir U18 tel que n18 = N*U18/100 est ENTIER et n18 ‚â§ N-2 (=> il restera ‚â•1 √©l√®ve "ni 17 ni 18")
  const U18_ALL = [10,12.5,20,25,30,40,50];
  const U18_OK = U18_ALL.filter(p => Number.isInteger(N*p/100) && (N*p/100) <= (N-2));
  const U18 = choice(U18_OK.length ? U18_OK : U18_ALL.filter(p => Number.isInteger(N*p/100))); // repli s√ªr
  const n18 = N * U18 / 100; // entier exact

  // 2) Tirer N17 avec 1 ‚â§ N17 ‚â§ N - n18 - 1  (=> "ni 17 ni 18" ‚â• 1)
  const N17_max_soft = Math.ceil(N*0.7);
  const hardMax = Math.max(4, N - n18 - 4);
  const N17_hi = Math.min(N17_max_soft, hardMax);
  const N17_lo = 4; // jamais 0 pour √©viter 100% en 4b
  const N17 = rnd(N17_lo, N17_hi);

  // 3) Filles : garde vos bornes
  const G = rnd(Math.ceil(N*0.4), Math.ceil(N*0.75));

  // 4) Filles de 17 ans : 0 ‚â§ G17 ‚â§ min(G, N17) et coh√©rence avec les gar√ßons
  const G17_min = Math.max(0, N17 - (N - G));
  const G17_max = Math.min(G, N17);
  const G17 = rnd(Math.max(0, G17_min), Math.max(0, G17_max));

  return {group,N,G,N17,G17,U18,n18};
}
,


render(host, st){
  const intro =
    '<div>'+indefDet(st.group)+
    ' compte '+NI(st.N)+' √©l√®ves, dont '+NI(st.G)+' filles. '+
    'Parmi les '+NI(st.N17)+' √©l√®ves de 17 ans, on d√©nombre '+NI(st.G17)+' filles.</div>';

  const defGroup = defDet(st.group); // "la classe", "le groupe ‚Ä¶", "l‚Äô√©quipe", ...

  renderRowsInputRight(host,
    'R√©pondre : proportions (fraction/d√©cimal/%) et entiers quand demand√©. '+
    'Pour les <strong>pourcentages, arrondir √† 0,01&nbsp;% pr√®s</strong> (donc d√©cimaux √† 4&nbsp;d√©cimales).',
    [
      { labelHTML: intro, rightHTML:'' },

      // ‚¨áÔ∏è corrig√© : article accord√©
      { labelHTML: `1a) Quelle est la proportion de filles dans ${defGroup} ? (<em> en fraction irr√©ductible</em>)`,
        id:'b1a' },

      // ‚¨áÔ∏è corrig√© : article accord√© + espace ins√©cable avant %
      { labelHTML: `1b) En d√©duire le pourcentage de filles dans ${defGroup} ? (<em>√† 0,01&nbsp;% pr√®s</em>)`,
        id:'b1b' },

      { labelHTML: '2a) Quelle est la proportion de filles de 17 ans parmi les filles ? (<em> en fraction irr√©ductible</em>)',
        id:'b2a' },
      { labelHTML: '2b) En d√©duire le pourcentage de filles de 17 ans parmi les filles ? (<em>√† 0,01&nbsp;% pr√®s</em>)',
        id:'b2b'},

      { labelHTML: '3) Quelles sont les populations consid√©r√©es en 1) et 2) ?', id:'b3'},

      { labelHTML: `4a) Il y a  ${fmtDecFR(st.U18,1)} % d‚Äô√©l√®ves de 18 ans : combien d‚Äô√©l√®ves ont 18 ans ?`, id:'b4a'},
      { labelHTML: '4b) Quel est le pourcentage d‚Äô√©l√®ves  d‚Äô√©l√®ves n‚Äôayant ni 17 ans ni 18 ans ? (<em>√† 0,01&nbsp;% pr√®s</em>). ',
        id:'b4b' }
    ]
  );
},

  correct(host, st){
    function parseProp(s){
      s = String(s||'').trim();
      let v = NaN; const m = s.match(/^([-+]?\d+)\s*\/\s*(\d+)$/);
      if(m){ v = parseInt(m[1],10)/parseInt(m[2],10); }
      else{
        const d = parseNumberFR(s); if(isFinite(d)) v = d; else {
          const p = parsePercent(s); if(isFinite(p)) v = p/100;
        }
      }
      return v;
    }
    const samePct2 = (a,b)=> Math.round(a*100) === Math.round(b*100);
    const sameDec4 = (a,b)=> Math.round(a*1e4) === Math.round(b*1e4);
const f1 = parseIrreducibleFraction($('#b1a',host).value);
const exp1 = toIrreducible(st.G, st.N);
const ok1a = !!f1 && f1.a===exp1.n && f1.b===exp1.d;
    const ok1b = (p => Number.isFinite(p) && samePct2(p, 100*st.G/st.N))(parsePercentStrict($('#b1b',host).value));

const f2 = parseIrreducibleFraction($('#b2a',host).value);
const exp2 = toIrreducible(st.G17, st.G);
const ok2a = !!f2 && f2.a===exp2.n && f2.b===exp2.d;
    const ok2b = (p => Number.isFinite(p) && samePct2(p, 100*st.G17/st.G))(parsePercentStrict($('#b2b',host).value));

    const ans3 = ($('#b3',host).value||'').toLowerCase().replace(/\s+/g,' ').trim();
    const ok3 = ans3.includes(st.group.split(' ')[0].toLowerCase()) && ans3.includes('fille');

const ok4a = parseIntStrict($('#b4a',host).value) === st.n18;

    const p17_round = Math.round(100*st.N17/st.N);
    const exp4b = 100 - p17_round - st.U18;
    const ok4b = (p => Number.isFinite(p) && samePct2(p, exp4b))(parsePercentRequireSign($('#b4b',host).value));

    const ok = ok1a && ok1b && ok2a && ok2b && ok3 && ok4a && ok4b;
    $('#res',host).innerHTML = ok ? '‚úî' :
      '‚úò Rappels : 1a/2a d√©cimal √† 4 d√©c.; 1b/2b/4b √† 0,01 % ; en 4b, on arrondit d‚Äôabord le % des 17 ans au % pr√®s.';
    $('#res',host).className = ok ? 'res-ok' : 'res-ko';
    return {ok,total:1};
  },
  solution(host, st){
    const sDec4 = x => fmtDecFR(x, 4);
const defGroup = defDet(st.group); // "la classe", "le groupe ‚Ä¶", "l‚Äô√©quipe", ...

const r1 = toIrreducible(st.G, st.N);
const L1a = `${Q(1,'a')} ${L(`p = ${texFrac(st.G, st.N)} = ${texFrac(r1.n, r1.d)}`)}`;
const S1a = `La proportion de filles dans ${defGroup} est ${L(texFrac(r1.n, r1.d))} ${L('\\approx ' + sDec4(st.G/st.N))}.`;

    const L1b = `${Q(1,'b')} ${chainFracDecPct(st.G, st.N, 2)}`;
const S1b = `Le pourcentage de filles dans le ${st.group} est ${PCT(100*st.G/st.N,2)}.`;

const r2 = toIrreducible(st.G17, st.G);
const L2a = `${Q(2,'a')} ${L(`p = ${texFrac(st.G17, st.G)} = ${texFrac(r2.n, r2.d)}`)}`;
const S2a = `La proportion de filles de 17 ans parmi les filles est ${L(texFrac(r2.n, r2.d))} ${L('\\approx ' + sDec4(st.G17/st.G))}.`;

    const L2b = `${Q(2,'b')} ${chainFracDecPct(st.G17, st.G, 2)}`;
const S2b = `Le pourcentage de filles de 17 ans parmi les filles est ${PCT(100*st.G17/st.G,2)}.`;

    const S3  = `${Q(3)} D‚Äôapr√®s l‚Äô√©nonc√©, les populations sont ¬´ ${st.group} ¬ª et ¬´ filles ¬ª.`;

    const L4a = `${Q(4,'a')} ${L(`${texFrac(fmtDecFR(st.U18,1),100)} \\times ${st.N} = ${st.n18}`)}`;
const S4a = `Il y a ${NI(st.n18)} ${s(st.n18,'√©l√®ve','√©l√®ves')} de 18 ans.`;

    const p17_pct_exact = 100*st.N17/st.N;
    const p17_pct_round = Math.round(p17_pct_exact);
    const nonePct = 100 - p17_pct_round - st.U18;
 // --- 4b) Nouvelle pr√©sentation demand√©e ---
// √âtape 1 : nombre d'√©l√®ves de 17 OU 18 ans
const k17or18 = st.N17 + st.n18;  // 17 ans + r√©sultat 4a

// √âtape 2 : nombre d'√©l√®ves NI 17 NI 18 ans
const kNeither = st.N - k17or18;

// √âtape 3 : pourcentage (2 d√©cimales) avec "=" ou "‚âà" selon le cas
const sDec2 = symTex(eqOrApproxSymbol(kNeither, st.N, 2));           // pour le d√©cimal (2 d√©c.)
const sPct2 = symTex(eqOrApproxPercentSymbol(kNeither, st.N, 2));    // pour le %

const fracNeither = texFrac(kNeither, st.N);
const dec2  = tidyDecFR(kNeither / st.N, 4);
const pct2  = tidyDecFR(100 * kNeither / st.N, 2);

// Lignes LaTeX
// 4b ‚Äî lignes annot√©es en clair apr√®s les √©galit√©s
const L4b1 = `${Q(4,'b')} ${L(`${st.N17} + ${st.n18} = ${k17or18}`)} √©l√®ves ont 17 ans ou 18 ans.`;
const L4b2 = `${L(`${st.N} - ${k17or18} = ${kNeither}`)} √©l√®ves ont ni 17 ans ni 18 ans.`;
// (L4b3 inchang√©)
const L4b3 = chainFracDecPct(kNeither, st.N, 2);


// Phrase r√©cap
const S4b_new =
  `Parmi les ${NI(st.N)} √©l√®ves, ${NI(kNeither)} ${s(kNeither,'√©l√®ve','√©l√®ves')} ` +
  `n‚Äô${vAvoir(kNeither)} ni 17 ans ni 18 ans, soit ${PCT(100*kNeither/st.N,2)}.`;

    $('#res',host).innerHTML = [
      L1a, S1a, L1b, S1b,
      L2a, S2a, L2b, S2b,
      S3,
      L4a, S4a,
        L4b1, L4b2, L4b3, S4b_new  // 4b) (nouveau)

    ].map(x=>`<p>${x}</p>`).join('');
    $('#res',host).className='res-ok';
	retypeset(host);   // <<< NEW
  },
  reset(host){ const root=innerHost(host); root.innerHTML=''; }
};

/* ================== Registre & moteur ================== */
const REGISTRY = [ex1,ex2,ex3,ex4,ex5,ex6,ex7];
window.REGISTRY = REGISTRY;

let scoreOK = 0, scoreTot = 0;
function updateScore(){ $('#score').textContent = `Score : ${scoreOK} / ${scoreTot}`; }

function buildOne(){
  const host=$('#host'); const sel=$('#exo-select');
  const def = REGISTRY.find(e=>e.id===sel.value);
  if(!def) return;
  const st = def.gen();
  host.dataset.active = def.id;
  host.dataset.state = JSON.stringify(st);
  def.render(host, st);
    retypeset(host);   // <<< NEW

  const res = $('#res',host); if(res){ res.textContent=''; res.className='res'; }
  addTicks(host);
  progressiveValidate(host); // ne montre rien tant que vide
}

function check(){
  const host = $('#host');
  const def  = REGISTRY.find(e => e.id === host.dataset.active);
  if (!def) return;

  addTicks(host);
  progressiveValidate(host);

  if (!allInputsFilled(host)) {
    const res = $('#res', host);
    if (res) { res.textContent = ''; res.className = 'res'; }
    return; // pas de score / pas de message tant que tout n'est pas rempli
  }

  const st = JSON.parse(host.dataset.state || "{}");
  const r  = def.correct(host, st);
  if (r) { scoreOK += (r.ok ? 1 : 0); scoreTot += (r.total || 1); updateScore(); }
}

function solution(){
  const host = $('#host');
  const def  = REGISTRY.find(e => e.id === host.dataset.active);
  if (!def || !def.solution) return;

  // Snapshot des valeurs visibles pour ne PAS les √©craser
  const visInputs = $$('#host input[type=text]').filter(inp => !inp.closest('.equ-offscreen'));
  const snapshot  = new Map(visInputs.map(inp => [inp, inp.value]));

  // Affichage de la solution uniquement dans #res
  const st = JSON.parse(host.dataset.state || "{}");
  def.solution(host, st);

  // Restaure strictement la saisie de l'√©l√®ve
  for (const [inp, val] of snapshot) inp.value = val;

  // Recalcule les ‚úî/‚úò sans message global
  progressiveValidate(host);
}

function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$('#host');
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def) def.reset(host);
}

document.addEventListener('DOMContentLoaded', function(){
  innerHost(document.getElementById('host'));
  const sel=$('#exo-select');
  REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener('change', buildOne);
  $('#btn-new').addEventListener('click', buildOne);
  $('#btn-check').addEventListener('click', check);
  $('#btn-solution').addEventListener('click', solution);
  $('#btn-reset').addEventListener('click', resetAll);

  sel.value=REGISTRY[0].id; buildOne(); updateScore();

  // Entr√©e -> V√©rifier depuis n'importe quel input visible de #host (pas ceux offscreen pour le PDF)
  document.addEventListener('keydown', function(ev){
    const a = document.activeElement;
    if (ev.key === 'Enter'
        && a
        && a.matches('#host input[type=text]')
        && !a.closest('.equ-offscreen')) {
      ev.preventDefault();
      try { check(); } catch(_e){}
    }
  });

  // PDF : consigne + √©nonc√© / ou correction seule (si withSolutions)
  if(typeof ExoPDF!=='undefined' && ExoPDF && ExoPDF.init){
    ExoPDF.init({
      title:'Seconde ‚Äì Proportion & pourcentages',
      max:50,
      mountAfterSelector:'.card.small',
      beforeRender(def, st, withSolutions){
        const tmp = document.createElement('div');
        tmp.style.position='fixed'; tmp.style.left='-10000px'; tmp.style.top='-10000px';
        def.render(tmp, st);

        if(!withSolutions){
          const off = tmp.querySelector('.equ-offscreen');
          let html = off ? off.innerHTML : (tmp.querySelector('.row .col-label')?.innerHTML || '');
          // 1) enlever les aides
          html = html.replace(/<br\s*\/?>\s*<small[\s\S]*?<\/small>/gi,'')
                     .replace(/<small[\s\S]*?<\/small>/gi,'');
          // 2) bordures tableaux (style local au PDF de CETTE fiche)
          const css = `<style>
            .tbl{border-collapse:collapse;border:1px solid #000}
            .tbl td,.tbl th{border:1px solid #000;padding:3px 6px;text-align:center}
            /* carr√©s vides √† la place des inputs (garde la hauteur) */
            .pdf-blank{display:inline-block; width:90px; height:30px;}
            /* au cas o√π une cellule reste vraiment vide */
            .tbl td:empty::before{content:"\\00a0";}
          </style>`;
          return css + html;
        } else {
          if(def.solution){
            def.solution(tmp, st);
            let html = tmp.querySelector('#res')?.innerHTML || '';
            const css = `<style>
              .tbl{border-collapse:collapse;border:1px solid #000}
              .tbl td,.tbl th{border:1px solid #000;padding:3px 6px;text-align:center}
            </style>`;
            return css + html;
          }
        }
        return '';
      }
    });
  }
});
})();
</script>

<!-- JS fournis -->
<script src="../../../../js/math-kbd.js" defer></script>
<script src="../../../../js/algebra-eval-patch.multiplicatif.js" defer></script>
<script src="../../../../js/dev-rules-clean.dedup.js" defer></script>
<script src="../../../../js/fraction-sign-clarity.dom.v3.js" defer></script>
<script src="../../../../js/exo-pdf-kit.multiplicatif.js" defer></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  // 1) Barre d‚Äôactions mobile (clones des boutons existants)
  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      // Boutons bas = miroirs des originaux
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // 2) Clavier math repliable (si pr√©sent)
  const kbdHost = document.querySelector('[data-math-kbd]')?.closest('.kbd-host');
  if (kbdHost && window.innerWidth <= 760) {
    kbdHost.setAttribute('data-collapsible','');
    const tg = document.createElement('button');
    tg.className='kbd-toggle'; tg.type='button';
    tg.textContent='Clavier math';
    tg.addEventListener('click',()=>kbdHost.setAttribute('data-open', kbdHost.getAttribute('data-open')==='1'?'0':'1'));
    document.body.appendChild(tg);
  }

  // 3) Confort de saisie
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  // 4) Points √† d√©placer : rayon + touche
  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>
</body>
</html>
