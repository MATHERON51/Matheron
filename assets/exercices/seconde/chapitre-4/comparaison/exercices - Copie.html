<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì √âtude de fonctions ‚Ä¢ Tableau de variations,extremums et tableau de signe</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* √©crase le gras inline sur les z√©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }

</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äî √âtude de fonctions ‚Ä¢ Tableau de variations,extremums et tableau de signe</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, √©crire une liste. Exemple : -3;2</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax=520, Hmax=300, mL=28, mT=8, mR=8, mB=28;
  const {xmin,xmax,ymin,ymax} = opts;

const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7)); // 4.5px par d√©faut

  // 1) √âchelle commune (orthonorm√©e)
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;
  const s  = Math.min(Wmax / Rx, Hmax / Ry);      // m√™me "px par unit√©" pour x et y
  const w  = s * Rx;
  const h  = s * Ry;

  // 2) Centrage de la fen√™tre de trac√© (letterbox si besoin)
  const x0 = mL + (Wmax - w)/2;
  const y0 = mT + (Hmax - h)/2;

  // 3) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  // Cr√©ation SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','repere');

  const defs = document.createElementNS(svg.namespaceURI,'defs');
 // ‚Äî‚Äî‚Äî PATCH FLECHES ‚Äî‚Äî‚Äî

const mark = document.createElementNS(svg.namespaceURI,'marker');
mark.setAttribute('id','arrow');
mark.setAttribute('markerUnits','userSpaceOnUse');   // taille ind√©pendante du stroke
mark.setAttribute('markerWidth', AR);
mark.setAttribute('markerHeight', AR);
mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
mark.setAttribute('refX', AR);                       // ‚Üê la pointe (x=AR) tombe pile sur la fin de la ligne
mark.setAttribute('refY', AR/2);
mark.setAttribute('orient','auto');

const tri = document.createElementNS(svg.namespaceURI,'path');
// triangle : pointe √† (AR, AR/2)
tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
tri.setAttribute('fill','#111');
mark.appendChild(tri);
defs.appendChild(mark);

  const clip=document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0); crect.setAttribute('y',y0);
  crect.setAttribute('width',w); crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g');
  const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes); svg.appendChild(plot);

  // Fonctions de transformation : m√™me √©chelle s pour x et y
  const X = x => x0 + (x - xmin) * s;
  const Y = y => y0 + h - (y - ymin) * s;

  // Cadre (zone orthonorm√©e centr√©e)
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0); frame.setAttribute('y',y0);
  frame.setAttribute('width',w); frame.setAttribute('height',h);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // Axes (born√©s au cadre)
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx=document.createElementNS(svg.namespaceURI,'g');
    const ty=document.createElementNS(svg.namespaceURI,'g');

    const fmt=n=>String(n).replace('-', '‚àí');

    // verticales enti√®res
    for(let xv=Math.ceil(xmin); xv<=xmax+1e-9; xv+=1){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx); l.setAttribute('y1',y0);
      l.setAttribute('x2',xx); l.setAttribute('y2',y0+h);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(xv);
      t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
      t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }
    // horizontales enti√®res
    for(let yv=Math.ceil(ymin); yv<=ymax+1e-9; yv+=1){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0); l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w); l.setAttribute('y2',yy);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(yv);
      t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
      t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }
    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }


 // Axes fl√©ch√©s jusqu'au bord du cadre
const axX = document.createElementNS(svg.namespaceURI,'line');
axX.setAttribute('x1', x0);
axX.setAttribute('x2', x0 + w);        // ‚Üê jusqu'au bord
axX.setAttribute('y1', yAxisY);
axX.setAttribute('y2', yAxisY);
axX.setAttribute('stroke', '#111');
axX.setAttribute('stroke-width', '2.2');
axX.setAttribute('stroke-linecap', 'butt'); // ‚Üê pas d‚Äôarrondi qui d√©passe
if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axX);

const axY = document.createElementNS(svg.namespaceURI,'line');
axY.setAttribute('x1', xAxisX);
axY.setAttribute('x2', xAxisX);
axY.setAttribute('y1', y0 + h);
axY.setAttribute('y2', y0);            // ‚Üê jusqu'au bord
axY.setAttribute('stroke', '#111');
axY.setAttribute('stroke-width', '2.2');
axY.setAttribute('stroke-linecap', 'butt'); // ‚Üê idem
if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axY);


  // inverses (px -> unit√©s)
  const Xi = px => xmin + (px - x0) / s;
  const Yi = py => ymin + (y0 + h - py) / s;

  // grande zone "hit" cliquable exactement sur le cadre
  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0); hit.setAttribute('y', y0);
  hit.setAttribute('width', w); hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };

}

// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}


const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };





// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// EXERCICE 3 ‚Äî Lire un tableau de variations (domaine, extr√©mums, QCM)
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const ex1 = {
  id:'var_table_read_qcm',
  title:'Lire un tableau de variations (domaine, extr√©mums, QCM)',
  gen(){
    // on fabrique 5 bornes enti√®res espac√©es (comme l‚Äôexemple : ‚àí4, ‚àí2, 0, 4, 6)
    const X = (()=> {
      const a = [-6,-5,-4][-~(Math.random()*3|0)%3];
      const steps = [2,2,4,2];                 // espacements lisibles
      const x0=a, x1=x0+steps[0], x2=x1+steps[1], x3=x2+steps[2], x4=x3+steps[3];
      return [x0,x1,x2,x3,x4];
    })();

    // valeurs aux noeuds, en alternant ‚Üó‚Üò‚Üó‚Üò avec amplitudes enti√®res lisibles
    const start = [-3,-2,-1][Math.floor(Math.random()*3)];
    const ups   = [2,3,4], downs = [2,3];
    const y0 = start;
    const y1 = y0 + ups[Math.floor(Math.random()*ups.length)];
    const y2 = y1 - (downs[Math.floor(Math.random()*downs.length)] + 1); // stricte
    const y3 = y2 + ups[Math.floor(Math.random()*ups.length)];
    const y4 = y3 - (downs[Math.floor(Math.random()*downs.length)] + 1);

    const Y = [y0,y1,y2,y3,y4];                // images connues aux bornes
    const DIR = ['‚Üó','‚Üò','‚Üó','‚Üò'];            // sens impos√©

    // intervalle de la question 3 (max/min) : on prend [X[1];X[4]] pour forcer un extr√©mum interne
    const Iq = [X[1], X[4]];

    // Fabrique quelques √©nonc√©s QCM (certains conclusifs, d‚Äôautres ¬´ ? ¬ª)
    function S(f){ return String(f).replace('-','‚àí'); }
    const pickInside = i => (X[i] + X[i+1]) / 2;       // point int√©rieur au segment i
// ================== QCM (question 4) ==================
function S(n){ return String(n).replace('-', '‚àí'); }
const incIdx = [...DIR.keys()].filter(i=>DIR[i]==='‚Üó');
const decIdx = [...DIR.keys()].filter(i=>DIR[i]==='‚Üò');
const usedPairs = new Set();
const keyPair = (x1,x2)=>`${x1}|${x2}`;

function intsIn(i){
  const A=[], a=X[i], b=X[i+1];
  for(let t=a; t<=b; t++) A.push(t);
  return A;
}
function pickPair(i){
  const L=intsIn(i); const P=[];
  for(let p=0;p<L.length;p++) for(let q=p+1;q<L.length;q++) P.push([L[p],L[q]]);
  // √©viter les r√©p√©titions globales
  const cand = P.filter(([u,v])=>!usedPairs.has(keyPair(u,v)));
  const [x1,x2] = (cand.length? choice(cand) : choice(P));
  usedPairs.add(keyPair(x1,x2));
  return [x1,x2];
}
function pickTwoDistinct(idxs){
  if(idxs.length>=2){
    const shuffled=[...idxs].sort(()=>Math.random()-0.5);
    return [shuffled[0], shuffled[1]];
  }
  // secours : duplique et prendra des paires diff√©rentes
  return [idxxs[0], idxxs[0]];
}

// ‚Äî A. CROISSANTE : vraie et fausse depuis DEUX intervalles croissants DISTINCTS
let [iInc1, iInc2] = pickTwoDistinct(incIdx);
let [a1,a2] = pickPair(iInc1);
let [a3,a4] = pickPair(iInc2);
const stmts_inc = [
  { k:'a1', txt:`f(${S(a1)}) < f(${S(a2)})`, want:'v' },  // vrai sur iInc1
  { k:'a2', txt:`f(${S(a3)}) > f(${S(a4)})`, want:'f' },  // faux sur iInc2
];

// ‚Äî B. D√âCROISSANTE : vraie et fausse depuis DEUX intervalles d√©croissants DISTINCTS
let [iDec1, iDec2] = pickTwoDistinct(decIdx);
let [b1,b2] = pickPair(iDec1);
let [b3,b4] = pickPair(iDec2);
const stmts_dec = [
  { k:'b1', txt:`f(${S(b1)}) > f(${S(b2)})`, want:'v' },  // vrai sur iDec1
  { k:'b2', txt:`f(${S(b3)}) < f(${S(b4)})`, want:'f' },  // faux sur iDec2
];

// ‚Äî C. comparaison √† un max/min : 1 vraie + 1 fausse (x entier non extr√©mal)
const yMax = Math.max(...Y), yMin = Math.min(...Y);
const extXs = new Set(X.filter((_,i)=>Y[i]===yMax || Y[i]===yMin));
function pickXnotExt(){
  const pool = [...incIdx, ...decIdx].flatMap(i=>intsIn(i));
  const cand = pool.filter(x=>!extXs.has(x));
  return choice(cand.length?cand:pool);
}
const xc = pickXnotExt();
const stmts_k = [
  { k:'c1', txt:`f(${S(xc)}) < ${S(yMax)}`, want:'v' },
  { k:'c2', txt:`f(${S(xc)}) > ${S(yMin)}`, want:'f' },
];

// ‚Äî D. & E. cas ‚Äúnc‚Äù (intervalles cons√©cutifs de sens oppos√©s) et cas ‚Äúextr√©mum concluant‚Äù
function findTurn(){
  for(let i=0;i<DIR.length-1;i++){
    if ((DIR[i]==='‚Üó' && DIR[i+1]==='‚Üò') || (DIR[i]==='‚Üò' && DIR[i+1]==='‚Üó')) return i;
  }
  return -1;
}
let stmt_nc, stmt_ext;
const t = findTurn();
if (t !== -1){
  const xL = choice(intsIn(t)), xR = choice(intsIn(t+1));
  const sym = choice(['<','>']);
  stmt_nc = { k:'d1', txt:`f(${S(xL)}) ${sym} f(${S(xR)})`, want:'nc' };

  // extr√©mum au n≈ìud X[t+1], comparer avec un entier de l‚Äôautre intervalle
  const isMax = (DIR[t]==='‚Üó' && DIR[t+1]==='‚Üò');
  const isMin = (DIR[t]==='‚Üò' && DIR[t+1]==='‚Üó');
  const xExt = X[t+1];
  const otherI = isMax ? (t+1) : t;
  const xO = choice(intsIn(otherI));
  const makeTrue = choice([true,false]);
  stmt_ext = isMax
    ? (makeTrue ? {k:'e1', txt:`f(${S(xExt)}) > f(${S(xO)})`, want:'v'}
                 : {k:'e1', txt:`f(${S(xExt)}) < f(${S(xO)})`, want:'f'})
    : (makeTrue ? {k:'e1', txt:`f(${S(xExt)}) < f(${S(xO)})`, want:'v'}
                 : {k:'e1', txt:`f(${S(xExt)}) > f(${S(xO)})`, want:'f'});
} else {
  // secours : deux intervalles quelconques (nc) + comparaison avec un max global (concluant)
  const ia = choice([...incIdx, ...decIdx]);
  const ib = choice([...incIdx, ...decIdx].filter(j=>j!==ia));
  stmt_nc = { k:'d1', txt:`f(${S(choice(intsIn(ia)))}) < f(${S(choice(intsIn(ib)))})`, want:'nc' };
  const xO = choice(intsIn(ia));
  stmt_ext = { k:'e1', txt:`f(${S(choice(X.filter((_,i)=>Y[i]===yMax)))}) ‚â• f(${S(xO)})`, want:'v' };
}

// ‚Äî M√©lange al√©atoire de l‚Äôordre des deux derni√®res questions (d / e)
const tail = Math.random()<0.5 ? [stmt_nc, stmt_ext] : [stmt_ext, stmt_nc];

// ‚Äî Assemblage final
// Assemblage + m√©lange COMPLET de l'ordre des questions
const stmts = [
  ...stmts_inc,   // croissante : V/F (intervalle A ‚â† intervalle B)
  ...stmts_dec,   // d√©croissante : V/F (intervalle C ‚â† intervalle D)
  ...stmts_k,     // max/min : V/F
  stmt_nc,        // impossible de conclure
  stmt_ext        // concluable avec extr√©mum (V ou F)
];
shuffle(stmts);   // ‚Üê ordre al√©atoire √† chaque g√©n√©ration

return { X, Y, DIR, Iq, stmts };




  },

  render(host, st){
    const {X,Y,DIR,Iq,stmts} = st;

    // variation table en ‚Äúlecture‚Äù (affich√©, non √©ditable)
    function rowX(){
      let r = '<tr><th>\\(x\\)</th>';
      X.forEach((x,i)=>{ r += `<td>\\(${String(x).replace('-','‚àí')}\\)</td>`; if(i<X.length-1) r+='<td></td>'; });
      r += '</tr>'; return r;
    }
function rowF(){
  let r = '<tr><th>\\(f\\)</th>';

  // --- cellule de d√©part (x0) : haut si max, bas si min ---
  const isMax0 = (DIR[0] === '‚Üò');      // si √ßa descend, y0 est un max
  const up0 = isMax0 ? `\\(${Y[0]}\\)` : '&nbsp;';
  const dn0 = isMax0 ? '&nbsp;' : `\\(${Y[0]}\\)`;
  r += `<td style="text-align:center"><div>${up0}</div><div style="height:6px"></div><div>${dn0}</div></td>`;

  // --- cellules internes (inchang√© sauf qu‚Äôon a d√©j√† trait√© y0) ---
  for(let i=0;i<DIR.length;i++){
    r += `<td style="text-align:center">${DIR[i]}</td>`;
    const isMax = (DIR[i]==='‚Üó' && DIR[i+1]==='‚Üò') || (i===DIR.length-1 && DIR[i]==='‚Üó');
    const up = isMax ? `\\(${Y[i+1]}\\)` : '&nbsp;';
    const dn = isMax ? '&nbsp;' : `\\(${Y[i+1]}\\)`;
    r += `<td style="text-align:center"><div>${up}</div><div style="height:6px"></div><div>${dn}</div></td>`;
  }
  r += '</tr>';
  return r;
}


    host.innerHTML = `
      <div>On donne le tableau de variation d‚Äôune fonction \\(f\\) :</div>
      <div class="var-wrap">
        <table class="pdf-tbl">
          <thead>${rowX()}</thead>
          <tbody>${rowF()}</tbody>
        </table>
      </div>

      <ol style="margin:.4rem 0 0 1.2rem">
        <li style="margin:.25rem 0">
          D√©terminer l‚Äô<b>ensemble de d√©finition</b> de \\(f\\).
          <div style="display:inline-flex;gap:8px;align-items:center;margin-left:8px">
            <input class="q-dom" type="text" placeholder="[a; b]" style="width:120px;text-align:center">
            <span class="tick nu"></span>
          </div>
        </li>

        <li style="margin:.25rem 0">
          D√©crire les <b>variations</b> (choisir ‚Üó ou ‚Üò pour chaque intervalle).
          <div class="var-wrap" style="margin-top:.3rem">
            ${X.slice(0,-1).map((x,i)=>`
              <div style="display:inline-flex;gap:6px;align-items:center;margin:2px 8px">
                <span>[${String(X[i]).replace('-','‚àí')} ; ${String(X[i+1]).replace('-','‚àí')}] :</span>
                <select class="q-dir" data-i="${i}">
                  <option value=""></option><option>‚Üò</option><option>‚Üó</option>
                </select>
                <span class="tick nu"></span>
              </div>`).join('')}
          </div>
        </li>

        <li style="margin:.25rem 0">
          Quel est le <b>maximum</b> de \\(f\\) sur
          \\([${String(Iq[0]).replace('-','‚àí')} ; ${String(Iq[1]).replace('-','‚àí')}]\\) ?
          En quelle(s) valeur(s) est-il atteint ?
          <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:.3rem 0 0 .2rem">
            <label>Valeur :</label>
            <input class="q-maxy" type="text" style="width:90px;text-align:center"><span class="tick nu"></span>
            <label>En \\(x=\\)</label>
            <input class="q-maxx" type="text" placeholder="liste ex. 0;4" style="width:130px;text-align:center"><span class="tick nu"></span>
          </div>
        </li>

        <li style="margin:.25rem 0">
          En justifiant ces r√©ponses, indiquer si chaque affirmation est <b>Vraie</b>, <b>Fausse</b> ou ¬´ <b>Impossible de conclure</b> ¬ª.
          <div style="margin:.35rem 0 0 .2rem">
            <ol type="a" style="margin:0 0 0 1.2rem">
              ${stmts.map(s=>`
                <li style="margin:.2rem 0">
                  \\(${s.txt}\\)
                  <select class="q-qcm" data-k="${s.k}">
                    <option value=""></option><option value="v">Vrai</option><option value="f">Faux</option><option value="nc">Impossible</option>
                  </select>
                  <span class="tick nu"></span>
                </li>`).join('')}
            </ol>
          </div>
        </li>
      </ol>
      <div class="steps small" id="res" style="margin-top:.5rem"></div>
    `;

    host.dataset.state_extra = JSON.stringify({}); // placeholder
    host.querySelectorAll('input,select').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st){
    const {X,Y,DIR,Iq,stmts} = st;
    let ok=0, tot=0;
    const norm = s => (s||'').trim().replace(/\u2212/g,'-').replace(/\s/g,'').replace(',', '.');

    // (1) Domaine
    const dom = host.querySelector('.q-dom');
    const wantDom = `[${X[0]};${X[X.length-1]}]`;
    if(dom && norm(dom.value)!==''){
      tot++;
      const v = norm(dom.value).replace(/;/g,';').replace(/\s/g,'');
      const good = v === `[${X[0]};${X[X.length-1]}]`;
      setTick(dom, good?'ok':'ko'); if(good) ok++;
    }

    // (2) Variations
    host.querySelectorAll('.q-dir').forEach((sel,i)=>{
      if(!sel.value) return;
      tot++; const good = sel.value===DIR[i];
      setTick(sel, good?'ok':'ko'); if(good) ok++;
    });

    // (3) Maximum sur [Iq]
    // on regarde les n≈ìuds inclus dans l‚Äôintervalle
    const idxL = X.findIndex(v=>v===Iq[0]);
    const idxR = X.findIndex(v=>v===Iq[1]);
    const subY = Y.slice(idxL, idxR+1);
    const subX = X.slice(idxL, idxR+1);
    const ymax = Math.max(...subY);
    const Xmax = subX.filter((_,i)=>subY[i]===ymax);

    const inMaxY = host.querySelector('.q-maxy');
    if(inMaxY && norm(inMaxY.value)!==''){ tot++; const good=(norm(inMaxY.value)===String(ymax)); setTick(inMaxY, good?'ok':'ko'); if(good) ok++; }

    const inMaxX = host.querySelector('.q-maxx');
    if(inMaxX && norm(inMaxX.value)!==''){
      tot++;
      const Ans = norm(inMaxX.value).split(';').filter(Boolean).map(s=>s.replace(',', '.'));
      const A=[...new Set(Ans)].sort(); const R=[...new Set(Xmax.map(String))].sort();
      const good = (A.length===R.length) && A.every((v,i)=>v===R[i]);
      setTick(inMaxX, good?'ok':'ko'); if(good) ok++;
    }

    // (4) QCM
 function evalStmt(s){ return s.want; }   // 'v' | 'f' | 'nc'

    host.querySelectorAll('.q-qcm').forEach(sel=>{
      if(!sel.value) return;
      tot++; const s = stmts.find(t=>t.k===sel.dataset.k);
      const want = evalStmt(s);
      const good = (sel.value===want);
      setTick(sel, good?'ok':'ko'); if(good) ok++;
    });

    const res=$('#res',host);
    res.textContent = '';
    ensureTickAfter(res).className = 'tick ' + (ok===tot && tot>0 ? 'ok' : 'nu');
    return {ok, total: tot};
  },

  solution(host, st){
    const {X,Y,DIR,Iq,stmts} = st;
    const idxL = X.findIndex(v=>v===Iq[0]);
    const idxR = X.findIndex(v=>v===Iq[1]);
    const subY = Y.slice(idxL, idxR+1);
    const subX = X.slice(idxL, idxR+1);
    const ymax = Math.max(...subY);
    const Xmax = subX.filter((_,i)=>subY[i]===ymax);

    const fmt = s=>String(s).replace('-','‚àí');
    const box = $('#res',host);
	
	
	const word = w => w==='v' ? 'Vrai' : w==='f' ? 'Faux' : 'Impossible';
	
    box.innerHTML = `
      <div class="step"><b>1.</b> Domaine : \\([${fmt(X[0])}\\,;\\,${fmt(X[X.length-1])}]\\).</div>
      <div class="step"><b>2.</b> Variations :
        ${X.slice(0,-1).map((_,i)=>`[${fmt(X[i])} ; ${fmt(X[i+1])}] : ${DIR[i]}`).join(' \\;\\; ')}
      </div>
      <div class="step"><b>3.</b> Sur \\([${fmt(Iq[0])}\\,;\\,${fmt(Iq[1])}]\\), le maximum vaut \\(${ymax}\\) atteint en ${Xmax.map(x=>`\\(x=${fmt(x)}\\)`).join(' et ')}.</div>
      <div class="step"><b>4.</b> QCM :</div>
      <ul style="margin:.2rem 0 0 1.1rem">
      ${stmts.map(s=>`<li>\\(${s.txt}\\) : <b>${word(s.want)}</b></li>`).join('')}

      </ul>
    `;
    typesetAll(box);
  },

  reset(host){ $('#res',host).textContent=''; }
};






/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì √âtude de fonctions ‚Ä¢ Sens de variations',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
