<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde â€“ Ã‰tude de fonctions â€¢ Tableau de variations,extremums et tableau de signe</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'âœ“'; color:#11823b; }
  .tick.ko::after{ content:'âœ—'; color:#b00020; }

  /* mini tableaux â€œPDF-likeâ€ (cadre extÃ©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + sÃ©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures intÃ©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre extÃ©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* SÃ©paration verticale aprÃ¨s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* SÃ©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule flÃ¨che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la flÃ¨che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enlÃ¨ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* BÃ‚TONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins Ã©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* Ã©vite que Ã§a dÃ©borde verticalement */
}
/* Ã©crase le gras inline sur les zÃ©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }

/* Affichage conditionnel */
@media screen { .screen-only{display:block!important} .print-only{display:none!important} }
@media print  { .screen-only{display:none!important} .print-only{display:block!important} }

/* Tableau QCM (Ã©cran) */
.table-qcm-screen{
  width:100%;
  border-collapse:separate;
  border-spacing:12px 8px;
}
.table-qcm-screen td{ width:50%; vertical-align:top }
.table-qcm-screen .cell{
  border:1px solid var(--line);
  border-radius:10px;
  padding:10px 12px;
  background:#fff;
}
.table-qcm-screen .num{ font-weight:700; margin-right:6px }
.table-qcm-screen select{ margin-left:8px }


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde â€” Ã‰tude de fonctions â€¢ Tableau de variations,extremums et tableau de signe</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type dâ€™exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">ðŸ”„ Nouvel Ã©noncÃ©</button>
      <button id="btn-check" class="btn">âœ… VÃ©rifier</button>
      <button id="btn-solution" class="btn">ðŸ’¡ Solution</button>
      <button id="btn-reset" class="btn">ðŸ§¹ RÃ©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>FlÃ¨ches : choisissez â†˜ ou â†—.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, Ã©crire une liste. Exemple : -3;2</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- mÃªme emplacement que dans ton modÃ¨le -->

<script>
(function(){
'use strict';

/* â€”â€”â€”â€”â€” Utils â€”â€”â€”â€”â€” */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='âˆ’';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){
  if(!el) return null;

  // 1) voisin immÃ©diat
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;

  // 2) chercher un tick dÃ©jÃ  prÃ©sent dans le mÃªme <li>
  const li = el.closest('li');
  if (li) {
    const found = li.querySelector(':scope > .tick');
    if (found) return found;
  }

  // 3) crÃ©er un tick et lâ€™ajouter en fin de <li> (ou juste aprÃ¨s el en secours)
  s = document.createElement('span');
  s.className = 'tick nu';
  if (li) li.appendChild(s);
  else el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax=520, Hmax=300, mL=28, mT=8, mR=8, mB=28;
  const {xmin,xmax,ymin,ymax} = opts;

const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7)); // 4.5px par dÃ©faut

  // 1) Ã‰chelle commune (orthonormÃ©e)
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;
  const s  = Math.min(Wmax / Rx, Hmax / Ry);      // mÃªme "px par unitÃ©" pour x et y
  const w  = s * Rx;
  const h  = s * Ry;

  // 2) Centrage de la fenÃªtre de tracÃ© (letterbox si besoin)
  const x0 = mL + (Wmax - w)/2;
  const y0 = mT + (Hmax - h)/2;

  // 3) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  // CrÃ©ation SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','repere');

  const defs = document.createElementNS(svg.namespaceURI,'defs');
 // â€”â€”â€” PATCH FLECHES â€”â€”â€”

const mark = document.createElementNS(svg.namespaceURI,'marker');
mark.setAttribute('id','arrow');
mark.setAttribute('markerUnits','userSpaceOnUse');   // taille indÃ©pendante du stroke
mark.setAttribute('markerWidth', AR);
mark.setAttribute('markerHeight', AR);
mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
mark.setAttribute('refX', AR);                       // â† la pointe (x=AR) tombe pile sur la fin de la ligne
mark.setAttribute('refY', AR/2);
mark.setAttribute('orient','auto');

const tri = document.createElementNS(svg.namespaceURI,'path');
// triangle : pointe Ã  (AR, AR/2)
tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
tri.setAttribute('fill','#111');
mark.appendChild(tri);
defs.appendChild(mark);

  const clip=document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0); crect.setAttribute('y',y0);
  crect.setAttribute('width',w); crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g');
  const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes); svg.appendChild(plot);

  // Fonctions de transformation : mÃªme Ã©chelle s pour x et y
  const X = x => x0 + (x - xmin) * s;
  const Y = y => y0 + h - (y - ymin) * s;

  // Cadre (zone orthonormÃ©e centrÃ©e)
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0); frame.setAttribute('y',y0);
  frame.setAttribute('width',w); frame.setAttribute('height',h);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // Axes (bornÃ©s au cadre)
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx=document.createElementNS(svg.namespaceURI,'g');
    const ty=document.createElementNS(svg.namespaceURI,'g');

    const fmt=n=>String(n).replace('-', 'âˆ’');

    // verticales entiÃ¨res
    for(let xv=Math.ceil(xmin); xv<=xmax+1e-9; xv+=1){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx); l.setAttribute('y1',y0);
      l.setAttribute('x2',xx); l.setAttribute('y2',y0+h);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(xv);
      t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
      t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }
    // horizontales entiÃ¨res
    for(let yv=Math.ceil(ymin); yv<=ymax+1e-9; yv+=1){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0); l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w); l.setAttribute('y2',yy);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(yv);
      t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
      t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }
    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }


 // Axes flÃ©chÃ©s jusqu'au bord du cadre
const axX = document.createElementNS(svg.namespaceURI,'line');
axX.setAttribute('x1', x0);
axX.setAttribute('x2', x0 + w);        // â† jusqu'au bord
axX.setAttribute('y1', yAxisY);
axX.setAttribute('y2', yAxisY);
axX.setAttribute('stroke', '#111');
axX.setAttribute('stroke-width', '2.2');
axX.setAttribute('stroke-linecap', 'butt'); // â† pas dâ€™arrondi qui dÃ©passe
if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axX);

const axY = document.createElementNS(svg.namespaceURI,'line');
axY.setAttribute('x1', xAxisX);
axY.setAttribute('x2', xAxisX);
axY.setAttribute('y1', y0 + h);
axY.setAttribute('y2', y0);            // â† jusqu'au bord
axY.setAttribute('stroke', '#111');
axY.setAttribute('stroke-width', '2.2');
axY.setAttribute('stroke-linecap', 'butt'); // â† idem
if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axY);


  // inverses (px -> unitÃ©s)
  const Xi = px => xmin + (px - x0) / s;
  const Yi = py => ymin + (y0 + h - py) / s;

  // grande zone "hit" cliquable exactement sur le cadre
  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0); hit.setAttribute('y', y0);
  hit.setAttribute('width', w); hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };

}

// utilitaires tracÃ©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* â€”â€”â€”â€”â€” Petits rendus de tableaux â€”â€”â€”â€”â€” */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contrÃ´le BÃ©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] triÃ©s
  // 1) Ã‰carter les voisins d'un zÃ©ro et imposer une pente minimale au zÃ©ro
  const MIN_SLOPE = 0.35;  // pente minimale au zÃ©ro (croisement visible)
  const MIN_AWAY  = 1;     // Ã©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes opposÃ©s et "Ã©loignÃ©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assurÃ© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "dÃ©-ondulationne"
  //    en bornant les pentes Ã  proximitÃ© de la sÃ©cante (Ã©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes calÃ©es sur ~80% de la sÃ©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extrÃ©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extrÃ©mum Ã  extrÃ©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de rÃ©fÃ©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extrÃ©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritschâ€“Carlson pour chaque segment (Ã©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non dÃ©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pondÃ©rÃ©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritschâ€“Carlson : imposer monotonicitÃ© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat â†’ pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 â†’ on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique dâ€™une courbe lisse avec n extrÃ©mums (entiers), sans plateau, + padding vertical
// â€”â€”â€” remplace entiÃ¨rement la fonction â€”â€”â€”
// --- Fabrique au propre : courbe lisse + racines entiÃ¨res (zÃ©ros sur des entiers) ---
// --- Courbe lisse : extrÃ©mums entiers (comme avant), + racines SIMPLES Ã  x entiers (â‰  extrÃ©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // Ã©chantillonnage avec Ã©cart â‰¥ 2 entre extrÃ©mums et â‰¥ 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : relÃ¢che Ã  Ã©cart â‰¥1 si trop serrÃ©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas dâ€™extremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // nÅ“uds initiaux : borne, extrÃ©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// â€”â€”â€” INSÃ‰RER DES RACINES UNIQUEMENT Ã€ DES ENTIERS â€”â€”â€”
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // zÃ©ro interne Ã  entier
      i++;
    } else {
      // largeur 1 : placer le zÃ©ro sur une ancre, en Ã©vitant un extrÃ©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 â‡’ extrÃ©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // zÃ©ro sur lâ€™ancre
    }
  }
}
// Nettoyage de sÃ©curitÃ© : retirer tout nÅ“ud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extrÃ©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // â€”â€”â€” ORIENTER les pentes des racines et CLAMP monotone (helpers dÃ©jÃ  fournis) â€”â€”â€”
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // repÃ¨re symÃ©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes oÃ¹ y=0 (uniques, triÃ©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchangÃ©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // â† dÃ©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}


const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };

// map + concat sans .join
function mapHTML(arr, render, sep=''){
  let out = '';
  for (let i = 0; i < arr.length; i++){
    out += render(arr[i], i);
    if (sep && i < arr.length - 1) out += sep;
  }
  return out;
}



const toTeX = s => s.replace(/</g, '\\lt ').replace(/>/g, '\\gt ');
const escHTML = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');



// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// EXERCICE 3 â€” Lire un tableau de variations (domaine, extrÃ©mums, QCM)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
const ex1 = {
  id:'var_table_read_qcm',
  title:'Lire un tableau de variations (domaine, extrÃ©mums, QCM)',
  gen(){
    // on fabrique 5 bornes entiÃ¨res espacÃ©es (comme lâ€™exemple : âˆ’4, âˆ’2, 0, 4, 6)
// --- Domaine large NON SYMÃ‰TRIQUE avec entiers intÃ©rieurs garantis ---
function makeNonSymmetricX(){
  // Ã‰carts (â‰¥3) pour assurer des entiers strictement intÃ©rieurs
  const steps = Array.from({length:4}, ()=> rint(3,7));     // tailles 3..7 (modifiable)
  const span  = steps.reduce((a,b)=>a+b,0);

  // Choix dâ€™une borne gauche large et non symÃ©trique
  // -> Ajuste ces bornes si tu veux "voir plus si nÃ©cessaire"
  const LMIN = -20, RMAX_TARGET = 20;                       // fenÃªtre globale dÃ©sirÃ©e
  const LMAX = Math.max(LMIN, RMAX_TARGET - span);          // borne droite â‰² RMAX_TARGET
  const L    = rint(LMIN, LMAX);                            // borne gauche alÃ©atoire

  // Construit X = [x0, ..., x4] strictement croissant
  const X = [L];
  for (const s of steps) X.push(X[X.length-1] + s);
  return X;
}
const X = makeNonSymmetricX();


    // valeurs aux noeuds, en alternant â†—â†˜â†—â†˜ avec amplitudes entiÃ¨res lisibles
// â€” sens de variation : on NE commence pas toujours par croissant
const startDir = choice(['â†—','â†˜']);
const DIR = Array.from({length:4}, (_,i)=> (i%2===0 ? startDir : (startDir==='â†—'?'â†˜':'â†—')));

// â€” amplitudes lisibles
const ups = [2,3,4], downs = [2,3];

// â€” valeurs aux noeuds, cohÃ©rentes avec DIR
let y0 = rint(-3, 2);
const Y = [y0];
for (let i=0; i<DIR.length; i++){
  if (DIR[i] === 'â†—'){
    Y.push(Y[i] + choice(ups));             // strictement â†‘
  } else {
    Y.push(Y[i] - (choice(downs) + 1));     // strictement â†“
  }
}
        // sens imposÃ©

    // intervalle de la question 3 (max/min) : on prend [X[1];X[4]] pour forcer un extrÃ©mum interne
    const Iq = [X[1], X[4]];


// Helpers dâ€™entiers dÃ©pendants de X (portÃ©e locale Ã  gen)
function intsIn(i){
  const a = X[i], b = X[i+1], L = [];
  for(let t=a; t<=b; t++) L.push(t);
  return L;
}
function intsOpen(i){           // entiers strictement Ã  lâ€™intÃ©rieur
  const L = [];
  for(let t=X[i]+1; t<=X[i+1]-1; t++) L.push(t);
  return L;
}
function intsLeft(i){           // intÃ©rieur sinon borne gauche
  const L = intsOpen(i);
  return L.length ? L : [X[i]];
}
function intsRight(i){          // intÃ©rieur sinon borne droite
  const L = intsOpen(i);
  return L.length ? L : [X[i+1]];
}





    // Fabrique quelques Ã©noncÃ©s QCM (certains conclusifs, dâ€™autres Â« ? Â»)
    function S(f){ return String(f).replace('-','âˆ’'); }
    const pickInside = i => (X[i] + X[i+1]) / 2;       // point intÃ©rieur au segment i
// â€”â€”â€”â€”â€” QCM (question 4) â€”â€”â€”â€”â€”
// â€”â€”â€”â€”â€” QCM (question 4) â€”â€”â€”â€”â€”

const incIdx = [...DIR.keys()].filter(i => DIR[i] === 'â†—');
const decIdx = [...DIR.keys()].filter(i => DIR[i] === 'â†˜');


function pickPairInInterval(i){
  const pool = (intsOpen(i).length ? intsOpen(i) : intsIn(i));
  const P = [];
  for(let p=0; p<pool.length; p++){
    for(let q=p+1; q<pool.length; q++){
      P.push([pool[p], pool[q]]);
    }
  }
  return P.length ? P[Math.floor(Math.random()*P.length)] : [X[i], X[i+1]];
}


function pickTwoDistinct(idxs){
  if(idxs.length >= 2){
    const sh = [...idxs].sort(() => Math.random()-0.5);
    return [sh[0], sh[1]];
  }
  return [idxs[0], idxs[0]]; // fallback (ne devrait pas arriver ici)
}

// A) CROISSANTE : 1 vraie + 1 fausse, sur deux intervalles â†— distincts
let [iInc1, iInc2] = pickTwoDistinct(incIdx);
let [a1, a2] = pickPairInInterval(iInc1);
let [a3, a4] = pickPairInInterval(iInc2);
const partA = [
  { id: 'inc_v',  want:'v', type:'inc', i:iInc1, x1:a1, x2:a2, txt:`f(${S(a1)}) < f(${S(a2)})` },
  { id: 'inc_f',  want:'f', type:'inc', i:iInc2, x1:a3, x2:a4, txt:`f(${S(a3)}) > f(${S(a4)})` },
];

// B) DÃ‰CROISSANTE : 1 vraie + 1 fausse, sur deux intervalles â†˜ distincts
let [iDec1, iDec2] = pickTwoDistinct(decIdx);
let [b1, b2] = pickPairInInterval(iDec1);
let [b3, b4] = pickPairInInterval(iDec2);
const partB = [
  { id: 'dec_v',  want:'v', type:'dec', i:iDec1, x1:b1, x2:b2, txt:`f(${S(b1)}) > f(${S(b2)})` },
  { id: 'dec_f',  want:'f', type:'dec', i:iDec2, x1:b3, x2:b4, txt:`f(${S(b3)}) < f(${S(b4)})` },
];

// C) Comparaison Ã  un max et Ã  un min : 1 vraie + 1 fausse
// â€” C) Comparaison Ã  un max ET Ã  un min â€” chacune peut Ãªtre VRAIE ou FAUSSE
const yMax = Math.max(...Y);
const yMin = Math.min(...Y);

// x entiers non extrÃ©maux (pour assurer les strictes inÃ©galitÃ©s)
const extXs = new Set(X.filter((_, i) => Y[i] === yMax || Y[i] === yMin));
function intsIn(i){ const L=[]; for(let t=X[i]; t<=X[i+1]; t++) L.push(t); return L; }
function pickXnotExt(){
  const pool = [...DIR.keys()].flatMap(i=>intsIn(i));
  const cand = pool.filter(x=>!extXs.has(x));
  return choice(cand.length ? cand : pool);
}

const idxForMax = choice([...DIR.keys()]);          // on choisit un intervalle
const Lmax = intsOpen(idxForMax);
const xMax = (Lmax.length ? choice(Lmax) : choice(intsIn(idxForMax)));

const xMin = pickXnotExt();   // point pour la comparaison au min

// AlÃ©a : chacune peut Ãªtre vraie (V) ou fausse (F)
const makeTrueMax = Math.random() < 0.5;   // si vrai â†’ f(x) < yMax ; sinon â†’ f(x) > yMax
const makeTrueMin = Math.random() < 0.5;   // si vrai â†’ f(x) > yMin ; sinon â†’ f(x) < yMin
let partC = [];
partC = [
  { id:'cmp_max', type:'toMax', want: makeTrueMax?'v':'f', x:xMax, k:yMax, sign: makeTrueMax?'<':'>',
    txt:`f(${S(xMax)}) ${makeTrueMax?'<':'>'} ${S(yMax)}`
  },
  { id:'cmp_min', type:'toMin', want: makeTrueMin?'v':'f', x:xMin, k:yMin, sign: makeTrueMin?'>':'<',
    txt:`f(${S(xMin)}) ${makeTrueMin?'>':'<'} ${S(yMin)}`
  }
];


// D) Intervalles consÃ©cutifs de sens opposÃ©s â†’ Impossible
function findTurn(){
  for(let i=0; i<DIR.length-1; i++){
    if ((DIR[i]==='â†—' && DIR[i+1]==='â†˜') || (DIR[i]==='â†˜' && DIR[i+1]==='â†—')) return i;
  }
  return -1;
}
// AVANT
// const t = findTurn();

// APRÃˆS â€” liste de TOUS les changements de sens, on en choisit un
const turns = [];
for (let i=0; i<DIR.length-1; i++){
  if ((DIR[i]==='â†—' && DIR[i+1]==='â†˜') || (DIR[i]==='â†˜' && DIR[i+1]==='â†—')) turns.push(i);
}
const t = choice(turns.length ? turns : [0]); // fallback au 1er segment si pas de turn
let partD = [];
let partE = [];
if(t !== -1){
const xL = intsLeft(t)[Math.floor(Math.random()*intsLeft(t).length)];
const xR = intsRight(t+1)[Math.floor(Math.random()*intsRight(t+1).length)];
  const sym = Math.random()<0.5 ? '<' : '>';
partD = [{ id:'nc_turn', want:'nc', type:'nc_turn', i:t, x1:xL, x2:xR, sym,
           txt:`f(${S(xL)}) ${sym} f(${S(xR)})`}];
// E) Comparaison avec lâ€™extrÃ©mum au changement de sens â€” non adjacent
// E) Comparaison avec lâ€™extrÃ©mum choisi (non adjacent)
// ==== Candidats extrÃ©mums globaux ====
const yGlobMax = Math.max(...Y);
const yGlobMin = Math.min(...Y);
const XglobMax = X.filter((_,i)=>Y[i]===yGlobMax);
const XglobMin = X.filter((_,i)=>Y[i]===yGlobMin);

// ==== Construit l'item E avec un extrÃ©mum GLOBAL ====
(function buildPartEGlobal(){
  const useMax = Math.random() < 0.5;               // au hasard: max ou min global
  const xExt = choice(useMax ? XglobMax : XglobMin);
  const kVal = useMax ? yGlobMax : yGlobMin;

  // Liste d'abscisses entiÃ¨res du domaine (y compris bornes)
  const allInts = [];
  for(let t=X[0]; t<=X[X.length-1]; t++) allInts.push(t);

  // On Ã©vite de prendre une autre abscisse qui atteint le mÃªme extrÃ©mum
  const badSet = new Set(useMax ? XglobMax : XglobMin);

  // Pour rendre VRAI, on veut f(xExt) > f(xO) si max global, f(xExt) < f(xO) si min global.
  // Comme on ne calcule pas f(xO), on s'appuie sur la propriÃ©tÃ© globale :
  //   max global : pour tout x, f(x) â‰¤ f(xExt), et strict < si x n'est pas aussi un argmax.
  //   min global : pour tout x, f(x) â‰¥ f(xExt), et strict > si x n'est pas aussi un argmin.
  // Donc il suffit de choisir xO âˆ‰ (argmax/argmin).
  const poolO = allInts.filter(x => x !== xExt && !badSet.has(x));
  const xO = choice(poolO.length ? poolO : allInts.filter(x=>x!==xExt));

  const makeTrue = Math.random() < 0.5;
  const sign = useMax
    ? (makeTrue ? '>' : '<')   // max global -> vrai si '>'
    : (makeTrue ? '<' : '>');  // min global -> vrai si '<'

  // Remplace l'ancien partE :
partE = [{
  id: makeTrue ? 'ext_v' : 'ext_f',
  want: makeTrue ? 'v' : 'f',
  type:'ext', ext: useMax?'max':'min',
  xExt, xO, kVal,
  txt: `f(${S(xExt)}) ${sign} f(${S(xO)})`
}];
})();





}else{
  // Secours : au pire, on place un "nc" arbitraire et un Ã©noncÃ© avec lâ€™extrÃ©mum global
  const ia = incIdx.concat(decIdx)[0];
  const ib = incIdx.concat(decIdx).find(j => j!==ia) ?? ia;
  partD = [{
    k:'nc_any', want:'nc', type:'nc_any', ia, ib,
    x1: intsIn(ia)[0], x2: intsIn(ib)[0], sym:'<',
    txt:`f(${S(intsIn(ia)[0])}) < f(${S(intsIn(ib)[0])})`
  }];
  partE = [{
    k:'ext_glob', want:'v', type:'ext_glob',
    xExt: X[Y.indexOf(yMax)], xO: intsIn(ia)[0],
    txt:`f(${S(X[Y.indexOf(yMax)])}) â‰¥ f(${S(intsIn(ia)[0])})`
  }];
}

// Pas de dÃ©doublonnage qui supprime tout : on prend nos 8 items puis on mÃ©lange
let stmts = [...partA, ...partB, ...partC, ...partD, ...partE];

// anti-doublon (mÃªme libellÃ© s.txt)
const seen = new Set();
stmts = stmts.filter(s => {
  if (seen.has(s.txt)) return false;
  seen.add(s.txt);
  return true;
});
stmts.sort(() => Math.random() - 0.5);

// â€”â€”â€” Q4/Q5 : encadrement d'une image sur un intervalle monotone â€”â€”â€”
function pickMonotoneIdx(weightInc=0.4){
  const wantInc = Math.random() < weightInc;
  let pool = wantInc ? incIdx : decIdx;
  if (!pool.length) pool = wantInc ? decIdx : incIdx; // secours
  return choice(pool);
}
function insideInts(i){
  const L=[]; for(let t=X[i]; t<=X[i+1]; t++) L.push(t); return L;
}
function insideOpenInts(i){
  const L=[]; for(let t=X[i]+1; t<=X[i+1]-1; t++) L.push(t); return L;
}
function preferIfPossible(val,i){
  const S = new Set(insideOpenInts(i).length? insideOpenInts(i) : insideInts(i));
  return S.has(val) ? val : choice([...S]);
}
function encadrementForK(i, k){
  const yA = Y[i], yB = Y[i+1];
  const lo = Math.min(yA,yB), hi = Math.max(yA,yB);
  return {k, i, lo, hi, dir: DIR[i]}; // â†— / â†˜
}

// â€”â€”â€” Q4/Q5 : encadrements monotones opposÃ©s â€”â€”â€”

// Q4 : intervalle choisi avec pondÃ©ration 40 % croissant / 60 % dÃ©croissant
const i4 = pickMonotoneIdx(0.40);
const k4 = preferIfPossible(2, i4);
const q4 = encadrementForK(i4, k4);

// Q5 : on impose le sens inverse de la question 4
const wantIncFor5 = q4.dir === 'â†˜'; // inverse
const pool5 = wantIncFor5 ? incIdx : decIdx;
let i5 = choice(pool5.length ? pool5 : [...DIR.keys()]);
if (i5 === i4 && pool5.length > 1) {
  // Ã©viter mÃªme intervalle que Q4
  const others = pool5.filter(j => j !== i4);
  i5 = choice(others);
}
const k5 = preferIfPossible(4, i5);
const q5 = encadrementForK(i5, k5);


// â€”â€”â€” Q6 : antÃ©cÃ©dent d'un extremum (max OU min global) â€”â€”â€”
const gMax = Math.max(...Y), gMin = Math.min(...Y);
const useMax = Math.random() < 0.5;
const yExt  = useMax ? gMax : gMin;
const Xexts = X.filter((_,i)=>Y[i]===yExt);
const q6 = { kind: useMax?'max':'min', y: yExt, X: Xexts };

// â€”â€”â€” Q7 : nombre d'antÃ©cÃ©dents de 0 (peut Ãªtre 0, 1 ou plusieurs) â€”â€”â€”
// 1) zÃ©ros "lisibles" (nÅ“uds oÃ¹ f=0)
const Znodes = X.filter((_, i) => Y[i] === 0);

// 2) zÃ©ros "non lisibles" : un par intervalle [X[i],X[i+1]] oÃ¹ le signe change
// (monotone sur chaque intervalle, donc exactement une racine ouverte ]a;b[)
const Zintervals = [];
for (let i = 0; i < Y.length - 1; i++) {
  const a = Y[i], b = Y[i+1];
  if (a === 0 && b === 0) continue;            // ne devrait pas arriver (variations strictes)
  if (a * b < 0) Zintervals.push([X[i], X[i+1]]);
}
const q7 = {
  zeros: Znodes.length + Zintervals.length,
  Znodes: Znodes.slice(),          // abscisses exactes visibles
  Zintervals: Zintervals.slice()   // intervalles oÃ¹ se trouve une racine (cachÃ©e)
};


return { X, Y, DIR, Iq, stmts, q4, q5, q6, q7 };









  },

  render(host, st){
    const {X,Y,DIR,Iq,stmts} = st;

    // variation table en â€œlectureâ€ (affichÃ©, non Ã©ditable)
    function rowX(){
      let r = '<tr><th>\\(x\\)</th>';
      X.forEach((x,i)=>{ r += `<td>\\(${String(x).replace('-','âˆ’')}\\)</td>`; if(i<X.length-1) r+='<td></td>'; });
      r += '</tr>'; return r;
    }
function rowF(){
  let r = '<tr><th>\\(f\\)</th>';

  // --- cellule de dÃ©part (x0) : haut si max, bas si min ---
  const isMax0 = (DIR[0] === 'â†˜');      // si Ã§a descend, y0 est un max
  const up0 = isMax0 ? `\\(${Y[0]}\\)` : '&nbsp;';
  const dn0 = isMax0 ? '&nbsp;' : `\\(${Y[0]}\\)`;
  r += `<td style="text-align:center"><div>${up0}</div><div style="height:6px"></div><div>${dn0}</div></td>`;

  // --- cellules internes (inchangÃ© sauf quâ€™on a dÃ©jÃ  traitÃ© y0) ---
  for(let i=0;i<DIR.length;i++){
    r += `<td style="text-align:center">${DIR[i]}</td>`;
    const isMax = (DIR[i]==='â†—' && DIR[i+1]==='â†˜') || (i===DIR.length-1 && DIR[i]==='â†—');
    const up = isMax ? `\\(${Y[i+1]}\\)` : '&nbsp;';
    const dn = isMax ? '&nbsp;' : `\\(${Y[i+1]}\\)`;
    r += `<td style="text-align:center"><div>${up}</div><div style="height:6px"></div><div>${dn}</div></td>`;
  }
  r += '</tr>';
  return r;
}


    host.innerHTML = `
      <div>On donne le tableau de variation dâ€™une fonction \\(f\\) :</div>
      <div class="var-wrap">
        <table class="pdf-tbl">
          <thead>${rowX()}</thead>
          <tbody>${rowF()}</tbody>
        </table>
      </div>

      <ol style="margin:.4rem 0 0 1.2rem">
        <li style="margin:.25rem 0">
          DÃ©terminer lâ€™<b>ensemble de dÃ©finition</b> de \\(f\\).
          <div style="display:inline-flex;gap:8px;align-items:center;margin-left:8px">
            <input class="q-dom" type="text" placeholder="" style="width:120px;text-align:center">
            <span class="tick nu"></span>
          </div>
        </li>



        <li style="margin:.25rem 0">
          Quel est le <b>maximum</b> de \\(f\\) sur
          \\([${String(Iq[0]).replace('-','âˆ’')} ; ${String(Iq[1]).replace('-','âˆ’')}]\\) ?
          En quelle(s) valeur(s) est-il atteint ?
          <div class ="pdf-hide" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:.3rem 0 0 .2rem">
        <label>Le maximum de la fonction \\(f\\) sur \\([${String(Iq[0]).replace('-','âˆ’')} ; ${String(Iq[1]).replace('-','âˆ’')}]\\) est :</label>
          <input class="qmaxy" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qmaxx" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>    
						

          </div>
        </li>

        <li style="margin:.25rem 0">
          En justifiant ces rÃ©ponses, indiquer si chaque affirmation est <b>Vraie</b>, <b>Fausse</b> ou Â« <b>Impossible de conclure</b> Â».
          <div style="margin:.35rem 0 0 .2rem">
<ol type="a" class="qcm-list print-only" style="margin:0 0 0 1.2rem">${mapHTML(stmts, function(s){
  const txtTeX = toTeX(s.txt); // <- convertit < et > en \lt \gt
  return '<li style="margin:.2rem 0">' +
           '\\(' + txtTeX + '\\)' +
           // rendu des <select>
'<select class="q-qcm" data-id="' + s.id + '">' +
             '<option value=""></option>' +
             '<option value="v">Vrai</option>' +
             '<option value="f">Faux</option>' +
             '<option value="nc">Impossible</option>' +
           '</select>' +
           '<span class="tick nu"></span>' +
         '</li>';
})}



            </ol>
          </div>
        </li>
      </ol>
      <div class="steps small" id="res" style="margin-top:.5rem"></div>
    `;

// 4) Encadrer une image
const q4 = st.q4;
const q4html = `
  <li style="margin:.25rem 0">
    ComplÃ©ter le plus prÃ©cisÃ©ment possible :
    &nbsp; â€¦ â‰¤ \\(f(${String(q4.k).replace('-','âˆ’')})\\) â‰¤ â€¦
	<br>
    <div class="pdf-hide" style="display:inline-flex;gap:6px;align-items:center;margin-left:8px">
      <input class="q4a" type="text" style="width:90px;text-align:center" placeholder="">
      <span style="opacity:.6">â‰¤</span>
      <span style="min-width:90px;text-align:center;display:inline-block">\\(f(${String(q4.k).replace('-','âˆ’')})\\)</span>
      <span style="opacity:.6">â‰¤</span>
      <input class="q4b" type="text" style="width:90px;text-align:center" placeholder="">
      <span class="tick nu"></span>
    </div>

  </li>`;

// 5) Encadrement le plus petit possible
const q5 = st.q5;
const q5html = `
  <li style="margin:.25rem 0">
    Donner lâ€™encadrement <b>le plus petit possible</b> de \\(f(${String(q5.k).replace('-','âˆ’')})\\).
	<br>
    <div class="pdf-hide" style="display:inline-flex;gap:6px;align-items:center;margin-left:8px">
      <input class="q5a" type="text" style="width:90px;text-align:center" placeholder="">
      <span style="opacity:.6">â‰¤</span>
      <span style="min-width:90px;text-align:center;display:inline-block">\\(f(${String(q5.k).replace('-','âˆ’')})\\)</span>
      <span style="opacity:.6">â‰¤</span>
      <input class="q5b" type="text" style="width:90px;text-align:center" placeholder="">
      <span class="tick nu"></span>
    </div>

  </li>`;

// 6) AntÃ©cÃ©dent dâ€™un extremum (rÃ©ponse oui/non)
const q6 = st.q6;
const q6html = `
  <li style="margin:.25rem 0">
    Donner un antÃ©cÃ©dent de \\(${q6.y}\\).
    En possÃ¨de-t-il dâ€™autre(s)&nbsp;?
    <div class="pdf-hide" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:.25rem 0 0 .2rem">
      <label>Un antÃ©cÃ©dent possible :</label>
      <input class="q6one" type="text" style="width:90px;text-align:center">
      <span class="tick nu"></span>
      <label>Autre(s)&nbsp;?</label>
      <select class="q6yn" style="width:90px;text-align:center">
        <option value=""></option>
        <option value="oui">oui</option>
        <option value="non">non</option>
      </select>
      <span class="tick nu"></span>
    </div>
  </li>`;


// 7) Nombre dâ€™antÃ©cÃ©dents de 0
const q7 = st.q7;
const q7html = `
  <li style="margin:.25rem 0">
    Combien \\(0\\) a-t-il dâ€™antÃ©cÃ©dent ?
    <div style="display:inline-flex;gap:8px;align-items:center;margin-left:8px">
      <input class="q7n" type="text" style="width:70px;text-align:center" placeholder="">
      <span class="tick nu"></span>
    </div>
  </li>`;

// â€¦puis INSÃ‰RER les trois blocs dans lâ€™<ol> existant (aprÃ¨s le QCM) :
const ol = host.querySelector('ol');
ol.insertAdjacentHTML('beforeend', q4html + q5html + q6html + q7html);







    host.dataset.state_extra = JSON.stringify({}); // placeholder
    host.querySelectorAll('input,select').forEach(ensureTickAfter);
	// Assure le tick dÃ¨s qu'on change une rÃ©ponse QCM
host.querySelectorAll('select.q-qcm, .q-qcm').forEach(sel=>{
  sel.addEventListener('change', ()=> ensureTickAfter(sel));
});





    typesetAll(host);
	
	
	// --- QCM Ã©cran : tableau 2 colonnes, l'impression garde la liste ---
(function twoColQcmScreen(){
  const list = host.querySelector('.qcm-list');
  if (!list) return;

  // EmpÃªche le double comptage : on retire la classe 'q-qcm' des selects de la liste (version print)
  list.querySelectorAll('select.q-qcm').forEach(sel => sel.classList.remove('q-qcm'));

  // Construit le tableau 2 colonnes pour l'Ã©cran
  const wrap = document.createElement('div');
  wrap.className = 'screen-only'; // visible Ã©cran seulement

  const rows = [];
  for (let i = 0; i < stmts.length; i += 2) {
    const a = stmts[i], b = stmts[i+1];

    const cell = s => `
      <div class="cell">
        <span class="num">${String.fromCharCode(97 + i + (s===b?1:0))}.</span>
        \\(${toTeX(s.txt)}\\)
        <select class="q-qcm" data-id="${s.id}">
          <option value=""></option>
          <option value="v">Vrai</option>
          <option value="f">Faux</option>
          <option value="nc">Impossible</option>
        </select>
        <span class="tick nu"></span>
      </div>`;

    rows.push(`<tr>
      <td>${cell(a)}</td>
      <td>${b ? cell(b) : ''}</td>
    </tr>`);
  }

  wrap.innerHTML = `
    <table class="table-qcm-screen" aria-hidden="true">
      <tbody>${rows.join('')}</tbody>
    </table>
  `;

  // On place la version Ã©cran juste APRÃˆS la liste (qui reste visible en PDF)
  list.insertAdjacentElement('afterend', wrap);

  // Ticks + events sur les nouveaux <select>
  wrap.querySelectorAll('select.q-qcm').forEach(sel=>{
    ensureTickAfter(sel);
    sel.addEventListener('change', ()=> ensureTickAfter(sel));
  });

  // Typeset des formules de la version Ã©cran
  typesetAll(wrap);
})();

  },

  correct(host, st){
    const {X,Y,DIR,Iq,stmts} = st;
    let ok=0, tot=0;
    const norm = s => (s||'').trim().replace(/\u2212/g,'-').replace(/\s/g,'').replace(',', '.');
// Ã  placer au dÃ©but de correct() aprÃ¨s les const
const setNuIfEmpty = (el) => {
  if (!el) return true;                       // rien Ã  faire
  const isEmpty = String(el.value ?? '').trim() === '';
  if (isEmpty) setTick(el, 'nu');
  return isEmpty;
};

    // (1) Domaine
   const dom = host.querySelector('.q-dom');
if (dom) {
  if (setNuIfEmpty(dom) === false) {          // non vide â†’ on Ã©value
    tot++;
    const v = norm(dom.value);
    const good = v === `[${X[0]};${X[X.length-1]}]`;
    setTick(dom, good ? 'ok' : 'ko');
    if (good) ok++;
  }
}




    // (3) Maximum sur [Iq]
    // on regarde les nÅ“uds inclus dans lâ€™intervalle
    const idxL = X.findIndex(v=>v===Iq[0]);
    const idxR = X.findIndex(v=>v===Iq[1]);
    const subY = Y.slice(idxL, idxR+1);
    const subX = X.slice(idxL, idxR+1);
    const ymax = Math.max(...subY);
    const Xmax = subX.filter((_,i)=>subY[i]===ymax);

// ymax/Xmax dÃ©jÃ  calculÃ©s plus haut

const inMaxY = host.querySelector('.qmaxy');  // <-- sans tiret !
if (inMaxY) {
  if (setNuIfEmpty(inMaxY) === false) {
    tot++;
    const good = (norm(inMaxY.value) === String(ymax));
    setTick(inMaxY, good ? 'ok' : 'ko');
    if (good) ok++;
  }
}

const inMaxX = host.querySelector('.qmaxx');  // <-- sans tiret !
if (inMaxX) {
  if (setNuIfEmpty(inMaxX) === false) {
    tot++;
    const Ans = norm(inMaxX.value).split(';').filter(Boolean);
    const A = [...new Set(Ans)].sort();
    const R = [...new Set(Xmax.map(String))].sort();
    const good = (A.length === R.length) && A.every((v,i)=>v===R[i]);
    setTick(inMaxX, good ? 'ok' : 'ko');
    if (good) ok++;
  }
}


    // (4) QCM
 function evalStmt(s){ return s.want; }   // 'v' | 'f' | 'nc'

host.querySelectorAll('.q-qcm').forEach(sel=>{
  const val = String(sel.value || '').trim();
  if (!val){ setTick(sel,'nu'); return; }

  const sid = sel.dataset.id;           // â† rÃ©cupÃ¨re lâ€™identifiant texte
  const s   = stmts.find(t => t.id === sid);

  if (!s){ setTick(sel,'nu'); return; } // sÃ©curitÃ©

  tot++;
  const good = (val === s.want);        // 'v' | 'f' | 'nc'
  setTick(sel, good ? 'ok' : 'ko');
  if (good) ok++;
});

const N = s => String(s||'').trim().replace(/\u2212/g,'-').replace(',', '.');

// Q4
if (st.q4){
  const a = host.querySelector('.q4a'), b = host.querySelector('.q4b');
  if (a && b){
    const va = N(a.value), vb = N(b.value);
    if (va==='' && vb===''){ setTick(a,'nu'); setTick(b,'nu'); }
    else{
      scoreTot+=2;
      const okA = (+va===st.q4.lo), okB = (+vb===st.q4.hi);
      setTick(a, okA?'ok':'ko'); setTick(b, okB?'ok':'ko');
      if (okA) scoreOK++; if (okB) scoreOK++;
    }
  }
}

// Q5 (mÃªme attente : bornes exactes et ordonnÃ©es)
if (st.q5){
  const a = host.querySelector('.q5a'), b = host.querySelector('.q5b');
  if (a && b){
    const va = N(a.value), vb = N(b.value);
    if (va==='' && vb===''){ setTick(a,'nu'); setTick(b,'nu'); }
    else{
      scoreTot+=2;
      const okA = (+va===st.q5.lo), okB = (+vb===st.q5.hi);
      setTick(a, okA?'ok':'ko'); setTick(b, okB?'ok':'ko');
      if (okA) scoreOK++; if (okB) scoreOK++;
    }
  }
}

// Q6 : un antÃ©cÃ©dent + autres (ou Â« non Â»)
// Q6 : un antÃ©cÃ©dent + oui/non
// Q6 : un antÃ©cÃ©dent + oui/non
if (st.q6){
  const one = host.querySelector('.q6one');
  const yn  = host.querySelector('.q6yn');
  const N = s => String(s||'').trim().toLowerCase().replace(/\u2212/g,'-');

  // Champ "un antÃ©cÃ©dent"
  if (one){
    const v = N(one.value);
    if (!v){ setTick(one,'nu'); }
    else{
      scoreTot++;
      const ok1 = st.q6.X.map(String).includes(v);
      setTick(one, ok1?'ok':'ko');
      if (ok1) scoreOK++;
    }
  }

  // Champ "oui/non" â€” accepte aussi les antÃ©cÃ©dents NON LISIBLE (plateau)
  if (yn){
    const v = N(yn.value);
    if (!v){ setTick(yn,'nu'); }
    else{
      scoreTot++;

      // plusieurs abscisses visibles
      let multiple = st.q6.X.length > 1;

      // ou plateau : deux bornes consÃ©cutives portent la valeur dâ€™extremum (infinitÃ© dâ€™antÃ©cÃ©dents non lisibles)
      if (!multiple){
        for (let i=0; i<st.Y.length-1; i++){
          if (st.Y[i] === st.q6.y && st.Y[i+1] === st.q6.y){
            multiple = true; break;
          }
        }
      }

      const ok2 = (multiple && v==='oui') || (!multiple && v==='non');
      setTick(yn, ok2?'ok':'ko');
      if (ok2) scoreOK++;
    }
  }
}



// Q7 : nombre dâ€™antÃ©cÃ©dents de 0
if (st.q7){
  const n = host.querySelector('.q7n');
  if (n){
    const v = N(n.value);
    if (!v){ setTick(n,'nu'); }
    else{
      scoreTot++;
      const okn = (+v===st.q7.zeros);
      setTick(n, okn?'ok':'ko'); if (okn) scoreOK++;
    }
  }
}



    const res=$('#res',host);
    res.textContent = '';
    ensureTickAfter(res).className = 'tick ' + (ok===tot && tot>0 ? 'ok' : 'nu');
    return {ok, total: tot};
  },

  solution(host, st){
    const {X,Y,DIR,Iq,stmts} = st;
    const idxL = X.findIndex(v=>v===Iq[0]);
    const idxR = X.findIndex(v=>v===Iq[1]);
    const subY = Y.slice(idxL, idxR+1);
    const subX = X.slice(idxL, idxR+1);
    const ymax = Math.max(...subY);
    const Xmax = subX.filter((_,i)=>subY[i]===ymax);

    const fmt = s=>String(s).replace('-','âˆ’');
    const box = $('#res',host);
	const gMax = Math.max(...Y);
const gMin = Math.min(...Y);

	
	const word = w => w==='v' ? 'Vrai' : w==='f' ? 'Faux' : 'Impossible';
	
    box.innerHTML = `
      <div class="step"><b>1.</b> Domaine : \\([${fmt(X[0])}\\,;\\,${fmt(X[X.length-1])}]\\).</div>

      <div class="step"><b>2.</b> Le maximum de la fonction \\(f\\) sur \\([${fmt(Iq[0])}\\,;\\,${fmt(Iq[1])}]\\) vaut \\(${ymax}\\) atteint en ${mapHTML(Xmax, x=>`\\(x=${fmt(x)}\\)`, ' et ')}.</div>

    `;
  // ðŸ‘‰ Ajouter ce helper ici (visible par explain)
  const S = n => String(n).replace('-', 'âˆ’');	
const explain = (s) => {
  const I1 = (i)=>`[${S(X[i])} ; ${S(X[i+1])}]`;
    const I = (i)=>`[${S(s.x1)} ; ${S(s.x2)}]`;

  const segMin = (i)=>Math.min(Y[i],Y[i+1]);
  const segMax = (i)=>Math.max(Y[i],Y[i+1]);

// ===== helper robuste : rend lâ€™index du segment contenant x =====
function segIndexOfX(x){
  // Ã  lâ€™intÃ©rieur strict
  for(let j=0; j<DIR.length; j++){
    const L = X[j], R = X[j+1];
    if (x > L && x < R) return j;
    // gÃ©rer proprement les cas aux bornes
    if (x === L) return j;
    if (x === R && j === DIR.length-1) return j; // derniÃ¨re borne
  }
  // secours : on accroche au segment le plus proche
  let j = 0;
  while (j < DIR.length-1 && X[j+1] < x) j++;
  return Math.max(0, Math.min(DIR.length-1, j));
}



  switch(s.type){
    case 'inc': {
      const a = S(s.x1), b = S(s.x2), Iab = I(s.i);
      const core = `la fonction \\(f\\) est <b>strictement croissante</b> sur \\(${Iab}\\) ainsi : \\(f(${a}) \\lt f(${b})\\).`;
      return s.want==='v'
        ? `\\(${S(s.x1)} \\lt ${S(s.x2)}\\), or ${core} <b>VRAIE</b>.`
        : `\\(${S(s.x1)} \\lt ${S(s.x2)}\\), or \\(f\\) est <b>strictement croissante</b> sur \\(${Iab}\\), on devrait avoir \\(f(${a}) \\lt f(${b})\\). <b>FAUSSE</b>.`;
    }
    case 'dec': {
      const a = S(s.x1), b = S(s.x2), Iab = I(s.i);
      const core = `la fonction \\(f\\) est <b>strictement dÃ©croissante</b> sur \\(${Iab}\\) ainsi : \\(f(${a}) \\gt f(${b})\\).`;
      return s.want==='v'
        ? `\\(${S(s.x1)} \\lt ${S(s.x2)}\\), or ${core} <b>VRAIE</b>.`
        : `\\(${S(s.x1)} \\lt ${S(s.x2)}\\), or \\(f\\) est <b>strictement dÃ©croissante</b>  sur \\(${Iab}\\), on devrait avoir \\(f(${a}) \\gt f(${b})\\). <b>FAUSSE</b>.`;
    }
case 'toMax': {
  const Idef = `[${fmt(X[0])}\\,;\\,${fmt(X[X.length-1])}]`;
  if (s.sign === '<') {
    // VRAIE : pour tout x, f(x) â‰¤ gMax â‡’ f(x) < gMax si x nâ€™est pas un argmax
    return `Sur \\(${Idef}\\), le <b>maximum (global)</b>  de \\(f\\) vaut \\(${gMax}\\), donc pour tout \\(x\\in${Idef}\\),
            \\(f(x)\\le ${gMax}\\).
            <br>Comme \\(${s.x}\\) nâ€™est pas une abscisse de maximum : on obtient \\(f(${S(s.x)}) \\lt ${gMax}\\). <b>VRAIE</b>.`;
  } else {
    // FAUSSE : impossible dâ€™avoir f(x) > gMax
    return `Sur \\(${Idef}\\), le <b>maximum (global)</b>  est \\(${gMax}\\), donc pour tout \\(x\\), \\(f(x)\\le ${gMax}\\).
            <br>Lâ€™assertion \\(f(${S(s.x)}) \\gt ${gMax}\\) est impossible. <b>FAUSSE</b>.`;
  }
}

case 'toMin': {
  const Idef = `[${fmt(X[0])}\\,;\\,${fmt(X[X.length-1])}]`;
  if (s.sign === '>') {
    // VRAIE : pour tout x, f(x) â‰¥ gMin â‡’ strict si x nâ€™est pas un argmin
    return `Sur \\(${Idef}\\), le <b>minimum (global)</b>  de \\(f\\) vaut \\(${gMin}\\), donc pour tout \\(x\\in${Idef}\\),
            \\(f(x)\\ge ${gMin}\\).
            <br>Comme \\(${S(s.x)}\\) nâ€™est pas une abscisse de minimum :  on obtient  \\(f(${S(s.x)})\\gt ${gMin}\\). <b>VRAIE</b>.`;
  } else {
    // FAUSSE : impossible dâ€™avoir f(x) < gMin
    return `Sur \\(${Idef}\\), le <b>minimum (global)</b>  est \\(${gMin}\\), donc pour tout \\(x\\), \\(f(x)\\ge ${gMin}\\).
           <br> Lâ€™assertion \\(f(${S(s.x)}) \\lt ${gMin}\\) est impossible. <b>FAUSSE</b>.`;
  }
}


    case 'nc_turn': {
      // deux intervalles consÃ©cutifs de sens opposÃ©s : encadrement seulement
      const a = s.i, Ibig = `[${S(X[a])} ; ${S(X[a+2])}]`;
      const m = Math.min(Y[a],Y[a+1],Y[a+2]);
      const M = Math.max(Y[a],Y[a+1],Y[a+2]);
      return `Le tableau prÃ©sente un changement de variations aux abords de \\(x=${S(X[a+1])}\\). On sait seulement que, pour tout \\(x\\in${Ibig}\\), \\(${m}\\le f(x)\\le ${M}\\). Impossible de comparer \\(f(${S(s.x1)})\\) et \\(f(${S(s.x2)})\\). <b>Impossible de conclure</b>.`;
    }
    case 'ext': {
  // intervalle uniquement entre xO et xExt (ordre automatique)
  const Iother = `[${S(Math.min(s.xO, s.xExt))} ; ${S(Math.max(s.xO, s.xExt))}]`;

  if (s.ext === 'max') {
    return s.want === 'v'
      ? `\\(f(${S(s.xExt)})\\) est le <b>maximum</b> sur \\(${Iother}\\) ainsi pour tout \\(x\\in${Iother}\\), on a \\(f(x)\\le f(${S(s.xExt)})\\).
         <br>En particulier, comme \\(${S(s.xO)}\\in${Iother}\\), \\(f(${S(s.xExt)}) \\gt f(${S(s.xO)})\\). <b>VRAIE</b>.`
      : `\\(f(${S(s.xExt)})\\) est le <b>maximum</b> sur \\(${Iother}\\)  ainsi pour tout \\(x\\in${Iother}\\), \\(f(x)\\le f(${S(s.xExt)})\\).
         <br>Or \\(${S(s.xO)}\\in${Iother}\\) donc \\(f(${S(s.xExt)})\\ge f(${S(s.xO)})\\). <b>FAUSSE</b>.`;
  } else {
    return s.want === 'v'
      ? `\\(f(${S(s.xExt)})\\) est le <b>minimum</b> sur \\(${Iother}\\) ainsi pour tout \\(x\\in${Iother}\\), on a \\(f(x)\\ge f(${S(s.xExt)})\\).
         <br>En particulier, comme \\(${S(s.xO)}\\in${Iother}\\), \\(f(${S(s.xExt)}) \\lt f(${S(s.xO)})\\). <b>VRAIE</b>.`
      : `\\(f(${S(s.xExt)})\\) est le <b>minimum</b> sur \\(${Iother}\\) ainsi pour tout \\(x\\in${Iother}\\), \\(f(x)\\ge f(${S(s.xExt)})\\).
         <br>Or \\(${S(s.xO)}\\in${Iother}\\) donc \\(f(${S(s.xExt)})\\le f(${S(s.xO)})\\).<b>FAUSSE</b>.`;
  }
}

    case 'nc_any': {
      const I1=`[${S(X[s.ia])} ; ${S(X[s.ia+1])}]`, I2=`[${S(X[s.ib])} ; ${S(X[s.ib+1])}]`;
      return `Les points appartiennent Ã  deux intervalles distincts (${I1} et ${I2}) sans information de liaison. On peut seulement encadrer les valeurs par les bornes locales : le tableau <b>ne permet pas de conclure</b>.`;
    }
    case 'ext_glob': {
      return `On compare une abscisse dâ€™extrÃ©mum global avec un point dâ€™un autre intervalle : on sait que \\(f(${S(s.xExt)})\\) est une borne dans la zone considÃ©rÃ©e, dâ€™oÃ¹ lâ€™inÃ©galitÃ© annoncÃ©e. <b>VRAIE</b>.`;
    }
    default: return '';
  }
};

const qcmHTML = `
  <div class="step"><b>3.</b> QCM :</div>
  <ol type="a" style="margin:.2rem 0 0 1.1rem">
${mapHTML(stmts, function(s){
  const verdict = (s.want === 'v' ? 'VRAIE' :
                   s.want === 'f' ? 'FAUSSE' :
                   'Impossible de conclure');
  return '<li>\\(' + s.txt + '\\) : ' + explain(s) + '</li>';
})}
  </ol>
`;

box.innerHTML += qcmHTML;

// Q4
if (st.q4){
  box.innerHTML += `
    <div class="step"><b>4.</b> Sur \\([${fmt(X[st.q4.i])}\\,;\\,${fmt(X[st.q4.i+1])}]\\),
    \\(f\\) est ${st.q4.dir==='â†—'?'croissante':'dÃ©croissante'}, donc :
    \\(${st.q4.lo} \\le f(${fmt(st.q4.k)}) \\le ${st.q4.hi}\\).</div>`;
}
// Q5
if (st.q5){
  box.innerHTML += `
    <div class="step"><b>5.</b> Sur \\([${fmt(X[st.q5.i])}\\,;\\,${fmt(X[st.q5.i+1])}]\\),
    \\(f\\) est ${st.q5.dir==='â†—'?'croissante':'dÃ©croissante'}, donc :
    \\(${st.q5.lo} \\le f(${fmt(st.q5.k)}) \\le ${st.q5.hi}\\).</div>`;
}


// Q6 â€” lister tous les antÃ©cÃ©dents : points lisibles + intervalles non lisibles (plateaux)
if (st.q6){
  const fmt = s => String(s).replace('-','âˆ’');
  const yE  = st.q6.y;

  // 1) AntÃ©cÃ©dents lisibles : nÅ“uds du tableau oÃ¹ f = yE
  const nodes = [];
  for (let i = 0; i < Y.length; i++) if (Y[i] === yE) nodes.push(X[i]);

  // 2) AntÃ©cÃ©dents non lisibles : plateaux [X[i]; X[i+1]] oÃ¹ f = yE aux deux bornes
  const segs = [];
  for (let i = 0; i < Y.length - 1; i++){
    if (Y[i] === yE && Y[i+1] === yE) segs.push([X[i], X[i+1]]);
  }

  // Mise en forme
  const nodesStr = nodes.map(x => `\\(x=${fmt(x)}\\)`);
  const segsStr  = segs.map(([a,b]) => `\\([${fmt(a)}\\,;\\,${fmt(b)}]\\)`);

  // Compte / phrasÃ©
  const hasPlateau = segs.length > 0;
  const countMsg = hasPlateau
    ? `\\( ${yE}\\) possÃ¨de une <b>infinitÃ©</b> dâ€™antÃ©cÃ©dents`
    : `\\( ${yE}\\) possÃ¨de ${nodes.length} antÃ©cÃ©dent(s)`;

  const parts = [];
  if (nodes.length === 1)      parts.push(` en ${nodesStr[0]}`);
  else if (nodes.length > 1)   parts.push(` en ${nodesStr.join(' et ')}`);

  if (segs.length === 1)       parts.push(`et pour tout \\(x\\) dans ${segsStr[0]}`);
  else if (segs.length > 1)    parts.push(`et pour tout \\(x\\) dans ${segsStr.join(' et ')}`);

  const detail = parts.length ? ` : ${parts.join(' ')}` : '';

  box.innerHTML += `
    <div class="step"><b>6.</b> 
      ${countMsg}${detail}.
    </div>`;
}



// Q7
// Q7 â€” phrasing robuste (singulier/pluriel, nÅ“uds vs intervalles)
if (st.q7){
  const fmt = s => String(s).replace('-', 'âˆ’');
  const nodes = st.q7.Znodes.map(x => `\\(x=${fmt(x)}\\)`);
  const segs  = st.q7.Zintervals.map(([a,b]) => `\\(]${fmt(a)}\\,;\\,${fmt(b)}[\\)`);

  const nN = nodes.length, nS = segs.length;

  const parts = [];
  if (nN === 1)        parts.push(` en ${nodes[0]}`);
  else if (nN > 1)     parts.push(` en ${nodes.join(' ; ')}`);

  if (nS === 1)        parts.push(` dans lâ€™intervalle ${segs[0]}`);
  else if (nS > 1)     parts.push(` dans les intervalles ${segs.join(' et ')}`);

  const detail = parts.length ? ` : ${parts.join(' et ')}` : '';

  box.innerHTML += `<div class="step"><b>7.</b> Il y a \\(${st.q7.zeros}\\) antÃ©cÃ©dent(s) de \\(0\\)${detail}.
    </div>`;
}





typesetAll(box);

	
	

  },

  reset(host){ $('#res',host).textContent=''; }
};






/* â€”â€”â€”â€”â€” Registre & UI â€”â€”â€”â€”â€” */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde â€“ Ã‰tude de fonctions â€¢ Sens de variations',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
sel.innerHTML = mapHTML(REGISTRY, (ex,idx)=>`<option value="${ex.id}">${idx+1} â€” ${ex.title}</option>`);
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
