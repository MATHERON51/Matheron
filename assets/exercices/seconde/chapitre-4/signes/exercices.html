<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì √âtude de fonctions ‚Ä¢ Sens de variations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äî √âtude de fonctions ‚Ä¢ Sens de variations</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, √©crire une liste. Exemple : -3;2</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax=520, Hmax=300, mL=28, mT=8, mR=8, mB=28;
  const {xmin,xmax,ymin,ymax} = opts;

const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7)); // 4.5px par d√©faut

  // 1) √âchelle commune (orthonorm√©e)
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;
  const s  = Math.min(Wmax / Rx, Hmax / Ry);      // m√™me "px par unit√©" pour x et y
  const w  = s * Rx;
  const h  = s * Ry;

  // 2) Centrage de la fen√™tre de trac√© (letterbox si besoin)
  const x0 = mL + (Wmax - w)/2;
  const y0 = mT + (Hmax - h)/2;

  // 3) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  // Cr√©ation SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','repere');

  const defs = document.createElementNS(svg.namespaceURI,'defs');
 // ‚Äî‚Äî‚Äî PATCH FLECHES ‚Äî‚Äî‚Äî

const mark = document.createElementNS(svg.namespaceURI,'marker');
mark.setAttribute('id','arrow');
mark.setAttribute('markerUnits','userSpaceOnUse');   // taille ind√©pendante du stroke
mark.setAttribute('markerWidth', AR);
mark.setAttribute('markerHeight', AR);
mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
mark.setAttribute('refX', AR);                       // ‚Üê la pointe (x=AR) tombe pile sur la fin de la ligne
mark.setAttribute('refY', AR/2);
mark.setAttribute('orient','auto');

const tri = document.createElementNS(svg.namespaceURI,'path');
// triangle : pointe √† (AR, AR/2)
tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
tri.setAttribute('fill','#111');
mark.appendChild(tri);
defs.appendChild(mark);

  const clip=document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0); crect.setAttribute('y',y0);
  crect.setAttribute('width',w); crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g');
  const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes); svg.appendChild(plot);

  // Fonctions de transformation : m√™me √©chelle s pour x et y
  const X = x => x0 + (x - xmin) * s;
  const Y = y => y0 + h - (y - ymin) * s;

  // Cadre (zone orthonorm√©e centr√©e)
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0); frame.setAttribute('y',y0);
  frame.setAttribute('width',w); frame.setAttribute('height',h);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // Axes (born√©s au cadre)
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx=document.createElementNS(svg.namespaceURI,'g');
    const ty=document.createElementNS(svg.namespaceURI,'g');

    const fmt=n=>String(n).replace('-', '‚àí');

    // verticales enti√®res
    for(let xv=Math.ceil(xmin); xv<=xmax+1e-9; xv+=1){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx); l.setAttribute('y1',y0);
      l.setAttribute('x2',xx); l.setAttribute('y2',y0+h);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(xv);
      t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
      t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }
    // horizontales enti√®res
    for(let yv=Math.ceil(ymin); yv<=ymax+1e-9; yv+=1){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0); l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w); l.setAttribute('y2',yy);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(yv);
      t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
      t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }
    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }


 // Axes fl√©ch√©s jusqu'au bord du cadre
const axX = document.createElementNS(svg.namespaceURI,'line');
axX.setAttribute('x1', x0);
axX.setAttribute('x2', x0 + w);        // ‚Üê jusqu'au bord
axX.setAttribute('y1', yAxisY);
axX.setAttribute('y2', yAxisY);
axX.setAttribute('stroke', '#111');
axX.setAttribute('stroke-width', '2.2');
axX.setAttribute('stroke-linecap', 'butt'); // ‚Üê pas d‚Äôarrondi qui d√©passe
if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axX);

const axY = document.createElementNS(svg.namespaceURI,'line');
axY.setAttribute('x1', xAxisX);
axY.setAttribute('x2', xAxisX);
axY.setAttribute('y1', y0 + h);
axY.setAttribute('y2', y0);            // ‚Üê jusqu'au bord
axY.setAttribute('stroke', '#111');
axY.setAttribute('stroke-width', '2.2');
axY.setAttribute('stroke-linecap', 'butt'); // ‚Üê idem
if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axY);


  // inverses (px -> unit√©s)
  const Xi = px => xmin + (px - x0) / s;
  const Yi = py => ymin + (y0 + h - py) / s;

  // grande zone "hit" cliquable exactement sur le cadre
  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0); hit.setAttribute('y', y0);
  hit.setAttribute('width', w); hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };

}

// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}






const ex1 = {
  id:'var_from_curve_multi',
  title:'Tableau de variations et extremums',
 gen(){
  const n = pickExtremaCountWeighted();
  const S = makeSmoothCurveKnots(n);                // ‚Üê nouvelle fabrique
  return { R:S.R, knots:S.knots, extrema:S.extrema, n, roots:S.roots, Xs:S.Xs, Ys:S.Ys };
},

  render(host, st){
  const {R,knots,extrema,n} = st;

host.innerHTML = `
  <div>Soit \\(f\\) la fonction repr√©sent√©e ci-contre.</div>
  <div id="qa">1. Donner le <b>tableau de variations</b> de la fonction \\(f\\) sur <span class="I2"></span>.</div>
      <div id="qa">2.  Quel est le <b>maximum</b> de \\(f\\) sur <span class="I2"></span> ?
  En quelle(s) valeur(s) est-il atteint ?</div>
  <div id="qa">3.  Quel est le <b>minimum</b> de \\(f\\) sur <span class="I2"></span> ?
  En quelle(s) valeur(s) est-il atteint ?</div>
    <div id="qa">4. Donner le <b>tableau de signe</b> de la fonction \\(f\\) sur <span class="I2"></span>.</div>
  <div class="graph" style="display:flex;justify-content:center;margin:.4rem 0"></div>

  <div id="var-host"></div>
  <div class="steps small" id="res"></div>
`;

// Intervalle "utile" [a; b] = [R.xmin+1 ; R.xmax-1]
const a2 = R.xmin + 1, b2 = R.xmax - 1;
host.querySelectorAll('#qa .I2').forEach(span=>{
  span.textContent = `[${String(a2).replace('-','‚àí')} ; ${String(b2).replace('-','‚àí')}]`;
});


  // Rep√®re + courbe lisse
  const rep = buildRepereSVG({ xmin:R.xmin, xmax:R.xmax, ymin:R.ymin, ymax:R.ymax, grid:true, arrows:true });
addPath(rep.plot, pathFromKnots(rep, knots), { stroke:'#e11d48', 'stroke-width':2.6 }); // rouge
  host.querySelector('.graph').appendChild(rep.svg);

  // ‚Äî helpers cellules
  const xCell = (idx, ph)=>`<td style="text-align:center">
    <input class="xcell" data-i="${idx}" type="text" style="width:110px;text-align:center" placeholder="">
  </td>`;
  const emptyCell = ()=>`<td></td>`;
  const arrowCell = idx=>`<td class="bigsel">
    <select class="dir" data-i="${idx}">
      <option value=""></option><option>‚Üò</option><option>‚Üó</option>
    </select>
  </td>`;
  const yCell = (idx, ph)=>`<td>
  <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
    <input class="ymax" data-i="${idx}" type="text" placeholder="" style="width:90px;text-align:center">
    <input class="ymin" data-i="${idx}" type="text" placeholder="" style="width:90px;text-align:center">
  </div>
</td>`;

  // Indexation des colonnes "donn√©es" : [-1, 0, 1, ..., n-1, -2]
  const dataCols = [-1, ...extrema.map((_,i)=>i), -2];
  const phX = i => (i===-1?`${R.xmin}`: i===-2?`${R.xmax}` : `${extrema[i].x}`).replace('-','‚àí');
  const phY = i => (i===-1||i===-2? '' : `${extrema[i].y}`); // placeholder visible seulement au niveau des extr√©mums

  // ‚Äî Ligne x : input, (vide), input, (vide), ..., input
  let rowX = `<tr><th>\\(x\\)</th>`;
  dataCols.forEach((idx,j)=>{
    rowX += xCell(idx, phX(idx));
    if (j < dataCols.length - 1) rowX += emptyCell(); // colonne vide au-dessus de chaque fl√®che
  });
  rowX += `</tr>`;

  // ‚Äî Ligne f : yCell, fl√®che, yCell, fl√®che, ..., yCell  (lignes coll√©es, pas de spacer)
  let rowF = `<tr><th>\\(f\\)</th>`;
  dataCols.forEach((idx,j)=>{
    rowF += yCell(idx, phY(idx));
    if (j < dataCols.length - 1) rowF += arrowCell(j); // autant de fl√®ches que d'intervalles
  });
  rowF += `</tr>`;

  // ‚Äî Table finale (sans ligne d‚Äô√©tiquettes)
document.getElementById('var-host').innerHTML = `
  		    <!-- NOUVEAU : bloc Questions 2 et 3 -->
  <div id="qa" class="card" style="margin:.5rem 0">
    <div id="q-int"></div>
    <ol style="margin:.4rem 0 .2rem 1.2rem">
      <li style="margin:.25rem 0">
	  <b>Tableau de variations</b> de la fonction \\(f\\) :
	  <div class="var-wrap">
    <table class="var frame-only">
      <tbody>
        ${rowX}
        ${rowF}
      </tbody>
    </table>
		  </div>
      <li style="margin:.25rem 0">
               <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label>Le <b>maximum</b> de la fonction \\(f\\) sur <span class="I"></span> est :</label>
          <input class="qmaxy" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qmaxx" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </li>
      <li style="margin:.25rem 0">
               <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label>Le <b>minimum</b> de la fonction \\(f\\) sur <span class="I"></span> est :</label>
          <input class="qminy" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qminx" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </li>
    </ol>
  </div>
`;
/* ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Q4 dans la m√™me carte (card small) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
(function addQ4InsideSameCard(){
  const aS = st.R.xmin + 1, bS = st.R.xmax - 1;
  const roots = (st.roots||[]).slice().sort((u,v)=>u-v);
  const k = roots.length;

  // colonnes : [xmin] [vide] [x1] [vide] ... [xk] [vide] [xmax]
  const cols = [];
  cols.push({kind:'x', role:'xmin', val:aS});
  for(let i=0;i<k;i++){ cols.push({kind:'gap'}); cols.push({kind:'x', role:'root', idx:i, val:roots[i]}); }
  cols.push({kind:'gap'}); cols.push({kind:'x', role:'xmax', val:bS});

  // helpers
  const cellX = (c)=>`<td>
    <input class="${c.role==='root'?'root':'xbnd'}"
           data-role="${c.role}" ${c.role==='root'?`data-i="${c.idx}"`:''}
           type="text" style="width:90px;text-align:center">
  </td>`;
  const cellGap = (i)=>`<td class="bigsel">
    <div style="display:flex;flex-direction:column;align-items:center;gap:2px">
      <select class="sgn" data-i="${i}" style="width:100%">
        <option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option>
      </select>
    </div>
  </td>`;
  const cellZero = (role, idx=null)=>`
    <td>
      <input class="z0" data-role="${role}" ${idx!==null?`data-i="${idx}"`:''}
             type="text" value="" placeholder="" style="width:60px;text-align:center">
    </td>`;
  const cellBlank = ()=>`<td></td>`;

  // LIGNE x
  let rowX = '<tr><th>\\(x\\)</th>';
  cols.forEach(c=>{ rowX += (c.kind==='x') ? cellX(c) : cellBlank(); });
  rowX += '</tr>';

  // LIGNE f : s√©lecteurs dans les gaps ; 0 √©ditables sous xmin/xmax et racines internes
  let rowF = '<tr><th>\\(f(x)\\)</th>';
  let sigIdx = 0;
  cols.forEach(c=>{
    if(c.kind==='gap')      rowF += cellGap(sigIdx++);
    else if(c.role==='root')rowF += cellZero('root', c.idx);
    else if(c.role==='xmin')rowF += cellZero('xmin');
    else if(c.role==='xmax')rowF += cellZero('xmax');
    else                    rowF += cellBlank();
  });
  rowF += '</tr>';

  const q4 = `
    <li style="margin:.25rem 0">
      <b>Tableau de signe</b> de la fonction \\(f\\) :
      <div class="var-wrap" style="margin-top:.35rem">
        <table class="var frame-only">
          <tbody>${rowX}${rowF}</tbody>
        </table>
      </div>
         </li>`;

  // ins√©rer dans la m√™me liste <ol> que Q1‚ÄìQ3
  const ol = document.querySelector('#qa ol');
  if(ol) ol.insertAdjacentHTML('beforeend', q4);

  // ticks + MathJax
  document.querySelectorAll('#qa select.sgn,#qa input.xbnd,#qa input.root,#qa input.z0').forEach(ensureTickAfter);
  typesetAll(document.getElementById('qa'));
})();

// Intervalle "utile" [a; b] = [R.xmin+1 ; R.xmax-1]
const a = R.xmin + 1, b = R.xmax - 1;
host.querySelectorAll('#qa .I').forEach(span=>{
  span.textContent = `[${String(a).replace('-','‚àí')} ; ${String(b).replace('-','‚àí')}]`;
});

// Ajuste la hauteur des s√©lecteurs de fl√®ches √† celle des colonnes max/min voisines
function adjustArrowHeights(){
  host.querySelectorAll('td.bigsel select').forEach(sel=>{
    const td = sel.closest('td');
    // colonne "valeurs" voisine (gauche sinon droite)
    const ref = td.previousElementSibling?.querySelector('.ycol')
             || td.nextElementSibling?.querySelector('.ycol');
    if(!ref) return;
    const h = Math.round(ref.getBoundingClientRect().height);

    // on fait correspondre hauteur + font-size + line-height
    sel.style.height    = h + 'px';
    sel.style.lineHeight= h + 'px';                 // certains navigateurs
    sel.style.fontSize  = Math.max(28, Math.floor(h * 0.72)) + 'px';
  });
}
adjustArrowHeights();
window.addEventListener('resize', adjustArrowHeights);


  // Ticks
  host.querySelectorAll('input,select').forEach(ensureTickAfter);
  typesetAll(host);
  host.querySelectorAll('#qa input').forEach(ensureTickAfter);

}
,

  // ‚Äî‚Äî‚Äî‚Äî‚Äî CORRECTION ‚Äî‚Äî‚Äî‚Äî‚Äî
correct(host,st){
  const {R, extrema, knots, n} = st;
  let ok=0, tot=0;

  const norm = s => (s||'').trim().replace(/\u2212/g,'-').replace(',','.');

  /* ========== 1) COMPLETUDE (pour afficher les V sur vides l√©gitimes) ========== */
  const wantX = [R.xmin+1, ...extrema.map(e=>e.x), R.xmax-1].map(String);

  const xInputs = [...host.querySelectorAll('input.xcell')];
  const allXFilled = xInputs.every(inp => norm(inp.value)!=='');
  const allDirFilled = [...host.querySelectorAll('select.dir')].every(sel => !!sel.value);

  // pour chaque extr√©mum i, au moins une des deux cases est remplie
  const allYFilledByExt = extrema.every((_,i)=>{
    const ya = norm(host.querySelector(`input.ymax[data-i="${i}"]`)?.value);
    const yi = norm(host.querySelector(`input.ymin[data-i="${i}"]`)?.value);
    return (ya!=='' || yi!=='');
  });

  const tableComplete = allXFilled && allDirFilled && allYFilledByExt;

  /* ========== 2) LIGNE x : v√©rification de la valeur attendue ========== */
  xInputs.forEach((inp,idx)=>{
    const v = norm(inp.value); if(!v) return;  // non rempli ‚Üí non compt√©
    tot++;
    const good = (v === wantX[idx]);
    setTick(inp, good?'ok':'ko'); if(good) ok++;
  });

  /* ========== 3) FL√àCHES : sens entre colonnes (n+1 fl√®ches) ========== */
  const Ys=[knots[0].y, ...extrema.map(e=>e.y), knots[knots.length-1].y];
  const DIR=[]; for(let i=0;i<=n;i++) DIR.push(Ys[i+1] > Ys[i] ? '‚Üó' : '‚Üò');

  host.querySelectorAll('select.dir').forEach(sel=>{
    if(!sel.value) return;
    tot++;
    const i=+sel.dataset.i, good=(sel.value===DIR[i]);
    setTick(sel, good?'ok':'ko'); if(good) ok++;
  });

  /* ========== 4) LIGNE f : valeurs d‚Äôextr√©mum ========== */
  for(let i=0;i<n;i++){
    const want  = String(extrema[i].y);
    const isMax = (extrema[i].type==='max');

    const ymax = host.querySelector(`input.ymax[data-i="${i}"]`);
    const ymin = host.querySelector(`input.ymin[data-i="${i}"]`);
    const vy   = norm(ymax?.value);
    const vi   = norm(ymin?.value);

    if(isMax){
      if(vy!==''){ tot++; const good=(vy===want); setTick(ymax, good?'ok':'ko'); if(good) ok++; }
      else if(tableComplete){ setTick(ymax,'ko'); } // vide mais requis ‚Üí X quand complet
      // ligne MIN doit rester vide
      if(vi!==''){ tot++; setTick(ymin,'ko'); }
      else if(tableComplete){ setTick(ymin,'ok'); } // vide l√©gitime ‚Üí V
    }else{ // minimum
      if(vi!==''){ tot++; const good=(vi===want); setTick(ymin, good?'ok':'ko'); if(good) ok++; }
      else if(tableComplete){ setTick(ymin,'ko'); }
      if(vy!==''){ tot++; setTick(ymax,'ko'); }
      else if(tableComplete){ setTick(ymax,'ok'); }
    }
  }

/* ========== 5) BORNES (x_min, x_max) : OBLIGATOIRE ========== */

// helper pour une borne
function checkBoundary(side){ // 'left' -> x_min, 'right' -> x_max
  const idx = (side==='left') ? '-1' : '-2';
  const yVal = (side==='left') ? Ys[0] : Ys[Ys.length-1];
  const dir  = (side==='left') ? DIR[0] : DIR[n];

  // r√®gle d‚Äôemplacement : √† gauche ‚Üó -> bas ; ‚Üò -> haut. √Ä droite ‚Üó -> haut ; ‚Üò -> bas.
  const shouldTop = (side==='left') ? (dir==='‚Üò') : (dir==='‚Üó');

  const ymax = host.querySelector(`input.ymax[data-i="${idx}"]`);
  const ymin = host.querySelector(`input.ymin[data-i="${idx}"]`);
  const vy = norm(ymax?.value), vi = norm(ymin?.value);

  const filled = (vy!=='' || vi!=='');
  if(!filled){
    // obligatoire ‚Üí si tableau complet, X sur les deux, sinon on attend
    if(tableComplete){
      setTick(ymax,'ko'); setTick(ymin,'ko');
      tot+=2; // on compte les deux manquants
    }
    return;
  }

  // bonne ligne + bonne valeur
  const topOK = (vy!=='' && vy===String(yVal) && shouldTop    && vi===''); // l‚Äôautre doit √™tre vide
  const botOK = (vi!=='' && vi===String(yVal) && !shouldTop   && vy==='');

  tot++; // on compte une v√©rif globale pour la borne
  if(topOK){ setTick(ymax,'ok'); setTick(ymin,'ok'); ok++; return; }
  if(botOK){ setTick(ymax,'ok'); setTick(ymin,'ok'); ok++; return; }

  // sinon, marquer pr√©cis√©ment ce qui est faux
  if(vy!=='') setTick(ymax, (vy===String(yVal) && shouldTop)? 'ok' : 'ko');
  else if(tableComplete) setTick(ymax, shouldTop ? 'ko':'ok'); // si vide mais on attendait en haut ‚Üí X

  if(vi!=='') setTick(ymin, (vi===String(yVal) && !shouldTop)? 'ok' : 'ko');
  else if(tableComplete) setTick(ymin, !shouldTop ? 'ko':'ok');
}
checkBoundary('left');
checkBoundary('right');

/* ========== 6) Questions max/min sur [a;b] (multiplicit√©) ========== */
const Xs2 = [R.xmin+1, ...extrema.map(e=>e.x), R.xmax-1];
const Ys2 = [knots[0].y, ...extrema.map(e=>e.y), knots[knots.length-1].y];

// max/min des images
const ymax = Math.max(...Ys2);
const ymin = Math.min(...Ys2);

// ensembles d'abscisses o√π le max/min est atteint
const Xmax = Xs2.filter((_,i)=>Ys2[i]===ymax).map(String);
const Xmin = Xs2.filter((_,i)=>Ys2[i]===ymin).map(String);

// normalise texte -> tableau de cha√Ænes num√©riques
const toList = s => (s||'')
  .trim()
  .replace(/\u2212/g,'-')     // minus unicode
  .replace(/,/g,';')
  .replace(/\s+/g,' ')
  .replace(/\s*;\s*/g,';')
  .split(';')
  .map(t=>t.trim())
  .filter(t=>t!=='')
  .map(t=>t.replace(',', '.')); // au cas o√π

function sameSet(ans, ref){
  if(ans.length===0) return false;
  const A=[...new Set(ans)], R=[...new Set(ref)];
  if(A.length!==R.length) return false;
  A.sort(); R.sort();
  for(let i=0;i<A.length;i++) if(A[i]!==R[i]) return false;
  return true;
}

function checkExact(sel, expected){
  const el = host.querySelector(sel);
  if(!el) return;
  const v = norm(el.value);
  if(!v) return; // vide -> non compt√©
  tot++;
  const good = (v === expected);
  setTick(el, good?'ok':'ko'); if(good) ok++;
}

// images (num√©riques exactes ici)
checkExact('.qmaxy', String(ymax));
checkExact('.qminy', String(ymin));

// abscisses : listes possibles
function checkList(sel, refSet){
  const el = host.querySelector(sel);
  if(!el) return;
  const L = toList(el.value);
  if(L.length===0) return;
  tot++;
  const good = sameSet(L, refSet);
  setTick(el, good?'ok':'ko'); if(good) ok++;
}
checkList('.qmaxx', Xmax);
checkList('.qminx', Xmin);
/* ===== 7) Q4 ‚Äî Tableau de signe ===== */
/* ===== 7) Q4 ‚Äî V√©rification tableau de signe (mod√®le Florent) ===== */
(function(){
  const norm = s => (s||'').trim().replace(/\u2212/g,'-').replace(',','.');
  const roots = (st.roots||[]).slice().sort((u,v)=>u-v).map(String);
  const aS = String(st.R.xmin+1), bS = String(st.R.xmax-1);

  // (a) bornes
  const inMin = host.querySelector('input.xbnd[data-role="xmin"]');
  const inMax = host.querySelector('input.xbnd[data-role="xmax"]');
  if(inMin && norm(inMin.value)!==''){ tot++; const okB=(norm(inMin.value)===aS); setTick(inMin, okB?'ok':'ko'); if(okB) ok++; }
  if(inMax && norm(inMax.value)!==''){ tot++; const okB=(norm(inMax.value)===bS); setTick(inMax, okB?'ok':'ko'); if(okB) ok++; }

  // (b) racines (ordre croissant)
  roots.forEach((w,i)=>{
    const inp = host.querySelector(`input.root[data-i="${i}"]`);
    if(!inp) return;
    const v = norm(inp.value);
    if(!v) return;
    tot++; const good=(v===w);
    setTick(inp, good?'ok':'ko'); if(good) ok++;
  });

  // (c) signes sur les k+1 intervalles entre [xmin, x1, ..., xk, xmax]
  const rts = st.roots.slice().sort((a,b)=>a-b);
  const cuts = [st.R.xmin+1, ...rts, st.R.xmax-1];

  // signe attendu dans (cuts[i], cuts[i+1])
  const wantSigns = (()=> {
    const X = st.Xs, Y = st.Ys, out=[];
    for(let i=0;i<cuts.length-1;i++){
      let s=null;
      for(let k=0;k<X.length;k++){
        if(X[k] > cuts[i]+1e-9 && X[k] < cuts[i+1]-1e-9){ s = (Math.sign(Y[k])>=0?'+':'‚àí'); break; }
      }
      if(s==null){
        const k = X.findIndex(x=>x>=cuts[i]);
        s = ((k>=0?Math.sign(Y[Math.min(k,Y.length-1)]):Math.sign(Y[0]))>=0?'+':'‚àí');
      }
      out.push(s);
    }
    return out;
  })();

  host.querySelectorAll('select.sgn').forEach(sel=>{
    if(!sel.value) return;
    tot++; const i=+sel.dataset.i, good=(sel.value===wantSigns[i]);
    setTick(sel, good?'ok':'ko'); if(good) ok++;
  });
  const a = st.R.xmin+1, b = st.R.xmax-1;
  const Xs = st.Xs, Ys = st.Ys;

  // valeur en bornes utiles
  const yL = Ys[0];                    // f(a)
  const yR = Ys[Ys.length-1];          // f(b)
  const needLeftZero  = (yL === 0);
  const needRightZero = (yR === 0);

  host.querySelectorAll('input.z0').forEach(inp=>{
    const role = inp.dataset.role;
    const v = norm(inp.value);

    // d√©termine si "z√©ro requis" pour cette case
    let required = false;
    if(role === 'root') required = true;
    else if(role === 'xmin') required = needLeftZero;
    else if(role === 'xmax') required = needRightZero;

    if(required){
      if(!v) return;                 // vide ‚Üí non compt√© (l'√©l√®ve n'a rien mis)
      tot++;
      const good = (v === '0');
      setTick(inp, good?'ok':'ko'); if(good) ok++;
    }else{
      // ne doit PAS √™tre rempli
      if(!v) return;                 // vide l√©gitime ‚Üí on ne compte pas
      tot++; setTick(inp,'ko');      // contenu non vide ‚Üí erreur
    }
  });

})();



  $('#res',host).textContent='';
  return {ok,total:tot};
}
,

// ‚Äî‚Äî‚Äî‚Äî‚Äî SOLUTION ‚Äî‚Äî‚Äî‚Äî‚Äî
solution(host, st){
  const { R, extrema, knots, n } = st;

  // Abscisses et images
  const Xs = [R.xmin+1, ...extrema.map(e=>e.x), R.xmax-1];
  const Ys = [knots[0].y, ...extrema.map(e=>e.y), knots[knots.length-1].y];

  // Sens ‚Üó/‚Üò entre colonnes
  const DIR = []; for(let i=0;i<=n;i++) DIR.push(Ys[i+1] > Ys[i] ? '‚Üó' : '‚Üò');

  // Ligne x : x_min, (vide), x1, (vide), ‚Ä¶, x_max
  const rowX = ['<tr><th>\\(x\\)</th>'];
  Xs.forEach((x,j)=>{
    rowX.push(`<td>\\(${x}\\)</td>`);
    if (j < Xs.length-1) rowX.push('<td></td>');
  });
  rowX.push('</tr>');

  // Bloc valeurs √† 2 niveaux (haut = MAX, bas = MIN)
  const valBlock = (kind, i, y)=>{
    let up='&nbsp;', dn='&nbsp;';
    if(kind==='ext'){                         // extr√©mum interne i
      if(extrema[i].type==='max') up = `\\(${y}\\)`; else dn = `\\(${y}\\)`;
    }else if(kind==='left'){                  // x_min : selon premi√®re fl√®che
      if (DIR[0]==='‚Üó') dn = `\\(${y}\\)`; else up = `\\(${y}\\)`;
    }else if(kind==='right'){                 // x_max : selon derni√®re fl√®che
      if (DIR[n]==='‚Üó') up = `\\(${y}\\)`; else dn = `\\(${y}\\)`;
    }
    return `<td>
      <div style="text-align:center">${up}</div>
      <div style="height:6px"></div>
      <div style="text-align:center">${dn}</div>
    </td>`;
  };

  // Ligne f : bloc(xmin), fl√®che0, bloc(ext0), fl√®che1, ‚Ä¶, fl√®che n, bloc(xmax)
  const rowF = ['<tr><th>\\(f\\)</th>'];
  rowF.push( valBlock('left', -1, Ys[0]) );
  for(let i=0;i<n;i++){
    rowF.push(`<td>${DIR[i]}</td>`);
    rowF.push( valBlock('ext', i, Ys[i+1]) );
  }
  rowF.push(`<td>${DIR[n]}</td>`);
  rowF.push( valBlock('right', -2, Ys[Ys.length-1]) );
  rowF.push('</tr>');

  const html = `
    <div><b>1.</b> Tableau de variations de \\(f\\) :</div>
	<div class="var-wrap">
      <table class="pdf-tbl">
        <thead>${rowX.join('')}</thead>
        <tbody>${rowF.join('')}</tbody>
      </table>
    </div>`;

  $('#res',host).innerHTML = `<div class="step"> ${html}</div>`;
 const a = R.xmin + 1, b = R.xmax - 1;
const Xs2 = [a, ...extrema.map(e=>e.x), b];
const Ys2 = [knots[0].y, ...extrema.map(e=>e.y), knots[knots.length-1].y];

const ymax = Math.max(...Ys2), ymin = Math.min(...Ys2);
const Xmax = Xs2.filter((_,i)=>Ys2[i]===ymax);
const Xmin = Xs2.filter((_,i)=>Ys2[i]===ymin);

const fmtList = L =>
  L.map(x => `x = ${String(x).replace('-', '‚àí')}`)
   .join(' \\;\\text{ et }\\; ');

const sBlock = document.createElement('div');
sBlock.className = 'step';
sBlock.style.marginTop = '6px';
sBlock.innerHTML = `
  <div><b>2.</b> Sur \\([${a}\\,;\\,${b}]\\), le maximum de la fonction \\(f\\) est \\( ${ymax}\\) atteint en \\( ${fmtList(Xmax)}\\).</div>
  <div><b>3.</b> Sur \\([${a}\\,;\\,${b}]\\), le minimum de la fonction \\(f\\) est \\( ${ymin}\\) atteint en \\(${fmtList(Xmin)}\\).</div>
`;
$('#res',host).appendChild(sBlock);
typesetAll($('#res',host));
// ‚Äî‚Äî‚Äî Solution Q4 : m√™me maquette, remplie ‚Äî‚Äî‚Äî
(function(){
  const aS = st.R.xmin+1, bS = st.R.xmax-1;
  const roots = (st.roots||[]).slice().sort((u,v)=>u-v);
  const k = roots.length;

  // signes attendus
  const cuts = [aS, ...roots, bS];
  const X = st.Xs, Y = st.Ys;
  const signs=[];
  for(let i=0;i<cuts.length-1;i++){
    let s=null;
    for(let t=0;t<X.length;t++){
      if(X[t] > cuts[i]+1e-9 && X[t] < cuts[i+1]-1e-9){ s=(Math.sign(Y[t])>=0?'+':'‚àí'); break; }
    }
    if(s==null){
      const t = X.findIndex(x=>x>=cuts[i]);
      s = ((t>=0?Math.sign(Y[Math.min(t,Y.length-1)]):Math.sign(Y[0]))>=0?'+':'‚àí');
    }
    signs.push(s);
  }

  // colonnes m√™mes qu'en √©nonc√©
  const cols=[];
  cols.push({kind:'x', role:'xmin', val:aS});
  for(let i=0;i<k;i++){ cols.push({kind:'gap'}); cols.push({kind:'x', role:'root', idx:i, val:roots[i]}); }
  cols.push({kind:'gap'}); cols.push({kind:'x', role:'xmax', val:bS});

// LIGNE x (affichage simple)
let rowX = '<tr><th>\\(x\\)</th>';
cols.forEach(c=>{
  if(c.kind==='x'){
    rowX += `<td>\\(${String(c.val).replace('-','‚àí')}\\)</td>`;
  }else{
    rowX += '<td></td>';
  }
});
rowX += '</tr>';

// LIGNE f (texte uniquement)
const yL = st.Ys[0], yR = st.Ys[st.Ys.length-1];
let rowF = '<tr><th>\\(f(x)\\)</th>';
let si=0;
cols.forEach(c=>{
  if(c.kind==='gap'){
    rowF += `<td style="font-weight:700;text-align:center">${signs[si++]}</td>`;
  }else if(c.role==='root'){
    rowF += `<td style="font-weight:700;text-align:center">0</td>`;
  }else if(c.role==='xmin'){
    rowF += `<td style="font-weight:700;text-align:center">${(yL===0)?'0':''}</td>`;
  }else if(c.role==='xmax'){
    rowF += `<td style="font-weight:700;text-align:center">${(yR===0)?'0':''}</td>`;
  }else{
    rowF += '<td></td>';
  }
});
rowF += '</tr>';



  const box = document.createElement('div');
  box.className = 'step';
  box.style.marginTop = '6px';
  box.innerHTML = `
    <div><b>4.</b> Tableau de signes de \\(f\\) :</div>
    <div class="var-wrap">
      <table class="pdf-tbl">
        
   <thead>${rowX}</thead>
 <tbody>${rowF}</tbody>

      </table>
    </div>`;
  $('#res',host).appendChild(box);
  typesetAll($('#res',host));
})();



  typesetAll(host);
}
,


  reset(host){ $('#res',host).textContent=''; }
};







const ex2 = {
  id:'table_to_points_curve',
  title:'Tableau de variations ‚Üí points ‚Üí courbe lisse',
gen(){
  const n = pickExtremaCountWeighted();
  const {knots, extrema, R} = makeSmoothCurveKnots(n);
  const xs = [R.xmin + 1, ...extrema.map(e=>e.x), R.xmax - 1];  // bornes ‚Äúutiles‚Äù (les n≈ìuds)
  const ys = [knots[0].y,  ...extrema.map(e=>e.y), knots[knots.length-1].y];
  return { n, R, extrema, xs, ys };
}
,


  render(host, st){
  const { n, R, extrema, xs, ys } = st;

  host.innerHTML = `
    <div>√Ä partir du <b>tableau de variations compl√©t√©</b> ci-dessous, place sur le rep√®re les points \\((x_i, f(x_i))\\).
    Quand tous les points sont correctement plac√©s, une courbe lisse s‚Äôaffiche automatiquement.</div>
    <div class="graph" style="display:flex;justify-content:center;margin:.4rem 0"></div>
    <div id="tbl"></div>
    <div class="steps small" id="res"></div>
  `;

    // ‚Äî‚Äî‚Äî Rep√®re interactif ‚Äî‚Äî‚Äî
  const rep = buildRepereSVG({ xmin:R.xmin, xmax:R.xmax, ymin:R.ymin, ymax:R.ymax, grid:true, arrows:true });
  const layerPts = document.createElementNS(rep.svg.namespaceURI,'g');
  rep.plot.appendChild(layerPts);
  host.querySelector('.graph').appendChild(rep.svg);

  const targets = xs.map((x,i)=>({ x, y: ys[i] }));
  const placed = [];

  function persist(){
    host.dataset.points = JSON.stringify({targets, placed});
  }

  function redraw(){
    while(layerPts.firstChild) layerPts.removeChild(layerPts.firstChild);
    placed.forEach(p=>{
      const c=document.createElementNS(rep.svg.namespaceURI,'circle');
      c.setAttribute('cx', rep.X(p.x)); c.setAttribute('cy', rep.Y(p.y));
      c.setAttribute('r', 4.2); c.setAttribute('fill', '#111');
      layerPts.appendChild(c);
    });
  }

  function svgPointFromClient(evt){
    const pt = rep.svg.createSVGPoint();
    pt.x = (evt.touches? evt.touches[0].clientX : evt.clientX);
    pt.y = (evt.touches? evt.touches[0].clientY : evt.clientY);
    return pt.matrixTransform(rep.svg.getScreenCTM().inverse());
  }

  function snapToGridUnits(svgPt){
    const x = Math.round(rep.Xi(svgPt.x));
    const y = Math.round(rep.Yi(svgPt.y));
    return {x,y};
  }

  function togglePoint(p){
    if(p.x<R.xmin || p.x>R.xmax || p.y<R.ymin || p.y>R.ymax) return;
    const k = placed.findIndex(q=>q.x===p.x && q.y===p.y);
    if(k>=0) placed.splice(k,1); else placed.push(p);
    redraw(); persist();
  }

const self = this; // pour appeler drawSmoothThrough depuis le handler

function allPointsPlaced() {
  const needed = xs.map((x,i)=>({x, y:ys[i]}));
  const TOL = 0.2;
  return needed.every(w =>
    placed.some(p => Math.abs(p.x - w.x) <= TOL && Math.abs(p.y - w.y) <= TOL)
  );
}

const handleClick = (e)=>{
  e.preventDefault();
  togglePoint( snapToGridUnits( svgPointFromClient(e) ) );

  // ‚ö° affichage auto de la courbe quand tout est bon
  if (!st._curveShown && allPointsPlaced()) {
    const pts = xs.map((x,i)=>({x, y:ys[i]}));
    self.drawSmoothThrough(st, pts);
    st._curveShown = true;
    $('#res',host).textContent = 'Tous les points sont correctement plac√©s : courbe affich√©e.';
  }
};
  rep.hit.addEventListener('click', handleClick);
  rep.hit.addEventListener('touchstart', handleClick, {passive:false});

  redraw();
  persist();

  // expose pour solution()
  st._rep = rep; st._layerPts = layerPts;


  /* ‚Äî‚Äî‚Äî Tableau de variations PR√â-REMPLI (aucune saisie) ‚Äî‚Äî‚Äî */
  const DIR=[]; for(let i=0;i<=n;i++) DIR.push(ys[i+1] > ys[i] ? '‚Üó' : '‚Üò');

  const rowX = ['<tr><th>\\(x\\)</th>'];
  xs.forEach((x,j)=>{ rowX.push(`<td>\\(${String(x).replace('-','‚àí')}\\)</td>`); if(j<xs.length-1) rowX.push('<td></td>'); });
  rowX.push('</tr>');

  const ruleAt = side => (side==='left' ? (DIR[0]==='‚Üò'?'top':'bot')
                                         : (DIR[n]==='‚Üó'?'top':'bot'));
  const valBlock=(where,i,y)=>{
    let up='&nbsp;', dn='&nbsp;';
    if(where==='left'){ (ruleAt('left')==='top' ? (up=`\\(${y}\\)`) : (dn=`\\(${y}\\)`)); }
    else if(where==='right'){ (ruleAt('right')==='top' ? (up=`\\(${y}\\)`) : (dn=`\\(${y}\\)`)); }
    else{ (st.extrema[i].type==='max' ? (up=`\\(${y}\\)`) : (dn=`\\(${y}\\)`)); }
    return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`;
  };

  const rowF=['<tr><th>\\(f\\)</th>'];
  rowF.push(valBlock('left',-1,ys[0]));
  for(let i=0;i<n;i++){
    rowF.push(`<td>${DIR[i]}</td>`);
    rowF.push(valBlock('ext',i,ys[i+1]));
  }
  rowF.push(`<td>${DIR[n]}</td>`);
  rowF.push(valBlock('right',-2,ys[ys.length-1]));
  rowF.push('</tr>');

  $('#tbl',host).innerHTML = `
    <div class="var-wrap">
      <table class="pdf-tbl">
        <thead>${rowX.join('')}</thead>
        <tbody>${rowF.join('')}</tbody>
      </table>
    </div>
  `;
  typesetAll(host);

  // √©tat pour la correction
  host.dataset.points = JSON.stringify({targets, placed});
  st._rep = rep; st._layerPts = layerPts;
},


  correct(host, st){
  const { xs, ys } = st;
  const state = JSON.parse(host.dataset.points||'{}');
  const placed = state.placed || [];
  const needed = xs.map((x,i)=>({x, y:ys[i]}));

  const TOL = 0.2;
  let ok = 0, tot = needed.length;

  needed.forEach(w=>{
    const hit = placed.some(p=> Math.abs(p.x-w.x)<=TOL && Math.abs(p.y-w.y)<=TOL );
    if(hit) ok++;
  });

  if (ok === tot && !st._curveShown) {
    const pts = xs.map((x,i)=>({x, y:ys[i]}));
    this.drawSmoothThrough(st, pts);
    st._curveShown = true;
    $('#res',host).textContent='Tous les points sont correctement plac√©s : courbe affich√©e.';
  } else if (ok !== tot) {
    $('#res',host).textContent = '';
  }

  // ‚¨áÔ∏è  TICK apr√®s clic sur V√©rifier (‚úì si tout est bon, ‚úó sinon)
  const resEl = $('#res',host);
  setTick(resEl, ok===tot ? 'ok' : 'ko');

  return { ok, total: tot };
},


  // Dessin d‚Äôune courbe lisse passant par les points (pentes nulles aux extr√©mums)
  drawSmoothThrough(st, pts){
    const rep = st._rep;
    if(!rep) return;
    // on cr√©e les "knots" : pente 0 aux extr√©mums uniquement (entre xmin et xmax)
    const K=[];
    for(let i=0;i<pts.length;i++){
      const x=pts[i].x, y=pts[i].y;
      // extr√©mum ssi x correspond √† un des x_i internes g√©n√©r√©s
      const kExt = st.extrema.findIndex(e=>e.x===x);
      const m = (kExt>=0 ? 0 : undefined); // pente nulle si extr√©mum, sinon calcul√©e apr√®s
      K.push({x,y,m});
    }
    // approx pente sur les non-extr√©mums (finies diff√©rences)
    for(let i=0;i<K.length;i++){
      if(K[i].m===0) continue;
      const prev=K[Math.max(0,i-1)], next=K[Math.min(K.length-1,i+1)];
      const dx=(next.x - prev.x)||1;
      K[i].m = (next.y - prev.y)/dx * 0.9; // lissage doux
    }
    const d = pathFromKnots(rep, K);
    addPath(rep.plot, d, {stroke:'#000','stroke-width':2.6});
  },

solution(host, st){
  const { R, xs, ys } = st;

  const steps = $('.steps', host);
  if (!steps) return;

  // Nettoyer le bloc correction
  steps.innerHTML = '';

  const title = document.createElement('div');
  title.textContent = 'Courbe corrig√©e :';
  title.style.fontWeight = '600';
  title.style.margin = '0 0 6px';
  steps.appendChild(title);

  const box = document.createElement('div');
  box.className = 'corr-graph';
  box.style.display = 'inline-block';
  box.style.background = '#fff';
  box.style.border = '1px solid #e6e6e6';
  box.style.borderRadius = '10px';
  box.style.padding = '8px';
  steps.appendChild(box);

  // --- Rep√®re d√©di√© ---
  const repSol = buildRepereSVG({
    xmin:R.xmin, xmax:R.xmax, ymin:R.ymin, ymax:R.ymax,
    grid:true, arrows:true
  });
// apr√®s: const repSol = buildRepereSVG({ ... });
repSol.svg.setAttribute('width',  564);   // ‚âà W calcul√© (ajuste si besoin)
repSol.svg.setAttribute('height', 336);   // ‚âà H calcul√©
  // ‚ö†Ô∏è ADAPTE selon ce que renvoie ta fonction :
  // si c‚Äôest un objet {svg, plot}
  const svg = repSol.svg || repSol;
  const plot = repSol.plot || svg;

  box.appendChild(svg);

  // --- Points attendus ---
  const svgNS = svg.namespaceURI;
  const layer = document.createElementNS(svgNS, 'g');
  plot.appendChild(layer);

  const pts = xs.map((x,i)=>({x, y:ys[i]}));
  pts.forEach(p=>{
    const c = document.createElementNS(svgNS,'circle');
    c.setAttribute('cx', repSol.X(p.x));
    c.setAttribute('cy', repSol.Y(p.y));
    c.setAttribute('r', 4.2);
    c.setAttribute('fill', '#111');
    layer.appendChild(c);
  });

  // --- Courbe lisse ---
  const prevRep = st._rep;
  st._rep = repSol;
  this.drawSmoothThrough(st, pts);
  st._rep = prevRep;


}
,

// ‚Äî‚Äî‚Äî Exo 2 : remplacer la fonction reset ‚Äî‚Äî‚Äî
reset(host){
  // 1) vider le message et remettre le tick neutre
  const resEl = $('#res', host);
  if (resEl) {
    resEl.textContent = '';
    ensureTickAfter(resEl).className = 'tick nu';
  }

  // 2) supprimer les points et la/les courbe(s) du <plot>
  const svg = $('.graph svg.repere', host);
  if (svg) {
    const plot = svg.querySelector('g.plot');
    if (plot) {
      // enl√®ve tous les cercles (points) et chemins (courbes) ajout√©s
      plot.querySelectorAll('circle').forEach(n => n.remove());
      plot.querySelectorAll('path').forEach(n => n.remove());
    }
  }

  // 3) vider l‚Äô√©tat "placed" mais conserver les cibles (targets)
  try {
    const S = JSON.parse(host.dataset.points || '{}');
    if (S && Array.isArray(S.targets)) {
      S.placed = [];                            // on efface uniquement les points pos√©s
      host.dataset.points = JSON.stringify(S);  // on persiste
    }
  } catch(_) {}
}
};




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì √âtude de fonctions ‚Ä¢ Sens de variations',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
