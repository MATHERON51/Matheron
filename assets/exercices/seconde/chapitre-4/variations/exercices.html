<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì √âtude de fonctions ‚Ä¢ Sens de variations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äî √âtude de fonctions ‚Ä¢ Sens de variations</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax=520, Hmax=300, mL=28, mT=8, mR=8, mB=28;
  const {xmin,xmax,ymin,ymax} = opts;

const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7)); // 4.5px par d√©faut

  // 1) √âchelle commune (orthonorm√©e)
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;
  const s  = Math.min(Wmax / Rx, Hmax / Ry);      // m√™me "px par unit√©" pour x et y
  const w  = s * Rx;
  const h  = s * Ry;

  // 2) Centrage de la fen√™tre de trac√© (letterbox si besoin)
  const x0 = mL + (Wmax - w)/2;
  const y0 = mT + (Hmax - h)/2;

  // 3) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  // Cr√©ation SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','repere');

  const defs = document.createElementNS(svg.namespaceURI,'defs');
 // ‚Äî‚Äî‚Äî PATCH FLECHES ‚Äî‚Äî‚Äî

const mark = document.createElementNS(svg.namespaceURI,'marker');
mark.setAttribute('id','arrow');
mark.setAttribute('markerUnits','userSpaceOnUse');   // taille ind√©pendante du stroke
mark.setAttribute('markerWidth', AR);
mark.setAttribute('markerHeight', AR);
mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
mark.setAttribute('refX', AR);                       // ‚Üê la pointe (x=AR) tombe pile sur la fin de la ligne
mark.setAttribute('refY', AR/2);
mark.setAttribute('orient','auto');

const tri = document.createElementNS(svg.namespaceURI,'path');
// triangle : pointe √† (AR, AR/2)
tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
tri.setAttribute('fill','#111');
mark.appendChild(tri);
defs.appendChild(mark);

  const clip=document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect=document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0); crect.setAttribute('y',y0);
  crect.setAttribute('width',w); crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes=document.createElementNS(svg.namespaceURI,'g');
  const plot=document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes); svg.appendChild(plot);

  // Fonctions de transformation : m√™me √©chelle s pour x et y
  const X = x => x0 + (x - xmin) * s;
  const Y = y => y0 + h - (y - ymin) * s;

  // Cadre (zone orthonorm√©e centr√©e)
  const frame=document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0); frame.setAttribute('y',y0);
  frame.setAttribute('width',w); frame.setAttribute('height',h);
  frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // Axes (born√©s au cadre)
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx=document.createElementNS(svg.namespaceURI,'g');
    const ty=document.createElementNS(svg.namespaceURI,'g');

    const fmt=n=>String(n).replace('-', '‚àí');

    // verticales enti√®res
    for(let xv=Math.ceil(xmin); xv<=xmax+1e-9; xv+=1){
      const xx=X(xv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx); l.setAttribute('y1',y0);
      l.setAttribute('x2',xx); l.setAttribute('y2',y0+h);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(xv);
      t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
      t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle');
      tx.appendChild(t);
    }
    // horizontales enti√®res
    for(let yv=Math.ceil(ymin); yv<=ymax+1e-9; yv+=1){
      const yy=Y(yv);
      const l=document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0); l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w); l.setAttribute('y2',yy);
      g.appendChild(l);

      const t=document.createElementNS(svg.namespaceURI,'text');
      t.textContent=fmt(yv);
      t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
      t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
      t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end');
      ty.appendChild(t);
    }
    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }


 // Axes fl√©ch√©s jusqu'au bord du cadre
const axX = document.createElementNS(svg.namespaceURI,'line');
axX.setAttribute('x1', x0);
axX.setAttribute('x2', x0 + w);        // ‚Üê jusqu'au bord
axX.setAttribute('y1', yAxisY);
axX.setAttribute('y2', yAxisY);
axX.setAttribute('stroke', '#111');
axX.setAttribute('stroke-width', '2.2');
axX.setAttribute('stroke-linecap', 'butt'); // ‚Üê pas d‚Äôarrondi qui d√©passe
if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axX);

const axY = document.createElementNS(svg.namespaceURI,'line');
axY.setAttribute('x1', xAxisX);
axY.setAttribute('x2', xAxisX);
axY.setAttribute('y1', y0 + h);
axY.setAttribute('y2', y0);            // ‚Üê jusqu'au bord
axY.setAttribute('stroke', '#111');
axY.setAttribute('stroke-width', '2.2');
axY.setAttribute('stroke-linecap', 'butt'); // ‚Üê idem
if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
axes.appendChild(axY);


  // inverses (px -> unit√©s)
  const Xi = px => xmin + (px - x0) / s;
  const Yi = py => ymin + (y0 + h - py) / s;

  // grande zone "hit" cliquable exactement sur le cadre
  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0); hit.setAttribute('y', y0);
  hit.setAttribute('width', w); hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };

}

// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}
function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = `M ${X(K[0].x)} ${Y(K[0].y)}`;
  for(let i=0;i<K.length-1;i++){
    const P0=[K[i].x, K[i].y], P1=[K[i+1].x, K[i+1].y];
    const {C1,C2} = hermiteToBezier(P0, P1, K[i].m, K[i+1].m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(P1[0])} ${Y(P1[1])}`;
  }
  return d;
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
function makeSmoothCurveKnots(nExt){
  // 1) Axe X sym√©trique
  const halfX = choice([5,6,7]);        // demi-largeur (au choix)
  const xmin = -halfX, xmax = +halfX;

  // abscisses enti√®res disponibles pour extr√©mums internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  function sampleSorted(arr, k){
    const a=[...arr], out=[];
    while(out.length<k && a.length){ out.push(a.splice(Math.floor(Math.random()*a.length),1)[0]); }
    out.sort((u,v)=>u-v); return out;
  }
  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleSorted(Xcand, n);

  // 2) Niveaux altern√©s min/max
  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // valeurs aux bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  const sL = 0.6 * (yFirst - yL) / (Xext[0] - xmin);
  const sR = 0.6 * (yR - yLast) / (xmax - Xext[n-1]);

  const K = [{x:xmin, y:yL, m:sL}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax, y:yR, m:sR});

  // 3) Axe Y sym√©trique (avec padding)
  const PAD=2;
  const yMinData = Math.min(yL,yR,...levels);
  const yMaxData = Math.max(yL,yR,...levels);
  // demi-hauteur sym√©trique, avec marge d‚Äô1 unit√© pour √©viter les bords
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;

  const R = {
    xmin: xmin - 1,      // petite marge visuelle en x (sym√©trique)
    xmax: xmax + 1,
    ymin: -halfY,        // sym√©trique en y
    ymax: +halfY
  };

  return {
    knots: K,
    extrema: Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')})),
    R
  };
}




const ex1 = {
  id:'var_from_curve_multi',
  title:'Compl√©ter le tableau de variations',
  gen(){
    const n = pickExtremaCountWeighted();                 // 15/40/35/10 %
    const {knots, extrema, R} = makeSmoothCurveKnots(n);  // rep√®re + courbe lisse + extr√©mums
    return { R, knots, extrema, n };
  },
  render(host, st){
  const {R,knots,extrema,n} = st;

  host.innerHTML = `
    <div>Soit \\(f\\) la fonction repr√©sent√©e ci-contre.</div>
		<div>Donner le tableau de variations de la fonction \\(f\\).</div>
    <div class="graph" style="display:flex;justify-content:center;margin:.4rem 0"></div>
    <div id="var-host"></div>
    <div class="steps small" id="res"></div>
  `;

  // Rep√®re + courbe lisse
  const rep = buildRepereSVG({ xmin:R.xmin, xmax:R.xmax, ymin:R.ymin, ymax:R.ymax, grid:true, arrows:true });
  addPath(rep.plot, pathFromKnots(rep, knots), { stroke:'#000', 'stroke-width':2.6 });
  host.querySelector('.graph').appendChild(rep.svg);

  // ‚Äî helpers cellules
  const xCell = (idx, ph)=>`<td style="text-align:center">
    <input class="xcell" data-i="${idx}" type="text" style="width:110px;text-align:center" placeholder="">
  </td>`;
  const emptyCell = ()=>`<td></td>`;
  const arrowCell = idx=>`<td class="bigsel">
    <select class="dir" data-i="${idx}">
      <option value=""></option><option>‚Üò</option><option>‚Üó</option>
    </select>
  </td>`;
  const yCell = (idx, ph)=>`<td>
  <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
    <input class="ymax" data-i="${idx}" type="text" placeholder="" style="width:90px;text-align:center">
    <input class="ymin" data-i="${idx}" type="text" placeholder="" style="width:90px;text-align:center">
  </div>
</td>`;

  // Indexation des colonnes "donn√©es" : [-1, 0, 1, ..., n-1, -2]
  const dataCols = [-1, ...extrema.map((_,i)=>i), -2];
  const phX = i => (i===-1?`${R.xmin}`: i===-2?`${R.xmax}` : `${extrema[i].x}`).replace('-','‚àí');
  const phY = i => (i===-1||i===-2? '' : `${extrema[i].y}`); // placeholder visible seulement au niveau des extr√©mums

  // ‚Äî Ligne x : input, (vide), input, (vide), ..., input
  let rowX = `<tr><th>\\(x\\)</th>`;
  dataCols.forEach((idx,j)=>{
    rowX += xCell(idx, phX(idx));
    if (j < dataCols.length - 1) rowX += emptyCell(); // colonne vide au-dessus de chaque fl√®che
  });
  rowX += `</tr>`;

  // ‚Äî Ligne f : yCell, fl√®che, yCell, fl√®che, ..., yCell  (lignes coll√©es, pas de spacer)
  let rowF = `<tr><th>\\(f\\)</th>`;
  dataCols.forEach((idx,j)=>{
    rowF += yCell(idx, phY(idx));
    if (j < dataCols.length - 1) rowF += arrowCell(j); // autant de fl√®ches que d'intervalles
  });
  rowF += `</tr>`;

  // ‚Äî Table finale (sans ligne d‚Äô√©tiquettes)
document.getElementById('var-host').innerHTML = `
  <div class="var-wrap">
    <table class="var frame-only">
      <tbody>
        ${rowX}
        ${rowF}
      </tbody>
    </table>
  </div>
`;
// Ajuste la hauteur des s√©lecteurs de fl√®ches √† celle des colonnes max/min voisines
function adjustArrowHeights(){
  host.querySelectorAll('td.bigsel select').forEach(sel=>{
    const td = sel.closest('td');
    // colonne "valeurs" voisine (gauche sinon droite)
    const ref = td.previousElementSibling?.querySelector('.ycol')
             || td.nextElementSibling?.querySelector('.ycol');
    if(!ref) return;
    const h = Math.round(ref.getBoundingClientRect().height);

    // on fait correspondre hauteur + font-size + line-height
    sel.style.height    = h + 'px';
    sel.style.lineHeight= h + 'px';                 // certains navigateurs
    sel.style.fontSize  = Math.max(28, Math.floor(h * 0.72)) + 'px';
  });
}
adjustArrowHeights();
window.addEventListener('resize', adjustArrowHeights);


  // Ticks
  host.querySelectorAll('input,select').forEach(ensureTickAfter);
  typesetAll(host);
}
,

  // ‚Äî‚Äî‚Äî‚Äî‚Äî CORRECTION ‚Äî‚Äî‚Äî‚Äî‚Äî
correct(host,st){
  const {R, extrema, knots, n} = st;
  let ok=0, tot=0;

  const norm = s => (s||'').trim().replace(/\u2212/g,'-').replace(',','.');

  /* ========== 1) COMPLETUDE (pour afficher les V sur vides l√©gitimes) ========== */
  const wantX = [R.xmin+1, ...extrema.map(e=>e.x), R.xmax-1].map(String);

  const xInputs = [...host.querySelectorAll('input.xcell')];
  const allXFilled = xInputs.every(inp => norm(inp.value)!=='');
  const allDirFilled = [...host.querySelectorAll('select.dir')].every(sel => !!sel.value);

  // pour chaque extr√©mum i, au moins une des deux cases est remplie
  const allYFilledByExt = extrema.every((_,i)=>{
    const ya = norm(host.querySelector(`input.ymax[data-i="${i}"]`)?.value);
    const yi = norm(host.querySelector(`input.ymin[data-i="${i}"]`)?.value);
    return (ya!=='' || yi!=='');
  });

  const tableComplete = allXFilled && allDirFilled && allYFilledByExt;

  /* ========== 2) LIGNE x : v√©rification de la valeur attendue ========== */
  xInputs.forEach((inp,idx)=>{
    const v = norm(inp.value); if(!v) return;  // non rempli ‚Üí non compt√©
    tot++;
    const good = (v === wantX[idx]);
    setTick(inp, good?'ok':'ko'); if(good) ok++;
  });

  /* ========== 3) FL√àCHES : sens entre colonnes (n+1 fl√®ches) ========== */
  const Ys=[knots[0].y, ...extrema.map(e=>e.y), knots[knots.length-1].y];
  const DIR=[]; for(let i=0;i<=n;i++) DIR.push(Ys[i+1] > Ys[i] ? '‚Üó' : '‚Üò');

  host.querySelectorAll('select.dir').forEach(sel=>{
    if(!sel.value) return;
    tot++;
    const i=+sel.dataset.i, good=(sel.value===DIR[i]);
    setTick(sel, good?'ok':'ko'); if(good) ok++;
  });

  /* ========== 4) LIGNE f : valeurs d‚Äôextr√©mum ========== */
  for(let i=0;i<n;i++){
    const want  = String(extrema[i].y);
    const isMax = (extrema[i].type==='max');

    const ymax = host.querySelector(`input.ymax[data-i="${i}"]`);
    const ymin = host.querySelector(`input.ymin[data-i="${i}"]`);
    const vy   = norm(ymax?.value);
    const vi   = norm(ymin?.value);

    if(isMax){
      if(vy!==''){ tot++; const good=(vy===want); setTick(ymax, good?'ok':'ko'); if(good) ok++; }
      else if(tableComplete){ setTick(ymax,'ko'); } // vide mais requis ‚Üí X quand complet
      // ligne MIN doit rester vide
      if(vi!==''){ tot++; setTick(ymin,'ko'); }
      else if(tableComplete){ setTick(ymin,'ok'); } // vide l√©gitime ‚Üí V
    }else{ // minimum
      if(vi!==''){ tot++; const good=(vi===want); setTick(ymin, good?'ok':'ko'); if(good) ok++; }
      else if(tableComplete){ setTick(ymin,'ko'); }
      if(vy!==''){ tot++; setTick(ymax,'ko'); }
      else if(tableComplete){ setTick(ymax,'ok'); }
    }
  }

/* ========== 5) BORNES (x_min, x_max) : OBLIGATOIRE ========== */

// helper pour une borne
function checkBoundary(side){ // 'left' -> x_min, 'right' -> x_max
  const idx = (side==='left') ? '-1' : '-2';
  const yVal = (side==='left') ? Ys[0] : Ys[Ys.length-1];
  const dir  = (side==='left') ? DIR[0] : DIR[n];

  // r√®gle d‚Äôemplacement : √† gauche ‚Üó -> bas ; ‚Üò -> haut. √Ä droite ‚Üó -> haut ; ‚Üò -> bas.
  const shouldTop = (side==='left') ? (dir==='‚Üò') : (dir==='‚Üó');

  const ymax = host.querySelector(`input.ymax[data-i="${idx}"]`);
  const ymin = host.querySelector(`input.ymin[data-i="${idx}"]`);
  const vy = norm(ymax?.value), vi = norm(ymin?.value);

  const filled = (vy!=='' || vi!=='');
  if(!filled){
    // obligatoire ‚Üí si tableau complet, X sur les deux, sinon on attend
    if(tableComplete){
      setTick(ymax,'ko'); setTick(ymin,'ko');
      tot+=2; // on compte les deux manquants
    }
    return;
  }

  // bonne ligne + bonne valeur
  const topOK = (vy!=='' && vy===String(yVal) && shouldTop    && vi===''); // l‚Äôautre doit √™tre vide
  const botOK = (vi!=='' && vi===String(yVal) && !shouldTop   && vy==='');

  tot++; // on compte une v√©rif globale pour la borne
  if(topOK){ setTick(ymax,'ok'); setTick(ymin,'ok'); ok++; return; }
  if(botOK){ setTick(ymax,'ok'); setTick(ymin,'ok'); ok++; return; }

  // sinon, marquer pr√©cis√©ment ce qui est faux
  if(vy!=='') setTick(ymax, (vy===String(yVal) && shouldTop)? 'ok' : 'ko');
  else if(tableComplete) setTick(ymax, shouldTop ? 'ko':'ok'); // si vide mais on attendait en haut ‚Üí X

  if(vi!=='') setTick(ymin, (vi===String(yVal) && !shouldTop)? 'ok' : 'ko');
  else if(tableComplete) setTick(ymin, !shouldTop ? 'ko':'ok');
}
checkBoundary('left');
checkBoundary('right');
  $('#res',host).textContent='';
  return {ok,total:tot};
}
,

// ‚Äî‚Äî‚Äî‚Äî‚Äî SOLUTION ‚Äî‚Äî‚Äî‚Äî‚Äî
solution(host, st){
  const { R, extrema, knots, n } = st;

  // Abscisses et images
  const Xs = [R.xmin+1, ...extrema.map(e=>e.x), R.xmax-1];
  const Ys = [knots[0].y, ...extrema.map(e=>e.y), knots[knots.length-1].y];

  // Sens ‚Üó/‚Üò entre colonnes
  const DIR = []; for(let i=0;i<=n;i++) DIR.push(Ys[i+1] > Ys[i] ? '‚Üó' : '‚Üò');

  // Ligne x : x_min, (vide), x1, (vide), ‚Ä¶, x_max
  const rowX = ['<tr><th>\\(x\\)</th>'];
  Xs.forEach((x,j)=>{
    rowX.push(`<td>\\(${x}\\)</td>`);
    if (j < Xs.length-1) rowX.push('<td></td>');
  });
  rowX.push('</tr>');

  // Bloc valeurs √† 2 niveaux (haut = MAX, bas = MIN)
  const valBlock = (kind, i, y)=>{
    let up='&nbsp;', dn='&nbsp;';
    if(kind==='ext'){                         // extr√©mum interne i
      if(extrema[i].type==='max') up = `\\(${y}\\)`; else dn = `\\(${y}\\)`;
    }else if(kind==='left'){                  // x_min : selon premi√®re fl√®che
      if (DIR[0]==='‚Üó') dn = `\\(${y}\\)`; else up = `\\(${y}\\)`;
    }else if(kind==='right'){                 // x_max : selon derni√®re fl√®che
      if (DIR[n]==='‚Üó') up = `\\(${y}\\)`; else dn = `\\(${y}\\)`;
    }
    return `<td>
      <div style="text-align:center">${up}</div>
      <div style="height:6px"></div>
      <div style="text-align:center">${dn}</div>
    </td>`;
  };

  // Ligne f : bloc(xmin), fl√®che0, bloc(ext0), fl√®che1, ‚Ä¶, fl√®che n, bloc(xmax)
  const rowF = ['<tr><th>\\(f\\)</th>'];
  rowF.push( valBlock('left', -1, Ys[0]) );
  for(let i=0;i<n;i++){
    rowF.push(`<td>${DIR[i]}</td>`);
    rowF.push( valBlock('ext', i, Ys[i+1]) );
  }
  rowF.push(`<td>${DIR[n]}</td>`);
  rowF.push( valBlock('right', -2, Ys[Ys.length-1]) );
  rowF.push('</tr>');

  const html = `
    <div class="var-wrap">
      <table class="pdf-tbl">
        <thead>${rowX.join('')}</thead>
        <tbody>${rowF.join('')}</tbody>
      </table>
    </div>`;

  $('#res',host).innerHTML = `<div class="step"><b>Tableau compl√©t√© :</b> ${html}</div>`;
  typesetAll(host);
}
,


  reset(host){ $('#res',host).textContent=''; }
};







const ex2 = {
  id:'table_to_points_curve',
  title:'Tableau de variations ‚Üí points ‚Üí courbe lisse',
gen(){
  const n = pickExtremaCountWeighted();
  const {knots, extrema, R} = makeSmoothCurveKnots(n);
  const xs = [R.xmin + 1, ...extrema.map(e=>e.x), R.xmax - 1];  // bornes ‚Äúutiles‚Äù (les n≈ìuds)
  const ys = [knots[0].y,  ...extrema.map(e=>e.y), knots[knots.length-1].y];
  return { n, R, extrema, xs, ys };
}
,


  render(host, st){
  const { n, R, extrema, xs, ys } = st;

  host.innerHTML = `
    <div>√Ä partir du <b>tableau de variations compl√©t√©</b> ci-dessous, place sur le rep√®re les points \\((x_i, f(x_i))\\).
    Quand tous les points sont correctement plac√©s, une courbe lisse s‚Äôaffiche automatiquement.</div>
    <div class="graph" style="display:flex;justify-content:center;margin:.4rem 0"></div>
    <div id="tbl"></div>
    <div class="steps small" id="res"></div>
  `;

    // ‚Äî‚Äî‚Äî Rep√®re interactif ‚Äî‚Äî‚Äî
  const rep = buildRepereSVG({ xmin:R.xmin, xmax:R.xmax, ymin:R.ymin, ymax:R.ymax, grid:true, arrows:true });
  const layerPts = document.createElementNS(rep.svg.namespaceURI,'g');
  rep.plot.appendChild(layerPts);
  host.querySelector('.graph').appendChild(rep.svg);

  const targets = xs.map((x,i)=>({ x, y: ys[i] }));
  const placed = [];

  function persist(){
    host.dataset.points = JSON.stringify({targets, placed});
  }

  function redraw(){
    while(layerPts.firstChild) layerPts.removeChild(layerPts.firstChild);
    placed.forEach(p=>{
      const c=document.createElementNS(rep.svg.namespaceURI,'circle');
      c.setAttribute('cx', rep.X(p.x)); c.setAttribute('cy', rep.Y(p.y));
      c.setAttribute('r', 4.2); c.setAttribute('fill', '#111');
      layerPts.appendChild(c);
    });
  }

  function svgPointFromClient(evt){
    const pt = rep.svg.createSVGPoint();
    pt.x = (evt.touches? evt.touches[0].clientX : evt.clientX);
    pt.y = (evt.touches? evt.touches[0].clientY : evt.clientY);
    return pt.matrixTransform(rep.svg.getScreenCTM().inverse());
  }

  function snapToGridUnits(svgPt){
    const x = Math.round(rep.Xi(svgPt.x));
    const y = Math.round(rep.Yi(svgPt.y));
    return {x,y};
  }

  function togglePoint(p){
    if(p.x<R.xmin || p.x>R.xmax || p.y<R.ymin || p.y>R.ymax) return;
    const k = placed.findIndex(q=>q.x===p.x && q.y===p.y);
    if(k>=0) placed.splice(k,1); else placed.push(p);
    redraw(); persist();
  }

const self = this; // pour appeler drawSmoothThrough depuis le handler

function allPointsPlaced() {
  const needed = xs.map((x,i)=>({x, y:ys[i]}));
  const TOL = 0.2;
  return needed.every(w =>
    placed.some(p => Math.abs(p.x - w.x) <= TOL && Math.abs(p.y - w.y) <= TOL)
  );
}

const handleClick = (e)=>{
  e.preventDefault();
  togglePoint( snapToGridUnits( svgPointFromClient(e) ) );

  // ‚ö° affichage auto de la courbe quand tout est bon
  if (!st._curveShown && allPointsPlaced()) {
    const pts = xs.map((x,i)=>({x, y:ys[i]}));
    self.drawSmoothThrough(st, pts);
    st._curveShown = true;
    $('#res',host).textContent = 'Tous les points sont correctement plac√©s : courbe affich√©e.';
  }
};
  rep.hit.addEventListener('click', handleClick);
  rep.hit.addEventListener('touchstart', handleClick, {passive:false});

  redraw();
  persist();

  // expose pour solution()
  st._rep = rep; st._layerPts = layerPts;


  /* ‚Äî‚Äî‚Äî Tableau de variations PR√â-REMPLI (aucune saisie) ‚Äî‚Äî‚Äî */
  const DIR=[]; for(let i=0;i<=n;i++) DIR.push(ys[i+1] > ys[i] ? '‚Üó' : '‚Üò');

  const rowX = ['<tr><th>\\(x\\)</th>'];
  xs.forEach((x,j)=>{ rowX.push(`<td>\\(${String(x).replace('-','‚àí')}\\)</td>`); if(j<xs.length-1) rowX.push('<td></td>'); });
  rowX.push('</tr>');

  const ruleAt = side => (side==='left' ? (DIR[0]==='‚Üò'?'top':'bot')
                                         : (DIR[n]==='‚Üó'?'top':'bot'));
  const valBlock=(where,i,y)=>{
    let up='&nbsp;', dn='&nbsp;';
    if(where==='left'){ (ruleAt('left')==='top' ? (up=`\\(${y}\\)`) : (dn=`\\(${y}\\)`)); }
    else if(where==='right'){ (ruleAt('right')==='top' ? (up=`\\(${y}\\)`) : (dn=`\\(${y}\\)`)); }
    else{ (st.extrema[i].type==='max' ? (up=`\\(${y}\\)`) : (dn=`\\(${y}\\)`)); }
    return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`;
  };

  const rowF=['<tr><th>\\(f\\)</th>'];
  rowF.push(valBlock('left',-1,ys[0]));
  for(let i=0;i<n;i++){
    rowF.push(`<td>${DIR[i]}</td>`);
    rowF.push(valBlock('ext',i,ys[i+1]));
  }
  rowF.push(`<td>${DIR[n]}</td>`);
  rowF.push(valBlock('right',-2,ys[ys.length-1]));
  rowF.push('</tr>');

  $('#tbl',host).innerHTML = `
    <div class="var-wrap">
      <table class="pdf-tbl">
        <thead>${rowX.join('')}</thead>
        <tbody>${rowF.join('')}</tbody>
      </table>
    </div>
  `;
  typesetAll(host);

  // √©tat pour la correction
  host.dataset.points = JSON.stringify({targets, placed});
  st._rep = rep; st._layerPts = layerPts;
},


  correct(host, st){
  const { xs, ys } = st;
  const state = JSON.parse(host.dataset.points||'{}');
  const placed = state.placed || [];
  const needed = xs.map((x,i)=>({x, y:ys[i]}));

  const TOL = 0.2;
  let ok = 0, tot = needed.length;

  needed.forEach(w=>{
    const hit = placed.some(p=> Math.abs(p.x-w.x)<=TOL && Math.abs(p.y-w.y)<=TOL );
    if(hit) ok++;
  });

  if (ok === tot && !st._curveShown) {
    const pts = xs.map((x,i)=>({x, y:ys[i]}));
    this.drawSmoothThrough(st, pts);
    st._curveShown = true;
    $('#res',host).textContent='Tous les points sont correctement plac√©s : courbe affich√©e.';
  } else if (ok !== tot) {
    $('#res',host).textContent = '';
  }

  // ‚¨áÔ∏è  TICK apr√®s clic sur V√©rifier (‚úì si tout est bon, ‚úó sinon)
  const resEl = $('#res',host);
  setTick(resEl, ok===tot ? 'ok' : 'ko');

  return { ok, total: tot };
},


  // Dessin d‚Äôune courbe lisse passant par les points (pentes nulles aux extr√©mums)
  drawSmoothThrough(st, pts){
    const rep = st._rep;
    if(!rep) return;
    // on cr√©e les "knots" : pente 0 aux extr√©mums uniquement (entre xmin et xmax)
    const K=[];
    for(let i=0;i<pts.length;i++){
      const x=pts[i].x, y=pts[i].y;
      // extr√©mum ssi x correspond √† un des x_i internes g√©n√©r√©s
      const kExt = st.extrema.findIndex(e=>e.x===x);
      const m = (kExt>=0 ? 0 : undefined); // pente nulle si extr√©mum, sinon calcul√©e apr√®s
      K.push({x,y,m});
    }
    // approx pente sur les non-extr√©mums (finies diff√©rences)
    for(let i=0;i<K.length;i++){
      if(K[i].m===0) continue;
      const prev=K[Math.max(0,i-1)], next=K[Math.min(K.length-1,i+1)];
      const dx=(next.x - prev.x)||1;
      K[i].m = (next.y - prev.y)/dx * 0.9; // lissage doux
    }
    const d = pathFromKnots(rep, K);
    addPath(rep.plot, d, {stroke:'#000','stroke-width':2.6});
  },

solution(host, st){
  const { R, xs, ys } = st;

  const steps = $('.steps', host);
  if (!steps) return;

  // Nettoyer le bloc correction
  steps.innerHTML = '';

  const title = document.createElement('div');
  title.textContent = 'Courbe corrig√©e :';
  title.style.fontWeight = '600';
  title.style.margin = '0 0 6px';
  steps.appendChild(title);

  const box = document.createElement('div');
  box.className = 'corr-graph';
  box.style.display = 'inline-block';
  box.style.background = '#fff';
  box.style.border = '1px solid #e6e6e6';
  box.style.borderRadius = '10px';
  box.style.padding = '8px';
  steps.appendChild(box);

  // --- Rep√®re d√©di√© ---
  const repSol = buildRepereSVG({
    xmin:R.xmin, xmax:R.xmax, ymin:R.ymin, ymax:R.ymax,
    grid:true, arrows:true
  });
// apr√®s: const repSol = buildRepereSVG({ ... });
repSol.svg.setAttribute('width',  564);   // ‚âà W calcul√© (ajuste si besoin)
repSol.svg.setAttribute('height', 336);   // ‚âà H calcul√©
  // ‚ö†Ô∏è ADAPTE selon ce que renvoie ta fonction :
  // si c‚Äôest un objet {svg, plot}
  const svg = repSol.svg || repSol;
  const plot = repSol.plot || svg;

  box.appendChild(svg);

  // --- Points attendus ---
  const svgNS = svg.namespaceURI;
  const layer = document.createElementNS(svgNS, 'g');
  plot.appendChild(layer);

  const pts = xs.map((x,i)=>({x, y:ys[i]}));
  pts.forEach(p=>{
    const c = document.createElementNS(svgNS,'circle');
    c.setAttribute('cx', repSol.X(p.x));
    c.setAttribute('cy', repSol.Y(p.y));
    c.setAttribute('r', 4.2);
    c.setAttribute('fill', '#111');
    layer.appendChild(c);
  });

  // --- Courbe lisse ---
  const prevRep = st._rep;
  st._rep = repSol;
  this.drawSmoothThrough(st, pts);
  st._rep = prevRep;


}
,

// ‚Äî‚Äî‚Äî Exo 2 : remplacer la fonction reset ‚Äî‚Äî‚Äî
reset(host){
  // 1) vider le message et remettre le tick neutre
  const resEl = $('#res', host);
  if (resEl) {
    resEl.textContent = '';
    ensureTickAfter(resEl).className = 'tick nu';
  }

  // 2) supprimer les points et la/les courbe(s) du <plot>
  const svg = $('.graph svg.repere', host);
  if (svg) {
    const plot = svg.querySelector('g.plot');
    if (plot) {
      // enl√®ve tous les cercles (points) et chemins (courbes) ajout√©s
      plot.querySelectorAll('circle').forEach(n => n.remove());
      plot.querySelectorAll('path').forEach(n => n.remove());
    }
  }

  // 3) vider l‚Äô√©tat "placed" mais conserver les cibles (targets)
  try {
    const S = JSON.parse(host.dataset.points || '{}');
    if (S && Array.isArray(S.targets)) {
      S.placed = [];                            // on efface uniquement les points pos√©s
      host.dataset.points = JSON.stringify(S);  // on persiste
    }
  } catch(_) {}
}
};




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì √âtude de fonctions ‚Ä¢ Sens de variations',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
