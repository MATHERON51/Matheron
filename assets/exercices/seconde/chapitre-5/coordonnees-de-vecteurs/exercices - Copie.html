<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Vecteurs - Coordonnées</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}

/* Bloc solution (UI) */
#res.steps{
  background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;
}
#res.steps p{margin:.25rem 0}

.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }


/* Parenthèses larges et "stretchy" autour des deux inputs */
/* Input colonne compact avec grandes parenthèses */
.colvec{
  /* Réglages rapides */
  --parenW: 10px;   /* largeur parenthèse */
  --padX:   6px;    /* marge interne gauche/droite */
  --gap:    4px;    /* écart entre les deux inputs */
  --inW:    54px;   /* largeur d’un input */
  --inPx:   6px;    /* padding horizontal input */
  --inPy:   4px;    /* padding vertical input */
  --inFs:   14px;   /* font-size input */

  position: relative;
  display: inline-grid;
  grid-template-rows: auto auto;
  row-gap: var(--gap);
  padding: 6px calc(var(--padX) + var(--parenW));
  vertical-align: middle;
}
.colvec input{
  width: var(--inW);
  text-align: center;
  padding: var(--inPy) var(--inPx);
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: var(--inFs);
}

/* Parenthèses stretch */
.colvec::before,
.colvec::after{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  width: var(--parenW);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: .95;
}
.colvec::before{
  left: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}
.colvec::after{
  right: 0; transform: scaleX(-1);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}

/* Tailles prêtes à l’emploi */
.colvec.sm { --parenW: 9px;  --padX: 6px; --gap: 4px; --inW: 48px; --inPy: 3px; --inFs: 13px; }
.colvec.xs { --parenW: 8px;  --padX: 5px; --gap: 3px; --inW: 42px; --inPy: 2px; --inFs: 12px; }




/* (facultatif) un peu plus épais sur écran Retina/print */
@media (min-resolution: 2dppx){
  .colvec::before, .colvec::after{
    filter: saturate(1.1);
  }
}

/* Grille 3 colonnes pour les vecteurs à placer (partie 3) */
.grid3 {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px 12px;           /* espace lignes/colonnes */
  align-items: start;
}
.grid3 .chipwrap { width: 100%; }

/* ---- Blocs sous le repère : 2 lignes × 5 colonnes ---- */
.flat12-wrap{ margin-top:10px; }

.sec{ margin:10px 0; }
.sec .title{ font-weight:700; font-size:1.05rem; margin-bottom:6px; }

/* une grille de 5 colonnes */
.grid5{
  display:grid;
  grid-template-columns: repeat(5, max-content);
  gap:8px 14px;
  align-items:center;
}

/* cellules : libellé + vecteur-colonne + tick */
.grid5 .inlinecell{ display:flex; align-items:center; gap:6px; }

/* vecteurs en colonne compacts pour tenir à 5×2 */
.grid5 .colvec{
  --parenW:8px; --padX:5px; --gap:3px;
  --inW:44px; --inPy:2px; --inFs:12.5px;
}

.hidden{ display:none; }




</style>

<!-- MathJax CHTML écran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Vecteurs - Coordonnées</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d’exercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
      <button id="btn-check" class="btn">✅ Vérifier</button>
      <button id="btn-solution" class="btn">💡 Solution</button>
      <button id="btn-reset" class="btn">🧹 Réinitialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>
  <div class="controls card" id="ampbar">
      <strong>Amplitude du repère (max ±12) :</strong>
      <span>x ∈ [</span><input id="xmin" type="number" value="-6" min="-12" max="12" step="1"><span>;</span>
      <input id="xmax" type="number" value="6"  min="-12" max="12" step="1"><span>],</span>
      <span>y ∈ [</span><input id="ymin" type="number" value="-6" min="-12" max="12" step="1"><span>;</span>
      <input id="ymax" type="number" value="6"  min="-12" max="12" step="1"><span>]</span>
      
      <strong style="margin-left:16px">Nombre d’objets :</strong>
      <input id="nbPts" type="number" value="3" min="3" max="10" step="1" style="width:80px">
      <label class="small"><input id="nbPts-random" type="checkbox"> Nombre aléatoire (par énoncé)</label>
    </div>
    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; réponses acceptées :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Coordonnées au format <code>u;v</code> (ex. <code>6;1</code> ou <code>3/2; -5</code>). Virgule décimale « , » ou point « . » acceptés.</li>
        <li>Jamais de parenthèses : on tape <code>6;1</code> (les parenthèses sont affichées automatiquement).</li>
        <li>Fractions conservées dans les corrections.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Mini helpers génériques ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
const HOST = $('#host');
function retypeset(host){ if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; }

/* ====== Rationnels “propres” (pour jolies fractions dans les corrections) ====== */
function R(p,q=1){ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function addR(x,y){ return R(x.p*y.q + y.p*x.q, x.q*y.q); }
function subR(x,y){ return R(x.p*y.q - y.p*x.q, x.q*y.q); }
function mulR(x,y){ return R(x.p*y.p, x.q*y.q); }
function negR(x){ return R(-x.p, x.q); }
function numR(x){ return x.p/x.q; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'−':''; const P=Math.abs(r.p); return s+'\\dfrac{'+P+'}{'+r.q+'}'; }
function textR(r){ return r.q===1 ? String(r.p) : `${r.p}/${r.q}`; }
// Retourne -\dfrac{|p|}{q} si p<0, sinon \dfrac{p}{q}; et un entier si q=1
function latexR_leadingMinus(r){
  const p = r.p, q = r.q;
  if (q === 1) return String(p);              // pas de /1 affiché dans ton flux final
  if (p < 0) return `-\\dfrac{${Math.abs(p)}}{${q}}`;
  return `\\dfrac{${p}}{${q}}`;
}


/* ===== MathJax helper ===== */
function MJ(el){
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}


/* ====== Affichages “coordonnées” ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages “coordonnées” — règles de parenthèses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenthèses autour d'un négatif
const nPlain = n => String(n);

// nombre entre parenthèses UNIQUEMENT s'il suit un "−" dans une différence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenthèses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifiée (pour l'étape -- → +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des négatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// ✅ Vecteur en COLONNE (définitif — laisse celui-ci et SUPPRIME toute redéfinition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\\\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }

// Retourne les étapes LaTeX pour p/q : d'abord p/q, puis (optionnel) la forme réduite.
function fracStepsLatex(p,q){
  const g0 = gcd(Math.abs(p), Math.abs(q));
  const first = `\\dfrac{${p}}{${q}}`;
  if (g0>1){
    const pr = p/g0, qr = q/g0;
    return [first, `\\dfrac{${pr}}{${qr}}`]; // étape "réduction"
  }
  return [first]; // déjà irréductible → une seule ligne
}

/* === Helpers de comparaison (signes & doublons) ========================== */
// Normalise les signes dans les fractions pour comparer :
//  \dfrac{-a}{b}  →  -\dfrac{a}{b}
// enlève espaces superflus et normalise le "−" unicode en "-"
function normalizeFracSign(s){
  return String(s)
    .replace(/\u2212/g, '-') // unicode minus → "-"
    .replace(/\\dfrac\{\s*-\s*([^}]+)\}\{\s*([^}]+)\}/g, '-\\dfrac{$1}{$2}')
    .replace(/\(\s*-\s*\\dfrac/g, '(-\\dfrac')
    .replace(/\s+/g, ' ')
    .trim();
}
// Deux coordonnées (x;y) LaTeX sont-elles identiques modulo placement du signe ?
function sameCoordPair(x1,y1,x2,y2){
  return normalizeFracSign(x1)===normalizeFracSign(x2)
      && normalizeFracSign(y1)===normalizeFracSign(y2);
}


/* ====== UI host ====== */
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq"></div>
    <hr class="sep">
    <div class="controls">
      <label class="input">Réponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>
  `;
}

function setEqu(html){ const box=$('#equ',HOST); if(box) box.innerHTML = html; retypeset(HOST); }
function setStepsHTML(html){ $('#res',HOST).innerHTML=html; retypeset(HOST); }
function setSteps(lines){ setStepsHTML(lines.map(L=>`<p>${L}</p>`).join('')); }
function setFB(ok,msg=''){ const fb=$('#fb',HOST); fb.className = ok?'ok':'ko'; fb.textContent=(ok?'✔︎ Correct. ':'✗ Incorrect. ')+msg; }

/* ====== Parsing des réponses u;v ====== */
function normalizeMinus(s){ return String(s||'').replace(/\u2212/g,'-').trim(); }
function parseNumber(token){
  token = token.replace(',','.');
  if (/^[-+]?\d+\/\d+$/.test(token)){ const [p,q]=token.split('/').map(Number); return p/q; }
  return token===''?NaN:Number(token);
}
function parsePairUV(s){
  s = normalizeMinus(s).replace(/\s+/g,'');
  const m = s.match(/^([^;]+);([^;]+)$/);
  if(!m) return {ok:false};
  const u=parseNumber(m[1]), v=parseNumber(m[2]);
  return (isFinite(u)&&isFinite(v)) ? {ok:true,u,v} : {ok:false};
}


// fabrique un "input colonne" avec deux champs empilés
function mkColInput(idBase, placeholderU='u', placeholderV='v',cls='sm'){
  return `<span class="colvec">
    <input id="${idBase}_u" type="text" inputmode="text" placeholder="">
    <input id="${idBase}_v" type="text" inputmode="text" placeholder="">
  </span>`;
}

// lit un "input colonne"
function readColInput(idBase){
  const uEl = document.getElementById(idBase+'_u');
  const vEl = document.getElementById(idBase+'_v');
  if (!uEl || !vEl) return {ok:false};
  const u = parseNumber(normalizeMinus(uEl.value.replace(',', '.')).trim());
  const v = parseNumber(normalizeMinus(vEl.value.replace(',', '.')).trim());
  if (!isFinite(u) || !isFinite(v)) return {ok:false};
  return {ok:true, u, v};
}

// lit soit un input colonne (idBase_u/idBase_v), soit un champ texte "u;v" (idBase)
function getPairFromInputs(idBase){
  const uEl = document.getElementById(idBase+'_u');
  const vEl = document.getElementById(idBase+'_v');
  if (uEl && vEl){
    if (!uEl.value && !vEl.value) return {ok:false, empty:true};
    return readColInput(idBase);
  }
  const tEl = document.getElementById(idBase);
  if (!tEl) return {ok:false};
  if (!tEl.value) return {ok:false, empty:true};
  return parsePairUV(tEl.value);
}




/* ====== Points aléatoires (entiers), tous distincts ====== */
function samePt(P,Q){ return P.a===Q.a && P.b===Q.b; }
function allDistinctPts(list){ for(let i=0;i<list.length;i++)for(let j=i+1;j<list.length;j++) if(samePt(list[i],list[j])) return false; return true; }
function randPointNum(min,max,existing=[]){
  let P; do{ P={a:randInt(min,max), b:randInt(min,max)}; }while(existing.some(E=>samePt(E,P)));
  return P;
}



/* ===== Repère ===== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.points=[]; this.user=[]; this.vectors=[]; this.userVectors=[];
    this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const ns = 'http://www.w3.org/2000/svg';
    const s  = document.createElementNS(ns,'svg');
    s.setAttribute('class','svgbox');
    s.setAttribute('viewBox','0 0 420 420');
    s.setAttribute('preserveAspectRatio','xMidYMid meet');

    const defs = document.createElementNS(ns,'defs');
    const marker = document.createElementNS(ns,'marker');
    marker.setAttribute('id','arrow');
    marker.setAttribute('markerUnits','strokeWidth');
    marker.setAttribute('markerWidth','6');
    marker.setAttribute('markerHeight','4');
    marker.setAttribute('refX','5');
    marker.setAttribute('refY','2');
    marker.setAttribute('orient','auto');
    const arrowPath = document.createElementNS(ns,'path');
    arrowPath.setAttribute('d','M0,0 L6,2 L0,4 z');
    arrowPath.setAttribute('fill','#000');
    marker.appendChild(arrowPath); defs.appendChild(marker); s.appendChild(defs);

    this.gGrid=document.createElementNS(ns,'g'); s.appendChild(this.gGrid);
    this.gAxes=document.createElementNS(ns,'g'); s.appendChild(this.gAxes);
    this.gPts=document.createElementNS(ns,'g'); s.appendChild(this.gPts);
    this.gVec=document.createElementNS(ns,'g'); s.appendChild(this.gVec);
    this.gUser=document.createElementNS(ns,'g'); s.appendChild(this.gUser);
    this.gUserVec=document.createElementNS(ns,'g'); s.appendChild(this.gUserVec);

    const handleTap = (ev) => {
      if(!this.clickable) return;
      const r  = s.getBoundingClientRect();
      const vb = s.viewBox?.baseVal || {x:0,y:0,width:420,height:420};
      const cx = ('clientX' in ev ? ev.clientX : ev.touches?.[0]?.clientX);
      const cy = ('clientY' in ev ? ev.clientY : ev.touches?.[0]?.clientY);
      const x = (cx - r.left) * (vb.width  / r.width);
      const y = (cy - r.top)  * (vb.height / r.height);
      const c = this.screenToCoord(x,y);
      const lim = this.innerLimits();
      const xi  = Math.round(c.x), yi = Math.round(c.y);
      if (xi < lim.xmin || xi > lim.xmax || yi < lim.ymin || yi > lim.ymax) return;
      if (this.onClick) this.onClick({x:xi,y:yi});
    };
    s.addEventListener('pointerdown', (ev)=>{ if (ev.pointerType==='touch') ev.preventDefault(); handleTap(ev); }, {passive:false});
    s.addEventListener('click', handleTap, {passive:true});
    return s;
  }
  innerLimits(){ const R=this.R; return {xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; }
  basis(){
    const w=420,h=420,m=24;
    const X=this.R.xmax-this.R.xmin, Y=this.R.ymax-this.R.ymin;
    const Sx = (w-2*m)/X, Sy = (h-2*m)/Y;
    const O = { x:m - this.R.xmin*Sx, y:h-m + this.R.ymin*Sy };
    return {O,Sx,Sy,w,h,m};
  }
  coordToScreen(x,y){ const {O,Sx,Sy}=this.basis(); return {x:O.x + x*Sx, y:O.y - y*Sy}; }
  screenToCoord(px,py){ const {O,Sx,Sy}=this.basis(); return {x:(px-O.x)/Sx, y:-(py-O.y)/Sy}; }

  setPoints(arr){ this.points=arr||[]; this.redraw(); }
  setVectors(arr){ this.vectors=arr||[]; this.redraw(); }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  clearUserVectors(){ this.userVectors=[]; this.gUserVec.innerHTML=''; }

  _latexFO(html, x, y, color='#000'){
    const fo=document.createElementNS(this.el.namespaceURI,'foreignObject');
    fo.setAttribute('x', x); fo.setAttribute('y', y); fo.setAttribute('width', 110); fo.setAttribute('height', 26);
    const div=document.createElementNS('http://www.w3.org/1999/xhtml','div');
    div.style.fontSize='13px'; div.style.fontWeight='700'; div.style.color=color;
    div.innerHTML = html;
    fo.appendChild(div);
    return fo;
  }
  
    _dot(px, py, label, color = '#000'){
    const g = document.createElementNS(this.el.namespaceURI,'g');
    const c = document.createElementNS(this.el.namespaceURI,'circle');
    c.setAttribute('cx', px);
    c.setAttribute('cy', py);
    c.setAttribute('r', 4.2);
    c.setAttribute('fill', color);
    g.appendChild(c);
    if(label){
      const t = document.createElementNS(this.el.namespaceURI,'text');
      t.setAttribute('x', px + 6);
      t.setAttribute('y', py - 6);
      t.setAttribute('font-size', '13');
      t.textContent = label;
      g.appendChild(t);
    }
    return g;
  }

  redraw(){
  const R=this.R;
  this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gPts.innerHTML=''; this.gVec.innerHTML='';

  const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',x1);L.setAttribute('y1',y1);L.setAttribute('x2',x2);L.setAttribute('y2',y2);
    L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); return L; };

  // grille
  for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
  for(let t=R.ymin;t<=R.ymax;t++){ const p1=this.coordToScreen(R.xmin,t), p2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }

  // axes
  const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
  const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
  axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);

  // O, u, v
  const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
  // point O
  this.gAxes.appendChild(this._dot(O.x,O.y,'O'));
  // flèche de u : O -> (1;0)
  const uLn=document.createElementNS(this.el.namespaceURI,'line');
  uLn.setAttribute('x1',O.x); uLn.setAttribute('y1',O.y); uLn.setAttribute('x2',I.x); uLn.setAttribute('y2',I.y);
  uLn.setAttribute('stroke','#000'); uLn.setAttribute('stroke-width','2'); uLn.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(uLn);
  // flèche de v : O -> (0;1)
  const vLn=document.createElementNS(this.el.namespaceURI,'line');
  vLn.setAttribute('x1',O.x); vLn.setAttribute('y1',O.y); vLn.setAttribute('x2',J.x); vLn.setAttribute('y2',J.y);
  vLn.setAttribute('stroke','#000'); vLn.setAttribute('stroke-width','2'); vLn.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(vLn);
  // labels LaTeX
  this.gAxes.appendChild(this._latexFO('\\(\\vec u\\)', I.x+6, I.y-18));
  this.gAxes.appendChild(this._latexFO('\\(\\vec v\\)', J.x+6, J.y-18));
  

  // points fixes
  for(const p of this.points){
    const P=this.coordToScreen(p.x,p.y);
    const g=document.createElementNS(this.el.namespaceURI,'g');
    const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); c.setAttribute('r',4.2); c.setAttribute('fill',p.fill||'#000'); g.appendChild(c);
    if(p.label){ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6); t.setAttribute('font-size','13'); t.textContent=p.label; g.appendChild(t); }
    this.gPts.appendChild(g);
  }

  // vecteurs fixes
  for(const v of this.vectors){
    const p1=this.coordToScreen(v.x1,v.y1), p2=this.coordToScreen(v.x2,v.y2);
    const ln=document.createElementNS(this.el.namespaceURI,'line'); ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y); ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
    ln.setAttribute('stroke',v.stroke||'#000'); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrow)'); this.gVec.appendChild(ln);
    if(v.label){ this.gVec.appendChild(this._latexFO(`\\(\\vec v_{${v.label.replace('v','')}}\\)`, p2.x+6, p2.y-18, v.stroke||'#000')); }
  }

  // re-typeset pour les foreignObjects
  MJ(this.el.parentNode||document.body);
}


  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){ g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','13'); t.setAttribute('font-weight','700'); t.setAttribute('fill',color); t.textContent=label;
      g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g);
    }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }

  placeUserVector(label,x1,y1,x2,y2,color='#0a84ff'){
    let g=this.gUserVec.querySelector(`g[data-vlabel="${label}"]`);
    if(!g){
      g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.vlabel=label;
      const ln=document.createElementNS(this.el.namespaceURI,'line'); ln.setAttribute('stroke',color); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrow)');
      const fo=this._latexFO(`\\(\\vec v_{${label.replace('v','')}}\\)`, 0, 0, color);
      g.appendChild(ln); g.appendChild(fo); this.gUserVec.appendChild(g);
    }
    const p1=this.coordToScreen(x1,y1), p2=this.coordToScreen(x2,y2);
    const ln=g.querySelector('line'), fo=g.querySelector('foreignObject');
    ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y); ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
    if(fo){ fo.setAttribute('x', p2.x+6); fo.setAttribute('y', p2.y-18); }
    const i=this.userVectors.findIndex(v=>v.label===label);
    const rec={label,x1,y1,x2,y2}; if(i>=0) this.userVectors[i]=rec; else this.userVectors.push(rec);
    MJ(this.el.parentNode||document.body);
  }
}

/* ===== UI helpers ===== */
/* ==== Couleurs & rendu rapide du repère ==== */
const PALETTE = ['#0a84ff','#d32f2f','#2e7d32','#6a1b9a','#f57c00','#00897b','#c62828','#6d4c41','#ad1457','#283593','#0277bd'];
const colorOfIndex = i => PALETTE[i % PALETTE.length];
const vecCol = (a,b) => `\\left(\\begin{array}{c} ${a} \\\\ ${b} \\end{array}\\right)`;


// mini “view” : on place un repère à gauche et à droite l’énoncé + actions + #res
function renderWithRepereIntoHost(host, R){
  host.innerHTML = `
    <div class="row">
      <div><div id="repere-slot" class="svgbox" style="width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff"></div></div>
      <div>
        <div id="equ"></div>
        <div class="optionline" id="actions" style="margin-top:.5rem"></div>
        <div id="res" class="steps"></div>
      </div>
    </div>`;
  // Repere vient de repere_patch_0813.js (global)
  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  document.getElementById('repere-slot').replaceWith(rep.el);
  return { rep, equ: document.getElementById('equ'), actions: document.getElementById('actions'), res: document.getElementById('res') };
}


const AMP={xmin:-6,xmax:6,ymin:-6,ymax:6};
function applyAMPInputs(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  xi=clamp(isNaN(xi)?-6:xi,-12,12); xa=clamp(isNaN(xa)?6:xa,-12,12);
  yi=clamp(isNaN(yi)?-6:yi,-12,12); ya=clamp(isNaN(ya)?6:ya,-12,12);
  if(xi===xa) xa=clamp(xi+1,-12,12); if(yi===ya) ya=clamp(yi+1,-12,12);
  if(xi>xa) [xi,xa]=[xa,xi]; if(yi>ya) [yi,ya]=[ya,yi];
  Object.assign(AMP,{xmin:xi,xmax:xa,ymin:yi,ymax:ya});
  ['xmin','xmax','ymin','ymax'].forEach(id=>$('#'+id).value=AMP[id]);
}

const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

function getNbPts(){
  const nbEl = document.getElementById('nbPts');
  const rand = document.getElementById('nbPts-random')?.checked;
  const min  = parseInt(nbEl?.min  || '3', 10);
  const max  = parseInt(nbEl?.max  || '10', 10);
  let   v    = parseInt(nbEl?.value|| '3', 10);
  v = clamp(isNaN(v)?3:v, min, max);
  return rand ? randInt(min, max) : v;
}

function getNbPtsInput(){
  const nbEl = document.getElementById('nbPts');
  const min  = parseInt(nbEl?.min  || '3', 10);
  const max  = parseInt(nbEl?.max  || '10', 10);
  let   v    = parseInt(nbEl?.value|| '3', 10);
  return clamp(isNaN(v)?3:v, min, max);
}



function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// cellules 3×3 à l'intérieur des limites "lim"
function makeCells(lim, rows=3, cols=3){
  const w = (lim.xmax - lim.xmin + 1), h = (lim.ymax - lim.ymin + 1);
  const cw = Math.floor(w / cols), ch = Math.floor(h / rows);
  const cells = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0 = lim.xmin + c*cw, x1 = (c===cols-1) ? lim.xmax : (x0+cw-1);
      const y0 = lim.ymin + r*ch, y1 = (r===rows-1) ? lim.ymax : (y0+ch-1);
      cells.push({xmin:x0, xmax:x1, ymin:y0, ymax:y1});
    }
  }
  return cells;
}
function randIntInCell(cell){ return { x: randInt(cell.xmin, cell.xmax), y: randInt(cell.ymin, cell.ymax) }; }
function fits(lim, x, y){ return x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax; }


// --- Unicité de pente : clé de colinéarité (ignore l'échelle et le signe global)
function slopeKey(dx, dy){
  if (dx === 0) return 'V';     // vertical
  if (dy === 0) return 'H';     // horizontal
  // normalise le signe pour que (dx,dy) et (-dx,-dy) donnent la même clé
  if (dx < 0){ dx = -dx; dy = -dy; }
  const g0 = gcd(Math.abs(dx), Math.abs(dy)) || 1;
  const a = dx / g0, b = dy / g0; // a = dx', b = dy' primitifs
  return b + '/' + a;             // on encode la pente (dy/dx) comme "b/a"
}


// --- Unicité stricte des coordonnées (a;b) pour la partie 3
const abKey = (a,b) => a + ';' + b;


/* ===== Utilitaire PDF : forcer la taille du SVG (300×300) ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }




/* ====== Générateur d’exos ====== */
const REGISTRY_MAP = {

  /* e1 — Coordonnées du vecteur AB */
  e1:{
    name:"Coordonnées du vecteur AB",
    gen(){
      const A = randPointNum(-8,8);
      const B = randPointNum(-8,8,[A]);
      this.state={A,B};
      setEqu(`<p>On considère les points \\(A${fmtPtLaNum(A)}\\) et \\(B${fmtPtLaNum(B)}\\).</p>
              <p>Calculer les coordonnées du vecteur \\(\\vec{AB}\\).</p>`);
    },
    verify(){
      const {A,B}=this.state;
      const expect = {u:B.a-A.a, v:B.b-A.b};
      const ans = parsePairUV($('#ans',HOST).value);
      const ok = ans.ok && Math.abs(ans.u-expect.u)<1e-9 && Math.abs(ans.v-expect.v)<1e-9;
      setFB(ok, ok?``:`Attendu : \\(\\vec{AB}${fmtVecLaNum(expect.u,expect.v)}\\).`);
      return ok;
    },
solution(){
  const {A,B}=this.state;
  const ux=B.a-A.a, vy=B.b-A.b;

  // Substitutions avec parenthèses UNIQUEMENT si le terme suit un "−"
  const sxSub = minusExpr(B.a, A.a); // "x_B - x_A"
  const sySub = minusExpr(B.b, A.b); // "y_B - y_A"

  // Lignes
  const L = [
    `\\(\\vec{AB}${colVecExpr('x_B-x_A','y_B-y_A')}\\)`,
    `\\(\\vec{AB}${colVecExpr(sxSub, sySub)}\\)`
  ];

  // Étape "-- → +" uniquement si A.a<0 ou A.b<0
  if (A.a < 0 || A.b < 0){
    const sxFix = minusExprSimplified(B.a, A.a);
    const syFix = minusExprSimplified(B.b, A.b);
    L.push(`\\(\\vec{AB}${colVecExpr(sxFix, syFix)}\\)`);
  }

  L.push(`\\(\\vec{AB}${fmtVecLaNum(ux,vy)}\\)`); // résultat en colonne
  setSteps(L);
}


  },

  /* e2 — Nature du quadrilatère ABCD (parallélogramme) */
  e2:{
    name:"Nature du quadrilatère \\(ABCD\\)",
    gen(){
      const A = randPointNum(-6,6);
      const B = randPointNum(-6,6,[A]);
      const C = randPointNum(-6,6,[A,B]);
      const D = {a: A.a + (C.a-B.a), b: A.b + (C.b-B.b)}; // pour forcer AB=DC
      if(!allDistinctPts([A,B,C,D])) return this.gen();
      this.state={A,B,C,D};
      setEqu(`<p>On considère \\(A${fmtPtLaNum(A)}\\), \\(B${fmtPtLaNum(B)}\\), \\(C${fmtPtLaNum(C)}\\) et \\(D${fmtPtLaNum(D)}\\).</p>
              <p>Quelle est la nature de \\(ABCD\\) ?</p>`);
    },
    verify(){
      const rep = ($('#ans',HOST).value||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      const ok = /parallelogramme/.test(rep);
      setFB(ok, ok?``:`Répondre « parallélogramme ».`);
      return ok;
    },
solution(){
   const {A,B,C,D}=this.state;

  const ABu=B.a-A.a, ABv=B.b-A.b;
  const DCu=C.a-D.a, DCv=C.b-D.b;

  const AB_sub = colVecExpr(minusExpr(B.a,A.a), minusExpr(B.b,A.b));
  const DC_sub = colVecExpr(minusExpr(C.a,D.a), minusExpr(C.b,D.b));

  const left = [
    `\\(\\vec{AB}${colVecExpr('x_B-x_A','y_B-y_A')}\\)`,
    `\\(\\vec{AB}${AB_sub}\\)`
  ];
  if (A.a<0 || A.b<0){
    left.push(`\\(\\vec{AB}${colVecExpr(minusExprSimplified(B.a,A.a), minusExprSimplified(B.b,A.b))}\\)`);
  }
  left.push(`\\(\\vec{AB}${fmtVecLaNum(ABu,ABv)}\\)`);

  const right = [
    `\\(\\vec{DC}${colVecExpr('x_C-x_D','y_C-y_D')}\\)`,
    `\\(\\vec{DC}${DC_sub}\\)`
  ];
  if (D.a<0 || D.b<0){
    right.push(`\\(\\vec{DC}${colVecExpr(minusExprSimplified(C.a,D.a), minusExprSimplified(C.b,D.b))}\\)`);
  }
  right.push(`\\(\\vec{DC}${fmtVecLaNum(DCu,DCv)}\\)`);

  setStepsHTML(
    `<table style="border-collapse:collapse;width:100%;">
      <tr>
        <td style="border:none;vertical-align:top;padding:6px;">${left.map(L=>`<p>${L}</p>`).join('')}</td>
        <td style="border:none;vertical-align:top;padding:6px;">${right.map(L=>`<p>${L}</p>`).join('')}</td>
      </tr>
    </table>
    <p>Ainsi \\(\\vec{AB}=\\vec{DC}\\), donc \\(ABCD\\) est un <strong>parallélogramme</strong>.</p>`
  );

}

  },

 e3:{
  name: "Placer des vecteurs d’après leurs coordonnées (origines données)",
  lead: "Clique sur l’extrémité de chaque vecteur demandé.",
  gen(){
    const R={...AMP};
    const n=Math.max(2,Math.min(6,getNbPts()));
    const lim={ xmin:R.xmin+1, xmax:R.xmax-1, ymin:R.ymin+1, ymax:R.ymax-1 };

    const ORI=[], V=[], used=new Set();
    function uniqPoint(){
      let x,y,k,tries=0;
      do{ x=randInt(lim.xmin,lim.xmax); y=randInt(lim.ymin,lim.ymax); k=x+';'+y; }
      while(used.has(k) && ++tries<1000);
      used.add(k); return {x,y};
    }
    let count=0, safety=0;
    while(count<n && ++safety<5000){
      const p=uniqPoint(); let a=0,b=0,guard=0;
      do{ a=randInt(-5,5); b=randInt(-5,5); } while((a===0 && b===0) && ++guard<500);
      const x2=p.x+a, y2=p.y+b;
      if(x2<lim.xmin || x2>lim.xmax || y2<lim.ymin || y2>lim.ymax) continue;
      ORI.push(p); V.push({a,b}); count++;
    }
    const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0,n).split('');
    const ORIColor = ORI.map((p,i)=>({label:labels[i],...p,color:colorOfIndex(i)}));
    this.state = { R, ORI: ORIColor, V, _currentId:'v1' };

    // rendu
    const ui = renderWithRepereIntoHost(HOST, R);
    ui.rep.setPoints(ORIColor.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.color})));
    ui.rep.setVectors([]); ui.rep.clearUserVectors();

    ui.equ.innerHTML = `<p>Tracer, depuis l’origine indiquée, les vecteurs suivants :</p>
      <ol style="margin:6px 0 0 20px">
        ${V.map((v,i)=>`<li>Depuis \\(${labels[i]}\\), tracer \\(\\vec v_${i+1}\\)\\(${vecCol(v.a,v.b)}\\).</li>`).join('')}
      </ol>`;
    retypeset(HOST);

    // sélecteur + ticks
    const chips=document.createElement('div');
    chips.className='chips';
    chips.innerHTML='<span>Vecteur courant :</span>';
    V.forEach((_,i)=>{
      const id='v'+(i+1);
      const wrap=document.createElement('div'); wrap.className='chipwrap';
      const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=id;
      sp.innerHTML = `<span class="dot" style="background:${colorOfIndex(i)}"></span> \\(\\vec v_${i+1}\\)`;
      const tk=document.createElement('span'); tk.className='tick'; tk.id='tk_'+id; tk.style.color=colorOfIndex(i);
      wrap.appendChild(sp); wrap.appendChild(tk); chips.appendChild(wrap);
      sp.addEventListener('click',()=>{
        [...chips.querySelectorAll('.chip')].forEach(c=>c.classList.toggle('active',c===sp));
        this.state._currentId = id;
      });
    });
    ui.actions.appendChild(chips); retypeset(HOST);
    // sélection par défaut
    const firstChip = chips.querySelector('.chip');
    if (firstChip) firstChip.classList.add('active');

    // interaction repère
    ui.rep.clickable=true;
    ui.rep.onClick = ({x,y})=>{
      const k = (this.state._currentId||'v1').match(/\d+$/);
      const idx = k ? (+k[0]-1) : 0;
      const o = this.state.ORI[idx];
      if (!o) return;
      ui.rep.placeUserVector(this.state._currentId, o.x,o.y, x,y, colorOfIndex(idx));
    };

    this.state.ui = ui;
  },

  // ✅ Ajustements en direct
  adjustLive(kind){
    const st=this.state; if(!st||!st.ui) return;

    // 1) Amplitude : redessiner sans changer les données ni les placements
    if (!kind || kind==='amp'){
      st.R={...AMP};
      st.ui.rep.R={...AMP};
      st.ui.rep.redraw();
      st.ui.rep.setPoints(st.ORI.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.color})));
      // re-poser les vecteurs déjà placés par l'élève
      const keep = [...(st.ui.rep.userVectors||[])];
      st.ui.rep.clearUserVectors();
      keep.forEach(v=>st.ui.rep.placeUserVector(v.label,v.x1,v.y1,v.x2,v.y2,v.stroke||'#0a84ff'));
    }

    // 2) Nombre d’objets : on ajoute/retire seulement la fin
    if (!kind || kind==='n'){
      const target = getNbPtsInput();
      const cur = st.V.length;
      const lim={ xmin:AMP.xmin+1, xmax:AMP.xmax-1, ymin:AMP.ymin+1, ymax:AMP.ymax-1 };

      // Ajouter
      if (target>cur){
        const labels='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        for(let i=cur;i<target;i++){
          // nouveau point d’origine unique
          const used=new Set(st.ORI.map(p=>p.x+';'+p.y));
          const uniqPoint=()=>{
            let x,y,k,tries=0;
            do{ x=randInt(lim.xmin,lim.xmax); y=randInt(lim.ymin,lim.ymax); k=x+';'+y; }
            while(used.has(k) && ++tries<500);
            used.add(k); return {x,y};
          };
          const p=uniqPoint();
          let a=0,b=0,guard=0;
          do{ a=randInt(-5,5); b=randInt(-5,5); } while((a===0&&b===0)&&++guard<500);
          const x2=p.x+a, y2=p.y+b;
          if(x2<lim.xmin||x2>lim.xmax||y2<lim.ymin||y2>lim.ymax){ i--; continue; }

          const color=colorOfIndex(i);
          st.ORI.push({label:labels[i],x:p.x,y:p.y,color});
          st.V.push({a,b});

          // Point & puce UI
          st.ui.rep.setPoints(st.ORI.map(q=>({x:q.x,y:q.y,label:q.label,fill:q.color})));
          const chipsHost = st.ui.actions.querySelector('.chips');
          if (chipsHost){
            const id='v'+(i+1);
            const wrap=document.createElement('div'); wrap.className='chipwrap';
            const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=id;
            sp.innerHTML = `<span class="dot" style="background:${color}"></span> \\(\\vec v_${i+1}\\)`;
            const tk=document.createElement('span'); tk.className='tick'; tk.id='tk_'+id; tk.style.color=color;
            wrap.appendChild(sp); wrap.appendChild(tk); chipsHost.appendChild(wrap);
            sp.addEventListener('click',()=>{
              [...chipsHost.querySelectorAll('.chip')].forEach(c=>c.classList.toggle('active',c===sp));
              st._currentId = id;
            });
            retypeset(HOST);
          }
        }
      }

      // Retirer
      if (target<cur){
        st.ORI.splice(target);
        st.V.splice(target);

        // enlever puces en trop
        const chipsHost = st.ui.actions.querySelector('.chips');
        if (chipsHost){
          const wraps=[...chipsHost.querySelectorAll('.chipwrap')];
          for(let i=wraps.length-1;i>=target;i--) wraps[i]?.remove();
        }

        // filtrer vecteurs utilisateur
        const keepIds = new Set(Array.from({length:target},(_,i)=>'v'+(i+1)));
        const saved = (st.ui.rep.userVectors||[]).filter(v=>keepIds.has(v.label));
        st.ui.rep.clearUserVectors();
        saved.forEach(v=>st.ui.rep.placeUserVector(v.label,v.x1,v.y1,v.x2,v.y2,v.stroke||'#0a84ff'));

        // points
        st.ui.rep.setPoints(st.ORI.map(q=>({x:q.x,y:q.y,label:q.label,fill:q.color})));

        // sélection courante valide
        if (!keepIds.has(st._currentId)) st._currentId='v1';
        const chips=[...(chipsHost?.querySelectorAll('.chip')||[])];
        chips.forEach(c=>c.classList.toggle('active', c.dataset.l===st._currentId));
      }
    }
  },

  verify(){
    const {ui,V,ORI}=this.state;
    const ids = V.map((_,i)=>'v'+(i+1));
    let ok=0,tot=0;
    ids.forEach((id,i)=>{
      const u=(ui.rep.userVectors||[]).find(v=>v.label===id);
      const tk=document.getElementById('tk_'+id);
      if(!u){ if(tk){ tk.textContent=''; tk.className='tick'; } return; }
      const baseOK=(u.x1===ORI[i].x && u.y1===ORI[i].y);
      const dx=u.x2-u.x1, dy=u.y2-u.y1;
      const good=baseOK && dx===V[i].a && dy===V[i].b;
      if(tk){ tk.textContent=good?'✔':'✘'; tk.className='tick '+(good?'ok':'ko'); tk.style.color=colorOfIndex(i); }
      tot++; if(good) ok++;
    });
    setFB(ok===tot, `${ok} / ${tot}`); return ok===tot;
  },

  solution(){
    const {ui,V,ORI}=this.state;
    const vects=V.map((v,i)=>({label:'v'+(i+1), x1:ORI[i].x,y1:ORI[i].y, x2:ORI[i].x+v.a,y2:ORI[i].y+v.b, stroke:colorOfIndex(i)}));
    ui.rep.setVectors(vects);
    ui.res.innerHTML = `<div class="step">${V.map((v,i)=>`\\(\\vec v_{${i+1}}  ${vecCol(v.a,v.b)}\\)`).join(' ; ')}</div>`;
    retypeset(HOST);
  }
},


ex4:{
  name: "Lire les coordonnées de vecteurs",
  lead: "Donner les coordonnées \\((u;v)\\) de chaque vecteur tracé.",
  gen(){
    const R={...AMP};
    const n=Math.max(2,Math.min(6,getNbPts()));
    const V=[];
    const lim={xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1};
    let tries=0;
    while(V.length<n && ++tries<3000){
      let a=0,b=0,guard=0;
      do{ a=randInt(-5,5); b=randInt(-5,5); } while((a===0&&b===0)&&++guard<500);
      const x1=randInt(lim.xmin,lim.xmax), y1=randInt(lim.ymin,lim.ymax);
      const x2=x1+a, y2=y1+b;
      if(x2<lim.xmin||x2>lim.xmax||y2<lim.ymin||y2>lim.ymax) continue;
      V.push({a,b,x1,y1,x2,y2});
    }
    this.state={ R,V };

    const ui=renderWithRepereIntoHost(HOST,R);
    ui.rep.setVectors(V.map((v,i)=>({label:'v'+(i+1), x1:v.x1,y1:v.y1, x2:v.x2,y2:v.y2, stroke:colorOfIndex(i)})));
    ui.equ.innerHTML = `<p>Par lecture graphique, donner les coordonnées des vecteurs \\(\\vec v_1,\\vec v_2,\\dots\\) (format \\((u;v)\\)).</p>`;
    V.forEach((_,i)=>{
      const row=document.createElement('div');
row.innerHTML = `\\(\\vec v_{${i+1}}\\) ${mkColInput('ans_v_'+(i+1),'u','v')} <span class="tick" id="tk_v${i+1}"></span>`;
      ui.actions.appendChild(row);
    });
    retypeset(HOST);
    this.state.ui=ui;
  },

  // ✅ Ajustements en direct
  adjustLive(kind){
    const st=this.state; if(!st||!st.ui) return;

    if (!kind || kind==='amp'){
      st.R={...AMP};
      st.ui.rep.R={...AMP};
      st.ui.rep.redraw();
      st.ui.rep.setVectors(st.V.map((v,i)=>({label:'v'+(i+1), x1:v.x1,y1:v.y1, x2:v.x2,y2:v.y2, stroke:colorOfIndex(i)})));
    }

    if (!kind || kind==='n'){
      const target=getNbPtsInput();
      const cur=st.V.length;
      const lim={xmin:AMP.xmin+1,xmax:AMP.xmax-1,ymin:AMP.ymin+1,ymax:AMP.ymax-1};

      // Ajouter
      if (target>cur){
        for(let i=cur;i<target;i++){
          let a=0,b=0,guard=0;
          do{ a=randInt(-5,5); b=randInt(-5,5); } while((a===0&&b===0)&&++guard<500);
          let x1,y1,x2,y2,ok=false;
          for(let t=0;t<500 && !ok;t++){
            x1=randInt(lim.xmin,lim.xmax); y1=randInt(lim.ymin,lim.ymax);
            x2=x1+a; y2=y1+b;
            ok = (x2>=lim.xmin && x2<=lim.xmax && y2>=lim.ymin && y2<=lim.ymax);
          }
          if(!ok){ i--; continue; }
          st.V.push({a,b,x1,y1,x2,y2});
          // tracer + input
          st.ui.rep.setVectors(st.V.map((v,j)=>({label:'v'+(j+1), x1:v.x1,y1:v.y1, x2:v.x2,y2:v.y2, stroke:colorOfIndex(j)})));
          const row=document.createElement('div');
row.innerHTML = `\\(\\vec v_{${i+1}}\\) ${mkColInput('ans_v_'+(i+1),'u','v')} <span class="tick" id="tk_v${i+1}"></span>`;
          st.ui.actions.appendChild(row);
          retypeset(HOST);
        }
      }

      // Retirer
      if (target<cur){
        st.V.splice(target);
        // retirer inputs du bas
        const rows=[...st.ui.actions.children];
        for(let i=rows.length-1; i>=0; i--){
          const hasInput = /ans_v_\d+/.test(rows[i]?.innerHTML||'');
          const idx = +((rows[i]?.querySelector('input')?.id||'').match(/\d+$/)||[0])[0];
          if (hasInput && idx>st.V.length) rows[i].remove();
        }
        // re-tracer
        st.ui.rep.setVectors(st.V.map((v,i)=>({label:'v'+(i+1), x1:v.x1,y1:v.y1, x2:v.x2,y2:v.y2, stroke:colorOfIndex(i)})));
        retypeset(HOST);
      }
    }
  },

  verify(){
    const {V}=this.state;
    let ok=0,tot=0;
    for(let i=0;i<V.length;i++){

      const got = getPairFromInputs('ans_v_'+(i+1));
if (got.empty){ const t=document.getElementById('tk_v'+(i+1)); if(t){ t.textContent=''; t.className='tick'; } continue; }
const good = got.ok && (got.u===V[i].a && got.v===V[i].b);

      const tk=document.getElementById('tk_v'+(i+1));
      if(tk){ tk.textContent=good?'✔':'✘'; tk.className='tick '+(good?'ok':'ko'); tk.style.color=colorOfIndex(i); }
      tot++; if(good) ok++;
    }
    setFB(ok===tot, `${ok} / ${tot}`); return ok===tot;
  },

  solution(){
    const {ui,V}=this.state;
    ui.res.innerHTML = `<div class="step">${V.map((v,i)=>`\\(\\vec v_{${i+1}}  ${vecCol(v.a,v.b)}\\)`).join(' ; ')}</div>`;
    retypeset(HOST);
  }
},

e5:{
  name:"Mix — Lecture & tracé de vecteurs (modèle écran)",
  lead:"On se place dans un repère \\((O;\\, \\vec i,\\, \\vec j)\\).",
  gen(){
    const R={...AMP};
    const lim={ xmin:R.xmin+1, xmax:R.xmax-1, ymin:R.ymin+1, ymax:R.ymax-1 };

    // ---- Paramétrage par le sélecteur "Nombre d’objets" ----
    // L = nb de lettres visibles pour la partie 1 (par défaut 5, maxi 10)
    // nU = nb de vecteurs u_i tracés (au moins 3)
    // nC = nb de points à placer (au moins 3)
    const nb = getNbPtsInput();

const L  = Math.max(5, Math.min(10, nb));
const nU = Math.max(3, Math.min(10, nb));
const nC = Math.max(3, Math.min(10, nb));

    // ---- Lettres dispo ----
    const ALL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const letters1 = ALL.slice(0, L).split('');                // pour les points A,B,C,...
    const lettersC = ALL.slice(L, L+nC).split('');              // lettres neuves pour H,K,L,... (partie 3)

    // ---- Points pour la partie 1 (A,B,C,...) ----
// ---- Points pour la partie 1 (A,B,C,...) — répartis par cellules
const used = new Set();
const cellsPts = shuffle(makeCells(lim, 3, 3));

const P = [];
for (let i=0; i<letters1.length; i++){
  // tourne sur les cellules si on dépasse 9
  const cell = cellsPts[i % cellsPts.length];
  let p, k=0;
  do{
    const q = randIntInCell(cell);
    p = {x:q.x, y:q.y};
  } while(used.has(p.x+';'+p.y) && ++k<400);
  used.add(p.x+';'+p.y);
  P.push(p);
}
const pts = letters1.map((Ltr,i)=>({label:Ltr,x:P[i].x,y:P[i].y,fill:'#000'}));


    // ---- Partie 1 : on choisit 3 couples (ou jusqu’à toutes les combinaisons si L petit)
// ---- Partie 1 : vecteurs entre lettres totalement aléatoires (pas toujours A…)
const pairs = [];
const nbPairs = Math.max(3, Math.min(nb, letters1.length * (letters1.length - 1) / 3));

// construit un générateur d'indices sans doublons ni inversion
const tried = new Set();
while (pairs.length < nbPairs) {
  const i = randInt(0, letters1.length - 1);
  let j = randInt(0, letters1.length - 1);
  while (j === i) j = randInt(0, letters1.length - 1);

  // empêche AB et BA simultanément
  const key1 = letters1[i] + letters1[j];
  const key2 = letters1[j] + letters1[i];
  if (tried.has(key1) || tried.has(key2)) continue;

  tried.add(key1);
  pairs.push([i, j]);
}


    // ---- Partie 2 : nU vecteurs u_i tracés à lire
// ---- Partie 2 : nU vecteurs u_i tracés à lire — origines éparpillées + directions variées
// ---- Partie 2 : nU vecteurs u_i tracés à lire — origines éparpillées + directions variées


const U = [];
const cellsU = shuffle(makeCells(lim, 3, 3)); // origines réparties
const usedSlopeU = new Set();                 // <-- anti-doublon de pente

// directions de base enrichies pour avoir assez de pentes distinctes
const DIRS_BASE = shuffle([
  [1,0],[0,1],[-1,0],[0,-1],      // H/V
  [1,1],[1,2],[2,1],[1,3],[3,1],[2,3],[3,2],
  [-1,1],[1,-1],[-1,-2],[-2,-1],[-1,-3],[-3,-1],[-2,-3],[-3,-2]
]);

for (let i = 0; i < nU; i++) {
  const cell = cellsU[i % cellsU.length];
  let tries = 0, ok = false;

  while (!ok && ++tries < 1000) {
    const o = randIntInCell(cell);
    const [aa, bb] = DIRS_BASE[(i + tries) % DIRS_BASE.length];

    // direction primitive
    const g = gcd(Math.abs(aa), Math.abs(bb)) || 1;
    const dirx = aa / g, diry = bb / g;

    // longueur entière 2..5
    const len = randInt(2, 5);
    let a = dirx * len;
    let b = diry * len;

    // anti-doublon de pente (colinéarité, signe global ignoré)
    const key = slopeKey(a, b);
    if (usedSlopeU.has(key)) continue;

    // ajuste si hors cadre (symétries possibles)
    let x2 = o.x + a, y2 = o.y + b;
    if (!fits(lim, x2, y2)) { a = -a; x2 = o.x + a; }
    if (!fits(lim, x2, y2)) { b = -b; y2 = o.y + b; }
    if (!fits(lim, x2, y2)) { a = -a; x2 = o.x + a; }

    ok = fits(lim, x2, y2);
    if (ok) {
      U.push({ a, b, x1: o.x, y1: o.y, x2, y2 });
      usedSlopeU.add(key);
    }
  }

  // si la cellule ne permet pas de placer, on réessaye le même i
  if (!ok) i--;
}




    // ---- Partie 3 : nC points à placer, forme AH:(u;v) où origine=A, point à placer=H
    // origine prise parmi les lettres existantes (partie 1), lettre d’arrivée = lettre neuve (lettersC)
// ---- Partie 3 : nC points à placer (origine = parmi pts), origines espacées
// ---- Partie 3 : nC points à placer (origines espacées) + unicité (a;b) + variété
const Casks = [];
const usedAB = new Set();   // <-- empêche les doublons exacts (a;b)

// directions plus riches
const DIRS_RICH = shuffle([
  // H / V
  [1,0],[0,1],[-1,0],[0,-1],
  // pentes simples
  [1,1],[1,-1],[-1,1],[-1,-1],
  // pentes 1/2, 2/1, 1/3, 3/1, 1/4, 4/1
  [1,2],[2,1],[1,3],[3,1],[1,4],[4,1],
  [-1,2],[-2,1],[-1,3],[-3,1],[-1,4],[-4,1],
  [1,-2],[2,-1],[1,-3],[3,-1],[1,-4],[4,-1],
  [-1,-2],[-2,-1],[-1,-3],[-3,-1],[-1,-4],[-4,-1],
  // mélanges 2–3, 3–2, 2–4, 4–2
  [2,3],[3,2],[-2,3],[-3,2],[2,-3],[3,-2],[-2,-3],[-3,-2],
  [2,4],[4,2],[-2,4],[-4,2],[2,-4],[4,-2],[-2,-4],[-4,-2]
]);

for (let i=0; i<nC; i++){
  // origine espacée : on échantillonne les points visibles de la partie 1
  const step = Math.max(1, Math.ceil(letters1.length / nC));
  const originIndex = (i * step) % letters1.length;
  const origin = pts[originIndex];

  let ok = false, guard = 0, pick = null;

  while(!ok && ++guard < 1500){
    // choisit une direction « de base » puis applique une longueur 1..6
    const [aa, bb] = DIRS_RICH[(i + guard) % DIRS_RICH.length];
    const g = gcd(Math.abs(aa), Math.abs(bb)) || 1;
    const dirx = aa / g, diry = bb / g;

    const len = randInt(1, 6);         // plus de variété
    let a = dirx * len, b = diry * len;

    // évite les doublons exacts (a;b) dans la série
    if (usedAB.has(abKey(a,b))) continue;

    // essaye de garder le point d'arrivée dans la fenêtre
    let x2 = origin.x + a, y2 = origin.y + b;
    if (!fits(lim, x2, y2)) { a = -a; x2 = origin.x + a; }
    if (!fits(lim, x2, y2)) { b = -b; y2 = origin.y + b; }
    if (!fits(lim, x2, y2)) { a = -a; x2 = origin.x + a; }

    ok = fits(lim, x2, y2);
    if (ok){
      usedAB.add(abKey(a,b));
      pick = { from: origin.label, to: lettersC[i], a, b, x2, y2, ox:origin.x, oy:origin.y };
    }
  }
  if (pick) Casks.push(pick);
}



    // ---- UI et tracés initiaux ----
    const ui = renderWithRepereIntoHost(HOST, R);
    ui.rep.setPoints(pts);
    // on trace les u_i (partie 2) dès le départ
    ui.rep.setVectors(U.map((v,i)=>({label:'u'+(i+1), x1:v.x1,y1:v.y1,x2:v.x2,y2:v.y2, stroke:colorOfIndex(i)})));
    ui.rep.clearUserVectors();

    // ---- Enoncé façon capture d’écran ----
    const list1 = pairs.map(([i,j])=>`\\(\\overrightarrow{${letters1[i]}${letters1[j]}}\\)`).join(', ');
    const list2 = Array.from({length:nU},(_,i)=>`\\(\\overrightarrow{u_${i+1}}\\)`).join(', ');
// --- petit helper pour le libellé a), b), c) ...
const alpha = i => String.fromCharCode(97 + i) + '.';

// --- tableau 3 colonnes, remplissage ligne par ligne
const rows = [];
for (let i=0; i<Casks.length; i+=3) rows.push(Casks.slice(i, i+3));

const table3 = `
  <table class="tbl3">
    ${rows.map((r,ri)=>{
      return `<tr>${
        r.map((c,ci)=>{
          const k = ri*3 + ci; // index global pour la lettre
          return `<td><small>${alpha(k)}</small>
                    \\(\\overrightarrow{${c.from}${c.to}}\\;${vecCol(c.a,c.b)}\\)
                  </td>`;
        }).join('') + (r.length<3 ? '<td></td>'.repeat(3-r.length) : '')
      }</tr>`;
    }).join('')}
  </table>`;

// --- énoncé complet
ui.equ.innerHTML = `
  <ol style="margin:0 0 0 18px; line-height:1.6">
    <li>Trouver, par lecture graphique, les coordonnées des vecteurs ${list1}.</li>
    <li>Lire les coordonnées des vecteurs ${list2}.</li>
    <li>Placer les points \\(${lettersC.join(', ')}\\) tels que : ${table3}</li>
  </ol>`;
retypeset(HOST);


    // ---- Panneau d’actions (inputs + ticks), style compact
    // 1) Inputs pour les paires AB, AC, ...
    const pane1=document.createElement('div');
    pane1.innerHTML = `<div class="small"><strong>1) Lecture des vecteurs entre points :</strong></div>`;
    pairs.forEach(([i,j],k)=>{
      const id='p1_'+k;
      const row=document.createElement('div');
      row.className='indline';
row.innerHTML = `<span class="lbl">\\(\\vec{${letters1[i]}${letters1[j]}}\\)</span>
  ${mkColInput('p1_'+k,'u','v')} <span class="tick" id="tk_p1_${k}"></span>`;

      pane1.appendChild(row);
    });

    // 2) Inputs pour u_i (même lecteur que ton ex4)
    const pane2=document.createElement('div');
    pane2.innerHTML = `<div class="small" style="margin-top:.5rem"><strong>2) Lecture des \\(\\vec u_i\\) :</strong></div>`;
    U.forEach((_,i)=>{
      const id='u_'+(i+1);
      const row=document.createElement('div');
      row.className='indline';
row.innerHTML = `\\(\\vec u_{${i+1}}\\) ${mkColInput('u_'+(i+1),'u','v')}
  <span class="tick" id="tk_u_${i+1}"></span>`;

      pane2.appendChild(row);
    });

    // 3) Tracé : chips sélection + ticks
    const pane3=document.createElement('div');
    pane3.innerHTML = `<div class="small" style="margin-top:.5rem"><strong>3) Placement des points :</strong></div>`;
    const chips=document.createElement('div'); chips.className='chips'; chips.innerHTML='<span>Point à placer :</span>';
    Casks.forEach((c,i)=>{
      const id='c'+(i+1);
      const wrap=document.createElement('div'); wrap.className='chipwrap';
      const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=id;
      sp.innerHTML = `<span class="dot" style="background:${colorOfIndex(i+10)}"></span> ${c.to}`;
      const tk=document.createElement('span'); tk.className='tick'; tk.id='tk_'+id; tk.style.color = colorOfIndex(i+10);
      wrap.appendChild(sp); wrap.appendChild(tk); chips.appendChild(wrap);
    });
    pane3.appendChild(chips);



    const chipEls=[...chips.querySelectorAll('.chip')];
    let state = this.state = { R, pts, pairs, U, Casks, ui, _curC:'c1' };




// -- On N'AFFICHE PAS pane1/pane2 dans la colonne de droite --
// On les reconstruit à plat, en ligne, SOUS le bloc repère/énoncé.
ui.actions.appendChild(pane3); // la partie 3 reste à droite, comme avant

// === Tableau "1) ... / 2) ..." sous le bloc repère/énoncé ===
// === Tableau "1) ... / 2) ..." sous le bloc repère/énoncé ===
this.buildFlat12 = () => {
  const st = this.state;
  if (!st || !st.ui) return;

  // supprime l'ancien bloc s'il existe
  const old = document.getElementById('flat12-wrap');
  if (old) old.remove();

  // on insère juste sous la .row du repère
  const rowContainer = HOST.querySelector('.row');
  if (!rowContainer) return;

  const wrap = document.createElement('div');
  wrap.id = 'flat12-wrap';
  wrap.className = 'flat12-wrap';

  // helpers -------------------------------------------------
  const N = getNbPtsInput();                      // déclencheur : 2e ligne si N >= 6
  const showRow2 = (N >= 6);

  function addSection(titleTex, items, buildCellHTML){
    const sec = document.createElement('div');
    sec.className = 'sec';
    sec.innerHTML =
      `<div class="title">${titleTex}</div>
       <div class="grid5" id="row1"></div>
       <div class="grid5 ${showRow2 ? '' : 'hidden'}" id="row2"></div>`;
    wrap.appendChild(sec);

    const row1 = sec.querySelector('#row1');
    const row2 = sec.querySelector('#row2');

    // on remplit 5 sur la première ligne, le reste (à partir du 6e) sur la seconde
    items.forEach((it, idx) => {
      const cell = document.createElement('span');
      cell.className = 'inlinecell';
      cell.innerHTML = buildCellHTML(it, idx);
      (idx < 5 ? row1 : row2).appendChild(cell);
    });
  }
  // ---------------------------------------------------------

  // SECTION 1 : vecteurs entre points
  addSection(
    '1) Lecture des vecteurs entre points :',
    st.pairs,                                              // [ [i,j], ... ]
    ([i,j], k) => {
      const A = st.pts[i], B = st.pts[j];
      return `\\(\\vec{${A.label}${B.label}}\\) ${mkColInput('p1_'+k,'u','v')}
              <span class="tick" id="tk_p1_${k}"></span>`;
    }
  );

  // SECTION 2 : lecture des u_i
  addSection(
    '2) Lecture des \\(\\vec u_i\\) :',
    st.U,                                                  // objets u1..uN
    (_v, i) => {
      const idx = i + 1;
      return `\\(\\vec u_{${idx}}\\) ${mkColInput('u_'+idx,'u','v')}
              <span class="tick" id="tk_u_${idx}"></span>`;
    }
  );

  rowContainer.insertAdjacentElement('afterend', wrap);
  retypeset(HOST);
};





    function setActive(id){ state._curC=id; chipEls.forEach(c=>c.classList.toggle('active', c.dataset.l===id)); }
    chipEls.forEach(c=>c.addEventListener('click',()=>setActive(c.dataset.l)));
    if (chipEls[0]) setActive('c1');

    // Interaction de tracé (partie 3)
    ui.rep.clickable=true;
    ui.rep.onClick = ({x,y})=>{
      const idx = Math.max(0, (+state._curC.replace('c',''))-1);
      const c = state.Casks[idx]; if(!c) return;
      ui.rep.placeUserVector('c'+(idx+1), c.ox,c.oy, x,y, colorOfIndex(idx+10));
    };
	this.state = { R, pts, pairs, U, Casks, ui };
// en fin de gen(), après this.state = { ... } actuel :
// === Post-gen : masters immuables + renderer piloté par le slider ===
const MAX = 10;
const st  = this.state = { R, pts, pairs, U, Casks, ui, _curC:'c1' };

// ---------- 1) CONSTRUIRE DES POOLS SUR MAX (indépendants de nb) ----------
const lettersPool = ALL.slice(0, MAX).split('');        // A..J pour les points
const lettersForC = ALL.slice(MAX, MAX+MAX).split('');  // K..T pour la partie 3

// points (pool de MAX), répartis par cellules
(function buildPtsPool(){
  const used = new Set();
  const cells = shuffle(makeCells(lim, 3, 3));
  st._ptsPool = [];
  for(let i=0;i<MAX;i++){
    const cell = cells[i % cells.length];
    let p, k=0;
    do {
      const q = randIntInCell(cell);
      p = {x:q.x, y:q.y};
    } while(used.has(p.x+';'+p.y) && ++k<400);
    used.add(p.x+';'+p.y);
    st._ptsPool.push({label:lettersPool[i], x:p.x, y:p.y, fill:'#000'});
  }
})();

// toutes les paires ordonnées sur le pool
st._pairsPool = [];
for(let i=0;i<lettersPool.length;i++){
  for(let j=0;j<lettersPool.length;j++){
    if(i!==j) st._pairsPool.push([i,j]);
  }
}

// vecteurs U (pool de MAX)
(function buildUPool(){
  // directions variées pour beaucoup de pentes distinctes
  const DIRS_BASE = shuffle([
    [1,0],[0,1],[-1,0],[0,-1],
    [1,1],[1,2],[2,1],[1,3],[3,1],[2,3],[3,2],
    [-1,1],[1,-1],[-1,-2],[-2,-1],[-1,-3],[-3,-1],[-2,-3],[-3,-2]
  ]);
  const cellsU = shuffle(makeCells(lim, 3, 3));
  const usedSlopeU = new Set();      // <-- anti-doublon de pente
  st._UPool = [];
  const MAX = 10;                    // on vise jusqu’à 10 u_i max

  for (let i = 0; i < MAX; i++){
    const cell = cellsU[i % cellsU.length];
    let tries = 0, ok = false, rec = null;

    while (!ok && ++tries < 1200){
      const o = randIntInCell(cell);
      const [aa, bb] = DIRS_BASE[(i + tries) % DIRS_BASE.length];
      const g = gcd(Math.abs(aa), Math.abs(bb)) || 1;
      const dirx = aa / g, diry = bb / g;

      const len = randInt(2, 5);
      let a = dirx * len, b = diry * len;

      const key = slopeKey(a, b);
      if (usedSlopeU.has(key)) continue;

      let x2 = o.x + a, y2 = o.y + b;
      if (!fits(lim, x2, y2)) { a = -a; x2 = o.x + a; }
      if (!fits(lim, x2, y2)) { b = -b; y2 = o.y + b; }
      if (!fits(lim, x2, y2)) { a = -a; x2 = o.x + a; }

      ok = fits(lim, x2, y2);
      if (ok) { rec = { a, b, x1:o.x, y1:o.y, x2, y2 }; }
    }

    if (!rec){ i--; continue; }
    st._UPool.push(rec);
    usedSlopeU.add(slopeKey(rec.a, rec.b));
  }
})();


// cibles à placer (pool de MAX), origines prises dans _ptsPool
(function buildCasksPool(){
  const DIRS_RICH = shuffle([
    [1,0],[0,1],[-1,0],[0,-1],
    [1,1],[1,-1],[-1,1],[-1,-1],
    [1,2],[2,1],[1,3],[3,1],[1,4],[4,1],
    [-1,2],[-2,1],[-1,3],[-3,1],[-1,4],[-4,1],
    [1,-2],[2,-1],[1,-3],[3,-1],[1,-4],[4,-1],
    [-1,-2],[-2,-1],[-1,-3],[-3,-1],[-1,-4],[-4,-1],
    [2,3],[3,2],[-2,3],[-3,2],[2,-3],[3,-2],[-2,-3],[-3,-2],
    [2,4],[4,2],[-2,4],[-4,2],[2,-4],[4,-2],[-2,-4],[-4,-2]
  ]);

  const usedAB = new Set();     // empêche les doublons (a;b) à la source
  st._CasksPool = [];
  const MAX = 10;

  for (let i=0; i<MAX; i++){
    const origin = st._ptsPool[i % st._ptsPool.length];
    let ok = false, guard = 0, rec = null;

    while(!ok && ++guard < 2000){
      const [aa, bb] = DIRS_RICH[(i + guard) % DIRS_RICH.length];
      const g = gcd(Math.abs(aa), Math.abs(bb)) || 1;
      const dirx = aa / g, diry = bb / g;

      const len = randInt(1, 6);
      let a = dirx * len, b = diry * len;

      if (usedAB.has(abKey(a,b))) continue;

      let x2 = origin.x + a, y2 = origin.y + b;
      if (!fits(lim, x2, y2)) { a = -a; x2 = origin.x + a; }
      if (!fits(lim, x2, y2)) { b = -b; y2 = origin.y + b; }
      if (!fits(lim, x2, y2)) { a = -a; x2 = origin.x + a; }

      ok = fits(lim, x2, y2);
      if (ok){
        usedAB.add(abKey(a,b));
        rec = { from: origin.label, to: (ALL.slice(MAX, MAX+MAX)[i]||('X'+i)),
                a, b, x2, y2, ox:origin.x, oy:origin.y };
      }
    }
    if (!rec){ i--; continue; }
    st._CasksPool.push(rec);
  }
})();

// ---- Master de paires stables (sans doublons AB/BA, orientation figée)
(function buildPairsMaster(){
  const MAX = 10;
  // on part de 0..MAX-1 (points A..J)
  const undirected = [];
  for (let i = 0; i < MAX; i++){
    for (let j = i+1; j < MAX; j++){
      undirected.push([i,j]);
    }
  }
  // orientation figée aléatoire pour chaque couple (pile ou face)
  const oriented = undirected.map(([i,j]) => (Math.random() < 0.5 ? [i,j] : [j,i]));
  // ordre aléatoire mais *fixé* pour toute la session
  st._pairsMaster = shuffle(oriented);
})();


// masters immuables = ces pools (grands)
st._masters = {
  pts:   st._ptsPool,           // taille MAX
  pairs: st._pairsPool,         // ~90
  U:     st._UPool,             // taille MAX
  Casks: st._CasksPool          // taille MAX
};

// ---------- 2) RENDERER (inchangé sauf qu’on slice dans _masters) ----------
function buildEquAndActions(){
  const list1 = st.pairs.map(([i,j])=>`\\(\\overrightarrow{${st.pts[i].label}${st.pts[j].label}}\\)`).join(', ');
  const list2 = st.U.map((_,i)=>`\\(\\overrightarrow{u_${i+1}}\\)`).join(', ');

  const rows=[]; for(let i=0;i<st.Casks.length;i+=3) rows.push(st.Casks.slice(i,i+3));
  const table3 = `
    <table class="tbl3">
      ${rows.map((r,ri)=>`<tr>${
        r.map((c,ci)=>{
          const k=ri*3+ci;
          return `<td><small>${alpha(k)}</small>
                    \\(\\overrightarrow{${c.from}${c.to}}\\;${vecCol(c.a,c.b)}\\)
                  </td>`;
        }).join('') + (r.length<3 ? '<td></td>'.repeat(3-r.length) : '')
      }</tr>`).join('')}
    </table>`;

  st.ui.equ.innerHTML = `
    <ol style="margin:0 0 0 18px; line-height:1.6">
      <li>Trouver, par lecture graphique, les coordonnées des vecteurs ${list1}.</li>
      <li>Lire les coordonnées des vecteurs ${list2}.</li>
      <li>Placer les points \\(${st.Casks.map(c=>c.to).join(', ')}\\) tels que : ${table3}</li>
    </ol>`;

  // Panneaux
  st.ui.actions.innerHTML = '';

  const pane1=document.createElement('div');
  pane1.innerHTML = `<div class="small"><strong>1) Lecture des vecteurs entre points :</strong></div>`;
  st.pairs.forEach(([i,j],k)=>{
    const row=document.createElement('div'); row.className='indline';
    row.innerHTML = `<span class="lbl">\\(\\vec{${st.pts[i].label}${st.pts[j].label}}\\)</span>
      ${mkColInput('p1_'+k,'u','v')} <span class="tick" id="tk_p1_${k}"></span>`;
    pane1.appendChild(row);
  });

  const pane2=document.createElement('div');
  pane2.innerHTML = `<div class="small" style="margin-top:.5rem"><strong>2) Lecture des \\(\\vec u_i\\) :</strong></div>`;
  st.U.forEach((_,i)=>{
    const row=document.createElement('div'); row.className='indline';
    row.innerHTML = `\\(\\vec u_{${i+1}}\\) ${mkColInput('u_'+(i+1),'u','v')} <span class="tick" id="tk_u_${i+1}"></span>`;
    pane2.appendChild(row);
  });

  const pane3=document.createElement('div');
  pane3.innerHTML = `<div class="small" style="margin-top:.5rem"><strong>3) Placement des points :</strong></div>`;
  const chips=document.createElement('div'); chips.className='chips'; chips.innerHTML='<span>Point à placer :</span>';
  st.Casks.forEach((c,i)=>{
    const id='c'+(i+1);
    const wrap=document.createElement('div'); wrap.className='chipwrap';
    const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=id;
    sp.innerHTML = `<span class="dot" style="background:${colorOfIndex(i+10)}"></span> ${c.to}`;
    const tk=document.createElement('span'); tk.className='tick'; tk.id='tk_'+id; tk.style.color = colorOfIndex(i+10);
    wrap.appendChild(sp); wrap.appendChild(tk); chips.appendChild(wrap);
  });
  pane3.appendChild(chips);

// pane1 / pane2 sont rendus à plat via this.buildFlat12()
// Ici on ne garde que la partie 3 dans la colonne de droite
st.ui.actions.appendChild(pane3);

// (re)construit les lignes 1) et 2) sous le repère
this.buildFlat12 && this.buildFlat12();



  const chipEls=[...chips.querySelectorAll('.chip')];
  function setActive(id){ st._curC=id; chipEls.forEach(c=>c.classList.toggle('active', c.dataset.l===id)); }
  chipEls.forEach(c=>c.addEventListener('click',()=>setActive(c.dataset.l)));
  if (chipEls[0]) setActive('c1');

  st.ui.rep.clickable=true;
  st.ui.rep.onClick = ({x,y})=>{
    const idx = Math.max(0, (+st._curC.replace('c',''))-1);
    const c = st.Casks[idx]; if(!c) return;
    st.ui.rep.placeUserVector('c'+(idx+1), c.ox,c.oy, x,y, colorOfIndex(idx+10));
  };

  retypeset(HOST);
}

// renderer appelé au changement “Nombre d’objets”
// renderer appelé au changement “Nombre d’objets”
st._render = (count) => {
  const L  = Math.max(5, Math.min(10, count));
  const nU = Math.max(3, Math.min(10, count));
  const nC = Math.max(3, Math.min(10, count));

// points visibles
// points visibles
st.pts = st._masters.pts.slice(0, L);

// ---- Paires : append-only à partir du master ----
const want = Math.max(3, Math.min(count, st._pairsMaster.length));

// stock persistant des paires choisies
if (!st._pairsChosen) st._pairsChosen = [];

// 1) on garde les paires déjà choisies qui restent valides pour ce L
st._pairsChosen = st._pairsChosen.filter(([a,b]) => a < L && b < L);

// 2) on complète en piochant à la suite du master (sans réinsérer de doublons)
const seen = new Set(st._pairsChosen.map(([a,b]) => a + '-' + b));
for (let k = 0; k < st._pairsMaster.length && st._pairsChosen.length < want; k++){
  const [a,b] = st._pairsMaster[k];
  if (a >= L || b >= L) continue;
  const key = a + '-' + b;
  if (seen.has(key)) continue;
  seen.add(key);
  st._pairsChosen.push([a,b]);           // <-- AJOUT EN FIN
}

// 3) si on a réduit le nombre demandé, on tronque par la fin
if (st._pairsChosen.length > want) st._pairsChosen.length = want;

// résultat pour l’énoncé
st.pairs = st._pairsChosen.slice();




  // vecteurs à lire et cibles à placer
  st.U     = st._masters.U.slice(0, nU);
  st.Casks = st._masters.Casks.slice(0, nC);

  // redraw
  st.ui.rep.setPoints(st.pts.map(p => ({ x:p.x, y:p.y, label:p.label, fill:'#000' })));
  st.ui.rep.setVectors(st.U.map((v,i)=>({ label:'u'+(i+1), x1:v.x1, y1:v.y1, x2:v.x2, y2:v.y2, stroke:colorOfIndex(i) })));
  st.ui.rep.clearUserVectors();

  buildEquAndActions();
};


// premier rendu avec la valeur courante du slider (pas de nouveau hasard)
st._render(getNbPtsInput());
this.buildFlat12 && this.buildFlat12();




  },

adjustLive(kind){
  const st = this.state; if(!st) return;

  if (!kind || kind === 'amp'){
    st.R = {...AMP};
    st.ui.rep.R = {...AMP};
    st.ui.rep.redraw();
    st.ui.rep.setPoints(st.pts.map(p=>({x:p.x,y:p.y,label:p.label,fill:'#000'})));
    st.ui.rep.setVectors(st.U.map((v,i)=>({label:'u'+(i+1), x1:v.x1,y1:v.y1,x2:v.x2,y2:v.y2, stroke:colorOfIndex(i)})));
    const keep = [...(st.ui.rep.userVectors||[])];
    st.ui.rep.clearUserVectors();
    keep.forEach(v=>st.ui.rep.placeUserVector(v.label,v.x1,v.y1,v.x2,v.y2,v.stroke||'#0a84ff'));
    return;
  }

if (kind === 'n'){
  st._render(getNbPtsInput());
  // reconstruit les lignes 1) et 2) sous le repère
if (typeof this.buildFlat12 === 'function') this.buildFlat12();

}

}
,

  verify(){
  const st=this.state, {ui}=st;
  let ok=0, tot=0;

  // --- Partie 1 : vecteurs entre points (inputs p1_k_u / p1_k_v)
  st.pairs.forEach(([i,j],k)=>{
    const got = getPairFromInputs('p1_'+k);
    const tk  = document.getElementById('tk_p1_'+k);
    if (got.empty){ if(tk){ tk.textContent=''; tk.className='tick'; } return; }
    const A=st.pts[i], B=st.pts[j];
    const good = got.ok && (got.u === (B.x-A.x)) && (got.v === (B.y-A.y));
    if(tk){ tk.textContent = good ? '✔' : '✘'; tk.className='tick '+(good?'ok':'ko'); }
    tot++; if(good) ok++;
  });

  // --- Partie 2 : lecture des u_i (inputs u_i_u / u_i_v)
  st.U.forEach((v,i)=>{
    const got = getPairFromInputs('u_'+(i+1));
    const tk  = document.getElementById('tk_u_'+(i+1));
    if (got.empty){ if(tk){ tk.textContent=''; tk.className='tick'; } return; }
    const good = got.ok && (got.u === v.a) && (got.v === v.b);
    if(tk){ tk.textContent = good ? '✔' : '✘'; tk.className='tick '+(good?'ok':'ko'); tk.style.color = colorOfIndex(i); }
    tot++; if(good) ok++;
  });

  // --- Partie 3 : placement des points (vecteurs cliqués)
  st.Casks.forEach((c,i)=>{
    const id='c'+(i+1);
    const u=(ui.rep.userVectors||[]).find(v=>v.label===id);
    const tk=document.getElementById('tk_'+id);
    if(!u){ if(tk){ tk.textContent=''; tk.className='tick'; } return; }
    const baseOK = (u.x1===c.ox && u.y1===c.oy);
    const dx=u.x2-u.x1, dy=u.y2-u.y1;
    const good = baseOK && dx===c.a && dy===c.b;
    if(tk){ tk.textContent = good ? '✔' : '✘'; tk.className='tick '+(good?'ok':'ko'); tk.style.color = colorOfIndex(i+10); }
    tot++; if(good) ok++;
  });

  setFB(ok===tot, `${ok} / ${tot}`);
  return ok===tot;
},


  solution(){
    const st=this.state, {ui}=st;

    // On superpose : les u_i (déjà visibles) + les vecteurs attendus de la partie 3 (AH, CK, ...)
    const vectsC = st.Casks.map((c,i)=>({label:'c'+(i+1), x1:c.ox,y1:c.oy, x2:c.ox+c.a,y2:c.oy+c.b, stroke:colorOfIndex(i+10)}));
    ui.rep.setVectors([
      ...st.U.map((v,i)=>({label:'u'+(i+1), x1:v.x1,y1:v.y1,x2:v.x2,y2:v.y2, stroke:colorOfIndex(i)})),
      ...vectsC
    ]);

    // Rendu texte compact façon “corrigé”
    const bloc1 = st.pairs.map(([i,j])=>{
      const A=st.pts[i], B=st.pts[j];
      return `\\(\\overrightarrow{${st.pts[i].label}${st.pts[j].label}}\\;${vecCol(B.x-A.x, B.y-A.y)}\\)`;
    }).join(' ; ');

    const bloc2 = st.U.map((v,i)=>`\\(\\vec u_{${i+1}}${vecCol(v.a,v.b)}\\)`).join(' ; ');
    const bloc3 = st.Casks.map((c)=>`\\(\\overrightarrow{${c.from}${c.to}}${vecCol(c.a,c.b)}\\)`).join(' ; ');

    ui.res.innerHTML =
      `<div class="step"><strong>1)</strong> ${bloc1}</div>`+
      `<div class="step"><strong>2)</strong> ${bloc2}</div>`+
      `<div class="step"><strong>3)</strong> ${bloc3}</div>`;
    retypeset(HOST);
  }
},



};

/* === Adapter pour le kit PDF (identique à avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;

/* Fabrique synchrone pour PDF : récupère l’écran et convertit en SVG dans beforeRender (inchangé) */
window.buildOneForPDFSync = function(defId){
  const cfg = REGISTRY_MAP[defId];
  if (!cfg) return { statement:'', solution:'' };

  const host   = document.querySelector('#host');
  const backup = host ? host.innerHTML : '';

  if (host) mountHost();
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // Génère l’écran (crée le repère pour e3/ex4/e5)
  cfg.gen.call(cfg);

  // ---- 1) Récupérer le repère s’il existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // sécurité namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) Énoncé texte
  const equHTML = (document.querySelector('#equ')||{}).innerHTML || '';

  // Énoncé final : grille 2 colonnes si on a un repère, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction
  cfg.solution.call(cfg);
  const solution = (document.querySelector('#res')||{}).innerHTML || '';

  if (host) host.innerHTML = backup;
  return { statement, solution };
};

function toggleAmpbar(activeId){
  const bar = document.getElementById('ampbar');
  if (!bar) return;
  const hide = (activeId === 'e1' || activeId === 'e2');
  bar.style.display = hide ? 'none' : '';
}

/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	toggleAmpbar(ACTIVE);

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){
     applyAMPInputs();          

  mountHost(); // injecte le layout par défaut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // éléments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', HOST);
  const fbEl  = $('#fb', HOST);
  const resEl = $('#res', HOST);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

  // génère l'exo (peut remplacer entièrement le host, ex. e3/ex4)
  cfg.gen.call(cfg);

  // (re)typeset
  retypeset();
  toggleAmpbar(ACTIVE);

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
    document.querySelector('#btn-reset').addEventListener('click', ()=>{ const a=$('#ans',HOST); if(a) a.value=''; const f=$('#fb',HOST); if(f) f.textContent=''; const r=$('#res',HOST); if(r) r.innerHTML=''; });
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
    document.querySelector('#btn-solution').addEventListener('click', ()=>{ REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]); });
function adjustLive(kind){
  const id = ACTIVE;
  if (id === 'e3'   && REGISTRY_MAP.e3.adjustLive)   REGISTRY_MAP.e3.adjustLive(kind);
  else if (id === 'ex4' && REGISTRY_MAP.ex4.adjustLive) REGISTRY_MAP.ex4.adjustLive(kind);
  else if (id === 'e5'  && REGISTRY_MAP.e5.adjustLive)  REGISTRY_MAP.e5.adjustLive(kind);
  else { applyAMPInputs(); }
}


['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;   toggleAmpbar(ACTIVE);  buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) — inchangé, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);

          const htmlIn =
            `<div class="exo-block">
               <span class="exo-title">Exercice — ${label}</span>
               <div class="exo-statement">${statement||''}</div>
             </div>` +
            (withSolutions
              ? `<div style="margin-top:1rem;">
                   <div class="exo-block">
                     <span class="exo-title">Correction</span>
                     <div class="exo-solution">${solution||''}</div>
                   </div>
                 </div>` : '');

          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
