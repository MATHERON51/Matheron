<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde — Vecteurs : Translations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,
input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc correction / explications */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
@media (max-width:600px){
  .line{white-space:normal}
}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:var(--ok)}
.tick.ko{color:var(--ko)}

.answers{
  display:flex;
  flex-direction:column;
  flex-wrap:wrap;
  gap:.4rem .5rem;
  margin-top:.6rem;
}
.answers .qa-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.4rem;
}
.answers .qa-row label{
  flex:1 1 auto;
  min-width:260px;
}
.answers .qa-row input{
  flex:0 0 auto;
  min-width:60px;
  max-width:80px;
  text-transform:uppercase;
  text-align:center;
  font-weight:600;
}
@media print{ .controls{display:none !important;} }

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}
.enonce .subhead{
  font-weight:600;
  margin-top:.5rem;
}


.exo-layout-table{
  width:100%;
  border-collapse:collapse;
}

.exo-layout-table td{
  vertical-align:top;
  border:none;
  padding:8px 12px;
}

.exo-fig-col{
  width:240px;
  min-width:240px;
}

@media(max-width:700px){
  .exo-layout-table,
  .exo-layout-table tbody,
  .exo-layout-table tr,
  .exo-layout-table td{
    display:block;
    width:100%;
  }
  .exo-fig-col{
    width:auto;
    min-width:auto;
    margin-bottom:1rem;
  }
}
.table-yn{
  border:1px solid #d0d0d0;     /* ✅ contour externe visible */
  border-radius:8px;
  background:#fff;
  border-collapse:separate;     /* ✅ on sépare pour garder le rayon + contour */
  border-spacing:0;             /* pas d’espace entre cellules */
  overflow:hidden;              /* les coins arrondis "coupent" l'intérieur */
}

.table-yn th,
.table-yn td{
  border:1px solid #e5e5e5;     /* traits internes des cases */
  padding:6px 8px;
  vertical-align:top;
}

.table-yn th{
  background:#f9f9fa;
  text-align:left;
  font-weight:600;
}


</style>

<!-- ⭐ MATHJAX CONFIG CHTML -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>Seconde – Vecteurs : Translation</strong>
  </h1>
</div>

<div class="wrap">
  <!-- barre de contrôle -->
  <div class="controls card">
    <label for="exo-select"><strong>Type d’exercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
    <button id="btn-check" class="btn">✅ Vérifier</button>
    <button id="btn-solution" class="btn">💡 Solution</button>
    <button id="btn-reset" class="btn">🧹 Réinitialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <!-- zone exo -->
  <div class="card" id="host"></div>

  <!-- bloc aide saisie -->
  <div class="card small">
    <strong>Saisie &amp; réponses acceptées :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Répondre par la lettre du point image (exemple : <code>A</code>, <code>B</code>, <code>G</code>...).</li>
      <li>La casse n’a pas d’importance (<code>a</code> = <code>A</code>).</li>
      <li>On ne demande jamais les coordonnées, juste le nom du point obtenu par la translation.</li>
    </ul>
  </div>

  <!-- clavier math -->
  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- Dépendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ===== Utils DOM / score ===== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }

/* ===== random helpers ===== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* =========================================================
   GÉOMÉTRIE / FIGURES DE RÉFÉRENCE POUR L'EXERCICE 1
   -------------------------------------------------
   On stocke 20 "figures". Chaque figure :
   - name: identifiant technique
   - pts: {A:{x:..,y:..},B:{...},...}
   Les positions servent uniquement à vérifier les translations:
      la translation qui envoie P->Q est le vecteur Q-P.
   On peut donc en déduire l'image de n'importe quel autre point R :
      R + (Q-P).

   Les lettres utilisées sont cohérentes avec ce qu'on affiche.
   On reste en grande majorité sur des lettres A,B,C,D,E,F,G,H,...
   (IMPORTANT: Toutes distinctes)
   ========================================================= */

function vecAdd(p,v){
  return {x:p.x+v.x, y:p.y+v.y};
}
function vecDiff(p,q){
  return {x:q.x-p.x, y:q.y-p.y}; // vecteur p->q
}
function samePoint(p,q){
  const EPS = 1e-6;
  return (Math.abs(p.x - q.x) < EPS &&
          Math.abs(p.y - q.y) < EPS);
}

function checkPlacement(st){
  // sécu
  if (!st || !st.targetPts) return {count:0, good:0};

  const need = ["K","L","M"];

  let locTot = 0;
  let locOK  = 0;

  need.forEach(lbl=>{
    const tickEl = $('#tick-'+lbl);
    if(!tickEl) return;

    // pas placé → neutre (rien affiché)
    if(!st.placedByStudent || !st.placedByStudent[lbl]){
      tickEl.className = 'tick';
      tickEl.textContent = '';
      return;
    }

    const got = st.placedByStudent[lbl]; // {x,y} posé élève
    const tar = st.targetPts[lbl];       // {x,y} attendu

    if(!tar){
      // pas de cible = neutre
      tickEl.className = 'tick';
      tickEl.textContent = '';
      return;
    }

    // l'élève a cliqué quelque part -> on compte cette tentative
    locTot++;

    const ok = (Math.abs(got.x - tar.x) < 1e-9 &&
                Math.abs(got.y - tar.y) < 1e-9);

    if(ok) locOK++;

    tickEl.className = 'tick ' + (ok ? 'ok' : 'ko');
    tickEl.textContent = ok ? '✓' : '✗';
  });

  return {count:locTot, good:locOK};
}



function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function buildTripletsForFigure(pts){
  const letters = Object.keys(pts);

  const cands1 = []; // type 1
  const cands2 = []; // type 2

  // Type 1 : "La translation qui transforme P en Q, transforme R en ... "
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if (j===i) continue;
      for (let k=0; k<letters.length; k++){
        if (k===i || k===j) continue;
        const P = letters[i];
        const Q = letters[j];
        const R = letters[k];

        const ans = translatePoint(pts, P, Q, R);
        if(!ans) continue;
        // question text
        const text = `La translation qui transforme \\( \\) \\(${P}\\) \\( \\)en\\( \\) \\(${Q}\\), transforme \\( \\)\\(${R}\\) \\( \\)en ...`;

        cands1.push({
          text,
          ans
        });
      }
    }
  }

  // Type 2 : "La translation de vecteur \vec{XY} transforme R en ..."
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if (j===i) continue;
      for (let k=0; k<letters.length; k++){
        if (k===i || k===j) continue;
        const X = letters[i];
        const Y = letters[j];
        const R = letters[k];

        const ans = translatePoint(pts, X, Y, R);
        if(!ans) continue;
        const text = `La translation de vecteur \\( \\) \\(\\overrightarrow{${X}${Y}}\\) \\( \\) transforme \\( \\)  \\(${R}\\) \\( \\) en ...`;

        cands2.push({
          text,
          ans
        });
      }
    }
  }

  return { cands1, cands2 };
}


// figure builder util: régulier n-gone centré, + points spéciaux
function regularPolygonPoints(n, radius, cx, cy, labels){
  const pts={};
  for(let i=0;i<n;i++){
    const ang = 2*Math.PI*i/n - Math.PI/2;
    const x = cx + Math.round(radius*Math.cos(ang));
    const y = cy + Math.round(radius*Math.sin(ang));
    pts[labels[i]]={x,y};
  }
  return pts;
}

// BANK_FIGURES : ~20 variantes
const BANK_FIGURES = [];

// 1. hexagone + diagonales façon "étoile" (style de ton losange/étoile)
BANK_FIGURES.push({
  name:"etoile_hex",
  pts:{
    A:{x:-2,y:0},
    B:{x:0,y:2},
    C:{x:2,y:0},
    D:{x:1,y:-2},
    E:{x:-1,y:-2},
    F:{x:0,y:0},   // centre
    G:{x:2,y:2},
    H:{x:-2,y:2}
  }
});

// 2. rectangle 3x2 maillé en croix
BANK_FIGURES.push({
  name:"rect_croix",
  pts:{
    A:{x:0,y:0},
    B:{x:3,y:0},
    C:{x:3,y:2},
    D:{x:0,y:2},
    E:{x:1.5,y:1},
    F:{x:1.5,y:2},
    G:{x:1.5,y:0},
    H:{x:0,y:1},
    I:{x:3,y:1}
  }
});

// 3. losange vertical
BANK_FIGURES.push({
  name:"losange",
  pts:{
    A:{x:0,y:2},
    B:{x:2,y:0},
    C:{x:0,y:-2},
    D:{x:-2,y:0},
    E:{x:0,y:0},
    F:{x:2,y:2},
    G:{x:-2,y:-2}
  }
});

// 4. maison pentagone (toit triangle + base rectangle)
BANK_FIGURES.push({
  name:"maison",
  pts:{
    A:{x:-2,y:0},
    B:{x:2,y:0},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:1.5}, // faîte du toit
    F:{x:0,y:-2},
    G:{x:-2,y:1.5},
    H:{x:2,y:1.5}
  }
});

// 5. octogone régulier
BANK_FIGURES.push({
  name:"octogone",
  pts: regularPolygonPoints(
    8, // n
    3, // rayon
    0,0,
    ['A','B','C','D','E','F','G','H']
  )
});

// 6. carré + centre + milieux
BANK_FIGURES.push({
  name:"carre_plus",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:0},
    F:{x:0,y:2},
    G:{x:2,y:0},
    H:{x:0,y:-2},
    I:{x:-2,y:0}
  }
});

// 7. trapèze isocèle + diagonales
BANK_FIGURES.push({
  name:"trapeze",
  pts:{
    A:{x:-3,y:2},
    B:{x:3,y:2},
    C:{x:2,y:-1},
    D:{x:-2,y:-1},
    E:{x:0,y:2},
    F:{x:0,y:-1},
    G:{x:2,y:2},
    H:{x:-2,y:2}
  }
});

// 8. triangle + son homothétie interne
BANK_FIGURES.push({
  name:"double_triangle",
  pts:{
    A:{x:-3,y:-1},
    B:{x:3,y:-1},
    C:{x:0,y:3},
    D:{x:-1,y:0.33},
    E:{x:1,y:0.33},
    F:{x:0,y:1.66}
  }
});

// 9. rectangle long + points milieu chaque côté
BANK_FIGURES.push({
  name:"rect_long",
  pts:{
    A:{x:-4,y:1},
    B:{x:4,y:1},
    C:{x:4,y:-1},
    D:{x:-4,y:-1},
    E:{x:0,y:1},
    F:{x:4,y:0},
    G:{x:0,y:-1},
    H:{x:-4,y:0}
  }
});

// 10. pentagone régulier
BANK_FIGURES.push({
  name:"penta",
  pts: regularPolygonPoints(
    5,
    3,
    0,0,
    ['A','B','C','D','E']
  )
});

// 11. hexagone régulier
BANK_FIGURES.push({
  name:"hexa",
  pts: regularPolygonPoints(
    6,
    3,
    0,0,
    ['A','B','C','D','E','F']
  )
});

// 12. "étoile" type losange+points ext
BANK_FIGURES.push({
  name:"etoile2",
  pts:{
    A:{x:0,y:3},
    B:{x:2,y:1},
    C:{x:3,y:0},
    D:{x:2,y:-1},
    E:{x:0,y:-3},
    F:{x:-2,y:-1},
    G:{x:-3,y:0},
    H:{x:-2,y:1},
    I:{x:0,y:0}
  }
});

// 13. Z quadrillé (genre réseau en escalier)
BANK_FIGURES.push({
  name:"zigzag",
  pts:{
    A:{x:-3,y:2},
    B:{x:-1,y:2},
    C:{x:1,y:0},
    D:{x:3,y:0},
    E:{x:1,y:-2},
    F:{x:-1,y:-2}
  }
});

// 14. double carré imbriqué
BANK_FIGURES.push({
  name:"double_square",
  pts:{
    A:{x:-3,y:3},
    B:{x:3,y:3},
    C:{x:3,y:-3},
    D:{x:-3,y:-3},
    E:{x:-1,y:1},
    F:{x:1,y:1},
    G:{x:1,y:-1},
    H:{x:-1,y:-1}
  }
});

// 15. rectangle + diagonales internes en X + point centre
BANK_FIGURES.push({
  name:"rect_X",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:0}
  }
});

// 16. parallélogramme simple
BANK_FIGURES.push({
  name:"para1",
  pts:{
    A:{x:-2,y:1},
    B:{x:2,y:1},
    C:{x:3,y:-2},
    D:{x:-1,y:-2},
    E:{x:0,y:-0.5}
  }
});

// 17. autre parallélogramme (plus aplati)
BANK_FIGURES.push({
  name:"para2",
  pts:{
    A:{x:-3,y:2},
    B:{x:2,y:2},
    C:{x:4,y:0},
    D:{x:-1,y:0},
    E:{x:0,y:1}
  }
});

// 18. escalier 3 niveaux
BANK_FIGURES.push({
  name:"esc2",
  pts:{
    A:{x:-2,y:2},
    B:{x:0,y:2},
    C:{x:0,y:1},
    D:{x:2,y:1},
    E:{x:2,y:-1},
    F:{x:-2,y:-1}
  }
});

// 19. trapèze + point milieu grandes bases
BANK_FIGURES.push({
  name:"trap2",
  pts:{
    A:{x:-4,y:2},
    B:{x:4,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:2},
    F:{x:0,y:-2}
  }
});

// 20. couronne carrée tournante (carré + carré tourné)
BANK_FIGURES.push({
  name:"carre_rot",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:3},
    F:{x:3,y:0},
    G:{x:0,y:-3},
    H:{x:-3,y:0}
  }
});


/* =========================================================
   GÉNÉRATION ÉNONCÉ EXERCICE 1
   -------------------------------------------------
   On va :
   1. choisir une figure aléatoire
   2. fabriquer un bloc d'énoncé en deux parties :
      (1) "La translation qui transforme ... en ... transforme ... en ..."
      (2) "La translation de vecteur \vec{XY} transforme ... en ..."
   3. générer aussi les réponses attendues
   ========================================================= */

function pickDistinctLetters(list, k){
  // renvoie k lettres distinctes prisent dans list
  const L=[...list];
  const out=[];
  while(out.length<k && L.length){
    const i = rnd(0,L.length-1);
    out.push(L.splice(i,1)[0]);
  }
  return out;
}

// Calcule image de R par la translation qui envoie P->Q
function translatePoint(pts, Pname, Qname, Rname){
  const P = pts[Pname];
  const Q = pts[Qname];
  const R = pts[Rname];
  if(!P||!Q||!R) return null;
  const v = vecDiff(P,Q); // vecteur P->Q = Q - P
  const Rimg = vecAdd(R,v); // R + v
  // retrouver la lettre S telle que pts[S] == Rimg
  for(const k in pts){
    if(samePoint(pts[k], Rimg)) return k;
  }
  return null; // pas trouvé = devrait pas arriver si figure cohérente
}

// fabrique un petit paquet de questions style 1.a ... 1.e
function makeBlockType1(pts){
  const letters = Object.keys(pts);
  const nbq = Math.min(5, letters.length-2);
  const qs=[];
  let tries = 0;

  for (let i=0; i<nbq && tries<100; i++){
    tries++;

    const trip = pickDistinctLetters(letters,3);
    if(trip.length<3) break;
    const [P,Q,R] = trip;

    const ans = translatePoint(pts,P,Q,R);
    if(!ans){
      // pas de i--
      continue;
    }
    qs.push({
      text:`La translation qui transforme \\(${P}\\) en \\(${Q}\\), transforme \\(${R}\\) en ...`,
      ans: ans
    });
  }
  return qs;
}



// fabrique un paquet de questions style 2.a ... 2.d
function makeBlockType2(pts){
  const letters = Object.keys(pts);
  const nbq = Math.min(4, letters.length-2);
  const qs=[];
  let tries = 0;

  for (let i=0; i<nbq && tries<100; i++){
    tries++;

    const pair = pickDistinctLetters(letters,2);
    if(pair.length<2) break;
    const [X,Y]=pair;

    let R = choice(letters.filter(L=>L!==X && L!==Y));
    const ans = translatePoint(pts,X,Y,R);
    if(!ans){
      continue;
    }
    qs.push({
      text:`La translation de vecteur \\(\\overrightarrow{${X}${Y}}\\) transforme \\(${R}\\) en ...`,
      ans: ans
    });
  }
  return qs;
}


// transforme les coords "math" pts{name:{x,y}} en un petit SVG centré
function buildFigureSVG(pts){
  // 1. récupère limites
  const names = Object.keys(pts);
  const xs = names.map(n=>pts[n].x);
  const ys = names.map(n=>pts[n].y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  const w = maxX - minX || 1;
  const h = maxY - minY || 1;

  // marge en px dans le viewport final
  const pad = 20;
  const viewW = 200;
  const viewH = 200;

  // facteur d'échelle : on veut que tout tienne dans 200x200 avec marge
  const scale =  ( (viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  // fonction pour convertir coord => pixel
  function toPix(p){
    const X = pad + (p.x - minX)*scale;
    // attention Y : le SVG a l'axe y vers le bas
    const Y = pad + (maxY - p.y)*scale;
    return {X,Y};
  }

  // on va dessiner :
  // - segments reliant les points dans l'ordre alphabétique (rapide)
  // - un point + label pour chaque lettre
  // NOTE: si tu veux des segments plus "intelligents"
  // (par exemple suivre une forme prédéfinie par figure),
  // on pourra ajouter dans BANK_FIGURES un champ edges:[["A","B"],["B","C"],...]
  // Pour l'instant, je vais relier A->B->C->...->A si >=3 points.
  let edges = [];
  if(names.length >= 3){
    const sorted = [...names].sort();
    for(let i=0;i<sorted.length-1;i++){
      edges.push([sorted[i], sorted[i+1]]);
    }
    edges.push([sorted[sorted.length-1], sorted[0]]);
  }

  // build <line> for edges
  let linesSVG = edges.map(([p1,p2])=>{
    const P1 = toPix(pts[p1]);
    const P2 = toPix(pts[p2]);
    return `<line x1="${P1.X.toFixed(1)}" y1="${P1.Y.toFixed(1)}"
                  x2="${P2.X.toFixed(1)}" y2="${P2.Y.toFixed(1)}"
                  stroke="#555" stroke-width="1.2" />`;
  }).join("");

  // build <circle> + <text> for points
  let ptsSVG = names.map(n=>{
    const P = toPix(pts[n]);
    return `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(P.X+5).toFixed(1)}" y="${(P.Y-5).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  }).join("");

  const svg = `
    <svg viewBox="0 0 ${viewW} ${viewH}"
         width="220" height="220"
         style="border:1px solid #ccc;border-radius:6px;background:#fff;margin:8px 0 16px 0;">
      ${linesSVG}
      ${ptsSVG}
    </svg>
  `;
  return svg;
}


function computeLayout(pts, extraPts){
  const baseNames = Object.keys(pts);
  const xs = baseNames.map(n=>pts[n].x);
  const ys = baseNames.map(n=>pts[n].y);

  if (extraPts){
    for (const k in extraPts){
      xs.push(extraPts[k].x);
      ys.push(extraPts[k].y);
    }
  }

  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  // marge généreuse autour (2 unités déjà c’était limite, on garde 2 ? tu dis que le quadrillage
  // n'était pas assez grand -> on va la monter à 3 pour être safe partout)
  minX = Math.floor(minX) - 3;
  maxX = Math.ceil(maxX) + 3;
  minY = Math.floor(minY) - 3;
  maxY = Math.ceil(maxY) + 3;

  const w = maxX - minX || 1;
  const h = maxY - minY || 1;

  const pad = 20;
  const viewW = 450; // plus large
  const viewH = 450;

  const scale = ((viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  function toPixXY(x,y){
    const X = pad + (x - minX)*scale;
    const Y = pad + (maxY - y)*scale; // repère math
    return {X,Y};
  }
  function toPix(p){ return toPixXY(p.x,p.y); }

  return {
    minX,maxX,minY,maxY,
    pad,viewW,viewH,scale,
    toPix,toPixXY
  };
}



function renderFigureSVG(layout, pts, extraPtsToShow, opts){
  const {
    minX,maxX,minY,maxY,
    pad,viewW,viewH,scale,
    toPix
  } = layout;
  const baseNames = Object.keys(pts);

  // 1. limites réelles de la figure (sans marge artificielle)
  const baseXs = baseNames.map(n=>pts[n].x);
  const baseYs = baseNames.map(n=>pts[n].y);
  const figMinX = Math.min(...baseXs);
  const figMaxX = Math.max(...baseXs);
  const figMinY = Math.min(...baseYs);
  const figMaxY = Math.max(...baseYs);

  // 2. pour savoir si on est "vraiment" sur un bord :
  //    tolérance très petite (strict égalité suffit si coords entières)
  function chooseLabelDir(p){
    const onLeft   = p.x === figMinX;
    const onRight  = p.x === figMaxX;
    const onBottom = p.y === figMinY;
    const onTop    = p.y === figMaxY;

    // priorité horizontale: si c'est extrême gauche ou droite → on met gauche/droite
    if (onLeft && !onRight)   return "left";
    if (onRight && !onLeft)   return "right";

    // sinon, priorité verticale: haut ou bas
    if (onTop && !onBottom)   return "top";
    if (onBottom && !onTop)   return "bottom";

    // sinon point intérieur
    return "inside";
  }

  function dirToOffset(dir){
    switch(dir){
      case "left":   return {dx:-14, dy:4};
      case "right":  return {dx:14,  dy:4};
      case "top":    return {dx:0,   dy:-12};
      case "bottom": return {dx:0,   dy:18};
      case "inside": return {dx:0,   dy:18};
    }
  }

  // ===== grille =====
  const gridLines = [];
  for(let X=minX; X<=maxX; X++){
    const p1 = toPix({x:X,y:minY});
    const p2 = toPix({x:X,y:maxY});
    gridLines.push(
      `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
             x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
             stroke="#ddd" stroke-width="0.6" />`
    );
  }
  for(let Y=minY; Y<=maxY; Y++){
    const p1 = toPix({x:minX,y:Y});
    const p2 = toPix({x:maxX,y:Y});
    gridLines.push(
      `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
             x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
             stroke="#ddd" stroke-width="0.6" />`
    );
  }

  // ===== segments de la figure =====
  // Toujours notre "ordre alphabétique fermé" pour l’instant
  let edges = [];
  if(baseNames.length >= 3){
    const sorted = [...baseNames].sort();
    for(let i=0;i<sorted.length-1;i++){
      edges.push([sorted[i], sorted[i+1]]);
    }
    edges.push([sorted[sorted.length-1], sorted[0]]);
  }
  const polyLines = edges.map(([p1,p2])=>{
    const P1 = toPix(pts[p1]);
    const P2 = toPix(pts[p2]);
    return `<line x1="${P1.X.toFixed(1)}" y1="${P1.Y.toFixed(1)}"
                  x2="${P2.X.toFixed(1)}" y2="${P2.Y.toFixed(1)}"
                  stroke="#444" stroke-width="1.4" />`;
  }).join("");

  // ===== points de base (A,B,C,...) =====
  const basePtsSVG = baseNames.map(n=>{
    const mathP = pts[n];
    const P = toPix(mathP);

    const dir = chooseLabelDir(mathP);
    const {dx,dy} = dirToOffset(dir);

    return `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(P.X+dx).toFixed(1)}" y="${(P.Y+dy).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  }).join("");

  // ===== points de correction K,L,M (rouge) =====
  let extraSVG = "";
  if (extraPtsToShow){
    Object.keys(extraPtsToShow).forEach(n=>{
      const mathP = extraPtsToShow[n];
      const P = toPix(mathP);

      // Pour K,L,M en correction on applique la même logique d'extérieur.
      // (ça les met aussi proprement dehors)
      const dir = chooseLabelDir(mathP);
      const {dx,dy} = dirToOffset(dir);

      extraSVG += `
        <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#b00020"/>
        <text x="${(P.X+dx).toFixed(1)}" y="${(P.Y+dy).toFixed(1)}"
              font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
              fill="#b00020">${n}</text>
      `;
    });
  }

  const clickable = opts && opts.interactive ? 'style="cursor:crosshair;touch-action:none;"' : '';

  const dataAttr =
    `data-minx="${minX}" data-maxy="${maxY}" data-scale="${scale}" data-pad="${pad}"`;

  return `
  <svg id="fig-click"
       ${dataAttr}
       viewBox="0 0 ${viewW} ${viewH}"
       width="${viewW}" height="${viewH}"
       ${clickable}
       style="border:1px solid #ccc;border-radius:6px;background:#fff;margin:8px 0 16px 0;
              width:${viewW}px; height:${viewH}px; max-width:${viewW}px; max-height:${viewH}px;">
    ${gridLines.join("")}
    ${polyLines}
    ${basePtsSVG}
    <g id="student-layer"></g>
    ${extraSVG}
  </svg>
`;

}






function buildPlacementTriples(pts){
  const letters = Object.keys(pts);

  // fabrique toutes les constructions possibles O + (V-U)
  // retourne {fromO: 'C', fromU:'E', fromV:'F', newName:'K', O, U, V, T:{x,y}, textLatex:"CK = EF"}
  const builds = [];
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if(j===i) continue;
      for (let k=0; k<letters.length; k++){
        if(k===i || k===j) continue;

        const Oname = letters[i]; // origine (ex: C)
        const Uname = letters[j]; // donne vecteur U->V
        const Vname = letters[k];

        // vecteur U->V
        const v = vecDiff(pts[Uname], pts[Vname]); // careful: vecDiff(p,q) = q - p, i.e. p->q
        // on veut O + (V - U)
        const T = vecAdd(pts[Oname], v);

        // Vérifier si T correspond déjà à un point existant -> on veut NOUVEAU point
        let isNew = true;
        for(const L of letters){
          if (samePoint(pts[L], T)){
            isNew = false;
            break;
          }
        }
        if(!isNew) continue;

        builds.push({
          Oname, Uname, Vname,
          T,
          // pour l'affichage latex ex: \overrightarrow{CK} = \overrightarrow{EF}
          // on remplit le nom final plus tard (K,L,M)
        });
      }
    }
  }
  return builds;
}


 function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function norm2(v){ return v.x*v.x+v.y*v.y; }
function sameVec(a,b){ return a.x===b.x && a.y===b.y; }
function collinear(a,b){
  // a || b  <=> a.x*b.y - a.y*b.x = 0
  return (a.x*b.y - a.y*b.x) === 0 && !(a.x===0 && a.y===0) && !(b.x===0 && b.y===0);
}
function sameDirection(a,b){
  if(!collinear(a,b)) return false;
  // même sens si a = k b avec k>0
  // tester signe scalaire a·b > 0
  return (a.x*b.x + a.y*b.y) > 0;
}
function oppositeDirection(a,b){
  if(!collinear(a,b)) return false;
  // sens opposés si a·b < 0
  return (a.x*b.x + a.y*b.y) < 0;
}
function sameLength(a,b){ return norm2(a) === norm2(b); }

function allDirectedPairs(pts){
  const names = Object.keys(pts);
  const out=[];
  for(let i=0;i<names.length;i++){
    for(let j=0;j<names.length;j++){
      if(j===i) continue;
      const A=names[i], B=names[j];
      const v={x:pts[B].x-pts[A].x, y:pts[B].y-pts[A].y};
      out.push({A,B,v, label:`\\(\\overrightarrow{${A}${B}}\\)`});
    }
  }
  return out;
}

function pickPairsForTable(vecs){
  // On veut 4 colonnes correspondant à 4 "situations-types".
  // Puis on mélange l'ordre avant de renvoyer.

  // Génère toutes les paires ordonnées (u,w) avec u != w
  const pairs = [];
  for (let i=0; i<vecs.length; i++){
    for (let j=0; j<vecs.length; j++){
      if(i===j) continue;
      pairs.push([vecs[i], vecs[j]]);
    }
  }

  // helper : renvoie la première paire qui vérifie un prédicat sur truthFor
  function findPairByProfile(testFn){
    const sh = shuffle(pairs);
    for(const [u,w] of sh){
      const t = truthFor(u.v, w.v);
      if (testFn(t)) {
        return {u,w,t};
      }
    }
    return null;
  }

  // PROFIL 1 : vecteurs égaux
  const col_equal = findPairByProfile(t => t.tEqual);

  // PROFIL 2 : vecteurs opposés
  const col_opposite = findPairByProfile(t => t.tOpposite);

  // PROFIL 3 : même direction, même sens, pas la même longueur
  // => tSameDir = true, tSameSens = true, tSameLen = false
  const col_sameDirSameSensDiffLen = findPairByProfile(t =>
    t.tSameDir && t.tSameSens && !t.tSameLen
    // (tEqual est forcément false dans ce cas)
  );

  // PROFIL 4 : pas la même direction (donc pas colinéaires),
  //            pas le même sens,
  //            même longueur
  // => tSameDir = false, tSameLen = true
  const col_diffDirSameLen = findPairByProfile(t =>
    !t.tSameDir && t.tSameLen
  );

  // Maintenant on collecte ceux qu'on a trouvés
  let wantedCols = [];
  if (col_equal)                  wantedCols.push({kind:'equal',     ...col_equal});
  if (col_opposite)               wantedCols.push({kind:'opposite',  ...col_opposite});
  if (col_sameDirSameSensDiffLen) wantedCols.push({kind:'sameDirSS', ...col_sameDirSameSensDiffLen});
  if (col_diffDirSameLen)         wantedCols.push({kind:'diffDirSL', ...col_diffDirSameLen});

  // Si la figure ne permet pas d'avoir les 4 profils (ça peut arriver),
  // on complète avec des paires quelconques pour rester à 4 colonnes.
  if (wantedCols.length < 4){
    const sh = shuffle(pairs);
    for (const [u,w] of sh){
      if (wantedCols.length >= 4) break;
      const already = wantedCols.some(c=>(c.u===u && c.w===w) || (c.u===w && c.w===u));
      if(!already){
        wantedCols.push({kind:'misc', u, w, t: truthFor(u.v,w.v)});
      }
    }
  }

  // Coupe à 4 et mélange l'ordre final
  wantedCols = shuffle(wantedCols.slice(0,4));

  // Formatage final identique à avant pour que le reste du code ne change pas
  return wantedCols.map((col,idx)=>{
    const {u,w,t} = col;

    return {
      type: col.kind,
      u, w,
      title:`${u.label} \\( \\) et  \\( \\) ${w.label}`,
      truths: {
        // on renvoie exactement les booléens attendus par la suite
        tSameDir:    t.tSameDir,
        // ATTENTION : pour la ligne "ont le même sens" dans le tableau,
        // on veut bien tSameSens (et pas "même direction && !opp")
        tSameSens:   t.tSameSens,
        tSameLen:    t.tSameLen,
        tEqual:      t.tEqual,
        tOpposite:   t.tOpposite
      },
      ids:{
        sameDir:   `c${idx}_dir`,
        sameSens:  `c${idx}_sens`,
        sameLen:   `c${idx}_len`,
        equal:     `c${idx}_eq`,
        opposite:  `c${idx}_op`
      }
    };
  });
}


function truthFor(a,b){
  // même direction = colinéaires (peu importe le sens)
  const tSameDir = collinear(a,b);

  // même sens = colinéaires ET produit scalaire > 0
  // => dans notre code sameDirection(a,b) fait déjà exactement ça
  const tSameSens = sameDirection(a,b);

  // même longueur
  const tSameLen = sameLength(a,b);

  // égaux = même direction, même sens, même longueur
  // dans notre code sameVec(a,b) teste exactement l'égalité
  const tEqual = sameVec(a,b);

  // opposés = même direction, sens opposés, même longueur
  // oppositeDirection(a,b) = colinéaires ET sens opposé
  const tOpposite = oppositeDirection(a,b) && tSameLen;

  return {
    tSameDir,     // colinéaires ?
    tSameSens,    // même sens ?
    tSameLen,     // même longueur ?
    tEqual,       // égaux ?
    tOpposite     // opposés ?
  };
}

function tfStatements(vecs){
  // On va construire des affirmations de 4 types :
  //  - "sont égaux"
  //  - "sont opposés"
  //  - "sont de sens opposés"
  //  - "ont la même longueur"

  // 1. lister toutes les paires (u,w) avec u != w
  const pairs = [];
  for (let i=0; i<vecs.length; i++){
    for (let j=0; j<vecs.length; j++){
      if(i===j) continue;
      const u = vecs[i], w = vecs[j];
      const t = truthFor(u.v, w.v); // {tSameDir,tSameSens,tSameLen,tEqual,tOpposite}

      // On prépare les 4 phrases possibles pour cette paire :
      const candidates = [
        {
          labelType: 'equal',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) sont égaux`,
          truth: t.tEqual
        },
        {
          labelType: 'opposite',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) sont opposés`,
          truth: t.tOpposite
        },
        {
          labelType: 'oppSense',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) sont de sens opposés`,
          // "de sens opposés" = oppositeDirection(a,b)
          truth: oppositeDirection(u.v, w.v)
        },
        {
          labelType: 'sameLen',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) ont la même longueur`,
          truth: t.tSameLen
        }
      ];

      pairs.push(...candidates);
    }
  }

  // 2. On classe par type de phrase ET par vérité
  //    ex: bucket['opposite'].true = [ {stmt, truth:true}, ... ]
  const bucket = {};
  function pushBucket(type, truthVal, obj){
    if(!bucket[type]) bucket[type] = {true:[], false:[]};
    bucket[type][truthVal ? 'true':'false'].push(obj);
  }

  for (const cand of pairs){
    pushBucket(cand.labelType, cand.truth, cand);
  }

  // 3. On essaie de construire une liste équilibrée :
  //    idéalement pour chaque type, 1 vrai + 1 faux
  const finalList = [];
  let trueCount = 0;
  let falseCount = 0;

  const typesOrder = shuffle(['equal','opposite','oppSense','sameLen']); // randomise l'ordre des thèmes

  // d'abord, on essaie d'ajouter pour chaque type un couple (vrai,faux) si possible
  for (const tp of typesOrder){
    const pack = bucket[tp];
    if(!pack) continue;

    // on pioche au hasard dedans pour varier
    const tTrueArr  = shuffle(pack.true);
    const tFalseArr = shuffle(pack.false);

    if (tTrueArr.length && tFalseArr.length){
      // on a les deux -> on prend un de chaque
      const candTrue  = tTrueArr[0];
      const candFalse = tFalseArr[0];

      finalList.push({stmt:candTrue.stmt, truth:true});
      finalList.push({stmt:candFalse.stmt, truth:false});
      trueCount++;
      falseCount++;
    }
  }

  // maintenant finalList contient par exemple 6 éléments (si certains types n'ont pas les deux cas)
  // objectif : arriver à 8 éléments pile, avec 4 vrais / 4 faux
  // On va remplir en respectant l'équilibre.

  function tryAddFromBuckets(wantTruth){
    // wantTruth est true ou false
    const shuffledTypes = shuffle(Object.keys(bucket));
    for (const tp of shuffledTypes){
      const arr = shuffle(bucket[tp][wantTruth ? 'true':'false']);
      for (const cand of arr){
        // éviter les doublons exacts de phrase
        if (finalList.some(x=>x.stmt===cand.stmt)) continue;
        finalList.push({stmt:cand.stmt, truth:wantTruth});
        if (wantTruth) trueCount++; else falseCount++;
        return true;
      }
    }
    return false;
  }

  // On boucle jusqu'à avoir 8 ou plus (sécurité anti boucle infinie : 200 itérations max)
  let guard = 0;
  while (finalList.length < 8 && guard < 200){
    guard++;

    // on veut tendre vers 4 vrais / 4 faux
    if (trueCount < 4){
      // on essaye d'ajouter un vrai
      if (!tryAddFromBuckets(true)){
        // si impossible, on tente quand même un faux
        tryAddFromBuckets(false);
      }
    } else if (falseCount < 4){
      // on essaye d'ajouter un faux
      if (!tryAddFromBuckets(false)){
        // sinon, on tente un vrai
        tryAddFromBuckets(true);
      }
    } else {
      // les deux quotas sont déjà atteints, on remplit ce qui manque
      // (devrait presque jamais arriver)
      if (!tryAddFromBuckets(true)){
        tryAddFromBuckets(false);
      }
    }
  }

  // si on en a pris plus de 8 par hasard, on coupe
  // mais en gardant l'équilibre le mieux possible
  // (finalList est en ordre de sélection, on mélange ensuite)
  if (finalList.length > 8){
    // stratégie simple : mélange puis on coupe 8
    // comme on a forcé l'équilibre pendant la construction, 4/4 reste très probable
    finalList.splice(0, finalList.length, ...shuffle(finalList).slice(0,8));
  }

  // dernière étape : mélange pour ne pas avoir (vrai,faux) collés par thème
  const shuffled = shuffle(finalList).slice(0,8);

  // on leur donne les labels a), b), c)...
  return shuffled.map((o,i)=>({
    label: String.fromCharCode(97+i)+')',
    stmt:  o.stmt,
    truth: o.truth,
    id:    `tf_${i}`
  }));
}


function genCommonVecteurs(){
  let attempt=0;
  while(attempt<40){
    attempt++;
    const fig = choice(BANK_FIGURES);
    const pts = fig.pts;

    // besoin d'assez de points pour être intéressant
    if(Object.keys(pts).length < 6) continue;

    // figure (même layout pour les deux exos)
    const layout = computeLayout(pts, null);
    const figSVG = renderFigureSVG(layout, pts, null, {interactive:false});

    const vecs = allDirectedPairs(pts);
    if(vecs.length < 20) continue;

    // ===== 1) TABLEAU OUI/NON =====
    const cols = pickPairsForTable(vecs).map((it,idx)=>{
      const {u,w} = it;
      const truths = truthFor(u.v,w.v);
      return {
        title:`${u.label} \\( \\) et  \\( \\) ${w.label}`,
        truths,
        ids:{
          sameDir:   `c${idx}_dir`,
          sameSens:  `c${idx}_sens`,
          sameLen:   `c${idx}_len`,
          equal:     `c${idx}_eq`,
          opposite:  `c${idx}_op`
        }
      };
    });

    // correction du tableau (Oui / Non)
    function yn(b){ return b ? 'Oui' : 'Non'; }
    const tableHead = cols
      .map(c=>`<th style="text-align:center;">${c.title}</th>`)
      .join('');

    const solRows = [
      {lab:'ont la même direction',  key:o=>yn(o.truths.tSameDir)},
      {lab:'ont le même sens',       key:o=>yn(o.truths.tSameDir && !o.truths.tOppDir)},
      {lab:'ont la même longueur',   key:o=>yn(o.truths.tSameLen)},
      {lab:'sont égaux',             key:o=>yn(o.truths.tEqual)},
      {lab:'sont opposés',           key:o=>yn(o.truths.tOpposite)}
    ].map(r=>{
      const tds = cols.map(c=>`<td style="text-align:center">${r.key(c)}</td>`).join('');
      return `<tr><td>${r.lab}</td>${tds}</tr>`;
    }).join('');

    const truthsTableHTML = `
      <div class="steps">
        <div class="stepTitle">Correction — Tableau</div>
<table class="table table-yn" style="width:100%">
          <tr>
            <th>Les vecteurs</th>
            ${tableHead}
          </tr>
          ${solRows}
        </table>
      </div>
    `;

    // ===== 2) VRAI / FAUX =====
    const tfList = tfStatements(vecs).map((o,i)=>({
      label: String.fromCharCode(97+i)+')',
      stmt:  o.stmt,
      truth: o.truth,
      id:    `tf_${i}`
    }));

    const tfCorrHTML = `
      <div class="steps">
        <div class="stepTitle">Correction — Vrai / Faux</div>
        ${
          tfList.map(x=>
            `<div class="line"><strong>${x.label}</strong> ${x.stmt} \\( \\) : \\( \\) ${x.truth?'Vrai':'Faux'}</div>`
          ).join('')
        }
      </div>
    `;

    // tout ce qu'il faut pour les deux exos
    return {
      figureSVG: figSVG,
      cols,
      tf: tfList,
      truthsTableHTML,
      tfCorrHTML
    };
  }

  // ===== fallback si pas réussi =====
  return {
    figureSVG:"<div style='color:#b00020;font-weight:600'>[Figure indisponible]</div>",
    cols:[],
    tf:[],
    truthsTableHTML:`<div class="steps">Aucune donnée (tableau)</div>`,
    tfCorrHTML:`<div class="steps">Aucune donnée (V/F)</div>`
  };
}







/* =========================================================
   RENDU DANS LE HOST POUR L'EXERCICE 1
   -------------------------------------------------
   Le bloc .exo-block reste celui de ta fiche.
   On va juste générer dynamiquement plusieurs <div class="qa-row">
   ========================================================= */

function buildHostHTML_exoTable(st){
  function selectYN(id){
    return `<select id="${id}" class="inp">
      <option value=""></option>
      <option>Oui</option>
      <option>Non</option>
    </select><span id="tick-${id}" class="tick"></span>`;
  }

  const headCols = st.cols
    .map(c=>`<th style="text-align:center;">${c.title}</th>`)
    .join('');

  const rows = [
    {lab:'ont la même direction',  key:c=>selectYN(c.ids.sameDir)},
    {lab:'ont le même sens',       key:c=>selectYN(c.ids.sameSens)},
    {lab:'ont la même longueur',   key:c=>selectYN(c.ids.sameLen)},
    {lab:'sont égaux',             key:c=>selectYN(c.ids.equal)},
    {lab:'sont opposés',           key:c=>selectYN(c.ids.opposite)}
  ].map(r=>{
    const tds = st.cols.map(c=>`<td style="text-align:center">${r.key(c)}</td>`).join('');
    return `<tr><td>${r.lab}</td>${tds}</tr>`;
  }).join('');

  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 1 — Vecteurs : comparaison</span>
      <table class="exo-layout-table">
        <tr>
          <td class="exo-fig-col">
            <div class="figure-area" style="text-align:center;">
              ${st.figureSVG}
            </div>
          </td>
          <td class="exo-q-col">
            <div class="enonce">
              <div class="subhead">
                Compléter le tableau en répondant par oui ou non.
              </div>
<table class="table table-yn" style="width:100%">
                <tr>
                  <th>Les vecteurs</th>
                  ${headCols}
                </tr>
                ${rows}
              </table>
              <div id="res" style="margin-top:1rem;"></div>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}





// maj tique locale
function setTickFor(id, state){
  const el = $('#tick-'+id);
  if(!el) return;
  if(state===true){ el.className='tick ok'; el.textContent='✓'; }
  else if(state===false){ el.className='tick ko'; el.textContent='✗'; }
  else { el.className='tick'; el.textContent=''; }
}


function checkAnswers_exoTable(st){
  let count=0, good=0;

  st.cols.forEach(c=>{
    const truth = c.truths;
const spec = [
  {id:c.ids.sameDir, expect: truth.tSameDir},
  {id:c.ids.sameSens, expect: truth.tSameSens},
  {id:c.ids.sameLen, expect: truth.tSameLen},
  {id:c.ids.equal,   expect: truth.tEqual},
  {id:c.ids.opposite,expect: truth.tOpposite},
];

    spec.forEach(s=>{
      const inp = $('#'+s.id);
      if(!inp){ setTickFor(s.id,null); return; }
      const v = (inp.value||'').toLowerCase();
      if(!v){ setTickFor(s.id,null); return; } // vide => pas compté
      count++;
      const ok = ( (s.expect && v==='oui') || (!s.expect && v==='non') );
      if(ok) good++;
      setTickFor(s.id, ok);
    });
  });

  return {count, good};
}




/* =========================================================
   REGISTRY : pour l'instant un seul exercice (EXO_TRANS_1)
   mais on garde l'architecture REG / REGISTRY comme sur
   tes autres fiches.
   ========================================================= */

const EXO_TABLE = {
  id:'exo_vect_table',
  title:'Exercice 1 — Tableau Oui/Non',
  gen(host){
    const stCommon = genCommonVecteurs();
    const st = {
      figureSVG: stCommon.figureSVG,
      cols: stCommon.cols,
      truthsTableHTML: stCommon.truthsTableHTML
    };
    if(host){
      host.innerHTML = buildHostHTML_exoTable(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    const r = checkAnswers_exoTable(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <span class="exo-title">Correction</span>
          <table class="exo-layout-table">
            <tr>
              <td class="exo-fig-col">
                <div class="figure-area" style="text-align:center;">
                  ${st.figureSVG}
                </div>
              </td>
              <td class="exo-q-col">
                ${st.truthsTableHTML}
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){
    $('#res',host).textContent = '';
    (host.__state?.cols||[]).forEach(c=>{
      Object.values(c.ids).forEach(id=>{
        const inp = $('#'+id, host); if(inp) inp.value='';
        setTickFor(id, null);
      });
    });
  }
};

function buildHostHTML_exoVF(st){
  function selectVF(id){
    return `<select id="${id}" class="inp">
      <option value=""></option>
      <option>Vrai</option>
      <option>Faux</option>
    </select><span id="tick-${id}" class="tick"></span>`;
  }

  const tfHTML = st.tf.map(o=>`
    <div class="qa-row" style="margin:.35rem 0;">
      <label style="min-width:260px;">
        <strong>\\(${o.label}\\)</strong> ${o.stmt}
      </label>
     \\( \\) ${selectVF(o.id)}
    </div>
  `).join('');

  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 2 — Vecteurs : Vrai / Faux</span>
      <table class="exo-layout-table">
        <tr>
          <td class="exo-fig-col">
            <div class="figure-area" style="text-align:center;">
              ${st.figureSVG}
            </div>
          </td>
          <td class="exo-q-col">
            <div class="enonce">
              <div class="subhead">
                Pour chaque affirmation, dire si elle est vraie ou fausse.
              </div>
              <div style="margin-left:1.2em;">
                ${tfHTML}
              </div>
              <div id="res" style="margin-top:1rem;"></div>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}


function checkAnswers_exoVF(st){
  let count=0, good=0;

  st.tf.forEach(o=>{
    const inp = $('#'+o.id);
    if(!inp){ setTickFor(o.id,null); return; }
    const v = (inp.value||'').toLowerCase();
    if(!v){ setTickFor(o.id,null); return; }
    count++;
    const ok = ( (o.truth && v==='vrai') || (!o.truth && v==='faux') );
    if(ok) good++;
    setTickFor(o.id, ok);
  });

  return {count, good};
}


const EXO_VF = {
  id:'exo_vect_vf',
  title:'Exercice 2 — Vrai / Faux',
  gen(host){
    const stCommon = genCommonVecteurs();
    const st = {
      figureSVG: stCommon.figureSVG,
      tf: stCommon.tf,
      tfCorrHTML: stCommon.tfCorrHTML
    };
    if(host){
      host.innerHTML = buildHostHTML_exoVF(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    const r = checkAnswers_exoVF(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <span class="exo-title">Correction</span>
          <table class="exo-layout-table">
            <tr>
              <td class="exo-fig-col">
                <div class="figure-area" style="text-align:center;">
                  ${st.figureSVG}
                </div>
              </td>
              <td class="exo-q-col">
                ${st.tfCorrHTML}
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){
    $('#res',host).textContent = '';
    (host.__state?.tf||[]).forEach(o=>{
      const inp = $('#'+o.id, host); if(inp) inp.value='';
      setTickFor(o.id, null);
    });
  }
};


// helpers reset
function stResetTicks(st){
  st.qAll.forEach(q=>setTickFor(q.inputId, null));
}

function stClearInputs(st){
  st.qAll.forEach(q=>{
    const inp = $('#'+q.inputId);
    if(inp) inp.value='';
  });
}





/* ============================================
   EXERCICE 3 — "Parallélogrammes en chaîne"
   Donnés : ABCD et CDEF parallélogrammes
   À prouver : ABFE est un parallélogramme
   (optionnel : on pourra enchaîner un 3e bloc EFGH)
   ============================================ */

function vAdd(p,v){ return {x:p.x+v.x, y:p.y+v.y}; }
function vSub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; } // vecteur b->a = a-b

function genChainParallelogram(){
  // --- 1) On choisit un parallélogramme ABCD de base ---
  // On prend A, B et D, puis on impose C = B + (D - A)
  // pour être SÛR que ABCD est un parallélogramme.

  const A = { x: 0,                  y: 0 };
  const B = { x: 4 + Math.random()*2, y: 0.5 + Math.random()*1.5 };
  const D = { x: 1 + Math.random()*2, y: 3   + Math.random()*2   };

  const DA = vSub(D, A); // D - A
  const C  = vAdd(B, DA); // C = B + (D-A)

  // À ce stade, ABCD est garanti parallélogramme.

  // --- 2) On construit un deuxième parallélogramme C D E F ---
  // Idée : on repart de CD comme côté commun.
  // On choisit un vecteur "tilt" U aléatoire pour décaler CE.
  // Puis on impose E = C + U et F = D + U,
  // ce qui garantit CDEF parallélogramme.

  const tilt = {
    x: (-1 + Math.random()*2), // petit décalage pas colinéaire à CD
    y: ( 2 + Math.random()*2)
  };

  const E = vAdd(C, tilt); // E = C + tilt
  const F = vAdd(D, tilt); // F = D + tilt

  // On a donc :
  //  - ABCD parallélogramme
  //  - CDEF parallélogramme

  // Et on va demander de prouver que ABFE est un parallélogramme.
  //
  // Remarque clé :
  //  Dans ABCD :  ->AB = ->DC   et   ->AD = ->BC
  //  Dans CDEF :  ->CD = ->EF   et   ->CF = ->DE
  //
  //  Pour ABFE :
  //   * montrer que ->AB = ->FE
  //       ->AB = ->DC (ABCD)
  //       ->DC = ->FE (CDEF, sens inversé)
  //     donc ->AB = ->FE
  //
  //   * et/ou ->AF = ->BE
  //       ->AF = ->AD + ->DF
  //       ->BE = ->BC + ->CE
  //     etc. Les élèves détaillent.
  //
  // On va les guider vers le critère "deux côtés opposés égaux et parallèles".

  // === Rendu SVG ===

  // On veut remplir visuellement les parallélogrammes DONNÉS (ABCD et CDEF),
  // mais PAS ABFE (celui-là ils doivent le "découvrir").
  const pts = {A,B,C,D,E,F};

  const filledPolys = [
    ['A','B','C','D'],   // ABCD (donné)
    ['C','D','F','E']    // CDEF (donné)
  ];

  // segments à tracer (contours)
  const segs = [
    // ABCD
    ['A','B'],['B','C'],['C','D'],['D','A'],
    // CDEF
    ['C','D'],['D','F'],['F','E'],['E','C'],
    // diagonales utiles visuellement (optionnel)
    ['A','C'],
    ['C','F']
  ];

  // on renvoie aussi l'énoncé et la correction texte
  const enonceHTML = `
    <div class="subhead" style="margin-bottom:.5rem">
      On considère les points suivants :
    </div>

    <div style="margin-left:1.2em; line-height:1.9">
      On sait que <strong>ABCD</strong> est un parallélogramme<br/>
      et que <strong>CDFE</strong> est un parallélogramme.
    </div>
  <div><br></div>
    <div>
           Montrer que <strong>ABEF</strong> est un parallélogramme.
        Justifier en utilisant des égalités de vecteurs.
    
    </div>
  `;

  const corrHTML = `
    <div class="steps">
      <div class="stepTitle">Correction</div>

      <div class="line">
        Comme \\(ABCD\\) est un parallélogramme, on sait que
        \\(\\overrightarrow{AB} = \\overrightarrow{DC}\\).
      </div>

      <div class="line">
        Comme \\(CDFE\\) est un parallélogramme, on sait que
        \\(\\overrightarrow{DC} = \\overrightarrow{FE}\\)
      </div>

      <div class="line">
        Donc \\(\\overrightarrow{AB} = \\overrightarrow{FE}\\).
             </div>

      <div class="line">
        Par conséquent, \\(ABEF\\) est un parallélogramme.
      </div>
    </div>
  `;

  return { pts, filledPolys, segs, enonceHTML, corrHTML };
}

/* ---------- rendu SVG sans quadrillage + anticollision labels ---------- */

function renderChainFigureSVG(st){
  const pts = st.pts;
  const names = Object.keys(pts);

  // cadre
  const xs = names.map(n=>pts[n].x);
  const ys = names.map(n=>pts[n].y);
  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  // marge pour respirer
  minX = Math.floor(minX)-1.5;
  maxX = Math.ceil(maxX)+1.5;
  minY = Math.floor(minY)-1.5;
  maxY = Math.ceil(maxY)+1.5;

  const w = maxX-minX || 1;
  const h = maxY-minY || 1;

  const pad = 20;
  const viewW = 360;
  const viewH = 260;

  const scale = ((viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  function toPix(P){
    const X = pad + (P.x-minX)*scale;
    const Y = pad + (maxY-P.y)*scale;
    return {X,Y};
  }

  // remplir les parallélogrammes donnés
  let fills = '';
  st.filledPolys.forEach(polyNames=>{
    const ptsAttr = polyNames.map(n=>{
      const P = toPix(pts[n]);
      return `${P.X.toFixed(1)},${P.Y.toFixed(1)}`;
    }).join(' ');
    fills += `
      <polygon points="${ptsAttr}"
               fill="rgba(200,150,100,0.08)"
               stroke="#c48a5a"
               stroke-width="1"
               stroke-linejoin="round" />
    `;
  });

  // tracer tous les segments utiles
  let segsSVG = '';
  st.segs.forEach(([Pname,Qname])=>{
    const P = toPix(pts[Pname]);
    const Q = toPix(pts[Qname]);
    segsSVG += `
      <line x1="${P.X.toFixed(1)}" y1="${P.Y.toFixed(1)}"
            x2="${Q.X.toFixed(1)}" y2="${Q.Y.toFixed(1)}"
            stroke="#222" stroke-width="1.4" />
    `;
  });

  // anticollision labels (même algo que tout à l'heure)
  const offsetPriority = [
    {dx:14, dy:4},
    {dx:-14,dy:4},
    {dx:0,  dy:-12},
    {dx:0,  dy:18},
    {dx:14, dy:-12},
    {dx:-14,dy:-12},
    {dx:14, dy:18},
    {dx:-14,dy:18}
  ];
  const placedBoxes=[];
  function boxesOverlap(a,b){
    const m=2;
    return !(a.x2 < b.x1-m ||
             a.x1 > b.x2+m ||
             a.y2 < b.y1-m ||
             a.y1 > b.y2+m);
  }
  function placeLabel(P){
    const estW=8, estH=12;
    for(const off of offsetPriority){
      const tx=P.X+off.dx;
      const ty=P.Y+off.dy;
      const box={x1:tx,y1:ty-12,x2:tx+estW,y2:ty};
      let ok=true;
      for(const b of placedBoxes){
        if(boxesOverlap(box,b)){ok=false;break;}
      }
      if(ok){ placedBoxes.push(box); return {tx,ty}; }
    }
    const tx=P.X, ty=P.Y+20;
    placedBoxes.push({x1:tx,y1:ty-12,x2:tx+8,y2:ty});
    return {tx,ty};
  }

  let ptsSVG = '';
  names.forEach(n=>{
    const P = toPix(pts[n]);
    const lab = placeLabel(P);
    ptsSVG += `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}"
              r="2.8" fill="#111"/>
      <text x="${lab.tx.toFixed(1)}" y="${lab.ty.toFixed(1)}"
            font-size="12"
            font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  });

  return `
    <svg viewBox="0 0 ${viewW} ${viewH}"
         width="${viewW}" height="${viewH}"
         style="border:1px solid #ccc;border-radius:6px;background:#fff;
                width:${viewW}px;max-width:${viewW}px;">
      ${fills}
      ${segsSVG}
      ${ptsSVG}
    </svg>
  `;
}

/* -------- bloc DOM de l'exercice 3 -------- */

function buildHostHTML_exo3(st){
  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 3 — Parallélogrammes et égalités de vecteurs</span>
      <table class="exo-layout-table">
        <tr>
          <td class="exo-q-col" style="width:60%;min-width:260px;">
            ${st.enonceHTML}
          </td>
          <td class="exo-fig-col" style="width:40%;min-width:240px;">
            <div class="figure-area" style="text-align:center;">
              ${renderChainFigureSVG(st)}
            </div>
          </td>
        </tr>
      </table>
    </div>
    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}

const EXO_PARAL = {
  id:'exo_vect_para',
  title:'Exercice 3 — Chaîne de parallélogrammes',
  gen(host){
    const st = genChainParallelogram();
    if(host){
      host.innerHTML = buildHostHTML_exo3(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    // rien à cocher ici
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <table class="exo-layout-table">
            <tr>
              <td class="exo-q-col" style="width:60%;min-width:260px;">
                ${st.corrHTML}
              </td>
              <td class="exo-fig-col" style="width:40%;min-width:240px;">
                <div class="figure-area" style="text-align:center;">
                  ${renderChainFigureSVG(st)}
                </div>
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){}
};













// registry
const REG = [EXO_TABLE, EXO_VF, EXO_PARAL];
window.REG = REG;
window.REGISTRY = REG;






/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);
function redrawStudentLayer(svg, st){
  const layer = svg.querySelector("#student-layer");
  if(!layer) return;

  // vider le layer
  layer.innerHTML = "";

  // pour chaque point déjà placé par l'élève, on le dessine
  if (!st.placedByStudent) return;
  for (const lbl of Object.keys(st.placedByStudent)){
    const {x,y} = st.placedByStudent[lbl];

    // projeter coord math -> pixel
    const minX  = parseFloat(svg.getAttribute("data-minx"));
    const maxY  = parseFloat(svg.getAttribute("data-maxy"));
    const scale = parseFloat(svg.getAttribute("data-scale"));
    const pad   = parseFloat(svg.getAttribute("data-pad"));

    const Xpix = pad + (x - minX)*scale;
    const Ypix = pad + (maxY - y)*scale;

    layer.innerHTML += `
      <circle cx="${Xpix.toFixed(1)}" cy="${Ypix.toFixed(1)}" r="3" fill="#b00020"/>
      <text x="${(Xpix+5).toFixed(1)}" y="${(Ypix-5).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#b00020">${lbl}</text>
    `;
  }
}

function attachInteractiveHandlers(){
  const host = $("#host");
  if(!host || !host.__state) return;
  const st = host.__state;

  const svg = host.querySelector("#fig-click");
  if(!svg) return;

  // init mémoire élève
  if(!st.placedByStudent){
    st.placedByStudent = {}; // ex {K:{x:...,y:...}, L:{...}, M:{...}}
  }
  st.activePoint = null;

  // Boutons K/L/M
  $$(".btn-place", host).forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const p = btn.getAttribute("data-point");
      st.activePoint = p; // active ce point
      // Optionnel : feedback visuel
      $$(".btn-place", host).forEach(b=>b.style.outline="none");
      btn.style.outline="2px solid #b00020";
    }, {passive:true});
  });

  // Clic sur le SVG pour poser/déplacer le point actif
  svg.addEventListener("click", (evt)=>{
    if(!st.activePoint) return; // aucun point sélectionné

    // récup conversion pixel -> math
    const bbox  = svg.getBoundingClientRect();
    const pad   = parseFloat(svg.getAttribute("data-pad"));
    const scale = parseFloat(svg.getAttribute("data-scale"));
    const minX  = parseFloat(svg.getAttribute("data-minx"));
    const maxY  = parseFloat(svg.getAttribute("data-maxy"));

    const relX = evt.clientX - bbox.left;
    const relY = evt.clientY - bbox.top;

    const xMath = ((relX - pad)/scale) + minX;
    const yMath = maxY - ((relY - pad)/scale);

    // snap aux entiers
    const xSnap = Math.round(xMath);
    const ySnap = Math.round(yMath);

    // on stocke pour ce label
    st.placedByStudent[st.activePoint] = {x:xSnap, y:ySnap};

    // redraw
    redrawStudentLayer(svg, st);
  }, {passive:true});
}


/* =========================================================
   ADAPTATEUR PDF
   -------------------------------------------------
   On reprend ton système : ExoPDF.init(...) + beforeGen,
   beforeRender refait un rendu LaTeX propre en SVG.
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try {
          st = JSON.parse(hostTmp.dataset.state || '{}');
        } catch(_){}
        return st;
      },

      // version adaptée pour cet exo :
      beforeRender(def, st, withSolutions){
  return (async () => {
    let host = null;
    try {
      host = document.createElement('div');
      host.id = 'pdf-host';
      host.style.position='fixed';
      host.style.left='-10000px';
      host.style.top='-10000px';
      document.body.appendChild(host);

      // Construire le bloc énoncé pour le PDF selon l'exo :
      let enonceHTML = '';
      if (def.id === 'exo_vect_table') {
        // Recréer l'énoncé sans les <select>
        const headCols = (st.cols||[])
          .map(c=>`<th style="text-align:center;">${c.title}</th>`)
          .join('');

        const rowsNoInput = [
          {lab:'ont la même direction'},
          {lab:'ont le même sens'},
          {lab:'ont la même longueur'},
          {lab:'sont égaux'},
          {lab:'sont opposés'}
        ].map(r=>{
          const tds = (st.cols||[]).map(()=>`<td style="text-align:center"></td>`).join('');
          return `<tr><td>${r.lab}</td>${tds}</tr>`;
        }).join('');

        enonceHTML = `
          <div class="exo-block">
            <span class="exo-title">Exercice 1 — Vecteurs : comparaison</span>
            <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
              <tr>
                <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                  <div style="text-align:center;">${st.figureSVG||''}</div>
                </td>
                <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                  <div class="subhead">Compléter le tableau en répondant par oui ou non.</div>
                  <table class="table" style="width:100%">
                    <tr>
                      <th>Les vecteurs</th>
                      ${headCols}
                    </tr>
                    ${rowsNoInput}
                  </table>
                </td>
              </tr>
            </table>
          </div>
        `;
      } else {
        // def.id === 'exo_vect_vf'
        // Recréer l'énoncé VF sans <select>
        const tfLines = (st.tf||[]).map(o=>{
          return `<div class="line"><strong>${o.label}</strong> ${o.stmt} : </div>`;
        }).join('');

        enonceHTML = `
          <div class="exo-block">
            <span class="exo-title">Exercice 2 — Vecteurs : Vrai / Faux</span>
            <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
              <tr>
                <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                  <div style="text-align:center;">${st.figureSVG||''}</div>
                </td>
                <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                  <div class="subhead">Dire si chaque affirmation est vraie ou fausse.</div>
                  <div style="margin-left:1.2em;">
                    ${tfLines}
                  </div>
                </td>
              </tr>
            </table>
          </div>
        `;
      }

      // Correction PDF si withSolutions
      let corrHTML = '';
      if (withSolutions){
        if (def.id === 'exo_vect_table'){
          corrHTML = `
            <div style="margin-top:1rem;">
              <div class="exo-block">
                <span class="exo-title">Correction</span>
                <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
                  <tr>
                    <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                      <div style="text-align:center;">${st.figureSVG||''}</div>
                    </td>
                    <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                      ${st.truthsTableHTML||''}
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          `;
        } else {
          corrHTML = `
            <div style="margin-top:1rem;">
              <div class="exo-block">
                <span class="exo-title">Correction</span>
                <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
                  <tr>
                    <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                      <div style="text-align:center;">${st.figureSVG||''}</div>
                    </td>
                    <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                      ${st.tfCorrHTML||''}
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          `;
        }
      }

      // On injecte les deux blocs dans l'iframe pour conversion MathJax SVG
      const iframe = document.createElement('iframe');
      iframe.style.position='fixed';
      iframe.style.left='-10000px';
      iframe.style.top='-10000px';
      iframe.style.width='0';
      iframe.style.height='0';
      iframe.style.visibility='hidden';
      document.body.appendChild(iframe);

      const iwin = iframe.contentWindow;
      const idoc = iframe.contentDocument;

      idoc.open();
      idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
      idoc.close();

      const contentDiv = idoc.getElementById('content');
      contentDiv.innerHTML = enonceHTML + corrHTML;

      // purge des vieux mjx éventuels
      contentDiv.querySelectorAll('mjx-container').forEach(mjx=>{
        mjx.replaceWith(mjx.textContent || '');
      });
      contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());

      const cfg = idoc.createElement('script');
      cfg.type = 'text/javascript';
      cfg.text = `
        window.MathJax = {
          tex: {
            inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
            displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
            processEscapes: true,
            packages: { '[+]': ['bbox','ams'] },
            macros: { vec: ['\\\\overrightarrow{#1}',1] }
          },
          svg: { fontCache: 'none' },
          options: { skipHtmlTags: ['script','noscript','style','textarea'] },
          startup: { typeset: false }
        };
      `;
      idoc.head.appendChild(cfg);

      const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
      const mj = idoc.createElement('script');
      mj.type = 'text/javascript';
      mj.src  = svgScriptURL;
      idoc.head.appendChild(mj);

      await new Promise(resolve=>{
        mj.onload = resolve;
        mj.onerror = resolve;
      });

      async function waitMathJaxReady(win){
        const limit=200;
        let n=0;
        while((!win.MathJax) || (!win.MathJax.typesetPromise && !win.MathJax.typeset)){
          await new Promise(res=>setTimeout(res,5));
          n++;
          if(n>limit) break;
        }
      }
      await waitMathJaxReady(iwin);

      if(iwin.MathJax && iwin.MathJax.typesetPromise){
        await iwin.MathJax.typesetPromise([ contentDiv ]);
      } else if(iwin.MathJax && iwin.MathJax.typeset){
        iwin.MathJax.typeset([ contentDiv ]);
      }

      // purge CHTML
      (function purgeCHTML(){
        contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n=>n.remove());
        contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n=>n.remove());
        contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());
      })();

      const finalHTML = contentDiv.innerHTML;

      iframe.remove();
      if(host) host.remove();

      return finalHTML;

    } catch(e){
      console.error('beforeRender SVG error:', e);

      // fallback minable mais sûr
      let fallbackHTML = '';
      if(host){
        fallbackHTML = (host.innerHTML || '');
        host.remove();
        host=null;
      }
      return fallbackHTML;
    }
  })();
}


    });
  });
})();

/* ===== mobile tweaks ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // champ focus mobile
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
