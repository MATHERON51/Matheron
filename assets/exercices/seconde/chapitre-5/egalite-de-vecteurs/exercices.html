<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äî Vecteurs : Translations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,
input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc correction / explications */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
@media (max-width:600px){
  .line{white-space:normal}
}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:var(--ok)}
.tick.ko{color:var(--ko)}

.answers{
  display:flex;
  flex-direction:column;
  flex-wrap:wrap;
  gap:.4rem .5rem;
  margin-top:.6rem;
}
.answers .qa-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.4rem;
}
.answers .qa-row label{
  flex:1 1 auto;
  min-width:260px;
}
.answers .qa-row input{
  flex:0 0 auto;
  min-width:60px;
  max-width:80px;
  text-transform:uppercase;
  text-align:center;
  font-weight:600;
}
@media print{ .controls{display:none !important;} }

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}
.enonce .subhead{
  font-weight:600;
  margin-top:.5rem;
}


.exo-layout-table{
  width:100%;
  border-collapse:collapse;
}

.exo-layout-table td{
  vertical-align:top;
  border:none;
  padding:8px 12px;
}

.exo-fig-col{
  width:240px;
  min-width:240px;
}

@media(max-width:700px){
  .exo-layout-table,
  .exo-layout-table tbody,
  .exo-layout-table tr,
  .exo-layout-table td{
    display:block;
    width:100%;
  }
  .exo-fig-col{
    width:auto;
    min-width:auto;
    margin-bottom:1rem;
  }
}
.table-yn{
  border:1px solid #d0d0d0;     /* ‚úÖ contour externe visible */
  border-radius:8px;
  background:#fff;
  border-collapse:separate;     /* ‚úÖ on s√©pare pour garder le rayon + contour */
  border-spacing:0;             /* pas d‚Äôespace entre cellules */
  overflow:hidden;              /* les coins arrondis "coupent" l'int√©rieur */
}

.table-yn th,
.table-yn td{
  border:1px solid #e5e5e5;     /* traits internes des cases */
  padding:6px 8px;
  vertical-align:top;
}

.table-yn th{
  background:#f9f9fa;
  text-align:left;
  font-weight:600;
}


</style>

<!-- ‚≠ê MATHJAX CONFIG CHTML -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>Seconde ‚Äì Vecteurs : Translation</strong>
  </h1>
</div>

<div class="wrap">
  <!-- barre de contr√¥le -->
  <div class="controls card">
    <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
    <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
    <button id="btn-solution" class="btn">üí° Solution</button>
    <button id="btn-reset" class="btn">üßπ R√©initialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <!-- zone exo -->
  <div class="card" id="host"></div>

  <!-- bloc aide saisie -->
  <div class="card small">
    <strong>Saisie &amp; r√©ponses accept√©es :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>R√©pondre par la lettre du point image (exemple : <code>A</code>, <code>B</code>, <code>G</code>...).</li>
      <li>La casse n‚Äôa pas d‚Äôimportance (<code>a</code> = <code>A</code>).</li>
      <li>On ne demande jamais les coordonn√©es, juste le nom du point obtenu par la translation.</li>
    </ul>
  </div>

  <!-- clavier math -->
  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- D√©pendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ===== Utils DOM / score ===== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }

/* ===== random helpers ===== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* =========================================================
   G√âOM√âTRIE / FIGURES DE R√âF√âRENCE POUR L'EXERCICE 1
   -------------------------------------------------
   On stocke 20 "figures". Chaque figure :
   - name: identifiant technique
   - pts: {A:{x:..,y:..},B:{...},...}
   Les positions servent uniquement √† v√©rifier les translations:
      la translation qui envoie P->Q est le vecteur Q-P.
   On peut donc en d√©duire l'image de n'importe quel autre point R :
      R + (Q-P).

   Les lettres utilis√©es sont coh√©rentes avec ce qu'on affiche.
   On reste en grande majorit√© sur des lettres A,B,C,D,E,F,G,H,...
   (IMPORTANT: Toutes distinctes)
   ========================================================= */

function vecAdd(p,v){
  return {x:p.x+v.x, y:p.y+v.y};
}
function vecDiff(p,q){
  return {x:q.x-p.x, y:q.y-p.y}; // vecteur p->q
}
function samePoint(p,q){
  const EPS = 1e-6;
  return (Math.abs(p.x - q.x) < EPS &&
          Math.abs(p.y - q.y) < EPS);
}

function checkPlacement(st){
  // s√©cu
  if (!st || !st.targetPts) return {count:0, good:0};

  const need = ["K","L","M"];

  let locTot = 0;
  let locOK  = 0;

  need.forEach(lbl=>{
    const tickEl = $('#tick-'+lbl);
    if(!tickEl) return;

    // pas plac√© ‚Üí neutre (rien affich√©)
    if(!st.placedByStudent || !st.placedByStudent[lbl]){
      tickEl.className = 'tick';
      tickEl.textContent = '';
      return;
    }

    const got = st.placedByStudent[lbl]; // {x,y} pos√© √©l√®ve
    const tar = st.targetPts[lbl];       // {x,y} attendu

    if(!tar){
      // pas de cible = neutre
      tickEl.className = 'tick';
      tickEl.textContent = '';
      return;
    }

    // l'√©l√®ve a cliqu√© quelque part -> on compte cette tentative
    locTot++;

    const ok = (Math.abs(got.x - tar.x) < 1e-9 &&
                Math.abs(got.y - tar.y) < 1e-9);

    if(ok) locOK++;

    tickEl.className = 'tick ' + (ok ? 'ok' : 'ko');
    tickEl.textContent = ok ? '‚úì' : '‚úó';
  });

  return {count:locTot, good:locOK};
}



function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function buildTripletsForFigure(pts){
  const letters = Object.keys(pts);

  const cands1 = []; // type 1
  const cands2 = []; // type 2

  // Type 1 : "La translation qui transforme P en Q, transforme R en ... "
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if (j===i) continue;
      for (let k=0; k<letters.length; k++){
        if (k===i || k===j) continue;
        const P = letters[i];
        const Q = letters[j];
        const R = letters[k];

        const ans = translatePoint(pts, P, Q, R);
        if(!ans) continue;
        // question text
        const text = `La translation qui transforme \\( \\) \\(${P}\\) \\( \\)en\\( \\) \\(${Q}\\), transforme \\( \\)\\(${R}\\) \\( \\)en ...`;

        cands1.push({
          text,
          ans
        });
      }
    }
  }

  // Type 2 : "La translation de vecteur \vec{XY} transforme R en ..."
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if (j===i) continue;
      for (let k=0; k<letters.length; k++){
        if (k===i || k===j) continue;
        const X = letters[i];
        const Y = letters[j];
        const R = letters[k];

        const ans = translatePoint(pts, X, Y, R);
        if(!ans) continue;
        const text = `La translation de vecteur \\( \\) \\(\\overrightarrow{${X}${Y}}\\) \\( \\) transforme \\( \\)  \\(${R}\\) \\( \\) en ...`;

        cands2.push({
          text,
          ans
        });
      }
    }
  }

  return { cands1, cands2 };
}


// figure builder util: r√©gulier n-gone centr√©, + points sp√©ciaux
function regularPolygonPoints(n, radius, cx, cy, labels){
  const pts={};
  for(let i=0;i<n;i++){
    const ang = 2*Math.PI*i/n - Math.PI/2;
    const x = cx + Math.round(radius*Math.cos(ang));
    const y = cy + Math.round(radius*Math.sin(ang));
    pts[labels[i]]={x,y};
  }
  return pts;
}

// BANK_FIGURES : ~20 variantes
const BANK_FIGURES = [];

// 1. hexagone + diagonales fa√ßon "√©toile" (style de ton losange/√©toile)
BANK_FIGURES.push({
  name:"etoile_hex",
  pts:{
    A:{x:-2,y:0},
    B:{x:0,y:2},
    C:{x:2,y:0},
    D:{x:1,y:-2},
    E:{x:-1,y:-2},
    F:{x:0,y:0},   // centre
    G:{x:2,y:2},
    H:{x:-2,y:2}
  }
});

// 2. rectangle 3x2 maill√© en croix
BANK_FIGURES.push({
  name:"rect_croix",
  pts:{
    A:{x:0,y:0},
    B:{x:3,y:0},
    C:{x:3,y:2},
    D:{x:0,y:2},
    E:{x:1.5,y:1},
    F:{x:1.5,y:2},
    G:{x:1.5,y:0},
    H:{x:0,y:1},
    I:{x:3,y:1}
  }
});

// 3. losange vertical
BANK_FIGURES.push({
  name:"losange",
  pts:{
    A:{x:0,y:2},
    B:{x:2,y:0},
    C:{x:0,y:-2},
    D:{x:-2,y:0},
    E:{x:0,y:0},
    F:{x:2,y:2},
    G:{x:-2,y:-2}
  }
});

// 4. maison pentagone (toit triangle + base rectangle)
BANK_FIGURES.push({
  name:"maison",
  pts:{
    A:{x:-2,y:0},
    B:{x:2,y:0},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:1.5}, // fa√Æte du toit
    F:{x:0,y:-2},
    G:{x:-2,y:1.5},
    H:{x:2,y:1.5}
  }
});

// 5. octogone r√©gulier
BANK_FIGURES.push({
  name:"octogone",
  pts: regularPolygonPoints(
    8, // n
    3, // rayon
    0,0,
    ['A','B','C','D','E','F','G','H']
  )
});

// 6. carr√© + centre + milieux
BANK_FIGURES.push({
  name:"carre_plus",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:0},
    F:{x:0,y:2},
    G:{x:2,y:0},
    H:{x:0,y:-2},
    I:{x:-2,y:0}
  }
});

// 7. trap√®ze isoc√®le + diagonales
BANK_FIGURES.push({
  name:"trapeze",
  pts:{
    A:{x:-3,y:2},
    B:{x:3,y:2},
    C:{x:2,y:-1},
    D:{x:-2,y:-1},
    E:{x:0,y:2},
    F:{x:0,y:-1},
    G:{x:2,y:2},
    H:{x:-2,y:2}
  }
});

// 8. triangle + son homoth√©tie interne
BANK_FIGURES.push({
  name:"double_triangle",
  pts:{
    A:{x:-3,y:-1},
    B:{x:3,y:-1},
    C:{x:0,y:3},
    D:{x:-1,y:0.33},
    E:{x:1,y:0.33},
    F:{x:0,y:1.66}
  }
});

// 9. rectangle long + points milieu chaque c√¥t√©
BANK_FIGURES.push({
  name:"rect_long",
  pts:{
    A:{x:-4,y:1},
    B:{x:4,y:1},
    C:{x:4,y:-1},
    D:{x:-4,y:-1},
    E:{x:0,y:1},
    F:{x:4,y:0},
    G:{x:0,y:-1},
    H:{x:-4,y:0}
  }
});

// 10. pentagone r√©gulier
BANK_FIGURES.push({
  name:"penta",
  pts: regularPolygonPoints(
    5,
    3,
    0,0,
    ['A','B','C','D','E']
  )
});

// 11. hexagone r√©gulier
BANK_FIGURES.push({
  name:"hexa",
  pts: regularPolygonPoints(
    6,
    3,
    0,0,
    ['A','B','C','D','E','F']
  )
});

// 12. "√©toile" type losange+points ext
BANK_FIGURES.push({
  name:"etoile2",
  pts:{
    A:{x:0,y:3},
    B:{x:2,y:1},
    C:{x:3,y:0},
    D:{x:2,y:-1},
    E:{x:0,y:-3},
    F:{x:-2,y:-1},
    G:{x:-3,y:0},
    H:{x:-2,y:1},
    I:{x:0,y:0}
  }
});

// 13. Z quadrill√© (genre r√©seau en escalier)
BANK_FIGURES.push({
  name:"zigzag",
  pts:{
    A:{x:-3,y:2},
    B:{x:-1,y:2},
    C:{x:1,y:0},
    D:{x:3,y:0},
    E:{x:1,y:-2},
    F:{x:-1,y:-2}
  }
});

// 14. double carr√© imbriqu√©
BANK_FIGURES.push({
  name:"double_square",
  pts:{
    A:{x:-3,y:3},
    B:{x:3,y:3},
    C:{x:3,y:-3},
    D:{x:-3,y:-3},
    E:{x:-1,y:1},
    F:{x:1,y:1},
    G:{x:1,y:-1},
    H:{x:-1,y:-1}
  }
});

// 15. rectangle + diagonales internes en X + point centre
BANK_FIGURES.push({
  name:"rect_X",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:0}
  }
});

// 16. parall√©logramme simple
BANK_FIGURES.push({
  name:"para1",
  pts:{
    A:{x:-2,y:1},
    B:{x:2,y:1},
    C:{x:3,y:-2},
    D:{x:-1,y:-2},
    E:{x:0,y:-0.5}
  }
});

// 17. autre parall√©logramme (plus aplati)
BANK_FIGURES.push({
  name:"para2",
  pts:{
    A:{x:-3,y:2},
    B:{x:2,y:2},
    C:{x:4,y:0},
    D:{x:-1,y:0},
    E:{x:0,y:1}
  }
});

// 18. escalier 3 niveaux
BANK_FIGURES.push({
  name:"esc2",
  pts:{
    A:{x:-2,y:2},
    B:{x:0,y:2},
    C:{x:0,y:1},
    D:{x:2,y:1},
    E:{x:2,y:-1},
    F:{x:-2,y:-1}
  }
});

// 19. trap√®ze + point milieu grandes bases
BANK_FIGURES.push({
  name:"trap2",
  pts:{
    A:{x:-4,y:2},
    B:{x:4,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:2},
    F:{x:0,y:-2}
  }
});

// 20. couronne carr√©e tournante (carr√© + carr√© tourn√©)
BANK_FIGURES.push({
  name:"carre_rot",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:3},
    F:{x:3,y:0},
    G:{x:0,y:-3},
    H:{x:-3,y:0}
  }
});


/* =========================================================
   G√âN√âRATION √âNONC√â EXERCICE 1
   -------------------------------------------------
   On va :
   1. choisir une figure al√©atoire
   2. fabriquer un bloc d'√©nonc√© en deux parties :
      (1) "La translation qui transforme ... en ... transforme ... en ..."
      (2) "La translation de vecteur \vec{XY} transforme ... en ..."
   3. g√©n√©rer aussi les r√©ponses attendues
   ========================================================= */

function pickDistinctLetters(list, k){
  // renvoie k lettres distinctes prisent dans list
  const L=[...list];
  const out=[];
  while(out.length<k && L.length){
    const i = rnd(0,L.length-1);
    out.push(L.splice(i,1)[0]);
  }
  return out;
}

// Calcule image de R par la translation qui envoie P->Q
function translatePoint(pts, Pname, Qname, Rname){
  const P = pts[Pname];
  const Q = pts[Qname];
  const R = pts[Rname];
  if(!P||!Q||!R) return null;
  const v = vecDiff(P,Q); // vecteur P->Q = Q - P
  const Rimg = vecAdd(R,v); // R + v
  // retrouver la lettre S telle que pts[S] == Rimg
  for(const k in pts){
    if(samePoint(pts[k], Rimg)) return k;
  }
  return null; // pas trouv√© = devrait pas arriver si figure coh√©rente
}

// fabrique un petit paquet de questions style 1.a ... 1.e
function makeBlockType1(pts){
  const letters = Object.keys(pts);
  const nbq = Math.min(5, letters.length-2);
  const qs=[];
  let tries = 0;

  for (let i=0; i<nbq && tries<100; i++){
    tries++;

    const trip = pickDistinctLetters(letters,3);
    if(trip.length<3) break;
    const [P,Q,R] = trip;

    const ans = translatePoint(pts,P,Q,R);
    if(!ans){
      // pas de i--
      continue;
    }
    qs.push({
      text:`La translation qui transforme \\(${P}\\) en \\(${Q}\\), transforme \\(${R}\\) en ...`,
      ans: ans
    });
  }
  return qs;
}



// fabrique un paquet de questions style 2.a ... 2.d
function makeBlockType2(pts){
  const letters = Object.keys(pts);
  const nbq = Math.min(4, letters.length-2);
  const qs=[];
  let tries = 0;

  for (let i=0; i<nbq && tries<100; i++){
    tries++;

    const pair = pickDistinctLetters(letters,2);
    if(pair.length<2) break;
    const [X,Y]=pair;

    let R = choice(letters.filter(L=>L!==X && L!==Y));
    const ans = translatePoint(pts,X,Y,R);
    if(!ans){
      continue;
    }
    qs.push({
      text:`La translation de vecteur \\(\\overrightarrow{${X}${Y}}\\) transforme \\(${R}\\) en ...`,
      ans: ans
    });
  }
  return qs;
}


// transforme les coords "math" pts{name:{x,y}} en un petit SVG centr√©
function buildFigureSVG(pts){
  // 1. r√©cup√®re limites
  const names = Object.keys(pts);
  const xs = names.map(n=>pts[n].x);
  const ys = names.map(n=>pts[n].y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  const w = maxX - minX || 1;
  const h = maxY - minY || 1;

  // marge en px dans le viewport final
  const pad = 20;
  const viewW = 200;
  const viewH = 200;

  // facteur d'√©chelle : on veut que tout tienne dans 200x200 avec marge
  const scale =  ( (viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  // fonction pour convertir coord => pixel
  function toPix(p){
    const X = pad + (p.x - minX)*scale;
    // attention Y : le SVG a l'axe y vers le bas
    const Y = pad + (maxY - p.y)*scale;
    return {X,Y};
  }

  // on va dessiner :
  // - segments reliant les points dans l'ordre alphab√©tique (rapide)
  // - un point + label pour chaque lettre
  // NOTE: si tu veux des segments plus "intelligents"
  // (par exemple suivre une forme pr√©d√©finie par figure),
  // on pourra ajouter dans BANK_FIGURES un champ edges:[["A","B"],["B","C"],...]
  // Pour l'instant, je vais relier A->B->C->...->A si >=3 points.
  let edges = [];
  if(names.length >= 3){
    const sorted = [...names].sort();
    for(let i=0;i<sorted.length-1;i++){
      edges.push([sorted[i], sorted[i+1]]);
    }
    edges.push([sorted[sorted.length-1], sorted[0]]);
  }

  // build <line> for edges
  let linesSVG = edges.map(([p1,p2])=>{
    const P1 = toPix(pts[p1]);
    const P2 = toPix(pts[p2]);
    return `<line x1="${P1.X.toFixed(1)}" y1="${P1.Y.toFixed(1)}"
                  x2="${P2.X.toFixed(1)}" y2="${P2.Y.toFixed(1)}"
                  stroke="#555" stroke-width="1.2" />`;
  }).join("");

  // build <circle> + <text> for points
  let ptsSVG = names.map(n=>{
    const P = toPix(pts[n]);
    return `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(P.X+5).toFixed(1)}" y="${(P.Y-5).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  }).join("");

  const svg = `
    <svg viewBox="0 0 ${viewW} ${viewH}"
         width="220" height="220"
         style="border:1px solid #ccc;border-radius:6px;background:#fff;margin:8px 0 16px 0;">
      ${linesSVG}
      ${ptsSVG}
    </svg>
  `;
  return svg;
}


function computeLayout(pts, extraPts){
  const baseNames = Object.keys(pts);
  const xs = baseNames.map(n=>pts[n].x);
  const ys = baseNames.map(n=>pts[n].y);

  if (extraPts){
    for (const k in extraPts){
      xs.push(extraPts[k].x);
      ys.push(extraPts[k].y);
    }
  }

  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  // marge g√©n√©reuse autour (2 unit√©s d√©j√† c‚Äô√©tait limite, on garde 2 ? tu dis que le quadrillage
  // n'√©tait pas assez grand -> on va la monter √† 3 pour √™tre safe partout)
  minX = Math.floor(minX) - 3;
  maxX = Math.ceil(maxX) + 3;
  minY = Math.floor(minY) - 3;
  maxY = Math.ceil(maxY) + 3;

  const w = maxX - minX || 1;
  const h = maxY - minY || 1;

  const pad = 20;
  const viewW = 450; // plus large
  const viewH = 450;

  const scale = ((viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  function toPixXY(x,y){
    const X = pad + (x - minX)*scale;
    const Y = pad + (maxY - y)*scale; // rep√®re math
    return {X,Y};
  }
  function toPix(p){ return toPixXY(p.x,p.y); }

  return {
    minX,maxX,minY,maxY,
    pad,viewW,viewH,scale,
    toPix,toPixXY
  };
}



function renderFigureSVG(layout, pts, extraPtsToShow, opts){
  const {
    minX,maxX,minY,maxY,
    pad,viewW,viewH,scale,
    toPix
  } = layout;
  const baseNames = Object.keys(pts);

  // 1. limites r√©elles de la figure (sans marge artificielle)
  const baseXs = baseNames.map(n=>pts[n].x);
  const baseYs = baseNames.map(n=>pts[n].y);
  const figMinX = Math.min(...baseXs);
  const figMaxX = Math.max(...baseXs);
  const figMinY = Math.min(...baseYs);
  const figMaxY = Math.max(...baseYs);

  // 2. pour savoir si on est "vraiment" sur un bord :
  //    tol√©rance tr√®s petite (strict √©galit√© suffit si coords enti√®res)
  function chooseLabelDir(p){
    const onLeft   = p.x === figMinX;
    const onRight  = p.x === figMaxX;
    const onBottom = p.y === figMinY;
    const onTop    = p.y === figMaxY;

    // priorit√© horizontale: si c'est extr√™me gauche ou droite ‚Üí on met gauche/droite
    if (onLeft && !onRight)   return "left";
    if (onRight && !onLeft)   return "right";

    // sinon, priorit√© verticale: haut ou bas
    if (onTop && !onBottom)   return "top";
    if (onBottom && !onTop)   return "bottom";

    // sinon point int√©rieur
    return "inside";
  }

  function dirToOffset(dir){
    switch(dir){
      case "left":   return {dx:-14, dy:4};
      case "right":  return {dx:14,  dy:4};
      case "top":    return {dx:0,   dy:-12};
      case "bottom": return {dx:0,   dy:18};
      case "inside": return {dx:0,   dy:18};
    }
  }

  // ===== grille =====
  const gridLines = [];
  for(let X=minX; X<=maxX; X++){
    const p1 = toPix({x:X,y:minY});
    const p2 = toPix({x:X,y:maxY});
    gridLines.push(
      `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
             x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
             stroke="#ddd" stroke-width="0.6" />`
    );
  }
  for(let Y=minY; Y<=maxY; Y++){
    const p1 = toPix({x:minX,y:Y});
    const p2 = toPix({x:maxX,y:Y});
    gridLines.push(
      `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
             x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
             stroke="#ddd" stroke-width="0.6" />`
    );
  }

  // ===== segments de la figure =====
  // Toujours notre "ordre alphab√©tique ferm√©" pour l‚Äôinstant
  let edges = [];
  if(baseNames.length >= 3){
    const sorted = [...baseNames].sort();
    for(let i=0;i<sorted.length-1;i++){
      edges.push([sorted[i], sorted[i+1]]);
    }
    edges.push([sorted[sorted.length-1], sorted[0]]);
  }
  const polyLines = edges.map(([p1,p2])=>{
    const P1 = toPix(pts[p1]);
    const P2 = toPix(pts[p2]);
    return `<line x1="${P1.X.toFixed(1)}" y1="${P1.Y.toFixed(1)}"
                  x2="${P2.X.toFixed(1)}" y2="${P2.Y.toFixed(1)}"
                  stroke="#444" stroke-width="1.4" />`;
  }).join("");

  // ===== points de base (A,B,C,...) =====
  const basePtsSVG = baseNames.map(n=>{
    const mathP = pts[n];
    const P = toPix(mathP);

    const dir = chooseLabelDir(mathP);
    const {dx,dy} = dirToOffset(dir);

    return `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(P.X+dx).toFixed(1)}" y="${(P.Y+dy).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  }).join("");

  // ===== points de correction K,L,M (rouge) =====
  let extraSVG = "";
  if (extraPtsToShow){
    Object.keys(extraPtsToShow).forEach(n=>{
      const mathP = extraPtsToShow[n];
      const P = toPix(mathP);

      // Pour K,L,M en correction on applique la m√™me logique d'ext√©rieur.
      // (√ßa les met aussi proprement dehors)
      const dir = chooseLabelDir(mathP);
      const {dx,dy} = dirToOffset(dir);

      extraSVG += `
        <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#b00020"/>
        <text x="${(P.X+dx).toFixed(1)}" y="${(P.Y+dy).toFixed(1)}"
              font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
              fill="#b00020">${n}</text>
      `;
    });
  }

  const clickable = opts && opts.interactive ? 'style="cursor:crosshair;touch-action:none;"' : '';

  const dataAttr =
    `data-minx="${minX}" data-maxy="${maxY}" data-scale="${scale}" data-pad="${pad}"`;

  return `
  <svg id="fig-click"
       ${dataAttr}
       viewBox="0 0 ${viewW} ${viewH}"
       width="${viewW}" height="${viewH}"
       ${clickable}
       style="border:1px solid #ccc;border-radius:6px;background:#fff;margin:8px 0 16px 0;
              width:${viewW}px; height:${viewH}px; max-width:${viewW}px; max-height:${viewH}px;">
    ${gridLines.join("")}
    ${polyLines}
    ${basePtsSVG}
    <g id="student-layer"></g>
    ${extraSVG}
  </svg>
`;

}






function buildPlacementTriples(pts){
  const letters = Object.keys(pts);

  // fabrique toutes les constructions possibles O + (V-U)
  // retourne {fromO: 'C', fromU:'E', fromV:'F', newName:'K', O, U, V, T:{x,y}, textLatex:"CK = EF"}
  const builds = [];
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if(j===i) continue;
      for (let k=0; k<letters.length; k++){
        if(k===i || k===j) continue;

        const Oname = letters[i]; // origine (ex: C)
        const Uname = letters[j]; // donne vecteur U->V
        const Vname = letters[k];

        // vecteur U->V
        const v = vecDiff(pts[Uname], pts[Vname]); // careful: vecDiff(p,q) = q - p, i.e. p->q
        // on veut O + (V - U)
        const T = vecAdd(pts[Oname], v);

        // V√©rifier si T correspond d√©j√† √† un point existant -> on veut NOUVEAU point
        let isNew = true;
        for(const L of letters){
          if (samePoint(pts[L], T)){
            isNew = false;
            break;
          }
        }
        if(!isNew) continue;

        builds.push({
          Oname, Uname, Vname,
          T,
          // pour l'affichage latex ex: \overrightarrow{CK} = \overrightarrow{EF}
          // on remplit le nom final plus tard (K,L,M)
        });
      }
    }
  }
  return builds;
}


 function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function norm2(v){ return v.x*v.x+v.y*v.y; }
function sameVec(a,b){ return a.x===b.x && a.y===b.y; }
function collinear(a,b){
  // a || b  <=> a.x*b.y - a.y*b.x = 0
  return (a.x*b.y - a.y*b.x) === 0 && !(a.x===0 && a.y===0) && !(b.x===0 && b.y===0);
}
function sameDirection(a,b){
  if(!collinear(a,b)) return false;
  // m√™me sens si a = k b avec k>0
  // tester signe scalaire a¬∑b > 0
  return (a.x*b.x + a.y*b.y) > 0;
}
function oppositeDirection(a,b){
  if(!collinear(a,b)) return false;
  // sens oppos√©s si a¬∑b < 0
  return (a.x*b.x + a.y*b.y) < 0;
}
function sameLength(a,b){ return norm2(a) === norm2(b); }

function allDirectedPairs(pts){
  const names = Object.keys(pts);
  const out=[];
  for(let i=0;i<names.length;i++){
    for(let j=0;j<names.length;j++){
      if(j===i) continue;
      const A=names[i], B=names[j];
      const v={x:pts[B].x-pts[A].x, y:pts[B].y-pts[A].y};
      out.push({A,B,v, label:`\\(\\overrightarrow{${A}${B}}\\)`});
    }
  }
  return out;
}

function pickPairsForTable(vecs){
  // On veut 4 colonnes correspondant √† 4 "situations-types".
  // Puis on m√©lange l'ordre avant de renvoyer.

  // G√©n√®re toutes les paires ordonn√©es (u,w) avec u != w
  const pairs = [];
  for (let i=0; i<vecs.length; i++){
    for (let j=0; j<vecs.length; j++){
      if(i===j) continue;
      pairs.push([vecs[i], vecs[j]]);
    }
  }

  // helper : renvoie la premi√®re paire qui v√©rifie un pr√©dicat sur truthFor
  function findPairByProfile(testFn){
    const sh = shuffle(pairs);
    for(const [u,w] of sh){
      const t = truthFor(u.v, w.v);
      if (testFn(t)) {
        return {u,w,t};
      }
    }
    return null;
  }

  // PROFIL 1 : vecteurs √©gaux
  const col_equal = findPairByProfile(t => t.tEqual);

  // PROFIL 2 : vecteurs oppos√©s
  const col_opposite = findPairByProfile(t => t.tOpposite);

  // PROFIL 3 : m√™me direction, m√™me sens, pas la m√™me longueur
  // => tSameDir = true, tSameSens = true, tSameLen = false
  const col_sameDirSameSensDiffLen = findPairByProfile(t =>
    t.tSameDir && t.tSameSens && !t.tSameLen
    // (tEqual est forc√©ment false dans ce cas)
  );

  // PROFIL 4 : pas la m√™me direction (donc pas colin√©aires),
  //            pas le m√™me sens,
  //            m√™me longueur
  // => tSameDir = false, tSameLen = true
  const col_diffDirSameLen = findPairByProfile(t =>
    !t.tSameDir && t.tSameLen
  );

  // Maintenant on collecte ceux qu'on a trouv√©s
  let wantedCols = [];
  if (col_equal)                  wantedCols.push({kind:'equal',     ...col_equal});
  if (col_opposite)               wantedCols.push({kind:'opposite',  ...col_opposite});
  if (col_sameDirSameSensDiffLen) wantedCols.push({kind:'sameDirSS', ...col_sameDirSameSensDiffLen});
  if (col_diffDirSameLen)         wantedCols.push({kind:'diffDirSL', ...col_diffDirSameLen});

  // Si la figure ne permet pas d'avoir les 4 profils (√ßa peut arriver),
  // on compl√®te avec des paires quelconques pour rester √† 4 colonnes.
  if (wantedCols.length < 4){
    const sh = shuffle(pairs);
    for (const [u,w] of sh){
      if (wantedCols.length >= 4) break;
      const already = wantedCols.some(c=>(c.u===u && c.w===w) || (c.u===w && c.w===u));
      if(!already){
        wantedCols.push({kind:'misc', u, w, t: truthFor(u.v,w.v)});
      }
    }
  }

  // Coupe √† 4 et m√©lange l'ordre final
  wantedCols = shuffle(wantedCols.slice(0,4));

  // Formatage final identique √† avant pour que le reste du code ne change pas
  return wantedCols.map((col,idx)=>{
    const {u,w,t} = col;

    return {
      type: col.kind,
      u, w,
      title:`${u.label} \\( \\) et  \\( \\) ${w.label}`,
      truths: {
        // on renvoie exactement les bool√©ens attendus par la suite
        tSameDir:    t.tSameDir,
        // ATTENTION : pour la ligne "ont le m√™me sens" dans le tableau,
        // on veut bien tSameSens (et pas "m√™me direction && !opp")
        tSameSens:   t.tSameSens,
        tSameLen:    t.tSameLen,
        tEqual:      t.tEqual,
        tOpposite:   t.tOpposite
      },
      ids:{
        sameDir:   `c${idx}_dir`,
        sameSens:  `c${idx}_sens`,
        sameLen:   `c${idx}_len`,
        equal:     `c${idx}_eq`,
        opposite:  `c${idx}_op`
      }
    };
  });
}


function truthFor(a,b){
  // m√™me direction = colin√©aires (peu importe le sens)
  const tSameDir = collinear(a,b);

  // m√™me sens = colin√©aires ET produit scalaire > 0
  // => dans notre code sameDirection(a,b) fait d√©j√† exactement √ßa
  const tSameSens = sameDirection(a,b);

  // m√™me longueur
  const tSameLen = sameLength(a,b);

  // √©gaux = m√™me direction, m√™me sens, m√™me longueur
  // dans notre code sameVec(a,b) teste exactement l'√©galit√©
  const tEqual = sameVec(a,b);

  // oppos√©s = m√™me direction, sens oppos√©s, m√™me longueur
  // oppositeDirection(a,b) = colin√©aires ET sens oppos√©
  const tOpposite = oppositeDirection(a,b) && tSameLen;

  return {
    tSameDir,     // colin√©aires ?
    tSameSens,    // m√™me sens ?
    tSameLen,     // m√™me longueur ?
    tEqual,       // √©gaux ?
    tOpposite     // oppos√©s ?
  };
}

function tfStatements(vecs){
  // On va construire des affirmations de 4 types :
  //  - "sont √©gaux"
  //  - "sont oppos√©s"
  //  - "sont de sens oppos√©s"
  //  - "ont la m√™me longueur"

  // 1. lister toutes les paires (u,w) avec u != w
  const pairs = [];
  for (let i=0; i<vecs.length; i++){
    for (let j=0; j<vecs.length; j++){
      if(i===j) continue;
      const u = vecs[i], w = vecs[j];
      const t = truthFor(u.v, w.v); // {tSameDir,tSameSens,tSameLen,tEqual,tOpposite}

      // On pr√©pare les 4 phrases possibles pour cette paire :
      const candidates = [
        {
          labelType: 'equal',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) sont √©gaux`,
          truth: t.tEqual
        },
        {
          labelType: 'opposite',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) sont oppos√©s`,
          truth: t.tOpposite
        },
        {
          labelType: 'oppSense',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) sont de sens oppos√©s`,
          // "de sens oppos√©s" = oppositeDirection(a,b)
          truth: oppositeDirection(u.v, w.v)
        },
        {
          labelType: 'sameLen',
          stmt: `${u.label} \\( \\) et \\( \\) ${w.label} \\( \\) ont la m√™me longueur`,
          truth: t.tSameLen
        }
      ];

      pairs.push(...candidates);
    }
  }

  // 2. On classe par type de phrase ET par v√©rit√©
  //    ex: bucket['opposite'].true = [ {stmt, truth:true}, ... ]
  const bucket = {};
  function pushBucket(type, truthVal, obj){
    if(!bucket[type]) bucket[type] = {true:[], false:[]};
    bucket[type][truthVal ? 'true':'false'].push(obj);
  }

  for (const cand of pairs){
    pushBucket(cand.labelType, cand.truth, cand);
  }

  // 3. On essaie de construire une liste √©quilibr√©e :
  //    id√©alement pour chaque type, 1 vrai + 1 faux
  const finalList = [];
  let trueCount = 0;
  let falseCount = 0;

  const typesOrder = shuffle(['equal','opposite','oppSense','sameLen']); // randomise l'ordre des th√®mes

  // d'abord, on essaie d'ajouter pour chaque type un couple (vrai,faux) si possible
  for (const tp of typesOrder){
    const pack = bucket[tp];
    if(!pack) continue;

    // on pioche au hasard dedans pour varier
    const tTrueArr  = shuffle(pack.true);
    const tFalseArr = shuffle(pack.false);

    if (tTrueArr.length && tFalseArr.length){
      // on a les deux -> on prend un de chaque
      const candTrue  = tTrueArr[0];
      const candFalse = tFalseArr[0];

      finalList.push({stmt:candTrue.stmt, truth:true});
      finalList.push({stmt:candFalse.stmt, truth:false});
      trueCount++;
      falseCount++;
    }
  }

  // maintenant finalList contient par exemple 6 √©l√©ments (si certains types n'ont pas les deux cas)
  // objectif : arriver √† 8 √©l√©ments pile, avec 4 vrais / 4 faux
  // On va remplir en respectant l'√©quilibre.

  function tryAddFromBuckets(wantTruth){
    // wantTruth est true ou false
    const shuffledTypes = shuffle(Object.keys(bucket));
    for (const tp of shuffledTypes){
      const arr = shuffle(bucket[tp][wantTruth ? 'true':'false']);
      for (const cand of arr){
        // √©viter les doublons exacts de phrase
        if (finalList.some(x=>x.stmt===cand.stmt)) continue;
        finalList.push({stmt:cand.stmt, truth:wantTruth});
        if (wantTruth) trueCount++; else falseCount++;
        return true;
      }
    }
    return false;
  }

  // On boucle jusqu'√† avoir 8 ou plus (s√©curit√© anti boucle infinie : 200 it√©rations max)
  let guard = 0;
  while (finalList.length < 8 && guard < 200){
    guard++;

    // on veut tendre vers 4 vrais / 4 faux
    if (trueCount < 4){
      // on essaye d'ajouter un vrai
      if (!tryAddFromBuckets(true)){
        // si impossible, on tente quand m√™me un faux
        tryAddFromBuckets(false);
      }
    } else if (falseCount < 4){
      // on essaye d'ajouter un faux
      if (!tryAddFromBuckets(false)){
        // sinon, on tente un vrai
        tryAddFromBuckets(true);
      }
    } else {
      // les deux quotas sont d√©j√† atteints, on remplit ce qui manque
      // (devrait presque jamais arriver)
      if (!tryAddFromBuckets(true)){
        tryAddFromBuckets(false);
      }
    }
  }

  // si on en a pris plus de 8 par hasard, on coupe
  // mais en gardant l'√©quilibre le mieux possible
  // (finalList est en ordre de s√©lection, on m√©lange ensuite)
  if (finalList.length > 8){
    // strat√©gie simple : m√©lange puis on coupe 8
    // comme on a forc√© l'√©quilibre pendant la construction, 4/4 reste tr√®s probable
    finalList.splice(0, finalList.length, ...shuffle(finalList).slice(0,8));
  }

  // derni√®re √©tape : m√©lange pour ne pas avoir (vrai,faux) coll√©s par th√®me
  const shuffled = shuffle(finalList).slice(0,8);

  // on leur donne les labels a), b), c)...
  return shuffled.map((o,i)=>({
    label: String.fromCharCode(97+i)+')',
    stmt:  o.stmt,
    truth: o.truth,
    id:    `tf_${i}`
  }));
}


function genCommonVecteurs(){
  let attempt=0;
  while(attempt<40){
    attempt++;
    const fig = choice(BANK_FIGURES);
    const pts = fig.pts;

    // besoin d'assez de points pour √™tre int√©ressant
    if(Object.keys(pts).length < 6) continue;

    // figure (m√™me layout pour les deux exos)
    const layout = computeLayout(pts, null);
    const figSVG = renderFigureSVG(layout, pts, null, {interactive:false});

    const vecs = allDirectedPairs(pts);
    if(vecs.length < 20) continue;

    // ===== 1) TABLEAU OUI/NON =====
    const cols = pickPairsForTable(vecs).map((it,idx)=>{
      const {u,w} = it;
      const truths = truthFor(u.v,w.v);
      return {
        title:`${u.label} \\( \\) et  \\( \\) ${w.label}`,
        truths,
        ids:{
          sameDir:   `c${idx}_dir`,
          sameSens:  `c${idx}_sens`,
          sameLen:   `c${idx}_len`,
          equal:     `c${idx}_eq`,
          opposite:  `c${idx}_op`
        }
      };
    });

    // correction du tableau (Oui / Non)
    function yn(b){ return b ? 'Oui' : 'Non'; }
    const tableHead = cols
      .map(c=>`<th style="text-align:center;">${c.title}</th>`)
      .join('');

    const solRows = [
      {lab:'ont la m√™me direction',  key:o=>yn(o.truths.tSameDir)},
      {lab:'ont le m√™me sens',       key:o=>yn(o.truths.tSameDir && !o.truths.tOppDir)},
      {lab:'ont la m√™me longueur',   key:o=>yn(o.truths.tSameLen)},
      {lab:'sont √©gaux',             key:o=>yn(o.truths.tEqual)},
      {lab:'sont oppos√©s',           key:o=>yn(o.truths.tOpposite)}
    ].map(r=>{
      const tds = cols.map(c=>`<td style="text-align:center">${r.key(c)}</td>`).join('');
      return `<tr><td>${r.lab}</td>${tds}</tr>`;
    }).join('');

    const truthsTableHTML = `
      <div class="steps">
        <div class="stepTitle">Correction ‚Äî Tableau</div>
<table class="table table-yn" style="width:100%">
          <tr>
            <th>Les vecteurs</th>
            ${tableHead}
          </tr>
          ${solRows}
        </table>
      </div>
    `;

    // ===== 2) VRAI / FAUX =====
    const tfList = tfStatements(vecs).map((o,i)=>({
      label: String.fromCharCode(97+i)+')',
      stmt:  o.stmt,
      truth: o.truth,
      id:    `tf_${i}`
    }));

    const tfCorrHTML = `
      <div class="steps">
        <div class="stepTitle">Correction ‚Äî Vrai / Faux</div>
        ${
          tfList.map(x=>
            `<div class="line"><strong>${x.label}</strong> ${x.stmt} \\( \\) : \\( \\) ${x.truth?'Vrai':'Faux'}</div>`
          ).join('')
        }
      </div>
    `;

    // tout ce qu'il faut pour les deux exos
    return {
      figureSVG: figSVG,
      cols,
      tf: tfList,
      truthsTableHTML,
      tfCorrHTML
    };
  }

  // ===== fallback si pas r√©ussi =====
  return {
    figureSVG:"<div style='color:#b00020;font-weight:600'>[Figure indisponible]</div>",
    cols:[],
    tf:[],
    truthsTableHTML:`<div class="steps">Aucune donn√©e (tableau)</div>`,
    tfCorrHTML:`<div class="steps">Aucune donn√©e (V/F)</div>`
  };
}







/* =========================================================
   RENDU DANS LE HOST POUR L'EXERCICE 1
   -------------------------------------------------
   Le bloc .exo-block reste celui de ta fiche.
   On va juste g√©n√©rer dynamiquement plusieurs <div class="qa-row">
   ========================================================= */

function buildHostHTML_exoTable(st){
  function selectYN(id){
    return `<select id="${id}" class="inp">
      <option value=""></option>
      <option>Oui</option>
      <option>Non</option>
    </select><span id="tick-${id}" class="tick"></span>`;
  }

  const headCols = st.cols
    .map(c=>`<th style="text-align:center;">${c.title}</th>`)
    .join('');

  const rows = [
    {lab:'ont la m√™me direction',  key:c=>selectYN(c.ids.sameDir)},
    {lab:'ont le m√™me sens',       key:c=>selectYN(c.ids.sameSens)},
    {lab:'ont la m√™me longueur',   key:c=>selectYN(c.ids.sameLen)},
    {lab:'sont √©gaux',             key:c=>selectYN(c.ids.equal)},
    {lab:'sont oppos√©s',           key:c=>selectYN(c.ids.opposite)}
  ].map(r=>{
    const tds = st.cols.map(c=>`<td style="text-align:center">${r.key(c)}</td>`).join('');
    return `<tr><td>${r.lab}</td>${tds}</tr>`;
  }).join('');

  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 1 ‚Äî Vecteurs : comparaison</span>
      <table class="exo-layout-table">
        <tr>
          <td class="exo-fig-col">
            <div class="figure-area" style="text-align:center;">
              ${st.figureSVG}
            </div>
          </td>
          <td class="exo-q-col">
            <div class="enonce">
              <div class="subhead">
                Compl√©ter le tableau en r√©pondant par oui ou non.
              </div>
<table class="table table-yn" style="width:100%">
                <tr>
                  <th>Les vecteurs</th>
                  ${headCols}
                </tr>
                ${rows}
              </table>
              <div id="res" style="margin-top:1rem;"></div>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}





// maj tique locale
function setTickFor(id, state){
  const el = $('#tick-'+id);
  if(!el) return;
  if(state===true){ el.className='tick ok'; el.textContent='‚úì'; }
  else if(state===false){ el.className='tick ko'; el.textContent='‚úó'; }
  else { el.className='tick'; el.textContent=''; }
}


function checkAnswers_exoTable(st){
  let count=0, good=0;

  st.cols.forEach(c=>{
    const truth = c.truths;
const spec = [
  {id:c.ids.sameDir, expect: truth.tSameDir},
  {id:c.ids.sameSens, expect: truth.tSameSens},
  {id:c.ids.sameLen, expect: truth.tSameLen},
  {id:c.ids.equal,   expect: truth.tEqual},
  {id:c.ids.opposite,expect: truth.tOpposite},
];

    spec.forEach(s=>{
      const inp = $('#'+s.id);
      if(!inp){ setTickFor(s.id,null); return; }
      const v = (inp.value||'').toLowerCase();
      if(!v){ setTickFor(s.id,null); return; } // vide => pas compt√©
      count++;
      const ok = ( (s.expect && v==='oui') || (!s.expect && v==='non') );
      if(ok) good++;
      setTickFor(s.id, ok);
    });
  });

  return {count, good};
}




/* =========================================================
   REGISTRY : pour l'instant un seul exercice (EXO_TRANS_1)
   mais on garde l'architecture REG / REGISTRY comme sur
   tes autres fiches.
   ========================================================= */

const EXO_TABLE = {
  id:'exo_vect_table',
  title:'Exercice 1 ‚Äî Tableau Oui/Non',
  gen(host){
    const stCommon = genCommonVecteurs();
    const st = {
      figureSVG: stCommon.figureSVG,
      cols: stCommon.cols,
      truthsTableHTML: stCommon.truthsTableHTML
    };
    if(host){
      host.innerHTML = buildHostHTML_exoTable(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    const r = checkAnswers_exoTable(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <span class="exo-title">Correction</span>
          <table class="exo-layout-table">
            <tr>
              <td class="exo-fig-col">
                <div class="figure-area" style="text-align:center;">
                  ${st.figureSVG}
                </div>
              </td>
              <td class="exo-q-col">
                ${st.truthsTableHTML}
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){
    $('#res',host).textContent = '';
    (host.__state?.cols||[]).forEach(c=>{
      Object.values(c.ids).forEach(id=>{
        const inp = $('#'+id, host); if(inp) inp.value='';
        setTickFor(id, null);
      });
    });
  }
};

function buildHostHTML_exoVF(st){
  function selectVF(id){
    return `<select id="${id}" class="inp">
      <option value=""></option>
      <option>Vrai</option>
      <option>Faux</option>
    </select><span id="tick-${id}" class="tick"></span>`;
  }

  const tfHTML = st.tf.map(o=>`
    <div class="qa-row" style="margin:.35rem 0;">
      <label style="min-width:260px;">
        <strong>\\(${o.label}\\)</strong> ${o.stmt}
      </label>
     \\( \\) ${selectVF(o.id)}
    </div>
  `).join('');

  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 2 ‚Äî Vecteurs : Vrai / Faux</span>
      <table class="exo-layout-table">
        <tr>
          <td class="exo-fig-col">
            <div class="figure-area" style="text-align:center;">
              ${st.figureSVG}
            </div>
          </td>
          <td class="exo-q-col">
            <div class="enonce">
              <div class="subhead">
                Pour chaque affirmation, dire si elle est vraie ou fausse.
              </div>
              <div style="margin-left:1.2em;">
                ${tfHTML}
              </div>
              <div id="res" style="margin-top:1rem;"></div>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}


function checkAnswers_exoVF(st){
  let count=0, good=0;

  st.tf.forEach(o=>{
    const inp = $('#'+o.id);
    if(!inp){ setTickFor(o.id,null); return; }
    const v = (inp.value||'').toLowerCase();
    if(!v){ setTickFor(o.id,null); return; }
    count++;
    const ok = ( (o.truth && v==='vrai') || (!o.truth && v==='faux') );
    if(ok) good++;
    setTickFor(o.id, ok);
  });

  return {count, good};
}


const EXO_VF = {
  id:'exo_vect_vf',
  title:'Exercice 2 ‚Äî Vrai / Faux',
  gen(host){
    const stCommon = genCommonVecteurs();
    const st = {
      figureSVG: stCommon.figureSVG,
      tf: stCommon.tf,
      tfCorrHTML: stCommon.tfCorrHTML
    };
    if(host){
      host.innerHTML = buildHostHTML_exoVF(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    const r = checkAnswers_exoVF(st);
    scoreTot += r.count;
    scoreOK  += r.good;
    updateScore();
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <span class="exo-title">Correction</span>
          <table class="exo-layout-table">
            <tr>
              <td class="exo-fig-col">
                <div class="figure-area" style="text-align:center;">
                  ${st.figureSVG}
                </div>
              </td>
              <td class="exo-q-col">
                ${st.tfCorrHTML}
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){
    $('#res',host).textContent = '';
    (host.__state?.tf||[]).forEach(o=>{
      const inp = $('#'+o.id, host); if(inp) inp.value='';
      setTickFor(o.id, null);
    });
  }
};


// helpers reset
function stResetTicks(st){
  st.qAll.forEach(q=>setTickFor(q.inputId, null));
}

function stClearInputs(st){
  st.qAll.forEach(q=>{
    const inp = $('#'+q.inputId);
    if(inp) inp.value='';
  });
}





/* ============================================
   EXERCICE 3 ‚Äî "Parall√©logrammes en cha√Æne"
   Donn√©s : ABCD et CDEF parall√©logrammes
   √Ä prouver : ABFE est un parall√©logramme
   (optionnel : on pourra encha√Æner un 3e bloc EFGH)
   ============================================ */

function vAdd(p,v){ return {x:p.x+v.x, y:p.y+v.y}; }
function vSub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }


// helpers pour label placement : on donne pour chaque point une "position d'√©tiquette"
// Ex: {dx:0,dy:14} = texte sous le point, {dx:14,dy:-4} = texte √† droite-haut, etc.
// but : rester CONSTANT = lisible, pas algo compliqu√©
function makeLabelAnchors2(A,B,C,D,E,F){
  // id√©e : A,B plut√¥t en bas, C,D milieu, E,F en haut-droite
  return {
    A:{dx:-6,dy:16},
    B:{dx: 6,dy:16},
    D:{dx:-14,dy:0},
    C:{dx:  8,dy:-6},
    E:{dx:  8,dy:-6},
    F:{dx:-18,dy:0}
  };
}
function makeLabelAnchors3(A,B,C,D,E,F,G,H){
  // pour trois √©tages fa√ßon "escaliers"
  return {
    A:{dx:-6,dy:16},
    B:{dx: 6,dy:16},
    D:{dx:-18,dy:0},
    C:{dx: 10,dy:-4},

    F:{dx:-18,dy:0},
    E:{dx: 10,dy:-4},

    H:{dx:-18,dy:0},
    G:{dx: 10,dy:-4}
  };
}
// fabrique un quadruplet A,B,C,D parall√©logramme "pench√© mais lisible"
// On force une forme du type "parall√©logramme oblique", pas trop √©cras√©.
// fabrique un quadruplet A,B,C,D parall√©logramme "pench√© mais lisible"
function makeBaseParallelogram() {
  // vecteur bas (AB)
  const vAB = {
    x: 4 + Math.random()*2,
    y: 0.2 + Math.random()*0.8
  };
  // vecteur hauteur (AD)
  const vAD = {
    x: 0.5 + Math.random()*1.0,
    y: 3 + Math.random()*1.5
  };

  const A = { x: 0, y: 0 };
  const B = { x: A.x + vAB.x, y: A.y + vAB.y };
  const D = { x: A.x + vAD.x, y: A.y + vAD.y };
  const C = { x: D.x + vAB.x, y: D.y + vAB.y };

  return { A, B, C, D, vAB, vAD };
}

// 2e parall√©logramme coll√© "au-dessus" du c√¥t√© CD
// On prend C,D et on les translate avec un vecteur lift (genre qui monte)
function extendSecondParallelogram(C, D){
  // vecteur qui "monte" bien, pour que E,F soient au-dessus de C,D
  const lift = {
    x: 0.5 + Math.random()*1.5,   // petit d√©calage lat√©ral
    y: 2   + Math.random()*1.5    // surtout vers le haut
  };

  const E = { x: C.x + lift.x, y: C.y + lift.y };
  const F = { x: D.x + lift.x, y: D.y + lift.y };

  // C-D-F-E est un parall√©logramme (CDFE)
  // CD // FE et DF // CE
  return { E, F, lift };
}

// 3e parall√©logramme coll√© AU-DESSUS de EF (pas en biais)
// On empile encore une fois vers le haut avec un nouveau lift2
function extendThirdParallelogram(E, F){
  // vecteur qui continue √† monter, dans le m√™me esprit que lift
  const lift2 = {
    x: 0.5 + Math.random()*1.5,
    y: 2   + Math.random()*1.5
  };

  const G = { x: E.x + lift2.x, y: E.y + lift2.y };
  const H = { x: F.x + lift2.x, y: F.y + lift2.y };

  // E-F-H-G est un parall√©logramme (EFHG)
  // EF // HG et FH // EG
  return { G, H, lift2 };
}

// G√©n√®re soit 2 parall√©logrammes (ABCD + CDFE)
// soit 3 (ABCD + CDFE + EFHG)
// et fabrique l'√©nonc√© / correction
// petit utilitaire vecteur g√©o pur (pas juste vAdd/vSub)
function vec(P,Q){
  return {x:Q.x-P.x, y:Q.y-P.y};
}
function vecEqual(u,v){
  const EPS = 1e-6;
  return Math.abs(u.x - v.x) < EPS && Math.abs(u.y - v.y) < EPS;
}


// teste si P-Q-R-S est un parall√©logramme dans cet ordre cyclique
// c.-√†-d. PQ // RS et QR // SP avec m√™me longueur
function isParallelogramOrder(pts, order){
  const [P,Q,R,S] = order.map(n=>pts[n]);
  if(!P||!Q||!R||!S) return false;
  const vPQ = vec(P,Q);
  const vRS = vec(R,S);
  const vQR = vec(Q,R);
  const vSP = vec(S,P);
  return vecEqual(vPQ, vRS) && vecEqual(vQR, vSP);
}

// fabrique les phrases de justification vectorielle pour un ordre P-Q-R-S
// On prend le premier couple de c√¥t√©s oppos√©s : PQ et RS
// On prouve vec(PQ)=vec(SR) AVEC DES JUSTES CHA√éNES
function makeProofForOrder(order, pts, withThird){
  // order = genre ['F','A','B','E'] affich√© √† l'√©l√®ve

  // On va essayer toutes les rotations cycliques :
  const rots = rotationsOf(order);

  // On garde la premi√®re rotation pour laquelle on arrive vraiment
  // √† produire des √©tapes vectorielles d√©taill√©es.
  let pickedRot = null;
  let stepsPQ_SR = [];
  let stepsQR_SP = [];

  for (const rot of rots){
    const [P,Q,R,S] = rot;

    // on (re)construit les facts √† chaque essai
    // (copi√©-coll√© de l'ancienne version)
    const facts = [];
    function addParallelogramFacts(P,Q,R,S,label){
      function pushFact(U,V,W,Z, reason){
        facts.push({lhs:[U,V], rhs:[W,Z], reason});
        facts.push({lhs:[V,U], rhs:[Z,W], reason}); // inverse
      }
      pushFact(P,Q, S,R, `\\(${label}\\) est un parall√©logramme`);
      pushFact(Q,R, P,S, `\\(${label}\\) est un parall√©logramme`);
    }

    // On recr√©e les facts pour cette figure pts :
    addParallelogramFacts("A","B","C","D","ABCD");
    addParallelogramFacts("C","D","F","E","CDFE");
    if (withThird){
      addParallelogramFacts("E","F","H","G","EFHG");
    }

    function chainReason(U,V,W,Z){
      function lineFrom(f, fromLhs=true){
        const [p,q] = fromLhs ? f.lhs : f.rhs;
        const [r,s] = fromLhs ? f.rhs : f.lhs;
        return `${f.reason} \\( \\) donc \\( \\) \\(\\overrightarrow{${p}${q}} = \\overrightarrow{${r}${s}}\\).`;
      }

      // 1 saut
      for (const f of facts){
        if (
          (f.lhs[0]===U && f.lhs[1]===V && f.rhs[0]===W && f.rhs[1]===Z) ||
          (f.rhs[0]===U && f.rhs[1]===V && f.lhs[0]===W && f.lhs[1]===Z)
        ){
          return [ lineFrom(f, true) ];
        }
      }

      // 2 sauts
      for (const f1 of facts){
        const uvMatchesLhs = (f1.lhs[0]===U && f1.lhs[1]===V);
        const uvMatchesRhs = (f1.rhs[0]===U && f1.rhs[1]===V);
        if (!(uvMatchesLhs || uvMatchesRhs)) continue;

        const afterUV = uvMatchesLhs ? f1.rhs : f1.lhs; // vecteur √©gal √† UV

        for (const f2 of facts){
          const midMatchesLhs =
            (f2.lhs[0]===afterUV[0] && f2.lhs[1]===afterUV[1] &&
             f2.rhs[0]===W && f2.rhs[1]===Z);
          const midMatchesRhs =
            (f2.rhs[0]===afterUV[0] && f2.rhs[1]===afterUV[1] &&
             f2.lhs[0]===W && f2.lhs[1]===Z);

          if (midMatchesLhs || midMatchesRhs){
            const line1 = uvMatchesLhs ? lineFrom(f1,true) : lineFrom(f1,false);
            const line2 = midMatchesLhs ? lineFrom(f2,true) : lineFrom(f2,false);
            return [ line1, line2 ];
          }
        }
      }

      // 3 sauts (autoris√© seulement si withThird)
      if (withThird){
        for (const f1 of facts){
          const uvMatchesLhs = (f1.lhs[0]===U && f1.lhs[1]===V);
          const uvMatchesRhs = (f1.rhs[0]===U && f1.rhs[1]===V);
          if (!(uvMatchesLhs || uvMatchesRhs)) continue;
          const A = uvMatchesLhs ? f1.rhs : f1.lhs;

          for (const f2 of facts){
            const aMatchesLhs = (f2.lhs[0]===A[0] && f2.lhs[1]===A[1]);
            const aMatchesRhs = (f2.rhs[0]===A[0] && f2.rhs[1]===A[1]);
            if (!(aMatchesLhs || aMatchesRhs)) continue;
            const B = aMatchesLhs ? f2.rhs : f2.lhs;

            for (const f3 of facts){
              const bMatchesLhs =
                (f3.lhs[0]===B[0] && f3.lhs[1]===B[1] &&
                 f3.rhs[0]===W && f3.rhs[1]===Z);
              const bMatchesRhs =
                (f3.rhs[0]===B[0] && f3.rhs[1]===B[1] &&
                 f3.lhs[0]===W && f3.lhs[1]===Z);
              if (bMatchesLhs || bMatchesRhs){
                const line1 = uvMatchesLhs ? lineFrom(f1,true) : lineFrom(f1,false);
                const line2 = aMatchesLhs  ? lineFrom(f2,true) : lineFrom(f2,false);
                const line3 = bMatchesLhs  ? lineFrom(f3,true) : lineFrom(f3,false);
                return [ line1, line2, line3 ];
              }
            }
          }
        }
      }

      return [];
    } // fin chainReason locale

    const testPQ_SR = chainReason(P,Q,S,R); // prouver ->PQ = ->SR
    const testQR_SP = chainReason(Q,R,S,P); // prouver ->QR = ->SP

    if (testPQ_SR.length || testQR_SP.length){
      pickedRot   = rot;
      stepsPQ_SR  = testPQ_SR;
      stepsQR_SP  = testQR_SP;
      break;
    }
  }

  // si aucune rotation donne des steps, fallback comme avant :
  if(!pickedRot){
    const fallbackLines = [];
    const [P,Q,R,S] = order;
    fallbackLines.push(
      `On montre que \\(\\overrightarrow{${P}${Q}} = \\overrightarrow{${S}${R}}\\) et \\(\\overrightarrow{${Q}${R}} = \\overrightarrow{${S}${P}}\\).`
    );
    fallbackLines.push(
      `Donc les c√¥t√©s oppos√©s du quadrilat√®re ${order.join('')} sont parall√®les et de m√™me longueur.`
    );
    fallbackLines.push(
      `Le quadrilat√®re \\(${order.join('')}\\) est donc un parall√©logramme.`
    );
    return fallbackLines;
  }

  // sinon on construit la correction propre √† partir de pickedRot,
  // MAIS on conclut sur le quadrilat√®re d'origine (celui pos√© dans la question).
  const [P,Q,R,S] = pickedRot;
  const lines = [];

  if(stepsPQ_SR.length){
    stepsPQ_SR.forEach(L=>lines.push(L));
    lines.push(`Donc \\( \\) \\(\\overrightarrow{${P}${Q}} = \\overrightarrow{${S}${R}}\\).`);
  }
  if(stepsQR_SP.length){
    stepsQR_SP.forEach(L=>lines.push(L));
    lines.push(`Donc \\( \\) \\( \\overrightarrow{${Q}${R}} = \\overrightarrow{${S}${P}} \\).`);
  }



  lines.push(
`Le quadrilat√®re \\( \\) \\(${order.join('')}\\) \\( \\) est donc un parall√©logramme.`
  );

  return lines;
}


  


function rotationsOf(order){
  // g√©n√®re les 4 rotations cycliques
  const rots = [];
  for (let i=0; i<order.length; i++){
    rots.push(order.slice(i).concat(order.slice(0,i)));
  }
  return rots;
}




// G√©n√®re soit 2 √©tages (ABCD + CDFE) soit 3 √©tages (ABCD + CDFE + EFHG)
function buildChainParallelograms(){
  // √©tage 1
  const base = makeBaseParallelogram();
  const {A,B,C,D} = base;

  // √©tage 2
  const ext2 = extendSecondParallelogram(C, D);
  const {E,F} = ext2;

  // peut-on monter un 3e √©tage ?
  const withThird = Math.random() < 0.5;
  let G,H;
  if(withThird){
    const ext3 = extendThirdParallelogram(E, F);
    G = ext3.G;
    H = ext3.H;
  }

  // points visibles dans la figure finale
  const pts = withThird ? {A,B,C,D,E,F,G,H} : {A,B,C,D,E,F};

  // polygones color√©s (√©tages)
  const filledPolys = withThird
    ? [
        ['A','B','C','D'],   // √©tage 1
        ['C','D','F','E'],   // √©tage 2
        ['E','F','H','G']    // √©tage 3
      ]
    : [
        ['A','B','C','D'],
        ['C','D','F','E']
      ];

  // segments √† tracer
  const segs = withThird
    ? [
        // ABCD
        ['A','B'],['B','C'],['C','D'],['D','A'],
        // CDFE
        ['C','D'],['D','F'],['F','E'],['E','C'],
        // EFHG
        ['E','F'],['F','H'],['H','G'],['G','E']
      ]
    : [
        // ABCD
        ['A','B'],['B','C'],['C','D'],['D','A'],
        // CDFE
        ['C','D'],['D','F'],['F','E'],['E','C']
      ];

  // ancres labels inchang√©es (tes fonctions)
  const labelAnchors = withThird
    ? makeLabelAnchors3(A,B,C,D,E,F,G,H)
    : makeLabelAnchors2(A,B,C,D,E,F);

  // -------------------------
  // CHOIX DU QUADRILAT√àRE CIBLE
  // -------------------------






  // -------------------------------------------------
  // NOUVEAU : choix du quadrilat√®re cible (option A)
  // -------------------------------------------------

  // 1. On dresse la liste des quadrilat√®res "candidats canoniques"
  //    (ceux qu'on sait pertinents g√©om√©triquement)
  let canonicalCandidates = [];

  if (!withThird) {
    // cas 2 parall√©logrammes
    // Le quadrilat√®re int√©ressant est le A-B-E-F "pont"
    canonicalCandidates.push(['A','B','E','F']);

  } else {
    // cas 3 parall√©logrammes
    // - le grand parall√©logramme ext√©rieur A-B-G-H
    canonicalCandidates.push(['A','B','G','H']);

    // - le parall√©logramme du haut F-E-G-H (attention : ordre cyclique F,E,G,H)
    canonicalCandidates.push(['F','E','G','H']);

    // - le parall√©logramme transversal A-B-G-E (ordre cyclique A,B,G,E)
    canonicalCandidates.push(['A','B','G','E']);
  }

  // 2. On filtre uniquement les canoniques qui sont VRAIMENT des parall√©logrammes
  //    selon la g√©om√©trie produite (c'est notre test solide).
  const realValidCanonicals = canonicalCandidates.filter(ord => isParallelogramOrder(pts, ord));

  // s√©curit√© : si jamais rien ne passe (√ßa devrait √™tre ultra rare),
  // on garde quand m√™me le premier "canonique"
  const chosenCanonical = realValidCanonicals.length
    ? choice(realValidCanonicals)
    : canonicalCandidates[0];

  // 3. On fabrique les rotations cycliques de CE quadrilat√®re-l√† uniquement.
  //    => ex ['A','B','E','F'] -> ['B','E','F','A'], ...
  const rots = rotationsOf(chosenCanonical);

  // 4. On choisit UNE rotation au hasard pour l'affichage final
  const chosenOrder = choice(rots);



  // -------------------------
  // √âNONC√â TEXTE
  // -------------------------
  const givenList = withThird
    ? ["\\(ABCD\\)","\\(CDFE\\)","\\(EFHG\\)"]
    : ["\\(ABCD\\)","\\(CDFE\\)"];

  const enonceHTML = `
    <div class="subhead" style="margin-bottom:.5rem">
      On consid√®re les points suivants.
    </div>

    <div style="line-height:1.9;margin-left:1.2em;">
      On sait que ${givenList.join(', ')} sont des parall√©logrammes.
    </div>

    <div style="margin-top:1rem;line-height:1.9;">
      Quelle est la nature du quadrilat√®re \\( \\) \\(${chosenOrder.join('')}\\) ?
      Justifier.
    </div>
  `;

  // -------------------------
  // CORRECTION TEXTE
  // -------------------------
  const proofLines = makeProofForOrder(chosenOrder, pts, withThird);

  const corrHTML = `
    <div class="steps">
      <div class="stepTitle">Correction</div>
      ${proofLines.map(L=>`<div class="line">${L}</div>`).join('')}
    </div>
  `;

  return {
    pts,
    filledPolys,
    segs,
    enonceHTML,
    corrHTML,
    labelAnchors,
    withThird
  };
}






/* ---------- rendu SVG sans quadrillage + anticollision labels ---------- */

function renderChainFigureSVG(st){
  const pts = st.pts;
  const names = Object.keys(pts);

  // cadre pour le viewBox
  const xs = names.map(n=>pts[n].x);
  const ys = names.map(n=>pts[n].y);
  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  // marges g√©n√©reuses pour le texte
  minX = Math.floor(minX)-2;
  maxX = Math.ceil(maxX)+2;
  minY = Math.floor(minY)-2;
  maxY = Math.ceil(maxY)+2;

  const w = maxX-minX || 1;
  const h = maxY-minY || 1;

  const pad = 20;
  const viewW = 360;
  const viewH = st.withThird ? 300 : 240; // un peu plus haut si 3 √©tages

  const scale = ((viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  function toPix(P){
    const X = pad + (P.x-minX)*scale;
    const Y = pad + (maxY-P.y)*scale;
    return {X,Y};
  }

  // remplissages
  let fills = '';
  st.filledPolys.forEach(polyNames=>{
    const ptsAttr = polyNames.map(n=>{
      const P = toPix(pts[n]);
      return `${P.X.toFixed(1)},${P.Y.toFixed(1)}`;
    }).join(' ');
    fills += `
      <polygon points="${ptsAttr}"
               fill="rgba(200,150,100,0.08)"
               stroke="#c48a5a"
               stroke-width="1"
               stroke-linejoin="round" />
    `;
  });

  // ar√™tes
  let segsSVG = '';
  st.segs.forEach(([Pname,Qname])=>{
    const P = toPix(pts[Pname]);
    const Q = toPix(pts[Qname]);
    segsSVG += `
      <line x1="${P.X.toFixed(1)}" y1="${P.Y.toFixed(1)}"
            x2="${Q.X.toFixed(1)}" y2="${Q.Y.toFixed(1)}"
            stroke="#222" stroke-width="1.4" />
    `;
  });

  // points + labels avec ancre fixe
  let ptsSVG = '';
  names.forEach(n=>{
    const P = toPix(pts[n]);
    const anch = st.labelAnchors[n] || {dx:8,dy:-6}; // fallback pas trop coll√©

    ptsSVG += `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}"
              r="3" fill="#111"/>
      <text x="${(P.X+anch.dx).toFixed(1)}"
            y="${(P.Y+anch.dy).toFixed(1)}"
            font-size="12"
            font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  });

  return `
    <svg viewBox="0 0 ${viewW} ${viewH}"
         width="${viewW}" height="${viewH}"
         style="border:1px solid #ccc;border-radius:6px;background:#fff;
                width:${viewW}px;max-width:${viewW}px;">
      ${fills}
      ${segsSVG}
      ${ptsSVG}
    </svg>
  `;
}


/* -------- bloc DOM de l'exercice 3 -------- */

function buildHostHTML_exo3(st){
  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 3 ‚Äî Cha√Æne de parall√©logrammes</span>
      <table class="exo-layout-table">
        <tr>
          <td class="exo-q-col" style="width:60%;min-width:260px;">
            ${st.enonceHTML}
          </td>
          <td class="exo-fig-col" style="width:40%;min-width:240px;">
            <div class="figure-area" style="text-align:center;">
              ${renderChainFigureSVG(st)}
            </div>
          </td>
        </tr>
      </table>
    </div>
    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}

const EXO_PARAL = {
  id:'exo_vect_para',
  title:'Exercice 3 ‚Äî Cha√Æne de parall√©logrammes',
  gen(host){
    const st = buildChainParallelograms(); // <-- nouvelle g√©n√©ration propre
    if(host){
      host.innerHTML = buildHostHTML_exo3(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    // pas d'auto-check (r√©daction)
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <table class="exo-layout-table">
            <tr>
              <td class="exo-q-col" style="width:60%;min-width:260px;">
                ${st.corrHTML}
              </td>
              <td class="exo-fig-col" style="width:40%;min-width:240px;">
                <div class="figure-area" style="text-align:center;">
                  ${renderChainFigureSVG(st)}
                </div>
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){}
};



/* =========================================================
   EXERCICE 4 ‚Äî Milieux et nature d'un quadrilat√®re
   -------------------------------------------------
   - On g√©n√®re un parall√©logramme ABCD.
   - On construit deux points ext√©rieurs I et J.
   - On choisit un sc√©nario parmi S1..S4.
   - On affiche l'√©nonc√© (sans quadrillage) + question.
   - Le bouton "Solution" affiche les 4 lignes de correction
     exactement dans le style valid√©.
   ========================================================= */

/* 1. Fabrique un parall√©logramme ABCD "propre" */
function makeNiceParallelogramNoGrid(){
  // base horizontale-ish
  const A = {x:0, y:1.5};
  const B = {x:3.5, y:1.5};
  const D = {x:-0.5, y:0};
  const C = {x:3, y:0};

  // on a donc ABCD parall√©logramme pench√© √† droite
  // Maintenant on place I et J pour que :
  //  - I soit "prolonge" vers la gauche/haut
  //  - J soit "prolonge" vers la droite/bas
  //
  // On veut qu'I soit tel que A ou B ou D soit milieu selon sc√©narios,
  // mais l√† on ne sait pas encore quel sc√©nario.
  // -> on NE place pas I et J tout de suite.
  // On retournera juste {A,B,C,D} et on laissera le sc√©nario les calculer.

  return {A,B,C,D};
}

/* petit utilitaire vectoriel */
function midToOtherEndpoint(mid, other){
  // si M est milieu de [P,Q] et on conna√Æt M et P,
  // alors Q = 2M - P
  return {
    x: 2*mid.x - other.x,
    y: 2*mid.y - other.y
  };
}


const SCENARIOS_4 = [
  // S1 ‚Äî A milieu [IB], C milieu [DJ]  ->  AI = CJ  (et AJ = CI)  ->  A-I-J-C
  {
    name: "S1_A-IB_C-DJ",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(A, B); // A milieu [IB]  => BA = AI
      const J = midToOtherEndpoint(C, D); // C milieu [DJ]  => CD = CJ
      return {I,J};
    },
    quad: ["A","I","J","C"], // oppos√©s: AI // CJ et IJ // CA
    helperSegs: [["I","B"], ["D","J"]],
    questionQuadLabel: "AICJ",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([IB]\\) \\( \\) ainsi \\( \\)  \\(\\overrightarrow{BA}=\\overrightarrow{AI}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([DJ]\\) \\( \\) ainsi \\( \\)  \\(\\overrightarrow{CD}=\\overrightarrow{JC}\\).",
      "Comme  \\( \\) \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{BA}=\\overrightarrow{CD}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{AI}=\\overrightarrow{JC}\\) \\( \\)  et le quadrilat√®re \\( \\)  \\(AICJ\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([IB]\\).","\\(C\\) \\( \\) est le milieu de \\([DJ]\\)."]
  },

  // S2 ‚Äî B milieu [AI], D milieu [CJ]  ->  BI = JD  ->  B-I-J-D
  {
    name: "S2_B-AI_D-CJ",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(B, A); // AB = BI
      const J = midToOtherEndpoint(D, C); // DC = DJ
      return {I,J};
    },
    quad: ["B","I","J","D"], // oppos√©s: BI // JD
    helperSegs: [["A","I"], ["C","J"]],
    questionQuadLabel: "BIDJ",
    statements: [
      "\\(B\\) \\( \\) est le milieu de \\([AI]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{BI}\\).",
      "\\(D\\) \\( \\) est le milieu de \\([CJ]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{JD}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc  \\( \\) \\(\\overrightarrow{BI}=\\overrightarrow{JD}\\)  \\( \\) et \\( \\)  \\(BIDJ\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(B\\) \\( \\) est le milieu de \\([AI]\\).","\\(D\\) \\( \\) est le milieu de \\([CJ]\\)."]
  },

  // S3 ‚Äî D milieu [AI], C milieu [BJ]  ->  DI = CJ  ->  D-I-J-C  (on conclut sur DI // CJ)
  {
    name: "S3_D-AI_C-BJ",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(D, A); // AD = DI
      const J = midToOtherEndpoint(C, B); // BC = CJ
      return {I,J};
    },
    quad: ["D","I","J","C"],
    helperSegs: [["A","I"], ["B","J"]],
    questionQuadLabel: "DIJC",
    statements: [
      "\\(D\\) \\( \\) est le milieu de \\([AI]\\) \\( \\) ainsi \\(\\overrightarrow{AD}=\\overrightarrow{DI}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([BJ]\\) \\( \\) ainsi \\(\\overrightarrow{BC}=\\overrightarrow{CJ}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{AD}=\\overrightarrow{BC}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{DI}=\\overrightarrow{CJ}\\)  \\( \\) et \\( \\)  \\(DIJC\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(D\\) \\( \\) est le milieu de \\([AI]\\).","\\(C\\) \\( \\) est le milieu de \\([BJ]\\)."]
  },

  // S4 ‚Äî A milieu [DI], B milieu [CJ]  ->  AI = BJ  ->  A-I-J-B
  {
    name: "S4_A-DI_B-CJ",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(A, D); // DA = AI
      const J = midToOtherEndpoint(B, C); // CB = BJ
      return {I,J};
    },
    quad: ["A","I","J","B"],
    helperSegs: [["D","I"], ["C","J"]],
    questionQuadLabel: "AIJB",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([DI]\\) \\( \\) ainsi \\(\\overrightarrow{DA}=\\overrightarrow{AI}\\).",
      "\\(B\\) \\( \\) est le milieu de \\([CJ]\\) \\( \\) ainsi \\(\\overrightarrow{CB}=\\overrightarrow{BJ}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{DA}=\\overrightarrow{CB}\\).",
      "Donc  \\( \\) \\(\\overrightarrow{AI}=\\overrightarrow{BJ}\\) \\( \\)  et \\( \\)  \\(AIJB\\) \\( \\)  est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([DI]\\).","\\(B\\) \\( \\) est le milieu de \\([CJ]\\)."]
  },

  // S5 ‚Äî A milieu [JB], C milieu [ID]  ->  AJ = CI  ->  A-J-I-C
  {
    name: "S5_A-JB_C-ID",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(A, B); // BA = AJ
      const I = midToOtherEndpoint(C, D); // CD = CI
      return {I,J};
    },
    quad: ["A","J","I","C"],
    helperSegs: [["J","B"], ["I","D"]],
    questionQuadLabel: "AJCI",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([JB]\\) \\( \\) ainsi \\(\\overrightarrow{BA}=\\overrightarrow{AJ}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([ID]\\) \\( \\) ainsi \\(\\overrightarrow{CD}=\\overrightarrow{IC}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{BA}=\\overrightarrow{CD}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{AJ}=\\overrightarrow{IC}\\)  \\( \\) et \\( \\)  \\(AJCI\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([JB]\\).","\\(C\\) \\( \\) est le milieu de \\([ID]\\)."]
  },

  // S6 ‚Äî B milieu [JA], D milieu [IC]  ->  BJ = DI  ->  B-J-I-D
  {
    name: "S6_B-JA_D-IC",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(B, A); // AB = BJ
      const I = midToOtherEndpoint(D, C); // CD = DI
      return {I,J};
    },
    quad: ["B","J","I","D"],
    helperSegs: [["J","A"], ["I","C"]],
    questionQuadLabel: "BJDI",
    statements: [
      "\\(B\\) \\( \\) est le milieu de \\([JA]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{BJ}\\).",
      "\\(D\\) \\( \\) est le milieu de \\([IC]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{ID}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc  \\( \\) \\(\\overrightarrow{BJ}=\\overrightarrow{ID}\\)  \\( \\) et \\( \\)  \\(BJDI\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(B\\) \\( \\) est le milieu de \\([JA]\\).","\\(D\\) \\( \\) est le milieu de \\([IC]\\)]."]
  },

  // S7 ‚Äî C milieu [JD], A milieu [IB]  ->  CJ = AI  ->  C-J-I-A
  {
    name: "S7_C-JD_A-IB",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(C, D); // DC = CJ
      const I = midToOtherEndpoint(A, B); // BA = AI
      return {I,J};
    },
    quad: ["C","J","I","A"],
    helperSegs: [["J","D"], ["I","B"]],
    questionQuadLabel: "CJAI",
    statements: [
      "\\(C\\) \\( \\) est le milieu de \\([JD]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{CJ}\\).",
      "\\(A\\) \\( \\) est le milieu de \\([IB]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{IA}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{CJ}=\\overrightarrow{IA}\\)  \\( \\) et \\( \\)  \\(CJAI\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(C\\) \\( \\) est le milieu de \\([JD]\\).","\\(A\\) \\( \\) est le milieu de \\([IB]\\)]."]
  },

  // S8 ‚Äî D milieu [IC], B milieu [JA]  ->  DI = BJ  ->  D-I-J-B
  {
    name: "S8_D-IC_B-JA",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(D, C); // CD = DI
      const J = midToOtherEndpoint(B, A); // AB = BJ
      return {I,J};
    },
    quad: ["D","I","J","B"],
    helperSegs: [["I","C"], ["J","A"]],
    questionQuadLabel: "IDJB",
    statements: [
      "\\(D\\) \\( \\) est le milieu de \\([IC]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{ID}\\).",
      "\\(B\\) \\( \\) est le milieu de \\([JA]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{BJ}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{ID}=\\overrightarrow{BJ}\\)  \\( \\) et \\( \\)  \\(IDJB\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(D\\) \\( \\) est le milieu de \\([IC]\\).","\\(B\\) \\( \\) est le milieu de \\([JA]\\)."]
  },

  // S9 ‚Äî A milieu [IB], D milieu [CJ]  ->  AI = JD  ->  A-I-D-J
  {
    name: "S9_A-IB_D-CJ",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(A, B); // BA = AI
      const J = midToOtherEndpoint(D, C); // DC = JD
      return {I,J};
    },
    quad: ["A","I","D","J"],
    helperSegs: [["I","B"], ["C","J"]],
    questionQuadLabel: "AIJD",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([IB]\\) \\( \\) ainsi \\(\\overrightarrow{BA}=\\overrightarrow{AI}\\).",
      "\\(D\\) \\( \\) est le milieu de \\([CJ]\\) \\( \\) ainsi \\(\\overrightarrow{CD}=\\overrightarrow{DJ}\\).",
      "Comme \\( \\)  \\(ABCD\\) \\( \\)  est un parall√©logramme, \\( \\)  \\(\\overrightarrow{BA}=\\overrightarrow{CD}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{AI}=\\overrightarrow{DJ}\\)  \\( \\) et \\( \\)  \\(AIJD\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([IB]\\).","\\(D\\) \\( \\) est le milieu de \\([CJ]\\)."]
  },

  // S10 ‚Äî B milieu [IA], C milieu [JD]  ->  BI = CJ  ->  B-I-C-J
  {
    name: "S10_B-IA_C-JD",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(B, A); // AB = BI
      const J = midToOtherEndpoint(C, D); // DC = CJ
      return {I,J};
    },
    quad: ["B","I","C","J"],
    helperSegs: [["I","A"], ["J","D"]],
    questionQuadLabel: "BIJC",
    statements: [
      "\\(B\\) \\( \\) est le milieu de \\([IA]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{BI}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([JD]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{CJ}\\).",
      "Comme \\( \\)  \\(ABCD\\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{BI}=\\overrightarrow{CJ}\\) \\( \\)  et \\( \\)  \\(BIJC\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(B\\) \\( \\) est le milieu de \\([IA]\\).","\\(C\\) \\( \\) est le milieu de \\([JD]\\)."]
  },

  // S11 ‚Äî A milieu [DJ], C milieu [IB]  ->  AJ = CI  ->  A-J-C-I
  {
    name: "S11_A-DJ_C-IB",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(A, D); // DA = AJ
      const I = midToOtherEndpoint(C, B); // CB = CI
      return {I,J};
    },
    quad: ["A","J","C","I"],
    helperSegs: [["D","J"], ["I","B"]],
    questionQuadLabel: "AJCI",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([DJ]\\) \\( \\) ainsi \\(\\overrightarrow{DA}=\\overrightarrow{AJ}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([IB]\\) \\( \\) ainsi \\(\\overrightarrow{CB}=\\overrightarrow{IC}\\).",
      "Comme  \\( \\) \\(ABCD\\)  \\( \\) est un parall√©logramme, \\(\\overrightarrow{DA}=\\overrightarrow{CB}\\).",
      "Donc  \\( \\) \\(\\overrightarrow{AJ}=\\overrightarrow{IC}\\)  \\( \\) et \\( \\)  \\(AJCI\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([DJ]\\).","\\(C\\) \\( \\) est le milieu de \\([IB]\\)."]
  },

  // S12 ‚Äî B milieu [CJ], D milieu [IA]  ->  BJ = DI  ->  B-J-D-I
  {
    name: "S12_B-CJ_D-IA",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(B, C); // CB = BJ
      const I = midToOtherEndpoint(D, A); // AD = DI
      return {I,J};
    },
    quad: ["B","J","D","I"],
    helperSegs: [["C","J"], ["A","I"]],
    questionQuadLabel: "BJDI",
    statements: [
      "\\(B\\) \\( \\) est le milieu de \\([CJ]\\) \\( \\) ainsi \\(\\overrightarrow{BC}=\\overrightarrow{JB}\\).",
      "\\(D\\) \\( \\) est le milieu de \\([IA]\\) \\( \\) ainsi \\(\\overrightarrow{AD}=\\overrightarrow{DI}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{BC}=\\overrightarrow{AD}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{JB}=\\overrightarrow{DI}\\)  \\( \\) et \\( \\)  \\(BJDI\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(B\\) \\( \\) est le milieu de \\([CJ]\\).","\\(D\\) \\( \\) est le milieu de \\([IA]\\)."]
  },

  // S13 ‚Äî tout √† gauche (A & D)  ->  AJ = CI  ->  A-J-C-I
  {
    name: "S13_A-JB_D-IC",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(A, B); // BA = AJ
      const I = midToOtherEndpoint(D, C); // DC = DI  -> On utilisera DC = CI ? (non : DI = DC)
      return {I,J};
    },
    quad: ["A","J","C","I"],
    helperSegs: [["J","B"], ["I","C"]],
    questionQuadLabel: "AJID",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([JB]\\) \\( \\) ainsi \\(\\overrightarrow{BA}=\\overrightarrow{AJ}\\).",
      "\\(D\\) \\( \\) est le milieu de \\([IC]\\) \\( \\) ainsi \\(\\overrightarrow{CD}=\\overrightarrow{DI}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme,  \\( \\) \\(\\overrightarrow{BA}=\\overrightarrow{CD}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{AJ}=\\overrightarrow{DI}\\)  \\( \\) et \\( \\)  \\(AJID\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([JB]\\).","\\(D\\) \\( \\) est le milieu de \\([IC]\\)."]
  },

  // S14 ‚Äî tout √† droite (B & C)  ->  BJ = DI  ->  B-J-I-D
  {
    name: "S14_B-JA_C-ID",
    buildIJ: ({A,B,C,D}) => {
      const J = midToOtherEndpoint(B, A); // AB = BJ
      const I = midToOtherEndpoint(C, D); // CD = CI
      return {I,J};
    },
    quad: ["B","J","I","D"],
    helperSegs: [["J","A"], ["I","D"]],
    questionQuadLabel: "BJIC",
    statements: [
      "\\(B\\) \\( \\) est le milieu de \\([JA]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{BJ}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([ID]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{CI}\\).",
      "Comme  \\( \\) \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{BJ}=\\overrightarrow{CI}\\)  \\( \\) et \\( \\)  \\(BJIC\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(B\\) \\( \\) est le milieu de \\([JA]\\).","\\(C\\) \\( \\) est le milieu de \\([ID]\\)."]
  },

  // S15 ‚Äî mix haut/bas (A & C)  ->  AI = JC  ->  A-I-C-J
  {
    name: "S15_A-BI_C-DJ",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(A, B); // BA = AI
      const J = midToOtherEndpoint(C, D); // CD = CJ
      return {I,J};
    },
    quad: ["A","I","J","C"],
    helperSegs: [["B","I"], ["D","J"]],
    questionQuadLabel: "AICJ",
    statements: [
      "\\(A\\) \\( \\) est le milieu de \\([BI]\\) \\( \\) ainsi \\(\\overrightarrow{BA}=\\overrightarrow{AI}\\).",
      "\\(C\\) \\( \\) est le milieu de \\([DJ]\\) \\( \\) ainsi \\(\\overrightarrow{CD}=\\overrightarrow{JC}\\).",
      "Comme  \\( \\) \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{BA}=\\overrightarrow{CD}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{AI}=\\overrightarrow{JC}\\) \\( \\)  et \\( \\)  \\(AICJ\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(A\\) \\( \\) est le milieu de \\([BI]\\)].","\\(C\\) \\( \\) est le milieu de \\([DJ]\\)."]
  },

  // S16 ‚Äî mix haut/bas (B & D)  ->  BI = JD  ->  B-I-D-J
  {
    name: "S16_B-IA_D-JC",
    buildIJ: ({A,B,C,D}) => {
      const I = midToOtherEndpoint(B, A); // AB = BI
      const J = midToOtherEndpoint(D, C); // CD = JD
      return {I,J};
    },
    quad: ["B","I","D","J"],
    helperSegs: [["I","A"], ["J","C"]],
    questionQuadLabel: "BIDJ",
    statements: [
      "\\(B\\) \\( \\) est le milieu de \\([IA]\\) \\( \\) ainsi \\(\\overrightarrow{AB}=\\overrightarrow{BI}\\).",
      "\\(D\\) \\( \\) est le milieu de \\([JC]\\) \\( \\) ainsi \\(\\overrightarrow{DC}=\\overrightarrow{JD}\\).",
      "Comme \\( \\)  \\(ABCD\\)  \\( \\) est un parall√©logramme, \\( \\)  \\(\\overrightarrow{AB}=\\overrightarrow{DC}\\).",
      "Donc \\( \\)  \\(\\overrightarrow{BI}=\\overrightarrow{JD}\\)  \\( \\) et \\( \\)  \\(BIDJ\\)  \\( \\) est un parall√©logramme."
    ],
    milieuSentences: ["\\(B\\) \\( \\) est le milieu de \\([IA]\\).","\\(D\\) \\( \\) est le milieu de \\([JC]\\)."]
    
  }
];



/* 3. SVG sans quadrillage, avec ABCD rempli + I,J visibles + les lettres propres */
function renderNoGridFigureParallelogram(st){
  const {A,B,C,D,I,J} = st;

  // cadre
  const xs=[A.x,B.x,C.x,D.x,I.x,J.x];
  const ys=[A.y,B.y,C.y,D.y,I.y,J.y];
  let minX=Math.min(...xs)-1, maxX=Math.max(...xs)+1;
  let minY=Math.min(...ys)-1, maxY=Math.max(...ys)+1;
  const viewW=380, viewH=200, pad=20;
  const w=maxX-minX, h=maxY-minY;
  const scale = ((viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h);

  function toPix(P){
    return {
      X: pad + (P.x-minX)*scale,
      Y: pad + (maxY-P.y)*scale
    };
  }

  // petit "tick" au milieu d‚Äôun segment
  function midTick(P,Q){
    const m = { x:(P.x+Q.x)/2, y:(P.y+Q.y)/2 };
    const d = { x: Q.y-P.y, y: -(Q.x-P.x) }; // perpendiculaire
    const k = 0.06; // longueur du tick (en unit√©s "math")
    const A = toPix({x:m.x + k*d.x, y:m.y + k*d.y});
    const B = toPix({x:m.x - k*d.x, y:m.y - k*d.y});
    return `<line x1="${A.X.toFixed(1)}" y1="${A.Y.toFixed(1)}"
                  x2="${B.X.toFixed(1)}" y2="${B.Y.toFixed(1)}"
                  stroke="#666" stroke-width="1" />`;
  }

  // polygon ABCD
  const polyPts=[A,B,C,D].map(P=>{
    const p=toPix(P);
    return `${p.X.toFixed(1)},${p.Y.toFixed(1)}`;
  }).join(' ');

  function dotWithLabel(P,name,dx,dy){
    const p=toPix(P);
    return `
      <circle cx="${p.X.toFixed(1)}" cy="${p.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(p.X+dx).toFixed(1)}" y="${(p.Y+dy).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${name}</text>`;
  }

  // ===== NOUVEAU : pointill√©s = exactement les helperSegs du sc√©nario =====
  const dashed = (st.scenario?.helperSegs || [])
    .map(([U,V])=>{
      const P = st[U], Q = st[V];
      if(!P || !Q) return '';
      const p1 = toPix(P), p2 = toPix(Q);
      return `
        <line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
              x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
              stroke="#555" stroke-width="1"
              stroke-dasharray="6 4" />
      `;
    }).join('');

  // ar√™tes du parall√©logramme ABCD
  const edgesABCD = [[A,B],[B,C],[C,D],[D,A]].map(([P,Q])=>{
    const p1=toPix(P), p2=toPix(Q);
    return `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
                   x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
                   stroke="#c48a5a" stroke-width="2" />`;
  }).join('');

  return `
    <svg viewBox="0 0 ${viewW} ${viewH}"
         width="${viewW}" height="${viewH}"
         style="border:1px solid #ccc;border-radius:6px;background:#fff;
                width:${viewW}px; max-width:${viewW}px;">
      <polygon points="${polyPts}"
               fill="rgba(200,150,100,0.08)"
               stroke="none"/>
      ${edgesABCD}
      ${dashed}
      ${dotWithLabel(A,"A",  6,-6)}
      ${dotWithLabel(B,"B",  6,-6)}
      ${dotWithLabel(C,"C",  6,14)}
      ${dotWithLabel(D,"D", -12,14)}
      ${dotWithLabel(I,"I", -10,-10)}
      ${dotWithLabel(J,"J",  6,14)}
    </svg>
  `;
}



/* 4. G√©n√©ration √©tat exercice 4 */
function genMilieuxExo(){
  const base = makeNiceParallelogramNoGrid();
  const scenario = SCENARIOS_4[Math.floor(Math.random()*SCENARIOS_4.length)];

  const {I,J} = scenario.buildIJ(base);

  const st = {
    A:base.A, B:base.B, C:base.C, D:base.D,
    I, J,
    scenario
  };

  st.figureSVG = renderNoGridFigureParallelogram(st);

  // √©nonc√© en texte
  // "ABCD est un parall√©logramme. ... B est le milieu du segment [AI] ..."
  const milieuLines = scenario.milieuSentences.map(s=>"      " + s).join("<br>");

  st.enonceHTML = `
    <div class="subhead" style="margin-bottom:.5rem">
      On consid√®re les points suivants.
    </div>

    <div style="line-height:1.8;margin-left:1.2em;">
      \\(ABCD\\) \\( \\) est un parall√©logramme.<br>
      ${milieuLines}
    </div>

    <div style="margin-top:1rem;line-height:1.8;">
      Quelle est la nature du quadrilat√®re \\(${scenario.questionQuadLabel}\\) ?<br>
      Justifier.
    </div>

  
  `;

  // correction bloc
  st.corrHTML = `
    <div class="steps">
      <div class="stepTitle">Correction</div>
      ${scenario.statements.map(L=>`<div class="line">${L}</div>`).join('')}
    </div>
  `;

  return st;
}

/* 5. Rendu DOM Exercice 4 */
function buildHostHTML_exo4(st){
  return `
    <div class="exo-block">
      <span class="exo-title">Exercice 4 ‚Äî Milieux et nature d‚Äôun quadrilat√®re</span>
      <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
        <tr>
          <td class="exo-fig-col" style="vertical-align:top;width:50%;min-width:240px;padding:8px 12px;border:none;">
            <div class="figure-area" style="text-align:center;">
              ${st.figureSVG}
            </div>
          </td>
          <td class="exo-q-col" style="vertical-align:top;width:50%;min-width:260px;padding:8px 12px;border:none;">
            ${st.enonceHTML}
          </td>
        </tr>
      </table>
    </div>
    <div id="solution-block" style="margin-top:1rem;"></div>
  `;
}

/* 6. Objet REG pour Exercice 4 */
const EXO_MILIEUX = {
  id:'exo_vect_milieux',
  title:'Exercice 4 ‚Äî Milieux et quadrilat√®re',
  gen(host){
    const st = genMilieuxExo();
    if(host){
      host.innerHTML = buildHostHTML_exo4(st);
      host.__state = st;
      host.dataset.state = JSON.stringify(st);
      if(window.MathJax?.typeset) MathJax.typeset();
    }
    return st;
  },
  correct(host, st){
    // rien √† cocher automatiquement, c'est une r√©dac
  },
  solution(host, st){
    const solZone = host.querySelector('#solution-block');
    if(solZone){
      solZone.innerHTML = `
        <div class="exo-block">
          <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
            <tr>
              <td class="exo-fig-col" style="vertical-align:top;width:50%;min-width:240px;padding:8px 12px;border:none;">
                <div class="figure-area" style="text-align:center;">
                  ${st.figureSVG}
                </div>
              </td>
              <td class="exo-q-col" style="vertical-align:top;width:50%;min-width:260px;padding:8px 12px;border:none;">
                ${st.corrHTML}
              </td>
            </tr>
          </table>
        </div>
      `;
      if(window.MathJax?.typeset) MathJax.typeset();
    }
  },
  reset(host){}
};
















// registry
const REG = [EXO_TABLE, EXO_VF, EXO_PARAL, EXO_MILIEUX];
window.REG = REG;
window.REGISTRY = REG;






/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);
function redrawStudentLayer(svg, st){
  const layer = svg.querySelector("#student-layer");
  if(!layer) return;

  // vider le layer
  layer.innerHTML = "";

  // pour chaque point d√©j√† plac√© par l'√©l√®ve, on le dessine
  if (!st.placedByStudent) return;
  for (const lbl of Object.keys(st.placedByStudent)){
    const {x,y} = st.placedByStudent[lbl];

    // projeter coord math -> pixel
    const minX  = parseFloat(svg.getAttribute("data-minx"));
    const maxY  = parseFloat(svg.getAttribute("data-maxy"));
    const scale = parseFloat(svg.getAttribute("data-scale"));
    const pad   = parseFloat(svg.getAttribute("data-pad"));

    const Xpix = pad + (x - minX)*scale;
    const Ypix = pad + (maxY - y)*scale;

    layer.innerHTML += `
      <circle cx="${Xpix.toFixed(1)}" cy="${Ypix.toFixed(1)}" r="3" fill="#b00020"/>
      <text x="${(Xpix+5).toFixed(1)}" y="${(Ypix-5).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#b00020">${lbl}</text>
    `;
  }
}

function attachInteractiveHandlers(){
  const host = $("#host");
  if(!host || !host.__state) return;
  const st = host.__state;

  const svg = host.querySelector("#fig-click");
  if(!svg) return;

  // init m√©moire √©l√®ve
  if(!st.placedByStudent){
    st.placedByStudent = {}; // ex {K:{x:...,y:...}, L:{...}, M:{...}}
  }
  st.activePoint = null;

  // Boutons K/L/M
  $$(".btn-place", host).forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const p = btn.getAttribute("data-point");
      st.activePoint = p; // active ce point
      // Optionnel : feedback visuel
      $$(".btn-place", host).forEach(b=>b.style.outline="none");
      btn.style.outline="2px solid #b00020";
    }, {passive:true});
  });

  // Clic sur le SVG pour poser/d√©placer le point actif
  svg.addEventListener("click", (evt)=>{
    if(!st.activePoint) return; // aucun point s√©lectionn√©

    // r√©cup conversion pixel -> math
    const bbox  = svg.getBoundingClientRect();
    const pad   = parseFloat(svg.getAttribute("data-pad"));
    const scale = parseFloat(svg.getAttribute("data-scale"));
    const minX  = parseFloat(svg.getAttribute("data-minx"));
    const maxY  = parseFloat(svg.getAttribute("data-maxy"));

    const relX = evt.clientX - bbox.left;
    const relY = evt.clientY - bbox.top;

    const xMath = ((relX - pad)/scale) + minX;
    const yMath = maxY - ((relY - pad)/scale);

    // snap aux entiers
    const xSnap = Math.round(xMath);
    const ySnap = Math.round(yMath);

    // on stocke pour ce label
    st.placedByStudent[st.activePoint] = {x:xSnap, y:ySnap};

    // redraw
    redrawStudentLayer(svg, st);
  }, {passive:true});
}


/* =========================================================
   ADAPTATEUR PDF
   -------------------------------------------------
   On reprend ton syst√®me : ExoPDF.init(...) + beforeGen,
   beforeRender refait un rendu LaTeX propre en SVG.
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try {
          st = JSON.parse(hostTmp.dataset.state || '{}');
        } catch(_){}
        return st;
      },

      // version adapt√©e pour cet exo :
      beforeRender(def, st, withSolutions){
  return (async () => {
    let host = null;
    try {
      host = document.createElement('div');
      host.id = 'pdf-host';
      host.style.position='fixed';
      host.style.left='-10000px';
      host.style.top='-10000px';
      document.body.appendChild(host);

      // Construire le bloc √©nonc√© pour le PDF selon l'exo :
      let enonceHTML = '';
      if (def.id === 'exo_vect_table') {
        // Recr√©er l'√©nonc√© sans les <select>
        const headCols = (st.cols||[])
          .map(c=>`<th style="text-align:center;">${c.title}</th>`)
          .join('');

        const rowsNoInput = [
          {lab:'ont la m√™me direction'},
          {lab:'ont le m√™me sens'},
          {lab:'ont la m√™me longueur'},
          {lab:'sont √©gaux'},
          {lab:'sont oppos√©s'}
        ].map(r=>{
          const tds = (st.cols||[]).map(()=>`<td style="text-align:center"></td>`).join('');
          return `<tr><td>${r.lab}</td>${tds}</tr>`;
        }).join('');

        enonceHTML = `
          <div class="exo-block">
            <span class="exo-title">Exercice 1 ‚Äî Vecteurs : comparaison</span>
            <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
              <tr>
                <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                  <div style="text-align:center;">${st.figureSVG||''}</div>
                </td>
                <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                  <div class="subhead">Compl√©ter le tableau en r√©pondant par oui ou non.</div>
                  <table class="table" style="width:100%">
                    <tr>
                      <th>Les vecteurs</th>
                      ${headCols}
                    </tr>
                    ${rowsNoInput}
                  </table>
                </td>
              </tr>
            </table>
          </div>
        `;
      } else if (def.id === 'exo_vect_vf') {
        // Recr√©er l'√©nonc√© VF sans <select>
        const tfLines = (st.tf||[]).map(o=>{
          return `<div class="line"><strong>${o.label}</strong> ${o.stmt} : </div>`;
        }).join('');

        enonceHTML = `
          <div class="exo-block">
            <span class="exo-title">Exercice 2 ‚Äî Vecteurs : Vrai / Faux</span>
            <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
              <tr>
                <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                  <div style="text-align:center;">${st.figureSVG||''}</div>
                </td>
                <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                  <div class="subhead">Dire si chaque affirmation est vraie ou fausse.</div>
                  <div style="margin-left:1.2em;">
                    ${tfLines}
                  </div>
                </td>
              </tr>
            </table>
          </div>
        `;
		
		 } else if (def.id === 'exo_vect_para') {
        // ----- EXERCICE 3 (Cha√Æne de parall√©logrammes) -----
        // Ici on r√©utilise exactement la structure de buildHostHTML_exo3 :
        //  - st.enonceHTML  : texte "On sait que ABCD ... Justifier."
        //  - renderChainFigureSVG(st) : la figure avec les 2 ou 3 parall√©logrammes empil√©s

        const figHTML = renderChainFigureSVG(st); // m√™me rendu que l'√©cran

        enonceHTML = `
          <div class="exo-block">
            <span class="exo-title">Exercice 3 ‚Äî Cha√Æne de parall√©logrammes</span>
            <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
              <tr>
                <td class="exo-q-col" style="vertical-align:top;width:60%;min-width:260px;padding:8px 12px;border:none;">
                  ${st.enonceHTML || ''}
                </td>
                <td class="exo-fig-col" style="vertical-align:top;width:40%;min-width:240px;padding:8px 12px;border:none;">
                  <div style="text-align:center;">${figHTML}</div>
                </td>
              </tr>
            </table>
          </div>
        `;
            } else if (def.id === 'exo_vect_milieux') {
        // ----- EXERCICE 4 (Milieux et quadrilat√®re) -----
        // On r√©utilise le rendu sans grille + le texte d‚Äô√©nonc√© d√©j√† pr√©sents dans l‚Äô√©tat.
        const figHTML = st.figureSVG || '';
        const enonceHTML4 = st.enonceHTML || '';

        enonceHTML = `
          <div class="exo-block">
            <span class="exo-title">Exercice 4 ‚Äî Milieux et nature d‚Äôun quadrilat√®re</span>
            <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
              <tr>
                <td class="exo-fig-col" style="vertical-align:top;width:50%;min-width:240px;padding:8px 12px;border:none;">
                  <div style="text-align:center;">${figHTML}</div>
                </td>
                <td class="exo-q-col" style="vertical-align:top;width:50%;min-width:260px;padding:8px 12px;border:none;">
                  ${enonceHTML4}
                </td>
              </tr>
            </table>
          </div>
        `;

      }

      // Correction PDF si withSolutions
      let corrHTML = '';
      if (withSolutions){
        if (def.id === 'exo_vect_table'){
          corrHTML = `
            <div style="margin-top:1rem;">
              <div class="exo-block">
                <span class="exo-title">Correction</span>
                <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
                  <tr>
                    <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                      <div style="text-align:center;">${st.figureSVG||''}</div>
                    </td>
                    <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                      ${st.truthsTableHTML||''}
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          `;
        } else if (def.id === 'exo_vect_vf'){
          corrHTML = `
            <div style="margin-top:1rem;">
              <div class="exo-block">
                <span class="exo-title">Correction</span>
                <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
                  <tr>
                    <td class="exo-fig-col" style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
                      <div style="text-align:center;">${st.figureSVG||''}</div>
                    </td>
                    <td class="exo-q-col" style="vertical-align:top;padding:8px 12px;border:none;">
                      ${st.tfCorrHTML||''}
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          `;
         } else if (def.id === 'exo_vect_para'){
          // correction exo 3
          // st.corrHTML = bloc "Correction" avec les √©tapes vectorielles jolies
          const figHTML = renderChainFigureSVG(st);

          corrHTML = `
            <div style="margin-top:1rem;">
              <div class="exo-block">
                <span class="exo-title">Correction</span>
                <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
                  <tr>
                    <td class="exo-q-col" style="vertical-align:top;width:60%;min-width:260px;padding:8px 12px;border:none;">
                      ${st.corrHTML || ''}
                    </td>
                    <td class="exo-fig-col" style="vertical-align:top;width:40%;min-width:240px;padding:8px 12px;border:none;">
                      <div style="text-align:center;">${figHTML}</div>
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          `;
                } else if (def.id === 'exo_vect_milieux') {
          const figHTML = st.figureSVG || '';
          const corrHTML4 = st.corrHTML || '';
          corrHTML = `
            <div style="margin-top:1rem;">
              <div class="exo-block">
                <span class="exo-title">Correction</span>
                <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
                  <tr>
                    <td class="exo-fig-col" style="vertical-align:top;width:50%;min-width:240px;padding:8px 12px;border:none;">
                      <div style="text-align:center;">${figHTML}</div>
                    </td>
                    <td class="exo-q-col" style="vertical-align:top;width:50%;min-width:260px;padding:8px 12px;border:none;">
                      ${corrHTML4}
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          `;
}
      }

      // On injecte les deux blocs dans l'iframe pour conversion MathJax SVG
      const iframe = document.createElement('iframe');
      iframe.style.position='fixed';
      iframe.style.left='-10000px';
      iframe.style.top='-10000px';
      iframe.style.width='0';
      iframe.style.height='0';
      iframe.style.visibility='hidden';
      document.body.appendChild(iframe);

      const iwin = iframe.contentWindow;
      const idoc = iframe.contentDocument;

      idoc.open();
      idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
      idoc.close();

      const contentDiv = idoc.getElementById('content');
      contentDiv.innerHTML = enonceHTML + corrHTML;

      // purge des vieux mjx √©ventuels
      contentDiv.querySelectorAll('mjx-container').forEach(mjx=>{
        mjx.replaceWith(mjx.textContent || '');
      });
      contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());

      const cfg = idoc.createElement('script');
      cfg.type = 'text/javascript';
      cfg.text = `
        window.MathJax = {
          tex: {
            inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
            displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
            processEscapes: true,
            packages: { '[+]': ['bbox','ams'] },
            macros: { vec: ['\\\\overrightarrow{#1}',1] }
          },
          svg: { fontCache: 'none' },
          options: { skipHtmlTags: ['script','noscript','style','textarea'] },
          startup: { typeset: false }
        };
      `;
      idoc.head.appendChild(cfg);

      const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
      const mj = idoc.createElement('script');
      mj.type = 'text/javascript';
      mj.src  = svgScriptURL;
      idoc.head.appendChild(mj);

      await new Promise(resolve=>{
        mj.onload = resolve;
        mj.onerror = resolve;
      });

      async function waitMathJaxReady(win){
        const limit=200;
        let n=0;
        while((!win.MathJax) || (!win.MathJax.typesetPromise && !win.MathJax.typeset)){
          await new Promise(res=>setTimeout(res,5));
          n++;
          if(n>limit) break;
        }
      }
      await waitMathJaxReady(iwin);

      if(iwin.MathJax && iwin.MathJax.typesetPromise){
        await iwin.MathJax.typesetPromise([ contentDiv ]);
      } else if(iwin.MathJax && iwin.MathJax.typeset){
        iwin.MathJax.typeset([ contentDiv ]);
      }

      // purge CHTML
      (function purgeCHTML(){
        contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n=>n.remove());
        contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n=>n.remove());
        contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());
      })();

      const finalHTML = contentDiv.innerHTML;

      iframe.remove();
      if(host) host.remove();

      return finalHTML;

    } catch(e){
      console.error('beforeRender SVG error:', e);

      // fallback minable mais s√ªr
      let fallbackHTML = '';
      if(host){
        fallbackHTML = (host.innerHTML || '');
        host.remove();
        host=null;
      }
      return fallbackHTML;
    }
  })();
}


    });
  });
})();

/* ===== mobile tweaks ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','V√©rifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // champ focus mobile
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
