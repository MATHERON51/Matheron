<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Vecteurs - Somme et diff√©rence</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}

/* Bloc solution (UI) */
#res.steps{
  background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;
}
#res.steps p{margin:.25rem 0}

.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }


/* Parenth√®ses larges et "stretchy" autour des deux inputs */
/* Input colonne compact avec grandes parenth√®ses */
.colvec{
  /* R√©glages rapides */
  --parenW: 10px;   /* largeur parenth√®se */
  --padX:   6px;    /* marge interne gauche/droite */
  --gap:    4px;    /* √©cart entre les deux inputs */
  --inW:    54px;   /* largeur d‚Äôun input */
  --inPx:   6px;    /* padding horizontal input */
  --inPy:   4px;    /* padding vertical input */
  --inFs:   14px;   /* font-size input */

  position: relative;
  display: inline-grid;
  grid-template-rows: auto auto;
  row-gap: var(--gap);
  padding: 6px calc(var(--padX) + var(--parenW));
  vertical-align: middle;
}
.colvec input{
  width: var(--inW);
  text-align: center;
  padding: var(--inPy) var(--inPx);
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: var(--inFs);
}

/* Parenth√®ses stretch */
.colvec::before,
.colvec::after{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  width: var(--parenW);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  opacity: .95;
}
.colvec::before{
  left: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}
.colvec::after{
  right: 0; transform: scaleX(-1);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 100" preserveAspectRatio="none"><path d="M18,2 C6,14 6,86 18,98" fill="none" stroke="%23111" stroke-width="3" stroke-linecap="round"/></svg>');
}

/* Tailles pr√™tes √† l‚Äôemploi */
.colvec.sm { --parenW: 9px;  --padX: 6px; --gap: 4px; --inW: 48px; --inPy: 3px; --inFs: 13px; }
.colvec.xs { --parenW: 8px;  --padX: 5px; --gap: 3px; --inW: 42px; --inPy: 2px; --inFs: 12px; }




/* (facultatif) un peu plus √©pais sur √©cran Retina/print */
@media (min-resolution: 2dppx){
  .colvec::before, .colvec::after{
    filter: saturate(1.1);
  }
}

/* Grille 3 colonnes pour les vecteurs √† placer (partie 3) */
.grid3 {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px 12px;           /* espace lignes/colonnes */
  align-items: start;
}
.grid3 .chipwrap { width: 100%; }

/* ---- Blocs sous le rep√®re : 2 lignes √ó 5 colonnes ---- */
.flat12-wrap{ margin-top:10px; }

.sec{ margin:10px 0; }
.sec .title{ font-weight:700; font-size:1.05rem; margin-bottom:6px; }

/* une grille de 5 colonnes */
.grid5{
  display:grid;
  grid-template-columns: repeat(5, max-content);
  gap:8px 14px;
  align-items:center;
}

/* cellules : libell√© + vecteur-colonne + tick */
.grid5 .inlinecell{ display:flex; align-items:center; gap:6px; }

/* vecteurs en colonne compacts pour tenir √† 5√ó2 */
.grid5 .colvec{
  --parenW:8px; --padX:5px; --gap:3px;
  --inW:44px; --inPy:2px; --inFs:12.5px;
}

.hidden{ display:none; }


/* ‚Äî Anti ‚Äúbarres noires‚Äù MathJax ‚Äî */
.steps mjx-container { color: #111 !important; background: transparent !important; }
.steps mjx-container svg { overflow: visible !important; }
.steps mjx-container svg rect,
.steps mjx-container svg path[data-mml-node="mspace"] { fill: none !important; }
.steps mjx-mrow, .steps mjx-mi, .steps mjx-mo, .steps mjx-mn { background: transparent !important; }

/* ==== Nom de vecteur avec fl√®che au-dessus ============================== */
.vecname{ position:relative; display:inline-block; }
.vecname input{
  width:72px; text-align:center; font-weight:700; font-size:15px;
  letter-spacing:.12em; text-transform:uppercase;
  padding:14px 10px 6px 10px; /* place pour la fl√®che au-dessus */
  border:1px solid #ddd; border-radius:8px; background:#fff;
}
.vecname::before{
  content:""; position:absolute; left:12px; right:20px; top:6px; height:2px; background:#111;
}
.vecname::after{
  content:""; position:absolute; top:2px; right:12px;
  border-left:8px solid #111; border-top:5px solid transparent; border-bottom:5px solid transparent;
}

/* Lignes compactes sous le rep√®re pour e2 */
.vecrow{ display:flex; align-items:center; gap:12px; margin:6px 0; flex-wrap:wrap; }
.vecrow .lbl{ font-weight:700; min-width:max-content; }
.vecrow .tick{ min-width:1.4rem; font-weight:900; }
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.pair{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.pair .lbl{font-weight:700;min-width:1.6rem}


</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Vecteurs - Somme et diff√©rence</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Coordonn√©es au format <code>u;v</code> (ex. <code>6;1</code> ou <code>3/2; -5</code>). Virgule d√©cimale ¬´ , ¬ª ou point ¬´ . ¬ª accept√©s.</li>
        <li>Jamais de parenth√®ses : on tape <code>6;1</code> (les parenth√®ses sont affich√©es automatiquement).</li>
        <li>Fractions conserv√©es dans les corrections.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Mini helpers g√©n√©riques ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
const HOST = $('#host');
function retypeset(host){
  if (window.__PDF_BUILDING) return;              // ‚¨ÖÔ∏è ignore en phase PDF
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]);
}function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; }

/* ====== Rationnels ‚Äúpropres‚Äù (pour jolies fractions dans les corrections) ====== */
function R(p,q=1){ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function addR(x,y){ return R(x.p*y.q + y.p*x.q, x.q*y.q); }
function subR(x,y){ return R(x.p*y.q - y.p*x.q, x.q*y.q); }
function mulR(x,y){ return R(x.p*y.p, x.q*y.q); }
function negR(x){ return R(-x.p, x.q); }
function numR(x){ return x.p/x.q; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'‚àí':''; const P=Math.abs(r.p); return s+'\\dfrac{'+P+'}{'+r.q+'}'; }
function textR(r){ return r.q===1 ? String(r.p) : `${r.p}/${r.q}`; }
// Retourne -\dfrac{|p|}{q} si p<0, sinon \dfrac{p}{q}; et un entier si q=1
function latexR_leadingMinus(r){
  const p = r.p, q = r.q;
  if (q === 1) return String(p);              // pas de /1 affich√© dans ton flux final
  if (p < 0) return `-\\dfrac{${Math.abs(p)}}{${q}}`;
  return `\\dfrac{${p}}{${q}}`;
}


/* ===== MathJax helper ===== */
function MJ(el){
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }

// ‚úÖ Vecteur en COLONNE (d√©finitif ‚Äî laisse celui-ci et SUPPRIME toute red√©finition plus bas)
function colVecExpr(xExpr, yExpr){
  return `\\begin{pmatrix} ${xExpr} \\\\ ${yExpr} \\end{pmatrix}`;
}
function fmtVecLaNum(x, y){ return colVecExpr(nPlain(x), nPlain(y)); }
function fmtVecLaR(x, y){  return colVecExpr(latexR(x), latexR(y)); }

// Retourne les √©tapes LaTeX pour p/q : d'abord p/q, puis (optionnel) la forme r√©duite.
function fracStepsLatex(p,q){
  const g0 = gcd(Math.abs(p), Math.abs(q));
  const first = `\\dfrac{${p}}{${q}}`;
  if (g0>1){
    const pr = p/g0, qr = q/g0;
    return [first, `\\dfrac{${pr}}{${qr}}`]; // √©tape "r√©duction"
  }
  return [first]; // d√©j√† irr√©ductible ‚Üí une seule ligne
}

/* === Helpers de comparaison (signes & doublons) ========================== */
// Normalise les signes dans les fractions pour comparer :
//  \dfrac{-a}{b}  ‚Üí  -\dfrac{a}{b}
// enl√®ve espaces superflus et normalise le "‚àí" unicode en "-"
function normalizeFracSign(s){
  return String(s)
    .replace(/\u2212/g, '-') // unicode minus ‚Üí "-"
    .replace(/\\dfrac\{\s*-\s*([^}]+)\}\{\s*([^}]+)\}/g, '-\\dfrac{$1}{$2}')
    .replace(/\(\s*-\s*\\dfrac/g, '(-\\dfrac')
    .replace(/\s+/g, ' ')
    .trim();
}
// Deux coordonn√©es (x;y) LaTeX sont-elles identiques modulo placement du signe ?
function sameCoordPair(x1,y1,x2,y2){
  return normalizeFracSign(x1)===normalizeFracSign(x2)
      && normalizeFracSign(y1)===normalizeFracSign(y2);
}


/* ====== UI host ====== */
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq"></div>
    <hr class="sep">
    <div class="controls">
      <label class="input">R√©ponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>
  `;
}

function setEqu(html){ const box=$('#equ',HOST); if(box) box.innerHTML = html; retypeset(HOST); }
function setStepsHTML(html){ $('#res',HOST).innerHTML=html; retypeset(HOST); }
function setSteps(lines){ setStepsHTML(lines.map(L=>`<p>${L}</p>`).join('')); }
function setFB(ok, msg=''){
  const fb = $('#fb', HOST);
  if (!fb) return;
  if (ok === null){        // ‚¨ÖÔ∏è mode neutre
    fb.className = '';     // ni .ok ni .ko
    fb.innerHTML = msg;    // message libre (peut contenir du HTML)
    return;
  }
  fb.className = ok ? 'ok' : 'ko';
  fb.textContent = (ok?'‚úîÔ∏é Correct. ':'‚úó Incorrect. ') + msg;
}

/* ====== Parsing des r√©ponses u;v ====== */
function normalizeMinus(s){ return String(s||'').replace(/\u2212/g,'-').trim(); }
function parseNumber(token){
  token = token.replace(',','.');
  if (/^[-+]?\d+\/\d+$/.test(token)){ const [p,q]=token.split('/').map(Number); return p/q; }
  return token===''?NaN:Number(token);
}
function parsePairUV(s){
  s = normalizeMinus(s).replace(/\s+/g,'');
  const m = s.match(/^([^;]+);([^;]+)$/);
  if(!m) return {ok:false};
  const u=parseNumber(m[1]), v=parseNumber(m[2]);
  return (isFinite(u)&&isFinite(v)) ? {ok:true,u,v} : {ok:false};
}


// fabrique un "input colonne" avec deux champs empil√©s
function mkColInput(idBase, placeholderU='u', placeholderV='v',cls='sm'){
  return `<span class="colvec">
    <input id="${idBase}_u" type="text" inputmode="text" placeholder="">
    <input id="${idBase}_v" type="text" inputmode="text" placeholder="">
  </span>`;
}

// lit un "input colonne"
function readColInput(idBase){
  const uEl = document.getElementById(idBase+'_u');
  const vEl = document.getElementById(idBase+'_v');
  if (!uEl || !vEl) return {ok:false};
  const u = parseNumber(normalizeMinus(uEl.value.replace(',', '.')).trim());
  const v = parseNumber(normalizeMinus(vEl.value.replace(',', '.')).trim());
  if (!isFinite(u) || !isFinite(v)) return {ok:false};
  return {ok:true, u, v};
}

// lit soit un input colonne (idBase_u/idBase_v), soit un champ texte "u;v" (idBase)
function getPairFromInputs(idBase){
  const uEl = document.getElementById(idBase+'_u');
  const vEl = document.getElementById(idBase+'_v');
  if (uEl && vEl){
    if (!uEl.value && !vEl.value) return {ok:false, empty:true};
    return readColInput(idBase);
  }
  const tEl = document.getElementById(idBase);
  if (!tEl) return {ok:false};
  if (!tEl.value) return {ok:false, empty:true};
  return parsePairUV(tEl.value);
}


/* ==== Helpers noms de vecteurs & coordonn√©es =========================== */
function mkVecNameInput(id, placeholder='AB'){
  return `<span class="vecname"><input id="${id}" type="text" maxlength="2" autocomplete="off" placeholder="${placeholder}"></span>`;
}
function normVName(s){
  return String(s||'').toUpperCase().replace(/[^ABCD]/g,'').slice(0,2); // garde A,B,C,D uniquement (2 lettres)
}

// Garde n‚Äôimporte quelle lettre A‚ÄìZ, coupe √† 2 lettres
function normVNameAZ(s){
  return String(s||'').toUpperCase().replace(/[^A-Z]/g,'').slice(0,2);
}

const VALID_NAMES = new Set(['AB','BA','BC','CB','CD','DC','AD','DA']);
const VALID_PAIRS = new Set([
  'AB|DC','DC|AB',
  'BA|CD','CD|BA',
  'BC|AD','AD|BC',
  'CB|DA','DA|CB',
]);

function pairOK(n1,n2){ return VALID_PAIRS.has(`${n1}|${n2}`); }

function vecByName(name, S){ // S = {A,B,C,D} avec a,b en entiers
  const {A,B,C,D} = S;
  switch(name){
    case 'AB': return {u: B.a-A.a, v: B.b-A.b};
    case 'BA': return {u: A.a-B.a, v: A.b-B.b};
    case 'BC': return {u: C.a-B.a, v: C.b-B.b};
    case 'CB': return {u: B.a-C.a, v: B.b-C.b};
    case 'CD': return {u: D.a-C.a, v: D.b-C.b};
    case 'DC': return {u: C.a-D.a, v: C.b-D.b};
    case 'AD': return {u: D.a-A.a, v: D.b-A.b};
    case 'DA': return {u: A.a-D.a, v: A.b-D.b};
    default:   return null;
  }
}
function sameUV(ans, exp){ return ans && exp && Math.abs(ans.u-exp.u)<1e-9 && Math.abs(ans.v-exp.v)<1e-9; }



/* ====== Points al√©atoires (entiers), tous distincts ====== */
function samePt(P,Q){ return P.a===Q.a && P.b===Q.b; }
function allDistinctPts(list){ for(let i=0;i<list.length;i++)for(let j=i+1;j<list.length;j++) if(samePt(list[i],list[j])) return false; return true; }
function randPointNum(min,max,existing=[]){
  let P; do{ P={a:randInt(min,max), b:randInt(min,max)}; }while(existing.some(E=>samePt(E,P)));
  return P;
}



/* ===== Rep√®re ===== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.points=[]; this.user=[]; this.vectors=[]; this.userVectors=[];
    this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const ns = 'http://www.w3.org/2000/svg';
    const s  = document.createElementNS(ns,'svg');
    s.setAttribute('class','svgbox');
    s.setAttribute('viewBox','0 0 420 420');
    s.setAttribute('preserveAspectRatio','xMidYMid meet');

const defs = document.createElementNS(ns,'defs');

// --- Pointe pour les AXES (un peu plus grande)
const axisArrow = document.createElementNS(ns,'marker');
axisArrow.setAttribute('id','axisArrow');
axisArrow.setAttribute('markerUnits','strokeWidth');
axisArrow.setAttribute('markerWidth','7');
axisArrow.setAttribute('markerHeight','5');
axisArrow.setAttribute('refX','5');
axisArrow.setAttribute('refY','2.5');
axisArrow.setAttribute('orient','auto');
{
  const p = document.createElementNS(ns,'path');
  p.setAttribute('d','M0,0 L6,2.5 L0,5 z');
  p.setAttribute('fill','#000');
  axisArrow.appendChild(p);
}
defs.appendChild(axisArrow);

// --- Pointe pour les VECTEURS (plus petite)
const vecArrow = document.createElementNS(ns,'marker');
vecArrow.setAttribute('id','vecArrow');
vecArrow.setAttribute('markerUnits','strokeWidth');
vecArrow.setAttribute('markerWidth','4');   // ‚¨ÖÔ∏è plus petit
vecArrow.setAttribute('markerHeight','3');
vecArrow.setAttribute('refX','3.2');
vecArrow.setAttribute('refY','1.5');
vecArrow.setAttribute('orient','auto');
{
  const p = document.createElementNS(ns,'path');
  p.setAttribute('d','M0,0 L4,1.5 L0,3 z');  // ‚¨ÖÔ∏è pointe r√©duite
  p.setAttribute('fill','#000');
  vecArrow.appendChild(p);
}
defs.appendChild(vecArrow);

s.appendChild(defs);




    this.gGrid=document.createElementNS(ns,'g'); s.appendChild(this.gGrid);
    this.gAxes=document.createElementNS(ns,'g'); s.appendChild(this.gAxes);
    this.gPts=document.createElementNS(ns,'g'); s.appendChild(this.gPts);
    this.gVec=document.createElementNS(ns,'g'); s.appendChild(this.gVec);
    this.gUser=document.createElementNS(ns,'g'); s.appendChild(this.gUser);
    this.gUserVec=document.createElementNS(ns,'g'); s.appendChild(this.gUserVec);

    const handleTap = (ev) => {
      if(!this.clickable) return;
      const r  = s.getBoundingClientRect();
      const vb = s.viewBox?.baseVal || {x:0,y:0,width:420,height:420};
      const cx = ('clientX' in ev ? ev.clientX : ev.touches?.[0]?.clientX);
      const cy = ('clientY' in ev ? ev.clientY : ev.touches?.[0]?.clientY);
      const x = (cx - r.left) * (vb.width  / r.width);
      const y = (cy - r.top)  * (vb.height / r.height);
      const c = this.screenToCoord(x,y);
      const lim = this.innerLimits();
      const xi  = Math.round(c.x), yi = Math.round(c.y);
      if (xi < lim.xmin || xi > lim.xmax || yi < lim.ymin || yi > lim.ymax) return;
      if (this.onClick) this.onClick({x:xi,y:yi});
    };
    s.addEventListener('pointerdown', (ev)=>{ if (ev.pointerType==='touch') ev.preventDefault(); handleTap(ev); }, {passive:false});
    s.addEventListener('click', handleTap, {passive:true});
    return s;
  }
  innerLimits(){ const R=this.R; return {xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; }
  basis(){
    const w=420,h=420,m=24;
    const X=this.R.xmax-this.R.xmin, Y=this.R.ymax-this.R.ymin;
    const Sx = (w-2*m)/X, Sy = (h-2*m)/Y;
    const O = { x:m - this.R.xmin*Sx, y:h-m + this.R.ymin*Sy };
    return {O,Sx,Sy,w,h,m};
  }
  coordToScreen(x,y){ const {O,Sx,Sy}=this.basis(); return {x:O.x + x*Sx, y:O.y - y*Sy}; }
  screenToCoord(px,py){ const {O,Sx,Sy}=this.basis(); return {x:(px-O.x)/Sx, y:-(py-O.y)/Sy}; }

  setPoints(arr){ this.points=arr||[]; this.redraw(); }
  setVectors(arr){ this.vectors=arr||[]; this.redraw(); }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  clearUserVectors(){ this.userVectors=[]; this.gUserVec.innerHTML=''; }

  _latexFO(html, x, y, color='#000'){
    const fo=document.createElementNS(this.el.namespaceURI,'foreignObject');
    fo.setAttribute('x', x); fo.setAttribute('y', y); fo.setAttribute('width', 110); fo.setAttribute('height', 26);
    const div=document.createElementNS('http://www.w3.org/1999/xhtml','div');
    div.style.fontSize='13px'; div.style.fontWeight='700'; div.style.color=color;
    div.innerHTML = html;
    fo.appendChild(div);
    return fo;
  }
  
    _dot(px, py, label, color = '#000'){
    const g = document.createElementNS(this.el.namespaceURI,'g');
    const c = document.createElementNS(this.el.namespaceURI,'circle');
    c.setAttribute('cx', px);
    c.setAttribute('cy', py);
    c.setAttribute('r', 4.2);
    c.setAttribute('fill', color);
    g.appendChild(c);
    if(label){
      const t = document.createElementNS(this.el.namespaceURI,'text');
      t.setAttribute('x', px + 6);
      t.setAttribute('y', py - 6);
      t.setAttribute('font-size', '13');
      t.textContent = label;
      g.appendChild(t);
    }
    return g;
  }

  redraw(){
  const R=this.R;
  this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gPts.innerHTML=''; this.gVec.innerHTML='';

  const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',x1);L.setAttribute('y1',y1);L.setAttribute('x2',x2);L.setAttribute('y2',y2);
    L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); return L; };

  // grille
  for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
  for(let t=R.ymin;t<=R.ymax;t++){ const p1=this.coordToScreen(R.xmin,t), p2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }

  // axes
  const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
  const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
  axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);

  // O, u, v
  const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
  // point O
  this.gAxes.appendChild(this._dot(O.x,O.y,'O'));
  // fl√®che de u : O -> (1;0)
  const uLn=document.createElementNS(this.el.namespaceURI,'line');
  uLn.setAttribute('x1',O.x); uLn.setAttribute('y1',O.y); uLn.setAttribute('x2',I.x); uLn.setAttribute('y2',I.y);
  uLn.setAttribute('stroke','#000'); uLn.setAttribute('stroke-width','2'); uLn.setAttribute('marker-end','url(#axisArrow)');;
  this.gAxes.appendChild(uLn);
  // fl√®che de v : O -> (0;1)
  const vLn=document.createElementNS(this.el.namespaceURI,'line');
  vLn.setAttribute('x1',O.x); vLn.setAttribute('y1',O.y); vLn.setAttribute('x2',J.x); vLn.setAttribute('y2',J.y);
  vLn.setAttribute('stroke','#000'); vLn.setAttribute('stroke-width','2'); vLn.setAttribute('marker-end','url(#axisArrow)');
  this.gAxes.appendChild(vLn);
  // labels LaTeX
  this.gAxes.appendChild(this._latexFO('\\(\\overrightarrow i\\)', I.x, I.y));
  this.gAxes.appendChild(this._latexFO('\\(\\overrightarrow j\\)', J.x+6, J.y-18));
  

  // points fixes
  // ‚¨áÔ∏è remplace le bloc "points fixes" dans redraw()
for(const p of this.points){
  const P=this.coordToScreen(p.x,p.y);
  const g=document.createElementNS(this.el.namespaceURI,'g');
  const c=document.createElementNS(this.el.namespaceURI,'circle');
  c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); c.setAttribute('r',4.2);
  c.setAttribute('fill',p.fill||'#000'); g.appendChild(c);
  if(p.label){
    const t=document.createElementNS(this.el.namespaceURI,'text');
    const dx = (typeof p.dx==='number') ? p.dx : 6;
    const dy = (typeof p.dy==='number') ? p.dy : -6;
    t.setAttribute('x', P.x + dx);
    t.setAttribute('y', P.y + dy);
    t.setAttribute('font-size','13');
    t.textContent = p.label;
    g.appendChild(t);
  }
  this.gPts.appendChild(g);
}

// ‚¨áÔ∏è remplace le bloc "vecteurs fixes" dans redraw()
// --- Vecteurs fixes : trait fin + label le long du segment, jamais dessus
// --- Vecteurs fixes : trait + label auto-plac√©
// --- Vecteurs fixes : trait + label AU-DESSUS DU MILIEU
// --- Vecteurs fixes : trait + label d√©cal√© perpendiculairement au segment
for (const v of this.vectors){
  const p1 = this.coordToScreen(v.x1, v.y1);
  const p2 = this.coordToScreen(v.x2, v.y2);

  // trait
  const ln = document.createElementNS(this.el.namespaceURI,'line');
  ln.setAttribute('x1', p1.x); ln.setAttribute('y1', p1.y);
  ln.setAttribute('x2', p2.x); ln.setAttribute('y2', p2.y);
  ln.setAttribute('stroke', v.stroke || '#111');
const sw = (typeof v.w === 'number') ? v.w : (v.thick ? 3.2 : 2.2);
ln.setAttribute('stroke-width', sw);
if (v.arrow !== false) {
  ln.setAttribute('marker-end','url(#vecArrow)');
}
  this.gVec.appendChild(ln);

  if (!v.label) continue;

  // g√©om√©trie √©cran
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const L  = Math.hypot(dx, dy) || 1;
  const mx = (p1.x + p2.x) * 0.5;
  const my = (p1.y + p2.y) * 0.5;

  // vecteur normal unitaire (perpendiculaire)
  // n = (-dy, dx)/L ; on choisit le signe pour respecter la r√®gle
  let nx = -dy / L, ny = dx / L;

  // seuils d‚Äôorientation
  const H = Math.abs(dy) <= 0.4 * Math.abs(dx); // ~horizontal
  const V = Math.abs(dx) <= 0.4 * Math.abs(dy); // ~vertical

  // offset en pixels (jamais sur le trait)
  let off = 20;

  if (H){
    // on veut "au-dessus" du segment ‚Üí ny doit √™tre n√©gatif en rep√®re √©cran
    if (ny > 0){ nx = -nx; ny = -ny; }
  } else if (V){
    // pour vertical, on force √† droite du trait (nx > 0). Si pr√®s du bord droit, √† gauche.
    const {w,m} = this.basis();
    const preferRight = (mx < w - m - 30);
    if (preferRight && nx < 0) { nx = -nx; ny = -ny; }
    if (!preferRight && nx > 0){ nx = -nx; ny = -ny; }
  } else {
    // oblique : "au-dessus" (ny<0)
    if (ny > 0){ nx = -nx; ny = -ny; }
  }

  let lx = mx + off * nx;
  let ly = my + off * ny;

  // si on touche le bord haut/bas, on inverse le c√¥t√© (fallback)
  const {w,h,m} = this.basis();
  const clamp = (x,a,b)=>Math.min(Math.max(x,a),b);
  if (ly < m + 6 || ly > h - m - 20){
    lx = mx - off * nx;
    ly = my - off * ny;
  }
  // clamp doux dans la vue
  lx = clamp(lx, m + 6, w - m - 6);
  ly = clamp(ly, m + 6, h - m - 6);

  // label LaTeX, sans fond
  this.gVec.appendChild(this._latexFO(`\\(\\vec ${v.label}\\)`, lx, ly, v.stroke || '#111'));
}





  // re-typeset pour les foreignObjects
  MJ(this.el.parentNode||document.body);
}


  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){ g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','13'); t.setAttribute('font-weight','700'); t.setAttribute('fill',color); t.textContent=label;
      g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g);
    }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }

placeUserVector(label,x1,y1,x2,y2,color='#0a84ff'){
  let g=this.gUserVec.querySelector(`g[data-vlabel="${label||''}"]`);
  if(!g){
    g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.vlabel = label||'';
    const ln=document.createElementNS(this.el.namespaceURI,'line');
    ln.setAttribute('stroke',color); ln.setAttribute('stroke-width','2.2');
ln.setAttribute('marker-end','url(#vecArrow)');
    g.appendChild(ln);
    // ‚¨áÔ∏è on n'ajoute le FO que si un label est fourni
    if (label){
      const fo=this._latexFO(`\\(\\overrightarrow v_{${label.replace('v','')}}\\)`, 0, 0, color);
      g.appendChild(fo);
    }
    this.gUserVec.appendChild(g);
  }
  const p1=this.coordToScreen(x1,y1), p2=this.coordToScreen(x2,y2);
  const ln=g.querySelector('line'); ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y);
  ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
  const fo=g.querySelector('foreignObject');
  if (fo){ fo.setAttribute('x', p2.x+6); fo.setAttribute('y', p2.y-18); }
  const i=this.userVectors.findIndex(vv=>vv.label===(label||'')); 
  const rec={label:label||'',x1,y1,x2,y2}; if(i>=0) this.userVectors[i]=rec; else this.userVectors.push(rec);
  MJ(this.el.parentNode||document.body);
}

}

/* ===== UI helpers ===== */
/* ==== Couleurs & rendu rapide du rep√®re ==== */
const PALETTE = ['#0a84ff','#d32f2f','#2e7d32','#6a1b9a','#f57c00','#00897b','#c62828','#6d4c41','#ad1457','#283593','#0277bd'];
const colorOfIndex = i => PALETTE[i % PALETTE.length];
const vecCol = (a,b) => `\\begin{pmatrix} ${a} \\\\ ${b} \\end{pmatrix}`;


// mini ‚Äúview‚Äù : on place un rep√®re √† gauche et √† droite l‚Äô√©nonc√© + actions + #res
function renderWithRepereIntoHost(host, R){
  host.innerHTML = `
    <div class="row">
      <div><div id="repere-slot" class="svgbox" style="width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff"></div></div>
      <div>
        <div id="equ"></div>
        <div class="optionline" id="actions" style="margin-top:.5rem"></div>
        <div id="res" class="steps"></div>
      </div>
    </div>`;
  // Repere vient de repere_patch_0813.js (global)
  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  document.getElementById('repere-slot').replaceWith(rep.el);
  return { rep, equ: document.getElementById('equ'), actions: document.getElementById('actions'), res: document.getElementById('res') };
}






function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// cellules 3√ó3 √† l'int√©rieur des limites "lim"
function makeCells(lim, rows=3, cols=3){
  const w = (lim.xmax - lim.xmin + 1), h = (lim.ymax - lim.ymin + 1);
  const cw = Math.floor(w / cols), ch = Math.floor(h / rows);
  const cells = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0 = lim.xmin + c*cw, x1 = (c===cols-1) ? lim.xmax : (x0+cw-1);
      const y0 = lim.ymin + r*ch, y1 = (r===rows-1) ? lim.ymax : (y0+ch-1);
      cells.push({xmin:x0, xmax:x1, ymin:y0, ymax:y1});
    }
  }
  return cells;
}
function randIntInCell(cell){ return { x: randInt(cell.xmin, cell.xmax), y: randInt(cell.ymin, cell.ymax) }; }
function fits(lim, x, y){ return x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax; }


// --- Unicit√© de pente : cl√© de colin√©arit√© (ignore l'√©chelle et le signe global)
function slopeKey(dx, dy){
  if (dx === 0) return 'V';     // vertical
  if (dy === 0) return 'H';     // horizontal
  // normalise le signe pour que (dx,dy) et (-dx,-dy) donnent la m√™me cl√©
  if (dx < 0){ dx = -dx; dy = -dy; }
  const g0 = gcd(Math.abs(dx), Math.abs(dy)) || 1;
  const a = dx / g0, b = dy / g0; // a = dx', b = dy' primitifs
  return b + '/' + a;             // on encode la pente (dy/dx) comme "b/a"
}


// --- Unicit√© stricte des coordonn√©es (a;b) pour la partie 3
const abKey = (a,b) => a + ';' + b;


/* ===== Utilitaire PDF : forcer la taille du SVG (300√ó300) ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }



// helpers you may already have:
const isEmptyTxt = id => !($('#'+id)?.value||'').trim();
const isEmptyCol = id => !($('#'+id+'_u')?.value||'').trim() && !($('#'+id+'_v')?.value||'').trim();

function namesArePaired(n1, n2){
  const s = v => String(v||'').toUpperCase().replace(/\s+/g,'');
  const map = { AB:'DC', BA:'CD', BC:'AD', CB:'DA' };
  const a = s(n1), b = s(n2);
  return !!(map[a] && map[a] === b);
}

function setTick(id, kind){ const el = document.getElementById(id); if(el){ el.className='tick '+(kind||''); el.textContent = kind==='ok' ? '‚úì' : kind==='ko' ? '‚úó' : ''; } }

function removeDefaultAnswerRow(){
  const ctrl = HOST.querySelector('.controls'); // le bloc "R√©ponse ‚Ä¶  #fb"
  if (ctrl) ctrl.remove();
}


/* ====== G√©n√©rateur d‚Äôexos ====== */
const REGISTRY_MAP = {


/* e1 ‚Äî Relation de Chasles (un seul ‚Äútrou‚Äù, parfois dans la somme) */
e1:{
  name:"Relation de Chasles",
  lead:"Compl√©ter l‚Äô√©galit√© en utilisant la relation de Chasles.",
  gen(){
    const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
    const takeDistinct = k=>{
      const used=new Set(), out=[];
      while(out.length<k){
        const L = LETTERS[randInt(0,LETTERS.length-1)];
        if(!used.has(L)){ used.add(L); out.push(L); }
      }
      return out;
    };

    const terms = (Math.random()<0.65 ? 2 : 3);       // 2 ou 3 vecteurs dans la somme
    const P = takeDistinct(terms+1);                  // cha√Æne P0‚ÄîP1‚Äî‚Ä¶‚ÄîPk
    const lhsNames = [];
    for(let i=0;i<terms;i++) lhsNames.push(`${P[i]}${P[i+1]}`);
    const rhsName  = `${P[0]}${P[terms]}`;

    // positions possibles du trou : 0..terms-1 (dans la somme) ou 'rhs'
    const choices = [...Array(terms).keys()].concat('rhs');
let hole;
if (terms === 3) {
  const pool = [0, 1, 1, 2, 'rhs']; // 1 est pr√©sent deux fois ‚Üí ~40% au milieu
  hole = pool[randInt(0, pool.length - 1)];
} else {
  const choices = [...Array(terms).keys()].concat('rhs');
  hole = choices[randInt(0, choices.length - 1)];
}    const expect = (hole==='rhs') ? rhsName : lhsNames[hole];

    // rendu : on met un input √† la place du trou, le reste en clair
    const slot = i => (i===hole
      ? `${mkVecNameInput('hole','')}`
      : `\\(\\overrightarrow{${lhsNames[i]}}\\)`);
    const rhsSlot = (hole==='rhs')
      ? `${mkVecNameInput('hole','')}`
      : `\\(\\overrightarrow{${rhsName}}\\)`;

    const plus = (a,b)=> a + '  + ' + b;
    const lhsHTML = lhsNames.map((_,i)=>slot(i)).reduce((acc,x,i)=> i?plus(acc,x):x, '');

    setEqu(`
      <p>Compl√©ter&nbsp;: ${lhsHTML} = ${rhsSlot}</p>
    `);
// Masquer la rang√©e "R√©ponse" par d√©faut (label + input #ans)
const defaultAnsRow = HOST.querySelector('.controls .input');
if (defaultAnsRow) defaultAnsRow.remove();

    // normalisation A‚ÄìZ live
    const inp = document.getElementById('hole');
    if (inp){ inp.addEventListener('input', e=>{ e.target.value = normVNameAZ(e.target.value); }); }

    this.state = { P, terms, lhsNames, rhsName, hole, expect };
    setStepsHTML(''); setFB(null,'');
    retypeset(HOST);
  },

  verify(){
    const {expect} = this.state||{};
    const got = normVNameAZ(document.getElementById('hole')?.value||'');
    if (!got){ setFB(false, 'Saisis un nom de vecteur (deux lettres).'); return false; }
    const ok = (got === expect);
    setFB(ok, ok ? '' : '');
    return ok;
  },

  solution(){
    const {lhsNames, rhsName} = this.state;
    const lhs = lhsNames.map(n=>`\\overrightarrow{${n}}`).join(' + ');
    setSteps([
      `\\(${lhs} = \\overrightarrow{${rhsName}}\\)`,
      `Relation de Chasles : on additionne des vecteurs cons√©cutifs pour aller directement de l‚Äôorigine √† l‚Äôextr√©mit√©.`
    ]);
  }
},

e2:{
  name:"R√®gle du parall√©logramme",
  lead:"√Ä l‚Äôaide du parall√©logramme, compl√©ter les √©galit√©s (saisir un nom de vecteur, ex. AB).",
  gen(){
  // ---- 4 lettres distinctes parmi A‚Ä¶Z
  const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
  const take4=()=>{ const u=new Set(); while(u.size<4) u.add(LETTERS[randInt(0,LETTERS.length-1)]); return [...u]; };
  const [LA,LB,LC,LD] = take4();
  const MAP = {A:LA, B:LB, C:LC, D:LD};
  const sub = name => name.replace(/[ABCD]/g, m => MAP[m]);

// Rep√®re plus large
const ui = renderWithRepereIntoHost(HOST, { xmin:-10, xmax:10, ymin:-10, ymax:10 });

// figure nue
ui.rep.gGrid.style.display = 'none';
ui.rep.gAxes.style.display = 'none';
ui.rep.el.style.border = 'none';

// Parall√©logramme AGRANDI en haut du cadre
const A = { a:-8, b: 7 };
const B = { a:  6, b: 7 };
const C = { a: 10, b: 3 };
const D = { a: -4, b: 3 };
this.state = { A,B,C,D, LA,LB,LC,LD };

// (optionnel) agrandir le SVG √† l'√©cran
ui.rep.el.style.width  = '520px';
ui.rep.el.style.height = '340px';

// tracer
ui.rep.setPoints([
  {x:A.a,y:A.b,label:LA},
  {x:B.a,y:B.b,label:LB},
  {x:C.a,y:C.b,label:LC},
  {x:D.a,y:D.b,label:LD}
]);
ui.rep.setVectors([
  {x1:A.a,y1:A.b,x2:B.a,y2:B.b,stroke:'#555'},
  {x1:B.a,y1:B.b,x2:C.a,y2:C.b,stroke:'#555'},
  {x1:C.a,y1:C.b,x2:D.a,y2:D.b,stroke:'#555'},
  {x1:D.a,y1:D.b,x2:A.a,y2:A.b,stroke:'#555'}
]);


// ---- Banque (√©crite en ABCD puis substitu√©e vers lettres tir√©es)
const BANK_ALL = [
  // lois vraies dans un parall√©logramme (diverses)
  {lhs:['AB','AD'], rhs:'AC'},
  {lhs:['BA','AD'], rhs:'BD'},
  {lhs:['CB','BA'], rhs:'CA'},
  {lhs:['DC','CB'], rhs:'DB'},
  {lhs:['AC','CD'], rhs:'AD'},
  {lhs:['DA','AB'], rhs:'DB'},
  {lhs:['BC','CD'], rhs:'BD'},
  {lhs:['CA','AB'], rhs:'CB'},
  {lhs:['DC','CA'], rhs:'DA'},
  {lhs:['AD','DC'], rhs:'AC'}
];

// 1) Deux √©galit√©s obligatoires "cons√©cutifs = diagonale"
const BANK_MAND = [
  { lhs: ['AB','AD'], rhs: 'AC' }, // depuis A
  { lhs: ['BA','BC'], rhs: 'BD' }  // depuis B
];

// 2) Substitution ABCD -> lettres tir√©es
const subIt = it => ({ lhs:[sub(it.lhs[0]), sub(it.lhs[1])], rhs: sub(it.rhs), _mand:true });
const MAND = BANK_MAND.map(subIt);

// 3) Compl√©ments √©ventuels (d√©j√† dans ton code)
const ALL  = BANK_ALL.map(it => ({ lhs:[sub(it.lhs[0]), sub(it.lhs[1])], rhs: sub(it.rhs), _mand:false }));

// 4) On construit le pool final (2 obligatoires + extras), puis on fabrique les lignes
const k = Math.max(2, randInt(3,4));
const used = new Set(MAND.map(it => it.lhs.join('|') + '=' + it.rhs));
const extra = [];
for (let i = 0; i < ALL.length && extra.length < (k - MAND.length); i++) {
  const it  = ALL[i];
  const key = it.lhs.join('|') + '=' + it.rhs;
  if (!used.has(key)) { used.add(key); extra.push(it); }
}
const POOL = MAND.concat(extra);
shuffle(POOL);

// 5) Construire les lignes
const rows = [];
for (let idx = 0; idx < POOL.length; idx++) {
  const it = POOL[idx];
  const id = 'hole_' + idx;
  let expect = '', where;

  // ‚¨ÖÔ∏è R√àGLE : pour les 2 ‚Äúcons√©cutifs = diagonale‚Äù, trou FORC√â √Ä DROITE
  if (it._mand) where = 'rhs';
  else {
    const choices = ['lhs0','lhs1','rhs'];
    where = choices[randInt(0, choices.length - 1)];
  }

  const cell = (name, hole) => hole ? mkVecNameInput(id,'') : `\\(\\overrightarrow{${name}}\\)`;

  let html = '';
  if (where === 'lhs0') { expect = it.lhs[0];
    html = `${cell(it.lhs[0],true)} + ${cell(it.lhs[1],false)} = ${cell(it.rhs,false)}`;
  } else if (where === 'lhs1') { expect = it.lhs[1];
    html = `${cell(it.lhs[0],false)} + ${cell(it.lhs[1],true)} = ${cell(it.rhs,false)}`;
  } else { /* rhs */ expect = it.rhs;
    html = `${cell(it.lhs[0],false)} + ${cell(it.lhs[1],false)} = ${cell(it.rhs,true)}`;
  }

  rows.push({ id, expect, html, lhs: it.lhs, rhs: it.rhs });
}

// 6) Rendu SANS .join + ticks
let lis = '';
for (let i = 0; i < rows.length; i++) {
  const r = rows[i];
  lis += '<li style="margin:.25rem 0">' + r.html + ' <span class="tick" id="tk_' + r.id + '"></span></li>';
}
ui.equ.innerHTML =
  '<p>Compl√©ter les √©galit√©s suivantes :</p>' +
  '<ol style="margin:.4rem 0 0 1.2rem">' + lis + '</ol>';

// normalisation + reset tick au saisie
for (let i = 0; i < rows.length; i++) {
  const r  = rows[i];
  const el = document.getElementById(r.id);
  if (!el) continue;
  el.addEventListener('input', e => {
    e.target.value = normVNameAZ(e.target.value);
    const tk = document.getElementById('tk_' + r.id);
    if (tk) { tk.textContent = ''; tk.className = 'tick'; }
  });
}

this.state.rows = rows;


  this.state.ui   = ui;
  retypeset(HOST);
  setStepsHTML(''); setFB(null,'');
}
,

verify(){
  const rows = this.state?.rows || [];
  let ok = 0, done = 0;

  for (let i = 0; i < rows.length; i++) {
    const r   = rows[i];
    const got = normVNameAZ(document.getElementById(r.id)?.value || '');
    const tk  = document.getElementById('tk_' + r.id);

    if (!got) { // vide ‚Üí pas de tick
      if (tk) { tk.textContent = ''; tk.className = 'tick'; }
      continue;
    }

    const good = (got === r.expect);
    if (tk) {
      tk.textContent = good ? '‚úì' : '‚úó';
      tk.className   = 'tick ' + (good ? 'ok' : 'ko');
    }
    done++; if (good) ok++;
  }

  if (done === 0) { setFB(false, 'Compl√®te au moins une √©galit√©.'); return false; }
  const all = (ok === rows.length);
  setFB(all, `${ok} / ${rows.length}`);
  return all;
}
,

solution(){
  const rows = this.state?.rows || [];
  const {A,B,C,D, LA,LB,LC,LD, ui} = this.state || {};

  // 1) Dessin corrig√© : on (re)trace le parall√©logramme + les diagonales
  if (ui && A && B && C && D){
    ui.rep.setVectors([
      // c√¥t√©s
      {x1:A.a,y1:A.b,x2:B.a,y2:B.b,stroke:'#555'},
      {x1:B.a,y1:B.b,x2:C.a,y2:C.b,stroke:'#555'},
      {x1:C.a,y1:C.b,x2:D.a,y2:D.b,stroke:'#555'},
      {x1:D.a,y1:D.b,x2:A.a,y2:A.b,stroke:'#555'},
      // diagonales (un peu mises en avant)
      {x1:A.a,y1:A.b,x2:C.a,y2:C.b,stroke:'#0a84ff'},
      {x1:B.a,y1:B.b,x2:D.a,y2:D.b,stroke:'#d32f2f'}
    ]);
  }

  // 2) Liste ¬´ compl√©tions ¬ª SANS .join
  let lis = '';
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    lis += '<li style="margin:.25rem 0">\\(' +
           '\\overrightarrow{' + r.lhs[0] + '} + \\overrightarrow{' + r.lhs[1] + '} = ' +
           '\\overrightarrow{' + r.rhs + '}' +
           '\\)</li>';
  }

  // 3) Rappel des deux √©galit√©s ‚Äúsomme de deux cons√©cutifs = diagonale‚Äù
  let rappel = '';
  if (LA && LB && LC && LD){
    rappel =
      '<div class="hint" style="margin-top:.4rem">' +
      'Rappels (parall√©logramme) : ' +
      '\\(\\overrightarrow{'+LA+LB+'} + \\overrightarrow{'+LA+LD+'} = \\overrightarrow{'+LA+LC+'}\\) ' +
      'et ' +
      '\\(\\overrightarrow{'+LB+LA+'} + \\overrightarrow{'+LB+LC+'} = \\overrightarrow{'+LB+LD+'}\\).' +
      '</div>';
  }

  // 4) Injection dans le bloc solution
  const html =
    '<p></p>' +
    '<ol style="margin:.4rem 0 0 1.2rem">' + lis + '</ol>';

  setStepsHTML(html);
  retypeset(HOST);
}

},


e3:{
  name:"Somme & diff√©rence de vecteurs ‚Äî identifier une lettre",
  gen(){
    const R={xmin:-6,xmax:6,ymin:-6,ymax:6};
    const ui = renderWithRepereIntoHost(HOST, R);
    const lim = ui.rep.innerLimits();
    const ri=(a,b)=>randInt(a,b);
    const inside=(x,y)=> x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax;

    // --- tirage robuste : on choisit d'abord E, u, v et les 5 cibles (lettres existantes),
    // puis on "remonte" A,B,C,D pour que les √©galit√©s soient vraies
    let S, E, u, v, Tm,Tn,Tp,Tq,Tr, A,B,C,D, tries=0;
// alphabet sans A,B,C,D,E et sans M,N,P,Q,R (pour √©viter toute ambigu√Øt√©)
const LETTER_POOL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  .split('')
  .filter(L => !['A','B','C','D','E','M','N','P','Q','R'].includes(L));

    function key(x,y){return x+';'+y;}

    do{
      // point E "centre" pour les fl√®ches
      E = {x:ri(lim.xmin+1, lim.xmax-1), y:ri(lim.ymin+1, lim.ymax-1)};

      // vecteurs u, v (petits et non nuls, extr√©mit√©s dans le cadre)
      u = {a:ri(-3,3), b:ri(-3,3)}; if(u.a===0 && u.b===0) u.a=1;
      v = {a:ri(-3,3), b:ri(-3,3)}; if(v.a===0 && v.b===0) v.b=1;
      const Eu={x:E.x+u.a,y:E.y+u.b}, Ev={x:E.x+v.a,y:E.y+v.b};
      if(!inside(Eu.x,Eu.y) || !inside(Ev.x,Ev.y)) { tries++; continue; }

      // on place 5 cibles distinctes (lettres autres que A..E)
      const used = new Set([key(E.x,E.y)]);
      function uniqPt(){
        let x,y,t=0; do{ x=ri(lim.xmin,lim.xmax); y=ri(lim.ymin,lim.ymax); }while(used.has(key(x,y)) && ++t<500);
        used.add(key(x,y)); return {x,y};
      }
      Tm = uniqPt(); Tn = uniqPt(); Tp = uniqPt(); Tq = uniqPt(); 
// ...
// point pour ER = u - v : extr√©mit√© FIX√âE √† E + u - v
const candR = { x: E.x + u.a - v.a, y: E.y + u.b - v.b };
if (!inside(candR.x, candR.y)) { tries++; continue; }   // hors cadre ‚Üí on retente
Tr = candR;
// ...

      // remonter A,B,C,D pour que :
      // AM = u, BN = -v, CP = u+v, DQ = -u+v
      A = {x: Tm.x - u.a,     y: Tm.y - u.b};
      B = {x: Tn.x + v.a,     y: Tn.y + v.b};
      C = {x: Tp.x - u.a - v.a, y: Tp.y - u.b - v.b};
      D = {x: Tq.x + u.a - v.a, y: Tq.y + u.b - v.b};

      // tout doit rester dans le cadre et distinct
      const pts=[A,B,C,D,Tm,Tn,Tp,Tq,Tr,E];
      if(!pts.every(p=>inside(p.x,p.y))) { tries++; continue; }
      const uniq = new Set(pts.map(p=>key(p.x,p.y)));
      if(uniq.size!==pts.length) { tries++; continue; }

      // assemble l‚Äôensemble affich√© : A,B,C,D,E + 5 cibles + 4/5 points de remplissage
      S = [
        {pt:A, L:'A'}, {pt:B, L:'B'}, {pt:C, L:'C'}, {pt:D, L:'D'}, {pt:E, L:'E'}
      ];
      // attribuer des lettres aux cibles (toutes diff√©rentes et ‚â† A..E)
      const bag = LETTER_POOL.slice();
      const pick = ()=>bag.splice(randInt(0,bag.length-1),1)[0];
      const LM = pick(), LN = pick(), LP = pick(), LQ = pick(), LR = pick();
      S.push({pt:Tm, L:LM}, {pt:Tn, L:LN}, {pt:Tp, L:LP}, {pt:Tq, L:LQ}, {pt:Tr, L:LR});

      // quelques points en plus (leur pr√©sence n'affecte pas l'exercice)
      const extraCount = 4;
      for(let i=0;i<extraCount;i++){
        let P, t=0; do{ P={x:ri(lim.xmin,lim.xmax), y:ri(lim.ymin,lim.ymax)}; }
        while(S.some(q=>q.pt.x===P.x && q.pt.y===P.y) && ++t<400);
        if(t<400) S.push({pt:P, L: pick()});
      }

      // OK si A,B,C,D distincts de E et des cibles (d√©j√† garanti), on peut sortir
      this.state = {
        ui, E, u, v,
        A,B,C,D,
        target:{ M:LM, N:LN, P:LP, Q:LQ, R:LR } // lettres attendues
      };
      break;
    }while(++tries<1200);


    // rendu graphique
    ui.rep.setPoints(S.map(o=>({x:o.pt.x,y:o.pt.y,label:o.L})));
    ui.rep.setVectors([
      {x1:E.x,y1:E.y,x2:E.x+u.a,y2:E.y+u.b,stroke:'#c62828'},
      {x1:E.x,y1:E.y,x2:E.x+v.a,y2:E.y+v.b,stroke:'#1565c0'}
    ]);
    // labels \vec u, \vec v
    const Eu = ui.rep.coordToScreen(E.x+u.a, E.y+u.b);
    const Ev = ui.rep.coordToScreen(E.x+v.a, E.y+v.b);
    ui.rep.gVec.appendChild(ui.rep._latexFO('\\(\\vec u\\)', Eu.x-18, Eu.y-22, '#c62828'));
    ui.rep.gVec.appendChild(ui.rep._latexFO('\\(\\vec v\\)', Ev.x+6 , Ev.y-18, '#1565c0'));
    retypeset(HOST);

    // √©nonc√© + 5 entr√©es ‚Äúune lettre‚Äù (aucune M,N,P,Q,R n‚Äôest dessin√©e)
    const rows = [
      {id:'m', tex:`\\overrightarrow{AM}=\\vec u`,          expectKey:'M'},
      {id:'n', tex:`\\overrightarrow{BN}=-\\vec v`,         expectKey:'N'},
      {id:'p', tex:`\\overrightarrow{CP}=\\vec u+\\vec v`,  expectKey:'P'},
      {id:'q', tex:`\\overrightarrow{DQ}=-\\vec u+\\vec v`, expectKey:'Q'},
      {id:'r', tex:`\\overrightarrow{ER}=\\vec u-\\vec v`,  expectKey:'R'}
    ];

    let html = '<p>Soit \\(A\\) et \\(B\\) deux points du plan et \\(\\overrightarrow{u}\\) et \\(\\overrightarrow{v}\\) deux vecteurs.<br>Sur la figure ci-dessous, identifier les points \\(M,N,P\\) et \\(Q\\) tels que :</p>';
    html += '<ol style="margin:.4rem 0 0 1.2rem">';
    for(const r of rows){
      html += `<li style="margin:.25rem 0">\\(${r.tex}\\) :
                 <input id="ans_${r.id}" type="text" maxlength="1" style="width:44px;text-align:center">
                 <span class="tick" id="tk_${r.id}"></span>
               </li>`;
    }
    html += '</ol>';
    ui.equ.innerHTML = html; retypeset(HOST);

    for(const r of rows){
      const el = document.getElementById('ans_'+r.id);
      el.addEventListener('input', e=>{
        e.target.value = String(e.target.value||'').toUpperCase().replace(/[^A-Z]/g,'').slice(0,1);
        const tk=document.getElementById('tk_'+r.id); if(tk){ tk.textContent=''; tk.className='tick'; }
      });
    }

    this.state.rows = rows;
    setFB(null,''); setStepsHTML('');
  },

  verify(){
    const st=this.state, rows=st.rows||[], tgt=st.target||{};
    let ok=0, done=0;
    for(const r of rows){
      const val=(document.getElementById('ans_'+r.id)?.value||'').toUpperCase().trim();
      const tk=document.getElementById('tk_'+r.id);
      if(!val){ if(tk){ tk.textContent=''; tk.className='tick'; } continue; } // neutre si vide
      const good = (val === tgt[r.expectKey]);
      if(tk){ tk.textContent = good ? '‚úì' : '‚úó'; tk.className = 'tick ' + (good?'ok':'ko'); }
      done++; if(good) ok++;
    }
    if(done===0){ setFB(false,'Compl√®te au moins une r√©ponse.'); return false; }
    const all = (ok===rows.length);
    setFB(all, `${ok} / ${rows.length}`);
    return all;
  },

  solution(){
    const {ui,u,v,target} = this.state;
    const L = [
      `De \\(\\overrightarrow{AM}=\\vec u\\), on lit \\(M=${target.M}\\).`,
      `De \\(\\overrightarrow{BN}=-\\vec v\\), on lit \\(N=${target.N}\\).`,
      `De \\(\\overrightarrow{CP}=\\vec u+\\vec v\\), on lit \\(P=${target.P}\\).`,
      `De \\(\\overrightarrow{DQ}=-\\vec u+\\vec v\\), on lit \\(Q=${target.Q}\\).`,
      `De \\(\\overrightarrow{ER}=\\vec u-\\vec v\\), on lit \\(R=${target.R}\\).`
    ];
    let html=''; for(const s of L) html += `<p>${s}</p>`;
    ui.res.innerHTML = html; retypeset(HOST);
  }
},

e4:{
  name:"Sommes & diff√©rences de vecteurs (u, v, w)",
  lead:"Les coordonn√©es de \\(\\vec u\\), \\(\\vec v\\) et \\(\\vec w\\) sont donn√©es. Calculer celles des combinaisons demand√©es (r√©ponse en colonne).",
  gen(){
    // --- tirage propre de u, v, w (petits entiers non nuls)
    function pick(){ let a=randInt(-7,7), b=randInt(-7,7); if(a===0&&b===0) a=1; return {a,b}; }
    const U=pick(), V=pick(), W=pick();
    this.state={U,V,W};

    // √©nonc√©
    let html = '';
    html += `<p>On se place dans un rep√®re \\((O;\\,\\vec i,\\,\\vec j)\\).</p>`;
    html += `<p>Soient \\(\\vec u${fmtVecLaNum(U.a,U.b)}\\), \\(\\vec v${fmtVecLaNum(V.a,V.b)}\\) et \\(\\vec w${fmtVecLaNum(W.a,W.b)}\\).</p>`;
    html += `<p>Calculer les coordonn√©es des vecteurs suivants :</p>`;

    // lignes (5 expressions)
    const rows = [
      { id:'r1', tex:'\\vec u + \\vec v',     eval: (U,V,W)=>({x:U.a+V.a, y:U.b+V.b}) },
      { id:'r2', tex:'\\vec u - \\vec v',     eval: (U,V,W)=>({x:U.a-V.a, y:U.b-V.b}) },
      { id:'r3', tex:'-\\vec u + \\vec w',    eval: (U,V,W)=>({x:-U.a+W.a, y:-U.b+W.b}) },
      { id:'r4', tex:'\\vec u + \\vec v + \\vec w', eval: (U,V,W)=>({x:U.a+V.a+W.a, y:U.b+V.b+W.b}) },
      { id:'r5', tex:'\\vec u + \\vec v - \\vec w', eval: (U,V,W)=>({x:U.a+V.a-W.a, y:U.b+V.b-W.b}) },
    ];
    this.state.rows = rows;

    // rendu sans .join
    html += '<ol >';
    for(const r of rows){
      html += `<li style="margin:.28rem 0">\\(${r.tex}\\)  ${mkColInput(r.id,'u','v','sm')} <span class="tick" id="tk_${r.id}"></span></li>`;
    }
    html += '</ol>';
    setEqu(html);
removeDefaultAnswerRow();   // ‚¨ÖÔ∏è vire la ligne "R√©ponse" et le #fb

    // reset ticks √† la saisie
    for(const r of rows){
      const uEl = document.getElementById(r.id+'_u');
      const vEl = document.getElementById(r.id+'_v');
      const clr = () => { const t=$('#tk_'+r.id); if(t){ t.textContent=''; t.className='tick'; } };
      if(uEl) uEl.addEventListener('input', clr);
      if(vEl) vEl.addEventListener('input', clr);
    }
    setFB(null,''); setStepsHTML('');
  },

  verify(){
    const {U,V,W,rows}=this.state;
    let ok=0, tot=0;
    for(const r of rows){
      const read = getPairFromInputs(r.id);
      const t = document.getElementById('tk_'+r.id);
      if(read.empty){ if(t){ t.textContent=''; t.className='tick'; } continue; } // neutre si vide
      const exp = r.eval(U,V,W);
      const good = read.ok && Math.abs(read.u-exp.x)<1e-9 && Math.abs(read.v-exp.y)<1e-9;
      if(t){ t.textContent = good?'‚úì':'‚úó'; t.className = 'tick ' + (good?'ok':'ko'); }
      tot++; if(good) ok++;
    }
if (tot===0){ setFB(null,''); return false; }          // aucun message
    const all = ok===rows.length;
    setFB(all, `${ok} / ${rows.length}`);
    return all;
  },

solution(){
  const {U,V,W,rows}=this.state;

  // affiche "a ¬± b ¬± c" sans parenth√®ses inutiles
  function sumExpr(nums){
    let s = String(nums[0]);
    for(let i=1;i<nums.length;i++){
      const n = nums[i];
      s += (n<0 ? ' - '+Math.abs(n) : ' + '+n);
    }
    return s;
  }

  // un item <li> num√©rot√© (1., 2., ‚Ä¶)
  function li(tex, xs, ys, xr, yr){
    let out = '';
    out += `<li style="margin:.25rem 0">`;
    out +=   `<div>\\(${tex}${colVecExpr(sumExpr(xs), sumExpr(ys))}\\)</div>`;
    out +=   `<div>\\(${tex} ${fmtVecLaNum(xr,yr)}\\)</div>`;
    out += `</li>`;
    return out;
  }

  let html = '<ol>';

  // 1) u+v
  let e = rows[0].eval(U,V,W);
  html += li('\\vec u+\\vec v', [U.a,V.a], [U.b,V.b], e.x, e.y);

  // 2) u-v
  e = rows[1].eval(U,V,W);
  html += li('\\vec u-\\vec v', [U.a,-V.a], [U.b,-V.b], e.x, e.y);

  // 3) -u+w
  e = rows[2].eval(U,V,W);
  html += li('-\\vec u+\\vec w', [-U.a,W.a], [-U.b,W.b], e.x, e.y);

  // 4) u+v+w
  e = rows[3].eval(U,V,W);
  html += li('\\vec u+\\vec v+\\vec w', [U.a,V.a,W.a], [U.b,V.b,W.b], e.x, e.y);

  // 5) u+v-w
  e = rows[4].eval(U,V,W);
  html += li('\\vec u+\\vec v-\\vec w', [U.a,V.a,-W.a], [U.b,V.b,-W.b], e.x, e.y);

  html += '</ol>';
  setStepsHTML(html);
}

},


e5:{
  name:"Placer B et C ‚Äî AB=u+v, AC=u-v",
  lead:"Cliquer dans le rep√®re pour placer les points \\(B\\) et \\(C\\). Utilise les puces ¬´ Placer B / Placer C ¬ª.",
  gen(){
    // 1) Mise en page avec rep√®re √† gauche
const ui = renderWithRepereIntoHost(HOST, { xmin:-8, xmax:8, ymin:-8, ymax:8 });
ui.rep.gAxes.style.display = 'none';

const lim = ui.rep.innerLimits();
const ri=(a,b)=>randInt(a,b);
const inside=(x,y)=> x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax;

// test croisement segments [P1,P2] et [Q1,Q2] en coordonn√©es enti√®res
function cross(A,B,C,D){
  const s = (P,Q,R)=> (Q.x-P.x)*(R.y-P.y) - (Q.y-P.y)*(R.x-P.x);
  const o1=s(A,B,C), o2=s(A,B,D), o3=s(C,D,A), o4=s(C,D,B);
  if (o1===0 && o2===0 && o3===0 && o4===0) return false; // colin√©aires: on tol√®re (on place loin)
  return (o1>0)!==(o2>0) && (o3>0)!==(o4>0);
}
let A,u,v,Pu,Pv,tries=0;

const notAxis = (x,y)=> (x!==0 && y!==0);

// vecteur non nul, pas d‚Äôaxes, pas de coordonn√©e ¬±1
function pickVec(range=4){
  let a,b;
  do{
    a = ri(-range, range); b = ri(-range, range);
  }while(
    a===0 || b===0 || Math.abs(a)===1 || Math.abs(b)===1
  );
  return {a,b};
}

// quadrillage 3√ó3 et cases candidates qui ne traversent pas les axes
const cells = makeCells(lim, 3, 3);
const candidates = cells.filter(c => !(c.xmin<=0 && c.xmax>=0) && !(c.ymin<=0 && c.ymax>=0));

function pickIn(cell){
  let x,y,s=0;
  do{
    x = ri(cell.xmin+1, cell.xmax-1);
    y = ri(cell.ymin+1, cell.ymax-1);
  }while(!notAxis(x,y) && ++s<200);
  return {x,y};
}

function segmentsCross(A,B,C,D){
  const s=(P,Q,R)=> (Q.x-P.x)*(R.y-P.y) - (Q.y-P.y)*(R.x-P.x);
  const o1=s(A,B,C), o2=s(A,B,D), o3=s(C,D,A), o4=s(C,D,B);
  if (o1===0 && o2===0 && o3===0 && o4===0) return false;
  return (o1>0)!==(o2>0) && (o3>0)!==(o4>0);
}

function isOpposite(u,v){ return (u.a === -v.a) && (u.b === -v.b); }
function isEqual(u,v){ return (u.a === v.a) && (u.b === v.b); }
function isZero(x,y){ return x===0 && y===0; }
function fitsLim(lim, P){ return P.x>=lim.xmin && P.x<=lim.xmax && P.y>=lim.ymin && P.y<=lim.ymax; }


// temporaires visibles depuis l'ext√©rieur de la boucle
let BexpTmp, CexpTmp;

// ===== tirage √† paliers =====
// ===== tirage √† paliers =====
do{
  // palier 1 : range ‚Äúnormal‚Äù
  let range = 4;
  if (tries > 600)  range = 5;
  if (tries > 1200) range = 6;

  // u
  u = pickVec(range);

  // v ‚Äî on refuse v = u ou v = -u
  let guardV = 0;
  do{
    v = pickVec(range);
  }while((isEqual(u,v) || isOpposite(u,v)) && ++guardV < 200);

  // si malgr√© tout on a un cas d√©g√©n√©r√©, on relance le tirage complet
  if (isEqual(u,v) || isOpposite(u,v)) { tries++; continue; }


  // A avec marges suffisantes + pas sur axes
  const mx = Math.max(Math.abs(u.a+v.a), Math.abs(u.a-v.a)) + 1;
  const my = Math.max(Math.abs(u.b+v.b), Math.abs(u.b-v.b)) + 1;

  let guardA = 0;
  do{
    A = { x: ri(lim.xmin+mx, lim.xmax-mx),
          y: ri(lim.ymin+my, lim.ymax-my) };
  }while(!notAxis(A.x,A.y) && ++guardA<300);

  // si on n'a pas r√©ussi √† sortir A des axes ‚Üí on retente compl√®tement
  if (!notAxis(A.x,A.y)) { tries++; continue; }

// ----- apr√®s avoir choisi A -----
// points attendus
BexpTmp = { x: A.x + u.a + v.a, y: A.y + u.b + v.b };
CexpTmp = { x: A.x + u.a - v.a, y: A.y + u.b - v.b };


// refus : B ou C confondus avec A (s√©curit√©)
if ((BexpTmp.x===A.x && BexpTmp.y===A.y) || (CexpTmp.x===A.x && CexpTmp.y===A.y)) { tries++; continue; }

// refus : B ou C hors limites internes
if (!fitsLim(lim, BexpTmp) || !fitsLim(lim, CexpTmp)) { tries++; continue; }

// (optionnel) pas sur les axes si tu veux rester clean
if (!notAxis(BexpTmp.x,BexpTmp.y) || !notAxis(CexpTmp.x,CexpTmp.y)) { tries++; continue; }




  // deux cases candidates distinctes
  const c1 = candidates[ri(0, candidates.length-1)];
  let c2;
  let guardC = 0;
  do{ c2 = candidates[ri(0, candidates.length-1)]; }while(c2===c1 && ++guardC<100);

  Pu = pickIn(c1);
  Pv = pickIn(c2);

  const Ue = { x: Pu.x+u.a, y: Pu.y+u.b };
  const Ve = { x: Pv.x+v.a, y: Pv.y+v.b };

  const okEnds = inside(Ue.x,Ue.y) && inside(Ve.x,Ve.y)
              && notAxis(Ue.x,Ue.y) && notAxis(Ve.x,Ve.y);

  // si √ßa coince trop souvent, on tol√®re √† partir du palier 3 que UNE seule extr√©mit√© touche un axe
  const relaxedOk = (tries > 1200)
    ? inside(Ue.x,Ue.y) && inside(Ve.x,Ve.y) &&
      !(Ue.x===0 && Ue.y===0) && !(Ve.x===0 && Ve.y===0) &&
      (notAxis(Ue.x,Ue.y) || notAxis(Ve.x,Ve.y))
    : okEnds;

  const segOK = relaxedOk && !segmentsCross(Pu,Ue,Pv,Ve);

  if (segOK) break;
}while(++tries < 2000);

// si on a touch√© le plafond, on refait un tirage simple ‚Äúsecours‚Äù (garanti fin)
if (tries >= 2000){
  u = pickVec(4); v = pickVec(4);
  // refuse v = ¬±u ici aussi
  while (isEqual(u,v) || isOpposite(u,v)) v = pickVec(4);

  A = { x: ri(lim.xmin+3, lim.xmax-3), y: ri(lim.ymin+3, lim.ymax-3) };

  const corners = candidates;
  const c1 = corners[ri(0, corners.length-1)];
  const c2 = corners[(corners.indexOf(c1)+2) % corners.length];
  Pu = pickIn(c1); Pv = pickIn(c2);

  // Bexp/Cexp et filtre cadre
BexpTmp = { x: A.x + u.a + v.a, y: A.y + u.b + v.b };
CexpTmp = { x: A.x + u.a - v.a, y: A.y + u.b - v.b };

  if (!fitsLim(lim,BexpTmp) || !fitsLim(lim,CexpTmp)) {
    // on retombe sur la boucle normale
    tries = 0;
  }
}


// points attendus (assur√©s dans le cadre gr√¢ce √† la marge)
// au cas (rare) o√π la boucle sortirait sans assignation explicite
const Bexp = BexpTmp || { x: A.x + u.a + v.a, y: A.y + u.b + v.b };
const Cexp = CexpTmp || { x: A.x + u.a - v.a, y: A.y + u.b - v.b };



    // 4) Trac√© de la figure (A, u, v)
    ui.rep.setPoints([{x:A.x,y:A.y,label:'A'}]);
ui.rep.setVectors([
  { x1:Pu.x, y1:Pu.y, x2:Pu.x+u.a, y2:Pu.y+u.b, stroke:'#c62828', label:'u', w:3.6 }, // u plus √©pais
  { x1:Pv.x, y1:Pv.y, x2:Pv.x+v.a, y2:Pv.y+v.b, stroke:'#1565c0', label:'v', w:3.6 }  // v plus √©pais
]);


    // 5) √ânonc√© + puces d‚Äôaction + deux ticks
    ui.equ.innerHTML =
      '<div class="sec"><div class="title">Consignes</div>' +
      '<p>Placer les points \\(B\\) et \\(C\\) tels que :</p>' +
      '<ul style="margin:.2rem 0 0 1.2rem">' +
        '<li>\\(\\overrightarrow{AB}=\\vec u+\\vec v\\) <span class="tick" id="tkB"></span></li>' +
        '<li>\\(\\overrightarrow{AC}=\\vec u-\\vec v\\) <span class="tick" id="tkC"></span></li>' +
      '</ul></div>';
    ui.actions.innerHTML =
      '<div class="chips">' +
        '<span class="chip active" id="chipB">Placer B</span>' +
        '<span class="chip" id="chipC">Placer C</span>' +
        '<span class="chip" id="clrB">Effacer B</span>' +
        '<span class="chip" id="clrC">Effacer C</span>' +
      '</div>';

    // 6) Interaction : mode actif B/C + placement au clic
    let MODE = 'B';
    const chipB = document.getElementById('chipB');
    const chipC = document.getElementById('chipC');
    const clrB  = document.getElementById('clrB');
    const clrC  = document.getElementById('clrC');

    function setMode(m){
      MODE=m;
      chipB.classList.toggle('active', m==='B');
      chipC.classList.toggle('active', m==='C');
    }
    chipB.addEventListener('click', ()=>setMode('B'));
    chipC.addEventListener('click', ()=>setMode('C'));

    const state = { ui, A, u, v, Bexp, Cexp, B:null, C:null };

    clrB.addEventListener('click', ()=>{
      state.B=null; ui.rep.clearUser(); if(state.C) ui.rep.placeUser('C',state.C.x,state.C.y);
      setTick('tkB',''); setFB(null,'');
    });
    clrC.addEventListener('click', ()=>{
      state.C=null; ui.rep.clearUser(); if(state.B) ui.rep.placeUser('B',state.B.x,state.B.y);
      setTick('tkC',''); setFB(null,'');
    });

    ui.rep.clickable = true;
ui.rep.onClick = ({x,y})=>{
  if (MODE==='B') state.B = {x,y}; else state.C = {x,y};

  // points
  ui.rep.clearUser();
  if(state.B) ui.rep.placeUser('B', state.B.x, state.B.y, '#7b1fa2'); // violet
  if(state.C) ui.rep.placeUser('C', state.C.x, state.C.y, '#2e7d32'); // vert

  // vecteurs depuis A
  ui.rep.clearUserVectors();
  if(state.B) ui.rep.placeUserVector(null, state.A.x, state.A.y, state.B.x, state.B.y, '#7b1fa2'); // AB violet
  if(state.C) ui.rep.placeUserVector(null, state.A.x, state.A.y, state.C.x, state.C.y, '#2e7d32'); // AC vert

  setFB(null,'');
};


    this.state = state;
    retypeset(HOST);
    setFB(null,'');
    setStepsHTML('');
  },

  verify(){
    const st=this.state; if(!st) return false;
    const near=(P,Q)=> P && Q && Math.abs(P.x-Q.x)<1e-9 && Math.abs(P.y-Q.y)<1e-9;

    // √©value s√©par√©ment B et C ; si vide ‚Üí pas de tick
    let done=0, ok=0;

    const tkB=document.getElementById('tkB');
    if (st.B){
      const goodB = near(st.B, st.Bexp);
      if (tkB){ tkB.textContent = goodB?'‚úì':'‚úó'; tkB.className='tick '+(goodB?'ok':'ko'); }
      done++; if(goodB) ok++;
    }else if(tkB){ tkB.textContent=''; tkB.className='tick'; }

    const tkC=document.getElementById('tkC');
    if (st.C){
      const goodC = near(st.C, st.Cexp);
      if (tkC){ tkC.textContent = goodC?'‚úì':'‚úó'; tkC.className='tick '+(goodC?'ok':'ko'); }
      done++; if(goodC) ok++;
    }else if(tkC){ tkC.textContent=''; tkC.className='tick'; }

    if (done===0){ setFB(null,''); return false; } // aucun message si rien plac√©
    const all = (ok===2);
    setFB(all, `${ok} / 2`);
    return all;
  },

solution(){
  const {ui, A, Bexp, Cexp} = this.state;

  // 1) points
  ui.rep.clearUser();
ui.rep.placeUser('B', Bexp.x, Bexp.y, '#7b1fa2'); // violet
ui.rep.placeUser('C', Cexp.x, Cexp.y, '#2e7d32'); // vert


  // 2) vecteurs corrig√©s : purge + (AB violet) + (AC vert)
  ui.rep.clearUserVectors();

  // petit helper pour contr√¥ler l'√©paisseur
  function drawVec(color, x1, y1, x2, y2){
    // placeUserVector ne g√®re pas encore l'√©paisseur ‚Üí on le fait ‚Äú√† la main‚Äù
    const ns = ui.rep.el.namespaceURI;
    const g  = document.createElementNS(ns,'g');
    const ln = document.createElementNS(ns,'line');
    const p1 = ui.rep.coordToScreen(x1,y1);
    const p2 = ui.rep.coordToScreen(x2,y2);
    ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y);
    ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
    ln.setAttribute('stroke',color);
    ln.setAttribute('stroke-width','3');           // ‚¨ÖÔ∏è plus visible
ln.setAttribute('marker-end','url(#vecArrow)');
    g.appendChild(ln);
    ui.rep.gUserVec.appendChild(g);                // ‚¨ÖÔ∏è tout en haut
  }

  drawVec('#7b1fa2', A.x, A.y, Bexp.x, Bexp.y);    // AB violet
  drawVec('#2e7d32', A.x, A.y, Cexp.x, Cexp.y);    // AC vert


}

},


e6:{
  name:"Sommes de vecteurs dans des parall√©logrammes",
  lead:"Figure sans quadrillage. \\(I,J,K,L\\) milieux de \\([AB],[BC],[CD],[DA]\\), \\(O\\) centre. Compl√©ter chaque √©galit√© avec un nom de vecteur correct (plusieurs r√©ponses possibles).",
  gen(){
    const ui = renderWithRepereIntoHost(HOST, { xmin:-9, xmax:9, ymin:-9, ymax:9 });
    // ‚Äî pas de quadrillage ni axes
    ui.rep.gGrid.style.display = 'none';
    ui.rep.gAxes.style.display = 'none';

    // ‚Äî figures FIXES (m√™mes coordonn√©es √† chaque g√©n√©ration)
    const TYPES = ['parall√©logramme','losange','rectangle','carr√©'];
    const kind  = TYPES[randInt(0,TYPES.length-1)];

    function mids(P,Q){ return {a:(P.a+Q.a)/2, b:(P.b+Q.b)/2}; }

    let A,B,C,D;
    switch(kind){
      case 'carr√©':       // c√¥t√© 8, centr√©
        A={a:-4,b: 4}; B={a: 4,b: 4}; C={a: 4,b:-4}; D={a:-4,b:-4}; break;
      case 'rectangle':   // 10√ó6, centr√©
        A={a:-5,b: 3}; B={a: 5,b: 3}; C={a: 5,b:-3}; D={a:-5,b:-3}; break;
case 'losange': {
  // --- Losange fixe, diagonales H/V, PAS un carr√© (dx ‚â† dy)
  // Cadre suppos√© ~[-10,10]√ó[-10,10] et sans quadrillage/axes.
  const Ocx = -1, Ocy = 1;    // centre O (fixe)
  const dx  = 6;              // demi-diagonale horizontale
  const dy  = 3;              // demi-diagonale verticale (‚â† dx)

  // Ordre autour du contour : A (gauche) -> B (haut) -> C (droite) -> D (bas)
  A = { a: Ocx - dx, b: Ocy       };   // gauche
  B = { a: Ocx,       b: Ocy + dy };   // haut
  C = { a: Ocx + dx, b: Ocy       };   // droite
  D = { a: Ocx,       b: Ocy - dy };   // bas

  // Diagonales : AC horizontale, BD verticale
  // C√¥t√©s √©gaux (‚àö(dx¬≤+dy¬≤)). Comme dx ‚â† dy ‚áí pas un carr√©.
  break;
}


      default:            // parall√©logramme non rectangle/losange
        A={a:-7,b: 3}; B={a: 4,b: 3}; C={a: 8,b:-3}; D={a:-3,b:-3}; break;
    }

    const I=mids(A,B), J=mids(B,C), K=mids(C,D), L=mids(D,A), O=mids(A,C);
    const PTS = {A,B,C,D,I,J,K,L,O};
    const names = Object.keys(PTS);

    // ‚Äî dessin des bords + diagonales (l√©ger)
    ui.rep.setPoints(names.map(n=>({x:PTS[n].a,y:PTS[n].b,label:n})));
ui.rep.setVectors([
  {x1:A.a,y1:A.b,x2:B.a,y2:B.b,stroke:'#444', arrow:false},
  {x1:B.a,y1:B.b,x2:C.a,y2:C.b,stroke:'#444', arrow:false},
  {x1:C.a,y1:C.b,x2:D.a,y2:D.b,stroke:'#444', arrow:false},
  {x1:D.a,y1:D.b,x2:A.a,y2:A.b,stroke:'#444', arrow:false},
  {x1:A.a,y1:A.b,x2:C.a,y2:C.b,stroke:'#999', arrow:false},
  {x1:B.a,y1:B.b,x2:D.a,y2:D.b,stroke:'#999', arrow:false}
]);

// ‚Ä¶ apr√®s avoir construit A,B,C,D puis I,J,K,L,O et l'objet PTS ‚Ä¶

// === Offsets "au dehors" par rapport au centre O ===
function offsetOut(P, O){
  // direction "vers l'ext√©rieur" (par rapport au centre)
  const sx = (P.a > O.a) ? 1 : (P.a < O.a ? -1 : 0);
  const sy = (P.b > O.b) ? 1 : (P.b < O.b ? -1 : 0);

  // bar√®me doux en pixels (SVG ‚Üó = x+, ‚Üò = y+)
  // gauche/droite surtout via dx, haut/bas via dy
  let dx = 0, dy = 0;

  if (sx < 0) dx = -16;       // √† gauche du point
  if (sx > 0) dx = 8;         // √† droite du point
  if (sx === 0) dx = -6;      // centr√© horizontal : petit d√©calage √† gauche

  if (sy > 0) dy = -10;       // au-dessus (y √©cran n√©gatif)
  if (sy < 0) dy = 14;        // au-dessous
  if (sy === 0) dy = 4;       // centr√© vertical : petit d√©calage bas

  return {dx, dy};
}

// === Injection des points avec dx,dy "au dehors"
(function(){
  const order = ['A','B','C','D','I','J','K','L','O']; // O restera dedans (pas d‚Äôext.)
  const arr = [];
  for (let i = 0; i < order.length; i++){
    const n = order[i];
    const P = PTS[n];
    const off = (n === 'O') ? {dx:6, dy:-6} : offsetOut(P, O); // O au centre
    arr.push({ x:P.a, y:P.b, label:n, dx:off.dx, dy:off.dy });
  }
  ui.rep.setPoints(arr);
})();

    // ‚Äî toutes les fl√®ches XY disponibles
    const v = (X,Y)=>({x:PTS[Y].a-PTS[X].a, y:PTS[Y].b-PTS[X].b});
    const eq = (u,w)=>Math.abs(u.x-w.x)<1e-9 && Math.abs(u.y-w.y)<1e-9;
    const ALL=[];
    for(let i=0;i<names.length;i++) for(let j=0;j<names.length;j++){
      if(i===j) continue; const X=names[i],Y=names[j]; ALL.push({name:X+Y, vec:v(X,Y)});
    }

  // ‚Äî utilitaires pour la fabrique des lignes
const vXY = (X,Y)=>({x:PTS[Y].a-PTS[X].a, y:PTS[Y].b-PTS[X].b});
const eqv  = (u,w)=>Math.abs(u.x-w.x)<1e-9 && Math.abs(u.y-w.y)<1e-9;

// Chasles *directe* pour une somme de 2 vecteurs : XY + YZ (ou sym√©trique)
function isChasles2(picks){
  if (picks.length !== 2) return false;
  const a = picks[0], b = picks[1];
  return (a.Y === b.X) || (b.Y === a.X);
}

// Construit le LHS en TeX SANS .join
function lhsTex(picks){
  let s = '';
  for (let i = 0; i < picks.length; i++){
    if (i > 0) s += ' + ';
    s += '\\overrightarrow{' + picks[i].X + picks[i].Y + '}';
  }
  return s;
}

// fabrique UNE ligne (2 ou 3 termes), en √©vitant la Chasles directe
function makeRow(force3 = false){
  const terms = force3 ? 3 : (Math.random() < .7 ? 2 : 3);
  const picks = [];
  while (picks.length < terms){
    const X = names[randInt(0, names.length-1)];
    const Y = names[randInt(0, names.length-1)];
    if (X === Y) continue;
    picks.push({X, Y});
  }
  if (terms === 2 && isChasles2(picks)) return null; // refuse XY+YZ

  // vecteur r√©sultant
  let R = {x:0, y:0};
  for (let i = 0; i < picks.length; i++){
    const w = vXY(picks[i].X, picks[i].Y);
    R = { x: R.x + w.x, y: R.y + w.y };
  }

  // toutes les solutions XY possibles
  const sols = [];
  for (let i = 0; i < names.length; i++){
    for (let j = 0; j < names.length; j++){
      if (i === j) continue;
      const X = names[i], Y = names[j];
      if (eqv(vXY(X,Y), R)) sols.push(X + Y);
    }
  }
  if (!sols.length) return null;

  return { id: 'hole_' + Math.random().toString(36).slice(2,8),
           lhs: lhsTex(picks), sols, terms };
}

// ‚Äî construire 6 lignes : au moins 2 lignes √† 3 termes, z√©ro Chasles directe
const rows = [];
let need3 = 2; // minimum de ‚Äúsommes √† 3 termes‚Äù
while (rows.length < 6){
  const want3 = (need3 > 0);
  const r = makeRow(want3);
  if (!r) continue;
  rows.push({ id:'hole_'+rows.length, lhs:r.lhs, sols:r.sols });
  if (r.terms === 3 && need3 > 0) need3--;
}
// (si par hasard need3>0 ‚Äî tr√®s improbable ‚Äî on peut reboucler, mais la logique ci-dessus suffit)

// ‚Äî rendu de l‚Äô√©nonc√© (sans .join)
let html = '<p>\\(ABCD\\) est un ' + kind + ' de centre \\(O\\).</p>' +
           '<p>\\(I,J,K\\) et \\(L\\) sont les milieux respectifs des c√¥t√©s \\([AB],[BC],[CD]\\) et \\([DA]\\).</p>' +
		   '<p>Compl√©ter les √©galit√©s suivantes :</p>' +
           '<ol style="margin:.4rem 0 0 1.2rem">';
for (let i = 0; i < rows.length; i++){
  const r = rows[i];
  html += '<li style="margin:.28rem 0">\\(' + r.lhs + '=\\) ' +
          mkVecNameInput(r.id,'') +
          ' <span class="tick" id="tk_' + r.id + '"></span></li>';
}
html += '</ol>';
ui.equ.innerHTML = html; retypeset(HOST);

// normalisation A‚ÄìZ + reset des ticks
for (let i = 0; i < rows.length; i++){
  const r = rows[i];
  const el = document.getElementById(r.id);
  if (!el) continue;
  el.addEventListener('input', e=>{
    e.target.value = normVNameAZ(e.target.value);
    setTick('tk_' + r.id, '');
  });
}

this.state = { ui, rows, PTS, names };
setFB(null,''); setStepsHTML('');

  },

  verify(){
    const st=this.state; if(!st) return false;
    const okSet=new Set(st.names);
    const vec=(X,Y)=>({x:st.PTS[Y].a-st.PTS[X].a, y:st.PTS[Y].b-st.PTS[X].b});
    const same=(u,w)=>Math.abs(u.x-w.x)<1e-9 && Math.abs(u.y-w.y)<1e-9;

    let ok=0, done=0;
    for(const r of st.rows){
      const val = normVNameAZ(document.getElementById(r.id)?.value||'');
      const tk  = document.getElementById('tk_'+r.id);
      if(!val){ if(tk){tk.textContent=''; tk.className='tick';} continue; }
      const X=val[0], Y=val[1];
      let good=false;
      if(val.length===2 && okSet.has(X) && okSet.has(Y) && X!==Y){
        const target = r.sols[0];               // n‚Äôimporte laquelle des solutions
        good = same(vec(X,Y), vec(target[0],target[1]));
      }
      if(tk){ tk.textContent=good?'‚úì':'‚úó'; tk.className='tick '+(good?'ok':'ko'); }
      done++; if(good) ok++;
    }
    if(done===0){ setFB(false,'Compl√®te au moins une √©galit√©.'); return false; }
    const all = (ok===st.rows.length);
    setFB(all, `${ok} / ${st.rows.length}`);
    return all;
  },

solution(){
  const st   = this.state || {};
  const rows = st.rows   || [];

  let html = '<div class="sec"><div class="title">R√©ponses possibles</div>';
  html += '<ol style="margin:.4rem 0 0 1.2rem">';

  for (let i = 0; i < rows.length; i++){
    const r = rows[i];

    // construit la ligne SANS .join : "LHS = \vec{XY1}, \vec{XY2}, ‚Ä¶"
    let rhs = '';
    for (let k = 0; k < r.sols.length; k++){
      if (k > 0) rhs += '=\\; ';
      rhs += '\\overrightarrow{' + r.sols[k] + '}';
    }

    html += '<li style="margin:.25rem 0">\\(' + r.lhs + ' = ' + rhs + '\\)</li>';
  }

  html += '</ol></div>';
  setStepsHTML(html);
  retypeset(HOST);
}

},



};

/* === Adapter pour le kit PDF (identique √† avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;


// PDF-only ‚Äî resserre *pmatrix* en array compact
// PDF-only ‚Äî compacte les vecteurs-colonne sans toucher l'√©cran
function tightenVectorsForPDF(html){
  if(!html) return html;

  // (a)  \begin{pmatrix} ... \end{pmatrix}  ->  ( array{c} ) + espaces n√©gatifs
  html = html.replace(
    /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (b)  \left( \begin{array}{c} ... \end{array} \right)  -> ajoute \! et r√©duit arraycolsep
  html = html.replace(
    /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (c)  versions sans \left...\right (rare) : ( array{c} ) ‚Üí ajoute \!
  html = html.replace(
    /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (d)  \pmatrix{‚Ä¶} macro √©ventuelle
  html = html.replace(
    /\\pmatrix\{([\s\S]*?)\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  return html;
}





/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
window.buildOneForPDFSync = function(defId){
  window.__PDF_BUILDING = true;           // ‚¨ÖÔ∏è d√©marre la zone neutre

  try {
    const cfg = REGISTRY_MAP[defId];
    if (!cfg) return { statement:'', solution:'' };

    const host   = document.querySelector('#host');
    const backup = host ? host.innerHTML : '';

    if (host) mountHost();
    document.querySelector('#lead').innerHTML = cfg.lead || '';

    // ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
    cfg.gen.call(cfg);


  // --- Restaure pour l‚Äô√©cran ---


  // ---- 1) R√©cup√©rer le rep√®re s‚Äôil existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // s√©curit√© namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) √ânonc√© texte (√©cran)
  const equHTML = (document.querySelector('#equ')||{}).innerHTML || '';

  // √ânonc√© final : grille 2 colonnes si on a un rep√®re, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction (√©cran)
const _oldRetypeset2 = window.retypeset;
  const _oldMJ2        = window.MJ;
  window.retypeset = function(){};
  window.MJ        = function(){};
  cfg.solution.call(cfg);
  
  // ---- Apr√®s cfg.solution.call(cfg); (et avant le restore) ----

// 2.1) R√©cup√©rer le SVG *corrig√©*
let corrigeRepereHTML = '';
{
  const svgSol = document.querySelector('.row svg.svgbox') || document.querySelector('svg.svgbox');
  if (svgSol){
    const clone = svgSol.cloneNode(true);
    clone.removeAttribute('style');
    clone.setAttribute('width','300');      // taille PDF
    clone.setAttribute('height','300');
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    corrigeRepereHTML = clone.outerHTML;
  }
}

// 2.2) R√©cup√©rer le HTML texte de la correction
const corrigeTexteHTML = (document.querySelector('#res')||{}).innerHTML || '';

// 2.3) Composer la *correction* pour le PDF : rep√®re + texte
const solution =
  corrigeRepereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${corrigeRepereHTML}</div>
         <div>${corrigeTexteHTML}</div>
       </div>`
    : corrigeTexteHTML;

  
  
  window.retypeset = _oldRetypeset2;
  window.MJ        = _oldMJ2;

  if (host) host.innerHTML = backup;

  // ---- 4) PDF-only : resserrer les pmatrix via TeX (espace interne)
  function tightenVectorsForPDF(html){
    if(!html) return html;
    // pmatrix -> array{c} + espaces n√©gatifs
    html = html.replace(
      /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \left( \begin{array}{c} ... \end{array} \right) -> ajoute \!
    html = html.replace(
      /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // versions sans \left...\right
    html = html.replace(
      /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \pmatrix{‚Ä¶}
    html = html.replace(
      /\\pmatrix\{([\s\S]*?)\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    return html;
  }

  const statementTight = statement;
  const solutionTight  = solution;
  
 function stripCHTML(html){
  if(!html) return html;
  return html
     .replace(/<mjx-container[\s\S]*?<\/mjx-container>/g, (m)=>{
       // On essaie de r√©cup√©rer le TeX source si MathJax l‚Äôa laiss√© en data-tex,
       // sinon on supprime (on n‚Äôen veut pas dans le PDF SVG).
       const tex = m.match(/data-tex="([^"]+)"/);
       return tex ? `\\(${tex[1]}\\)` : '';
     });
 }
 const statementClean = stripCHTML(statementTight);
 const solutionClean  = stripCHTML(solutionTight);

  // ‚ö†Ô∏è On wrappe ici avec .vec-tight pour activer le CSS ‚Äúresserr√©‚Äù c√¥t√© iframe PDF (SVG)
    return {
      statement: `<div class="vec-tight">${statementTight||''}</div>`,
      solution:  `<div class="vec-tight">${solutionTight||''}</div>`
    };
  } finally {
    window.__PDF_BUILDING = false;        // ‚¨ÖÔ∏è on r√©active l‚Äô√©cran quoi qu‚Äôil arrive
  }
};




/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){

  mountHost(); // injecte le layout par d√©faut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // √©l√©ments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', HOST);
  const fbEl  = $('#fb', HOST);
  const resEl = $('#res', HOST);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

  // g√©n√®re l'exo (peut remplacer enti√®rement le host, ex. e3/ex4)
  cfg.gen.call(cfg);




  // (re)typeset
  retypeset();

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
document.querySelector('#btn-reset').addEventListener('click', ()=>{
  const a=$('#ans',HOST); if(a) a.value='';
  document.querySelectorAll('.colvec input').forEach(i=> i.value=''); // ‚¨ÖÔ∏è AJOUT
  const f=$('#fb',HOST); if(f) f.textContent='';
  const r=$('#res',HOST); if(r) r.innerHTML='';
});
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
    document.querySelector('#btn-solution').addEventListener('click', ()=>{ REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]); });


function adjustLive(kind){
  const id = ACTIVE;
  if (id === 'e3'   && REGISTRY_MAP.e3.adjustLive)   REGISTRY_MAP.e3.adjustLive(kind);
  else if (id === 'ex4' && REGISTRY_MAP.ex4.adjustLive) REGISTRY_MAP.ex4.adjustLive(kind);
  else if (id === 'e5'  && REGISTRY_MAP.e5.adjustLive)  REGISTRY_MAP.e5.adjustLive(kind);
  else { applyAMPInputs(); }
}


['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;     buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) ‚Äî inchang√©, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);
// --- PDF-only: resserre les parenth√®ses des vecteurs-colonne ---
function tightenVectorsForPDF(html){
  if(!html) return html;
  // 1) diminue l'espace colonne dans les array (√©quivalent \arraycolsep)
  html = html.replace(/\\begin\{array\}\{c\}/g, '{\\arraycolsep=1.5pt\\begin{array}{c}');
  // 2) colle les grandes parenth√®ses √† la matrice (\left( ... \right))
  //    (sans toucher le reste du doc)
  html = html
    .replace(/\\left\(\s*\\begin\{array\}\{c\}/g, '\\left(\\mkern-6mu\\begin{array}{c}')
    .replace(/\\end\{array\}\s*\\right\)/g, '\\end{array}\\mkern-6mu\\right)');
  return html;
}

const statementTight = tightenVectorsForPDF(statement);
const solutionTight  = tightenVectorsForPDF(solution);

          const htmlIn =
  `<div class="exo-block">
     <span class="exo-title">Exercice</span>
     <div class="exo-statement">${statementTight||''}</div>
   </div>` +
  (withSolutions
    ? `<div style="margin-top:1rem;">
         <div class="exo-block"><div class="steps" id="pdf-steps">
           <span class="exo-title">Correction</span>
           <!-- ‚¨áÔ∏è Ajout d‚Äôun conteneur .steps pour retrouver la zone grise -->
           <div class="exo-solution">${solutionTight||''}</div></div>
         </div>
       </div>`
    : '');


          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;
const css = idoc.createElement('style');
css.textContent = `
  :root{
    --ink:#111; --bg:#fafafa; --card:#fff; --line:#e5e7eb; --muted:#666;
    --steps-bg:#f3f4f6; --steps-border:#e5e7eb; --steps-left:#9aa0a6;
  }
  body{font:16px/1.55 system-ui,Segoe UI,Roboto,Arial;color:var(--ink);}
  .exo-title{display:block;font-weight:700;margin:0 0 6px}
  /* ‚öôÔ∏è Zone grise identique √† l‚Äô√©cran (#res.steps) */
  .steps{
    background:var(--steps-bg);
    border:1px solid var(--steps-border);
    border-left:4px solid var(--steps-left);
    border-radius:8px;
    padding:10px;
    margin:.45rem 0 0 .15rem;
  }
  .steps p{margin:.25rem 0}
  /* Table ‚Äúe5‚Äù compacte */
  .tbl3{border-collapse:collapse}
  .tbl3 td{padding:2px 6px;vertical-align:top}
  
  /* === Tighten parentheses around column vectors (SVG output) === */
/* CHTML (au cas o√π), agit sur les delimiters extensibles */
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:first-child { margin-right: -0.18em; }
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:last-child  { margin-left:  -0.18em; }
.vec-tight mjx-mtable mjx-mtd { padding-left: .15em; padding-right: .15em; }
.vec-tight mjx-mtable > mjx-table { margin-left: 0; margin-right: 0; }

/* SVG : d√©caler l√©g√®rement OPEN/CLOSE pour coller les parenth√®ses au tableau */
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="OPEN"]  { transform: translateX(-0.18em); }
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="CLOSE"] { transform: translateX( 0.18em); }

/* Ajustement global tr√®s l√©ger si besoin (peut √™tre mis √† 0 si tu pr√©f√®res) */
.vec-tight svg[aria-hidden="true"] { margin-left:-0.10em; margin-right:-0.10em; }
/* --- Anti "barres noires" MathJax (PDF) --- */
.exo-statement,
.exo-solution { color:#111 !important; background:transparent !important; }

/* Cas CHTML (au cas o√π) */
mjx-container { color:#111 !important; background:transparent !important; }
mjx-container svg { overflow:visible !important; }
mjx-container svg rect,
mjx-container svg path[data-mml-node="mspace"] { fill:none !important; }

/* Cas SVG standalone (ce que tu utilises dans l‚Äôiframe) */
.exo-statement svg rect,
.exo-statement svg path[data-mml-node="mspace"],
.exo-solution  svg rect,
.exo-solution  svg path[data-mml-node="mspace"] { fill:none !important; }

`;
idoc.head.appendChild(css);

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
