<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde — Vecteurs : Translations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{
  --ink:#111;
  --bg:#fafafa;
  --card:#fff;
  --line:#e6e6e6;
  --ok:#11823b;
  --ko:#b00020
}
html,body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font:16px/1.55 system-ui,Segoe UI,Roboto,Arial
}
.header{
  position:sticky;
  top:0;
  background:#fff;
  border-bottom:1px solid #eee;
  padding:14px 18px;
  z-index:5
}
.wrap{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px
}
.card{
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04)
}

.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center
}
select,
input[type="text"]{
  padding:8px 10px;
  border:1px solid #ddd;
  border-radius:8px;
  font-size:15px
}
.btn{
  padding:8px 12px;
  border:1px solid #ddd;
  background:#fff;
  border-radius:8px;
  cursor:pointer
}
.btn:hover{background:#f6f6f6}
.score{margin-left:auto}

.table{
  width:100%;
  border-collapse:collapse;
  margin:.35rem 0
}
.table th,.table td{
  border:1px solid #e5e5e5;
  padding:6px 8px;
  vertical-align:top
}
.table th{
  background:#f3f3f6;
  text-align:left
}

/* bloc correction / explications */
.steps{
  margin:.45rem 0 0 .15rem;
  padding:.45rem .6rem;
  background:#f7f8fb;
  border:1px dashed #c7d2fe;
  border-radius:10px
}
.stepTitle{
  font-weight:600;
  margin-top:.4rem;
  margin-bottom:.2rem;
  text-decoration:underline;
}
.line{white-space:nowrap}
@media (max-width:600px){
  .line{white-space:normal}
}
.tick{
  display:inline-block;
  min-width:1.2em;
  margin-left:8px;
  font-weight:700
}
.tick.ok{color:var(--ok)}
.tick.ko{color:var(--ko)}

.answers{
  display:flex;
  flex-direction:column;
  flex-wrap:wrap;
  gap:.4rem .5rem;
  margin-top:.6rem;
}
.answers .qa-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.4rem;
}
.answers .qa-row label{
  flex:1 1 auto;
  min-width:260px;
}
.answers .qa-row input{
  flex:0 0 auto;
  min-width:60px;
  max-width:80px;
  text-transform:uppercase;
  text-align:center;
  font-weight:600;
}
@media print{ .controls{display:none !important;} }

.steps .line{ margin:.32rem 0; line-height:1.9 }
.steps mjx-container{ padding-bottom:.08em }
@media print{
  .steps .line{ margin:.36rem 0; line-height:2 }
}

/* bloc exo visible */
.exo-block{
  border:2px solid #ddd;
  border-radius:10px;
  padding:12px 14px;
}
.exo-title{
  font-weight:700;
  text-decoration:underline;
  margin-bottom:.5rem;
  display:block;
}
.enonce .subhead{
  font-weight:600;
  margin-top:.5rem;
}


.exo-layout-table{
  width:100%;
  border-collapse:collapse;
}

.exo-layout-table td{
  vertical-align:top;
  border:none;
  padding:8px 12px;
}

.exo-fig-col{
  width:240px;
  min-width:240px;
}

@media(max-width:700px){
  .exo-layout-table,
  .exo-layout-table tbody,
  .exo-layout-table tr,
  .exo-layout-table td{
    display:block;
    width:100%;
  }
  .exo-fig-col{
    width:auto;
    min-width:auto;
    margin-bottom:1rem;
  }
}


</style>

<!-- ⭐ MATHJAX CONFIG CHTML -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>
  .MJX_Assistive_MathML, mjx-assistive-mml { display:none !important; }
</style>

</head>
<body>
<div class="header">
  <h1 style="margin:0;font-size:1.1rem">
    <strong>Seconde – Vecteurs : Translation</strong>
  </h1>
</div>

<div class="wrap">
  <!-- barre de contrôle -->
  <div class="controls card">
    <label for="exo-select"><strong>Type d’exercice :</strong></label>
    <select id="exo-select"></select>

    <button id="btn-new" class="btn">🔄 Nouvel énoncé</button>
    <button id="btn-check" class="btn">✅ Vérifier</button>
    <button id="btn-solution" class="btn">💡 Solution</button>
    <button id="btn-reset" class="btn">🧹 Réinitialiser</button>

    <span class="score">Score : <span id="score">0 / 0</span></span>
  </div>

  <!-- zone exo -->
  <div class="card" id="host"></div>

  <!-- bloc aide saisie -->
  <div class="card small">
    <strong>Saisie &amp; réponses acceptées :</strong>
    <ul style="margin:.5rem 0 0 18px">
      <li>Répondre par la lettre du point image (exemple : <code>A</code>, <code>B</code>, <code>G</code>...).</li>
      <li>La casse n’a pas d’importance (<code>a</code> = <code>A</code>).</li>
      <li>On ne demande jamais les coordonnées, juste le nom du point obtenu par la translation.</li>
    </ul>
  </div>

  <!-- clavier math -->
  <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
</div>

<!-- Dépendances projet -->
<script src='../../../../js/dev-rules-clean.dedup.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>

<script>
'use strict';

/* ===== Utils DOM / score ===== */
const $  = (s,r)=> (r||document).querySelector(s);
const $$ = (s,r)=> Array.from((r||document).querySelectorAll(s));
let scoreOK=0, scoreTot=0;
function updateScore(){ const el=$("#score"); if(el) el.textContent = scoreOK+" / "+scoreTot; }

/* ===== random helpers ===== */
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* =========================================================
   GÉOMÉTRIE / FIGURES DE RÉFÉRENCE POUR L'EXERCICE 1
   -------------------------------------------------
   On stocke 20 "figures". Chaque figure :
   - name: identifiant technique
   - pts: {A:{x:..,y:..},B:{...},...}
   Les positions servent uniquement à vérifier les translations:
      la translation qui envoie P->Q est le vecteur Q-P.
   On peut donc en déduire l'image de n'importe quel autre point R :
      R + (Q-P).

   Les lettres utilisées sont cohérentes avec ce qu'on affiche.
   On reste en grande majorité sur des lettres A,B,C,D,E,F,G,H,...
   (IMPORTANT: Toutes distinctes)
   ========================================================= */

function vecAdd(p,v){
  return {x:p.x+v.x, y:p.y+v.y};
}
function vecDiff(p,q){
  return {x:q.x-p.x, y:q.y-p.y}; // vecteur p->q
}
function samePoint(p,q){
  const EPS = 1e-6;
  return (Math.abs(p.x - q.x) < EPS &&
          Math.abs(p.y - q.y) < EPS);
}

function checkPlacement(st){
  // sécu
  if (!st || !st.targetPts) return {count:0, good:0};

  const need = ["K","L","M"];

  let locTot = 0;
  let locOK  = 0;

  need.forEach(lbl=>{
    const tickEl = $('#tick-'+lbl);
    if(!tickEl) return;

    // pas placé → neutre (rien affiché)
    if(!st.placedByStudent || !st.placedByStudent[lbl]){
      tickEl.className = 'tick';
      tickEl.textContent = '';
      return;
    }

    const got = st.placedByStudent[lbl]; // {x,y} posé élève
    const tar = st.targetPts[lbl];       // {x,y} attendu

    if(!tar){
      // pas de cible = neutre
      tickEl.className = 'tick';
      tickEl.textContent = '';
      return;
    }

    // l'élève a cliqué quelque part -> on compte cette tentative
    locTot++;

    const ok = (Math.abs(got.x - tar.x) < 1e-9 &&
                Math.abs(got.y - tar.y) < 1e-9);

    if(ok) locOK++;

    tickEl.className = 'tick ' + (ok ? 'ok' : 'ko');
    tickEl.textContent = ok ? '✓' : '✗';
  });

  return {count:locTot, good:locOK};
}



function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function buildTripletsForFigure(pts){
  const letters = Object.keys(pts);

  const cands1 = []; // type 1
  const cands2 = []; // type 2

  // Type 1 : "La translation qui transforme P en Q, transforme R en ... "
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if (j===i) continue;
      for (let k=0; k<letters.length; k++){
        if (k===i || k===j) continue;
        const P = letters[i];
        const Q = letters[j];
        const R = letters[k];

        const ans = translatePoint(pts, P, Q, R);
        if(!ans) continue;
        // question text
        const text = `La translation qui transforme \\( \\) \\(${P}\\) \\( \\)en\\( \\) \\(${Q}\\), transforme \\( \\)\\(${R}\\) \\( \\)en ...`;

        cands1.push({
          text,
          ans
        });
      }
    }
  }

  // Type 2 : "La translation de vecteur \vec{XY} transforme R en ..."
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if (j===i) continue;
      for (let k=0; k<letters.length; k++){
        if (k===i || k===j) continue;
        const X = letters[i];
        const Y = letters[j];
        const R = letters[k];

        const ans = translatePoint(pts, X, Y, R);
        if(!ans) continue;
        const text = `La translation de vecteur \\( \\) \\(\\overrightarrow{${X}${Y}}\\) \\( \\) transforme \\( \\)  \\(${R}\\) \\( \\) en ...`;

        cands2.push({
          text,
          ans
        });
      }
    }
  }

  return { cands1, cands2 };
}


// figure builder util: régulier n-gone centré, + points spéciaux
function regularPolygonPoints(n, radius, cx, cy, labels){
  const pts={};
  for(let i=0;i<n;i++){
    const ang = 2*Math.PI*i/n - Math.PI/2;
    const x = cx + Math.round(radius*Math.cos(ang));
    const y = cy + Math.round(radius*Math.sin(ang));
    pts[labels[i]]={x,y};
  }
  return pts;
}

// BANK_FIGURES : ~20 variantes
const BANK_FIGURES = [];

// 1. hexagone + diagonales façon "étoile" (style de ton losange/étoile)
BANK_FIGURES.push({
  name:"etoile_hex",
  pts:{
    A:{x:-2,y:0},
    B:{x:0,y:2},
    C:{x:2,y:0},
    D:{x:1,y:-2},
    E:{x:-1,y:-2},
    F:{x:0,y:0},   // centre
    G:{x:2,y:2},
    H:{x:-2,y:2}
  }
});

// 2. rectangle 3x2 maillé en croix
BANK_FIGURES.push({
  name:"rect_croix",
  pts:{
    A:{x:0,y:0},
    B:{x:3,y:0},
    C:{x:3,y:2},
    D:{x:0,y:2},
    E:{x:1.5,y:1},
    F:{x:1.5,y:2},
    G:{x:1.5,y:0},
    H:{x:0,y:1},
    I:{x:3,y:1}
  }
});

// 3. losange vertical
BANK_FIGURES.push({
  name:"losange",
  pts:{
    A:{x:0,y:2},
    B:{x:2,y:0},
    C:{x:0,y:-2},
    D:{x:-2,y:0},
    E:{x:0,y:0},
    F:{x:2,y:2},
    G:{x:-2,y:-2}
  }
});

// 4. maison pentagone (toit triangle + base rectangle)
BANK_FIGURES.push({
  name:"maison",
  pts:{
    A:{x:-2,y:0},
    B:{x:2,y:0},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:1.5}, // faîte du toit
    F:{x:0,y:-2},
    G:{x:-2,y:1.5},
    H:{x:2,y:1.5}
  }
});

// 5. octogone régulier
BANK_FIGURES.push({
  name:"octogone",
  pts: regularPolygonPoints(
    8, // n
    3, // rayon
    0,0,
    ['A','B','C','D','E','F','G','H']
  )
});

// 6. carré + centre + milieux
BANK_FIGURES.push({
  name:"carre_plus",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:0},
    F:{x:0,y:2},
    G:{x:2,y:0},
    H:{x:0,y:-2},
    I:{x:-2,y:0}
  }
});

// 7. trapèze isocèle + diagonales
BANK_FIGURES.push({
  name:"trapeze",
  pts:{
    A:{x:-3,y:2},
    B:{x:3,y:2},
    C:{x:2,y:-1},
    D:{x:-2,y:-1},
    E:{x:0,y:2},
    F:{x:0,y:-1},
    G:{x:2,y:2},
    H:{x:-2,y:2}
  }
});

// 8. triangle + son homothétie interne
BANK_FIGURES.push({
  name:"double_triangle",
  pts:{
    A:{x:-3,y:-1},
    B:{x:3,y:-1},
    C:{x:0,y:3},
    D:{x:-1,y:0.33},
    E:{x:1,y:0.33},
    F:{x:0,y:1.66}
  }
});

// 9. rectangle long + points milieu chaque côté
BANK_FIGURES.push({
  name:"rect_long",
  pts:{
    A:{x:-4,y:1},
    B:{x:4,y:1},
    C:{x:4,y:-1},
    D:{x:-4,y:-1},
    E:{x:0,y:1},
    F:{x:4,y:0},
    G:{x:0,y:-1},
    H:{x:-4,y:0}
  }
});

// 10. pentagone régulier
BANK_FIGURES.push({
  name:"penta",
  pts: regularPolygonPoints(
    5,
    3,
    0,0,
    ['A','B','C','D','E']
  )
});

// 11. hexagone régulier
BANK_FIGURES.push({
  name:"hexa",
  pts: regularPolygonPoints(
    6,
    3,
    0,0,
    ['A','B','C','D','E','F']
  )
});

// 12. "étoile" type losange+points ext
BANK_FIGURES.push({
  name:"etoile2",
  pts:{
    A:{x:0,y:3},
    B:{x:2,y:1},
    C:{x:3,y:0},
    D:{x:2,y:-1},
    E:{x:0,y:-3},
    F:{x:-2,y:-1},
    G:{x:-3,y:0},
    H:{x:-2,y:1},
    I:{x:0,y:0}
  }
});

// 13. Z quadrillé (genre réseau en escalier)
BANK_FIGURES.push({
  name:"zigzag",
  pts:{
    A:{x:-3,y:2},
    B:{x:-1,y:2},
    C:{x:1,y:0},
    D:{x:3,y:0},
    E:{x:1,y:-2},
    F:{x:-1,y:-2}
  }
});

// 14. double carré imbriqué
BANK_FIGURES.push({
  name:"double_square",
  pts:{
    A:{x:-3,y:3},
    B:{x:3,y:3},
    C:{x:3,y:-3},
    D:{x:-3,y:-3},
    E:{x:-1,y:1},
    F:{x:1,y:1},
    G:{x:1,y:-1},
    H:{x:-1,y:-1}
  }
});

// 15. rectangle + diagonales internes en X + point centre
BANK_FIGURES.push({
  name:"rect_X",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:0}
  }
});

// 16. parallélogramme simple
BANK_FIGURES.push({
  name:"para1",
  pts:{
    A:{x:-2,y:1},
    B:{x:2,y:1},
    C:{x:3,y:-2},
    D:{x:-1,y:-2},
    E:{x:0,y:-0.5}
  }
});

// 17. autre parallélogramme (plus aplati)
BANK_FIGURES.push({
  name:"para2",
  pts:{
    A:{x:-3,y:2},
    B:{x:2,y:2},
    C:{x:4,y:0},
    D:{x:-1,y:0},
    E:{x:0,y:1}
  }
});

// 18. escalier 3 niveaux
BANK_FIGURES.push({
  name:"esc2",
  pts:{
    A:{x:-2,y:2},
    B:{x:0,y:2},
    C:{x:0,y:1},
    D:{x:2,y:1},
    E:{x:2,y:-1},
    F:{x:-2,y:-1}
  }
});

// 19. trapèze + point milieu grandes bases
BANK_FIGURES.push({
  name:"trap2",
  pts:{
    A:{x:-4,y:2},
    B:{x:4,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:2},
    F:{x:0,y:-2}
  }
});

// 20. couronne carrée tournante (carré + carré tourné)
BANK_FIGURES.push({
  name:"carre_rot",
  pts:{
    A:{x:-2,y:2},
    B:{x:2,y:2},
    C:{x:2,y:-2},
    D:{x:-2,y:-2},
    E:{x:0,y:3},
    F:{x:3,y:0},
    G:{x:0,y:-3},
    H:{x:-3,y:0}
  }
});


/* =========================================================
   GÉNÉRATION ÉNONCÉ EXERCICE 1
   -------------------------------------------------
   On va :
   1. choisir une figure aléatoire
   2. fabriquer un bloc d'énoncé en deux parties :
      (1) "La translation qui transforme ... en ... transforme ... en ..."
      (2) "La translation de vecteur \vec{XY} transforme ... en ..."
   3. générer aussi les réponses attendues
   ========================================================= */

function pickDistinctLetters(list, k){
  // renvoie k lettres distinctes prisent dans list
  const L=[...list];
  const out=[];
  while(out.length<k && L.length){
    const i = rnd(0,L.length-1);
    out.push(L.splice(i,1)[0]);
  }
  return out;
}

// Calcule image de R par la translation qui envoie P->Q
function translatePoint(pts, Pname, Qname, Rname){
  const P = pts[Pname];
  const Q = pts[Qname];
  const R = pts[Rname];
  if(!P||!Q||!R) return null;
  const v = vecDiff(P,Q); // vecteur P->Q = Q - P
  const Rimg = vecAdd(R,v); // R + v
  // retrouver la lettre S telle que pts[S] == Rimg
  for(const k in pts){
    if(samePoint(pts[k], Rimg)) return k;
  }
  return null; // pas trouvé = devrait pas arriver si figure cohérente
}

// fabrique un petit paquet de questions style 1.a ... 1.e
function makeBlockType1(pts){
  const letters = Object.keys(pts);
  const nbq = Math.min(5, letters.length-2);
  const qs=[];
  let tries = 0;

  for (let i=0; i<nbq && tries<100; i++){
    tries++;

    const trip = pickDistinctLetters(letters,3);
    if(trip.length<3) break;
    const [P,Q,R] = trip;

    const ans = translatePoint(pts,P,Q,R);
    if(!ans){
      // pas de i--
      continue;
    }
    qs.push({
      text:`La translation qui transforme \\(${P}\\) en \\(${Q}\\), transforme \\(${R}\\) en ...`,
      ans: ans
    });
  }
  return qs;
}



// fabrique un paquet de questions style 2.a ... 2.d
function makeBlockType2(pts){
  const letters = Object.keys(pts);
  const nbq = Math.min(4, letters.length-2);
  const qs=[];
  let tries = 0;

  for (let i=0; i<nbq && tries<100; i++){
    tries++;

    const pair = pickDistinctLetters(letters,2);
    if(pair.length<2) break;
    const [X,Y]=pair;

    let R = choice(letters.filter(L=>L!==X && L!==Y));
    const ans = translatePoint(pts,X,Y,R);
    if(!ans){
      continue;
    }
    qs.push({
      text:`La translation de vecteur \\(\\overrightarrow{${X}${Y}}\\) transforme \\(${R}\\) en ...`,
      ans: ans
    });
  }
  return qs;
}


// transforme les coords "math" pts{name:{x,y}} en un petit SVG centré
function buildFigureSVG(pts){
  // 1. récupère limites
  const names = Object.keys(pts);
  const xs = names.map(n=>pts[n].x);
  const ys = names.map(n=>pts[n].y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  const w = maxX - minX || 1;
  const h = maxY - minY || 1;

  // marge en px dans le viewport final
  const pad = 20;
  const viewW = 200;
  const viewH = 200;

  // facteur d'échelle : on veut que tout tienne dans 200x200 avec marge
  const scale =  ( (viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  // fonction pour convertir coord => pixel
  function toPix(p){
    const X = pad + (p.x - minX)*scale;
    // attention Y : le SVG a l'axe y vers le bas
    const Y = pad + (maxY - p.y)*scale;
    return {X,Y};
  }

  // on va dessiner :
  // - segments reliant les points dans l'ordre alphabétique (rapide)
  // - un point + label pour chaque lettre
  // NOTE: si tu veux des segments plus "intelligents"
  // (par exemple suivre une forme prédéfinie par figure),
  // on pourra ajouter dans BANK_FIGURES un champ edges:[["A","B"],["B","C"],...]
  // Pour l'instant, je vais relier A->B->C->...->A si >=3 points.
  let edges = [];
  if(names.length >= 3){
    const sorted = [...names].sort();
    for(let i=0;i<sorted.length-1;i++){
      edges.push([sorted[i], sorted[i+1]]);
    }
    edges.push([sorted[sorted.length-1], sorted[0]]);
  }

  // build <line> for edges
  let linesSVG = edges.map(([p1,p2])=>{
    const P1 = toPix(pts[p1]);
    const P2 = toPix(pts[p2]);
    return `<line x1="${P1.X.toFixed(1)}" y1="${P1.Y.toFixed(1)}"
                  x2="${P2.X.toFixed(1)}" y2="${P2.Y.toFixed(1)}"
                  stroke="#555" stroke-width="1.2" />`;
  }).join("");

  // build <circle> + <text> for points
  let ptsSVG = names.map(n=>{
    const P = toPix(pts[n]);
    return `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(P.X+5).toFixed(1)}" y="${(P.Y-5).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  }).join("");

  const svg = `
    <svg viewBox="0 0 ${viewW} ${viewH}"
         width="220" height="220"
         style="border:1px solid #ccc;border-radius:6px;background:#fff;margin:8px 0 16px 0;">
      ${linesSVG}
      ${ptsSVG}
    </svg>
  `;
  return svg;
}


function computeLayout(pts, extraPts){
  const baseNames = Object.keys(pts);
  const xs = baseNames.map(n=>pts[n].x);
  const ys = baseNames.map(n=>pts[n].y);

  if (extraPts){
    for (const k in extraPts){
      xs.push(extraPts[k].x);
      ys.push(extraPts[k].y);
    }
  }

  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  // marge généreuse autour (2 unités déjà c’était limite, on garde 2 ? tu dis que le quadrillage
  // n'était pas assez grand -> on va la monter à 3 pour être safe partout)
  minX = Math.floor(minX) - 3;
  maxX = Math.ceil(maxX) + 3;
  minY = Math.floor(minY) - 3;
  maxY = Math.ceil(maxY) + 3;

  const w = maxX - minX || 1;
  const h = maxY - minY || 1;

  const pad = 20;
  const viewW = 450; // plus large
  const viewH = 450;

  const scale = ((viewW-2*pad)/w < (viewH-2*pad)/h
                ? (viewW-2*pad)/w
                : (viewH-2*pad)/h );

  function toPixXY(x,y){
    const X = pad + (x - minX)*scale;
    const Y = pad + (maxY - y)*scale; // repère math
    return {X,Y};
  }
  function toPix(p){ return toPixXY(p.x,p.y); }

  return {
    minX,maxX,minY,maxY,
    pad,viewW,viewH,scale,
    toPix,toPixXY
  };
}



function renderFigureSVG(layout, pts, extraPtsToShow, opts){
  const {
    minX,maxX,minY,maxY,
    pad,viewW,viewH,scale,
    toPix
  } = layout;
  const baseNames = Object.keys(pts);

  // 1. limites réelles de la figure (sans marge artificielle)
  const baseXs = baseNames.map(n=>pts[n].x);
  const baseYs = baseNames.map(n=>pts[n].y);
  const figMinX = Math.min(...baseXs);
  const figMaxX = Math.max(...baseXs);
  const figMinY = Math.min(...baseYs);
  const figMaxY = Math.max(...baseYs);

  // 2. pour savoir si on est "vraiment" sur un bord :
  //    tolérance très petite (strict égalité suffit si coords entières)
  function chooseLabelDir(p){
    const onLeft   = p.x === figMinX;
    const onRight  = p.x === figMaxX;
    const onBottom = p.y === figMinY;
    const onTop    = p.y === figMaxY;

    // priorité horizontale: si c'est extrême gauche ou droite → on met gauche/droite
    if (onLeft && !onRight)   return "left";
    if (onRight && !onLeft)   return "right";

    // sinon, priorité verticale: haut ou bas
    if (onTop && !onBottom)   return "top";
    if (onBottom && !onTop)   return "bottom";

    // sinon point intérieur
    return "inside";
  }

  function dirToOffset(dir){
    switch(dir){
      case "left":   return {dx:-14, dy:4};
      case "right":  return {dx:14,  dy:4};
      case "top":    return {dx:0,   dy:-12};
      case "bottom": return {dx:0,   dy:18};
      case "inside": return {dx:0,   dy:18};
    }
  }

  // ===== grille =====
  const gridLines = [];
  for(let X=minX; X<=maxX; X++){
    const p1 = toPix({x:X,y:minY});
    const p2 = toPix({x:X,y:maxY});
    gridLines.push(
      `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
             x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
             stroke="#ddd" stroke-width="0.6" />`
    );
  }
  for(let Y=minY; Y<=maxY; Y++){
    const p1 = toPix({x:minX,y:Y});
    const p2 = toPix({x:maxX,y:Y});
    gridLines.push(
      `<line x1="${p1.X.toFixed(1)}" y1="${p1.Y.toFixed(1)}"
             x2="${p2.X.toFixed(1)}" y2="${p2.Y.toFixed(1)}"
             stroke="#ddd" stroke-width="0.6" />`
    );
  }

  // ===== segments de la figure =====
  // Toujours notre "ordre alphabétique fermé" pour l’instant
  let edges = [];
  if(baseNames.length >= 3){
    const sorted = [...baseNames].sort();
    for(let i=0;i<sorted.length-1;i++){
      edges.push([sorted[i], sorted[i+1]]);
    }
    edges.push([sorted[sorted.length-1], sorted[0]]);
  }
  const polyLines = edges.map(([p1,p2])=>{
    const P1 = toPix(pts[p1]);
    const P2 = toPix(pts[p2]);
    return `<line x1="${P1.X.toFixed(1)}" y1="${P1.Y.toFixed(1)}"
                  x2="${P2.X.toFixed(1)}" y2="${P2.Y.toFixed(1)}"
                  stroke="#444" stroke-width="1.4" />`;
  }).join("");

  // ===== points de base (A,B,C,...) =====
  const basePtsSVG = baseNames.map(n=>{
    const mathP = pts[n];
    const P = toPix(mathP);

    const dir = chooseLabelDir(mathP);
    const {dx,dy} = dirToOffset(dir);

    return `
      <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#111"/>
      <text x="${(P.X+dx).toFixed(1)}" y="${(P.Y+dy).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#111">${n}</text>
    `;
  }).join("");

  // ===== points de correction K,L,M (rouge) =====
  let extraSVG = "";
  if (extraPtsToShow){
    Object.keys(extraPtsToShow).forEach(n=>{
      const mathP = extraPtsToShow[n];
      const P = toPix(mathP);

      // Pour K,L,M en correction on applique la même logique d'extérieur.
      // (ça les met aussi proprement dehors)
      const dir = chooseLabelDir(mathP);
      const {dx,dy} = dirToOffset(dir);

      extraSVG += `
        <circle cx="${P.X.toFixed(1)}" cy="${P.Y.toFixed(1)}" r="3" fill="#b00020"/>
        <text x="${(P.X+dx).toFixed(1)}" y="${(P.Y+dy).toFixed(1)}"
              font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
              fill="#b00020">${n}</text>
      `;
    });
  }

  const clickable = opts && opts.interactive ? 'style="cursor:crosshair;touch-action:none;"' : '';

  const dataAttr =
    `data-minx="${minX}" data-maxy="${maxY}" data-scale="${scale}" data-pad="${pad}"`;

  return `
  <svg id="fig-click"
       ${dataAttr}
       viewBox="0 0 ${viewW} ${viewH}"
       width="${viewW}" height="${viewH}"
       ${clickable}
       style="border:1px solid #ccc;border-radius:6px;background:#fff;margin:8px 0 16px 0;
              width:${viewW}px; height:${viewH}px; max-width:${viewW}px; max-height:${viewH}px;">
    ${gridLines.join("")}
    ${polyLines}
    ${basePtsSVG}
    <g id="student-layer"></g>
    ${extraSVG}
  </svg>
`;

}






function buildPlacementTriples(pts){
  const letters = Object.keys(pts);

  // fabrique toutes les constructions possibles O + (V-U)
  // retourne {fromO: 'C', fromU:'E', fromV:'F', newName:'K', O, U, V, T:{x,y}, textLatex:"CK = EF"}
  const builds = [];
  for (let i=0; i<letters.length; i++){
    for (let j=0; j<letters.length; j++){
      if(j===i) continue;
      for (let k=0; k<letters.length; k++){
        if(k===i || k===j) continue;

        const Oname = letters[i]; // origine (ex: C)
        const Uname = letters[j]; // donne vecteur U->V
        const Vname = letters[k];

        // vecteur U->V
        const v = vecDiff(pts[Uname], pts[Vname]); // careful: vecDiff(p,q) = q - p, i.e. p->q
        // on veut O + (V - U)
        const T = vecAdd(pts[Oname], v);

        // Vérifier si T correspond déjà à un point existant -> on veut NOUVEAU point
        let isNew = true;
        for(const L of letters){
          if (samePoint(pts[L], T)){
            isNew = false;
            break;
          }
        }
        if(!isNew) continue;

        builds.push({
          Oname, Uname, Vname,
          T,
          // pour l'affichage latex ex: \overrightarrow{CK} = \overrightarrow{EF}
          // on remplit le nom final plus tard (K,L,M)
        });
      }
    }
  }
  return builds;
}


function genExTranslations(){
  let attempt = 0;
  while (attempt < 30){
    attempt++;

    // 1. figure aléatoire
    const fig = choice(BANK_FIGURES);
    const pts = fig.pts;

    // 2. on construit TOUS les triplets valides pour les questions 1 et 2
    const { cands1, cands2 } = buildTripletsForFigure(pts);

    // 3. garde-fous : on veut au moins 3 questions de chaque type
    //    ET un peu de richesse globale
    if (cands1.length < 3 || cands2.length < 3 || (cands1.length + cands2.length < 12)){
      continue; // figure trop pauvre → on réessaie
    }

    // 4. on mélange aléatoirement puis on prend 3 questions de chaque type
    const pick1 = shuffle(cands1).slice(0,3); // type "translation qui transforme P en Q"
    const pick2 = shuffle(cands2).slice(0,3); // type "translation de vecteur XY"

    // 5. assemble qAll = [1.a,1.b,1.c,2.a,2.b,2.c]
    const qAll = [];

    pick1.forEach((q, idx)=>{
      qAll.push({
        group:"1",
        label:`${String.fromCharCode(97+idx)})`, // 1.a etc
        text:q.text,
        ans:q.ans,
        inputId:`ans1_${idx}`
      });
    });

    pick2.forEach((q, idx)=>{
      qAll.push({
        group:"2",
        label:`${String.fromCharCode(97+idx)})`, // 2.a etc
        text:q.text,
        ans:q.ans,
        inputId:`ans2_${idx}`
      });
    });

    // 6. Question 3 : placement de K, L, M
    //    on génère des nouveaux points à construire par translation
    const builds = buildPlacementTriples(pts);

    // il nous faut AU MOINS 3 builds, sinon on repart
    if (builds.length < 3){
      continue;
    }

    // ⚠ NOUVEAU : on choisit 3 builds avec des coordonnées DISTINCTES
    // helper pour comparer des coords entières
    function sameCoords(P,Q){
      return Math.abs(P.x - Q.x) < 1e-9 && Math.abs(P.y - Q.y) < 1e-9;
    }

    let pickedBuilds = null;
    // on va essayer plusieurs combinaisons au hasard jusqu'à trouver 3 positions différentes
    for (let trial = 0; trial < 200 && !pickedBuilds; trial++){
      const cand3 = shuffle(builds).slice(0,3);
      if (cand3.length < 3) continue;
      const P1 = cand3[0].T;
      const P2 = cand3[1].T;
      const P3 = cand3[2].T;
      const allDistinct =
        !sameCoords(P1,P2) &&
        !sameCoords(P1,P3) &&
        !sameCoords(P2,P3);
      if (allDistinct){
        pickedBuilds = cand3;
      }
    }

    // si malgré tout on ne trouve pas 3 points distincts → on repart sur une autre figure
    if (!pickedBuilds){
      continue;
    }

    const newNames = ['K','L','M'];

    const extraPts = {};            // { K:{x,y}, L:{x,y}, M:{x,y} }
    const triplesForDisplay = [];   // pour écrire l'énoncé en latex

    for (let idx=0; idx<3; idx++){
      const b = pickedBuilds[idx];
      const newName = newNames[idx];

      // coordonnée du nouveau point (T) pour ce build
      extraPts[newName] = b.T;

      // stocke les infos pour le texte \vec{GK} = \vec{AB}, etc.
      triplesForDisplay.push({
        fromO: b.Oname,   // point d'origine du vecteur à gauche (ex G dans GK)
        newPt: newName,   // K / L / M
        fromU: b.Uname,   // point U pour le vecteur de référence (ex A)
        fromV: b.Vname    // point V pour le vecteur de référence (ex B)
      });
    }

    // jolis énoncés latex pour la question 3
    const q3HTML = `
      Sur le quadrillage ci-contre, placer les points \\(K\\), \\(L\\) et \\(M\\) tels que :
      <div style="margin-left:1.2em; margin-top:.4rem;">
        \\( \\overrightarrow{${triplesForDisplay[0].fromO}${triplesForDisplay[0].newPt}} = \\overrightarrow{${triplesForDisplay[0].fromU}${triplesForDisplay[0].fromV}} \\)<br>
        \\( \\overrightarrow{${triplesForDisplay[1].fromO}${triplesForDisplay[1].newPt}} = \\overrightarrow{${triplesForDisplay[1].fromU}${triplesForDisplay[1].fromV}} \\)<br>
        \\( \\overrightarrow{${triplesForDisplay[2].newPt}${triplesForDisplay[2].fromO}} = \\overrightarrow{${triplesForDisplay[2].fromV}${triplesForDisplay[2].fromU}} \\)
      </div>
    `;

    // 7. Layout UNIQUE pour TOUT (élève ET corrigé)
    const layout = computeLayout(pts, extraPts);

    // 8. figure interactive pour l'élève :
    const figStudent = renderFigureSVG(layout, pts, null, {interactive:true});

    // 9. figure corrigée :
    const figCorr = renderFigureSVG(layout, pts, extraPts, {interactive:false});

    // 10. correction des questions 1 et 2
    const corrLines = qAll.map(q=>{
      const qTextNoDots = q.text.replace(/\.\.\.$/,'');
      return `<div class="line">${q.label} ${qTextNoDots} \\( \\) \\(${q.ans}\\)</div>`;
    }).join("");

    // 11. bloc solution en tableau 2 colonnes
    const solTableHTML = `
      <div class="exo-block">
        <span class="exo-title">Correction</span>
        <table class="exo-layout-table">
          <tr>
            <td class="exo-fig-col">
              <div class="figure-area" style="text-align:center;">
                ${figCorr}
              </div>
            </td>
            <td class="exo-q-col">
              <div class="steps">
                <div class="stepTitle">Correction détaillée</div>
                ${corrLines}
              </div>
            </td>
          </tr>
        </table>
      </div>
    `;

    // 12. succès → on renvoie l'état
    return {
      title: "Exercice 1 — Translation et vecteur",
      figureSVG: figStudent,
      qAll,
      q3HTML,
      targetPts: extraPts,
      layoutInfo: {
        minX: layout.minX,
        maxY: layout.maxY,
        pad:  layout.pad,
        scale:layout.scale
      },
      orderForPlacement: ["K","L","M"],

      // pour la correction / PDF
      corrFigure:    figCorr,
      corrLinesHTML: corrLines,
      solTableHTML
    };
  }

  // si on n'a rien réussi après 30 tentatives on renvoie un fallback propre
  return {
    title:"Exercice 1 — Translation et vecteur",
    figureSVG:"<div style='color:#b00020;font-weight:600'>[Aucune figure exploitable]</div>",
    qAll:[],
    q3HTML:"",
    targetPts:{},
    layoutInfo:{minX:0,maxY:0,pad:20,scale:20},
    orderForPlacement:["K","L","M"],
    corrFigure:"",
    corrLinesHTML:"",
    solTableHTML:`<div class="exo-block"><span class="exo-title">Correction</span><div class="steps"><div class="stepTitle">Aucune question générée</div></div></div>`
  };
}





/* =========================================================
   RENDU DANS LE HOST POUR L'EXERCICE 1
   -------------------------------------------------
   Le bloc .exo-block reste celui de ta fiche.
   On va juste générer dynamiquement plusieurs <div class="qa-row">
   ========================================================= */

function buildHostHTML_trans(st){
  const grp1 = st.qAll.filter(q=>q.group==="1");
  const grp2 = st.qAll.filter(q=>q.group==="2");

  function renderGroupWithInputs(num, arr){
    if(!arr.length) return '';
    const lines = arr.map(q=>{
      const displayText = q.text.replace('...', ' ');
      return `
        <div class="qa-row" style="margin:.4rem 0;">
          <label for="${q.inputId}" style="flex:1 1 auto;min-width:260px;">
            <strong>\\(${q.label}\\)</strong>
            ${displayText}\\( \\)
          </label>
          <input id="${q.inputId}" class="inp"
                 maxlength="2"
                 style="text-transform:uppercase;min-width:60px;max-width:80px;text-align:center;font-weight:600;">
          <span id="tick-${q.inputId}" class="tick" style="margin-left:6px"></span>
        </div>
      `;
    }).join("");
    return `
      <div class="subhead" style="font-weight:600;margin-top:.8rem;">${num}.</div>
      <div style="margin-left:1.2em;">
        ${lines}
      </div>
    `;
  }

  // groupe 3 : pas d'input, juste l'énoncé q3Text
const group3HTML = `
  <div class="subhead" style="font-weight:600;margin-top:1rem;">3.</div>
  <div style="margin-left:1.2em;">
    ${st.q3HTML || ""}
  </div>
`;


  // colonne de droite
  const rightColHTML = `
    <div class="enonce">
      <div style="margin-bottom:.5rem;"></div>

      ${renderGroupWithInputs("1", grp1)}
      ${renderGroupWithInputs("2", grp2)}
      ${group3HTML}

      <div id="res" style="margin-top:1rem;"></div>
    </div>
  `;

  // colonne de gauche → figureSVG élève (grille sans K,L,M)
const leftColHTML = `
  <div class="figure-area" style="text-align:center;">
    ${st.figureSVG}
    <div class="place-controls" style="display:flex;justify-content:center;gap:.5rem;flex-wrap:wrap;">
      <button class="btn-place" data-point="K"
        style="padding:4px 8px;border:1px solid #999;border-radius:6px;background:#fff;cursor:pointer;font-size:.9rem;">
        Placer K
      </button>
      <button class="btn-place" data-point="L"
        style="padding:4px 8px;border:1px solid #999;border-radius:6px;background:#fff;cursor:pointer;font-size:.9rem;">
        Placer L
      </button>
      <button class="btn-place" data-point="M"
        style="padding:4px 8px;border:1px solid #999;border-radius:6px;background:#fff;cursor:pointer;font-size:.9rem;">
        Placer M
      </button>
    </div>

    <div class="place-ticks" style="display:flex;justify-content:center;gap:1rem;margin-top:.5rem;font-weight:600;">
      <div style="min-width:2rem;">K <span id="tick-K" class="tick"></span></div>
      <div style="min-width:2rem;">L <span id="tick-L" class="tick"></span></div>
      <div style="min-width:2rem;">M <span id="tick-M" class="tick"></span></div>
    </div>
  </div>
`;



 return `
  <div class="exo-block">
    <span class="exo-title">${st.title}</span>

    <table class="exo-layout-table">
      <tr>
        <td class="exo-fig-col">
          ${leftColHTML}
        </td>
        <td class="exo-q-col">
          ${rightColHTML}
        </td>
      </tr>
    </table>
  </div>

  <!-- 🔽 conteneur pour la correction complète en tableau -->
  <div id="solution-block" style="margin-top:1rem;"></div>
`;

}



// maj tique locale
function setTickFor(id, state){
  // state peut être true (ok), false (ko), ou null/undefined (pas d'info)
  const el = $('#tick-'+id);
  if(!el) return;

  if(state === true){
    el.className = 'tick ok';
    el.textContent = '✓';
  } else if(state === false){
    el.className = 'tick ko';
    el.textContent = '✗';
  } else {
    // état neutre → on cache visuellement
    el.className = 'tick';
    el.textContent = '';
  }
}


function checkAnswer_trans(st){
  let locTot = 0;
  let locOK  = 0;

  st.qAll.forEach(q=>{
    const inp = $('#'+q.inputId);
    if(!inp){
      setTickFor(q.inputId, null);
      return;
    }

    const valRaw = (inp.value||'').trim();
    if(!valRaw){
      // rien tapé -> pas de tick du tout
      setTickFor(q.inputId, null);
      return;
    }

    // là l'élève a tenté une réponse, on corrige
    locTot++;
    const student = valRaw.toUpperCase();
    const good    = String(q.ans||'').toUpperCase();
    const ok = (student === good);
    if(ok) locOK++;

    setTickFor(q.inputId, ok); // ok = true ou false
  });

  return {count:locTot, good:locOK};
}



/* =========================================================
   REGISTRY : pour l'instant un seul exercice (EXO_TRANS_1)
   mais on garde l'architecture REG / REGISTRY comme sur
   tes autres fiches.
   ========================================================= */

const EXO_TRANS_1 = {
  id:'exo_trans_1',
  title:'Exercice 1 — Translation',
  gen(host){
  const st = genExTranslations();
  if (host){
    host.innerHTML = buildHostHTML_trans(st);
    host.__state = st;

   host.dataset.state = JSON.stringify({
  title:       st.title,
  figureSVG:   st.figureSVG,
  qAll:        st.qAll,
  q3HTML:      st.q3HTML,
  // pour la correction :
  corrFigure:      st.corrFigure,
  corrLinesHTML:   st.corrLinesHTML,
  solTableHTML:    st.solTableHTML
});


    attachInteractiveHandlers(); // <-- IMPORTANT

    if (window.MathJax?.typeset) MathJax.typeset();
  }
  return st;
}
,
correct(host, st){
  const r1 = checkAnswer_trans(st); // réponses textuelles 1./2.
  const r2 = checkPlacement(st);    // placement K,L,M

  scoreTot += r1.count + r2.count;
  scoreOK  += r1.good  + r2.good;
  updateScore();
},

solution(host, st){
  // on insère le tableau de correction global sous l’énoncé
  const solZone = host.querySelector('#solution-block');
  if (solZone){
    solZone.innerHTML = st.solTableHTML;
  }

  // puis on relance MathJax pour mettre au propre les \(...\)
  if(window.MathJax?.typeset) MathJax.typeset();
}
,
  reset(host){
  $('#res',host).textContent = '';
  stResetTicks(host.__state);
  stClearInputs(host.__state);

  // on reset aussi les ticks K/L/M
  ["K","L","M"].forEach(lbl=>{
    const t = $('#tick-'+lbl, host);
    if(t){
      t.className = 'tick';
      t.textContent = '';
    }
  });
}

};

// helpers reset
function stResetTicks(st){
  st.qAll.forEach(q=>setTickFor(q.inputId, null));
}

function stClearInputs(st){
  st.qAll.forEach(q=>{
    const inp = $('#'+q.inputId);
    if(inp) inp.value='';
  });
}

/* =========================================================
   EXO REGISTRY GLOBAL
   ========================================================= */
const REG = [EXO_TRANS_1];
window.REG = REG;
window.REGISTRY = REG;

/* ===== Montage UI ===== */
function mount(){
  const sel=$("#exo-select"); if(!sel) return;
  sel.innerHTML = REG.map((e,i)=>`<option value="${e.id}">${i+1}. ${e.title}</option>`).join('');

  function getDef(){
    const id=sel.value||REG[0].id;
    return REG.find(e=>e.id===id)||REG[0];
  }
  function newOne(){
    const ex=getDef();
    const host=$("#host");
    ex.gen(host);
  }
  function check(){
    const ex=getDef();
    const host=$("#host");
    ex.correct(host, host.__state);
  }
  function sol(){
    const ex=getDef();
    const host=$("#host");
    ex.solution(host, host.__state);
  }
  function reset(){
    const ex=getDef();
    const host=$("#host");
    ex.reset(host);
  }

  sel.onchange=newOne;
  $("#btn-new").onclick=newOne;
  $("#btn-check").onclick=check;
  $("#btn-solution").onclick=sol;
  $("#btn-reset").onclick=reset;

  document.addEventListener('keydown', e=>{ if(e.key==='Enter'){ check(); }});

  sel.value=REG[0].id;
  newOne();
  updateScore();
}
document.addEventListener('DOMContentLoaded', mount);
function redrawStudentLayer(svg, st){
  const layer = svg.querySelector("#student-layer");
  if(!layer) return;

  // vider le layer
  layer.innerHTML = "";

  // pour chaque point déjà placé par l'élève, on le dessine
  if (!st.placedByStudent) return;
  for (const lbl of Object.keys(st.placedByStudent)){
    const {x,y} = st.placedByStudent[lbl];

    // projeter coord math -> pixel
    const minX  = parseFloat(svg.getAttribute("data-minx"));
    const maxY  = parseFloat(svg.getAttribute("data-maxy"));
    const scale = parseFloat(svg.getAttribute("data-scale"));
    const pad   = parseFloat(svg.getAttribute("data-pad"));

    const Xpix = pad + (x - minX)*scale;
    const Ypix = pad + (maxY - y)*scale;

    layer.innerHTML += `
      <circle cx="${Xpix.toFixed(1)}" cy="${Ypix.toFixed(1)}" r="3" fill="#b00020"/>
      <text x="${(Xpix+5).toFixed(1)}" y="${(Ypix-5).toFixed(1)}"
            font-size="12" font-family="system-ui,Segoe UI,Roboto,Arial"
            fill="#b00020">${lbl}</text>
    `;
  }
}

function attachInteractiveHandlers(){
  const host = $("#host");
  if(!host || !host.__state) return;
  const st = host.__state;

  const svg = host.querySelector("#fig-click");
  if(!svg) return;

  // init mémoire élève
  if(!st.placedByStudent){
    st.placedByStudent = {}; // ex {K:{x:...,y:...}, L:{...}, M:{...}}
  }
  st.activePoint = null;

  // Boutons K/L/M
  $$(".btn-place", host).forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const p = btn.getAttribute("data-point");
      st.activePoint = p; // active ce point
      // Optionnel : feedback visuel
      $$(".btn-place", host).forEach(b=>b.style.outline="none");
      btn.style.outline="2px solid #b00020";
    }, {passive:true});
  });

  // Clic sur le SVG pour poser/déplacer le point actif
  svg.addEventListener("click", (evt)=>{
    if(!st.activePoint) return; // aucun point sélectionné

    // récup conversion pixel -> math
    const bbox  = svg.getBoundingClientRect();
    const pad   = parseFloat(svg.getAttribute("data-pad"));
    const scale = parseFloat(svg.getAttribute("data-scale"));
    const minX  = parseFloat(svg.getAttribute("data-minx"));
    const maxY  = parseFloat(svg.getAttribute("data-maxy"));

    const relX = evt.clientX - bbox.left;
    const relY = evt.clientY - bbox.top;

    const xMath = ((relX - pad)/scale) + minX;
    const yMath = maxY - ((relY - pad)/scale);

    // snap aux entiers
    const xSnap = Math.round(xMath);
    const ySnap = Math.round(yMath);

    // on stocke pour ce label
    st.placedByStudent[st.activePoint] = {x:xSnap, y:ySnap};

    // redraw
    redrawStudentLayer(svg, st);
  }, {passive:true});
}


/* =========================================================
   ADAPTATEUR PDF
   -------------------------------------------------
   On reprend ton système : ExoPDF.init(...) + beforeGen,
   beforeRender refait un rendu LaTeX propre en SVG.
   ========================================================= */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;

    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',

      beforeGen(def, _st, ctx){
        const hostTmp = document.createElement('div');
        if (def && typeof def.gen === 'function') def.gen(hostTmp);
        let st = {};
        try {
          st = JSON.parse(hostTmp.dataset.state || '{}');
        } catch(_){}
        return st;
      },

      // version adaptée pour cet exo :
      beforeRender(def, st, withSolutions){
  return (async () => {
    let host = null;
    try {
      host = document.createElement('div');
      host.id = 'pdf-host';
      host.style.position='fixed';
      host.style.left='-10000px';
      host.style.top='-10000px';
      document.body.appendChild(host);

      // on prépare l'énoncé PDF :
      // - titre
      // - figureSVG
      // - puis les questions 1.a,1.b,... 2.a,2.b,... sans inputs
     // on prépare l'énoncé PDF :

// ... tout le code avant reste inchangé jusqu'à la construction de rightPDF/leftPDF ...

const grp1 = (st.qAll || []).filter(q=>q.group==="1");
const grp2 = (st.qAll || []).filter(q=>q.group==="2");

function renderGroupNoInput(num, arr){
  if(!arr.length) return '';
  const lines = arr.map(q=>{
    const t = q.text.replace('...', '_____');
    return `<div>${q.label} ${t}</div>`;
  }).join("");
  return `
    <div style="margin-top:.8rem;">
      <div style="font-weight:600;">${num}.</div>
      <div style="margin-left:1.2em;">
        ${lines}
      </div>
    </div>
  `;
}

const rightPDF = `
  <div>
    <div></div>
    ${renderGroupNoInput("1", grp1)}
    ${renderGroupNoInput("2", grp2)}
    <div style="margin-top:1rem;">
      ${st.q3HTML || ""}
    </div>
  </div>
`;

const leftPDF = `
  <div style="text-align:center;">
    ${st.figureSVG || ""}
  </div>
`;

const pdfTwoCols = `
  <table class="exo-layout-table" style="width:100%;border-collapse:collapse;">
    <tr>
      <td class="exo-fig-col"
          style="vertical-align:top;width:420px;min-width:420px;padding:8px 12px;border:none;">
        ${leftPDF}
      </td>
      <td class="exo-q-col"
          style="vertical-align:top;padding:8px 12px;border:none;">
        ${rightPDF}
      </td>
    </tr>
  </table>
`;

// maintenant on colle l'énoncé PUIS la correction sous forme de tableau
let innerHTML_for_pdf = `
  <div class="exo-block">
    <span class="exo-title">${st.title||''}</span>
    ${pdfTwoCols}
  </div>
`;

if (withSolutions){
  innerHTML_for_pdf += `
    <div style="margin-top:1rem;">
      ${st.solTableHTML || ""}
    </div>
  `;
}



      // === tout le reste du pipeline iframe MathJax SVG est identique à ce qu'on a déjà ===
      const iframe = document.createElement('iframe');
      iframe.style.position='fixed';
      iframe.style.left='-10000px';
      iframe.style.top='-10000px';
      iframe.style.width='0';
      iframe.style.height='0';
      iframe.style.visibility='hidden';
      document.body.appendChild(iframe);

      const iwin = iframe.contentWindow;
      const idoc = iframe.contentDocument;

      idoc.open();
      idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="content"></div></body></html>');
      idoc.close();

      const contentDiv = idoc.getElementById('content');
      contentDiv.innerHTML = innerHTML_for_pdf;

      // purge éventuelle d'anciens mjx
      contentDiv.querySelectorAll('mjx-container').forEach(mjx=>{
        mjx.replaceWith(mjx.textContent || '');
      });
      contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());

      const cfg = idoc.createElement('script');
      cfg.type = 'text/javascript';
      cfg.text = `
        window.MathJax = {
          tex: {
            inlineMath: [['\\\\(','\\\\)'], ['$', '$']],
            displayMath: [['\\\\[','\\\\]'], ['$$','$$']],
            processEscapes: true,
            packages: { '[+]': ['bbox','ams'] },
            macros: { vec: ['\\\\overrightarrow{#1}',1] }
          },
          svg: { fontCache: 'none' },
          options: { skipHtmlTags: ['script','noscript','style','textarea'] },
          startup: { typeset: false }
        };
      `;
      idoc.head.appendChild(cfg);

      const svgScriptURL = new URL("../../../../es5/tex-svg.js", window.location.href).href;
      const mj = idoc.createElement('script');
      mj.type = 'text/javascript';
      mj.src  = svgScriptURL;
      idoc.head.appendChild(mj);

      await new Promise(resolve=>{
        mj.onload = resolve;
        mj.onerror = resolve;
      });

      async function waitMathJaxReady(win){
        const limit=200;
        let n=0;
        while((!win.MathJax) || (!win.MathJax.typesetPromise && !win.MathJax.typeset)){
          await new Promise(res=>setTimeout(res,5));
          n++;
          if(n>limit) break;
        }
      }
      await waitMathJaxReady(iwin);

      if(iwin.MathJax && iwin.MathJax.typesetPromise){
        await iwin.MathJax.typesetPromise([ contentDiv ]);
      }else if(iwin.MathJax && iwin.MathJax.typeset){
        iwin.MathJax.typeset([ contentDiv ]);
      }

      ;(function purgeCHTML(){
        contentDiv.querySelectorAll('mjx-container[jax="CHTML"]').forEach(n=>n.remove());
        contentDiv.querySelectorAll('mjx-container:not([jax="SVG"])').forEach(n=>n.remove());
        contentDiv.querySelectorAll('.MJX_Assistive_MathML, mjx-assistive-mml').forEach(n=>n.remove());
      })();

      const finalHTML = contentDiv.innerHTML;

      iframe.remove();
      if(host) host.remove();

      return finalHTML;

    } catch(e){
      console.error('beforeRender SVG error:', e);
      let fallbackHTML = '';
      if(host){
        fallbackHTML = withSolutions
          ? (host.querySelector('#res')?.outerHTML || host.innerHTML)
          : host.innerHTML;
        host.remove();
        host=null;
      }
      return fallbackHTML;
    }
  })();
}

    });
  });
})();

/* ===== mobile tweaks ===== */
document.addEventListener('DOMContentLoaded', () => {
  const coarse = matchMedia('(pointer:coarse)').matches;

  if (window.innerWidth <= 760) {
    const actions = document.querySelector('.controls') || document.querySelector('.header .controls');
    if (actions) {
      const bar = document.createElement('div');
      bar.className = 'mb-actions';
      [['#btn-check','Vérifier'], ['#btn-solution','Solution']].forEach(([sel,label])=>{
        const src = document.querySelector(sel);
        if (src) {
          const clone = src.cloneNode(true);
          clone.classList.add('btn');
          clone.type = 'button';
          clone.removeAttribute('id');
          clone.addEventListener('click', (e)=>{ e.preventDefault(); src.click(); });
          bar.appendChild(clone);
        } else {
          const fallback = document.createElement('button');
          fallback.className = 'btn';
          fallback.type = 'button';
          fallback.textContent = label;
          fallback.addEventListener('click', (e)=>{ e.preventDefault(); document.querySelector(sel)?.click(); });
          bar.appendChild(fallback);
        }
      });
      document.body.appendChild(bar);
    }
  }

  // champ focus mobile
  document.querySelectorAll('input[type="text"], textarea').forEach(el=>{
    el.setAttribute('autocomplete','off');
    el.setAttribute('autocapitalize','off');
    el.setAttribute('autocorrect','off');
    el.setAttribute('spellcheck','false');
    el.addEventListener('focus', ()=>{ setTimeout(()=>el.scrollIntoView({block:'center', behavior:'smooth'}), 50); }, {passive:true});
  });

  if (coarse) {
    document.querySelectorAll('circle[data-draggable], .pt, .drag-point').forEach(c=>{
      const r = parseFloat(c.getAttribute('r')||'5');
      if (r < 10) c.setAttribute('r', String(12));
      c.style.touchAction='none';
    });
  }
}, {passive:true});
</script>

</body>
</html>
