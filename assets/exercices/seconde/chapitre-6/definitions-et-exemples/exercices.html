<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Fonctions affines - D√©finitions et exemples</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}

/* Bloc solution (UI) */
#res.steps{
  background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;
}
#res.steps p{margin:.25rem 0}

.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }




/* Grille 3 colonnes pour les vecteurs √† placer (partie 3) */
.grid3 {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px 12px;           /* espace lignes/colonnes */
  align-items: start;
}
.grid3 .chipwrap { width: 100%; }

/* ---- Blocs sous le rep√®re : 2 lignes √ó 5 colonnes ---- */
.flat12-wrap{ margin-top:10px; }

.sec{ margin:10px 0; }
.sec .title{ font-weight:700; font-size:1.05rem; margin-bottom:6px; }

/* une grille de 5 colonnes */
.grid5{
  display:grid;
  grid-template-columns: repeat(5, max-content);
  gap:8px 14px;
  align-items:center;
}

/* cellules : libell√© + vecteur-colonne + tick */
.grid5 .inlinecell{ display:flex; align-items:center; gap:6px; }

/* vecteurs en colonne compacts pour tenir √† 5√ó2 */
.grid5 .colvec{
  --parenW:8px; --padX:5px; --gap:3px;
  --inW:44px; --inPy:2px; --inFs:12.5px;
}

.hidden{ display:none; }


/* ‚Äî Anti ‚Äúbarres noires‚Äù MathJax ‚Äî */
.steps mjx-container { color: #111 !important; background: transparent !important; }
.steps mjx-container svg { overflow: visible !important; }
.steps mjx-container svg rect,
.steps mjx-container svg path[data-mml-node="mspace"] { fill: none !important; }
.steps mjx-mrow, .steps mjx-mi, .steps mjx-mo, .steps mjx-mn { background: transparent !important; }

/* ==== Nom de vecteur avec fl√®che au-dessus ============================== */
.vecname{ position:relative; display:inline-block; }
.vecname input{
  width:72px; text-align:center; font-weight:700; font-size:15px;
  letter-spacing:.12em; text-transform:uppercase;
  padding:14px 10px 6px 10px; /* place pour la fl√®che au-dessus */
  border:1px solid #ddd; border-radius:8px; background:#fff;
}
.vecname::before{
  content:""; position:absolute; left:12px; right:20px; top:6px; height:2px; background:#111;
}
.vecname::after{
  content:""; position:absolute; top:2px; right:12px;
  border-left:8px solid #111; border-top:5px solid transparent; border-bottom:5px solid transparent;
}

/* Lignes compactes sous le rep√®re pour e2 */
.vecrow{ display:flex; align-items:center; gap:12px; margin:6px 0; flex-wrap:wrap; }
.vecrow .lbl{ font-weight:700; min-width:max-content; }
.vecrow .tick{ min-width:1.4rem; font-weight:900; }
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.pair{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.pair .lbl{font-weight:700;min-width:1.6rem}

/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }

.table-compare {
  border-collapse: collapse;
  width: 100%;
  margin: .5rem 0 .6rem 0;
}
.table-compare td {
  vertical-align: top;
  padding: 0 .8rem;
  border: none;
}
.table-compare td:first-child {
  border-right: 2px solid #000; /* fine barre verticale */
}
</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Fonctions affines - D√©finitions et exemples</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Coordonn√©es au format <code>u;v</code> (ex. <code>6;1</code> ou <code>3/2; -5</code>). Virgule d√©cimale ¬´ , ¬ª ou point ¬´ . ¬ª accept√©s.</li>
        <li>Jamais de parenth√®ses : on tape <code>6;1</code> (les parenth√®ses sont affich√©es automatiquement).</li>
        <li>Fractions conserv√©es dans les corrections.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Mini helpers g√©n√©riques ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
const HOST = $('#host');
function retypeset(host){
  if (window.__PDF_BUILDING) return;              // ‚¨ÖÔ∏è ignore en phase PDF
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]);
}function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; }

/* ====== Rationnels ‚Äúpropres‚Äù (pour jolies fractions dans les corrections) ====== */
function R(p,q=1){ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function addR(x,y){ return R(x.p*y.q + y.p*x.q, x.q*y.q); }
function subR(x,y){ return R(x.p*y.q - y.p*x.q, x.q*y.q); }
function mulR(x,y){ return R(x.p*y.p, x.q*y.q); }
function negR(x){ return R(-x.p, x.q); }
function numR(x){ return x.p/x.q; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'‚àí':''; const P=Math.abs(r.p); return s+'\\dfrac{'+P+'}{'+r.q+'}'; }
function textR(r){ return r.q===1 ? String(r.p) : `${r.p}/${r.q}`; }
// Retourne -\dfrac{|p|}{q} si p<0, sinon \dfrac{p}{q}; et un entier si q=1
function latexR_leadingMinus(r){
  const p = r.p, q = r.q;
  if (q === 1) return String(p);              // pas de /1 affich√© dans ton flux final
  if (p < 0) return `-\\dfrac{${Math.abs(p)}}{${q}}`;
  return `\\dfrac{${p}}{${q}}`;
}


/* ===== MathJax helper ===== */
function MJ(el){
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }



// Retourne les √©tapes LaTeX pour p/q : d'abord p/q, puis (optionnel) la forme r√©duite.
function fracStepsLatex(p,q){
  const g0 = gcd(Math.abs(p), Math.abs(q));
  const first = `\\dfrac{${p}}{${q}}`;
  if (g0>1){
    const pr = p/g0, qr = q/g0;
    return [first, `\\dfrac{${pr}}{${qr}}`]; // √©tape "r√©duction"
  }
  return [first]; // d√©j√† irr√©ductible ‚Üí une seule ligne
}

/* === Helpers de comparaison (signes & doublons) ========================== */
// Normalise les signes dans les fractions pour comparer :
//  \dfrac{-a}{b}  ‚Üí  -\dfrac{a}{b}
// enl√®ve espaces superflus et normalise le "‚àí" unicode en "-"
function normalizeFracSign(s){
  return String(s)
    .replace(/\u2212/g, '-') // unicode minus ‚Üí "-"
    .replace(/\\dfrac\{\s*-\s*([^}]+)\}\{\s*([^}]+)\}/g, '-\\dfrac{$1}{$2}')
    .replace(/\(\s*-\s*\\dfrac/g, '(-\\dfrac')
    .replace(/\s+/g, ' ')
    .trim();
}


/* ====== UI host ====== */
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq"></div>
    <hr class="sep">
    <div class="controls">
      <label class="input">R√©ponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>
  `;
}

function setEqu(html){ const box=$('#equ',HOST); if(box) box.innerHTML = html; retypeset(HOST); }
function setStepsHTML(html){ $('#res',HOST).innerHTML=html; retypeset(HOST); }
function setSteps(lines){ setStepsHTML(lines.map(L=>`<p>${L}</p>`).join('')); }
function setFB(ok, msg=''){
  const fb = $('#fb', HOST);
  if (!fb) return;
  if (ok === null){        // ‚¨ÖÔ∏è mode neutre
    fb.className = '';     // ni .ok ni .ko
    fb.innerHTML = msg;    // message libre (peut contenir du HTML)
    return;
  }
  fb.className = ok ? 'ok' : 'ko';
  fb.textContent = (ok?'‚úîÔ∏é Correct. ':'‚úó Incorrect. ') + msg;
}

/* ====== Parsing des r√©ponses u;v ====== */
function normalizeMinus(s){ return String(s||'').replace(/\u2212/g,'-').trim(); }
function parseNumber(token){
  token = token.replace(',','.');
  if (/^[-+]?\d+\/\d+$/.test(token)){ const [p,q]=token.split('/').map(Number); return p/q; }
  return token===''?NaN:Number(token);
}
function parsePairUV(s){
  s = normalizeMinus(s).replace(/\s+/g,'');
  const m = s.match(/^([^;]+);([^;]+)$/);
  if(!m) return {ok:false};
  const u=parseNumber(m[1]), v=parseNumber(m[2]);
  return (isFinite(u)&&isFinite(v)) ? {ok:true,u,v} : {ok:false};
}


/* ===== Rep√®re ===== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R};
    this.points=[]; this.user=[]; this.vectors=[]; this.userVectors=[];
    this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const ns = 'http://www.w3.org/2000/svg';
    const s  = document.createElementNS(ns,'svg');
    s.setAttribute('class','svgbox');
    s.setAttribute('viewBox','0 0 420 420');
    s.setAttribute('preserveAspectRatio','xMidYMid meet');

const defs = document.createElementNS(ns,'defs');

// --- Pointe pour les AXES (un peu plus grande)
const axisArrow = document.createElementNS(ns,'marker');
axisArrow.setAttribute('id','axisArrow');
axisArrow.setAttribute('markerUnits','strokeWidth');
axisArrow.setAttribute('markerWidth','7');
axisArrow.setAttribute('markerHeight','5');
axisArrow.setAttribute('refX','5');
axisArrow.setAttribute('refY','2.5');
axisArrow.setAttribute('orient','auto');
{
  const p = document.createElementNS(ns,'path');
  p.setAttribute('d','M0,0 L6,2.5 L0,5 z');
  p.setAttribute('fill','#000');
  axisArrow.appendChild(p);
}
defs.appendChild(axisArrow);

// --- Pointe pour les VECTEURS (plus petite)
const vecArrow = document.createElementNS(ns,'marker');
vecArrow.setAttribute('id','vecArrow');
vecArrow.setAttribute('markerUnits','strokeWidth');
vecArrow.setAttribute('markerWidth','4');   // ‚¨ÖÔ∏è plus petit
vecArrow.setAttribute('markerHeight','3');
vecArrow.setAttribute('refX','3.2');
vecArrow.setAttribute('refY','1.5');
vecArrow.setAttribute('orient','auto');
{
  const p = document.createElementNS(ns,'path');
  p.setAttribute('d','M0,0 L4,1.5 L0,3 z');  // ‚¨ÖÔ∏è pointe r√©duite
  p.setAttribute('fill','#000');
  vecArrow.appendChild(p);
}
defs.appendChild(vecArrow);

s.appendChild(defs);




    this.gGrid=document.createElementNS(ns,'g'); s.appendChild(this.gGrid);
    this.gAxes=document.createElementNS(ns,'g'); s.appendChild(this.gAxes);
    this.gPts=document.createElementNS(ns,'g'); s.appendChild(this.gPts);
    this.gVec=document.createElementNS(ns,'g'); s.appendChild(this.gVec);
    this.gUser=document.createElementNS(ns,'g'); s.appendChild(this.gUser);
    this.gUserVec=document.createElementNS(ns,'g'); s.appendChild(this.gUserVec);

    const handleTap = (ev) => {
      if(!this.clickable) return;
      const r  = s.getBoundingClientRect();
      const vb = s.viewBox?.baseVal || {x:0,y:0,width:420,height:420};
      const cx = ('clientX' in ev ? ev.clientX : ev.touches?.[0]?.clientX);
      const cy = ('clientY' in ev ? ev.clientY : ev.touches?.[0]?.clientY);
      const x = (cx - r.left) * (vb.width  / r.width);
      const y = (cy - r.top)  * (vb.height / r.height);
      const c = this.screenToCoord(x,y);
      const lim = this.innerLimits();
      const xi  = Math.round(c.x), yi = Math.round(c.y);
      if (xi < lim.xmin || xi > lim.xmax || yi < lim.ymin || yi > lim.ymax) return;
      if (this.onClick) this.onClick({x:xi,y:yi});
    };
    s.addEventListener('pointerdown', (ev)=>{ if (ev.pointerType==='touch') ev.preventDefault(); handleTap(ev); }, {passive:false});
    s.addEventListener('click', handleTap, {passive:true});
    return s;
  }
  innerLimits(){ const R=this.R; return {xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; }
  basis(){
    const w=420,h=420,m=24;
    const X=this.R.xmax-this.R.xmin, Y=this.R.ymax-this.R.ymin;
    const Sx = (w-2*m)/X, Sy = (h-2*m)/Y;
    const O = { x:m - this.R.xmin*Sx, y:h-m + this.R.ymin*Sy };
    return {O,Sx,Sy,w,h,m};
  }
  coordToScreen(x,y){ const {O,Sx,Sy}=this.basis(); return {x:O.x + x*Sx, y:O.y - y*Sy}; }
  screenToCoord(px,py){ const {O,Sx,Sy}=this.basis(); return {x:(px-O.x)/Sx, y:-(py-O.y)/Sy}; }

  setPoints(arr){ this.points=arr||[]; this.redraw(); }
  setVectors(arr){ this.vectors=arr||[]; this.redraw(); }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  clearUserVectors(){ this.userVectors=[]; this.gUserVec.innerHTML=''; }

  _latexFO(html, x, y, color='#000'){
    const fo=document.createElementNS(this.el.namespaceURI,'foreignObject');
    fo.setAttribute('x', x); fo.setAttribute('y', y); fo.setAttribute('width', 110); fo.setAttribute('height', 26);
    const div=document.createElementNS('http://www.w3.org/1999/xhtml','div');
    div.style.fontSize='13px'; div.style.fontWeight='700'; div.style.color=color;
    div.innerHTML = html;
    fo.appendChild(div);
    return fo;
  }
  
    _dot(px, py, label, color = '#000'){
    const g = document.createElementNS(this.el.namespaceURI,'g');
    const c = document.createElementNS(this.el.namespaceURI,'circle');
    c.setAttribute('cx', px);
    c.setAttribute('cy', py);
    c.setAttribute('r', 4.2);
    c.setAttribute('fill', color);
    g.appendChild(c);
    if(label){
      const t = document.createElementNS(this.el.namespaceURI,'text');
      t.setAttribute('x', px + 6);
      t.setAttribute('y', py - 6);
      t.setAttribute('font-size', '13');
      t.textContent = label;
      g.appendChild(t);
    }
    return g;
  }

  redraw(){
  const R=this.R;
  this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gPts.innerHTML=''; this.gVec.innerHTML='';

  const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line');
    L.setAttribute('x1',x1);L.setAttribute('y1',y1);L.setAttribute('x2',x2);L.setAttribute('y2',y2);
    L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.2:1); return L; };

  // grille
  for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
  for(let t=R.ymin;t<=R.ymax;t++){ const p1=this.coordToScreen(R.xmin,t), p2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }

  // axes
  const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
  const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
  axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)');
  this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);

  // O, u, v
  const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
  // point O
  this.gAxes.appendChild(this._dot(O.x,O.y,'O'));
  // fl√®che de u : O -> (1;0)
  const uLn=document.createElementNS(this.el.namespaceURI,'line');
  uLn.setAttribute('x1',O.x); uLn.setAttribute('y1',O.y); uLn.setAttribute('x2',I.x); uLn.setAttribute('y2',I.y);
  uLn.setAttribute('stroke','#000'); uLn.setAttribute('stroke-width','2'); uLn.setAttribute('marker-end','url(#axisArrow)');;
  this.gAxes.appendChild(uLn);
  // fl√®che de v : O -> (0;1)
  const vLn=document.createElementNS(this.el.namespaceURI,'line');
  vLn.setAttribute('x1',O.x); vLn.setAttribute('y1',O.y); vLn.setAttribute('x2',J.x); vLn.setAttribute('y2',J.y);
  vLn.setAttribute('stroke','#000'); vLn.setAttribute('stroke-width','2'); vLn.setAttribute('marker-end','url(#axisArrow)');
  this.gAxes.appendChild(vLn);
  // labels LaTeX
  this.gAxes.appendChild(this._latexFO('\\(\\overrightarrow i\\)', I.x, I.y));
  this.gAxes.appendChild(this._latexFO('\\(\\overrightarrow j\\)', J.x+6, J.y-18));
  

  // points fixes
  // ‚¨áÔ∏è remplace le bloc "points fixes" dans redraw()
for(const p of this.points){
  const P=this.coordToScreen(p.x,p.y);
  const g=document.createElementNS(this.el.namespaceURI,'g');
  const c=document.createElementNS(this.el.namespaceURI,'circle');
  c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); c.setAttribute('r',4.2);
  c.setAttribute('fill',p.fill||'#000'); g.appendChild(c);
  if(p.label){
    const t=document.createElementNS(this.el.namespaceURI,'text');
    const dx = (typeof p.dx==='number') ? p.dx : 6;
    const dy = (typeof p.dy==='number') ? p.dy : -6;
    t.setAttribute('x', P.x + dx);
    t.setAttribute('y', P.y + dy);
    t.setAttribute('font-size','13');
    t.textContent = p.label;
    g.appendChild(t);
  }
  this.gPts.appendChild(g);
}

// ‚¨áÔ∏è remplace le bloc "vecteurs fixes" dans redraw()
// --- Vecteurs fixes : trait fin + label le long du segment, jamais dessus
// --- Vecteurs fixes : trait + label auto-plac√©
// --- Vecteurs fixes : trait + label AU-DESSUS DU MILIEU
// --- Vecteurs fixes : trait + label d√©cal√© perpendiculairement au segment
for (const v of this.vectors){
  const p1 = this.coordToScreen(v.x1, v.y1);
  const p2 = this.coordToScreen(v.x2, v.y2);

  // trait
  const ln = document.createElementNS(this.el.namespaceURI,'line');
  ln.setAttribute('x1', p1.x); ln.setAttribute('y1', p1.y);
  ln.setAttribute('x2', p2.x); ln.setAttribute('y2', p2.y);
  ln.setAttribute('stroke', v.stroke || '#111');
const sw = (typeof v.w === 'number') ? v.w : (v.thick ? 3.2 : 2.2);
ln.setAttribute('stroke-width', sw);
if (v.arrow !== false) {
  ln.setAttribute('marker-end','url(#vecArrow)');
}
  this.gVec.appendChild(ln);

  if (!v.label) continue;

  // g√©om√©trie √©cran
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const L  = Math.hypot(dx, dy) || 1;
  const mx = (p1.x + p2.x) * 0.5;
  const my = (p1.y + p2.y) * 0.5;

  // vecteur normal unitaire (perpendiculaire)
  // n = (-dy, dx)/L ; on choisit le signe pour respecter la r√®gle
  let nx = -dy / L, ny = dx / L;

  // seuils d‚Äôorientation
  const H = Math.abs(dy) <= 0.4 * Math.abs(dx); // ~horizontal
  const V = Math.abs(dx) <= 0.4 * Math.abs(dy); // ~vertical

  // offset en pixels (jamais sur le trait)
  let off = 20;

  if (H){
    // on veut "au-dessus" du segment ‚Üí ny doit √™tre n√©gatif en rep√®re √©cran
    if (ny > 0){ nx = -nx; ny = -ny; }
  } else if (V){
    // pour vertical, on force √† droite du trait (nx > 0). Si pr√®s du bord droit, √† gauche.
    const {w,m} = this.basis();
    const preferRight = (mx < w - m - 30);
    if (preferRight && nx < 0) { nx = -nx; ny = -ny; }
    if (!preferRight && nx > 0){ nx = -nx; ny = -ny; }
  } else {
    // oblique : "au-dessus" (ny<0)
    if (ny > 0){ nx = -nx; ny = -ny; }
  }

  let lx = mx + off * nx;
  let ly = my + off * ny;

  // si on touche le bord haut/bas, on inverse le c√¥t√© (fallback)
  const {w,h,m} = this.basis();
  const clamp = (x,a,b)=>Math.min(Math.max(x,a),b);
  if (ly < m + 6 || ly > h - m - 20){
    lx = mx - off * nx;
    ly = my - off * ny;
  }
  // clamp doux dans la vue
  lx = clamp(lx, m + 6, w - m - 6);
  ly = clamp(ly, m + 6, h - m - 6);

  // label LaTeX, sans fond
  this.gVec.appendChild(this._latexFO(`\\(\\vec ${v.label}\\)`, lx, ly, v.stroke || '#111'));
}





  // re-typeset pour les foreignObjects
  MJ(this.el.parentNode||document.body);
}


  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){ g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','13'); t.setAttribute('font-weight','700'); t.setAttribute('fill',color); t.textContent=label;
      g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g);
    }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }

placeUserVector(label,x1,y1,x2,y2,color='#0a84ff'){
  let g=this.gUserVec.querySelector(`g[data-vlabel="${label||''}"]`);
  if(!g){
    g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.vlabel = label||'';
    const ln=document.createElementNS(this.el.namespaceURI,'line');
    ln.setAttribute('stroke',color); ln.setAttribute('stroke-width','2.2');
ln.setAttribute('marker-end','url(#vecArrow)');
    g.appendChild(ln);
    // ‚¨áÔ∏è on n'ajoute le FO que si un label est fourni
    if (label){
      const fo=this._latexFO(`\\(\\overrightarrow v_{${label.replace('v','')}}\\)`, 0, 0, color);
      g.appendChild(fo);
    }
    this.gUserVec.appendChild(g);
  }
  const p1=this.coordToScreen(x1,y1), p2=this.coordToScreen(x2,y2);
  const ln=g.querySelector('line'); ln.setAttribute('x1',p1.x); ln.setAttribute('y1',p1.y);
  ln.setAttribute('x2',p2.x); ln.setAttribute('y2',p2.y);
  const fo=g.querySelector('foreignObject');
  if (fo){ fo.setAttribute('x', p2.x+6); fo.setAttribute('y', p2.y-18); }
  const i=this.userVectors.findIndex(vv=>vv.label===(label||'')); 
  const rec={label:label||'',x1,y1,x2,y2}; if(i>=0) this.userVectors[i]=rec; else this.userVectors.push(rec);
  MJ(this.el.parentNode||document.body);
}

}

/* ===== UI helpers ===== */
/* ==== Couleurs & rendu rapide du rep√®re ==== */
const PALETTE = ['#0a84ff','#d32f2f','#2e7d32','#6a1b9a','#f57c00','#00897b','#c62828','#6d4c41','#ad1457','#283593','#0277bd'];
const colorOfIndex = i => PALETTE[i % PALETTE.length];


// mini ‚Äúview‚Äù : on place un rep√®re √† gauche et √† droite l‚Äô√©nonc√© + actions + #res
function renderWithRepereIntoHost(host, R){
  host.innerHTML = `
    <div class="row">
      <div><div id="repere-slot" class="svgbox" style="width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff"></div></div>
      <div>
        <div id="equ"></div>
        <div class="optionline" id="actions" style="margin-top:.5rem"></div>
        <div id="res" class="steps"></div>
      </div>
    </div>`;
  // Repere vient de repere_patch_0813.js (global)
  const rep = new Repere(R || {xmin:-6,xmax:6,ymin:-6,ymax:6});
  document.getElementById('repere-slot').replaceWith(rep.el);
  return { rep, equ: document.getElementById('equ'), actions: document.getElementById('actions'), res: document.getElementById('res') };
}






function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// cellules 3√ó3 √† l'int√©rieur des limites "lim"
function makeCells(lim, rows=3, cols=3){
  const w = (lim.xmax - lim.xmin + 1), h = (lim.ymax - lim.ymin + 1);
  const cw = Math.floor(w / cols), ch = Math.floor(h / rows);
  const cells = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0 = lim.xmin + c*cw, x1 = (c===cols-1) ? lim.xmax : (x0+cw-1);
      const y0 = lim.ymin + r*ch, y1 = (r===rows-1) ? lim.ymax : (y0+ch-1);
      cells.push({xmin:x0, xmax:x1, ymin:y0, ymax:y1});
    }
  }
  return cells;
}
function randIntInCell(cell){ return { x: randInt(cell.xmin, cell.xmax), y: randInt(cell.ymin, cell.ymax) }; }
function fits(lim, x, y){ return x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax; }


// --- Unicit√© de pente : cl√© de colin√©arit√© (ignore l'√©chelle et le signe global)
function slopeKey(dx, dy){
  if (dx === 0) return 'V';     // vertical
  if (dy === 0) return 'H';     // horizontal
  // normalise le signe pour que (dx,dy) et (-dx,-dy) donnent la m√™me cl√©
  if (dx < 0){ dx = -dx; dy = -dy; }
  const g0 = gcd(Math.abs(dx), Math.abs(dy)) || 1;
  const a = dx / g0, b = dy / g0; // a = dx', b = dy' primitifs
  return b + '/' + a;             // on encode la pente (dy/dx) comme "b/a"
}


// --- Unicit√© stricte des coordonn√©es (a;b) pour la partie 3
const abKey = (a,b) => a + ';' + b;


/* ===== Utilitaire PDF : forcer la taille du SVG (300√ó300) ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }



// helpers you may already have:
const isEmptyTxt = id => !($('#'+id)?.value||'').trim();
const isEmptyCol = id => !($('#'+id+'_u')?.value||'').trim() && !($('#'+id+'_v')?.value||'').trim();

function namesArePaired(n1, n2){
  const s = v => String(v||'').toUpperCase().replace(/\s+/g,'');
  const map = { AB:'DC', BA:'CD', BC:'AD', CB:'DA' };
  const a = s(n1), b = s(n2);
  return !!(map[a] && map[a] === b);
}

function setTick(id, kind){ const el = document.getElementById(id); if(el){ el.className='tick '+(kind||''); el.textContent = kind==='ok' ? '‚úì' : kind==='ko' ? '‚úó' : ''; } }

function removeDefaultAnswerRow(){
  const ctrl = HOST.querySelector('.controls'); // le bloc "R√©ponse ‚Ä¶  #fb"
  if (ctrl) ctrl.remove();
}


// supprime un signe d‚Äôen-t√™te (prend aussi le vrai "‚àí" unicode)
function stripLeadSign(s){
  return String(s).replace(/^[\u2212\-+]\s*/,'');
}

// normalise les suites de signes: "+ ‚àí"‚Üí" ‚àí", "‚àí ‚àí"‚Üí" +", "+ +"‚Üí"+", et supprime un "+" initial
function tidySigns(s){
  return String(s)
    .replace(/\+\s*[\u2212\-]\s*/g,' ‚àí ')
    .replace(/[\u2212\-]\s*[\u2212\-]\s*/g,' + ')
    .replace(/\+\s*\+\s*/g,' + ')
    .replace(/^\s*\+\s*/,'');
}


/* ====== G√©n√©rateur d‚Äôexos ====== */
const REGISTRY_MAP = {



e1:{
  name:"Vocabulaire ‚Äî nature, m, b, sens",
  lead:"Pour chaque fonction, pr√©ciser sa nature (non affine, affine, lin√©aire ou constante), les valeurs du coefficient directeur \\(m\\) et de l‚Äôordonn√©e √† l‚Äôorigine \\(b\\) (si possible), et le sens de variation.",

  gen(){
    mountHost();
    removeDefaultAnswerRow();
    setFB(null,'');

    // ====== Helpers g√©n√©raux ======
    const RX_ND=/^\s*(?:nd|n\.?d\.?|non\s*d[√©e]fini|non\s*d[√©e]finie|aucun|‚Äî|-)?\s*$/i;

    function rng(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function pickIntNoZero(a,b){ let n=0; do{ n=rng(a,b); }while(n===0); return n; }

    function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
    function makeFrac(p,q){ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return {p:p/g, q:q/g}; }

    // Fraction non nulle al√©atoire
    function pickFrac(){
      let p=0,q=1; do{ p=rng(-9,9); q=rng(2,6); }while(p===0);
      return makeFrac(p,q);
    }

    // ====== Nettoyage de signes ======
    function stripLeadSign(s){ return String(s).replace(/^[\u2212\-+]\s*/,''); }
    function tidySigns(s){
      return String(s)
        .replace(/\+\s*[\u2212\-]\s*/g,' ‚àí ')
        .replace(/[\u2212\-]\s*[\u2212\-]\s*/g,' + ')
        .replace(/\+\s*\+\s*/g,' + ')
        .replace(/^\s*\+\s*/,'')
        .replace(/\s{2,}/g,' ');
    }

    // ====== Affichage nombres/TeX ======
    const asInt = n => (n<0?`‚àí${-n}`:`${n}`);
    const texFrac = r => (r.q===1?`${r.p}`:`\\dfrac{${r.p}}{${r.q}}`);
    const leadFrac = r => (r.p<0?'-':'') + texFrac({p:Math.abs(r.p),q:r.q});

    // ====== Mon√¥mes sans afficher 1/‚àí1 ======
    function headMonoInt(n, pow){ // d√©but de ligne (pas de signe + initial)
      const neg = n<0, A = Math.abs(n);
      const coef = (A===1 ? '' : String(A)+' ');
      return (neg?'‚àí ':'') + coef + pow;
    }
    function monoInt(n, pow){     // suite de ligne
      const A = Math.abs(n), sign = (n<0?' ‚àí ':' + ');
      const coef = (A===1 ? '' : String(A)+' ');
      return sign + coef + pow;
    }
    function headMonoFrac(fr, pow){
      const r = makeFrac(fr.p, fr.q), neg = r.p<0, A = Math.abs(r.p), is1 = (A===r.q);
      const coef = (is1 ? '' : texFrac({p:A,q:r.q})+' ');
      return (neg?'‚àí ':'') + coef + pow;
    }
    function monoFrac(fr, pow){
      const r = makeFrac(fr.p, fr.q), sign = (r.p<0?' ‚àí ':' + '), A = Math.abs(r.p), is1 = (A===r.q);
      const coef = (is1 ? '' : texFrac({p:A,q:r.q})+' ');
      return sign + coef + pow;
    }

    // ====== Affichages affines ======
    function affineIntStr(m,b){ // m entier ‚â†0 ; b entier ‚â†0
      let s = 'f(x)= ' + headMonoInt(m,'x');
      s += ' ' + (b<0?'‚àí':'+' ) + ' ' + Math.abs(b);
      return tidySigns(s);
    }
    function affineFracStr(mf, bVal){ // m fraction ; bVal entier ou fraction
      let s = 'f(x)= ' + headMonoFrac(mf,'x');
      if (typeof bVal==='number'){
        s += ' ' + (bVal<0?'‚àí':'+' ) + ' ' + Math.abs(bVal);
      }else{
        const rb = makeFrac(bVal.p,bVal.q);
        s += ' ' + (rb.p<0?'‚àí':'+' ) + ' ' + texFrac({p:Math.abs(rb.p),q:rb.q});
      }
      return tidySigns(s);
    }

    // ====== Colonnes tableau (UI) ======
    const sensOpts=["","croissante","d√©croissante","constante","ND"];
    const natureOpts=["","affine","lin√©aire","constante","non affine"];

    // ====== Lignes √† fabriquer ======
    const rows=[]; // chaque row: {kind, latex, mVal, bVal, sens, mText, bText}

    // 1) Affine enti√®re
    (function(){
      const m = pickIntNoZero(-8,8);
      let b=0; do{ b=rng(-9,9); }while(b===0);
      const s = affineIntStr(m,b);
      rows.push({ kind:'affine', latex:'\\('+s+'\\)', mVal:m, bVal:b, sens:(m>0?'croissante':'d√©croissante'), mText:asInt(m), bText:asInt(b) });
    })();

    // 2) Affine avec fraction (m fraction, b entier OU fraction)
    (function(){
      const mf = pickFrac();
      if (Math.random()<0.5){
        let b=0; do{ b=rng(-9,9); }while(b===0);
        const s = affineFracStr(mf,b);
        rows.push({ kind:'affine', latex:'\\('+s+'\\)', mVal:mf.p/mf.q, bVal:b, sens:(mf.p/mf.q>0?'croissante':'d√©croissante'),
                    mText:texFrac(mf), bText:asInt(b) });
      }else{
        const bf = pickFrac();
        const s = affineFracStr(mf,bf);
        rows.push({ kind:'affine', latex:'\\('+s+'\\)', mVal:mf.p/mf.q, bVal:bf.p/bf.q, sens:(mf.p/mf.q>0?'croissante':'d√©croissante'),
                    mText:texFrac(mf), bText:texFrac(bf) });
      }
    })();

    // 3) Lin√©aire (b=0)
    (function(){
      const m = pickIntNoZero(-9,9);
      const s = 'f(x)= ' + headMonoInt(m,'x');
      rows.push({ kind:'lin√©aire', latex:'\\('+tidySigns(s)+'\\)', mVal:m, bVal:0, sens:(m>0?'croissante':'d√©croissante'),
                  mText:asInt(m), bText:'0' });
    })();

    // 4) Constante
    (function(){
      let b=0; do{ b=rng(-9,9); }while(b===0);
      rows.push({ kind:'constante', latex:'\\(f(x)= '+asInt(b)+'\\)', mVal:0, bVal:b, sens:'constante', mText:'0', bText:asInt(b) });
    })();

    // 5) Non affine ‚Äî pool conforme (‚àöx et |x| seulement + autres non affines s√ªrs)
    (function(){
      const cand = [];
      // a x^2 + b x + c
      (function(){
        const a=pickIntNoZero(-6,6), b=pickIntNoZero(-8,8); let c=0; do{ c=rng(-9,9); }while(c===0);
        let s = 'f(x)= ' + headMonoInt(a,'x^{2}') + monoInt(b,'x') + ' ' + (c<0?'‚àí':'+' ) + ' ' + Math.abs(c);
        cand.push('\\('+tidySigns(s)+'\\)');
      })();
      // a|x| + b
      (function(){
        const a=pickIntNoZero(-7,7); let b=0; do{ b=rng(-9,9); }while(b===0);
        let s = 'f(x)= ' + headMonoInt(a,'|x|') + ' ' + (b<0?'‚àí':'+' ) + ' ' + Math.abs(b);
        cand.push('\\('+tidySigns(s)+'\\)');
      })();
      // a‚àöx + b
      (function(){
        const a=pickIntNoZero(-6,6); let b=0; do{ b=rng(-9,9); }while(b===0);
        let s = 'f(x)= ' + headMonoInt(a,'\\sqrt{x}') + ' ' + (b<0?'‚àí':'+' ) + ' ' + Math.abs(b);
        cand.push('\\('+tidySigns(s)+'\\)');
      })();
      // (a x + b) / (c x + d) (non proportionnels)
      (function(){
        const a=pickIntNoZero(-6,6), c=pickIntNoZero(-6,6);
        let b=0; do{ b=rng(-8,8); }while(b===0);
        let d=0; do{ d=rng(-8,8); }while(d===0 || a*d===b*c);
        const top = headMonoInt(a,'x') + ' ' + (b<0?'‚àí':'+' ) + ' ' + Math.abs(b);
        const bot = headMonoInt(c,'x') + ' ' + (d<0?'‚àí':'+' ) + ' ' + Math.abs(d);
        let s = 'f(x)= \\dfrac{'+top+'}{'+bot+'}';
        cand.push('\\('+tidySigns(s)+'\\)');
      })();
      // a x^3 + b x
      (function(){
        const a=pickIntNoZero(-4,4), b=pickIntNoZero(-8,8);
        let s = 'f(x)= ' + headMonoInt(a,'x^{3}') + monoInt(b,'x');
        cand.push('\\('+tidySigns(s)+'\\)');
      })();
      // a/x + b x
      (function(){
        const a=pickIntNoZero(-8,8), b=pickIntNoZero(-6,6);
        let s = 'f(x)=\\dfrac{'+asInt(a)+'}{x}' + monoInt(b,'');
        cand.push('\\('+tidySigns(s)+'\\)');
      })();

      const k = rng(0,cand.length-1);
      rows.push({ kind:'non affine', latex:cand[k], mVal:null, bVal:null, sens:'ND',
                  mText:'ND', bText:'ND' });
    })();

    // 6) Affine √©crite f(x)=p+mx (avec/ sans fraction)
    (function(){
      const useFrac = Math.random()<0.5;

      if(useFrac){
        const mf = pickFrac();
        if(Math.random()<0.5){
          const pf = pickFrac();
          let s = 'f(x)= ' + leadFrac(pf) + ' ' + (mf.p<0?'‚àí':'+' ) + ' ' + stripLeadSign(headMonoFrac(mf,'x'));
          s = tidySigns(s);
          rows.push({ kind:'affine', latex:'\\('+s+'\\)', mVal:mf.p/mf.q, bVal:pf.p/pf.q, sens:(mf.p/mf.q>0?'croissante':'d√©croissante'),
                      mText:texFrac(mf), bText:texFrac(pf) });
        }else{
          let p=0; do{ p=rng(-9,9); }while(p===0);
          let s = 'f(x)= '+asInt(p)+' ' + (mf.p<0?'‚àí':'+' ) + ' ' + stripLeadSign(headMonoFrac(mf,'x'));
          s = tidySigns(s);
          rows.push({ kind:'affine', latex:'\\('+s+'\\)', mVal:mf.p/mf.q, bVal:p, sens:(mf.p/mf.q>0?'croissante':'d√©croissante'),
                      mText:texFrac(mf), bText:asInt(p) });
        }
      }else{
        const m = pickIntNoZero(-8,8);
        let p=0; do{ p=rng(-9,9); }while(p===0);
        let s = 'f(x)= '+asInt(p)+' ' + (m<0?'‚àí':'+' ) + ' ' + stripLeadSign(headMonoInt(m,'x'));
        s = tidySigns(s);
        rows.push({ kind:'affine', latex:'\\('+s+'\\)', mVal:m, bVal:p, sens:(m>0?'croissante':'d√©croissante'),
                    mText:asInt(m), bText:asInt(p) });
      }
    })();

    // m√©lange (Fisher‚ÄìYates)
    for(let i=rows.length-1;i>0;i--){ const j=rng(0,i); const t=rows[i]; rows[i]=rows[j]; rows[j]=t; }

    // ====== Rendu tableau (sans .join) ======
    function buildOptions(arr){
      let s=''; for(let i=0;i<arr.length;i++){ const v=arr[i]||''; s += '<option value="'+v+'">'+(v||'‚Äî')+'</option>'; }
      return s;
    }

    let html = '<p>Pour chaque fonction , pr√©ciser sa nature (non affine, affine, lin√©aire ou constante), les valeurs du coefficient directeur \\(m\\) et de l‚Äôordonn√©e √† l‚Äôorigine \\(p\\) (si possible), et le sens de variation (selon vos connaissances).</p>';
	html += '<p>Si non affine : √©crire ND pour \\(m, p\\) et sens</p>.';
	html += '<table class="table-black">';
html += '<thead><tr>';
html += '<th>fonction</th>';
html += '<th>nature</th>';
html += '<th>coefficient directeur</th>';
html += '<th>ordonn√©e √† l‚Äôorigine</th>';
html += '<th>sens de variation</th>';
html += '</tr></thead><tbody>';

for(let i=0;i<rows.length;i++){
  const id='v'+i;
  html += '<tr>';

  html += '<td>'+rows[i].latex+'</td>';

  html += '<td><select id="'+id+'_nat">'+buildOptions(natureOpts)+'</select> '+
          '<span class="tick" id="tk_'+id+'_nat"></span></td>';

  html += '<td><input id="'+id+'_m" type="text" inputmode="text" style="width:90px" placeholder=""> '+
          '<span class="tick" id="tk_'+id+'_m"></span></td>';

  html += '<td><input id="'+id+'_b" type="text" inputmode="text" style="width:90px" placeholder=""> '+
          '<span class="tick" id="tk_'+id+'_b"></span></td>';

  html += '<td><select id="'+id+'_sens">'+buildOptions(sensOpts)+'</select> '+
          '<span class="tick" id="tk_'+id+'_sens"></span></td>';

  html += '</tr>';
}
html += '</tbody></table>';

    setEqu(html); retypeset(HOST);

    // √©tat pour v√©rification/solution
    this.state = { rows, RX_ND };
  },

  verify(){
  const st = this.state; if(!st) return false;
  const rows = st.rows, RX_ND = st.RX_ND;

  const isBlank = v => String(v||'').trim()==='';
  const normStr = s => String(s||'').toLowerCase().trim();

  // renvoie 'ok' | 'ko' | 'neutral'
  function numEq(exp, got){
    if (isBlank(got)) return 'neutral';
    if (exp === null){                // attendu : ND
      return RX_ND.test(got) ? 'ok' : 'ko';
    }
    const g = normalizeMinus(String(got).trim());
    if (RX_ND.test(g)) return 'ko';   // ‚ÄúND‚Äù alors que d√©fini
    const v = parseNumber(g);
    return (isFinite(v) && Math.abs(v-exp)<1e-9) ? 'ok' : 'ko';
  }

  let ok = 0, tot = 0;

  for(let i=0;i<rows.length;i++){
    const id = 'v'+i, r = rows[i];

    // nature (select)
    let stNat = 'neutral';
    const nat = normStr(document.getElementById(id+'_nat').value);
    if (!isBlank(nat)){
      const natExp = (r.kind==='affine' ? 'affine' : r.kind);
      stNat = (nat===natExp) ? 'ok' : 'ko';
    }
    setTick('tk_'+id+'_nat', stNat==='ok'?'ok':stNat==='ko'?'ko':'');
    if (stNat!=='neutral'){ tot++; if(stNat==='ok') ok++; }

    // m (input texte)
    const stM = numEq(r.mVal, document.getElementById(id+'_m').value);
    setTick('tk_'+id+'_m', stM==='ok'?'ok':stM==='ko'?'ko':'');
    if (stM!=='neutral'){ tot++; if(stM==='ok') ok++; }

    // b (input texte)
    const stB = numEq(r.bVal, document.getElementById(id+'_b').value);
    setTick('tk_'+id+'_b', stB==='ok'?'ok':stB==='ko'?'ko':'');
    if (stB!=='neutral'){ tot++; if(stB==='ok') ok++; }

    // sens (select)
    let stS = 'neutral';
    const sSel = normStr(document.getElementById(id+'_sens').value);
    if (!isBlank(sSel)){
      if (r.sens === 'ND'){
        stS = (sSel==='nd') ? 'ok' : 'ko';
      }else{
        stS = (sSel===r.sens) ? 'ok' : 'ko';
      }
    }
    setTick('tk_'+id+'_sens', stS==='ok'?'ok':stS==='ko'?'ko':'');
    if (stS!=='neutral'){ tot++; if(stS==='ok') ok++; }
  }

  // feedback : neutre si rien n‚Äôa √©t√© rempli
  if (tot===0){ setFB(null,''); return false; }
  const all = (ok===tot);
  setFB(all, `${ok} / ${tot}`);
  return all;
},


  solution(){
  const rows = this.state?.rows || [];

  let html = '<div class="sec"><div class="title">Correction</div>';
  html += '<table class="table-black">';
  html += '<thead><tr>';
  html += '<th>fonction</th>';
  html += '<th>nature</th>';
  html += '<th>\\(m\\)</th>';
  html += '<th>\\(p\\)</th>';
  html += '<th>sens de variation</th>';
  html += '</tr></thead><tbody>';

  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const nat = (r.kind==='affine' ? 'affine' : r.kind);
    const sensTxt = (r.sens || 'ND');   // assure l‚Äôaffichage m√™me si r.sens est falsy

    html += '<tr>';
    html += '<td>'+ r.latex +'</td>';
    html += '<td>'+ nat +'</td>';
    html += '<td>\\('+ r.mText +'\\)</td>';
    html += '<td>\\('+ r.bText +'\\)</td>';
    html += '<td>'+ sensTxt +'</td>';
    html += '</tr>';
  }

  html += '</tbody></table>';

  // petit rappel de r√®gle en dessous
  html += '<div class="hint" style="margin-top:.35rem">';
  html += 'Rappel : pour une fonction affine \\(f(x)=mx+p\\), si \\(m&gt;0\\) la fonction est croissante, ';
  html += 'si \\(m&lt;0\\) elle est d√©croissante, si \\(m=0\\) elle est constante. <br>Pour une fonction non affine : ND.';
  html += '</div>';

  html += '</div>';

  setStepsHTML(html);
  retypeset(HOST);
}

},


ex2 :{
name: "Mod√©lisation",
  lead: "Compl√©ter le tableau, mod√©liser chaque option par une fonction, puis conclure sur les co√ªts et le budget.",

  gen(){
    mountHost(); removeDefaultAnswerRow(); setFB(null,'');

    // ---- utils ----
    const euro = x => (Math.round(x*100)/100)
      .toLocaleString('fr-FR',{minimumFractionDigits:(x%1?2:0), maximumFractionDigits:2})+' ‚Ç¨';
    const parseNum = s => {
      s = String(s||'').replace(',','.').replace(/\s+/g,'').replace(/[‚Ç¨]/g,'');
      if (/^\d+\/\d+$/.test(s)){ const [p,q]=s.split('/').map(Number); return p/q; }
      return Number(s);
    };
    const isBlank = s => String(s||'').trim()==='';
    const rnd = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

// "de" vs "d‚Äô" (h muet inclus)
function deOf(word){
  const w = String(word||'').trim();
  const startsWithVowel = /^[aeiouyh√¢√†√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º≈ì]/i.test(w);
  return startsWithVowel ? `d‚Äô${w}` : `de ${w}`;
}


    // ---- BANQUE : chaque entr√©e pr√©cise le contexte + inversion possible des natures ----
    // Chaque option est donn√©e sous (m, b0) avec f(x) = m x + b0
    // nat: "lin√©aire" si b0=0, sinon "affine"
    const BANK = [
      { // 1 DVD (Option1 lin√©aire, Option2 affine)
        intro: "Une m√©diath√®que propose deux formules de location de DVD sur l‚Äôann√©e.",
        thing: "DVD", thingPlural: "DVD", verbe: "lou√©s",
        Xs:[0,2,6], Nq:20, BUD:70,
        opt1:{label:"Option 1", m:3.5, b0:0,  desc:"chaque DVD est lou√© 3,50 ‚Ç¨"},
        opt2:{label:"Option 2", m:2,   b0:12, desc:"abonnement annuel de 12 ‚Ç¨, puis 2 ‚Ç¨ par DVD lou√©"}
      },
      { // 2 Salle de sport (1 lin√©aire, 2 affine)
        intro:"Un club de sport offre deux possibilit√©s pour s‚Äôentra√Æner selon la fr√©quence des s√©ances.",
        thing:"s√©ance", thingPlural:"s√©ances", verbe:"suivies",
        Xs:[0,5,10], Nq:20, BUD:160,
        opt1:{label:"Option 1", m:8,  b0:0,  desc:"s√©ance √† 8 ‚Ç¨"},
        opt2:{label:"Option 2", m:4,  b0:60, desc:"abonnement annuel de 60 ‚Ç¨, puis 4 ‚Ç¨ par s√©ance"}
      },
      { // 3 Forfait mobile (2 affine, 1 lin√©aire ‚Äî invers√©)
        intro:"Un op√©rateur t√©l√©phonique propose deux offres selon le temps d‚Äôappel r√©alis√© chaque mois.",
        thing:"minute", thingPlural:"minutes", verbe:"consomm√©es",
        Xs:[0,20,50], Nq:120, BUD:40,
        opt1:{label:"Option 1", m:0.10, b0:10, desc:"abonnement mensuel de 10 ‚Ç¨, puis 0,10 ‚Ç¨ par minute"},
        opt2:{label:"Option 2", m:0.30, b0:0,  desc:"paiement √† 0,30 ‚Ç¨ la minute"}
      },
      { // 4 V√©lo √©lectrique
        intro:"Une agence de location de v√©los √©lectriques propose deux formules de tarification journali√®re.",
        thing:"jour", thingPlural:"jours", verbe:"lou√©s",
        Xs:[0,3,7], Nq:10, BUD:120,
        opt1:{label:"Option 1", m:10, b0:20, desc:"carte √† 20 ‚Ç¨, puis 10 ‚Ç¨ par jour lou√©"},
        opt2:{label:"Option 2", m:15, b0:0,  desc:"location √† 15 ‚Ç¨ par jour"}
      },
      { // 5 Piscine
        intro:"La piscine municipale vend ses entr√©es selon deux modes de paiement.",
        thing:"entr√©e", thingPlural:"entr√©es", verbe:"effectu√©es",
        Xs:[0,5,12], Nq:20, BUD:80,
        opt1:{label:"Option 1", m:4,   b0:0,  desc:"entr√©e √† 4 ‚Ç¨"},
        opt2:{label:"Option 2", m:2.5, b0:40, desc:"carte annuelle de 40 ‚Ç¨, puis 2,50 ‚Ç¨ par entr√©e"}
      },
      { // 6 Escalade
        intro:"Une salle d‚Äôescalade propose soit un tarif √† la s√©ance, soit un abonnement annuel.",
        thing:"s√©ance", thingPlural:"s√©ances", verbe:"r√©alis√©es",
        Xs:[0,5,15], Nq:12, BUD:150,
        opt1:{label:"Option 1", m:12, b0:0,   desc:"s√©ance √† 12 ‚Ç¨"},
        opt2:{label:"Option 2", m:6,  b0:100, desc:"abonnement de 100 ‚Ç¨, puis 6 ‚Ç¨ par s√©ance"}
      },
      { // 7 Stationnement
        intro:"Un parking propose un paiement √† l‚Äôheure ou un abonnement mensuel avec tarif r√©duit.",
        thing:"heure", thingPlural:"heures", verbe:"pay√©es",
        Xs:[0,10,30], Nq:50, BUD:80,
        opt1:{label:"Option 1", m:2,  b0:0,  desc:"2 ‚Ç¨ par heure"},
        opt2:{label:"Option 2", m:1,  b0:40, desc:"abonnement mensuel de 40 ‚Ç¨, puis 1 ‚Ç¨ par heure"}
      },
      { // 8 Streaming
        intro:"Une plateforme de streaming offre un paiement √† la s√©ance ou un abonnement mensuel.",
        thing:"film", thingPlural:"films", verbe:"vus",
        Xs:[0,4,10], Nq:15, BUD:40,
        opt1:{label:"Option 1", m:3,   b0:0,  desc:"location √† 3 ‚Ç¨ le film"},
        opt2:{label:"Option 2", m:1.5, b0:12, desc:"abonnement mensuel de 12 ‚Ç¨, puis 1,50 ‚Ç¨ par film"}
      },
      { // 9 Photocopies
        intro:"Un service d‚Äôimpression facture au nombre de pages avec ou sans carte d‚Äôabonnement.",
        thing:"page", thingPlural:"pages", verbe:"imprim√©es",
        Xs:[0,25,100], Nq:200, BUD:25,
        opt1:{label:"Option 1", m:0.20, b0:0, desc:"0,20 ‚Ç¨ par page"},
        opt2:{label:"Option 2", m:0.10, b0:5, desc:"carte de membre √† 5 ‚Ç¨, puis 0,10 ‚Ç¨ par page"}
      },
      { // 10 Cours particuliers
        intro:"Un professeur propose deux formules pour ses cours particuliers.",
        thing:"cours", thingPlural:"cours", verbe:"pris",
        Xs:[0,2,8], Nq:10, BUD:250,
        opt1:{label:"Option 1", m:25, b0:0,  desc:"cours √† 25 ‚Ç¨"},
        opt2:{label:"Option 2", m:20, b0:50, desc:"adh√©sion de 50 ‚Ç¨, puis 20 ‚Ç¨ par cours"}
      },
      { // 11 Livraison repas
        intro:"Une application de livraison propose un abonnement pour r√©duire les frais de livraison.",
        thing:"livraison", thingPlural:"livraisons", verbe:"effectu√©es",
        Xs:[0,5,20], Nq:25, BUD:60,
        opt1:{label:"Option 1", m:2.5, b0:0,  desc:"2,50 ‚Ç¨ de frais par commande"},
        opt2:{label:"Option 2", m:1,   b0:30, desc:"abonnement de 30 ‚Ç¨, puis 1 ‚Ç¨ par livraison"}
      },
      { // 12 Ski
        intro:"Une boutique de sport loue du mat√©riel de ski √† la journ√©e ou avec forfait semaine.",
        thing:"jour", thingPlural:"jours", verbe:"lou√©s",
        Xs:[0,2,6], Nq:7, BUD:180,
        opt1:{label:"Option 1", m:25, b0:0,  desc:"25 ‚Ç¨ par jour"},
        opt2:{label:"Option 2", m:20, b0:40, desc:"forfait de 40 ‚Ç¨, puis 20 ‚Ç¨ par jour"}
      },
      { // 13 Biblioth√®que
        intro:"Une biblioth√®que municipale permet d‚Äôemprunter des livres √† l‚Äôunit√© ou avec abonnement annuel.",
        thing:"livre", thingPlural:"livres", verbe:"emprunt√©s",
        Xs:[0,4,12], Nq:20, BUD:20,
        opt1:{label:"Option 1", m:1.5, b0:0,  desc:"1,50 ‚Ç¨ par emprunt"},
        opt2:{label:"Option 2", m:0.5, b0:10, desc:"abonnement annuel de 10 ‚Ç¨, puis 0,50 ‚Ç¨ par livre"}
      },
      { // 14 Guitare
        intro:"Une √©cole de musique propose deux formules pour suivre des cours de guitare.",
        thing:"cours", thingPlural:"cours", verbe:"pris",
        Xs:[0,3,8], Nq:12, BUD:160,
        opt1:{label:"Option 1", m:18, b0:0,  desc:"18 ‚Ç¨ le cours"},
        opt2:{label:"Option 2", m:12, b0:50, desc:"adh√©sion de 50 ‚Ç¨, puis 12 ‚Ç¨ par cours"}
      },
      { // 15 Cin√©ma
        intro:"Un cin√©ma propose la carte ¬´ Cin√©Pass ¬ª en alternative √† la place √† l‚Äôunit√©.",
        thing:"place", thingPlural:"places", verbe:"achet√©es",
        Xs:[0,2,6], Nq:10, BUD:60,
        opt1:{label:"Option 1", m:9,  b0:0,  desc:"9 ‚Ç¨ la place"},
        opt2:{label:"Option 2", m:6,  b0:20, desc:"carte √† 20 ‚Ç¨, puis 6 ‚Ç¨ la place"}
      },
      { // 16 Bus
        intro:"La compagnie de bus locale vend des tickets √† l‚Äôunit√© ou un abonnement mensuel.",
        thing:"trajet", thingPlural:"trajets", verbe:"effectu√©s",
        Xs:[0,10,40], Nq:50, BUD:70,
        opt1:{label:"Option 1", m:2,  b0:0,  desc:"2 ‚Ç¨ le trajet"},
        opt2:{label:"Option 2", m:1,  b0:30, desc:"abonnement de 30 ‚Ç¨, puis 1 ‚Ç¨ par trajet"}
      },
      { // 17 Laverie
        intro:"Une laverie automatique met en place une carte fid√©lit√© pour r√©duire le co√ªt des lavages.",
        thing:"lavage", thingPlural:"lavages", verbe:"effectu√©s",
        Xs:[0,2,8], Nq:12, BUD:40,
        opt1:{label:"Option 1", m:5,  b0:0,  desc:"5 ‚Ç¨ par lavage"},
        opt2:{label:"Option 2", m:3,  b0:10, desc:"carte √† 10 ‚Ç¨, puis 3 ‚Ç¨ par lavage"}
      },
      { // 18 Natation
        intro:"Le club de natation municipal propose une formule √† la s√©ance et une formule annuelle.",
        thing:"s√©ance", thingPlural:"s√©ances", verbe:"suivies",
        Xs:[0,3,10], Nq:15, BUD:120,
        opt1:{label:"Option 1", m:10, b0:0,  desc:"10 ‚Ç¨ la s√©ance"},
        opt2:{label:"Option 2", m:7,  b0:40, desc:"forfait de 40 ‚Ç¨, puis 7 ‚Ç¨ par s√©ance"}
      },
      { // 19 Internet (invers√© : 1 affine, 2 lin√©aire)
        intro:"Un fournisseur d‚Äôacc√®s √† Internet propose un abonnement avec engagement ou un paiement sans engagement.",
        thing:"mois", thingPlural:"mois", verbe:"pay√©s",
        Xs:[0,1,6], Nq:12, BUD:350,
        opt1:{label:"Option 1", m:25, b0:50, desc:"frais d‚Äôouverture de 50 ‚Ç¨, puis 25 ‚Ç¨ par mois"},
        opt2:{label:"Option 2", m:30, b0:0,  desc:"30 ‚Ç¨ par mois, sans engagement"}
      },
      { // 20 Train (texte sans abr√©v.)
        intro:"Une compagnie ferroviaire propose une carte de r√©duction pour les voyageurs fr√©quents.",
        thing:"kilom√®tre", thingPlural:"kilom√®tres", verbe:"parcourus",
        Xs:[0,100,300], Nq:600, BUD:200,
        opt1:{label:"Option 1", m:0.25, b0:0,  desc:"0,25 ‚Ç¨ par kilom√®tre parcouru"},
        opt2:{label:"Option 2", m:0.18, b0:50, desc:"carte √† 50 ‚Ç¨, puis 0,18 ‚Ç¨ par kilom√®tre parcouru"}
      }
    ];

// juste apr√®s const BANK = [ ... ] ajoute ce bloc pour enrichir chaque entr√©e :
BANK.forEach(ctx => {
  const t = ctx.thingPlural;
  const b = ctx.BUD;
  const o1 = "option 1", o2 = "option 2";

  switch (ctx.intro) {

    case "Une m√©diath√®que propose deux formules de location de DVD sur l‚Äôann√©e.":
      ctx.q5 = {
        q: `Avec un budget de ${b} ‚Ç¨, quelle formule permet de louer le plus de DVD ?`,
        r: (best, equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de louer le m√™me nombre de DVD.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de louer le plus de DVD.`
      }; break;

    case "Un club de sport offre deux possibilit√©s pour s‚Äôentra√Æner selon la fr√©quence des s√©ances.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de suivre le plus de s√©ances ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de suivre le m√™me nombre de s√©ances.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de suivre le plus de s√©ances.`
      }; break;

    case "Un op√©rateur t√©l√©phonique propose deux offres selon le temps d‚Äôappel r√©alis√© chaque mois.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle offre permet de t√©l√©phoner le plus longtemps ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux offres permettent de t√©l√©phoner aussi longtemps.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de t√©l√©phoner plus longtemps.`
      }; break;

    case "Une agence de location de v√©los √©lectriques propose deux formules de tarification journali√®re.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de louer un v√©lo le plus de jours ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de louer un v√©lo le m√™me nombre de jours.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de louer un v√©lo plus longtemps.`
      }; break;

    case "La piscine municipale vend ses entr√©es selon deux modes de paiement.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet d‚Äôaller le plus souvent √† la piscine ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent d‚Äôaller aussi souvent √† la piscine.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet d‚Äôaller plus souvent √† la piscine.`
      }; break;

    case "Une salle d‚Äôescalade propose soit un tarif √† la s√©ance, soit un abonnement annuel.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de grimper le plus souvent ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de grimper aussi souvent.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de grimper plus souvent.`
      }; break;

    case "Un parking propose un paiement √† l‚Äôheure ou un abonnement mensuel avec tarif r√©duit.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de se garer le plus longtemps ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de se garer aussi longtemps.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de se garer plus longtemps.`
      }; break;

    case "Une plateforme de streaming offre un paiement √† la s√©ance ou un abonnement mensuel.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de regarder le plus de films ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de regarder autant de films.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de regarder plus de films.`
      }; break;

    case "Un service d‚Äôimpression facture au nombre de pages avec ou sans carte d‚Äôabonnement.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet d‚Äôimprimer le plus de pages ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent d‚Äôimprimer le m√™me nombre de pages.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet d‚Äôimprimer plus de pages.`
      }; break;

    case "Un professeur propose deux formules pour ses cours particuliers.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de prendre le plus de cours ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de suivre le m√™me nombre de cours.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de suivre plus de cours.`
      }; break;

    case "Une application de livraison propose un abonnement pour r√©duire les frais de livraison.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de faire le plus de livraisons ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de faire autant de livraisons.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de faire plus de livraisons.`
      }; break;

    case "Une boutique de sport loue du mat√©riel de ski √† la journ√©e ou avec forfait semaine.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de louer le mat√©riel le plus de jours ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de louer le mat√©riel le m√™me nombre de jours.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de louer le mat√©riel plus longtemps.`
      }; break;

    case "Une biblioth√®que municipale permet d‚Äôemprunter des livres √† l‚Äôunit√© ou avec abonnement annuel.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet d‚Äôemprunter le plus de livres ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent d‚Äôemprunter le m√™me nombre de livres.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet d‚Äôemprunter plus de livres.`
      }; break;

    case "Une √©cole de musique propose deux formules pour suivre des cours de guitare.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de suivre le plus de cours de guitare ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de suivre le m√™me nombre de cours de guitare.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de suivre plus de cours de guitare.`
      }; break;

    case "Un cin√©ma propose la carte ¬´ Cin√©Pass ¬ª en alternative √† la place √† l‚Äôunit√©.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet d‚Äôaller le plus souvent au cin√©ma ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent d‚Äôaller aussi souvent au cin√©ma.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet d‚Äôaller plus souvent au cin√©ma.`
      }; break;

    case "La compagnie de bus locale vend des tickets √† l‚Äôunit√© ou un abonnement mensuel.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet d‚Äôeffectuer le plus de trajets ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent d‚Äôeffectuer autant de trajets.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet d‚Äôeffectuer plus de trajets.`
      }; break;

    case "Une laverie automatique met en place une carte fid√©lit√© pour r√©duire le co√ªt des lavages.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de faire le plus de lavages ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de faire autant de lavages.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de faire plus de lavages.`
      }; break;

    case "Le club de natation municipal propose une formule √† la s√©ance et une formule annuelle.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de suivre le plus de s√©ances ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de suivre autant de s√©ances.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de suivre plus de s√©ances.`
      }; break;

    case "Un fournisseur d‚Äôacc√®s √† Internet propose un abonnement avec engagement ou un paiement sans engagement.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet d‚Äôavoir Internet le plus longtemps ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de b√©n√©ficier d‚ÄôInternet aussi longtemps.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de b√©n√©ficier d‚ÄôInternet plus longtemps.`
      }; break;

    case "Une compagnie ferroviaire propose une carte de r√©duction pour les voyageurs fr√©quents.":
      ctx.q5 = {
        q:`Avec un budget de ${b} ‚Ç¨, quelle formule permet de parcourir la plus grande distance ?`,
        r:(best,equal)=> equal ?
          `Avec un budget de ${b} ‚Ç¨, les deux formules permettent de parcourir la m√™me distance.` :
          `Avec un budget de ${b} ‚Ç¨, l'${best} permet de parcourir une plus grande distance.`
      }; break;
  }
});
// Apr√®s la d√©claration de BANK, ajoute :
BANK.forEach(ctx => {
  // phrase MAX (utilis√©e dans les colonnes de la Q4)
  // n => renvoie la phrase correcte pour ce th√®me
  switch (ctx.intro) {
    case "Une m√©diath√®que propose deux formules de location de DVD sur l‚Äôann√©e.":
      ctx.maxLine = n => `On peut louer au plus ${n} DVD.`; break;

    case "Un club de sport offre deux possibilit√©s pour s‚Äôentra√Æner selon la fr√©quence des s√©ances.":
      ctx.maxLine = n => `On peut suivre au plus ${n} s√©ances.`; break;

    case "Un op√©rateur t√©l√©phonique propose deux offres selon le temps d‚Äôappel r√©alis√© chaque mois.":
      ctx.maxLine = n => `On peut t√©l√©phoner au plus ${n} minutes.`; break;

    case "Une agence de location de v√©los √©lectriques propose deux formules de tarification journali√®re.":
      ctx.maxLine = n => `On peut louer un v√©lo au plus ${n} jours.`; break;

    case "La piscine municipale vend ses entr√©es selon deux modes de paiement.":
      ctx.maxLine = n => `On peut aller √† la piscine au plus ${n} fois.`; break;

    case "Une salle d‚Äôescalade propose soit un tarif √† la s√©ance, soit un abonnement annuel.":
      ctx.maxLine = n => `On peut grimper au plus ${n} s√©ances.`; break;

    case "Un parking propose un paiement √† l‚Äôheure ou un abonnement mensuel avec tarif r√©duit.":
      ctx.maxLine = n => `On peut se garer au plus ${n} heures.`; break;

    case "Une plateforme de streaming offre un paiement √† la s√©ance ou un abonnement mensuel.":
      ctx.maxLine = n => `On peut regarder au plus ${n} films.`; break;

    case "Un service d‚Äôimpression facture au nombre de pages avec ou sans carte d‚Äôabonnement.":
      ctx.maxLine = n => `On peut imprimer au plus ${n} pages.`; break;

    case "Un professeur propose deux formules pour ses cours particuliers.":
      ctx.maxLine = n => `On peut prendre au plus ${n} cours.`; break;

    case "Une application de livraison propose un abonnement pour r√©duire les frais de livraison.":
      ctx.maxLine = n => `On peut faire au plus ${n} livraisons.`; break;

    case "Une boutique de sport loue du mat√©riel de ski √† la journ√©e ou avec forfait semaine.":
      ctx.maxLine = n => `On peut louer le mat√©riel au plus ${n} jours.`; break;

    case "Une biblioth√®que municipale permet d‚Äôemprunter des livres √† l‚Äôunit√© ou avec abonnement annuel.":
      ctx.maxLine = n => `On peut emprunter au plus ${n} livres.`; break;

    case "Une √©cole de musique propose deux formules pour suivre des cours de guitare.":
      ctx.maxLine = n => `On peut suivre au plus ${n} cours de guitare.`; break;

    case "Un cin√©ma propose la carte ¬´ Cin√©Pass ¬ª en alternative √† la place √† l‚Äôunit√©.":
      ctx.maxLine = n => `On peut acheter au plus ${n} places de cin√©ma.`; break;

    case "La compagnie de bus locale vend des tickets √† l‚Äôunit√© ou un abonnement mensuel.":
      ctx.maxLine = n => `On peut effectuer au plus ${n} trajets.`; break;

    case "Une laverie automatique met en place une carte fid√©lit√© pour r√©duire le co√ªt des lavages.":
      ctx.maxLine = n => `On peut faire au plus ${n} lavages.`; break;

    case "Le club de natation municipal propose une formule √† la s√©ance et une formule annuelle.":
      ctx.maxLine = n => `On peut suivre au plus ${n} s√©ances de natation.`; break;

    case "Un fournisseur d‚Äôacc√®s √† Internet propose un abonnement avec engagement ou un paiement sans engagement.":
      ctx.maxLine = n => `On peut b√©n√©ficier d‚ÄôInternet au plus ${n} mois.`; break;

    case "Une compagnie ferroviaire propose une carte de r√©duction pour les voyageurs fr√©quents.":
      ctx.maxLine = n => `On peut parcourir au plus ${n} kilom√®tres.`; break;
  }
});


    const ctx = BANK[rnd(0,BANK.length-1)];

    // mod√®les (fonctionnels)
    const f1 = x => ctx.opt1.m*x + ctx.opt1.b0;
    const f2 = x => ctx.opt2.m*x + ctx.opt2.b0;

    const T = { // valeurs du tableau
      f0: f1(ctx.Xs[0]), f1: f1(ctx.Xs[1]), f2: f1(ctx.Xs[2]),
      g0: f2(ctx.Xs[0]), g1: f2(ctx.Xs[1]), g2: f2(ctx.Xs[2])
    };

    // natures (affiche/justifie dans la correction)
    const nat1 = (ctx.opt1.b0===0 ? 'lin√©aire' : 'affine');
    const nat2 = (ctx.opt2.b0===0 ? 'lin√©aire' : 'affine');

    // budget
    const max1 = Math.floor( ctx.BUD / ctx.opt1.m );                          // si lin√©aire
    const max2 = (ctx.BUD < ctx.opt2.b0) ? 0 : Math.floor((ctx.BUD-ctx.opt2.b0)/ctx.opt2.m);

    // rendu √©nonc√©
    let html = '';
    html += '<div class="eq">';
    html += `<p><strong>Exercice : Mod√©lisation</strong></p>`;
    html += `<p>${ctx.intro}</p>`;
    html += '<ul style="margin:.2rem 0 .6rem 1.2rem">';
    html += `<li><strong>${ctx.opt1.label}</strong> : ${ctx.opt1.desc}.</li>`;
    html += `<li><strong>${ctx.opt2.label}</strong> : ${ctx.opt2.desc}.</li>`;
    html += '</ul>';
html += `<p>On note \\(x\\) le nombre ${deOf(ctx.thingPlural)} ${ctx.verbe}.</p>`;

    // tableau
    html += '<ol style="margin:.5rem 0 0 1.2rem"><li>Compl√©ter le tableau suivant :</li></ol>';
    html += '<table class="table-black" style="margin:.4rem 0 .8rem 0">';
    html += '<thead><tr>';
    html += `<th>Nombre de ${ctx.thingPlural} ${ctx.verbe}</th>`;
    html += `<th>${ctx.Xs[0]}</th><th>${ctx.Xs[1]}</th><th>${ctx.Xs[2]}</th>`;
    html += '</tr></thead><tbody>';
// ... dans le tableau :
html += `<tr><td>Prix avec ${ctx.opt1.label.toLowerCase()} (en ‚Ç¨)</td>
  <td><input id="t_f_0" style="width:90px"> <span class="tick" id="tk_t_f_0"></span></td>
  <td><input id="t_f_1" style="width:90px"> <span class="tick" id="tk_t_f_1"></span></td>
  <td><input id="t_f_2" style="width:90px"> <span class="tick" id="tk_t_f_2"></span></td></tr>`;

html += `<tr><td>Prix avec ${ctx.opt2.label.toLowerCase()} (en ‚Ç¨)</td>
  <td><input id="t_g_0" style="width:90px"> <span class="tick" id="tk_t_g_0"></span></td>
  <td><input id="t_g_1" style="width:90px"> <span class="tick" id="tk_t_g_1"></span></td>
  <td><input id="t_g_2" style="width:90px"> <span class="tick" id="tk_t_g_2"></span></td></tr>`;

    html += '</tbody></table>';

    // questions
    html += '<ol start="2" style="margin:.5rem 0 0 1.2rem">';
    html += `<li style="margin:.25rem 0">a) D√©terminer la fonction \\(f\\) qui mod√©lise le prix √† payer en euro en fonction de \\(x\\) avec ${ctx.opt1.label.toLowerCase()}. `
          + `\\(f(x)=\\) <input id="f" style="width:160px"> <span class="tick" id="tk_f"></span>`
          + `<br>b) Quelle est la nature de cette fonction ? Justifier la r√©ponse. `
          + `<select id="f_nat"><option value=""></option><option>lin√©aire</option><option>affine</option><option>constante</option><option>non affine</option></select><span class="tick" id="tk_f_nat"></span></li>`;
    html += `<li style="margin:.25rem 0">a) D√©terminer la fonction \\(g\\) qui mod√©lise le prix √† payer en euro en fonction de \\(x\\) avec ${ctx.opt2.label.toLowerCase()}. `
          + `\\(g(x)=\\) <input id="g" style="width:160px"><span class="tick" id="tk_g"></span>`
          + `<br>b) Quelle est la nature de cette fonction ? Justifier la r√©ponse. `
          + `<select id="g_nat"><option value=""></option><option>lin√©aire</option><option>affine</option><option>constante</option><option>non affine</option></select><span class="tick" id="tk_g_nat"></span></li>`;
    html += `<li style="margin:.25rem 0">Combien co√ªte ${ctx.Nq} ${ctx.thingPlural} avec ${ctx.opt2.label.toLowerCase()} ? `
          + `<input id="q_cost" style="width:100px"> ‚Ç¨ <span class="tick" id="tk_q_cost"></span></li>`;
   html += `<li style="margin:.25rem 0">${ctx.q5.q}
  <select id="q_best"><option value=""></option><option>${ctx.opt1.label.toLowerCase()}</option><option>${ctx.opt2.label.toLowerCase()}</option><option>√©galit√©</option></select><span class="tick" id="tk_q_best"></span></li>`;
  html += '</ol></div>';

    setEqu(html); retypeset(HOST);

    this.state = { ctx, T, nat1, nat2, max1, max2 };
  },

verify(){
  const st=this.state; if(!st) return false;

  // ---------- utilitaires ----------
  const isBlank = s => String(s||'').trim()==='';
  const parseNum = s => {
    s = String(s||'').replace(/\u2212/g,'-').replace(',','.');
    if (/^[+-]?\d+\/\d+$/.test(s)){ const [p,q]=s.split('/').map(Number); return p/q; }
    return Number(s);
  };
  function cmpNum(id, exp){
    const v = document.getElementById(id)?.value ?? '';
    if (isBlank(v)) return 'neutral';
    const n = parseNum(String(v).replace(/\s+/g,'').replace(/[‚Ç¨]/g,''));
    return (isFinite(n) && Math.abs(n-exp)<1e-9) ? 'ok' : 'ko';
  }
  function asTick(state){ return state==='ok' ? 'ok' : state==='ko' ? 'ko' : ''; }
  function setTickFromState(id, state){ setTick(id, asTick(state)); }

  // ---------- parse RHS affine tr√®s tol√©rant ----------
  // Accepte: mx+p, p+mx, x*k, k*x, x/2, (2x)/3, etc. (ordre libre)
  function checkAffineRHS(id, expm, expp){
    const raw = (document.getElementById(id)?.value || '');
    if (raw.trim()==='') return 'neutral';

    // normalisation douce
    let s = raw.replace(/\s+/g,'')
               .replace(/,/g,'.')
               .replace(/\u2212/g,'-');

    // s√©curit√© basique (caract√®res autoris√©s)
    if (!/^[0-9xX+\-*/().\/]*$/.test(s)) return 'ko';
    s = s.toLowerCase();

    // supprimer * inutiles visuels "2*x" => "2x"
    s = s.replace(/(\d)\*x/g, '$1x').replace(/x\*(\d)/g, 'x$1');

    // D√©couper en termes sign√©s :  "+..."/"-..."/"..."
    const parts = s.match(/[+\-]?[^+\-]+/g);
    if (!parts) return 'ko';

    let M = 0, P = 0, seenX = false;

    for (let term of parts){
      // constant pur ?
      if (/^[-+]?(?:\d+(?:\.\d+)?|\d+\/\d+)$/.test(term)){
        P += parseNum(term);
        continue;
      }

      // formes avec x : autoriser plusieurs √©critures, mais une SEULE composante lin√©aire au final
      // 1) ¬±x
      if (/^[+-]?x$/.test(term)){
        M += (term[0]==='-' ? -1 : 1);
        seenX = true;
        continue;
      }

      // 2) ¬±x/NUM
      if (/^[+-]?x\/(?:\d+(?:\.\d+)?|\d+\/\d+)$/.test(term)){
        const sign = (term[0]==='-' ? -1 : 1);
        const den  = parseNum(term.slice(term.indexOf('/')+1));
        if (!isFinite(den) || Math.abs(den)<1e-12) return 'ko';
        M += sign * (1/den);
        seenX = true;
        continue;
      }

      // 3) ¬±NUM*x  ou  ¬±(NUM)x  (√©toile √©ventuellement absente car d√©j√† retir√©e au-dessus)
      if (/^[+-]?(?:\d+(?:\.\d+)?|\d+\/\d+)x$/.test(term)){
        const coef = parseNum(term.replace(/x$/,''));
        M += coef;
        seenX = true;
        continue;
      }

      // 4) ¬±NUMx/NUM2   (ex: 2x/3)
      if (/^[+-]?(?:\d+(?:\.\d+)?|\d+\/\d+)x\/(?:\d+(?:\.\d+)?|\d+\/\d+)$/.test(term)){
        const sign = (term[0]==='-' ? -1 : 1);
        const [numPart, denPart] = term.replace(/^[+-]?/,'').split('x/'); // "2" , "3"
        const num = parseNum(numPart), den = parseNum(denPart);
        if (!isFinite(num) || !isFinite(den) || Math.abs(den)<1e-12) return 'ko';
        M += sign * (num/den);
        seenX = true;
        continue;
      }

      // 5) constant + lin√©aire m√©lang√©s sans s√©parateur n'est pas acceptable (ex: "40x" est cas 3)
      //    Si on tombe ici, on tente la forme "p+mx" / "mx+p" compress√©e
      //    On r√©√©crit 'x*NUM' en 'NUMx' plus haut ; essayons de s√©parer par (x) et num√©ro constant
      if (/x/.test(term)){
        // exemples tol√©r√©s: "40+x", "x+40", "x*2+40", "40+x/2" ‚Üí mais ces cas auraient d√ª √™tre scind√©s par parts;
        // si on est l√†, c'est un terme non reconnu (ex: "(x)"), on √©choue proprement.
        return 'ko';
      }

      // sinon c'est un r√©sidu invalide
      return 'ko';
    }

    // On a somme(M x) + somme(constants) ‚Üí comparer
    return (Math.abs(M-expm)<1e-9 && Math.abs(P-expp)<1e-9) ? 'ok' : 'ko';
  }

  // ---------- comptage & ticks ----------
  let ok=0, tot=0;
  const count = s => { if(s!=='neutral'){ tot++; if(s==='ok') ok++; } };

  // 1) Tableau
  let s;
  s = cmpNum('t_f_0', st.T.f0); setTickFromState('tk_t_f_0', s); count(s);
  s = cmpNum('t_f_1', st.T.f1); setTickFromState('tk_t_f_1', s); count(s);
  s = cmpNum('t_f_2', st.T.f2); setTickFromState('tk_t_f_2', s); count(s);
  s = cmpNum('t_g_0', st.T.g0); setTickFromState('tk_t_g_0', s); count(s);
  s = cmpNum('t_g_1', st.T.g1); setTickFromState('tk_t_g_1', s); count(s);
  s = cmpNum('t_g_2', st.T.g2); setTickFromState('tk_t_g_2', s); count(s);

  // 2a) f(x) = ...
  s = checkAffineRHS('f', st.ctx.opt1.m, st.ctx.opt1.b0); setTickFromState('tk_f', s); count(s);

  // 2b) nature f
  const fNat = (document.getElementById('f_nat')?.value||'').toLowerCase().trim();
  if (fNat===''){ setTickFromState('tk_f_nat','neutral'); }
  else { s = (fNat===st.nat1?'ok':'ko'); setTickFromState('tk_f_nat', s); count(s); }

  // 3a) g(x) = ...
  s = checkAffineRHS('g', st.ctx.opt2.m, st.ctx.opt2.b0); setTickFromState('tk_g', s); count(s);

  // 3b) nature g
  const gNat = (document.getElementById('g_nat')?.value||'').toLowerCase().trim();
  if (gNat===''){ setTickFromState('tk_g_nat','neutral'); }
  else { s = (gNat===st.nat2?'ok':'ko'); setTickFromState('tk_g_nat', s); count(s); }

  // 3c) co√ªt Nq option 2
  s = cmpNum('q_cost', st.ctx.opt2.m*st.ctx.Nq + st.ctx.opt2.b0); setTickFromState('tk_q_cost', s); count(s);

  // 4) meilleure option
  const best = (document.getElementById('q_best')?.value||'').toLowerCase().trim();
  if (best===''){ setTickFromState('tk_q_best','neutral'); }
  else{
    const exp = (st.max1===st.max2 ? '√©galit√©'
                : (st.max1>st.max2 ? st.ctx.opt1.label.toLowerCase()
                                   : st.ctx.opt2.label.toLowerCase()));
    s = (best===exp?'ok':'ko'); setTickFromState('tk_q_best', s); count(s);
  }

  // feedback
  if (tot===0){ setFB(null,''); return false; }
  const all = (ok===tot); setFB(all, `${ok} / ${tot}`); return all;
},

  solution(){
    const st=this.state; if(!st) return;
    const euro = x => (Math.round(x*100)/100)
      .toLocaleString('fr-FR',{minimumFractionDigits:(x%1?2:0), maximumFractionDigits:2})+' ‚Ç¨';

    const {ctx,T,nat1,nat2,max1,max2} = st;
	const coefX = m => {
  const v = Math.round(m*100)/100;
  if (Math.abs(v-1) < 1e-12)  return 'x';
  if (Math.abs(v+1) < 1e-12)  return '-x';
  return dec(v) + 'x';
};
const sEq = (m,b0) => (b0===0 ? `f(x)= ${coefX(m)}` : `f(x)= ${coefX(m)} + ${dec(b0)}`);

    // seuil d'int√©r√™t (si m1 ‚â† m2)
const m1 = ctx.opt1.m, p1 = ctx.opt1.b0, m2 = ctx.opt2.m, p2 = ctx.opt2.b0;
    const seuil = (Math.abs(m1-m2)<1e-12) ? null : (p2-p1)/(m1-m2);
const dec = x => (Math.round(x*100)/100)
  .toLocaleString('fr-FR',{minimumFractionDigits:(x%1?2:0), maximumFractionDigits:2});
const approxSign = x => (Number.isInteger(x) ? '=' : '\\approx');
// √©crit m¬∑x sans montrer 1x ni -1x

const lineFracOrDirect = (num, den) => {
  if (Math.abs(den-1)  < 1e-12) return `<p></p>`;
  if (Math.abs(den+1)  < 1e-12) return `<p>\\( x = -${dec(num)} \\)</p>`;
  return `<p>\\( x = \\dfrac{${dec(num)}}{${dec(den)}} \\)</p>`;
};


// signe propre pour un constant b : "", " + 12", " - 12"
const fmtC = b => (Math.abs(b)<1e-12 ? '' : (b>0 ? ` + ${dec(b)}` : ` - ${dec(-b)}`));
// √©crit m¬∑x puis le constant : "2x + 12", "x - 5", "-x", etc.
const termAff = (m,b) => `${coefX(m)}${fmtC(b)}`;


    // ‚Äî‚Äî‚Äî CORRECTION r√©dig√©e (style ¬´ manuel ¬ª) ‚Äî‚Äî‚Äî
    let html = '<div class="sec"><div class="title">Correction</div>';

    // 1) Tableau corrig√©
    html += '<table class="table-black" style="margin:.3rem 0 .7rem 0">';
    html += '<thead><tr>';
    html += `<th>Nombre de ${ctx.thingPlural} ${ctx.verbe}</th>`;
    html += `<th>${ctx.Xs[0]}</th><th>${ctx.Xs[1]}</th><th>${ctx.Xs[2]}</th>`;
    html += '</tr></thead><tbody>';
    html += `<tr><td>Prix avec ${ctx.opt1.label.toLowerCase()}</td><td>${euro(T.f0)}</td><td>${euro(T.f1)}</td><td>${euro(T.f2)}</td></tr>`;
    html += `<tr><td>Prix avec ${ctx.opt2.label.toLowerCase()}</td><td>${euro(T.g0)}</td><td>${euro(T.g1)}</td><td>${euro(T.g2)}</td></tr>`;
    html += '</tbody></table>';

    // 2) Fonction f : r√©daction
    html += '<div class="steps">';
    html += `<p><strong>2. a)</strong> Avec ${ctx.opt1.label.toLowerCase()}, le prix est proportionnel au nombre de ${ctx.thingPlural}. `;
    html += `On a donc \\( ${sEq(ctx.opt1.m,ctx.opt1.b0)} \\).</p>`;
    html += `<p><strong>2. b)</strong> ${ctx.opt1.label} est une fonction <strong>${nat1}</strong>`;
    html += (ctx.opt1.b0===0 ? ' car elle est de la forme \\(f(x)=mx\\).' : ' car elle est de la forme \\(f(x)=mx+p\\) avec un terme constant non nul.');
    html += '</p>';

    // 3) Fonction g : r√©daction
    html += `<p><strong>3. a)</strong> Avec ${ctx.opt2.label.toLowerCase()}, on paie une partie fixe puis une partie proportionnelle : `;
    html += `\\( ${sEq(ctx.opt2.m,ctx.opt2.b0)} \\).</p>`;
    html += `<p><strong>3. b)</strong> ${ctx.opt2.label} est une fonction <strong>${nat2}</strong>`;
    html += (ctx.opt2.b0===0 ? ' car elle est de la forme \\(g(x)=mx\\).' : ' car elle est de la forme \\(g(x)=mx+p\\) avec un terme constant non nul.');
    html += '</p>';

    // 3.c) Co√ªt pour Nq avec Option 2 : calcul d√©velopp√©
const gNq = ctx.opt2.m*ctx.Nq + ctx.opt2.b0;
const prodN = ctx.opt2.m*ctx.Nq;
html += `<p><strong>4. </strong> Co√ªt pour \\(x=${ctx.Nq}\\) avec ${ctx.opt2.label.toLowerCase()} :</p>`;
html += `<p>\\( g(${ctx.Nq}) = ${dec(ctx.opt2.m)}\\times ${ctx.Nq}${ctx.opt2.b0?` + ${dec(ctx.opt2.b0)}`:''}= ${dec(prodN)}${ctx.opt2.b0?` + ${dec(ctx.opt2.b0)}`:''}= ${dec(gNq)} \\).</p>`;
html += `<p> Soit ${euro(gNq)}.</p>`;







    // 4) Budget : deux colonnes comme ta maquette, avec r√©solution explicite
html += '<table class="table-compare"><tbody><tr><td>';
    // colonne gauche : option 1
    html += `<p><strong>5. </strong> Avec ${ctx.opt1.label.toLowerCase()} :</p>`;
    html += `<p>\\( f(x) = ${ctx.BUD} \\)</p>`;
    if (ctx.opt1.b0===0){
const r1 = ctx.BUD/ctx.opt1.m;
html += `<p>\\( ${coefX(ctx.opt1.m)} = ${dec(ctx.BUD)}  \\)</p>`;
html += lineFracOrDirect(ctx.BUD, ctx.opt1.m);
// on √©vite la ligne finale si on vient d√©j√† d‚Äô√©crire "x = nombre" (den=¬±1)
if (Math.abs(ctx.opt1.m) !== 1){
  html += `<p>\\( x ${approxSign(r1)} ${dec(r1)} \\)</p>`;
}




html += `<p>${ctx.maxLine(max1)}</p>`;
    }else{
const r1 = (ctx.BUD - ctx.opt1.b0)/ctx.opt1.m;
html += `<p>\\( ${coefX(ctx.opt1.m)} + ${dec(ctx.opt1.b0)} = ${dec(ctx.BUD)} \\)</p>`;
html += `<p>\\( ${coefX(ctx.opt1.m)} = ${dec(ctx.BUD - ctx.opt1.b0)}  \\)</p>`;
html += lineFracOrDirect(ctx.BUD - ctx.opt1.b0, ctx.opt1.m);
if (Math.abs(ctx.opt1.m) !== 1){
  html += `<p>\\( x ${approxSign(r1)} ${dec(r1)} \\)</p>`;
}



html += `<p>${ctx.maxLine(max1)}</p>`;
    }
    html += '</td><td>';

    // colonne droite : option 2
    html += `<p>Avec ${ctx.opt2.label.toLowerCase()} :</p>`;
    html += `<p>\\( g(x) = ${ctx.BUD} \\)</p>`;
    if (ctx.opt2.b0===0){
const r2 = ctx.BUD/ctx.opt2.m;
html += `<p>\\( ${coefX(ctx.opt2.m)} = ${dec(ctx.BUD)} \\)</p>`;
html += lineFracOrDirect(ctx.BUD, ctx.opt2.m);
if (Math.abs(ctx.opt2.m) !== 1){
  html += `<p>\\( x ${approxSign(r2)} ${dec(r2)} \\)</p>`;
}




html += `<p>${ctx.maxLine(max2)}</p>`;
    }else{
const r2 = (ctx.BUD - ctx.opt2.b0)/ctx.opt2.m;
html += `<p>\\( ${coefX(ctx.opt2.m)} + ${dec(ctx.opt2.b0)} = ${dec(ctx.BUD)}\\)</p>`;
html += `<p>\\( ${coefX(ctx.opt2.m)} = ${dec(ctx.BUD - ctx.opt2.b0)}  \\)</p>`;
html += lineFracOrDirect(ctx.BUD - ctx.opt2.b0, ctx.opt2.m);
if (Math.abs(ctx.opt2.m) !== 1){
  html += `<p>\\( x ${approxSign(r2)} ${dec(r2)} \\)</p>`;
}



html += `<p>${ctx.maxLine(max2)}</p>`;
    }
    html += '</td></tr></tbody></table>';

    // conclusion + (facultatif) seuil
const best = (max1===max2 ? '√©galit√©' : (max1>max2 ? ctx.opt1.label.toLowerCase() : ctx.opt2.label.toLowerCase()));
const phrase = ctx.q5.r(best, max1===max2);
html += `<p><strong>Conclusion :</strong> ${phrase}</p>`;

// ‚Äî‚Äî‚Äî Seuil indicatif (remplace ton bloc existant) ‚Äî‚Äî‚Äî
if (Math.abs(m1 - m2) > 1e-12) {
  const num = p2 - p1;             // (p2 - p1)
  const den = m1 - m2;             // (m1 - m2)
  const xSeuil = num / den;

  html += `<p style="font-style:italic">Seuil indicatif :</p>`;
  html += `<p>\\( f(x) = g(x) \\)</p>`;
  html += `<p>\\( ${termAff(m1,p1)} = ${termAff(m2,p2)} \\)</p>`;

  // Regroupement des x : (m1-m2)x = (p2-p1)
  html += `<p>\\( ${coefX(den)} = ${dec(num)} \\)</p>`;

  const isDen1    = Math.abs(den - 1) < 1e-12;
  const isDenNeg1 = Math.abs(den + 1) < 1e-12;

  if (isDen1) {
    // den = +1 ‚Üí d√©j√† "x = num" juste au-dessus ‚Üí ne rien rajouter (√©vite le doublon)
  } else if (isDenNeg1) {
    // den = ‚àí1 ‚Üí on ajoute la ligne de changement de signe seulement
    html += `<p>\\( x = -${dec(num)} \\)</p>`;
  } else {
    // den quelconque ‚Üí fraction + √©ventuelle approx
    html += `<p>\\( x = \\dfrac{${dec(num)}}{${dec(den)}} \\)</p>`;
    html += `<p>\\( x ${approxSign(xSeuil)} ${dec(xSeuil)} \\)</p>`;
  }
}



    html += '</div>'; // .steps
    html += '</div>'; // .sec

    setStepsHTML(html); retypeset(HOST);
  }
},


e3_twoPts:{
  name:"Affine ‚Äì retrouver m et p √† partir de deux valeurs",
  lead:"D√©terminer une fonction affine \\(f\\) telle que \\(f(x_1)=y_1\\) et \\(f(x_2)=y_2\\).",

  gen(){
    mountHost(); removeDefaultAnswerRow(); setFB(null,'');

    // helpers
    const ri=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const pickM=()=>{ let m; do{ m=ri(-5,5);}while(m===0); return m; };   // m ‚â† 0 (classique)
    const pickP=()=>ri(-9,9);

    // assure m,p entiers, puis construit (x1,y1),(x2,y2)
    const m = pickM(), p = pickP();
function pickX(){ let v=0; do{ v=ri(-6,6); }while(v===0); return v; }  // interdit 0
let x1 = pickX();
let x2 = pickX();
while (x2 === x1) x2 = pickX();  // distincts ET non nuls
    const y1 = m*x1 + p, y2 = m*x2 + p;

    // p-ecran: ordre al√©atoire  (x1,y1) / (x2,y2)
    const shuf = Math.random()<0.5;
    const X1 = shuf?x2:x1, Y1 = shuf?y2:y1;
    const X2 = shuf?x1:x2, Y2 = shuf?y1:y2;

    // helpers d‚Äôaffichage
    const coefX = (k)=> (k===1?'x':k===-1?'-x':`${k}x`);

    // √©nonc√© + inputs
    let html='';
    html += '<p><strong>Exercice.</strong> D√©terminer une fonction affine \\(f\\) v√©rifiant&nbsp;:</p>';
    html += `<p>\\(f(${X1})=${Y1}\\) et \\(f(${X2})=${Y2}\\).</p>`;
    html += '<div class="vecrow" style="margin-top:.6rem">';
    html += '<span class="lbl">\\(m =\\) </span><input id="in_m" style="width:90px"> <span class="tick" id="tk_m"></span>';
    html += '<span class="lbl" style="margin-left:16px">\\(p =\\) </span><input id="in_p" style="width:90px"> <span class="tick" id="tk_p"></span>';
    html += '</div>';
    html += '<div class="vecrow"><span class="lbl">\\(f(x) = \\)</span><input id="in_fx" style="width:220px" placeholder=""> <span class="tick" id="tk_fx"></span></div>';
    setEqu(html); retypeset(HOST);

    this.state = {m,p,X1,Y1,X2,Y2, coefX};
  },

  verify(){
    const st=this.state; if(!st) return false;

    // parse nombre (entier/decimal/fraction)
    const normMinus = s => String(s||'').replace(/\u2212/g,'-').trim();
    const parseNum   = s => {
      s = normMinus(s).replace(',','.');
      if (/^[+-]?\d+\/\d+$/.test(s)){ const [a,b]=s.split('/').map(Number); return a/b; }
      return Number(s);
    };
    const isBlank = s => String(s||'').trim()==='';

    // parse expression affine tr√®s tol√©rante (mx+p ou p+mx, x/2, 2x/3, -x, etc.)
    function checkAffineExpr(raw, expm, expp){
      if (isBlank(raw)) return 'neutral';
      let s = normMinus(raw).toLowerCase().replace(/\s+/g,'').replace(/,/g,'.');
      if (!/^[0-9x+\-*/().\/]*$/.test(s)) return 'ko';
      s = s.replace(/(\d)\*x/g,'$1x').replace(/x\*(\d)/g,'x$1');
      const parts = s.match(/[+\-]?[^+\-]+/g) || [];
      let M=0, P=0;
      for (let t of parts){
        // constants
        if (/^[+-]?(?:\d+(?:\.\d+)?|\d+\/\d+)$/.test(t)){ P += parseNum(t); continue; }
        // ¬±x
        if (/^[+-]?x$/.test(t)){ M += (t[0]==='-'?-1:1); continue; }
        // ¬±x/num
        if (/^[+-]?x\/(?:\d+(?:\.\d+)?|\d+\/\d+)$/.test(t)){ const sgn=(t[0]==='-'?-1:1); M += sgn*(1/parseNum(t.slice(t.indexOf('/')+1))); continue; }
        // ¬±num x
        if (/^[+-]?(?:\d+(?:\.\d+)?|\d+\/\d+)x$/.test(t)){ M += parseNum(t.replace(/x$/,'')); continue; }
        // ¬±(num)x/num2
        if (/^[+-]?(?:\d+(?:\.\d+)?|\d+\/\d+)x\/(?:\d+(?:\.\d+)?|\d+\/\d+)$/.test(t)){
          const sgn=(t[0]==='-'?-1:1);
          const [num,den]=t.replace(/^[+-]?/,'').split('x/'); M += sgn*(parseNum(num)/parseNum(den)); continue;
        }
        return 'ko';
      }
      return (Math.abs(M-expm)<1e-9 && Math.abs(P-expp)<1e-9) ? 'ok' : 'ko';
    }

    // ticks util
    const set = (id,st)=> setTick(id, st==='ok'?'ok':st==='ko'?'ko':'');
    let ok=0, tot=0; const count = s=>{ if(s!=='neutral'){ tot++; if(s==='ok') ok++; } };

    // m, p num√©riques
    const vm = $('#in_m')?.value ?? '', vp = $('#in_p')?.value ?? '';
    const sm = isBlank(vm) ? 'neutral' : (Math.abs(parseNum(vm)-st.m)<1e-9 ? 'ok' : 'ko');
    const sp = isBlank(vp) ? 'neutral' : (Math.abs(parseNum(vp)-st.p)<1e-9 ? 'ok' : 'ko');
    set('tk_m', sm); count(sm);
    set('tk_p', sp); count(sp);

    // f(x)= ‚Ä¶
    const sfx = checkAffineExpr($('#in_fx')?.value||'', st.m, st.p);
    set('tk_fx', sfx); count(sfx);

    if (tot===0){ setFB(null,''); return false; }
    const all = ok===tot; setFB(all, `${ok} / ${tot}`); return all;
  },

solution(){
  const st=this.state; if(!st) return;
  const {X1,Y1,X2,Y2,m,p} = st;

  // ‚Äî helpers affichage (NE PAS montrer 1m / -1m, ni 1x / -1x) ‚Äî
  const coefX = k => (k===1?'x':k===-1?'-x':`${k}x`);
  const coefM = a => (a===1?'m':a===-1?'-m':`${a}m`);     // <-- √©vite 1m et -1m
  const magm  = a => (a===1 ? 'm' : `${a}m`);
  const pmSign = t => (t<0 ? ' + ' : ' - ');
  const pLine = (Y1,X1) => `${Y1}${pmSign(X1)}${magm(Math.abs(X1))}`;

  const den = X2 - X1;          // (x2 - x1)
  const num = Y2 - Y1;          // (y2 - y1)

  // ligne 2 du syst√®me d√©j√† simplifi√©e; √©viter 1m / -1m
  const sys2 =
    (den=== 1) ? `m = ${num}` :
    (den===-1) ? `-m = ${num}` :
                 `${den}m = ${num}`;

  let html = '<div class="sec"><div class="title">Correction</div><div class="steps">';

  // (1) Affine
  html += '<p>\\(f\\) est une fonction affine, donc \\(f(x)=mx+p\\).</p>';

  // (2) Syst√®me sur f(x1), f(x2) puis √©quations ‚Äî> SANS 1m/-1m
  html += `\\(\\begin{cases} f(${X1})=${Y1} \\\\ f(${X2})=${Y2} \\end{cases}`
       + `\\Longleftrightarrow\\begin{cases} ${coefM(X1)}+p=${Y1} \\\\ ${coefM(X2)}+p=${Y2} \\end{cases}\\)`;

  // (3) Syst√®me demand√© : p=... et √©quation de substitution SANS "+-"
// signe propre pour Y1 et pour le terme |x1|¬∑m
const y1Signed  = (Y1 >= 0 ? ` + ${Y1}` : ` - ${Math.abs(Y1)}`);
const x1mSigned = (X1 < 0 ? ' + ' : ' - ') + magm(Math.abs(X1));

html += `\\(\\Longleftrightarrow\\begin{cases}\\; p = ${pLine(Y1,X1)} \\\\ \\; ${coefM(X2)}${y1Signed}${x1mSigned} = ${Y2} \\end{cases}\\)`;
  html += `\\(\\Longleftrightarrow\\begin{cases}\\; p = ${pLine(Y1,X1)} \\\\ \\; ${sys2} \\end{cases}\\)`;

  // (4) m : fraction puis entier (signe propre si den<0)
  const frac = (den<0) ? `\\dfrac{${num}}{-${Math.abs(den)}}` : `\\dfrac{${num}}{${den}}`;
  html += `\\(\\Longleftrightarrow\\begin{cases}\\;  p = ${pLine(Y1,X1)} \\\\ \\; m = ${frac} \\end{cases}\\)`;

  // (5) Substitution : parenth√®ses si m<0 apr√®s "√ó" (et jamais 1m)
  const s = pmSign(X1);                             // " + " si X1<0, sinon " - "
  const partM = (Math.abs(X1)===1 ? 'm' : `${Math.abs(X1)}m`);
  const mMul = (m<0 ? `(${m})` : `${m}`);           // <-- parenth√®ses si m n√©gatif
  html += `\\(\\Longleftrightarrow\\begin{cases}\\;  p = ${Y1}${s}${Math.abs(X1)===1?`m`:`${Math.abs(X1)}m`} \\\\ \\; m = ${m} \\end{cases}\\)`;
  html += `\\(\\Longleftrightarrow\\begin{cases}\\;  p = ${Y1}${s}${Math.abs(X1)===1?` ${m}`:` ${Math.abs(X1)}\\times ${mMul}`} \\\\ \\; m = ${m} \\end{cases}\\)`;
  html += `\\(\\Longleftrightarrow\\begin{cases}\\;  p = ${p} \\\\ \\; m = ${m} \\end{cases}\\)`;

  // (6) f(x) finale sans 1x/‚àí1x
  const fx = p===0 ? `${coefX(m)}` : `${coefX(m)} ${p<0?'‚àí':'+'} ${Math.abs(p)}`;
  html += `<p>Ainsi \\(f(x)= ${fx}.\\)</p>`;

  html += '</div></div>';
  setStepsHTML(html); retypeset(HOST);
}



},



};

/* === Adapter pour le kit PDF (identique √† avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;


// PDF-only ‚Äî resserre *pmatrix* en array compact
// PDF-only ‚Äî compacte les vecteurs-colonne sans toucher l'√©cran
function tightenVectorsForPDF(html){
  if(!html) return html;

  // (a)  \begin{pmatrix} ... \end{pmatrix}  ->  ( array{c} ) + espaces n√©gatifs
  html = html.replace(
    /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (b)  \left( \begin{array}{c} ... \end{array} \right)  -> ajoute \! et r√©duit arraycolsep
  html = html.replace(
    /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (c)  versions sans \left...\right (rare) : ( array{c} ) ‚Üí ajoute \!
  html = html.replace(
    /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (d)  \pmatrix{‚Ä¶} macro √©ventuelle
  html = html.replace(
    /\\pmatrix\{([\s\S]*?)\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  return html;
}





/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
window.buildOneForPDFSync = function(defId){
  window.__PDF_BUILDING = true;           // ‚¨ÖÔ∏è d√©marre la zone neutre

  try {
    const cfg = REGISTRY_MAP[defId];
    if (!cfg) return { statement:'', solution:'' };

    const host   = document.querySelector('#host');
    const backup = host ? host.innerHTML : '';

    if (host) mountHost();
    document.querySelector('#lead').innerHTML = cfg.lead || '';

    // ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
    cfg.gen.call(cfg);


  // --- Restaure pour l‚Äô√©cran ---


  // ---- 1) R√©cup√©rer le rep√®re s‚Äôil existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // s√©curit√© namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) √ânonc√© texte (√©cran)
  const equHTML = (document.querySelector('#equ')||{}).innerHTML || '';

  // √ânonc√© final : grille 2 colonnes si on a un rep√®re, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction (√©cran)
const _oldRetypeset2 = window.retypeset;
  const _oldMJ2        = window.MJ;
  window.retypeset = function(){};
  window.MJ        = function(){};
  cfg.solution.call(cfg);
  
  // ---- Apr√®s cfg.solution.call(cfg); (et avant le restore) ----

// 2.1) R√©cup√©rer le SVG *corrig√©*
let corrigeRepereHTML = '';
{
  const svgSol = document.querySelector('.row svg.svgbox') || document.querySelector('svg.svgbox');
  if (svgSol){
    const clone = svgSol.cloneNode(true);
    clone.removeAttribute('style');
    clone.setAttribute('width','300');      // taille PDF
    clone.setAttribute('height','300');
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    corrigeRepereHTML = clone.outerHTML;
  }
}

// 2.2) R√©cup√©rer le HTML texte de la correction
const corrigeTexteHTML = (document.querySelector('#res')||{}).innerHTML || '';

// 2.3) Composer la *correction* pour le PDF : rep√®re + texte
const solution =
  corrigeRepereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${corrigeRepereHTML}</div>
         <div>${corrigeTexteHTML}</div>
       </div>`
    : corrigeTexteHTML;

  
  
  window.retypeset = _oldRetypeset2;
  window.MJ        = _oldMJ2;

  if (host) host.innerHTML = backup;

  // ---- 4) PDF-only : resserrer les pmatrix via TeX (espace interne)
  function tightenVectorsForPDF(html){
    if(!html) return html;
    // pmatrix -> array{c} + espaces n√©gatifs
    html = html.replace(
      /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \left( \begin{array}{c} ... \end{array} \right) -> ajoute \!
    html = html.replace(
      /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // versions sans \left...\right
    html = html.replace(
      /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \pmatrix{‚Ä¶}
    html = html.replace(
      /\\pmatrix\{([\s\S]*?)\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    return html;
  }

  const statementTight = statement;
  const solutionTight  = solution;
  
 function stripCHTML(html){
  if(!html) return html;
  return html
     .replace(/<mjx-container[\s\S]*?<\/mjx-container>/g, (m)=>{
       // On essaie de r√©cup√©rer le TeX source si MathJax l‚Äôa laiss√© en data-tex,
       // sinon on supprime (on n‚Äôen veut pas dans le PDF SVG).
       const tex = m.match(/data-tex="([^"]+)"/);
       return tex ? `\\(${tex[1]}\\)` : '';
     });
 }
 const statementClean = stripCHTML(statementTight);
 const solutionClean  = stripCHTML(solutionTight);

  // ‚ö†Ô∏è On wrappe ici avec .vec-tight pour activer le CSS ‚Äúresserr√©‚Äù c√¥t√© iframe PDF (SVG)
    return {
      statement: `<div class="vec-tight">${statementTight||''}</div>`,
      solution:  `<div class="vec-tight">${solutionTight||''}</div>`
    };
  } finally {
    window.__PDF_BUILDING = false;        // ‚¨ÖÔ∏è on r√©active l‚Äô√©cran quoi qu‚Äôil arrive
  }
};




/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){

  mountHost(); // injecte le layout par d√©faut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // √©l√©ments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', HOST);
  const fbEl  = $('#fb', HOST);
  const resEl = $('#res', HOST);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

  // g√©n√®re l'exo (peut remplacer enti√®rement le host, ex. e3/ex4)
  cfg.gen.call(cfg);




  // (re)typeset
  retypeset();

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
document.querySelector('#btn-reset').addEventListener('click', ()=>{
  const a=$('#ans',HOST); if(a) a.value='';
  document.querySelectorAll('.colvec input').forEach(i=> i.value=''); // ‚¨ÖÔ∏è AJOUT
  const f=$('#fb',HOST); if(f) f.textContent='';
  const r=$('#res',HOST); if(r) r.innerHTML='';
});
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
    document.querySelector('#btn-solution').addEventListener('click', ()=>{ REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]); });


function adjustLive(kind){
  const id = ACTIVE;
  if (id === 'e3'   && REGISTRY_MAP.e3.adjustLive)   REGISTRY_MAP.e3.adjustLive(kind);
  else if (id === 'ex4' && REGISTRY_MAP.ex4.adjustLive) REGISTRY_MAP.ex4.adjustLive(kind);
  else if (id === 'e5'  && REGISTRY_MAP.e5.adjustLive)  REGISTRY_MAP.e5.adjustLive(kind);
  else { applyAMPInputs(); }
}


['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;     buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) ‚Äî inchang√©, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);
// --- PDF-only: resserre les parenth√®ses des vecteurs-colonne ---
function tightenVectorsForPDF(html){
  if(!html) return html;
  // 1) diminue l'espace colonne dans les array (√©quivalent \arraycolsep)
  html = html.replace(/\\begin\{array\}\{c\}/g, '{\\arraycolsep=1.5pt\\begin{array}{c}');
  // 2) colle les grandes parenth√®ses √† la matrice (\left( ... \right))
  //    (sans toucher le reste du doc)
  html = html
    .replace(/\\left\(\s*\\begin\{array\}\{c\}/g, '\\left(\\mkern-6mu\\begin{array}{c}')
    .replace(/\\end\{array\}\s*\\right\)/g, '\\end{array}\\mkern-6mu\\right)');
  return html;
}

const statementTight = tightenVectorsForPDF(statement);
const solutionTight  = tightenVectorsForPDF(solution);

          const htmlIn =
  `<div class="exo-block">
     <span class="exo-title">Exercice</span>
     <div class="exo-statement">${statementTight||''}</div>
   </div>` +
  (withSolutions
    ? `<div style="margin-top:1rem;">
         <div class="exo-block"><div class="steps" id="pdf-steps">
           <span class="exo-title"></span>
           <!-- ‚¨áÔ∏è Ajout d‚Äôun conteneur .steps pour retrouver la zone grise -->
           <div class="exo-solution">${solutionTight||''}</div></div>
         </div>
       </div>`
    : '');


          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;
const css = idoc.createElement('style');
css.textContent = `
  :root{
    --ink:#111; --bg:#fafafa; --card:#fff; --line:#e5e7eb; --muted:#666;
    --steps-bg:#f3f4f6; --steps-border:#e5e7eb; --steps-left:#9aa0a6;
  }
  body{font:16px/1.55 system-ui,Segoe UI,Roboto,Arial;color:var(--ink);}
  .exo-title{display:block;font-weight:700;margin:0 0 6px}
  /* ‚öôÔ∏è Zone grise identique √† l‚Äô√©cran (#res.steps) */
  .steps{
    background:var(--steps-bg);
    border:1px solid var(--steps-border);
    border-left:4px solid var(--steps-left);
    border-radius:8px;
    padding:10px;
    margin:.45rem 0 0 .15rem;
  }
  .steps p{margin:.25rem 0}
  /* Table ‚Äúe5‚Äù compacte */
  .tbl3{border-collapse:collapse}
  .tbl3 td{padding:2px 6px;vertical-align:top}
  
  /* === Tighten parentheses around column vectors (SVG output) === */
/* CHTML (au cas o√π), agit sur les delimiters extensibles */
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:first-child { margin-right: -0.18em; }
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:last-child  { margin-left:  -0.18em; }
.vec-tight mjx-mtable mjx-mtd { padding-left: .15em; padding-right: .15em; }
.vec-tight mjx-mtable > mjx-table { margin-left: 0; margin-right: 0; }

/* SVG : d√©caler l√©g√®rement OPEN/CLOSE pour coller les parenth√®ses au tableau */
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="OPEN"]  { transform: translateX(-0.18em); }
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="CLOSE"] { transform: translateX( 0.18em); }

/* Ajustement global tr√®s l√©ger si besoin (peut √™tre mis √† 0 si tu pr√©f√®res) */
.vec-tight svg[aria-hidden="true"] { margin-left:-0.10em; margin-right:-0.10em; }
/* --- Anti "barres noires" MathJax (PDF) --- */
.exo-statement,
.exo-solution { color:#111 !important; background:transparent !important; }

/* Cas CHTML (au cas o√π) */
mjx-container { color:#111 !important; background:transparent !important; }
mjx-container svg { overflow:visible !important; }
mjx-container svg rect,
mjx-container svg path[data-mml-node="mspace"] { fill:none !important; }

/* Cas SVG standalone (ce que tu utilises dans l‚Äôiframe) */
.exo-statement svg rect,
.exo-statement svg path[data-mml-node="mspace"],
.exo-solution  svg rect,
.exo-solution  svg path[data-mml-node="mspace"] { fill:none !important; }
/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }
`;
idoc.head.appendChild(css);

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
