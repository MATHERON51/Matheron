<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Fonctions affines - In√©quations "produit"</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}

/* Bloc solution (UI) */
#res.steps{
  background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;
}
#res.steps p{margin:.25rem 0}

.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }




/* Grille 3 colonnes pour les vecteurs √† placer (partie 3) */
.grid3 {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px 12px;           /* espace lignes/colonnes */
  align-items: start;
}
.grid3 .chipwrap { width: 100%; }

/* ---- Blocs sous le rep√®re : 2 lignes √ó 5 colonnes ---- */
.flat12-wrap{ margin-top:10px; }

.sec{ margin:10px 0; }
.sec .title{ font-weight:700; font-size:1.05rem; margin-bottom:6px; }

/* une grille de 5 colonnes */
.grid5{
  display:grid;
  grid-template-columns: repeat(5, max-content);
  gap:8px 14px;
  align-items:center;
}

/* cellules : libell√© + vecteur-colonne + tick */
.grid5 .inlinecell{ display:flex; align-items:center; gap:6px; }

/* vecteurs en colonne compacts pour tenir √† 5√ó2 */
.grid5 .colvec{
  --parenW:8px; --padX:5px; --gap:3px;
  --inW:44px; --inPy:2px; --inFs:12.5px;
}

.hidden{ display:none; }


/* ‚Äî Anti ‚Äúbarres noires‚Äù MathJax ‚Äî */
.steps mjx-container { color: #111 !important; background: transparent !important; }
.steps mjx-container svg { overflow: visible !important; }
.steps mjx-container svg rect,
.steps mjx-container svg path[data-mml-node="mspace"] { fill: none !important; }
.steps mjx-mrow, .steps mjx-mi, .steps mjx-mo, .steps mjx-mn { background: transparent !important; }

/* ==== Nom de vecteur avec fl√®che au-dessus ============================== */
.vecname{ position:relative; display:inline-block; }
.vecname input{
  width:72px; text-align:center; font-weight:700; font-size:15px;
  letter-spacing:.12em; text-transform:uppercase;
  padding:14px 10px 6px 10px; /* place pour la fl√®che au-dessus */
  border:1px solid #ddd; border-radius:8px; background:#fff;
}
.vecname::before{
  content:""; position:absolute; left:12px; right:20px; top:6px; height:2px; background:#111;
}
.vecname::after{
  content:""; position:absolute; top:2px; right:12px;
  border-left:8px solid #111; border-top:5px solid transparent; border-bottom:5px solid transparent;
}

/* Lignes compactes sous le rep√®re pour e2 */
.vecrow{ display:flex; align-items:center; gap:12px; margin:6px 0; flex-wrap:wrap; }
.vecrow .lbl{ font-weight:700; min-width:max-content; }
.vecrow .tick{ min-width:1.4rem; font-weight:900; }
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.pair{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.pair .lbl{font-weight:700;min-width:1.6rem}

/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }

.table-compare {
  border-collapse: collapse;
  width: 100%;
  margin: .5rem 0 .6rem 0;
}
.table-compare td {
  vertical-align: top;
  padding: 0 .8rem;
  border: none;
}
.table-compare td:first-child {
  border-right: 2px solid #000; /* fine barre verticale */
}


 /* tableaux imprimables style PDF */
  table.pdf-tbl{ border-collapse:separate; border-spacing:0; border:none; margin:.4rem 0; }
  table.pdf-tbl th, table.pdf-tbl td{ border:none; padding:4px 6px; text-align:center; vertical-align:middle; }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* tableaux interactifs (cadre uniquement) */
  table.var{ border-collapse:separate; border-spacing:0; margin:.35rem auto }
  table.var th, table.var td{ padding:4px 6px; border:none }
  table.var tr:first-child > * { border-top:    1.5px solid #000; }
  table.var tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.var tr > *:first-child { border-left:   1.5px solid #000; }
  table.var tr > *:last-child  { border-right:  1.5px solid #000; }
  table.var tbody tr:first-child > * { border-bottom: 1.5px solid #000; }
  table.var td.bigsel{ padding:0 }
  table.var td.bigsel select{ display:block; width:100%; height:100%; background:transparent; padding:0; margin:0; text-align:center; text-align-last:center; appearance:none }
  table.var input[type="text"]{ width:110px; text-align:center }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.repere{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  
  /* S√©parateur vertical apr√®s la 1re colonne, pour tous les tableaux interactifs */
table.var tr > *:first-child{
  border-left: 1.5px solid #000;   /* bord ext√©rieur gauche (d√©j√† pr√©sent) */
  border-right: 1.5px solid #000;  /* ‚áê ajout : barre verticale apr√®s la 1re colonne */
}
/* 5) f' + variations ‚Äî trait entre f'(x) et f (√©nonc√© + PDF) */
#dv-wrap table.var tbody tr:nth-child(2) > *,
#dv-out  table.pdf-tbl tbody tr:nth-child(2) > * {
  border-bottom: 1.5px solid #000;
}
/* 5) ENONC√â : trait entre f'(x) et f */
#dv-wrap table.var tbody tr:nth-child(2) > * {
  border-bottom: 1.5px solid #000;
}

/* 5) SOLUTION (PDF) : trait entre f'(x) et f */
#dv-out table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}
/* Enlever fond/bordure sur les blocs de solution */
#v-out.steps,
#s1-out.steps,
#sf-out.steps,
#dv-out.steps,
#curve-out-var.steps,
#curve-out-sign.steps {
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}
#v-out .step, #s1-out .step, #sf-out .step,
#dv-out .step, #curve-out-var .step, #curve-out-sign .step {
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}
/* Trait entre f'(x) et f dans la solution auto */
#curve-out-deriv table.pdf-tbl tbody tr:first-child > *{
  border-bottom: 1.5px solid #000;
}

/* Pas de fond gris pour cette sortie */
#curve-out-deriv.steps { background: transparent !important; border:none !important; padding:0 !important; }
#curve-out-deriv .step  { background: transparent !important; border:none !important; padding:0 !important; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}

/* 2 barres (||) ‚Äî √©cart RESSERR√â */
table.pdf-tbl td.dbar::before,
table.pdf-tbl td.dbar::after{
  content:'';
  position:absolute;
  top:-1.5px;
  bottom:-1.5px;
  border-left:2px solid #000;
}
table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

/* === 4) TABLEAU SIGNE FACTORIS√â ‚Äî ENONC√â (grille interactive) === */
/* trait sous x (tu l'as d√©j√† via tbody tr:first-child > * { border-bottom: ... }) */
/* traits entre 'a' / facteurs / 'f(x)' */
#sf-wrap table.var tbody tr.sf-row-a > *,
#sf-wrap table.var tbody tr.sf-row-factor + tr.sf-row-factor > *,
#sf-wrap table.var tbody tr.sf-row-fx > * {
  border-top: 1.5px solid #000;
}
/* Ligne apr√®s 'a' (si la ligne 'a' est affich√©e) */
#sf-wrap table.var tbody tr.sf-row-a + tr.sf-row-factor > * {
  border-top: 1.5px solid #000;
}

/* === 4) TABLEAU SIGNE FACTORIS√â ‚Äî SOLUTION (PDF) === */
/* traits entre 'a' / facteurs / 'f(x)' */
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-a > *,
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-factor + tr.sf-pdf-row-factor > *,
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-fx > * {
  border-top: 1.5px solid #000;
}

/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* Courbes multiples : trait horizontal entre f'(x) et f dans la SOLUTION (PDF) */
#mc-out-deriv table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}

/* Gabarit SOLUTION (pdf-tbl) ‚Äî a√©ration mod√©r√©e */
.steps .pdf-tbl{
  width: auto;             /* ne force pas 100% */
  max-width: 100%;
  table-layout: auto;
}
.steps .pdf-tbl th,
.steps .pdf-tbl td{
  padding: 5px 8px;        /* l√©ger + que l'origine, moins qu'avant */
}
.steps .pdf-tbl tbody th{
  min-width: 64px;         /* libell√©s (f, f', a, ‚Ä¶) */
}
.steps .pdf-tbl td{
  min-width: 30px;         /* colonnes x / intervalles */
}
/* Fl√®ches plus grandes dans les tableaux de variations de la **solution** */
.steps .pdf-tbl td.arr{
  font-size: 1.45em;   /* taille des fl√®ches */
  line-height: 1;
  font-weight: 700;
  padding-left: 6px;
  padding-right: 6px;
}
@media print{
  .steps .pdf-tbl td.arr{ font-size: 1.6em; }
}
/* Centrage vertical (valeur unique) */
table.pdf-tbl td.mid, table.var td.mid { position: relative; }
table.pdf-tbl td.mid .midv, table.var td.mid .midv{
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  white-space:nowrap; text-align:center;
}

/* tableau de signes : colonnes sym√©triques */
.pdf-tbl.sign4 td { padding-left: 6px; padding-right: 6px; } /* optionnel, m√™me padding */
.pdf-tbl.sign4 td.L { text-align: left; }
.pdf-tbl.sign4 td.C { text-align: center; position: relative; }
.pdf-tbl.sign4 td.R { text-align: right; }


/* ===== Tableau de signes ‚Äî version √âCRAN (live) ===== */
table.pdf-tbl.sign-live td,
table.pdf-tbl.sign-live th{
  padding: 6px 10px;       /* remet de l'air */
  line-height: 1.2;
}

/* live : on annule le centrage absolu‚Ä¶ */
table.pdf-tbl.sign-live td.mid {
  position: static;
  height: 44px;
}
/* ‚Ä¶sauf pour les cellules qui dessinent une barre */
table.pdf-tbl.sign-live td.zbar,
table.pdf-tbl.sign-live td.sbar,
table.pdf-tbl.sign-live td.dbar {
  position: relative; /* indispensable pour confiner ::before */
}

table.pdf-tbl.sign-live td.mid .midv{
  position: static;
  transform: none;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 28px;
}

/* entr√©es confortables et non √©cras√©es */
table.pdf-tbl.sign-live select,
table.pdf-tbl.sign-live input{
  height: 30px;
  padding: 4px 8px;
  font-size: 15px;
  box-sizing: border-box;
}

/* des colonnes ‚Äú0‚Äù un peu plus larges pour les barres zbar */
table.pdf-tbl.sign-live col.col-zero { width: 58px; }
table.pdf-tbl.sign-live col.col-int  { width: 140px; }
table.pdf-tbl.sign-live col.col-lbl  { width: 70px; }

/* ===== LIGNES HORIZONTALES ‚Äî TABLEAUX √âCRAN ===== */

/* 1) Tableaux de signes/variations en version √©cran (.pdf-tbl.sign-live) */
table.pdf-tbl.sign-live thead tr > *{
  border-bottom: 1.5px solid #000;     /* trait sous la ligne x */
}
table.pdf-tbl.sign-live tbody tr + tr > *{
  border-top: 1px solid #000;          /* trait fin entre lignes */
}

/* 2) Tableaux interactifs type .var (si utilis√©s √† l‚Äô√©cran) */
table.var thead tr > *{
  border-bottom: 1.5px solid #000;     /* trait sous la ligne x */
}
table.var tbody tr + tr > *{
  border-top: 1px solid #000;          /* trait fin entre lignes */
}

/* 3) Les lignes ‚Äúsp√©ciales‚Äù doivent rester plus √©paisses */
#sf-wrap table.var tbody tr.sf-row-a > *,
#sf-wrap table.var tbody tr.sf-row-factor + tr.sf-row-factor > *,
#sf-wrap table.var tbody tr.sf-row-fx > *,
#sf-out  table.pdf-tbl tbody tr.sf-pdf-row-a > *,
#sf-out  table.pdf-tbl tbody tr.sf-pdf-row-factor + tr.sf-pdf-row-factor > *,
#sf-out  table.pdf-tbl tbody tr.sf-pdf-row-fx > *{
  border-top: 1.5px solid #000 !important;   /* prime sur la r√®gle ‚Äú1px‚Äù */
}

/* (Si tu utilises un tableau ¬´ d√©riv√©e/variations ¬ª similaire) */
#dv-wrap table.var tbody tr:nth-child(2) > *,
#dv-out  table.pdf-tbl tbody tr:nth-child(2) > *{
  border-bottom: 1.5px solid #000;          /* trait entre f'(x) et f */
}
/* 1) LIGNES HORIZONTALES ‚Äî solution (.pdf-tbl) */
table.pdf-tbl thead tr > *{
  border-bottom: 1.5px solid #000;      /* trait sous la ligne x */
}
table.pdf-tbl tbody tr + tr > *{
  border-top: 1px solid #000;           /* s√©parateur fin entre lignes du corps */
}

/* 2) BARRES VERTICALES UNIQUEMENT DANS <tbody> (pas sur la ligne des x) */
table.pdf-tbl tbody td.zbar,
table.pdf-tbl tbody td.sbar,
table.pdf-tbl tbody td.dbar{ position: relative; }  /* confinement du ::before */

table.pdf-tbl tbody td.zbar::before,
table.pdf-tbl tbody td.sbar::before,
table.pdf-tbl tbody td.dbar::before,
table.pdf-tbl tbody td.dbar::after{
  content:'';
  position:absolute;
  top:-1.5px; bottom:-1.5px;            /* colle aux traits horizontaux du corps */
  left:50%; transform:translateX(-50%);
  border-left:2px solid #000;
}
table.pdf-tbl tbody td.dbar::before{ left: calc(50% - 2px); }
table.pdf-tbl tbody td.dbar::after { left: calc(50% + 2px); }

/* D√©sactive explicitement toute barre dans THEAD (s√©curit√©) */
table.pdf-tbl thead td.zbar::before,
table.pdf-tbl thead td.sbar::before,
table.pdf-tbl thead td.dbar::before,
table.pdf-tbl thead td.dbar::after{ content:none !important; }

/* M√™me r√®gle pour la version √©cran si tu utilises .sign-live */
table.pdf-tbl.sign-live tbody td.zbar,
table.pdf-tbl.sign-live tbody td.sbar,
table.pdf-tbl.sign-live tbody td.dbar{ position: relative; }
table.pdf-tbl.sign-live thead td.zbar::before,
table.pdf-tbl.sign-live thead td.sbar::before,
table.pdf-tbl.sign-live thead td.dbar::before,
table.pdf-tbl.sign-live thead td.dbar::after{ content:none !important; }

/* Cach√© sur √©cran, pr√©sent dans le DOM (utile pour le PDF) */
.hide-screen{ display:none !important; }

/* Solution (PDF) : pousser les signes aux bords sur les colonnes extr√™mes */
#res.steps table.pdf-tbl tbody tr > td.mid:first-of-type .midv{
  left: auto;              /* on annule le centrage horizontal */
  right: 6px;              /* colle √† droite */
  transform: translateY(-50%);  /* seulement centr√© verticalement */
  text-align: right;
}

#res.steps table.pdf-tbl tbody tr > td.mid:last-of-type .midv{
  left: 6px;               /* colle √† gauche */
  right: auto;
  transform: translateY(-50%);
  text-align: left;
}

</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Fonctions affines - In√©quations "produit"</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
<li>Pour la question <strong>1)</strong> : saisir la solution sous la forme <code>{r√©ponse}</code> (ex. <code>{3/2}</code>). Ne pas taper <code>S=</code> dans le champ.</li>
<li>Pour plus de d√©tails dans les r√©solutions d'√©quations ou d'in√©quations : voir chapitre 1.</li>
<li>Rappel : Multiplier par un nombre n√©gatif change l'ordre de l'in√©galit√©.</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Mini helpers g√©n√©riques ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
const HOST = $('#host');
function retypeset(host){
  if (window.__PDF_BUILDING) return;              // ‚¨ÖÔ∏è ignore en phase PDF
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]);
}function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; }

/* ====== Rationnels ‚Äúpropres‚Äù (pour jolies fractions dans les corrections) ====== */
function R(p,q=1){ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function addR(x,y){ return R(x.p*y.q + y.p*x.q, x.q*y.q); }
function subR(x,y){ return R(x.p*y.q - y.p*x.q, x.q*y.q); }
function mulR(x,y){ return R(x.p*y.p, x.q*y.q); }
function negR(x){ return R(-x.p, x.q); }
function numR(x){ return x.p/x.q; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'‚àí':''; const P=Math.abs(r.p); return s+'\\dfrac{'+P+'}{'+r.q+'}'; }
function textR(r){ return r.q===1 ? String(r.p) : `${r.p}/${r.q}`; }
// Retourne -\dfrac{|p|}{q} si p<0, sinon \dfrac{p}{q}; et un entier si q=1
function latexR_leadingMinus(r){
  // r = {p,q} d√©j√† r√©duit
  const p = r.p, q = r.q;
  if (q === 1) return String(p);                    // pas de /1
  const P = Math.abs(p), Q = Math.abs(q);
  const sign = (p*q < 0) ? '‚àí' : '';                // signe global
  return `${sign}\\dfrac{${P}}{${Q}}`;              // ‚àí devant \dfrac
}



/* ===== MathJax helper ===== */
function MJ(el){
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }



// Retourne les √©tapes LaTeX pour p/q : d'abord p/q, puis (optionnel) la forme r√©duite.
// Remplace TOUT le bloc existant par celui-ci
function fracStepsLatex(p, q){
  // signe global devant, jamais de /1
  const sgn = (p*q < 0) ? '‚àí' : '';
  let P = Math.abs(p), Q = Math.abs(q);

  // √âtape 1 : forme "brute" (si Q==1, on √©crit un entier)
  const first = (Q === 1) ? `${sgn}${P}` : `${sgn}\\dfrac{${P}}{${Q}}`;

  // √âtape 2 : forme r√©duite (si r√©ductible)
  const g0 = gcd(P, Q);
  if (g0 > 1){
    const pr = P / g0, qr = Q / g0;
    const reduced = (qr === 1) ? `${sgn}${pr}` : `${sgn}\\dfrac{${pr}}{${qr}}`;
    // si la r√©duction ne change rien visuellement, on garde une seule √©tape
    if (reduced !== first) return [first, reduced];
  }

  return [first];
}



/* === Helpers de comparaison (signes & doublons) ========================== */
// Normalise les signes dans les fractions pour comparer :
//  \dfrac{-a}{b}  ‚Üí  -\dfrac{a}{b}
// enl√®ve espaces superflus et normalise le "‚àí" unicode en "-"
function normalizeFracSign(s){
  return String(s)
    .replace(/\u2212/g, '-') // unicode minus ‚Üí "-"
    .replace(/\\dfrac\{\s*-\s*([^}]+)\}\{\s*([^}]+)\}/g, '-\\dfrac{$1}{$2}')
    .replace(/\(\s*-\s*\\dfrac/g, '(-\\dfrac')
    .replace(/\s+/g, ' ')
    .trim();
}


/* ====== UI host ====== */
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq hide-screen"></div>   <!-- ‚¨ÖÔ∏è cach√© √† l'√©cran -->
    <hr class="sep">
    <div class="controls">
      <label class="input">R√©ponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>
  `;
}


function setEqu(html){ const box=$('#equ',HOST); if(box) box.innerHTML = html; retypeset(HOST); }
function setStepsHTML(html){ $('#res',HOST).innerHTML=html; retypeset(HOST); }
function setSteps(lines){ setStepsHTML(lines.map(L=>`<p>${L}</p>`).join('')); }
function setFB(ok, msg=''){
  const fb = $('#fb', HOST);
  if (!fb) return;
  if (ok === null){        // ‚¨ÖÔ∏è mode neutre
    fb.className = '';     // ni .ok ni .ko
    fb.innerHTML = msg;    // message libre (peut contenir du HTML)
    return;
  }
  fb.className = ok ? 'ok' : 'ko';
  fb.textContent = (ok?'‚úîÔ∏é Correct. ':'‚úó Incorrect. ') + msg;
}

/* ====== Parsing des r√©ponses u;v ====== */
function normalizeMinus(s){ return String(s||'').replace(/\u2212/g,'-').trim(); }
function parseNumber(token){
  token = String(token)
    .trim()
    .replace(/\s+/g,'')
    .replace(/[‚àí‚Äì‚Äî]/g,'-')   // ‚Üê moins Unicode ‚Üí '-'
    .replace(',', '.');      // d√©cimales fr
  if (/^[-+]?\d+\/\d+$/.test(token)){
    const [p,q] = token.split('/').map(Number);
    return p/q;
  }
  return token==='' ? NaN : Number(token);
}

function parsePairUV(s){
  s = normalizeMinus(s).replace(/\s+/g,'');
  const m = s.match(/^([^;]+);([^;]+)$/);
  if(!m) return {ok:false};
  const u=parseNumber(m[1]), v=parseNumber(m[2]);
  return (isFinite(u)&&isFinite(v)) ? {ok:true,u,v} : {ok:false};
}








function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// cellules 3√ó3 √† l'int√©rieur des limites "lim"
function makeCells(lim, rows=3, cols=3){
  const w = (lim.xmax - lim.xmin + 1), h = (lim.ymax - lim.ymin + 1);
  const cw = Math.floor(w / cols), ch = Math.floor(h / rows);
  const cells = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0 = lim.xmin + c*cw, x1 = (c===cols-1) ? lim.xmax : (x0+cw-1);
      const y0 = lim.ymin + r*ch, y1 = (r===rows-1) ? lim.ymax : (y0+ch-1);
      cells.push({xmin:x0, xmax:x1, ymin:y0, ymax:y1});
    }
  }
  return cells;
}
function randIntInCell(cell){ return { x: randInt(cell.xmin, cell.xmax), y: randInt(cell.ymin, cell.ymax) }; }
function fits(lim, x, y){ return x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax; }


// --- Unicit√© de pente : cl√© de colin√©arit√© (ignore l'√©chelle et le signe global)
function slopeKey(dx, dy){
  if (dx === 0) return 'V';     // vertical
  if (dy === 0) return 'H';     // horizontal
  // normalise le signe pour que (dx,dy) et (-dx,-dy) donnent la m√™me cl√©
  if (dx < 0){ dx = -dx; dy = -dy; }
  const g0 = gcd(Math.abs(dx), Math.abs(dy)) || 1;
  const a = dx / g0, b = dy / g0; // a = dx', b = dy' primitifs
  return b + '/' + a;             // on encode la pente (dy/dx) comme "b/a"
}


// --- Unicit√© stricte des coordonn√©es (a;b) pour la partie 3
const abKey = (a,b) => a + ';' + b;


/* ===== Utilitaire PDF : forcer la taille du SVG (300√ó300) ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }



// helpers you may already have:
const isEmptyTxt = id => !($('#'+id)?.value||'').trim();
const isEmptyCol = id => !($('#'+id+'_u')?.value||'').trim() && !($('#'+id+'_v')?.value||'').trim();

function namesArePaired(n1, n2){
  const s = v => String(v||'').toUpperCase().replace(/\s+/g,'');
  const map = { AB:'DC', BA:'CD', BC:'AD', CB:'DA' };
  const a = s(n1), b = s(n2);
  return !!(map[a] && map[a] === b);
}

function setTick(id, kind){ const el = document.getElementById(id); if(el){ el.className='tick '+(kind||''); el.textContent = kind==='ok' ? '‚úì' : kind==='ko' ? '‚úó' : ''; } }

function removeDefaultAnswerRow(){
  const ctrl = HOST.querySelector('.controls'); // le bloc "R√©ponse ‚Ä¶  #fb"
  if (ctrl) ctrl.remove();
}


// supprime un signe d‚Äôen-t√™te (prend aussi le vrai "‚àí" unicode)
function stripLeadSign(s){
  return String(s).replace(/^[\u2212\-+]\s*/,'');
}

// normalise les suites de signes: "+ ‚àí"‚Üí" ‚àí", "‚àí ‚àí"‚Üí" +", "+ +"‚Üí"+", et supprime un "+" initial
function tidySigns(s){
  return String(s)
    .replace(/\+\s*[\u2212\-]\s*/g,' ‚àí ')
    .replace(/[\u2212\-]\s*[\u2212\-]\s*/g,' + ')
    .replace(/\+\s*\+\s*/g,' + ')
    .replace(/^\s*\+\s*/,'');
}





// fabrique l‚Äôintervalle en LaTeX selon le comparateur final et x0
function intervalFromCmp(finalCmp, x0Latex){
  if (finalCmp === '<')   return `\\left] -\\infty\\,;\\, ${x0Latex} \\right[`;
  if (finalCmp === '<=')  return `\\left] -\\infty\\,;\\, ${x0Latex} \\right]`;
  if (finalCmp === '>')   return `\\left] ${x0Latex} \\;;\\; +\\infty \\right[`;
  /* finalCmp === '>=' */ return `\\left[ ${x0Latex} \\;;\\; +\\infty \\right[`;
}


function dedupLines(lines){
  const out = [];
  let prev = '';
  for (const L of lines){
    if (!L) continue;                       // null/undefined/'' ‚Üí saute
    const key = String(L).replace(/\s+/g,' ').trim();
    if (key !== prev){ out.push(L); prev = key; }
  }
  return out;
}

// normalisation tr√®s agressive pour comparer 2 lignes de TeX
function _normLine(s){
  return String(s)
    .replace(/\u2212/g,'-')             // ‚àí ‚Üí -
    .replace(/\s+/g,' ')                // espaces multiples
    .replace(/\s*([=<>])\s*/g,' $1 ')   // espaces autour de = < >
    .replace(/\\ge/g,'>=')              // \ge ‚Üí >= (cl√© unique)
    .replace(/\\le/g,'<=')              // \le ‚Üí <=
    .replace(/^\s+|\s+$/g,'')           // trim
}

// pousse la ligne uniquement si elle est diff√©rente de la pr√©c√©dente
function _pushStep(arr, line){
  if (!line) return;
  const cur = _normLine(line);
  const prev = _normLine(arr.length ? arr[arr.length-1] : '');
  if (cur !== prev) arr.push(line);
}


// rend des <p>‚Ä¶</p> sans .join()
function _renderParas(lines){
  let html = '';
  for (const L of lines){ if (L) html += `<p>${L}</p>`; }
  return html;
}

function parseSingletonSet(s, parseNum){
  s = normalizeMinus(String(s||'')).trim();
  const m = s.match(/^\{\s*([^}]+)\s*\}$/);  // exige { ‚Ä¶ }
  if(!m) return {ok:false};
  const n = parseNum(m[1]);
  return (isFinite(n)) ? {ok:true, value:n} : {ok:false};
}





// helper unique pour √©tiquettes de facteurs : JAMAIS "x - -5"
const factorTeX = x => `x ${x<0 ? '+' : '‚àí'} ${Math.abs(x)}`;   // ex. x + 5  ou  x ‚àí 3


// --- Parse un ensemble de la forme ]a;b[ U [c;d] ...
function parseIntervals(txt){
  const t = String(txt).replace(/\s+/g,'').replace(/[‚àí‚Äì‚Äî]/g,'-');
  if (!t) return [];
  const parts = t.split(/‚à™|U|u/).filter(Boolean);
  const toNum = s=>{
    if (s==='-‚àû'||s==='-oo') return -Infinity;
    if (s==='+‚àû'||s==='+oo') return +Infinity;
    if (/^[+-]?\d+\/\d+$/.test(s)){ const [p,q]=s.split('/').map(Number); return p/q; }
    return Number(s.replace(',','.'));
  };
  const out=[];
  for (const p of parts){
    const L = p[0], R = p[p.length-1];
    const inner = p.slice(1,-1);
    const k = inner.indexOf(';'); if (k<0) continue;
    const A = toNum(inner.slice(0,k));
    const B = toNum(inner.slice(k+1));
    out.push({A,B,L,R}); // L: '['=ferm√©, ']'=ouvert ; R: ']'=ferm√©, '['=ouvert
  }
  return out;
}
// x appartient-il √† l‚Äôunion U ?
function inU(x,U){
  for (const I of U){
    const okL = (I.L===']'? x> I.A : x>= I.A); // ']' = ouvert √† gauche
    const okR = (I.R==='['? x< I.B : x<= I.B); // '[' = ouvert √† droite
    if (okL && okR) return true;
  }
  return false;
}
// Compare ¬´ ensemble saisi ¬ª vs ¬´ ensemble attendu ¬ª en testant des points
function sameSet(userIntervals, expectedIntervals, testPoints){
  for (const x of testPoints){
    if (inU(x,userIntervals) !== inU(x,expectedIntervals)) return false;
  }
  return true;
}

/* ====== G√©n√©rateur d‚Äôexos ====== */
const REGISTRY_MAP = {


/* ------------------------------------------------------------------ *
 * EX 2 ‚Äî In√©quation : produit de deux affines  (m1x+p1)(m2x+p2) ‚àò 0
 * ------------------------------------------------------------------ */
ex1: {
  name: "R√©soudre une in√©quation avec tableau de signes (m1x+p1)(m2x+p2)",
  lead: "Compl√©ter le tableau de signes puis r√©soudre l‚Äôin√©quation.",
  gen(){
    const choice = a => a[Math.floor(Math.random()*a.length)];
    const rint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

    // a ‚àà Z\{0}; m1,m2 ‚àà Z\{0}; p1,p2 ‚àà Z ; on √©vite m√™mes racines
    const a  = 1;
    let m1 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let m2 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let p1 = rint(-9,9), p2 = rint(-9,9);

    // racines r = -p/m (rationnelles)
    const R = (p,q)=>{ // r√©duction
      const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
      if(q<0){p=-p;q=-q}
      const d=g(p,q); return {p: p/d, q: q/d};
    };
    const r1 = R(-p1, m1), r2 = R(-p2, m2);
    const sameRoot = (r1.p===r2.p && r1.q===r2.q);
    if (sameRoot){ // force des racines distinctes
      p2 += (p2>=0?1:-1);
    }

    const cmp = choice(['<','>','‚â§','‚â•']);
	// apr√®s avoir fix√© a, m1, p1, m2, p2, cmp‚Ä¶
const ord1 = Math.random() < .5 ? 'mxp' : 'pmx';
const ord2 = Math.random() < .5 ? 'mxp' : 'pmx';
this.state = { a, m1, p1, m2, p2, cmp, ord1, ord2 };

    this.render(HOST, this.state);
  },

  render(host, st){
    const hasA = st.a!==1;

    // helpers d‚Äôaffichage
// remplace ton ancien affTeX ou ajoute cette version √† c√¥t√©
function affTeX(m, p, ord = 'mxp'){
  const mterm = (m===1) ? 'x' : (m===-1) ? '‚àíx' : `${m}x`;
  const ppos  = `${Math.abs(p)}`;

  if (ord === 'mxp'){                 // forme "mx ¬± p"
    if (p === 0) return mterm;
    return `${mterm} ${p>0 ? '+' : '‚àí'} ${ppos}`;
  } else {                            // forme "p ¬± mx"
    if (p === 0) return mterm;        // jamais "+ 0"
    const lead = (p>0) ? `${ppos}` : `‚àí ${ppos}`;  // pas de "+k" en t√™te
    if (m > 0) return `${lead} + ${m===1?'x':`${m}x`}`;
    // m < 0
    return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
  }
}

    const latexFracLead = (p,q)=>{
      // signe global devant \dfrac ; entier si q=1
      if (q===1) return String(p);
      const s = (p*q<0)?'‚àí':'';
      const P=Math.abs(p), Q=Math.abs(q);
      return `${s}\\dfrac{${P}}{${Q}}`;
    };
    const rootOf = (m,p)=>({ p:-p, q:m }); // racine = -p/m (non r√©duite)
    const red = (num,den)=>{ const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
      if(den<0){num=-num;den=-den} const d=g(num,den); return {p:num/d,q:den/d}; };

    // racines r√©duites
    const rA = red(-st.p1, st.m1);
    const rB = red(-st.p2, st.m2);
    // ordre croissant
    const vA = rA.p / rA.q, vB = rB.p / rB.q;
    const left  = (vA<=vB) ? {lab:rA, who:'F1'} : {lab:rB, who:'F2'};
    const right = (vA<=vB) ? {lab:rB, who:'F2'} : {lab:rA, who:'F1'};
    const rL = left.lab, rR = right.lab;

    // \[ a(m1x+p1)(m2x+p2) \]
    const A = (st.a===1?'':st.a===-1?'‚àí':'\\, '+st.a+'\\, ');
    const fx = `${A}\\big(${affTeX(st.m1, st.p1, st.ord1)
}\\big)\\big(${affTeX(st.m2, st.p2, st.ord2)}\\big)`;
    const cmp2tex = c=>({ '<':'\\;<\\;', '‚â§':'\\;\\le\\;', '>':'\\;>\\;', '‚â•':'\\;\\ge\\;' }[c]);

    // üîí pour le PDF (#equ cach√© √† l‚Äô√©cran)
    setEqu(`R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`);
    (this.state||(this.state={}))._equForPDF = `R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`;

    // S√©lecteurs
    const select = id => `<select id="${id}">
      <option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option>
    </select><span class="tick" id="tk_${id}"></span>`;
    const zsel  = id => `<select id="${id}">
      <option value=""></option><option value="0">0</option>
    </select><span class="tick" id="tk_${id}"></span>`;

    // t√™te : x, -inf, rL, (int), rR, +inf
  // t√™te : x, -inf, r1 (input), (int), r2 (input), +inf
const rowHdr = `
  <tr>
    <th>\\(x\\)</th>
    <td class="L">\\(-\\infty\\)</td>
    <td class="mid">
      <div class="midv">
        <input id="r1" style="width:80px;text-align:center">
        <span class="tick" id="tk_r1"></span>
      </div>
    </td>
    <td></td>
    <td class="mid">
      <div class="midv">
        <input id="r2" style="width:80px;text-align:center">
        <span class="tick" id="tk_r2"></span>
      </div>
    </td>
    <td class="R">\\(+\\infty\\)</td>
  </tr>`;


    // lignes
    const rowA = hasA ? `
      <tr class="sf-row-a">
        <th>\\(${st.a}\\)</th>
        <td class="mid"><div class="midv">${select('A_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('A_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('A_R')}</div></td>
      </tr>` : '';

    const rowF1 = `
      <tr class="sf-row-factor">
        <th>\\(${affTeX(st.m1, st.p1, st.ord1)
}\\)</th>
        <td class="mid"><div class="midv">${select('F1_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F1_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('F1_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F1_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('F1_R')}</div></td>
      </tr>`;

    const rowF2 = `
      <tr class="sf-row-factor">
        <th>\\(${affTeX(st.m2, st.p2, st.ord2)}\\)</th>
        <td class="mid"><div class="midv">${select('F2_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F2_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('F2_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F2_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('F2_R')}</div></td>
      </tr>`;

    const rowFx = `
      <tr class="sf-row-fx">
        <th>\\(f(x)\\)</th>
        <td class="mid"><div class="midv">${select('FX_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('FX_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('FX_R')}</div></td>
      </tr>`;

    const tableHTML = `
      <table class="pdf-tbl sign4 sign-live" style="width:auto">
        <colgroup>
          <col class="col-lbl"><col class="col-int"><col class="col-zero">
          <col class="col-int"><col class="col-zero"><col class="col-int">
        </colgroup>
        <thead>${rowHdr}</thead>
        <tbody>${rowA}${rowF1}${rowF2}${rowFx}</tbody>
      </table>`;

    // UI sp√©cifique
    removeDefaultAnswerRow();
    let body = $('#ex9_body', host);
    if (!body) {
      body = document.createElement('div');
      body.id = 'ex9_body';
      const equEl = $('#equ', host);
      (equEl?.parentNode || host).insertBefore(body, equEl?.nextSibling || null);
    }

    body.innerHTML = `
      <div>
        \\(${fx}\\)
        <select id="cmpSel" style="margin-left:.4rem">
          <option value="<"${st.cmp=='<'?' selected':''}>&lt; 0</option>
          <option value="‚â§"${st.cmp=='‚â§'?' selected':''}>‚â§ 0</option>
          <option value=">"${st.cmp=='>'?' selected':''}>&gt; 0</option>
          <option value="‚â•"${st.cmp=='‚â•'?' selected':''}>‚â• 0</option>
        </select>
      </div>
      ${tableHTML}
      <div class="vecrow pdf-hide" style="margin:.5rem 0 .25rem 0">
        <span>\\(S=\\)</span>
        <input id="ex9_S" style="width:360px" placeholder="">
        <span class="tick" id="tk_set9"></span>
      </div>
      <div id="ex9_hint" class="hint"></div>
    `;

    $('#cmpSel',host).addEventListener('change', e=>{
      st.cmp = e.target.value;
      this.state.cmp = st.cmp;
      this.state._equForPDF = `R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`;
      setEqu(this.state._equForPDF);
      this.solution(host, this.state);
      retypeset(host);
    });

    retypeset(host);

    // === V√©rification
this.verify = ()=>{
  const v = id => ($('#'+id,HOST)?.value||'').trim();
  const setTick = (id, kind)=>{ const el=$('#'+id,HOST); if(!el) return; el.className='tick '+(kind||''); el.textContent = kind==='ok'?'‚úì':kind==='ko'?'‚úó':''; };

  let tots=0, oks=0;

  // ===== racines r√©duites et ordre =====
  const red = (num,den)=>{ const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1}; if(den<0){num=-num;den=-den} const d=g(num,den); return {p:num/d,q:den/d}; };
  const rA = red(-this.state.p1, this.state.m1);
  const rB = red(-this.state.p2, this.state.m2);
  const vA = rA.p/rA.q, vB = rB.p/rB.q;
  const rL = (vA<=vB)? rA : rB, rR = (vA<=vB)? rB : rA;
  const want1 = rL.p/rL.q, want2 = rR.p/rR.q;

  // t√™tes (inputs r1, r2)
  if (v('r1')!==''){ tots++; const ok=Math.abs(parseNumber(v('r1'))-want1)<1e-9; oks+=ok; setTick('tk_r1', ok?'ok':'ko'); } else setTick('tk_r1','');
  if (v('r2')!==''){ tots++; const ok=Math.abs(parseNumber(v('r2'))-want2)<1e-9; oks+=ok; setTick('tk_r2', ok?'ok':'ko'); } else setTick('tk_r2','');

  // ===== lignes F1 / F2 : signes attendus
  const signLeft  = m => (m>0?'‚àí':'+');
  const signRight = m => (m>0?'+':'‚àí');

  const fSmall = (vA<=vB)? 'F1':'F2';
  const s1_L = signLeft(this.state.m1);
  const s1_R = signRight(this.state.m1);
  const s1_M = (fSmall==='F1') ? (this.state.m1>0?'+':'‚àí') : (this.state.m1>0?'‚àí':'+');

  const s2_L = signLeft(this.state.m2);
  const s2_R = signRight(this.state.m2);
  const s2_M = (fSmall==='F2') ? (this.state.m2>0?'+':'‚àí') : (this.state.m2>0?'‚àí':'+');

  const chk = (id, want)=>{ const got=v(id); if(got===''){ setTick('tk_'+id,''); return; } tots++; const ok=(got===want); oks+=ok; setTick('tk_'+id, ok?'ok':'ko'); };

  // F1
  chk('F1_L',s1_L); chk('F1_M',s1_M); chk('F1_R',s1_R);
  chk('F1_Z1', fSmall==='F1'?'0':''); chk('F1_Z2', fSmall==='F1'?'' :'0');
  // F2
  chk('F2_L',s2_L); chk('F2_M',s2_M); chk('F2_R',s2_R);
  chk('F2_Z1', fSmall==='F2'?'0':''); chk('F2_Z2', fSmall==='F2'?'' :'0');

  // ===== f(x) (ici a=+1) =====
  const mulSign = (...ss)=> (ss.filter(s=>s==='‚àí').length%2===0)?'+':'‚àí';
  const fL = mulSign(s1_L, s2_L);
  const fM = mulSign(s1_M, s2_M);
  const fR = mulSign(s1_R, s2_R);
  chk('FX_L',fL); chk('FX_M',fM); chk('FX_R',fR);
  chk('FX_Z1','0'); chk('FX_Z2','0');

  // ====== V√©rif S ‚Äî s√©mantique via parseIntervals ======
  const incl    = (this.state.cmp==='‚â§'||this.state.cmp==='‚â•');
  const wantPos = (this.state.cmp==='>'||this.state.cmp==='‚â•');

  const valAt = [want1, want2];
  // construit l'ensemble attendu EX comme union de segments qui matchent le signe voulu
  const EX = [];
  const pushSeg = (AL, AR, segSign)=>{
    if (wantPos ? segSign==='+' : segSign==='‚àí'){
      const A = (AL===null) ? -Infinity : valAt[AL];
      const B = (AR===null) ? +Infinity : valAt[AR];
      const L = (AL!==null && incl) ? '[' : ']';   // bornes = z√©ros du num√©rateur ‚Üí ferm√©es si incl
      const R = (AR!==null && incl) ? ']' : '[';
      EX.push({A,B,L,R});
    }
  };
  pushSeg(null, 0, fL);
  pushSeg(0,    1, fM);
  pushSeg(1,  null, fR);

  const U = parseIntervals($('#ex9_S',HOST)?.value||'');
  if (($('#ex9_S',HOST)?.value||'').trim()!==''){
    tots++;
    const tests = [ valAt[0]-1, valAt[0], (valAt[0]+valAt[1])/2, valAt[1], valAt[1]+1 ];
    const ok = sameSet(U, EX, tests);
    oks += ok; setTick('tk_set9', ok?'ok':'ko');
  } else setTick('tk_set9','');

  const filled = (tots>0);
  setFB(filled ? (oks===tots) : null, filled ? `${oks} / ${tots}` : '');
  return (filled && oks===tots);
};

  },

  solution(host, st){
  const box = $('#res',host); if(!box) return;

  // Affichage d‚Äôune affine m x + p (sans 1x/‚àí1x et sans +0)
function affTeX(m, p, ord = 'mxp'){
  const mterm = (m===1) ? 'x' : (m===-1) ? '‚àíx' : `${m}x`;
  const ppos  = `${Math.abs(p)}`;

  if (ord === 'mxp'){                 // mx ¬± p
    if (p === 0) return mterm;
    return `${mterm} ${p>0 ? '+' : '‚àí'} ${ppos}`;
  } else {                            // p ¬± mx
    if (p === 0) return mterm;        // jamais ‚Äú+ 0‚Äù
    const lead = (p>0) ? `${ppos}` : `‚àí ${ppos}`;  // pas de ‚Äú+k‚Äù en t√™te
    if (m > 0) return `${lead} + ${m===1?'x':`${m}x`}`;
    return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
  }
}


  // R√©duction fraction (num/den) + normalisation de signe (‚àí devant)
  const red = (num,den)=>{
    const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
    if(den<0){num=-num;den=-den}
    const d=g(num,den);
    return {p:num/d, q:den/d};
  };
  // \frac avec signe global devant ; entier si q=1
  const frac = (r)=> r.q===1 ? String(r.p)
    : `${(r.p*r.q<0)?'‚àí':''}\\dfrac{${Math.abs(r.p)}}{${Math.abs(r.q)}}`;

  // Racines r√©duites : rA=-p1/m1 , rB=-p2/m2
  const rA = red(-st.p1, st.m1), rB = red(-st.p2, st.m2);
  const vA = rA.p/rA.q, vB = rB.p/rB.q;
  const rL = (vA<=vB)? rA : rB;
  const rR = (vA<=vB)? rB : rA;

  // Signes des lignes
  const sA = st.a>0?'+':'‚àí';                    // signe de a
  const s1pos = st.m1>0?'+':'‚àí';
  const s2pos = st.m2>0?'+':'‚àí';
  const s1_L = (st.m1>0)?'‚àí':'+';
  const s1_R = (st.m1>0)?'+':'‚àí';
  const s2_L = (st.m2>0)?'‚àí':'+';
  const s2_R = (st.m2>0)?'+':'‚àí';
  // Signe sur l‚Äôintervalle central, selon qui porte la petite / grande racine
  const s1_M = (vA<=vB) ? s1pos : (s1pos==='+'?'‚àí':'+');
  const s2_M = (vB<=vA) ? s2pos : (s2pos==='+'?'‚àí':'+');

  const mul = (...ss)=> (ss.filter(s=>s==='‚àí').length%2===0)?'+':'‚àí';
  // ‚ö†Ô∏è On n‚Äôignore a que si a==+1 (ligne masqu√©e ET produit comme si ¬´ + ¬ª)
  const useAInProduct = (st.a !== 1);
  const fL = mul(useAInProduct?sA:'+', s1_L, s2_L);
  const fM = mul(useAInProduct?sA:'+', s1_M, s2_M);
  const fR = mul(useAInProduct?sA:'+', s1_R, s2_R);

  // Ligne du tableau
  const row = (lbl, Ls, z1, Ms, z2, Rs) => `
    <tr>
      <th>${lbl}</th>
      <td class="mid"><div class="midv"><b>${Ls}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z1?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${Ms}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z2?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${Rs}</b></div></td>
    </tr>`;

  // Table corrig√©e (ligne a masqu√©e SEULEMENT si a=+1 ; visible si a=-1)
  const tableHTML = `
    <table class="pdf-tbl" style="width:auto; margin-top:.35rem">
      <thead>
        <tr>
          <th>\\(x\\)</th>
          <td>\\(-\\infty\\)</td>
          <td class="C zbar">\\(${frac(rL)}\\)</td>
          <td></td>
          <td class="C zbar">\\(${frac(rR)}\\)</td>
          <td>\\(+\\infty\\)</td>
        </tr>
      </thead>
      <tbody>
        ${(st.a!==1) ? row(`\\(${st.a}\\)`, sA, false, sA, false, sA) : ''}  <!-- visible si a=-1 -->
        ${row(`\\(${affTeX(st.m1, st.p1, st.ord1)
}\\)`, s1_L, (vA<=vB), s1_M, (vB<=vA), s1_R)}
        ${row(`\\(${affTeX(st.m2, st.p2, st.ord2)}\\)`, s2_L, (vB<=vA), s2_M, (vA<=vB), s2_R)}
        ${row('\\(f(x)\\)', fL, true, fM, true, fR)}
      </tbody>
    </table>`;

  // √âtapes √©quation mx+p=0 ‚Üí mx=-p ‚Üí x=(-p)/m (sans ‚Äú= +k‚Äù)
  // Utilise fracStepsLatex(p,q) d√©j√† d√©fini dans ton fichier
function makeEqSteps(m, p, ord){
  const L1 = `\\(${affTeX(m,p,ord)} = 0\\)`;   // d√©part fid√®le √† l‚Äô√©nonc√©

  // mx = -p (sans ‚Äú= +k‚Äù)
  const mleft = (m===1)?'x' : (m===-1)?'‚àíx' : m+'x';
  let rhs2;
  if (p===0)      rhs2 = '0';
  else if (p<0)   rhs2 = `${Math.abs(p)}`;   // -(-k) = k
  else            rhs2 = `‚àí\\,${p}`;

  const L2 = `\\(${mleft} = ${rhs2}\\)`;

  // x = (-p)/m (r√©duction + signe global)
  let L3;
  if (m===1){
    L3 = `\\( x = ${ p===0 ? '0' : (p<0 ? String(Math.abs(p)) : `‚àí${p}`) } \\)`;
  } else if (m===-1){
    L3 = `\\( x = ${ p } \\)`;
  } else {
    const steps = fracStepsLatex(-p, m);   // d√©j√† dispo dans ton fichier
    L3 = (steps.length===1)
      ? `\\( x = ${steps[0]} \\)`
      : `\\( x = ${steps[1]} \\)`;
  }
  return [L1, L2, L3];
}

// et plus bas :
const leftSteps  = makeEqSteps(st.m1, st.p1, st.ord1);
const rightSteps = makeEqSteps(st.m2, st.p2, st.ord2);



  const nbRows = Math.max(leftSteps.length, rightSteps.length);
  let eqRowsHTML = '';
  for (let i=0;i<nbRows;i++){
    const L = leftSteps[i]  ? `<div>${leftSteps[i]}</div>`  : '';
    const R = rightSteps[i] ? `<div>${rightSteps[i]}</div>` : '';
    const OU = (L||R) ? `\\(\\text{ou}\\)` : '';
    eqRowsHTML += `
      <tr>
        <td style="vertical-align:top; padding:4px 10px; border:none;">${L}</td>
        <td style="vertical-align:top; padding:4px 10px; border:none; text-align:center; ">${OU}</td>
        <td style="vertical-align:top; padding:4px 10px; border:none;">${R}</td>
      </tr>`;
  }
  const eqTable = `
    <table style=" margin:.2rem 0;">
      <tbody>${eqRowsHTML}</tbody>
    </table>`;

  // Conclusion selon le signe au centre et l‚Äôinclusion du comparateur
  const cmp2tex = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);
  const incl = (st.cmp==='‚â§'||st.cmp==='‚â•');
const wantInside = (st.cmp==='<'||st.cmp==='‚â§') ? (fM==='‚àí') : (fM==='+');
  const S = wantInside
    ? `${incl?'\\left[':'\\left]'} ${frac(rL)} \\;;\\; ${frac(rR)} ${incl?'\\right]':'\\right['}`
    : `${incl?'\\left]':'\\left]'} -\\infty \\;;\\; ${frac(rL)} ${incl?'\\right]':'\\right['} \\;\\cup\\; ${incl?'\\left[':'\\left]'} ${frac(rR)} \\;;\\; +\\infty \\right[`;

  box.innerHTML = `
    <div class="step"><b>√âquation associ√©e (produit nul).</b>
      ${eqTable}
    </div>
    <div class="step"><b>Tableau de signes.</b>${tableHTML}</div>
    <div class="step"><b>Conclusion.</b>
      \\(f(x) ${cmp2tex(st.cmp)} 0\\;\\Rightarrow\\; S = ${S}\\).
    </div>`;
  retypeset(host);
}
},



/* ------------------------------------------------------------------ *
 * EX 2 ‚Äî In√©quation : produit de deux affines  a(m1x+p1)(m2x+p2) ‚àò 0
 * ------------------------------------------------------------------ */
ex2: {
  name: "R√©soudre une in√©quation avec tableau de signes a(m1x+p1)(m2x+p2)",
  lead: "Compl√©ter le tableau de signes puis r√©soudre l‚Äôin√©quation.",
  gen(){
    const choice = a => a[Math.floor(Math.random()*a.length)];
    const rint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

    // a ‚àà Z\{0}; m1,m2 ‚àà Z\{0}; p1,p2 ‚àà Z ; on √©vite m√™mes racines
    const a  = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);
    let m1 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let m2 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let p1 = rint(-9,9), p2 = rint(-9,9);

    // racines r = -p/m (rationnelles)
    const R = (p,q)=>{ // r√©duction
      const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
      if(q<0){p=-p;q=-q}
      const d=g(p,q); return {p: p/d, q: q/d};
    };
    const r1 = R(-p1, m1), r2 = R(-p2, m2);
    const sameRoot = (r1.p===r2.p && r1.q===r2.q);
    if (sameRoot){ // force des racines distinctes
      p2 += (p2>=0?1:-1);
    }

    const cmp = choice(['<','>','‚â§','‚â•']);
	// apr√®s avoir fix√© a, m1, p1, m2, p2, cmp‚Ä¶
const ord1 = Math.random() < .5 ? 'mxp' : 'pmx';
const ord2 = Math.random() < .5 ? 'mxp' : 'pmx';
this.state = { a, m1, p1, m2, p2, cmp, ord1, ord2 };

    this.render(HOST, this.state);
  },

  render(host, st){
    const hasA = st.a!==1;

    // helpers d‚Äôaffichage
// remplace ton ancien affTeX ou ajoute cette version √† c√¥t√©
function affTeX(m, p, ord = 'mxp'){
  const mterm = (m===1) ? 'x' : (m===-1) ? '‚àíx' : `${m}x`;
  const ppos  = `${Math.abs(p)}`;

  if (ord === 'mxp'){                 // forme "mx ¬± p"
    if (p === 0) return mterm;
    return `${mterm} ${p>0 ? '+' : '‚àí'} ${ppos}`;
  } else {                            // forme "p ¬± mx"
    if (p === 0) return mterm;        // jamais "+ 0"
    const lead = (p>0) ? `${ppos}` : `‚àí ${ppos}`;  // pas de "+k" en t√™te
    if (m > 0) return `${lead} + ${m===1?'x':`${m}x`}`;
    // m < 0
    return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
  }
}

    const latexFracLead = (p,q)=>{
      // signe global devant \dfrac ; entier si q=1
      if (q===1) return String(p);
      const s = (p*q<0)?'‚àí':'';
      const P=Math.abs(p), Q=Math.abs(q);
      return `${s}\\dfrac{${P}}{${Q}}`;
    };
    const rootOf = (m,p)=>({ p:-p, q:m }); // racine = -p/m (non r√©duite)
    const red = (num,den)=>{ const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
      if(den<0){num=-num;den=-den} const d=g(num,den); return {p:num/d,q:den/d}; };

    // racines r√©duites
    const rA = red(-st.p1, st.m1);
    const rB = red(-st.p2, st.m2);
    // ordre croissant
    const vA = rA.p / rA.q, vB = rB.p / rB.q;
    const left  = (vA<=vB) ? {lab:rA, who:'F1'} : {lab:rB, who:'F2'};
    const right = (vA<=vB) ? {lab:rB, who:'F2'} : {lab:rA, who:'F1'};
    const rL = left.lab, rR = right.lab;

    // \[ a(m1x+p1)(m2x+p2) \]
    const A = (st.a===1?'':st.a===-1?'‚àí':'\\, '+st.a+'\\, ');
    const fx = `${A}\\big(${affTeX(st.m1, st.p1, st.ord1)
}\\big)\\big(${affTeX(st.m2, st.p2, st.ord2)}\\big)`;
    const cmp2tex = c=>({ '<':'\\;<\\;', '‚â§':'\\;\\le\\;', '>':'\\;>\\;', '‚â•':'\\;\\ge\\;' }[c]);

    // üîí pour le PDF (#equ cach√© √† l‚Äô√©cran)
    setEqu(`R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`);
    (this.state||(this.state={}))._equForPDF = `R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`;

    // S√©lecteurs
    const select = id => `<select id="${id}">
      <option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option>
    </select><span class="tick" id="tk_${id}"></span>`;
    const zsel  = id => `<select id="${id}">
      <option value=""></option><option value="0">0</option>
    </select><span class="tick" id="tk_${id}"></span>`;

    // t√™te : x, -inf, rL, (int), rR, +inf
  // t√™te : x, -inf, r1 (input), (int), r2 (input), +inf
const rowHdr = `
  <tr>
    <th>\\(x\\)</th>
    <td class="L">\\(-\\infty\\)</td>
    <td class="mid">
      <div class="midv">
        <input id="r1" style="width:80px;text-align:center">
        <span class="tick" id="tk_r1"></span>
      </div>
    </td>
    <td></td>
    <td class="mid">
      <div class="midv">
        <input id="r2" style="width:80px;text-align:center">
        <span class="tick" id="tk_r2"></span>
      </div>
    </td>
    <td class="R">\\(+\\infty\\)</td>
  </tr>`;


    // lignes
    const rowA = hasA ? `
      <tr class="sf-row-a">
        <th>\\(${st.a}\\)</th>
        <td class="mid"><div class="midv">${select('A_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('A_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('A_R')}</div></td>
      </tr>` : '';

    const rowF1 = `
      <tr class="sf-row-factor">
        <th>\\(${affTeX(st.m1, st.p1, st.ord1)
}\\)</th>
        <td class="mid"><div class="midv">${select('F1_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F1_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('F1_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F1_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('F1_R')}</div></td>
      </tr>`;

    const rowF2 = `
      <tr class="sf-row-factor">
        <th>\\(${affTeX(st.m2, st.p2, st.ord2)}\\)</th>
        <td class="mid"><div class="midv">${select('F2_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F2_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('F2_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('F2_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('F2_R')}</div></td>
      </tr>`;

    const rowFx = `
      <tr class="sf-row-fx">
        <th>\\(f(x)\\)</th>
        <td class="mid"><div class="midv">${select('FX_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('FX_M')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('FX_R')}</div></td>
      </tr>`;

    const tableHTML = `
      <table class="pdf-tbl sign4 sign-live" style="width:auto">
        <colgroup>
          <col class="col-lbl"><col class="col-int"><col class="col-zero">
          <col class="col-int"><col class="col-zero"><col class="col-int">
        </colgroup>
        <thead>${rowHdr}</thead>
        <tbody>${rowA}${rowF1}${rowF2}${rowFx}</tbody>
      </table>`;

    // UI sp√©cifique
    removeDefaultAnswerRow();
    let body = $('#ex9_body', host);
    if (!body) {
      body = document.createElement('div');
      body.id = 'ex9_body';
      const equEl = $('#equ', host);
      (equEl?.parentNode || host).insertBefore(body, equEl?.nextSibling || null);
    }

    body.innerHTML = `
      <div>
        \\(${fx}\\)
        <select id="cmpSel" style="margin-left:.4rem">
          <option value="<"${st.cmp=='<'?' selected':''}>&lt; 0</option>
          <option value="‚â§"${st.cmp=='‚â§'?' selected':''}>‚â§ 0</option>
          <option value=">"${st.cmp=='>'?' selected':''}>&gt; 0</option>
          <option value="‚â•"${st.cmp=='‚â•'?' selected':''}>‚â• 0</option>
        </select>
      </div>
      ${tableHTML}
      <div class="vecrow pdf-hide" style="margin:.5rem 0 .25rem 0">
        <span>\\(S=\\)</span>
        <input id="ex9_S" style="width:360px" placeholder="">
        <span class="tick" id="tk_set9"></span>
      </div>
      <div id="ex9_hint" class="hint"></div>
    `;

    $('#cmpSel',host).addEventListener('change', e=>{
      st.cmp = e.target.value;
      this.state.cmp = st.cmp;
      this.state._equForPDF = `R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`;
      setEqu(this.state._equForPDF);
      this.solution(host, this.state);
      retypeset(host);
    });

    retypeset(host);

    // === V√©rification
   this.verify = ()=>{
  const v = id => ($('#'+id,HOST)?.value||'').trim();
  const setTick = (id, kind)=>{ const el=$('#'+id,HOST); if(!el) return; el.className='tick '+(kind||''); el.textContent = kind==='ok'?'‚úì':kind==='ko'?'‚úó':''; };

  let tots=0, oks=0;
  const hasA = this.state.a!==1;

  // ===== racines r√©duites et ordre =====
  const red = (num,den)=>{ const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1}; if(den<0){num=-num;den=-den} const d=g(num,den); return {p:num/d,q:den/d}; };
  const rA = red(-this.state.p1, this.state.m1);
  const rB = red(-this.state.p2, this.state.m2);
  const vA = rA.p/rA.q, vB = rB.p/rB.q;
  const rL = (vA<=vB)? rA : rB, rR = (vA<=vB)? rB : rA;
  const want1 = rL.p/rL.q, want2 = rR.p/rR.q;

  // t√™tes
  if (v('r1')!==''){ tots++; const ok=Math.abs(parseNumber(v('r1'))-want1)<1e-9; oks+=ok; setTick('tk_r1', ok?'ok':'ko'); } else setTick('tk_r1','');
  if (v('r2')!==''){ tots++; const ok=Math.abs(parseNumber(v('r2'))-want2)<1e-9; oks+=ok; setTick('tk_r2', ok?'ok':'ko'); } else setTick('tk_r2','');

  // util coche
  const chk = (id, want)=>{ const got=v(id); if(got===''){ setTick('tk_'+id,''); return; } tots++; const ok=(got===want); oks+=ok; setTick('tk_'+id, ok?'ok':'ko'); };

  // a
  const sA = this.state.a>0?'+':'‚àí';
  if (hasA){ chk('A_L',sA); chk('A_M',sA); chk('A_R',sA); chk('A_Z1',''); chk('A_Z2',''); }

  // signes F1/F2
  const signLeft  = m => (m>0?'‚àí':'+');
  const signRight = m => (m>0?'+':'‚àí');
  const fSmall = (vA<=vB)? 'F1':'F2';

  const s1_L = signLeft(this.state.m1);
  const s1_R = signRight(this.state.m1);
  const s1_M = (fSmall==='F1') ? (this.state.m1>0?'+':'‚àí') : (this.state.m1>0?'‚àí':'+');

  const s2_L = signLeft(this.state.m2);
  const s2_R = signRight(this.state.m2);
  const s2_M = (fSmall==='F2') ? (this.state.m2>0?'+':'‚àí') : (this.state.m2>0?'‚àí':'+');

  // coche F1/F2
  chk('F1_L',s1_L); chk('F1_M',s1_M); chk('F1_R',s1_R);
  chk('F1_Z1', fSmall==='F1'?'0':''); chk('F1_Z2', fSmall==='F1'?'' :'0');

  chk('F2_L',s2_L); chk('F2_M',s2_M); chk('F2_R',s2_R);
  chk('F2_Z1', fSmall==='F2'?'0':''); chk('F2_Z2', fSmall==='F2'?'' :'0');

  // f(x)
  const mulSign = (...ss)=> (ss.filter(s=>s==='‚àí').length%2===0)?'+':'‚àí';
  const fL = mulSign(hasA?sA:'+', s1_L, s2_L);
  const fM = mulSign(hasA?sA:'+', s1_M, s2_M);
  const fR = mulSign(hasA?sA:'+', s1_R, s2_R);
  chk('FX_L',fL); chk('FX_M',fM); chk('FX_R',fR);
  chk('FX_Z1','0'); chk('FX_Z2','0');

  // ====== V√©rif S ‚Äî s√©mantique ======
  const incl    = (this.state.cmp==='‚â§'||this.state.cmp==='‚â•');
  const wantPos = (this.state.cmp==='>'||this.state.cmp==='‚â•');
  const valAt = [want1, want2];

  const EX = [];
  const pushSeg = (AL, AR, segSign)=>{
    if (wantPos ? segSign==='+' : segSign==='‚àí'){
      const A = (AL===null) ? -Infinity : valAt[AL];
      const B = (AR===null) ? +Infinity : valAt[AR];
      const L = (AL!==null && incl) ? '[' : ']';   // z√©ros du num√©rateur ‚Üí ferm√©s si incl
      const R = (AR!==null && incl) ? ']' : '[';
      EX.push({A,B,L,R});
    }
  };
  pushSeg(null, 0, fL);
  pushSeg(0,    1, fM);
  pushSeg(1,  null, fR);

  const Sraw = $('#ex9_S',HOST)?.value.trim() || '';
  if (Sraw!==''){
    tots++;
    const U = parseIntervals(Sraw);
    const tests = [ valAt[0]-1, valAt[0], (valAt[0]+valAt[1])/2, valAt[1], valAt[1]+1 ];
    const ok = sameSet(U, EX, tests);
    oks += ok; setTick('tk_set9', ok?'ok':'ko');
  } else setTick('tk_set9','');

  const filled = (tots>0);
  setFB(filled ? (oks===tots) : null, filled ? `${oks} / ${tots}` : '');
  return (filled && oks===tots);
};

  },

  solution(host, st){
  const box = $('#res',host); if(!box) return;

  // Affichage d‚Äôune affine m x + p (sans 1x/‚àí1x et sans +0)
function affTeX(m, p, ord = 'mxp'){
  const mterm = (m===1) ? 'x' : (m===-1) ? '‚àíx' : `${m}x`;
  const ppos  = `${Math.abs(p)}`;

  if (ord === 'mxp'){                 // mx ¬± p
    if (p === 0) return mterm;
    return `${mterm} ${p>0 ? '+' : '‚àí'} ${ppos}`;
  } else {                            // p ¬± mx
    if (p === 0) return mterm;        // jamais ‚Äú+ 0‚Äù
    const lead = (p>0) ? `${ppos}` : `‚àí ${ppos}`;  // pas de ‚Äú+k‚Äù en t√™te
    if (m > 0) return `${lead} + ${m===1?'x':`${m}x`}`;
    return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
  }
}


  // R√©duction fraction (num/den) + normalisation de signe (‚àí devant)
  const red = (num,den)=>{
    const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
    if(den<0){num=-num;den=-den}
    const d=g(num,den);
    return {p:num/d, q:den/d};
  };
  // \frac avec signe global devant ; entier si q=1
  const frac = (r)=> r.q===1 ? String(r.p)
    : `${(r.p*r.q<0)?'‚àí':''}\\dfrac{${Math.abs(r.p)}}{${Math.abs(r.q)}}`;

  // Racines r√©duites : rA=-p1/m1 , rB=-p2/m2
  const rA = red(-st.p1, st.m1), rB = red(-st.p2, st.m2);
  const vA = rA.p/rA.q, vB = rB.p/rB.q;
  const rL = (vA<=vB)? rA : rB;
  const rR = (vA<=vB)? rB : rA;

  // Signes des lignes
  const sA = st.a>0?'+':'‚àí';                    // signe de a
  const s1pos = st.m1>0?'+':'‚àí';
  const s2pos = st.m2>0?'+':'‚àí';
  const s1_L = (st.m1>0)?'‚àí':'+';
  const s1_R = (st.m1>0)?'+':'‚àí';
  const s2_L = (st.m2>0)?'‚àí':'+';
  const s2_R = (st.m2>0)?'+':'‚àí';
  // Signe sur l‚Äôintervalle central, selon qui porte la petite / grande racine
  const s1_M = (vA<=vB) ? s1pos : (s1pos==='+'?'‚àí':'+');
  const s2_M = (vB<=vA) ? s2pos : (s2pos==='+'?'‚àí':'+');

  const mul = (...ss)=> (ss.filter(s=>s==='‚àí').length%2===0)?'+':'‚àí';
  // ‚ö†Ô∏è On n‚Äôignore a que si a==+1 (ligne masqu√©e ET produit comme si ¬´ + ¬ª)
  const useAInProduct = (st.a !== 1);
  const fL = mul(useAInProduct?sA:'+', s1_L, s2_L);
  const fM = mul(useAInProduct?sA:'+', s1_M, s2_M);
  const fR = mul(useAInProduct?sA:'+', s1_R, s2_R);

  // Ligne du tableau
  const row = (lbl, Ls, z1, Ms, z2, Rs) => `
    <tr>
      <th>${lbl}</th>
      <td class="mid"><div class="midv"><b>${Ls}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z1?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${Ms}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z2?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${Rs}</b></div></td>
    </tr>`;

  // Table corrig√©e (ligne a masqu√©e SEULEMENT si a=+1 ; visible si a=-1)
  const tableHTML = `
    <table class="pdf-tbl" style="width:auto; margin-top:.35rem">
      <thead>
        <tr>
          <th>\\(x\\)</th>
          <td>\\(-\\infty\\)</td>
          <td class="C zbar">\\(${frac(rL)}\\)</td>
          <td></td>
          <td class="C zbar">\\(${frac(rR)}\\)</td>
          <td>\\(+\\infty\\)</td>
        </tr>
      </thead>
      <tbody>
        ${(st.a!==1) ? row(`\\(${st.a}\\)`, sA, false, sA, false, sA) : ''}  <!-- visible si a=-1 -->
        ${row(`\\(${affTeX(st.m1, st.p1, st.ord1)
}\\)`, s1_L, (vA<=vB), s1_M, (vB<=vA), s1_R)}
        ${row(`\\(${affTeX(st.m2, st.p2, st.ord2)}\\)`, s2_L, (vB<=vA), s2_M, (vA<=vB), s2_R)}
        ${row('\\(f(x)\\)', fL, true, fM, true, fR)}
      </tbody>
    </table>`;

  // √âtapes √©quation mx+p=0 ‚Üí mx=-p ‚Üí x=(-p)/m (sans ‚Äú= +k‚Äù)
  // Utilise fracStepsLatex(p,q) d√©j√† d√©fini dans ton fichier
function makeEqSteps(m, p, ord){
  const L1 = `\\(${affTeX(m,p,ord)} = 0\\)`;   // d√©part fid√®le √† l‚Äô√©nonc√©

  // mx = -p (sans ‚Äú= +k‚Äù)
  const mleft = (m===1)?'x' : (m===-1)?'‚àíx' : m+'x';
  let rhs2;
  if (p===0)      rhs2 = '0';
  else if (p<0)   rhs2 = `${Math.abs(p)}`;   // -(-k) = k
  else            rhs2 = `‚àí\\,${p}`;

  const L2 = `\\(${mleft} = ${rhs2}\\)`;

  // x = (-p)/m (r√©duction + signe global)
  let L3;
  if (m===1){
    L3 = `\\( x = ${ p===0 ? '0' : (p<0 ? String(Math.abs(p)) : `‚àí${p}`) } \\)`;
  } else if (m===-1){
    L3 = `\\( x = ${ p } \\)`;
  } else {
    const steps = fracStepsLatex(-p, m);   // d√©j√† dispo dans ton fichier
    L3 = (steps.length===1)
      ? `\\( x = ${steps[0]} \\)`
      : `\\( x = ${steps[1]} \\)`;
  }
  return [L1, L2, L3];
}

// et plus bas :
const leftSteps  = makeEqSteps(st.m1, st.p1, st.ord1);
const rightSteps = makeEqSteps(st.m2, st.p2, st.ord2);



  const nbRows = Math.max(leftSteps.length, rightSteps.length);
  let eqRowsHTML = '';
  for (let i=0;i<nbRows;i++){
    const L = leftSteps[i]  ? `<div>${leftSteps[i]}</div>`  : '';
    const R = rightSteps[i] ? `<div>${rightSteps[i]}</div>` : '';
    const OU = (L||R) ? `\\(\\text{ou}\\)` : '';
    eqRowsHTML += `
      <tr>
        <td style="vertical-align:top; padding:4px 10px; border:none;">${L}</td>
        <td style="vertical-align:top; padding:4px 10px; border:none; text-align:center; ">${OU}</td>
        <td style="vertical-align:top; padding:4px 10px; border:none;">${R}</td>
      </tr>`;
  }
  const eqTable = `
    <table style=" margin:.2rem 0;">
      <tbody>${eqRowsHTML}</tbody>
    </table>`;

  // Conclusion selon le signe au centre et l‚Äôinclusion du comparateur
  const cmp2tex = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);
  const incl = (st.cmp==='‚â§'||st.cmp==='‚â•');
const wantInside = (st.cmp==='<'||st.cmp==='‚â§') ? (fM==='‚àí') : (fM==='+');
  const S = wantInside
    ? `${incl?'\\left[':'\\left]'} ${frac(rL)} \\;;\\; ${frac(rR)} ${incl?'\\right]':'\\right['}`
    : `${incl?'\\left]':'\\left]'} -\\infty \\;;\\; ${frac(rL)} ${incl?'\\right]':'\\right['} \\;\\cup\\; ${incl?'\\left[':'\\left]'} ${frac(rR)} \\;;\\; +\\infty \\right[`;

  box.innerHTML = `
    <div class="step"><b>√âquation associ√©e (produit nul).</b>
      ${eqTable}
    </div>
    <div class="step"><b>Tableau de signes.</b>${tableHTML}</div>
    <div class="step"><b>Conclusion.</b>
      \\(f(x) ${cmp2tex(st.cmp)} 0\\;\\Rightarrow\\; S = ${S}\\).
    </div>`;
  retypeset(host);
}
},

ex3: {
  name: "R√©soudre une in√©quation avec tableau de signes a(m1x+p1)(m2x+p2)(m3x+p3)",
  lead: "Compl√©ter le tableau de signes puis r√©soudre l‚Äôin√©quation.",
  gen(){
    const choice = a => a[Math.floor(Math.random()*a.length)];
    const rint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

    const a  = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);

    let m1 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let m2 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let m3 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);

    let p1 = rint(-9,9), p2 = rint(-9,9), p3 = rint(-9,9);

    // r√©duction racines et unicit√©
    const g = (x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
    const red = (num,den)=>{ if(den<0){num=-num;den=-den} const d=g(num,den); return {p:num/d,q:den/d}; };
    const sameRat = (r,s)=> r.p===s.p && r.q===s.q;

    let rA = red(-p1,m1), rB = red(-p2,m2), rC = red(-p3,m3);
    // on force 3 racines distinctes
    let guard = 0;
    while ((sameRat(rA,rB) || sameRat(rA,rC) || sameRat(rB,rC)) && guard++<50){
      p3 += (p3>=0?1:-1);
      rC = red(-p3,m3);
    }

    const cmp = choice(['<','>','‚â§','‚â•']);
    const ord1 = Math.random()<.5 ? 'mxp' : 'pmx';
    const ord2 = Math.random()<.5 ? 'mxp' : 'pmx';
    const ord3 = Math.random()<.5 ? 'mxp' : 'pmx';

    this.state = { a,m1,p1,m2,p2,m3,p3, cmp, ord1,ord2,ord3 };
    this.render(HOST, this.state);
  },

  render(host, st){
    const hasA = st.a!==1;

    function affTeX(m, p, ord='mxp'){
      const mterm = (m===1)?'x' : (m===-1)?'‚àíx' : `${m}x`;
      const P = Math.abs(p);
      if (ord==='mxp'){ if(p===0) return mterm; return `${mterm} ${p>0?'+':'‚àí'} ${P}`; }
      // p ¬± mx
      if (p===0) return mterm;
      const lead = p>0 ? `${P}` : `‚àí ${P}`;
      if (m>0) return `${lead} + ${m===1?'x':`${m}x`}`;
      return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
    }
    const red = (num,den)=>{
      const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
      if(den<0){num=-num;den=-den}
      const d=g(num,den); return {p:num/d,q:den/d};
    };
    const fracLead = r => r.q===1 ? String(r.p)
      : `${(r.p*r.q<0)?'‚àí':''}\\dfrac{${Math.abs(r.p)}}{${Math.abs(r.q)}}`;

    const r1 = red(-st.p1, st.m1), r2 = red(-st.p2, st.m2), r3 = red(-st.p3, st.m3);
    const arr = [
      {r:r1, who:'F1', m:st.m1},
      {r:r2, who:'F2', m:st.m2},
      {r:r3, who:'F3', m:st.m3},
    ].sort((A,B)=> A.r.p/A.r.q - B.r.p/B.r.q);

    const rL = arr[0], rM = arr[1], rR = arr[2];

    const A = (st.a===1?'':st.a===-1?'‚àí':'\\, '+st.a+'\\, ');
    const fx = `${A}\\big(${affTeX(st.m1,st.p1,st.ord1)}\\big)\\big(${affTeX(st.m2,st.p2,st.ord2)}\\big)\\big(${affTeX(st.m3,st.p3,st.ord3)}\\big)`;
    const cmp2tex = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);

    setEqu(`R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`);
    (this.state||(this.state={}))._equForPDF = `R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`;

    const select = id => `<select id="${id}">
      <option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option>
    </select><span class="tick" id="tk_${id}"></span>`;
    const zsel  = id => `<select id="${id}">
      <option value=""></option><option value="0">0</option>
    </select><span class="tick" id="tk_${id}"></span>`;

    // ent√™te avec 3 z√©ros √©ditables
    const rowHdr = `
      <tr>
        <th>\\(x\\)</th>
        <td class="L">\\(-\\infty\\)</td>
        <td class="mid"><div class="midv"><input id="r1" style="width:80px;text-align:center"><span class="tick" id="tk_r1"></span></div></td>
        <td></td>
        <td class="mid"><div class="midv"><input id="r2" style="width:80px;text-align:center"><span class="tick" id="tk_r2"></span></div></td>
        <td></td>
        <td class="mid"><div class="midv"><input id="r3" style="width:80px;text-align:center"><span class="tick" id="tk_r3"></span></div></td>
        <td class="R">\\(+\\infty\\)</td>
      </tr>`;

    const rowA = hasA ? `
      <tr class="sf-row-a">
        <th>\\(${st.a}\\)</th>
        <td class="mid"><div class="midv">${select('A_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('A_M1')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('A_M2')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('A_Z3')}</div></td>
        <td class="mid"><div class="midv">${select('A_R')}</div></td>
      </tr>` : '';

    const rowF = (lbl,id)=>`
      <tr class="sf-row-factor">
        <th>\\(${lbl}\\)</th>
        <td class="mid"><div class="midv">${select(id+'_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel(id+'_Z1')}</div></td>
        <td class="mid"><div class="midv">${select(id+'_M1')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel(id+'_Z2')}</div></td>
        <td class="mid"><div class="midv">${select(id+'_M2')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel(id+'_Z3')}</div></td>
        <td class="mid"><div class="midv">${select(id+'_R')}</div></td>
      </tr>`;

    const rowFx = `
      <tr class="sf-row-fx">
        <th>\\(f(x)\\)</th>
        <td class="mid"><div class="midv">${select('FX_L')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z1')}</div></td>
        <td class="mid"><div class="midv">${select('FX_M1')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z2')}</div></td>
        <td class="mid"><div class="midv">${select('FX_M2')}</div></td>
        <td class="zbar mid"><div class="midv">${zsel('FX_Z3')}</div></td>
        <td class="mid"><div class="midv">${select('FX_R')}</div></td>
      </tr>`;

    const tableHTML = `
      <table class="pdf-tbl sign4 sign-live" style="width:auto">
        <colgroup>
          <col class="col-lbl">
          <col class="col-int"><col class="col-zero">
          <col class="col-int"><col class="col-zero">
          <col class="col-int"><col class="col-zero">
          <col class="col-int">
        </colgroup>
        <thead>${rowHdr}</thead>
        <tbody>
          ${rowA}
          ${rowF(affTeX(st.m1,st.p1,st.ord1), 'F1')}
          ${rowF(affTeX(st.m2,st.p2,st.ord2), 'F2')}
          ${rowF(affTeX(st.m3,st.p3,st.ord3), 'F3')}
          ${rowFx}
        </tbody>
      </table>`;

    removeDefaultAnswerRow();
    let body = $('#ex10_body', host);
    if (!body) {
      body = document.createElement('div');
      body.id = 'ex10_body';
      const equEl = $('#equ', host);
      (equEl?.parentNode || host).insertBefore(body, equEl?.nextSibling || null);
    }

    body.innerHTML = `
      <div>
        \\(${fx}\\)
        <select id="cmpSel" style="margin-left:.4rem">
          <option value="<"${st.cmp=='<'?' selected':''}>&lt; 0</option>
          <option value="‚â§"${st.cmp=='‚â§'?' selected':''}>‚â§ 0</option>
          <option value=">"${st.cmp=='>'?' selected':''}>&gt; 0</option>
          <option value="‚â•"${st.cmp=='‚â•'?' selected':''}>‚â• 0</option>
        </select>
      </div>
      ${tableHTML}
      <div class="vecrow pdf-hide" style="margin:.5rem 0 .25rem 0">
        <span>\\(S=\\)</span>
        <input id="ex10_S" style="width:420px" placeholder="">
        <span class="tick" id="tk_set10"></span>
      </div>
      <div id="ex10_hint" class="hint"></div>
    `;

    $('#cmpSel',host).addEventListener('change', e=>{
      st.cmp = e.target.value;
      this.state.cmp = st.cmp;
      this.state._equForPDF = `R√©soudre \\( ${fx} ${cmp2tex(st.cmp)} 0 \\).`;
      setEqu(this.state._equForPDF);
      this.solution(host, this.state);
      retypeset(host);
    });

    retypeset(host);

    // ====== V√©rification ======
this.verify = ()=>{
  const v = id => ($('#'+id,HOST)?.value||'').trim();
  const setTick = (id, kind)=>{ const el=$('#'+id,HOST); if(!el) return; el.className='tick '+(kind||''); el.textContent = kind==='ok'?'‚úì':kind==='ko'?'‚úó':''; };

  let tots=0, oks=0;
  const hasA = this.state.a!==1;

  // ===== racines tri√©es =====
  const red = (num,den)=>{ const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1}; if(den<0){num=-num;den=-den} const d=g(num,den); return {p:num/d,q:den/d}; };
  const r1 = red(-this.state.p1,this.state.m1), r2 = red(-this.state.p2,this.state.m2), r3 = red(-this.state.p3,this.state.m3);
  const arr = [
    {r:r1, who:'F1', m:this.state.m1},
    {r:r2, who:'F2', m:this.state.m2},
    {r:r3, who:'F3', m:this.state.m3},
  ].sort((A,B)=> A.r.p/A.r.q - B.r.p/B.r.q);
  const rL=arr[0], rM=arr[1], rR=arr[2];
  const rvals=[rL.r.p/rL.r.q, rM.r.p/rM.r.q, rR.r.p/rR.r.q];

  // t√™tes r1..r3
  ['r1','r2','r3'].forEach((id,i)=>{
    if (v(id)!==''){ tots++; const ok=Math.abs(parseNumber(v(id))-rvals[i])<1e-9; oks+=ok; setTick('tk_'+id, ok?'ok':'ko'); }
    else setTick('tk_'+id,'');
  });

  // util coche
  const chk = (id, want)=>{ const got=v(id); if(got===''){ setTick('tk_'+id,''); return; } tots++; const ok=(got===want); oks+=ok; setTick('tk_'+id, ok?'ok':'ko'); };

  // a
  const sA = this.state.a>0?'+':'‚àí';
  if (hasA){
    ['L','M1','M2','R'].forEach(pos=>chk('A_'+pos, sA));
    ['Z1','Z2','Z3'].forEach(z=>chk('A_'+z,''));
  }

  // signes facteurs
  const signLeft  = m => (m>0?'‚àí':'+');
  const signRight = m => (m>0?'+':'‚àí');

  const M = {F1:this.state.m1, F2:this.state.m2, F3:this.state.m3};
  const whoL=rL.who, whoM=rM.who, whoR=rR.who;

  function signsOf(who){
    const m = M[who];
    return {
      L:  signLeft(m),
      M1: (who===whoL ? signRight(m) : signLeft(m)),
      M2: (who===whoR ? signLeft(m)  : signRight(m)),
      R:  signRight(m)
    };
  }
  const S1=signsOf('F1'), S2=signsOf('F2'), S3=signsOf('F3');

  // coche lignes facteurs (signes + 0 sous sa colonne)
  [['F1',S1],['F2',S2],['F3',S3]].forEach(([id,S],k)=>{
    chk(id+'_L',S.L); chk(id+'_M1',S.M1); chk(id+'_M2',S.M2); chk(id+'_R',S.R);
    chk(id+'_Z1', (whoL===('F'+(k+1)))?'0':'');
    chk(id+'_Z2', (whoM===('F'+(k+1)))?'0':'');
    chk(id+'_Z3', (whoR===('F'+(k+1)))?'0':'');
  });

  // f(x)
  const mulSign = (...ss)=> (ss.filter(s=>s==='‚àí').length%2===0)?'+':'‚àí';
  const useA = hasA ? sA : '+';
  const fL  = mulSign(useA, S1.L , S2.L , S3.L );
  const fM1 = mulSign(useA, S1.M1, S2.M1, S3.M1);
  const fM2 = mulSign(useA, S1.M2, S2.M2, S3.M2);
  const fR  = mulSign(useA, S1.R , S2.R , S3.R );
  chk('FX_L',fL); chk('FX_M1',fM1); chk('FX_M2',fM2); chk('FX_R',fR);
  chk('FX_Z1','0'); chk('FX_Z2','0'); chk('FX_Z3','0');

  // ====== V√©rif S ‚Äî s√©mantique ======
  const incl    = (this.state.cmp==='‚â§'||this.state.cmp==='‚â•');
  const wantPos = (this.state.cmp==='>'||this.state.cmp==='‚â•');

  const valAt = i => rvals[i];
  const EX = [];
  const pushSeg = (iL, iR, segSign)=>{
    if (wantPos ? segSign==='+' : segSign==='‚àí'){
      const A = (iL==null)? -Infinity : valAt(iL);
      const B = (iR==null)? +Infinity : valAt(iR);
      // bornes = z√©ros du num√©rateur ‚Üí ferm√©es si incl
      const L = (iL!=null && incl) ? '[' : ']';
      const R = (iR!=null && incl) ? ']' : '[';
      EX.push({A,B,L,R});
    }
  };
  pushSeg(null, 0, fL);
  pushSeg(0,    1, fM1);
  pushSeg(1,    2, fM2);
  pushSeg(2,  null, fR);

  const Sraw = $('#ex10_S',HOST)?.value.trim() || '';
  if (Sraw!==''){
    tots++;
    const U = parseIntervals(Sraw);
    const tests = [ valAt(0)-1, valAt(0), (valAt(0)+valAt(1))/2, valAt(1), (valAt(1)+valAt(2))/2, valAt(2), valAt(2)+1 ];
    const ok = sameSet(U, EX, tests);
    oks += ok; setTick('tk_set10', ok?'ok':'ko');
  } else setTick('tk_set10','');

  const filled = (tots>0);
  setFB(filled ? (oks===tots) : null, filled ? `${oks} / ${tots}` : '');
  return (filled && oks===tots);
};

  },

  solution(host, st){
    const box = $('#res',host); if(!box) return;

    function affTeX(m, p, ord='mxp'){
      const mterm = (m===1)?'x' : (m===-1)?'‚àíx' : `${m}x`;
      const P = Math.abs(p);
      if (ord==='mxp'){ if(p===0) return mterm; return `${mterm} ${p>0?'+':'‚àí'} ${P}`; }
      if (p===0) return mterm;
      const lead = p>0 ? `${P}` : `‚àí ${P}`;
      if (m>0) return `${lead} + ${m===1?'x':`${m}x`}`;
      return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
    }
    const red = (num,den)=>{
      const g=(x,y)=>{x=Math.abs(x);y=Math.abs(y);while(y){const t=x%y;x=y;y=t}return x||1};
      if(den<0){num=-num;den=-den}
      const d=g(num,den); return {p:num/d, q:den/d};
    };
    const frac = r => r.q===1 ? String(r.p)
      : `${(r.p*r.q<0)?'‚àí':''}\\dfrac{${Math.abs(r.p)}}{${Math.abs(r.q)}}`;

    const r1 = red(-st.p1, st.m1), r2 = red(-st.p2, st.m2), r3 = red(-st.p3, st.m3);
    const arr = [
      {r:r1, who:'F1', m:st.m1, lbl: affTeX(st.m1,st.p1,st.ord1)},
      {r:r2, who:'F2', m:st.m2, lbl: affTeX(st.m2,st.p2,st.ord2)},
      {r:r3, who:'F3', m:st.m3, lbl: affTeX(st.m3,st.p3,st.ord3)},
    ].sort((A,B)=> A.r.p/A.r.q - B.r.p/B.r.q);
    const rL=arr[0], rM=arr[1], rR=arr[2];

    const sA = st.a>0?'+':'‚àí';
    const signLeft  = m => (m>0?'‚àí':'+');
    const signRight = m => (m>0?'+':'‚àí');

    function row(lbl, Ls, z1, M1s, z2, M2s, z3, Rs){
      return `
        <tr>
          <th>${lbl}</th>
          <td class="mid"><div class="midv"><b>${Ls}</b></div></td>
          <td class="zbar mid"><div class="midv"><b>${z1?'0':''}</b></div></td>
          <td class="mid"><div class="midv"><b>${M1s}</b></div></td>
          <td class="zbar mid"><div class="midv"><b>${z2?'0':''}</b></div></td>
          <td class="mid"><div class="midv"><b>${M2s}</b></div></td>
          <td class="zbar mid"><div class="midv"><b>${z3?'0':''}</b></div></td>
          <td class="mid"><div class="midv"><b>${Rs}</b></div></td>
        </tr>`;
    }

    function lineFor(who,m){
      const isL = (rL.who===who), isM = (rM.who===who), isR = (rR.who===who);
      const L  = signLeft(m);
      const M1 = isL ? signRight(m) : signLeft(m);
      const M2 = isR ? signLeft(m)  : signRight(m);
      const R  = signRight(m);
      return row(`\\(${arr.find(x=>x.who===who).lbl}\\)`,
        L, isL, M1, isM, M2, isR, R);
    }

const useA = (st.a!==1) ? (st.a>0 ? '+' : '‚àí') : '+';
    const tableHTML = `
      <table class="pdf-tbl" style="width:auto; margin-top:.35rem">
        <thead>
          <tr>
            <th>\\(x\\)</th>
            <td>\\(-\\infty\\)</td>
            <td class="C zbar">\\(${frac(rL.r)}\\)</td>
            <td></td>
            <td class="C zbar">\\(${frac(rM.r)}\\)</td>
            <td></td>
            <td class="C zbar">\\(${frac(rR.r)}\\)</td>
            <td>\\(+\\infty\\)</td>
          </tr>
        </thead>
        <tbody>
          ${useA ? row(`\\(${st.a}\\)`, sA, false, sA, false, sA, false, sA) : ''}
          ${lineFor('F1', st.m1)}
          ${lineFor('F2', st.m2)}
          ${lineFor('F3', st.m3)}
          ${(()=>{ // f(x)
            const L  = [useA?sA:'+',
                        signLeft(st.m1), signLeft(st.m2), signLeft(st.m3)];
            const M1 = [useA?sA:'+',
                        (rL.who==='F1')?signRight(st.m1):signLeft(st.m1),
                        (rL.who==='F2')?signRight(st.m2):signLeft(st.m2),
                        (rL.who==='F3')?signRight(st.m3):signLeft(st.m3)];
            const M2 = [useA?sA:'+',
                        (rR.who==='F1')?signLeft(st.m1):signRight(st.m1),
                        (rR.who==='F2')?signLeft(st.m2):signRight(st.m2),
                        (rR.who==='F3')?signLeft(st.m3):signRight(st.m3)];
            const R  = [useA?sA:'+',
                        signRight(st.m1), signRight(st.m2), signRight(st.m3)];
            const mul = arr=> (arr.filter(s=>s==='‚àí').length%2===0)?'+':'‚àí';
            return row('\\(f(x)\\)', mul(L), true, mul(M1), true, mul(M2), true, mul(R));
          })()}
        </tbody>
      </table>`;

    // √âquations associ√©es (3 colonnes)
    function fracStepsLatex(p, q){
      const g=(a,b)=>{a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a||1};
      const s = (p*q<0)?'‚àí':'';
      let P=Math.abs(p), Q=Math.abs(q);
      const first = (Q===1) ? `${s}${P}` : `${s}\\dfrac{${P}}{${Q}}`;
      const d=g(P,Q); if(d>1){ const pr=P/d, qr=Q/d; const red=(qr===1)?`${s}${pr}`:`${s}\\dfrac{${pr}}{${qr}}`; if(red!==first) return [first,red]; }
      return [first];
    }
    function makeEqSteps(m, p, ord){
      const L1 = `\\(${affTeX(m,p,ord)} = 0\\)`;
      const mleft = (m===1)?'x' : (m===-1)?'‚àíx' : m+'x';
      let rhs2;
      if (p===0)      rhs2 = '0';
      else if (p<0)   rhs2 = `${Math.abs(p)}`;
      else            rhs2 = `‚àí\\,${p}`;
      const L2 = `\\(${mleft} = ${rhs2}\\)`;
      let L3;
      if (m===1){ L3 = `\\( x = ${ p===0 ? '0' : (p<0 ? String(Math.abs(p)) : `‚àí${p}`) } \\)`; }
      else if (m===-1){ L3 = `\\( x = ${ p } \\)`; }
      else{
        const steps = fracStepsLatex(-p, m);
        L3 = (steps.length===1) ? `\\( x = ${steps[0]} \\)` : `\\( x = ${steps[1]} \\)`;
      }
      return [L1,L2,L3];
    }

    const S1 = makeEqSteps(st.m1,st.p1,st.ord1);
    const S2 = makeEqSteps(st.m2,st.p2,st.ord2);
    const S3 = makeEqSteps(st.m3,st.p3,st.ord3);

    const H = (L)=> L? `<div>${L}</div>`:'';
    const nb = Math.max(S1.length,S2.length,S3.length);
    let eqRows = '';
    for (let i=0;i<nb;i++){
      eqRows += `
        <tr>
          <td style="vertical-align:top; padding:4px 10px; border:none;">${H(S1[i])}</td>
          <td style="vertical-align:top; padding:4px 10px; border:none; text-align:center;">\\(\\text{ou}\\)</td>
          <td style="vertical-align:top; padding:4px 10px; border:none;">${H(S2[i])}</td>
          <td style="vertical-align:top; padding:4px 10px; border:none; text-align:center;">\\(\\text{ou}\\)</td>
          <td style="vertical-align:top; padding:4px 10px; border:none;">${H(S3[i])}</td>
        </tr>`;
    }
    const eqTable = `<table style="margin:.2rem 0;"><tbody>${eqRows}</tbody></table>`;

    // Conclusion (utilise les signes calcul√©s ci-dessus)
    const cmp2tex = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);

    // recompute signes f pour la conclusion
    const SL = signLeft, SR = signRight;
const fL  = (['dummy',
  useA, SL(st.m1), SL(st.m2), SL(st.m3)].filter(s=>s==='‚àí').length%2)?'‚àí':'+';
const fM1 = (['dummy',
  useA,
  (rL.who==='F1')?SR(st.m1):SL(st.m1),
  (rL.who==='F2')?SR(st.m2):SL(st.m2),
  (rL.who==='F3')?SR(st.m3):SL(st.m3)
].filter(s=>s==='‚àí').length%2)?'‚àí':'+';
const fM2 = (['dummy',
  useA,
  (rR.who==='F1')?SL(st.m1):SR(st.m1),
  (rR.who==='F2')?SL(st.m2):SR(st.m2),
  (rR.who==='F3')?SL(st.m3):SR(st.m3)
].filter(s=>s==='‚àí').length%2)?'‚àí':'+';
const fR  = (['dummy',
  useA, SR(st.m1), SR(st.m2), SR(st.m3)].filter(s=>s==='‚àí').length%2)?'‚àí':'+';

    const incl = (st.cmp==='‚â§'||st.cmp==='‚â•');
    const wantPlus  = (st.cmp==='>'||st.cmp==='‚â•');
    const okL  = (wantPlus? fL==='+'  : fL==='‚àí');
    const okM1 = (wantPlus? fM1==='+' : fM1==='‚àí');
    const okM2 = (wantPlus? fM2==='+' : fM2==='‚àí');
    const okR  = (wantPlus? fR==='+'  : fR==='‚àí');

    const Ltex  = `\\left] -\\infty\\,;\\, ${frac(rL.r)} ${incl?'\\right]':'\\right['}`;
    const M1tex = `${incl?'\\left[':'\\left]'} ${frac(rL.r)} \\;;\\; ${frac(rM.r)} ${incl?'\\right]':'\\right['}`;
    const M2tex = `${incl?'\\left[':'\\left]'} ${frac(rM.r)} \\;;\\; ${frac(rR.r)} ${incl?'\\right]':'\\right['}`;
    const Rtex  = `${incl?'\\left[':'\\left]'} ${frac(rR.r)} \\;;\\; +\\infty \\right[`;

    const parts = [];
    if (okL)  parts.push(Ltex);
    if (okM1) parts.push(M1tex);
    if (okM2) parts.push(M2tex);
    if (okR)  parts.push(Rtex);

    const S = parts.length ? parts.join('\\;\\cup\\;') : '\\varnothing';

    box.innerHTML = `
      <div class="step"><b>√âquations associ√©es (produit nul).</b>${eqTable}</div>
      <div class="step"><b>Tableau de signes.</b>${tableHTML}</div>
      <div class="step"><b>Conclusion.</b>
        \\(f(x) ${cmp2tex(st.cmp)} 0\\;\\Rightarrow\\; S = ${S}\\).
      </div>`;
    retypeset(host);
  }
},


};

/* === Adapter pour le kit PDF (identique √† avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;


// PDF-only ‚Äî resserre *pmatrix* en array compact
// PDF-only ‚Äî compacte les vecteurs-colonne sans toucher l'√©cran
function tightenVectorsForPDF(html){
  if(!html) return html;

  // (a)  \begin{pmatrix} ... \end{pmatrix}  ->  ( array{c} ) + espaces n√©gatifs
  html = html.replace(
    /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (b)  \left( \begin{array}{c} ... \end{array} \right)  -> ajoute \! et r√©duit arraycolsep
  html = html.replace(
    /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (c)  versions sans \left...\right (rare) : ( array{c} ) ‚Üí ajoute \!
  html = html.replace(
    /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (d)  \pmatrix{‚Ä¶} macro √©ventuelle
  html = html.replace(
    /\\pmatrix\{([\s\S]*?)\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  return html;
}





/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
window.buildOneForPDFSync = function(defId){
  window.__PDF_BUILDING = true;           // ‚¨ÖÔ∏è d√©marre la zone neutre

  try {
    const cfg = REGISTRY_MAP[defId];
    if (!cfg) return { statement:'', solution:'' };

    const host   = document.querySelector('#host');
    const backup = host ? host.innerHTML : '';

    if (host) mountHost();
    document.querySelector('#lead').innerHTML = cfg.lead || '';

    // ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
    cfg.gen.call(cfg);


  // --- Restaure pour l‚Äô√©cran ---


  // ---- 1) R√©cup√©rer le rep√®re s‚Äôil existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // s√©curit√© namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) √ânonc√© texte (√©cran)
// on tente d'abord #equ ; sinon on prend le backup stock√© en state
const equHTML =
  (document.querySelector('#equ')?.innerHTML || '') ||
  (window.REGISTRY_MAP?.[defId]?.state?._equForPDF
     ? `<p>${window.REGISTRY_MAP[defId].state._equForPDF}</p>` : '');

  // √ânonc√© final : grille 2 colonnes si on a un rep√®re, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction (√©cran)
const _oldRetypeset2 = window.retypeset;
  const _oldMJ2        = window.MJ;
  window.retypeset = function(){};
  window.MJ        = function(){};
 cfg.solution.call(cfg, host, cfg.state); // ‚Üê passe bien host + √©tat courant
  
  // ---- Apr√®s cfg.solution.call(cfg); (et avant le restore) ----

// 2.1) R√©cup√©rer le SVG *corrig√©*
let corrigeRepereHTML = '';
{
  const svgSol = document.querySelector('.row svg.svgbox') || document.querySelector('svg.svgbox');
  if (svgSol){
    const clone = svgSol.cloneNode(true);
    clone.removeAttribute('style');
    clone.setAttribute('width','300');      // taille PDF
    clone.setAttribute('height','300');
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    corrigeRepereHTML = clone.outerHTML;
  }
}

// 2.2) R√©cup√©rer le HTML texte de la correction
const corrigeTexteHTML = (document.querySelector('#res')||{}).innerHTML || '';

// 2.3) Composer la *correction* pour le PDF : rep√®re + texte
const solution =
  corrigeRepereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${corrigeRepereHTML}</div>
         <div>${corrigeTexteHTML}</div>
       </div>`
    : corrigeTexteHTML;

  
  
  window.retypeset = _oldRetypeset2;
  window.MJ        = _oldMJ2;

  if (host) host.innerHTML = backup;

  // ---- 4) PDF-only : resserrer les pmatrix via TeX (espace interne)
  function tightenVectorsForPDF(html){
    if(!html) return html;
    // pmatrix -> array{c} + espaces n√©gatifs
    html = html.replace(
      /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \left( \begin{array}{c} ... \end{array} \right) -> ajoute \!
    html = html.replace(
      /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // versions sans \left...\right
    html = html.replace(
      /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \pmatrix{‚Ä¶}
    html = html.replace(
      /\\pmatrix\{([\s\S]*?)\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    return html;
  }

  const statementTight = statement;
  const solutionTight  = solution;
  
 function stripCHTML(html){
  if(!html) return html;
  return html
     .replace(/<mjx-container[\s\S]*?<\/mjx-container>/g, (m)=>{
       // On essaie de r√©cup√©rer le TeX source si MathJax l‚Äôa laiss√© en data-tex,
       // sinon on supprime (on n‚Äôen veut pas dans le PDF SVG).
       const tex = m.match(/data-tex="([^"]+)"/);
       return tex ? `\\(${tex[1]}\\)` : '';
     });
 }
 const statementClean = stripCHTML(statementTight);
 const solutionClean  = stripCHTML(solutionTight);

  // ‚ö†Ô∏è On wrappe ici avec .vec-tight pour activer le CSS ‚Äúresserr√©‚Äù c√¥t√© iframe PDF (SVG)
    return {
      statement: `<div class="vec-tight">${statementTight||''}</div>`,
      solution:  `<div class="vec-tight">${solutionTight||''}</div>`
    };
  } finally {
    window.__PDF_BUILDING = false;        // ‚¨ÖÔ∏è on r√©active l‚Äô√©cran quoi qu‚Äôil arrive
  }
};




/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){

  mountHost(); // injecte le layout par d√©faut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // √©l√©ments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', HOST);
  const fbEl  = $('#fb', HOST);
  const resEl = $('#res', HOST);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

  // g√©n√®re l'exo (peut remplacer enti√®rement le host, ex. e3/ex4)
  cfg.gen.call(cfg);




  // (re)typeset
  retypeset();

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
document.querySelector('#btn-reset').addEventListener('click', ()=>{
  const a=$('#ans',HOST); if(a) a.value='';
  document.querySelectorAll('.colvec input').forEach(i=> i.value=''); // ‚¨ÖÔ∏è AJOUT
  const f=$('#fb',HOST); if(f) f.textContent='';
  const r=$('#res',HOST); if(r) r.innerHTML='';
});
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
 document.querySelector('#btn-solution').addEventListener('click', ()=>{
   const ex = REGISTRY_MAP[ACTIVE];
   ex.solution.call(ex, HOST, ex.state);   // ‚Üê on passe host + √©tat courant
 });

function adjustLive(kind){
  const id = ACTIVE;
  if (id === 'e3'   && REGISTRY_MAP.e3.adjustLive)   REGISTRY_MAP.e3.adjustLive(kind);
  else if (id === 'ex4' && REGISTRY_MAP.ex4.adjustLive) REGISTRY_MAP.ex4.adjustLive(kind);
  else if (id === 'e5'  && REGISTRY_MAP.e5.adjustLive)  REGISTRY_MAP.e5.adjustLive(kind);
  else { applyAMPInputs(); }
}


['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;     buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) ‚Äî inchang√©, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);
// --- PDF-only: resserre les parenth√®ses des vecteurs-colonne ---
function tightenVectorsForPDF(html){
  if(!html) return html;
  // 1) diminue l'espace colonne dans les array (√©quivalent \arraycolsep)
  html = html.replace(/\\begin\{array\}\{c\}/g, '{\\arraycolsep=1.5pt\\begin{array}{c}');
  // 2) colle les grandes parenth√®ses √† la matrice (\left( ... \right))
  //    (sans toucher le reste du doc)
  html = html
    .replace(/\\left\(\s*\\begin\{array\}\{c\}/g, '\\left(\\mkern-6mu\\begin{array}{c}')
    .replace(/\\end\{array\}\s*\\right\)/g, '\\end{array}\\mkern-6mu\\right)');
  return html;
}

const statementTight = tightenVectorsForPDF(statement);
const solutionTight  = tightenVectorsForPDF(solution);

          const htmlIn =
  `<div class="exo-block">
     <span class="exo-title">Exercice</span>
     <div class="exo-statement">${statementTight||''}</div>
   </div>` +
  (withSolutions
    ? `<div style="margin-top:1rem;">
         <div class="exo-block"><div class="steps" id="pdf-steps">
           <span class="exo-title"></span>
           <!-- ‚¨áÔ∏è Ajout d‚Äôun conteneur .steps pour retrouver la zone grise -->
           <div class="exo-solution">${solutionTight||''}</div></div>
         </div>
       </div>`
    : '');


          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;
const css = idoc.createElement('style');
css.textContent = `
  :root{
    --ink:#111; --bg:#fafafa; --card:#fff; --line:#e5e7eb; --muted:#666;
    --steps-bg:#f3f4f6; --steps-border:#e5e7eb; --steps-left:#9aa0a6;
  }
  body{font:16px/1.55 system-ui,Segoe UI,Roboto,Arial;color:var(--ink);}
  .exo-title{display:block;font-weight:700;margin:0 0 6px}
  /* ‚öôÔ∏è Zone grise identique √† l‚Äô√©cran (#res.steps) */
  .steps{
    background:var(--steps-bg);
    border:1px solid var(--steps-border);
    border-left:4px solid var(--steps-left);
    border-radius:8px;
    padding:10px;
    margin:.45rem 0 0 .15rem;
  }
  .steps p{margin:.25rem 0}
  /* Table ‚Äúe5‚Äù compacte */
  .tbl3{border-collapse:collapse}
  .tbl3 td{padding:2px 6px;vertical-align:top}
  
  /* === Tighten parentheses around column vectors (SVG output) === */
/* CHTML (au cas o√π), agit sur les delimiters extensibles */
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:first-child { margin-right: -0.18em; }
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:last-child  { margin-left:  -0.18em; }
.vec-tight mjx-mtable mjx-mtd { padding-left: .15em; padding-right: .15em; }
.vec-tight mjx-mtable > mjx-table { margin-left: 0; margin-right: 0; }

/* SVG : d√©caler l√©g√®rement OPEN/CLOSE pour coller les parenth√®ses au tableau */
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="OPEN"]  { transform: translateX(-0.18em); }
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="CLOSE"] { transform: translateX( 0.18em); }

/* Ajustement global tr√®s l√©ger si besoin (peut √™tre mis √† 0 si tu pr√©f√®res) */
.vec-tight svg[aria-hidden="true"] { margin-left:-0.10em; margin-right:-0.10em; }
/* --- Anti "barres noires" MathJax (PDF) --- */
.exo-statement,
.exo-solution { color:#111 !important; background:transparent !important; }

/* Cas CHTML (au cas o√π) */
mjx-container { color:#111 !important; background:transparent !important; }
mjx-container svg { overflow:visible !important; }
mjx-container svg rect,
mjx-container svg path[data-mml-node="mspace"] { fill:none !important; }

/* Cas SVG standalone (ce que tu utilises dans l‚Äôiframe) */
.exo-statement svg rect,
.exo-statement svg path[data-mml-node="mspace"],
.exo-solution  svg rect,
.exo-solution  svg path[data-mml-node="mspace"] { fill:none !important; }
/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }
`;
idoc.head.appendChild(css);

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
