<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Fonctions affines - In√©quations "quotient"</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}

/* Bloc solution (UI) */
#res.steps{
  background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;
}
#res.steps p{margin:.25rem 0}

.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }

/* Grille 3 colonnes pour les vecteurs √† placer (partie 3) */
.grid3 { display:grid; grid-template-columns:repeat(3, minmax(0, 1fr)); gap:8px 12px; align-items:start; }
.grid3 .chipwrap { width:100%; }

/* ---- Blocs sous le rep√®re : 2 lignes √ó 5 colonnes ---- */
.flat12-wrap{ margin-top:10px; }

.sec{ margin:10px 0; }
.sec .title{ font-weight:700; font-size:1.05rem; margin-bottom:6px; }

/* une grille de 5 colonnes */
.grid5{ display:grid; grid-template-columns: repeat(5, max-content); gap:8px 14px; align-items:center; }
.grid5 .inlinecell{ display:flex; align-items:center; gap:6px; }
.grid5 .colvec{ --parenW:8px; --padX:5px; --gap:3px; --inW:44px; --inPy:2px; --inFs:12.5px; }

.hidden{ display:none; }

/* ‚Äî Anti ‚Äúbarres noires‚Äù MathJax ‚Äî */
.steps mjx-container { color: #111 !important; background: transparent !important; }
.steps mjx-container svg { overflow: visible !important; }
.steps mjx-container svg rect,
.steps mjx-container svg path[data-mml-node="mspace"] { fill: none !important; }
.steps mjx-mrow, .steps mjx-mi, .steps mjx-mo, .steps mjx-mn { background: transparent !important; }

/* ==== Nom de vecteur avec fl√®che au-dessus ============================== */
.vecname{ position:relative; display:inline-block; }
.vecname input{
  width:72px; text-align:center; font-weight:700; font-size:15px;
  letter-spacing:.12em; text-transform:uppercase;
  padding:14px 10px 6px 10px; /* place pour la fl√®che au-dessus */
  border:1px solid #ddd; border-radius:8px; background:#fff;
}
.vecname::before{ content:""; position:absolute; left:12px; right:20px; top:6px; height:2px; background:#111; }
.vecname::after{
  content:""; position:absolute; top:2px; right:12px;
  border-left:8px solid #111; border-top:5px solid transparent; border-bottom:5px solid transparent;
}

/* Lignes compactes sous le rep√®re pour e2 */
.vecrow{ display:flex; align-items:center; gap:12px; margin:6px 0; flex-wrap:wrap; }
.vecrow .lbl{ font-weight:700; min-width:max-content; }
.vecrow .tick{ min-width:1.4rem; font-weight:900; }
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.pair{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.pair .lbl{font-weight:700;min-width:1.6rem}

/* Tableau bordur√© noir partout */
.table-black{ width:100%; border-collapse:collapse; border:1.2px solid #000; }
.table-black th, .table-black td{ border:1.2px solid #000; padding:6px 8px; text-align:left; }
.table-black thead th{ background:#fff; }

.table-compare { border-collapse: collapse; width: 100%; margin: .5rem 0 .6rem 0; }
.table-compare td { vertical-align: top; padding: 0 .8rem; border: none; }
/* barre verticale seulement si la table N‚ÄôEST PAS en mode "one" */
.table-compare:not(.one) td:first-child { border-right: 2px solid #000; }
/* solo : aucune barre, padding standard */
.table-compare.one td.solo { border: none; padding: 0 .8rem; }


/* tableaux imprimables style PDF */
table.pdf-tbl{ border-collapse:separate; border-spacing:0; border:none; margin:.4rem 0; }
table.pdf-tbl th, table.pdf-tbl td{ border:none; padding:4px 6px; text-align:center; vertical-align:middle; }
table.pdf-tbl th{ background:#f3f3f6 }
table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
table.pdf-tbl thead tr > *:first-child,
table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

/* tableaux interactifs (cadre uniquement) */
table.var{ border-collapse:separate; border-spacing:0; margin:.35rem auto }
table.var th, table.var td{ padding:4px 6px; border:none }
table.var tr:first-child > * { border-top:    1.5px solid #000; }
table.var tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var tr > *:first-child { border-left:   1.5px solid #000; }
table.var tr > *:last-child  { border-right:  1.5px solid #000; }
table.var tbody tr:first-child > * { border-bottom: 1.5px solid #000; }
table.var td.bigsel{ padding:0 }
table.var td.bigsel select{ display:block; width:100%; height:100%; background:transparent; padding:0; margin:0; text-align:center; text-align-last:center; appearance:none }
table.var input[type="text"]{ width:110px; text-align:center }

/* zone courbes */
.graph{display:flex;justify-content:center;margin:.4rem 0}
svg.repere{background:#fff;border:1px solid #e5e5e5;border-radius:8px}

/* S√©parateur vertical apr√®s la 1re colonne (tous tableaux interactifs) */
table.var tr > *:first-child{
  border-left: 1.5px solid #000;
  border-right: 1.5px solid #000;
}

/* divers traits sp√©ciaux (variations / solution pdf) */
#dv-wrap table.var tbody tr:nth-child(2) > *,
#dv-out  table.pdf-tbl tbody tr:nth-child(2) > * { border-bottom: 1.5px solid #000; }
#dv-out table.pdf-tbl tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* Enlever fond/bordure sur les blocs de solution */
#v-out.steps,#s1-out.steps,#sf-out.steps,#dv-out.steps,#curve-out-var.steps,#curve-out-sign.steps{ background:transparent!important; border:none!important; padding:0!important }
#v-out .step,#s1-out .step,#sf-out .step,#dv-out .step,#curve-out-var .step,#curve-out-sign .step{ background:transparent!important; border:none!important; padding:0!important }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute; top:-1.5px; bottom:-1.5px; left:50%; transform:translateX(-50%);
  border-left:2px solid #000;
}

/* 2 barres (||) ‚Äî √©cart serr√© */
table.pdf-tbl td.dbar::before,
table.pdf-tbl td.dbar::after{
  content:'';
  position:absolute; top:-1.5px; bottom:-1.5px; border-left:2px solid #000;
}
table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

/* ===== version √©cran (live) ===== */
table.pdf-tbl.sign-live td, table.pdf-tbl.sign-live th{ padding:6px 10px; line-height:1.2; }
table.pdf-tbl.sign-live td.mid { position: static; height:44px; }
table.pdf-tbl.sign-live td.zbar, table.pdf-tbl.sign-live td.sbar, table.pdf-tbl.sign-live td.dbar{ position:relative; }
table.pdf-tbl.sign-live td.mid .midv{ position:static; transform:none; display:flex; align-items:center; justify-content:center; min-height:28px; }
table.pdf-tbl.sign-live select, table.pdf-tbl.sign-live input{ height:30px; padding:4px 8px; font-size:15px; box-sizing:border-box; }

/* colonnes larges */
table.pdf-tbl.sign-live col.col-zero { width: 58px; }
table.pdf-tbl.sign-live col.col-int  { width: 140px; }
table.pdf-tbl.sign-live col.col-lbl  { width: 70px; }

/* lignes horizontales pour √©cran & pdf */
table.pdf-tbl.sign-live thead tr > *{ border-bottom: 1.5px solid #000; }
table.pdf-tbl.sign-live tbody tr + tr > *{ border-top: 1px solid #000; }
table.var thead tr > *{ border-bottom: 1.5px solid #000; }
table.var tbody tr + tr > *{ border-top: 1px solid #000; }
#sf-wrap table.var tbody tr.sf-row-a > *,
#sf-wrap table.var tbody tr.sf-row-factor + tr.sf-row-factor > *,
#sf-wrap table.var tbody tr.sf-row-fx > *,
#sf-out  table.pdf-tbl tbody tr.sf-pdf-row-a > *,
#sf-out  table.pdf-tbl tbody tr.sf-pdf-row-factor + tr.sf-pdf-row-factor > *,
#sf-out  table.pdf-tbl tbody tr.sf-pdf-row-fx > *{ border-top: 1.5px solid #000 !important; }

/* thead sans barres verticales utiles */
table.pdf-tbl thead tr > *{ border-bottom:1.5px solid #000; }
table.pdf-tbl tbody tr + tr > *{ border-top:1px solid #000; }
table.pdf-tbl tbody td.zbar, table.pdf-tbl tbody td.sbar, table.pdf-tbl tbody td.dbar{ position:relative; }
table.pdf-tbl tbody td.zbar::before, table.pdf-tbl tbody td.sbar::before,
table.pdf-tbl tbody td.dbar::before, table.pdf-tbl tbody td.dbar::after{
  content:''; position:absolute; top:-1.5px; bottom:-1.5px; left:50%; transform:translateX(-50%); border-left:2px solid #000;
}
table.pdf-tbl tbody td.dbar::before{ left: calc(50% - 2px); }
table.pdf-tbl tbody td.dbar::after { left: calc(50% + 2px); }
table.pdf-tbl thead td.zbar::before, table.pdf-tbl thead td.sbar::before,
table.pdf-tbl thead td.dbar::before, table.pdf-tbl thead td.dbar::after{ content:none!important; }
/* tableau de signes : colonnes sym√©triques */
.pdf-tbl.sign4 td { padding-left: 6px; padding-right: 6px; } /* optionnel, m√™me padding */
.pdf-tbl.sign4 td.L { text-align: left; }
.pdf-tbl.sign4 td.C { text-align: center; position: relative; }
.pdf-tbl.sign4 td.R { text-align: right; }

.hide-screen{ display:none !important; }

/* Tableau de la SOLUTION uniquement */
#res.steps table.pdf-tbl tbody tr > td.mid:first-of-type{
  text-align: right !important;   /* signe coll√© √† droite sur ]-‚àû ; r1[ */
}
#res.steps table.pdf-tbl tbody tr > td.mid:last-of-type{
  text-align: left !important;    /* signe coll√© √† gauche sur [rk ; +‚àû[ */
}


</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>


</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Fonctions affines - In√©quations "quotient"</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; rappels :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>In√©quation <em>quotient</em> : les **z√©ros** de \(f\) viennent du <u>num√©rateur</u> ; les **valeurs interdites** (double barre) du <u>d√©nominateur</u>.</li>
        <li>Dans la ligne \(f(x)\) (√©cran), tu peux choisir : rien / 0 / ¬´ || ¬ª. <u>La double barre n‚Äôappara√Æt que dans la solution</u>.</li>
        <li>Ne pas taper <code>S=</code> : √©crire l‚Äôensemble solution directement.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Mini helpers ====== */
const $=(s,r=document)=>r.querySelector(s);
function retypeset(host){ if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t} return a||1; }
function R(p,q=1){ if(q<0){p=-p;q=-q} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'‚àí':''; const P=Math.abs(r.p); return `${s}\\dfrac{${P}}{${r.q}}`; }
function latexFracLead(p,q){ if(q===1) return String(p); const s=(p*q<0)?'‚àí':''; return `${s}\\dfrac{${Math.abs(p)}}{${Math.abs(q)}}`; }
function parseNumber(token){
  token = String(token)
    .trim()
    .replace(/\s+/g,'')
    .replace(/[‚àí‚Äì‚Äî]/g,'-')   // ‚Üê moins Unicode ‚Üí '-'
    .replace(',', '.');      // d√©cimales fr
  if (/^[-+]?\d+\/\d+$/.test(token)){
    const [p,q] = token.split('/').map(Number);
    return p/q;
  }
  return token==='' ? NaN : Number(token);
}

function removeDefaultAnswerRow(){ const ctrl = HOST.querySelector('.controls'); if (ctrl) ctrl.remove(); }

/* ====== UI host ====== */
const HOST = $('#host');
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq hide-screen"></div>
    <hr class="sep">
    <div class="controls">
      <label class="input">R√©ponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>`;
}

/* ===== Affichage affine m x + p (ordre mx¬±p ou p¬±mx) ===== */
function affTeX(m,p,ord='mxp'){
  const mterm = (m===1)?'x':(m===-1)?'‚àíx':`${m}x`;
  const P = Math.abs(p);
  if (ord==='mxp'){ if(p===0) return mterm; return `${mterm} ${p>0?'+':'‚àí'} ${P}`; }
  if (p===0) return mterm;
  const lead = p>0?`${P}`:`‚àí ${P}`;
  if (m>0) return `${lead} + ${m===1?'x':`${m}x`}`;
  return `${lead} ‚àí ${Math.abs(m)===1?'x':`${Math.abs(m)}x`}`;
}

function texMx(m){
  return (m===1) ? 'x' : (m===-1 ? '‚àíx' : `${m}x`);
}

/* √âtapes sans doublons :
   - ligne 1 : (mx+p)=0   toujours
   - ligne 2 :  mx = -p   seulement si p‚â†0
   - ligne 3 :  x = (-p)/m toujours, SAUF si |m|=1 et p‚â†0 (car identique √† la 2)
*/
function zeroStepsUnique(lbl, m, p){
  const lines = [];
  lines.push(`\\(${lbl} = 0\\)<br>`);                              // 1
  if (p !== 0){
    lines.push(`\\(${texMx(m)} = ${latexFracLead(-p,1)}\\)<br>`);  // 2
  }
  // 3) finale, sauf doublon avec la 2 quand |m|=1 et p‚â†0
if (!(m===1 && p!==0)){
  lines.push(`\\(x = ${latexR(red(-p,m))}\\)<br>`);
}
  return lines.join('\n');
}



/* ====== Gabarits de tableaux ‚Äúquotient‚Äù ====== */
function makeHeadCols(rats){
  // rats = [r1, r2, ...] tri√©s croissant
  let t = `<tr><th>\\(x\\)</th><td class="L">\\(-\\infty\\)</td>`;
  rats.forEach((r,i)=>{
    t += `<td class="mid"><div class="midv"><input id="r${i+1}" style="width:80px;text-align:center"><span class="tick" id="tk_r${i+1}"></span></div></td>`;
    if (i<rats.length-1) t += `<td></td>`;
  });
  t += `<td class="R">\\(+\\infty\\)</td></tr>`;
  return t;
}
function selectSign(id){ return `<select id="${id}"><option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option></select><span class="tick" id="tk_${id}"></span>`; }
function selectZeroBarFx(id){ // rien / 0 / ||
  return `<select id="${id}">
    <option value=""></option>
    <option value="0">0</option>
    <option value="||">||</option>
  </select><span class="tick" id="tk_${id}"></span>`;
}
function selectZeroOnly(id){ // rien / 0 (pour toutes les lignes de facteurs, m√™me si pas de z√©ro)
  return `<select id="${id}">
    <option value=""></option>
    <option value="0">0</option>
  </select><span class="tick" id="tk_${id}"></span>`;
}

/* ====== Tris et racines ====== */
function red(num,den){ if(den<0){num=-num;den=-den} const d=gcd(Math.abs(num),Math.abs(den)); return {p:num/d,q:den/d}; }
function val(r){ return r.p/r.q; }

// crochet gauche/droit en fonction du type de point et de "incl" (‚â§ ou ‚â•)
function LB(kind, incl){ return (incl && String(kind).startsWith('N')) ? '\\left[' : '\\left]'; }
function RB(kind, incl){ return (incl && String(kind).startsWith('N')) ? '\\right]' : '\\right['; }


// Tableau 2 colonnes‚Ä¶ ou 1 seule si b est vide
function twoCols(a, b){
  const hasB = !!(b && String(b).trim());
  if (!hasB){
    return `<table class="table-compare one"><tr>
      <td class="solo">${a||''}</td>
    </tr></table>`;
  }
  return `<table class="table-compare"><tr>
    <td>${a||''}</td>
    <td>${b||''}</td>
  </tr></table>`;
}

// Remplace les anciens canon(...) par ceci :
function canonInt(s){
  const ZERO_WIDTH = /[\u200B-\u200D\u2060\uFEFF]/g;
  return String(s)
    .replace(ZERO_WIDTH,'')
    .replace(/^\s*S\s*=\s*/i,'')          // tol√®re "S= ..."
    .replace(/(\d)\s*,\s*(\d)/g,'$1.$2')  // 1,5 ‚Üí 1.5 (d√©cimal)
    .replace(/,/g,';')                    // autres virgules ‚Üí ';'
    .replace(/\s+/g,'')
    .replace(/\\left|\\right/g,'')
    .replace(/\\;|\\,|~/g,'')
    .replace(/[‚àí‚Äì‚Äî]/g,'-')
    .replace(/\\dfrac\{([^}]+)\}\{([^}]+)\}/g,'$1/$2')
    .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g,'$1/$2')
    .replace(/\\cup|‚à™/gi,'U')             // unions ‚Üí 'U'
    .replace(/[u]/gi,'U')                 // accepte 'u'
    .replace(/\+\s*‚àû|\+\s*oo/gi,'+oo')
    .replace(/-\s*‚àû|-\s*oo/gi,'-oo')
    .replace(/‚àû/g,'oo')
    .replace(/\\]/g,']').replace(/\\\[/g,'[')
    .replace(/\\\)/g,')').replace(/\\\(/g,'(');
}

// ‚á© normalise vraiment les unions : s√©pare, nettoie chaque morceau, et recolle proprement
function canonSet(s){
  s = canonInt(s)
        .replace(/\(/g,'[').replace(/\)/g,']');  // tol√®re () comme [] si √©l√®ve se trompe
  const parts = s.split(/U+/).filter(Boolean);
  // on enl√®ve tout vide r√©siduel, on unifie la casse, et on recolle avec un seul 'U'
  return parts.join('U');
}

// --- Parse un ensemble de la forme ]a;b[ U [c;d] ...
function parseIntervals(txt){
  const t = String(txt).replace(/\s+/g,'').replace(/[‚àí‚Äì‚Äî]/g,'-');
  if (!t) return [];
  const parts = t.split(/‚à™|U|u/).filter(Boolean);
  const toNum = s=>{
    if (s==='-‚àû'||s==='-oo') return -Infinity;
    if (s==='+‚àû'||s==='+oo') return +Infinity;
    if (/^[+-]?\d+\/\d+$/.test(s)){ const [p,q]=s.split('/').map(Number); return p/q; }
    return Number(s.replace(',','.'));
  };
  const out=[];
  for (const p of parts){
    const L = p[0], R = p[p.length-1];
    const inner = p.slice(1,-1);
    const k = inner.indexOf(';'); if (k<0) continue;
    const A = toNum(inner.slice(0,k));
    const B = toNum(inner.slice(k+1));
    out.push({A,B,L,R}); // L: '['=ferm√©, ']'=ouvert ; R: ']'=ferm√©, '['=ouvert
  }
  return out;
}
// x appartient-il √† l‚Äôunion U ?
function inU(x,U){
  for (const I of U){
    const okL = (I.L===']'? x> I.A : x>= I.A); // ']' = ouvert √† gauche
    const okR = (I.R==='['? x< I.B : x<= I.B); // '[' = ouvert √† droite
    if (okL && okR) return true;
  }
  return false;
}
// Compare ¬´ ensemble saisi ¬ª vs ¬´ ensemble attendu ¬ª en testant des points
function sameSet(userIntervals, expectedIntervals, testPoints){
  for (const x of testPoints){
    if (inU(x,userIntervals) !== inU(x,expectedIntervals)) return false;
  }
  return true;
}

// Retourne le produit TeX de 'factors'.
// - Si un seul facteur ET pas de 'a' affich√© => pas de parenth√®ses.
// - Sinon, parenth√®se chaque facteur: \big(...\big)
function prodTeX(factors, hasA){
  if (factors.length === 1 && !hasA) return factors[0];
  return factors.map(s => `\\big(${s}\\big)`).join('');
}



/* ====== EXERCICES (quotient) =================================== */
const REGISTRY_MAP = {

/* -------------------------------------------------------------- *
 * EX1 ‚Äî (m1x+p1) / (n1x+q1)  ‚àò  0
 * -------------------------------------------------------------- */
ex1:{
  name:"Quotient simple : (m1x+p1)/(n1x+q1) ‚àò 0",
  lead:"Compl√©ter le tableau de signes (quotient) puis r√©soudre l‚Äôin√©quation.",
  gen(){
    const choice=a=>a[Math.floor(Math.random()*a.length)];
    let m1 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let n1 = choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let p1 = randInt(-9,9), q1 = randInt(-9,9);
    // √©viter co√Øncidence des racines num/den
    let rN = red(-p1,m1), rD = red(-q1,n1);
    if (rN.p===rD.p && rN.q===rD.q){ q1 += (q1>=0?1:-1); rD = red(-q1,n1); }
    const cmp = choice(['<','>','‚â§','‚â•']);
    const ordN = Math.random()<.5?'mxp':'pmx';
    const ordD = Math.random()<.5?'mxp':'pmx';
    this.state={m1,p1,n1,q1,cmp,ordN,ordD};
    this.render(HOST,this.state);
  },
  render(host,st){
    const fx = `\\dfrac{${affTeX(st.m1,st.p1,st.ordN)}}{${affTeX(st.n1,st.q1,st.ordD)}}`;
    const cmp2 = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);
    $('#equ',host).innerHTML = `R√©soudre \\( ${fx} ${cmp2(st.cmp)} 0 \\).`;

    const rN = red(-st.p1, st.m1);   // z√©ro f (num√©rateur)
    const rD = red(-st.q1, st.n1);   // interdit (d√©nominateur)
    const rats = [ {r:rN,kind:'N'}, {r:rD,kind:'D'} ].sort((a,b)=> val(a.r)-val(b.r));

    // T√™te √©cran
    const thead = makeHeadCols(rats.map(o=>o.r));
    const mkRowFactor = (lbl,id,who)=>{
      // toujours des s√©lecteurs "0 / vide" sur toutes les colonnes
      const L = selectSign(id+'_L');
      const M1= selectSign(id+'_M1');
      const R = selectSign(id+'_R');
      const z1 = selectZeroOnly(id+'_Z1');
      const z2 = selectZeroOnly(id+'_Z2');
      return `
        <tr class="sf-row-factor">
          <th>\\(${lbl}\\)</th>
          <td class="mid"><div class="midv">${L}</div></td>
          <td class="zbar mid"><div class="midv">${z1}</div></td>
          <td class="mid"><div class="midv">${M1}</div></td>
          <td class="zbar mid"><div class="midv">${z2}</div></td>
          <td class="mid"><div class="midv">${R}</div></td>
        </tr>`;
    };

    const rowNum = mkRowFactor(affTeX(st.m1,st.p1,st.ordN),'NUM','N');
    const rowDen = mkRowFactor(affTeX(st.n1,st.q1,st.ordD),'DEN','D'); // s√©lecteurs pr√©sents mais la bonne r√©ponse attend ¬´ vide ¬ª

    // f(x) ‚Äî √† l‚Äô√©cran : select rien/0/||
    const rowFx = `
      <tr class="sf-row-fx">
        <th>\\(f(x)\\)</th>
        <td class="mid"><div class="midv">${selectSign('FX_L')}</div></td>
        <td class="zbar mid"><div class="midv">${selectZeroBarFx('FX_Z1')}</div></td>
        <td class="mid"><div class="midv">${selectSign('FX_M1')}</div></td>
        <td class="zbar mid"><div class="midv">${selectZeroBarFx('FX_Z2')}</div></td>
        <td class="mid"><div class="midv">${selectSign('FX_R')}</div></td>
      </tr>`;

    const tableHTML = `
      <table class="pdf-tbl sign4 sign-live" style="width:auto">
        <colgroup><col class="col-lbl"><col class="col-int"><col class="col-zero"><col class="col-int"><col class="col-zero"><col class="col-int"></colgroup>
        <thead>${thead}</thead>
        <tbody>${rowNum}${rowDen}${rowFx}</tbody>
      </table>`;

    removeDefaultAnswerRow();
    let body = $('#exq1_body',host); if(!body){ body=document.createElement('div'); body.id='exq1_body'; const equEl=$('#equ',host); (equEl?.parentNode||host).insertBefore(body, equEl?.nextSibling||null); }
    body.innerHTML = `
      <div>\\(${fx}\\)
        <select id="cmpSel" style="margin-left:.4rem">
          <option value="<"${st.cmp=='<'?' selected':''}>&lt; 0</option>
          <option value="‚â§"${st.cmp=='‚â§'?' selected':''}>‚â§ 0</option>
          <option value=">"${st.cmp=='>'?' selected':''}>&gt; 0</option>
          <option value="‚â•"${st.cmp=='‚â•'?' selected':''}>‚â• 0</option>
        </select>
      </div>
      ${tableHTML}
      <div class="vecrow pdf-hide" style="margin:.5rem 0 .25rem 0">
        <span>\\(S=\\)</span>
        <input id="exq1_S" style="width:360px"><span class="tick" id="tk_setq1"></span>
      </div>
      <div id="exq1_hint" class="hint"></div>`;

    $('#cmpSel',host).addEventListener('change',e=>{ st.cmp=e.target.value; this.state.cmp=st.cmp; this.solution(host,st); retypeset(host); });
    retypeset(host);

    /* ===== V√©rification ===== */
    this.verify=()=>{
      const v=id=>($('#'+id,host)?.value||'').trim();
      const setT=(id,k)=>{ const el=$('#'+id,host); if(!el) return; el.className='tick '+(k||''); el.textContent = k==='ok'?'‚úì':k==='ko'?'‚úó':''; };

      const sorted=[rN,rD].sort((a,b)=>val(a)-val(b));
      let tots=0,oks=0;
      ['r1','r2'].forEach((id,i)=>{ const got=v(id); if(got!==''){ tots++; const ok = Math.abs(parseNumber(got)-val(sorted[i]))<1e-9; oks+=ok; setT('tk_'+id,ok?'ok':'ko'); } else setT('tk_'+id,''); });

      const firstIsN = (sorted[0].p===rN.p && sorted[0].q===rN.q);
      const signLeftNum  = st.m1>0?'‚àí':'+';
      const signRightNum = st.m1>0?'+':'‚àí';
      const signLeftDen  = st.n1>0?'‚àí':'+';
      const signRightDen = st.n1>0?'+':'‚àí';
      const num_M1 = firstIsN ? (st.m1>0?'+':'‚àí') : (st.m1>0?'‚àí':'+');
      const den_M1 = firstIsN ? (st.n1>0?'‚àí':'+') : (st.n1>0?'+':'‚àí');

      function chk(id,want){ const got=v(id); if(got===''){ setT('tk_'+id,''); return; } tots++; const ok=(got===want); oks+=ok; setT('tk_'+id,ok?'ok':'ko'); }
      // NUM (z√©ro attendu uniquement sur sa colonne)
      chk('NUM_L',signLeftNum); chk('NUM_M1',num_M1); chk('NUM_R',signRightNum);
      chk('NUM_Z1', firstIsN?'0':''); chk('NUM_Z2', firstIsN?'':'0');
      // DEN (jamais 0 attendu mais s√©lecteur propos√©)
   // DEN ‚Äî demander aussi le 0 au bon endroit
chk('DEN_L',signLeftDen); 
chk('DEN_M1',den_M1); 
chk('DEN_R',signRightDen);

// Si la 1re coupure (colonne) est le NUM√âRATEUR, alors le z√©ro du DEN est en 2e colonne, et inversement.
chk('DEN_Z1', firstIsN ? ''  : '0');
chk('DEN_Z2', firstIsN ? '0' : '');


      // f(x) : signe du quotient
      const mul = (...ss)=> (ss.filter(s=>'‚àí'===s).length%2===0)?'+':'‚àí';
      const fL  = mul(signLeftNum, signLeftDen);
      const fM1 = mul(num_M1, den_M1);
      const fR  = mul(signRightNum, signRightDen);
      chk('FX_L',fL); chk('FX_M1',fM1); chk('FX_R',fR);
      // z√©ros/|| √† l‚Äô√©cran : libres (not√©s positif si rempli)
// APR√àS : "0" si la coupure est Num√©rateur, "||" si D√©nominateur
function chkZ(id, want){
  const got = v(id);
  if (got===''){ setT('tk_'+id,''); return; }
  tots++; const ok = (got===want); oks+=ok; setT('tk_'+id, ok?'ok':'ko');
}
const wantZ1 = firstIsN ? '0'  : '||';
const wantZ2 = firstIsN ? '||' : '0';
chkZ('FX_Z1', wantZ1);
chkZ('FX_Z2', wantZ2);


      // Ensemble S
// ===== Ensemble S (comparaison s√©mantique) =====
const Sraw = v('exq1_S');
if (Sraw!==''){
  tots++;

  // Intervalles ATTENDUS (programmatiquement)
  const incl = (st.cmp==='‚â§'||st.cmp==='‚â•');
  const wantPlus = (st.cmp==='>'||st.cmp==='‚â•');

  const P = [sorted[0], sorted[1]].map(r=>r.p/r.q);
  const kind = [
    (sorted[0].p===rN.p && sorted[0].q===rN.q) ? 'N' : 'D',
    (sorted[1].p===rN.p && sorted[1].q===rN.q) ? 'N' : 'D'
  ];
  const segSign = [fL, fM1, fR];     // signes sur les 3 segments

  const EX = [];
  // segment gauche ]-‚àû ; r1 ?[
  if ((wantPlus? segSign[0]==='+' : segSign[0]==='‚àí')){
    EX.push({A:-Infinity, B:P[0], L:']', R: (incl && kind[0]==='N') ? ']' : '['});
  }
  // segment milieu ?r1 ; r2?
  if ((wantPlus? segSign[1]==='+' : segSign[1]==='‚àí')){
    EX.push({A:P[0], B:P[1],
             L: (incl && kind[0]==='N') ? '[' : ']',
             R: (incl && kind[1]==='N') ? ']' : '['});
  }
  // segment droit ?r2 ; +‚àû[
  if ((wantPlus? segSign[2]==='+' : segSign[2]==='‚àí')){
    EX.push({A:P[1], B:+Infinity,
             L: (incl && kind[1]==='N') ? '[' : ']',
             R: '['});
  }

  // Intervalles SAISIS
  const U = parseIntervals(Sraw);

  // Points de test : int√©rieur + bornes
  const mid = (P[0]+P[1])/2;
  const tests = [P[0]-1, P[0], mid, P[1], P[1]+1];

  const ok = sameSet(U, EX, tests);
  oks += ok; setT('tk_setq1', ok?'ok':'ko');
} else setT('tk_setq1','');

      const fb = $('#fb',HOST); if (fb){ fb.className=(oks===tots)?'ok':'ko'; fb.textContent = (tots? `${oks} / ${tots}`:''); }
      return (tots>0 && oks===tots);
    };
  },
  solution(host,st){
    const box = $('#res',host); if(!box) return;
    const rN = red(-st.p1, st.m1), rD = red(-st.q1, st.n1);
    const arr = [ {r:rN,kind:'N',lbl:affTeX(st.m1,st.p1,st.ordN)},
                  {r:rD,kind:'D',lbl:affTeX(st.n1,st.q1,st.ordD)} ]
                .sort((A,B)=> val(A.r)-val(B.r));
    const first = arr[0], second = arr[1];

    const signLeft = m => (m>0?'‚àí':'+');
    const signRight= m => (m>0?'+':'‚àí');

    const numL = signLeft(st.m1), numR = signRight(st.m1);
    const denL = signLeft(st.n1), denR = signRight(st.n1);
    const numM = (first.kind==='N') ? signRight(st.m1) : signLeft(st.m1);
    const denM = (first.kind==='D') ? signRight(st.n1) : signLeft(st.n1);

    const mul = (...ss)=> (ss.filter(s=>'‚àí'===s).length%2===0)?'+':'‚àí';
    const fL  = mul(numL, denL);
    const fM1 = mul(numM, denM);
    const fR  = mul(numR, denR);

    // ‚ûú remplace tout le bloc "function row(...) { ... }" + la construction de tableHTML par :

const preHTML_ex1 = `
  <div class="step">
    <table class="table-compare">
      <tr>
        <td>
          <b>Z√©ros du num√©rateur :</b><br>
          ${zeroStepsUnique(affTeX(st.m1,st.p1,st.ordN), st.m1, st.p1)}
        </td>
        <td>
          <b>Valeur interdite :</b><br>
          ${zeroStepsUnique(affTeX(st.n1,st.q1,st.ordD), st.n1, st.q1)}
        </td>
      </tr>
    </table>
  </div>`;




function row(lbl, Ls, z1, mid, z2, Rs){
  // FACTEURS : toujours une barre simple et "0" aux racines (m√™me pour le d√©nominateur)
  return `
  <tr>
    <th>${lbl}</th>
    <td class="mid"><div class="midv"><b>${Ls}</b></div></td>
    <td class="zbar mid"><div class="midv"><b>${z1?'0':''}</b></div></td>
    <td class="mid"><div class="midv"><b>${mid}</b></div></td>
    <td class="zbar mid"><div class="midv"><b>${z2?'0':''}</b></div></td>
    <td class="mid"><div class="midv"><b>${Rs}</b></div></td>
  </tr>`;
}

const z1N = (first.kind==='N'), z2N = (second.kind==='N');
const z1D = (first.kind==='D'), z2D = (second.kind==='D');

const tableHTML = `
  <table class="pdf-tbl" style="width:auto; margin-top:.35rem">
    <thead>
      <tr>
        <th>\\(x\\)</th>
        <td>\\(-\\infty\\)</td>
        <td class="C sbar">\\(${latexR(first.r)}\\)</td>
        <td></td>
        <td class="C sbar">\\(${latexR(second.r)}\\)</td>
        <td>\\(+\\infty\\)</td>
      </tr>
    </thead>
    <tbody>
      ${row(`\\(${affTeX(st.m1,st.p1,st.ordN)}\\)`, numL, z1N, numM, z2N, numR)}
      ${row(`\\(${affTeX(st.n1,st.q1,st.ordD)}\\)`, denL, z1D, denM, z2D, denR)}
      ${(()=>{ // f(x) : z√©ros -> zbar "0" ; interdits -> dbar "||"
        const c1 = (first.kind==='D')?'dbar':'zbar';
        const c2 = (second.kind==='D')?'dbar':'zbar';
        const t1 = (first.kind==='D')?'': '0';
        const t2 = (second.kind==='D')?'': '0';
        return `
          <tr>
            <th>\\(f(x)\\)</th>
            <td class="mid"><div class="midv"><b>${fL}</b></div></td>
            <td class="${c1} mid"><div class="midv"><b>${t1}</b></div></td>
            <td class="mid"><div class="midv"><b>${fM1}</b></div></td>
            <td class="${c2} mid"><div class="midv"><b>${t2}</b></div></td>
            <td class="mid"><div class="midv"><b>${fR}</b></div></td>
          </tr>`;
      })()}
    </tbody>
  </table>`;


    const cmp2 = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);
const incl = (st.cmp==='‚â§'||st.cmp==='‚â•');
const wantPlus  = (st.cmp==='>'||st.cmp==='‚â•');
const okL = (wantPlus? fL==='+' : fL==='‚àí');
const okM = (wantPlus? fM1==='+' : fM1==='‚àí');
const okR = (wantPlus? fR==='+' : fR==='‚àí');

const L = `\\left] -\\infty\\,;\\, ${latexR(first.r)} ${RB(first.kind,incl)}`;
const M = `${LB(first.kind,incl)} ${latexR(first.r)} \\;;\\; ${latexR(second.r)} ${RB(second.kind,incl)}`;
const R = `${LB(second.kind,incl)} ${latexR(second.r)} \\;;\\; +\\infty \\right[`;

const parts=[]; if(okL)parts.push(L); if(okM)parts.push(M); if(okR)parts.push(R);
const S = parts.length? parts.join('\\;\\cup\\;') : '\\varnothing';


box.innerHTML = `
  ${preHTML_ex1}
  <div class="step"><b>Tableau de signes (quotient).</b>${tableHTML}</div>
  <div class="step"><b>Conclusion.</b> \\(f(x) ${cmp2(st.cmp)} 0\\;\\Rightarrow\\; S = ${S}\\).</div>`;
retypeset(host);
  }
},


/* -------------------------------------------------------------- *
 * EX2 ‚Äî a ¬∑ (m1x+p1)(m2x+p2) / (n1x+q1)  ‚àò  0
 * -------------------------------------------------------------- */
ex2:{
  name:"Quotient : a¬∑(m1x+p1)(m2x+p2) / (n1x+q1) ‚àò 0",
  lead:"Compl√©ter le tableau (num√©rateur √ó d√©nominateur) puis r√©soudre.",
  gen(){
    const choice=a=>a[Math.floor(Math.random()*a.length)];
    const a = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);
    let m1=choice([-5,-4,-3,-2,-1,1,2,3,4,5]),
        m2=choice([-5,-4,-3,-2,-1,1,2,3,4,5]),
        n1=choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let p1=randInt(-9,9), p2=randInt(-9,9), q1=randInt(-9,9);

    let rN1=red(-p1,m1), rN2=red(-p2,m2), rD1=red(-q1,n1);
    if ((rN1.p===rD1.p && rN1.q===rD1.q) || (rN2.p===rD1.p && rN2.q===rD1.q)){ q1 += (q1>=0?1:-1); rD1=red(-q1,n1); }
    if (rN1.p===rN2.p && rN1.q===rN2.q){ p2 += (p2>=0?1:-1); rN2=red(-p2,m2); }

    const cmp = choice(['<','>','‚â§','‚â•']);
    const ord1=Math.random()<.5?'mxp':'pmx';
    const ord2=Math.random()<.5?'mxp':'pmx';
    const ordD=Math.random()<.5?'mxp':'pmx';
    this.state={a,m1,p1,m2,p2,n1,q1,cmp,ord1,ord2,ordD};
    this.render(HOST,this.state);
  },
  render(host,st){
    const A = (st.a===1?'':st.a===-1?'‚àí':String(st.a));
    const num = `\\big(${affTeX(st.m1,st.p1,st.ord1)}\\big)\\big(${affTeX(st.m2,st.p2,st.ord2)}\\big)`;
    const den = `${affTeX(st.n1,st.q1,st.ordD)}`;
const fx = `\\dfrac{${st.a===1?'':A+'\\,'}${num}}{${den}}`;
    const cmp2 = c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[c]);
    $('#equ',host).innerHTML = `R√©soudre \\( ${fx} ${cmp2(st.cmp)} 0 \\).`;

    const rN1=red(-st.p1,st.m1), rN2=red(-st.p2,st.m2), rD1=red(-st.q1,st.n1);
    const points = [ {r:rN1,kind:'N1'}, {r:rN2,kind:'N2'}, {r:rD1,kind:'D'} ].sort((a,b)=>val(a.r)-val(b.r));

    const thead = makeHeadCols(points.map(o=>o.r));
    function rowA(){
      if (st.a===1) return '';
      return `
      <tr class="sf-row-a">
        <th>\\(${st.a}\\)</th>
        <td class="mid"><div class="midv">${selectSign('A_L')}</div></td>
        <td class="zbar mid"><div class="midv"><span class="tick" id="tk_A_Z1"></span></div></td>
        <td class="mid"><div class="midv">${selectSign('A_M1')}</div></td>
        <td class="zbar mid"><div class="midv"><span class="tick" id="tk_A_Z2"></span></div></td>
        <td class="mid"><div class="midv">${selectSign('A_M2')}</div></td>
        <td class="zbar mid"><div class="midv"><span class="tick" id="tk_A_Z3"></span></div></td>
        <td class="mid"><div class="midv">${selectSign('A_R')}</div></td>
      </tr>`;
    }
    function rowFactor(lbl,id){
      // toujours des s√©lecteurs "0 / vide" sur chaque coupure
      const z = k=>selectZeroOnly(`${id}_${k}`);
      return `
        <tr class="sf-row-factor">
          <th>\\(${lbl}\\)</th>
          <td class="mid"><div class="midv">${selectSign(id+'_L')}</div></td>
          <td class="zbar mid"><div class="midv">${z('Z1')}</div></td>
          <td class="mid"><div class="midv">${selectSign(id+'_M1')}</div></td>
          <td class="zbar mid"><div class="midv">${z('Z2')}</div></td>
          <td class="mid"><div class="midv">${selectSign(id+'_M2')}</div></td>
          <td class="zbar mid"><div class="midv">${z('Z3')}</div></td>
          <td class="mid"><div class="midv">${selectSign(id+'_R')}</div></td>
        </tr>`;
    }
    const rowNum1 = rowFactor(affTeX(st.m1,st.p1,st.ord1), 'N1');
    const rowNum2 = rowFactor(affTeX(st.m2,st.p2,st.ord2), 'N2');
    const rowDen1 = rowFactor(affTeX(st.n1,st.q1,st.ordD), 'D'); // s√©lecteurs propos√©s mais "vide" attendu

    const rowFx = `
      <tr class="sf-row-fx">
        <th>\\(f(x)\\)</th>
        <td class="mid"><div class="midv">${selectSign('FX_L')}</div></td>
        <td class="zbar mid"><div class="midv">${selectZeroBarFx('FX_Z1')}</div></td>
        <td class="mid"><div class="midv">${selectSign('FX_M1')}</div></td>
        <td class="zbar mid"><div class="midv">${selectZeroBarFx('FX_Z2')}</div></td>
        <td class="mid"><div class="midv">${selectSign('FX_M2')}</div></td>
        <td class="zbar mid"><div class="midv">${selectZeroBarFx('FX_Z3')}</div></td>
        <td class="mid"><div class="midv">${selectSign('FX_R')}</div></td>
      </tr>`;

    const tableHTML = `
      <table class="pdf-tbl sign4 sign-live" style="width:auto">
        <colgroup>
          <col class="col-lbl">
          <col class="col-int"><col class="col-zero">
          <col class="col-int"><col class="col-zero">
          <col class="col-int"><col class="col-zero">
          <col class="col-int">
        </colgroup>
        <thead>${thead}</thead>
        <tbody>
          ${rowA()}
          ${rowNum1}
          ${rowNum2}
          ${rowDen1}
          ${rowFx}
        </tbody>
      </table>`;

    removeDefaultAnswerRow();
    let body=$('#exq2_body',host); if(!body){ body=document.createElement('div'); body.id='exq2_body'; const equEl=$('#equ',host); (equEl?.parentNode||host).insertBefore(body,equEl?.nextSibling||null); }
    body.innerHTML = `
      <div>\\(${fx}\\)
        <select id="cmpSel2" style="margin-left:.4rem">
          <option value="<"${st.cmp=='<'?' selected':''}>&lt; 0</option>
          <option value="‚â§"${st.cmp=='‚â§'?' selected':''}>‚â§ 0</option>
          <option value=">"${st.cmp=='>'?' selected':''}>&gt; 0</option>
          <option value="‚â•"${st.cmp=='‚â•'?' selected':''}>‚â• 0</option>
        </select>
      </div>
      ${tableHTML}
      <div class="vecrow pdf-hide" style="margin:.5rem 0 .25rem 0">
        <span>\\(S=\\)</span>
        <input id="exq2_S" style="width:420px"><span class="tick" id="tk_setq2"></span>
      </div>`;
    $('#cmpSel2',host).addEventListener('change',e=>{ st.cmp=e.target.value; this.state.cmp=st.cmp; this.solution(host,st); retypeset(host); });
    retypeset(host);

this.verify = () => {
  const v=id=>($('#'+id,HOST)?.value||'').trim();
  const setT=(id,k)=>{ const el=$('#'+id,HOST); if(!el) return; el.className='tick '+(k||''); el.textContent=(k==='ok'?'‚úì':k==='ko'?'‚úó':''); };

  // points tri√©s + kinds (d√©j√† construits en render())
  const pts = points; // [{r:{p,q}, kind:'N1'|'N2'|'D'}] tri√©s

  let tots=0,oks=0;
  // racines r1 r2 r3
  ['r1','r2','r3'].forEach((id,i)=>{
    const got=v(id);
    if(got!==''){ tots++; const ok=Math.abs(parseNumber(got) - (pts[i].r.p/pts[i].r.q))<1e-9; oks+=ok; setT('tk_'+id, ok?'ok':'ko'); }
    else setT('tk_'+id,'');
  });

  // signes attendus sur chaque ligne (comme avant)
  function signLeft(m){ return (m>0?'‚àí':'+'); }
  function signRight(m){ return (m>0?'+':'‚àí'); }
  function lineSigns(m,who){
    return {
      L:signLeft(m),
      M1:(pts[0].kind===who)?signRight(m):signLeft(m),
      M2:(pts[2].kind===who)?signLeft(m):signRight(m),
      R:signRight(m)
    };
  }
  const sA = (st.a>0?'+':'‚àí');
  if (st.a!==1){
    ['L','M1','M2','R'].forEach(k=>{
      const got=v('A_'+k); if(got===''){ setT('tk_A_'+k,''); }
      else { tots++; const ok=(got===sA); oks+=ok; setT('tk_A_'+k,ok?'ok':'ko'); }
    });
  }
  const N1=lineSigns(st.m1,'N1'), N2=lineSigns(st.m2,'N2'), D=lineSigns(st.n1,'D');

  function chkLine(base, S, who){
    // signes
    ['L','M1','M2','R'].forEach((k)=>{
      const got=v(base+'_'+k); if(got===''){ setT('tk_'+base+'_'+k,''); }
      else { tots++; const ok=(got===S[k]); oks+=ok; setT('tk_'+base+'_'+k, ok?'ok':'ko'); }
    });
    // z√©ros sur les colonnes (0 pour le facteur correspondant, vide sinon)
    ['Z1','Z2','Z3'].forEach((z,i)=>{
      const want = (pts[i].kind===who)?'0':'';
      const got=v(base+'_'+z);
      if(got===''){ setT('tk_'+base+'_'+z,''); }
      else { tots++; const ok=(got===want); oks+=ok; setT('tk_'+base+'_'+z, ok?'ok':'ko'); }
    });
  }
  chkLine('N1',N1,'N1');
  chkLine('N2',N2,'N2');
  // D : m√™me logique (0 attendu sous sa colonne dans les lignes facteurs)
  chkLine('D', D, 'D');

  // f(x) : signes par segment
  const mul=(...ss)=> (ss.filter(s=>'‚àí'===s).length%2===0)?'+':'‚àí';
  const useA = (st.a!==1)?(st.a>0?'+':'‚àí'):'+';
  const fL  = mul(useA, N1.L, N2.L, D.L);
  const fM1 = mul(useA, N1.M1,N2.M1,D.M1);
  const fM2 = mul(useA, N1.M2,N2.M2,D.M2);
  const fR  = mul(useA, N1.R , N2.R , D.R );
  function chk(id,want){ const got=v(id); if(got===''){ setT('tk_'+id,''); } else { tots++; const ok=(got===want); oks+=ok; setT('tk_'+id, ok?'ok':'ko'); } }
  chk('FX_L',fL); chk('FX_M1',fM1); chk('FX_M2',fM2); chk('FX_R',fR);

  // ¬´ 0/|| ¬ª sous les coupures pour f(x)
  function wantZat(i){ return (pts[i].kind==='D') ? '||' : '0'; }
  ['FX_Z1','FX_Z2','FX_Z3'].forEach((id,i)=>{
    const got=v(id);
    if(got===''){ setT('tk_'+id,''); return; }
    tots++; const ok=(got===wantZat(i)); oks+=ok; setT('tk_'+id, ok?'ok':'ko');
  });

  // ===================== S ‚Äî comparaison s√©mantique =====================
  const Sraw = v('exq2_S');
  if (Sraw!==''){
    tots++;

    const incl    = (st.cmp==='‚â§'||st.cmp==='‚â•');
    const wantPos = (st.cmp==='>'||st.cmp==='‚â•');

    const valAt = i => pts[i].r.p / pts[i].r.q;
    const kindAt= i => pts[i].kind[0]; // 'N' ou 'D'

    function pushSeg(EX, iLeft, iRight, segSign){
      if (wantPos ? segSign==='+' : segSign==='‚àí'){
        const A = (iLeft==null) ? -Infinity : valAt(iLeft);
        const B = (iRight==null)? +Infinity : valAt(iRight);
        const L = (iLeft!=null && incl && kindAt(iLeft)==='N') ? '[' : ']';
        const R = (iRight!=null&& incl && kindAt(iRight)==='N') ? ']' : '[';
        EX.push({A,B,L,R});
      }
    }
    const EX=[];
    pushSeg(EX, null, 0, fL);
    pushSeg(EX, 0,    1, fM1);
    pushSeg(EX, 1,    2, fM2);
    pushSeg(EX, 2, null, fR);

    const U = parseIntervals(Sraw);
    const tests = [
      valAt(0)-1, valAt(0),
      (valAt(0)+valAt(1))/2, valAt(1),
      (valAt(1)+valAt(2))/2, valAt(2),
      valAt(2)+1
    ];
    const ok = sameSet(U, EX, tests);
    oks += ok; setT('tk_setq2', ok?'ok':'ko');
  } else setT('tk_setq2','');

  const fb=$('#fb',HOST); if(fb){ fb.className=(oks===tots)?'ok':'ko'; fb.textContent=(tots? `${oks} / ${tots}`:''); }
  return (tots>0 && oks===tots);
};

  },
  solution(host,st){
    const box=$('#res',host); if(!box) return;
    const pts = [
      {r:red(-st.p1,st.m1), kind:'N1', lbl:affTeX(st.m1,st.p1,st.ord1)},
      {r:red(-st.p2,st.m2), kind:'N2', lbl:affTeX(st.m2,st.p2,st.ord2)},
      {r:red(-st.q1,st.n1), kind:'D',  lbl:affTeX(st.n1,st.q1,st.ordD)}
    ].sort((A,B)=>val(A.r)-val(B.r));
    const useA = (st.a!==1)?(st.a>0?'+':'‚àí'):'+';
    const signLeft = m => (m>0?'‚àí':'+');
    const signRight= m => (m>0?'+':'‚àí');

    function signsOf(m,who){
      return {
        L:signLeft(m),
        M1:(pts[0].kind===who)?signRight(m):signLeft(m),
        M2:(pts[2].kind===who)?signLeft(m):signRight(m),
        R:signRight(m)
      };
    }
    const N1 = signsOf(st.m1,'N1'), N2 = signsOf(st.m2,'N2'), D = signsOf(st.n1,'D');
    const mul=(...ss)=> (ss.filter(s=>'‚àí'===s).length%2===0)?'+':'‚àí';
    const fL  = mul(useA, N1.L, N2.L, D.L);
    const fM1 = mul(useA, N1.M1,N2.M1,D.M1);
    const fM2 = mul(useA, N1.M2,N2.M2,D.M2);
    const fR  = mul(useA, N1.R , N2.R , D.R );

// remplace l'ancien zeroSteps(...) par :
function zeroSteps(lbl, m, p){
  return zeroStepsUnique(lbl, m, p);
}

// dans preHTML_ex2, ne change que les appels (ils restent identiques) :
const Z1 = zeroSteps(affTeX(st.m1,st.p1,st.ord1), st.m1, st.p1);
const Z2 = zeroSteps(affTeX(st.m2,st.p2,st.ord2), st.m2, st.p2);
const VI = zeroSteps(affTeX(st.n1,st.q1,st.ordD), st.n1, st.q1); // une seule VI en ex2

const preHTML_ex2 = `
  <div class="step">
    <table class="table-compare">
      <tr>
        <td style="width:50%">
          <b>Z√©ros du num√©rateur :</b>
          ${twoCols(Z1, Z2)}
        </td>
        <td style="width:50%">
          <b>Valeur interdite :</b><br>
          ${VI}
        </td>
      </tr>
    </table>
  </div>`;




    function row(lbl, Ls, z1, M1s, z2, M2s, z3, Rs){
  // FACTEURS : toujours zbar et "0" aux racines (y compris au d√©nominateur)
  return `
    <tr>
      <th>${lbl}</th>
      <td class="mid"><div class="midv"><b>${Ls}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z1?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${M1s}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z2?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${M2s}</b></div></td>
      <td class="zbar mid"><div class="midv"><b>${z3?'0':''}</b></div></td>
      <td class="mid"><div class="midv"><b>${Rs}</b></div></td>
    </tr>`;
}

    const tableHTML = `
      <table class="pdf-tbl" style="width:auto; margin-top:.35rem">
        <thead>
          <tr>
            <th>\\(x\\)</th>
            <td>\\(-\\infty\\)</td>
            <td class="C sbar">\\(${latexR(pts[0].r)}\\)</td>
            <td></td>
            <td class="C sbar">\\(${latexR(pts[1].r)}\\)</td>
            <td></td>
            <td class="C sbar">\\(${latexR(pts[2].r)}\\)</td>
            <td>\\(+\\infty\\)</td>
          </tr>
        </thead>
        <tbody>
          ${(st.a!==1)? row(`\\(${st.a}\\)`, useA, false, useA, false, useA, false, useA, 'N') : '' }
 ${row(`\\(${affTeX(st.m1,st.p1,st.ord1)}\\)`, N1.L, (pts[0].kind==='N1'), N1.M1, (pts[1].kind==='N1'), N1.M2, (pts[2].kind==='N1'), N1.R)}
 ${row(`\\(${affTeX(st.m2,st.p2,st.ord2)}\\)`, N2.L, (pts[0].kind==='N2'), N2.M1, (pts[1].kind==='N2'), N2.M2, (pts[2].kind==='N2'), N2.R)}
 ${row(`\\(${affTeX(st.n1,st.q1,st.ordD)}\\)`, D.L , (pts[0].kind==='D'),  D.M1, (pts[1].kind==='D'),  D.M2, (pts[2].kind==='D'),  D.R )} ${(()=>{ // f(x) ‚Äî ici seulement on met "||" pour les D
            const k = (i)=> pts[i].kind==='D'?'D':'N';
            const zC=i=> k(i)==='D'?'dbar':'zbar';
            const zTxt=i=> k(i)==='D'?'':'0';
            return `
              <tr>
                <th>\\(f(x)\\)</th>
                <td class="mid"><div class="midv"><b>${fL}</b></div></td>
                <td class="${zC(0)} mid"><div class="midv"><b>${zTxt(0)}</b></div></td>
                <td class="mid"><div class="midv"><b>${fM1}</b></div></td>
                <td class="${zC(1)} mid"><div class="midv"><b>${zTxt(1)}</b></div></td>
                <td class="mid"><div class="midv"><b>${fM2}</b></div></td>
                <td class="${zC(2)} mid"><div class="midv"><b>${zTxt(2)}</b></div></td>
                <td class="mid"><div class="midv"><b>${fR}</b></div></td>
              </tr>`;
          })()}
        </tbody>
      </table>`;

    const cmp2=c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[st.cmp]);
const incl=(st.cmp==='‚â§'||st.cmp==='‚â•'), wantPlus=(st.cmp==='>'||st.cmp==='‚â•');
const okL  = (wantPlus? fL==='+'  : fL==='‚àí');
const okM1 = (wantPlus? fM1==='+' : fM1==='‚àí');
const okM2 = (wantPlus? fM2==='+' : fM2==='‚àí');
const okR  = (wantPlus? fR==='+'  : fR==='‚àí');

 const K = i => pts[i].kind;
 const I = i => latexR(pts[i].r);

const L  = `\\left] -\\infty\\,;\\, ${I(0)} ${RB(K(0),incl)}`;
const M1 = `${LB(K(0),incl)} ${I(0)} \\;;\\; ${I(1)} ${RB(K(1),incl)}`;
const M2 = `${LB(K(1),incl)} ${I(1)} \\;;\\; ${I(2)} ${RB(K(2),incl)}`;
const R  = `${LB(K(2),incl)} ${I(2)} \\;;\\; +\\infty \\right[`;

const parts=[]; if(okL)parts.push(L); if(okM1)parts.push(M1); if(okM2)parts.push(M2); if(okR)parts.push(R);
const S = parts.length? parts.join('\\;\\cup\\;') : '\\varnothing';


box.innerHTML = `
  ${preHTML_ex2}
  <div class="step"><b>Tableau de signes (quotient).</b>${tableHTML}</div>
  <div class="step"><b>Conclusion.</b> \\(f(x) ${cmp2(st.cmp)} 0\\;\\Rightarrow\\; S = ${S}\\).</div>`;
retypeset(host);
  }
},


/* -------------------------------------------------------------- *
 * EX3 ‚Äî a ¬∑ (m1x+p1)(m2x+p2) / ((n1x+q1)(n2x+q2))  ‚àò  0
 * -------------------------------------------------------------- */
/* -------------------------------------------------------------- *
 * EX3 ‚Äî Quotient mixte (3 patrons) :
 *   A) a¬∑(m1x+p1)(m2x+p2) / (n1x+q1)
 *   B) a¬∑(m1x+p1)(m2x+p2) / ((n1x+q1)(n2x+q2))   ‚Üê (cas actuel)
 *   C) a¬∑(m1x+p1)            / ((n1x+q1)(n2x+q2))
 * -------------------------------------------------------------- */
ex3:{
  name:'Quotient : patrons mixtes (3 cas) ‚àò 0',
  lead:'Compl√©ter le tableau (z√©ros num., double-barres den.) puis r√©soudre.',
  gen(){
    const choice=a=>a[Math.floor(Math.random()*a.length)];
    // Patron al√©atoire : 'A' (2N/1D), 'B' (2N/2D), 'C' (1N/2D)
    const pattern = choice(['A','B','C']);

    const a = choice([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6]);

    // Coeffs des facteurs (on √©vite 0)
    const pickM = ()=> choice([-5,-4,-3,-2,-1,1,2,3,4,5]);
    let m1=pickM(), p1=randInt(-9,9);
    let m2=pickM(), p2=randInt(-9,9);
    let n1=pickM(), q1=randInt(-9,9);
    let n2=pickM(), q2=randInt(-9,9);

    // Racines (r = -p/m) sous forme r√©duite
    const rr = (P,M)=>red(-P,M);

    // Liste des points selon le patron choisi
    let pts = [];
    if (pattern==='A'){      // 2N / 1D
      pts = [
        {r:rr(p1,m1), kind:'N1'},
        {r:rr(p2,m2), kind:'N2'},
        {r:rr(q1,n1), kind:'D1'},
      ];
    } else if (pattern==='B'){ // 2N / 2D
      pts = [
        {r:rr(p1,m1), kind:'N1'},
        {r:rr(p2,m2), kind:'N2'},
        {r:rr(q1,n1), kind:'D1'},
        {r:rr(q2,n2), kind:'D2'},
      ];
    } else {                 // 'C' : 1N / 2D
      pts = [
        {r:rr(p1,m1), kind:'N1'},
        {r:rr(q1,n1), kind:'D1'},
        {r:rr(q2,n2), kind:'D2'},
      ];
    }

    // √âvite toute co√Øncidence de racines
    const same=(u,v)=>u.r.p===v.r.p && u.r.q===v.r.q;
    function deconflict(){
      let changed=false;
      for (let i=0;i<pts.length;i++){
        for (let j=i+1;j<pts.length;j++){
          if (same(pts[i],pts[j])){
            // d√©cale un param√®tre du j-i√®me point
            const k = pts[j].kind;
            if (k.startsWith('N')){ // bouge p
              if (k==='N1'){ p1 += (p1>=0?1:-1); pts[j].r = rr(p1,m1); }
              if (k==='N2'){ p2 += (p2>=0?1:-1); pts[j].r = rr(p2,m2); }
            } else { // D
              if (k==='D1'){ q1 += (q1>=0?1:-1); pts[j].r = rr(q1,n1); }
              if (k==='D2'){ q2 += (q2>=0?1:-1); pts[j].r = rr(q2,n2); }
            }
            changed=true;
          }
        }
      }
      return changed;
    }
    for (let guard=0; guard<10 && deconflict(); guard++);

    // Ordres d‚Äôaffichage (mx¬±p ou p¬±mx)
    const ord1=Math.random()<.5?'mxp':'pmx';
    const ord2=Math.random()<.5?'mxp':'pmx';
    const ordD1=Math.random()<.5?'mxp':'pmx';
    const ordD2=Math.random()<.5?'mxp':'pmx';

    const cmp = choice(['<','>','‚â§','‚â•']);

    this.state={pattern,a,m1,p1,m2,p2,n1,q1,n2,q2,cmp,ord1,ord2,ordD1,ordD2};
    this.render(HOST,this.state);
  },

  render(host,st){
    // --- Construire f(x) selon le patron ---
   // --- Construire f(x) selon le patron, SANS parenth√®ses inutiles ---
const hasA = (st.a !== 1);
const Acoef = hasA ? (st.a === -1 ? '‚àí' : String(st.a)) : '';

const N1 = affTeX(st.m1, st.p1, st.ord1);
const N2 = affTeX(st.m2, st.p2, st.ord2);
const D1 = affTeX(st.n1, st.q1, st.ordD1);
const D2 = affTeX(st.n2, st.q2, st.ordD2);

// liste des facteurs num / den selon le patron
const numFactors =
  (st.pattern === 'C') ? [N1] : [N1, N2];              // C : 1 num ; A,B : 2 num
const denFactors =
  (st.pattern === 'A') ? [D1] : [D1, D2];              // A : 1 den ; B,C : 2 den

const num = `${hasA ? (Acoef + '\\,') : ''}${prodTeX(numFactors, hasA)}`;
const den = `${prodTeX(denFactors, false)}`;

const fx = `\\dfrac{${num}}{${den}}`;

    const cmp2=c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[st.cmp]);
    $('#equ',host).innerHTML = `R√©soudre \\( ${fx} ${cmp2(st.cmp)} 0 \\).`;

    // --- Points tri√©s ---
    let pts = [];
    const pushIf = (ok, r, kind, lbl)=>{ if(ok) pts.push({r,kind,lbl}); };
    const rN1 = red(-st.p1,st.m1), rN2 = red(-st.p2,st.m2),
          rD1 = red(-st.q1,st.n1), rD2 = red(-st.q2,st.n2);

    if (st.pattern==='A'){
      pushIf(true, rN1,'N1',affTeX(st.m1,st.p1,st.ord1));
      pushIf(true, rN2,'N2',affTeX(st.m2,st.p2,st.ord2));
      pushIf(true, rD1,'D1',affTeX(st.n1,st.q1,st.ordD1));
    } else if (st.pattern==='B'){
      pushIf(true, rN1,'N1',affTeX(st.m1,st.p1,st.ord1));
      pushIf(true, rN2,'N2',affTeX(st.m2,st.p2,st.ord2));
      pushIf(true, rD1,'D1',affTeX(st.n1,st.q1,st.ordD1));
      pushIf(true, rD2,'D2',affTeX(st.n2,st.q2,st.ordD2));
    } else {
      pushIf(true, rN1,'N1',affTeX(st.m1,st.p1,st.ord1));
      pushIf(true, rD1,'D1',affTeX(st.n1,st.q1,st.ordD1));
      pushIf(true, rD2,'D2',affTeX(st.n2,st.q2,st.ordD2));
    }
    pts.sort((A,B)=>val(A.r)-val(B.r));
    const K = pts.length;                // 3 ou 4
    const SEG = K-1;                     // segments internes

    // --- Utilitaires de table dynamiques ---
    const makeHead = ()=>{
      let t=`<tr><th>\\(x\\)</th><td class="L">\\(-\\infty\\)</td>`;
      pts.forEach((o,i)=>{
        t+=`<td class="mid"><div class="midv"><input id="r${i+1}" style="width:80px;text-align:center"><span class="tick" id="tk_r${i+1}"></span></div></td>`;
        if(i<K-1) t+=`<td></td>`;
      });
      t+=`<td class="R">\\(+\\infty\\)</td></tr>`;
      return t;
    };

    const selS = id=>`<select id="${id}"><option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option></select><span class="tick" id="tk_${id}"></span>`;
    const zOnly = id=>`<select id="${id}"><option value=""></option><option value="0">0</option></select><span class="tick" id="tk_${id}"></span>`;
    const zFx   = id=>`<select id="${id}"><option value=""></option><option value="0">0</option><option value="||">||</option></select><span class="tick" id="tk_${id}"></span>`;

    // Construit une ligne facteur dynamique (K points ‚áí K z-colonnes et SEG segments)
    function rowFactor(lbl, baseId){
      let h = `<tr class="sf-row-factor"><th>\\(${lbl}\\)</th>`;
      // L
      h += `<td class="mid"><div class="midv">${selS(baseId+'_L')}</div></td>`;
      // alternance [Z1, M1, Z2, M2, ..., ZK]
      for (let i=1;i<=K;i++){
        h += `<td class="zbar mid"><div class="midv">${zOnly(`${baseId}_Z${i}`)}</div></td>`;
        if (i<=SEG) h += `<td class="mid"><div class="midv">${selS(`${baseId}_M${i}`)}</div></td>`;
      }
      // R
      h += `<td class="mid"><div class="midv">${selS(baseId+'_R')}</div></td></tr>`;
      return h;
    }

    // Ligne a (constante) optionnelle
    function rowA(){
      if (st.a===1) return '';
      let h = `<tr class="sf-row-a"><th>\\(${st.a}\\)</th>`;
      h += `<td class="mid"><div class="midv">${selS('A_L')}</div></td>`;
      for (let i=1;i<=K;i++){
        h += `<td class="zbar mid"><div class="midv"><span class="tick" id="tk_A_Z${i}"></span></div></td>`;
        if (i<=SEG) h += `<td class="mid"><div class="midv">${selS('A_M'+i)}</div></td>`;
      }
      h += `<td class="mid"><div class="midv">${selS('A_R')}</div></td></tr>`;
      return h;
    }

    // Ligne f(x) avec ¬´ 0 / || ¬ª
    function rowFx(){
      let h = `<tr class="sf-row-fx"><th>\\(f(x)\\)</th>`;
      h += `<td class="mid"><div class="midv">${selS('FX_L')}</div></td>`;
      for (let i=1;i<=K;i++){
        h += `<td class="zbar mid"><div class="midv">${zFx('FX_Z'+i)}</div></td>`;
        if (i<=SEG) h += `<td class="mid"><div class="midv">${selS('FX_M'+i)}</div></td>`;
      }
      h += `<td class="mid"><div class="midv">${selS('FX_R')}</div></td></tr>`;
      return h;
    }

    // Compose le tableau live
    const thead = makeHead();
    const rows = [
      rowA(),
      (st.pattern!=='C') ? rowFactor(affTeX(st.m2,st.p2,st.ord2),'N2') : '',  // N2 seulement si pr√©sent
      rowFactor(affTeX(st.m1,st.p1,st.ord1),'N1'),
      rowFactor(affTeX(st.n1,st.q1,st.ordD1),'D1'),
      (st.pattern!=='A') ? rowFactor(affTeX(st.n2,st.q2,st.ordD2),'D2') : '', // D2 seulement si pr√©sent
      rowFx()
    ].join('');

// --- colgroup correct : [lbl] + K√ó([int][zero]) + [int] final
const colgroupHTML = (() => {
  let cols = '<col class="col-lbl">';
  for (let i = 0; i < K; i++){
    cols += '<col class="col-int"><col class="col-zero">';
  }
  cols += '<col class="col-int">';
  return `<colgroup>${cols}</colgroup>`;
})();

const tableHTML = `
  <table class="pdf-tbl sign4 sign-live" style="width:auto">
    ${colgroupHTML}
    <thead>${makeHead()}</thead>
    <tbody>${rows}</tbody>
  </table>`;


    // ‚Äî‚Äî‚Äî Montage DOM
    removeDefaultAnswerRow();
    let body=$('#exq3_body',host); if(!body){ body=document.createElement('div'); body.id='exq3_body'; const equEl=$('#equ',host); (equEl?.parentNode||host).insertBefore(body,equEl?.nextSibling||null); }
    body.innerHTML = `
      <div>\\(${fx}\\)
        <select id="cmpSel3" style="margin-left:.4rem">
          <option value="<"${st.cmp=='<'?' selected':''}>&lt; 0</option>
          <option value="‚â§"${st.cmp=='‚â§'?' selected':''}>‚â§ 0</option>
          <option value=">"${st.cmp=='>'?' selected':''}>&gt; 0</option>
          <option value="‚â•"${st.cmp=='‚â•'?' selected':''}>‚â• 0</option>
        </select>
      </div>
      ${tableHTML}
      <div class="vecrow pdf-hide" style="margin:.5rem 0 .25rem 0">
        <span>\\(S=\\)</span>
        <input id="exq3_S" style="width:520px"><span class="tick" id="tk_setq3"></span>
      </div>`;

    $('#cmpSel3',host).addEventListener('change',e=>{ st.cmp=e.target.value; this.state.cmp=st.cmp; this.solution(host,st); retypeset(host); });
    retypeset(host);

    // ---------- V√©rification ----------
   this.verify = () => {
  const v=id=>($('#'+id,HOST)?.value||'').trim();
  const setT=(id,k)=>{ const el=$('#'+id,HOST); if(!el) return; el.className='tick '+(k||''); el.textContent=(k==='ok'?'‚úì':k==='ko'?'‚úó':''); };

  let tots=0,oks=0;

  // points tri√©s d√©j√† calcul√©s en render(): pts (K=3 ou 4), SEG=K-1
  const P = pts.slice();                   // [{r:{p,q},kind:'N1'|'N2'|'D1'|'D2'}]
  const K = P.length, SEG = K-1;

  // r1..rK
  P.forEach((o,i)=>{
    const got=v('r'+(i+1));
    if(got!==''){ tots++; const ok=Math.abs(parseNumber(got) - (o.r.p/o.r.q))<1e-9; oks+=ok; setT('tk_r'+(i+1), ok?'ok':'ko'); }
    else setT('tk_r'+(i+1),'');
  });

  // constantes
  const signLeft = m => (m>0?'‚àí':'+');
  const signRight= m => (m>0?'+':'‚àí');

  // segSignsFor : renvoie le signe par segment [L, M1.., R] pour un facteur
  function segSignsFor(m, who){
    const zIdx = P.findIndex(o=>o.kind===who);       // 0..K-1
    const arr = Array(SEG+2).fill(signLeft(m));      // [L, M1.., R]
    for (let s=0; s<=SEG+1; s++) if (s>zIdx) arr[s]=signRight(m);
    return arr;
  }

  // ligne 'a' (constante)
  const sA = st.a>0?'+':'‚àí';
  if (st.a!==1){
    const keys=['L',...Array.from({length:SEG},(_,i)=>'M'+(i+1)),'R'];
    keys.forEach(k=>{
      const got=v('A_'+k); if(got===''){ setT('tk_A_'+k,''); }
      else { tots++; const ok=(got===sA); oks+=ok; setT('tk_A_'+k, ok?'ok':'ko'); }
    });
  }

  // lignes pr√©sentes (selon patron)
  const present = [];
  if (st.pattern!=='C') present.push({id:'N2', m:st.m2});
  present.push({id:'N1', m:st.m1});
  present.push({id:'D1', m:st.n1});
  if (st.pattern!=='A') present.push({id:'D2', m:st.n2});

  // v√©rification d'une ligne facteur
  function chkLine(id, m){
    const S = segSignsFor(m,id);
    const keys=['L',...Array.from({length:SEG},(_,i)=>'M'+(i+1)),'R'];
    keys.forEach((k,idx)=>{
      const got=v(id+'_'+k); if(got===''){ setT('tk_'+id+'_'+k,''); }
      else { tots++; const ok=(got===S[idx]); oks+=ok; setT('tk_'+id+'_'+k, ok?'ok':'ko'); }
    });
    // z√©ros sous ses colonnes (0 si c'est sa racine, sinon vide)
    for(let i=1;i<=K;i++){
      const expect = (P[i-1].kind===id)?'0':'';
      const got=v(id+'_Z'+i);
      if(got===''){ setT('tk_'+id+'_Z'+i,''); }
      else { tots++; const ok=(got===expect); oks+=ok; setT('tk_'+id+'_Z'+i, ok?'ok':'ko'); }
    }
  }
  present.forEach(L=>chkLine(L.id, L.m));

  // f(x) : produit des signes par segment
  const mul=(...ss)=> (ss.filter(s=>'‚àí'===s).length%2===0)?'+':'‚àí';
  const useA = (st.a!==1)?(st.a>0?'+':'‚àí'):'+';

  const segsFx = Array(SEG+2).fill(null).map((_,segIdx)=>{
    const pack=[];
    if (st.a!==1) pack.push(useA);
    if (st.pattern!=='C'){ const S=segSignsFor(st.m2,'N2'); pack.push(S[segIdx]); }
    { const S=segSignsFor(st.m1,'N1'); pack.push(S[segIdx]); }
    { const S=segSignsFor(st.n1,'D1'); pack.push(S[segIdx]); }
    if (st.pattern!=='A'){ const S=segSignsFor(st.n2,'D2'); pack.push(S[segIdx]); }
    return mul(...pack);
  });

  const keysFx=['L',...Array.from({length:SEG},(_,i)=>'M'+(i+1)),'R'];
  keysFx.forEach((k,idx)=>{
    const got=v('FX_'+k); if(got===''){ setT('tk_FX_'+k,''); }
    else { tots++; const ok=(got===segsFx[idx]); oks+=ok; setT('tk_FX_'+k, ok?'ok':'ko'); }
  });
  for(let i=1;i<=K;i++){
    const want = P[i-1].kind.startsWith('D') ? '||' : '0';
    const got  = v('FX_Z'+i);
    if (got===''){ setT('tk_FX_Z'+i,''); }
    else { tots++; const ok=(got===want); oks+=ok; setT('tk_FX_Z'+i, ok?'ok':'ko'); }
  }

  // ===================== S ‚Äî comparaison s√©mantique =====================
  const Sraw = v('exq3_S');
  if (Sraw!==''){
    tots++;

    const incl    = (st.cmp==='‚â§'||st.cmp==='‚â•');
    const wantPos = (st.cmp==='>'||st.cmp==='‚â•');

    const valAt = i => P[i].r.p / P[i].r.q;
    const kindAt= i => P[i].kind[0]; // 'N' ou 'D'

    function pushSeg(EX, iLeft, iRight, sign){
      if (wantPos ? sign==='+' : sign==='‚àí'){
        const A = (iLeft==null) ? -Infinity : valAt(iLeft);
        const B = (iRight==null)? +Infinity : valAt(iRight);
        const L = (iLeft!=null && incl && kindAt(iLeft)==='N') ? '[' : ']';
        const R = (iRight!=null&& incl && kindAt(iRight)==='N') ? ']' : '[';
        EX.push({A,B,L,R});
      }
    }

    const EX=[];
    for (let s=0; s<=SEG+1; s++){
      const iL = (s===0)      ? null : (s-1);
      const iR = (s===SEG+1)  ? null : s;
      pushSeg(EX, iL, iR, segsFx[s]);
    }

    const U = parseIntervals(Sraw);
    // points de test : un dans chaque segment + toutes les bornes
    const tests=[];
    tests.push(valAt(0)-1);
    for (let i=0;i<K;i++){
      tests.push(valAt(i));                               // la borne
      if (i<K-1) tests.push( (valAt(i)+valAt(i+1))/2 );   // le milieu
    }
    tests.push(valAt(K-1)+1);

    const ok = sameSet(U, EX, tests);
    oks += ok; setT('tk_setq3', ok?'ok':'ko');
  } else setT('tk_setq3','');

  const fb=$('#fb',HOST); if(fb){ fb.className=(oks===tots)?'ok':'ko'; fb.textContent=(tots? `${oks} / ${tots}`:''); }
  return (tots>0 && oks===tots);
};

  },

  solution(host,st){
    const box=$('#res',host); if(!box) return;

    // Reconstituer pts tri√©s + libell√©s (m√™mes que render)
    const arr=[];
    const push=(ok,r,kind,lbl)=>{ if(ok) arr.push({r,kind,lbl}); };
    const rN1 = red(-st.p1,st.m1), rN2 = red(-st.p2,st.m2),
          rD1 = red(-st.q1,st.n1), rD2 = red(-st.q2,st.n2);

    if (st.pattern==='A'){
      push(true,rN1,'N1',affTeX(st.m1,st.p1,st.ord1));
      push(true,rN2,'N2',affTeX(st.m2,st.p2,st.ord2));
      push(true,rD1,'D1',affTeX(st.n1,st.q1,st.ordD1));
    } else if (st.pattern==='B'){
      push(true,rN1,'N1',affTeX(st.m1,st.p1,st.ord1));
      push(true,rN2,'N2',affTeX(st.m2,st.p2,st.ord2));
      push(true,rD1,'D1',affTeX(st.n1,st.q1,st.ordD1));
      push(true,rD2,'D2',affTeX(st.n2,st.q2,st.ordD2));
    } else {
      push(true,rN1,'N1',affTeX(st.m1,st.p1,st.ord1));
      push(true,rD1,'D1',affTeX(st.n1,st.q1,st.ordD1));
      push(true,rD2,'D2',affTeX(st.n2,st.q2,st.ordD2));
    }
    arr.sort((A,B)=>val(A.r)-val(B.r));
    const K=arr.length, SEG=K-1;

    const signLeft = m => (m>0?'‚àí':'+');
    const signRight= m => (m>0?'+':'‚àí');

    function segSignsFor(m, who){
      const zIdx = arr.findIndex(o=>o.kind===who);
      const a = Array(SEG+2).fill(signLeft(m));
      for(let s=0;s<=SEG+1;s++) if (s>zIdx) a[s]=signRight(m);
      return a;
    }

    const useA=(st.a!==1)?(st.a>0?'+':'‚àí'):'+';
    const pack = [];
    if (st.pattern!=='C') pack.push({id:'N2', m:st.m2, lbl:affTeX(st.m2,st.p2,st.ord2)});
    pack.push({id:'N1', m:st.m1, lbl:affTeX(st.m1,st.p1,st.ord1)});
    pack.push({id:'D1', m:st.n1, lbl:affTeX(st.n1,st.q1,st.ordD1)});
    if (st.pattern!=='A') pack.push({id:'D2', m:st.n2, lbl:affTeX(st.n2,st.q2,st.ordD2)});

    // Pr√©-√©tapes (z√©ros / VI) en deux colonnes
    const zerosHTML = pack.filter(x=>x.id.startsWith('N')).map(x=>zeroStepsUnique(x.lbl, x.m, (x.id==='N1'?st.p1:st.p2))).join('');
    const viHTML    = pack.filter(x=>x.id.startsWith('D')).map(x=>{
      const p = (x.id==='D1'?st.q1:st.q2), n=(x.id==='D1'?st.n1:st.n2);
      return zeroStepsUnique(x.lbl, n, p);
    }).join('');

// --- √âtapes "z√©ros" et "valeurs interdites" en 2 colonnes (comme ex2)
function zSteps(lbl, m, p){ return zeroStepsUnique(lbl, m, p); }

const ZN1 = zSteps(affTeX(st.m1,st.p1,st.ord1), st.m1, st.p1);
const ZN2 = (st.pattern!=='C')
  ? zSteps(affTeX(st.m2,st.p2,st.ord2), st.m2, st.p2)
  : '';  // pas de 2e facteur au num√©rateur dans le patron C

const VD1 = zSteps(affTeX(st.n1,st.q1,st.ordD1), st.n1, st.q1);
const VD2 = (st.pattern!=='A')
  ? zSteps(affTeX(st.n2,st.q2,st.ordD2), st.n2, st.q2)
  : '';  // pas de 2e facteur au d√©nominateur dans le patron A

const preHTML_ex3 = `
  <div class="step">
    <table class="table-compare">
      <tr>
        <td style="width:50%">
          <b>Z√©ros du num√©rateur :</b>
          ${twoCols(ZN1, ZN2)}
        </td>
        <td style="width:50%">
          <b>Valeur(s) interdite(s) :</b>
          ${twoCols(VD1, VD2)}
        </td>
      </tr>
    </table>
  </div>`;


    // Table PDF (signes + 0 ; f(x) met || pour D)
    function cellBar(i, isF){
      const isD = arr[i].kind.startsWith('D');
      const cls = isF ? (isD?'dbar':'zbar') : 'zbar';
      const txt = isF ? (isD?'':'0') : '0';
      return `<td class="${cls} mid"><div class="midv"><b>${txt}</b></div></td>`;
    }
    function row(lbl, signs, id){
      let h = `<tr><th>\\(${lbl}\\)</th>`;
      h += `<td class="mid"><div class="midv"><b>${signs[0]}</b></div></td>`;
      for (let i=0;i<K;i++){
        h += cellBar(i,false);                                 // 0 aux racines de ce facteur
        if (i<SEG) h += `<td class="mid"><div class="midv"><b>${signs[i+1]}</b></div></td>`;
      }
      h += `<td class="mid"><div class="midv"><b>${signs[SEG+1]}</b></div></td></tr>`;
      return h.replace(/<b><\/b>/g,'');
    }

    // signes de chaque ligne facteur
    const lines = pack.map(x=>({ lbl:x.lbl, id:x.id, S:segSignsFor(x.m,x.id) }));

    // f(x) (produit)
    const mul=(...ss)=> (ss.filter(s=>'‚àí'===s).length%2===0)?'+':'‚àí';
    const fSeg = Array(SEG+2).fill(null).map((_,s)=>{
      const list=[]; if (st.a!==1) list.push(useA);
      lines.forEach(L=>list.push(L.S[s]));
      return mul(...list);
    });

    const table = `
      <table class="pdf-tbl" style="width:auto; margin-top:.35rem">
        <thead>
          <tr>
            <th>\\(x\\)</th>
            <td>\\(-\\infty\\)</td>
            ${arr.map(o=>`<td class="C sbar">\\(${latexR(o.r)}\\)</td>`).join('<td></td>')}
            <td>\\(+\\infty\\)</td>
          </tr>
        </thead>
        <tbody>
          ${(st.a!==1)? (()=>{ // ligne a
            let h = `<tr><th>\\(${st.a}\\)</th><td class="mid"><div class="midv"><b>${useA}</b></div></td>`;
            for (let i=0;i<K;i++){ h += `<td class="zbar mid"><div class="midv"></div></td>`; if(i<SEG) h += `<td class="mid"><div class="midv"><b>${useA}</b></div></td>`; }
            h += `<td class="mid"><div class="midv"><b>${useA}</b></div></td></tr>`; return h;
          })() : '' }
          ${lines.map(L=>row(L.lbl, L.S, L.id)).join('')}
          ${(()=>{ // f(x) avec || pour D
            let h = `<tr><th>\\(f(x)\\)</th><td class="mid"><div class="midv"><b>${fSeg[0]}</b></div></td>`;
            for (let i=0;i<K;i++){
              h += cellBar(i,true);  // || si D, 0 si N
              if (i<SEG) h += `<td class="mid"><div class="midv"><b>${fSeg[i+1]}</b></div></td>`;
            }
            h += `<td class="mid"><div class="midv"><b>${fSeg[SEG+1]}</b></div></td></tr>`;
            return h;
          })()}
        </tbody>
      </table>`;

    // Conclusion (S)
    const cmp2=c=>({ '<':'\\;<\\;','>':'\\;>\\;','‚â§':'\\;\\le\\;','‚â•':'\\;\\ge\\;' }[st.cmp]);
    const incl=(st.cmp==='‚â§'||st.cmp==='‚â•'), wantPlus=(st.cmp==='>'||st.cmp==='‚â•');
    const ok = s => wantPlus ? (s==='+') : (s==='‚àí');

    const LB2 = (kind)=>LB(kind,incl);
    const RB2 = (kind)=>RB(kind,incl);
    const I = i => latexR(arr[i].r);
    const KND = i => arr[i].kind;

    const parts=[];
    if (ok(fSeg[0])) parts.push(`\\left] -\\infty\\,;\\, ${I(0)} ${RB2(KND(0))}`);
    for (let s=1;s<=SEG;s++) if (ok(fSeg[s])) parts.push(`${LB2(KND(s-1))} ${I(s-1)} \\;;\\; ${I(s)} ${RB2(KND(s))}`);
    if (ok(fSeg[SEG+1])) parts.push(`${LB2(KND(SEG))} ${I(SEG)} \\;;\\; +\\infty \\right[`);
    const S = parts.length? parts.join('\\;\\cup\\;') : '\\varnothing';

    box.innerHTML = `
      ${preHTML_ex3}
      <div class="step"><b>Tableau de signes (quotient).</b>${table}</div>
      <div class="step"><b>Conclusion.</b> \\(f(x) ${cmp2(st.cmp)} 0\\;\\Rightarrow\\; S = ${S}\\).</div>`;
    retypeset(host);
  }
},


}; // REGISTRY_MAP

/* === Adapter pour le kit PDF (identique √† avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;


// PDF-only ‚Äî resserre *pmatrix* en array compact
// PDF-only ‚Äî compacte les vecteurs-colonne sans toucher l'√©cran
function tightenVectorsForPDF(html){
  if(!html) return html;

  // (a)  \begin{pmatrix} ... \end{pmatrix}  ->  ( array{c} ) + espaces n√©gatifs
  html = html.replace(
    /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (b)  \left( \begin{array}{c} ... \end{array} \right)  -> ajoute \! et r√©duit arraycolsep
  html = html.replace(
    /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (c)  versions sans \left...\right (rare) : ( array{c} ) ‚Üí ajoute \!
  html = html.replace(
    /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (d)  \pmatrix{‚Ä¶} macro √©ventuelle
  html = html.replace(
    /\\pmatrix\{([\s\S]*?)\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  return html;
}





/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
window.buildOneForPDFSync = function(defId){
  window.__PDF_BUILDING = true;           // ‚¨ÖÔ∏è d√©marre la zone neutre

  try {
    const cfg = REGISTRY_MAP[defId];
    if (!cfg) return { statement:'', solution:'' };

    const host   = document.querySelector('#host');
    const backup = host ? host.innerHTML : '';

    if (host) mountHost();
    document.querySelector('#lead').innerHTML = cfg.lead || '';

    // ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
    cfg.gen.call(cfg);


  // --- Restaure pour l‚Äô√©cran ---


  // ---- 1) R√©cup√©rer le rep√®re s‚Äôil existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // s√©curit√© namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) √ânonc√© texte (√©cran)
// on tente d'abord #equ ; sinon on prend le backup stock√© en state
const equHTML =
  (document.querySelector('#equ')?.innerHTML || '') ||
  (window.REGISTRY_MAP?.[defId]?.state?._equForPDF
     ? `<p>${window.REGISTRY_MAP[defId].state._equForPDF}</p>` : '');

  // √ânonc√© final : grille 2 colonnes si on a un rep√®re, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction (√©cran)
const _oldRetypeset2 = window.retypeset;
  const _oldMJ2        = window.MJ;
  window.retypeset = function(){};
  window.MJ        = function(){};
 cfg.solution.call(cfg, host, cfg.state); // ‚Üê passe bien host + √©tat courant
  
  // ---- Apr√®s cfg.solution.call(cfg); (et avant le restore) ----

// 2.1) R√©cup√©rer le SVG *corrig√©*
let corrigeRepereHTML = '';
{
  const svgSol = document.querySelector('.row svg.svgbox') || document.querySelector('svg.svgbox');
  if (svgSol){
    const clone = svgSol.cloneNode(true);
    clone.removeAttribute('style');
    clone.setAttribute('width','300');      // taille PDF
    clone.setAttribute('height','300');
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    corrigeRepereHTML = clone.outerHTML;
  }
}

// 2.2) R√©cup√©rer le HTML texte de la correction
const corrigeTexteHTML = (document.querySelector('#res')||{}).innerHTML || '';

// 2.3) Composer la *correction* pour le PDF : rep√®re + texte
const solution =
  corrigeRepereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${corrigeRepereHTML}</div>
         <div>${corrigeTexteHTML}</div>
       </div>`
    : corrigeTexteHTML;

  
  
  window.retypeset = _oldRetypeset2;
  window.MJ        = _oldMJ2;

  if (host) host.innerHTML = backup;

  // ---- 4) PDF-only : resserrer les pmatrix via TeX (espace interne)
  function tightenVectorsForPDF(html){
    if(!html) return html;
    // pmatrix -> array{c} + espaces n√©gatifs
    html = html.replace(
      /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \left( \begin{array}{c} ... \end{array} \right) -> ajoute \!
    html = html.replace(
      /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // versions sans \left...\right
    html = html.replace(
      /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \pmatrix{‚Ä¶}
    html = html.replace(
      /\\pmatrix\{([\s\S]*?)\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    return html;
  }

  const statementTight = statement;
  const solutionTight  = solution;
  
 function stripCHTML(html){
  if(!html) return html;
  return html
     .replace(/<mjx-container[\s\S]*?<\/mjx-container>/g, (m)=>{
       // On essaie de r√©cup√©rer le TeX source si MathJax l‚Äôa laiss√© en data-tex,
       // sinon on supprime (on n‚Äôen veut pas dans le PDF SVG).
       const tex = m.match(/data-tex="([^"]+)"/);
       return tex ? `\\(${tex[1]}\\)` : '';
     });
 }
 const statementClean = stripCHTML(statementTight);
 const solutionClean  = stripCHTML(solutionTight);

  // ‚ö†Ô∏è On wrappe ici avec .vec-tight pour activer le CSS ‚Äúresserr√©‚Äù c√¥t√© iframe PDF (SVG)
    return {
      statement: `<div class="vec-tight">${statementTight||''}</div>`,
      solution:  `<div class="vec-tight">${solutionTight||''}</div>`
    };
  } finally {
    window.__PDF_BUILDING = false;        // ‚¨ÖÔ∏è on r√©active l‚Äô√©cran quoi qu‚Äôil arrive
  }
};




/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){

  mountHost(); // injecte le layout par d√©faut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // √©l√©ments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', HOST);
  const fbEl  = $('#fb', HOST);
  const resEl = $('#res', HOST);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

  // g√©n√®re l'exo (peut remplacer enti√®rement le host, ex. e3/ex4)
  cfg.gen.call(cfg);




  // (re)typeset
  retypeset();

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
document.querySelector('#btn-reset').addEventListener('click', ()=>{
  const a=$('#ans',HOST); if(a) a.value='';
  document.querySelectorAll('.colvec input').forEach(i=> i.value=''); // ‚¨ÖÔ∏è AJOUT
  const f=$('#fb',HOST); if(f) f.textContent='';
  const r=$('#res',HOST); if(r) r.innerHTML='';
});
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
 document.querySelector('#btn-solution').addEventListener('click', ()=>{
   const ex = REGISTRY_MAP[ACTIVE];
   ex.solution.call(ex, HOST, ex.state);   // ‚Üê on passe host + √©tat courant
 });

function adjustLive(kind){
  const id = ACTIVE;
  if (id === 'e3'   && REGISTRY_MAP.e3.adjustLive)   REGISTRY_MAP.e3.adjustLive(kind);
  else if (id === 'ex4' && REGISTRY_MAP.ex4.adjustLive) REGISTRY_MAP.ex4.adjustLive(kind);
  else if (id === 'e5'  && REGISTRY_MAP.e5.adjustLive)  REGISTRY_MAP.e5.adjustLive(kind);
  else { applyAMPInputs(); }
}


['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;     buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) ‚Äî inchang√©, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);
// --- PDF-only: resserre les parenth√®ses des vecteurs-colonne ---
function tightenVectorsForPDF(html){
  if(!html) return html;
  // 1) diminue l'espace colonne dans les array (√©quivalent \arraycolsep)
  html = html.replace(/\\begin\{array\}\{c\}/g, '{\\arraycolsep=1.5pt\\begin{array}{c}');
  // 2) colle les grandes parenth√®ses √† la matrice (\left( ... \right))
  //    (sans toucher le reste du doc)
  html = html
    .replace(/\\left\(\s*\\begin\{array\}\{c\}/g, '\\left(\\mkern-6mu\\begin{array}{c}')
    .replace(/\\end\{array\}\s*\\right\)/g, '\\end{array}\\mkern-6mu\\right)');
  return html;
}

const statementTight = tightenVectorsForPDF(statement);
const solutionTight  = tightenVectorsForPDF(solution);

          const htmlIn =
  `<div class="exo-block">
     <span class="exo-title">Exercice</span>
     <div class="exo-statement">${statementTight||''}</div>
   </div>` +
  (withSolutions
    ? `<div style="margin-top:1rem;">
         <div class="exo-block"><div class="steps" id="pdf-steps">
           <span class="exo-title"></span>
           <!-- ‚¨áÔ∏è Ajout d‚Äôun conteneur .steps pour retrouver la zone grise -->
           <div class="exo-solution">${solutionTight||''}</div></div>
         </div>
       </div>`
    : '');


          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;
const css = idoc.createElement('style');
css.textContent = `
  :root{
    --ink:#111; --bg:#fafafa; --card:#fff; --line:#e5e7eb; --muted:#666;
    --steps-bg:#f3f4f6; --steps-border:#e5e7eb; --steps-left:#9aa0a6;
  }
  body{font:16px/1.55 system-ui,Segoe UI,Roboto,Arial;color:var(--ink);}
  .exo-title{display:block;font-weight:700;margin:0 0 6px}
  /* ‚öôÔ∏è Zone grise identique √† l‚Äô√©cran (#res.steps) */
  .steps{
    background:var(--steps-bg);
    border:1px solid var(--steps-border);
    border-left:4px solid var(--steps-left);
    border-radius:8px;
    padding:10px;
    margin:.45rem 0 0 .15rem;
  }
  .steps p{margin:.25rem 0}
  /* Table ‚Äúe5‚Äù compacte */
  .tbl3{border-collapse:collapse}
  .tbl3 td{padding:2px 6px;vertical-align:top}
  
  /* === Tighten parentheses around column vectors (SVG output) === */
/* CHTML (au cas o√π), agit sur les delimiters extensibles */
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:first-child { margin-right: -0.18em; }
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:last-child  { margin-left:  -0.18em; }
.vec-tight mjx-mtable mjx-mtd { padding-left: .15em; padding-right: .15em; }
.vec-tight mjx-mtable > mjx-table { margin-left: 0; margin-right: 0; }

/* SVG : d√©caler l√©g√®rement OPEN/CLOSE pour coller les parenth√®ses au tableau */
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="OPEN"]  { transform: translateX(-0.18em); }
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="CLOSE"] { transform: translateX( 0.18em); }

/* Ajustement global tr√®s l√©ger si besoin (peut √™tre mis √† 0 si tu pr√©f√®res) */
.vec-tight svg[aria-hidden="true"] { margin-left:-0.10em; margin-right:-0.10em; }
/* --- Anti "barres noires" MathJax (PDF) --- */
.exo-statement,
.exo-solution { color:#111 !important; background:transparent !important; }

/* Cas CHTML (au cas o√π) */
mjx-container { color:#111 !important; background:transparent !important; }
mjx-container svg { overflow:visible !important; }
mjx-container svg rect,
mjx-container svg path[data-mml-node="mspace"] { fill:none !important; }

/* Cas SVG standalone (ce que tu utilises dans l‚Äôiframe) */
.exo-statement svg rect,
.exo-statement svg path[data-mml-node="mspace"],
.exo-solution  svg rect,
.exo-solution  svg path[data-mml-node="mspace"] { fill:none !important; }
/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }
/* Tableau de la SOLUTION uniquement */
#res.steps table.pdf-tbl tbody tr > td.mid:first-of-type{
  text-align: right !important;   /* signe coll√© √† droite sur ]-‚àû ; r1[ */
}
#res.steps table.pdf-tbl tbody tr > td.mid:last-of-type{
  text-align: left !important;    /* signe coll√© √† gauche sur [rk ; +‚àû[ */
}

`;
idoc.head.appendChild(css);

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
