<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Fonctions affines - Repr√©sentations graphiques : Droites</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; --tick-ok:#11823b; --tick-ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}
#res.steps{background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;}
#res.steps p{margin:.25rem 0}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
@media print{ .controls,.header,.kbd-HOST,.hide-print{display:none!important} .card{box-shadow:none} }
.table-black{width:100%;border-collapse:collapse;border:1.2px solid #000}
.table-black th,.table-black td{border:1.2px solid #000;padding:6px 8px;text-align:left}
.table-black thead th{background:#fff}
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.chips{display:flex;gap:.5rem;margin:.25rem 0;flex-wrap:wrap}
.chip{
  display:inline-block; padding:.2rem .5rem; border:1px solid #bbb; border-radius:999px;
  cursor:pointer; user-select:none; line-height:1; font-weight:600;
}
.chip:focus{outline:2px solid #777; outline-offset:2px}
.chip.active{background:#111;color:#fff;border-color:#111}
</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/repere_patch_0813.js' defer></script>
</head>

<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Fonctions affines - Repr√©sentations graphiques : Droites</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="HOST"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les √©quations : <code>f(x)=mx+p</code> ou <code>f_i(x)=mx+p</code> (fractions et virgules fran√ßaises accept√©es).</li>
        <li>Jamais de <code>1x</code> ni <code>-1x</code> attendus : on √©crit <code>x</code> ou <code>-x</code>.</li>
        <li>Aucun <code>+-</code> ; les parenth√®ses autour d‚Äôun n√©gatif n‚Äôapparaissent qu‚Äôapr√®s un ¬´ ‚àí ¬ª.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ======================= Helpers g√©n√©riques ======================= */
const $  = (s,r=document)=>r.querySelector(s);
const $$ = (s,r=document)=>[...r.querySelectorAll(s)];
function retypeset(root){ if(window.MathJax?.typesetPromise) MathJax.typesetPromise([root||document]); }

function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function rnd(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function simp(p,q){ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return {p:p/g,q:q/g}; }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* ====== LaTeX helpers ====== */
function latexNum(n){ return (Number.isInteger(n)? String(n) : String(n).replace('.',',')); }
function latexSignNum(n){ return n<0?` - ${latexNum(Math.abs(n))}`:` + ${latexNum(n)}`; }
function latexMonomeX(m){ if(m===1) return 'x'; if(m===-1) return '‚àíx'; return `${latexNum(m)}x`; }
function latexFrac(p,q){ const S=simp(p,q); return (S.q===1? latexNum(S.p) : `\\dfrac{${S.p}}{${S.q}}`); }
function dot(c){ return `<span style="display:inline-block;width:.7rem;height:.7rem;border-radius:50%;background:${c};vertical-align:-1px;margin-right:.35rem"></span>`; }
const PALETTE = ['#0ea5e9','#22c55e','#ef4444','#a855f7','#f59e0b','#10b981'];

/* ====== Host UI scaffold ====== */
const HOST = $('#HOST');
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div class="row">
      <div id="rep-wrap"></div>
      <div>
        <div id="equ" class="eq"></div>
        <div id="res" class="steps"></div>
      </div>
    </div>
  `;
}
function setEqu(html){ $('#equ',HOST).innerHTML = html; retypeset(HOST); }
function setResHTML(html){ const r=$('#res',HOST); r.classList.add('steps'); r.innerHTML=html; retypeset(HOST); }
function setResP(lines){ setResHTML(lines.map(s=>`<p>${s}</p>`).join('')); }

/* ======================= Rep√®re minimal ======================= */
const AMP = { xmin:-6, xmax:6, ymin:-6, ymax:6 };

class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R}; this.g={};
    this.el = this._init();
    this.redraw();
  }
  _init(){
    const s = document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
    this.g.grid = document.createElementNS(s.namespaceURI,'g');
    this.g.axes = document.createElementNS(s.namespaceURI,'g');
    this.g.given= document.createElementNS(s.namespaceURI,'g');
    this.g.user = document.createElementNS(s.namespaceURI,'g');
    s.append(this.g.grid,this.g.axes,this.g.given,this.g.user);

    s.addEventListener('pointerdown', (ev)=>{
      if(!this.clickable || typeof this.onClick!=='function') return;
      const r = s.getBoundingClientRect();
      const X = ev.clientX - r.left, Y = ev.clientY - r.top;
      const P = this.screenToCoord(X,Y);
      this.onClick(P);
    });

    return s;
  }
  placeUser(label, x, y, color='#0a84ff'){
    const old = this.g.user.querySelector(`g[data-label="${label}"]`);
    if(old) old.remove();
    const p = this.coordToScreen(x,y);
    const G = document.createElementNS(this.el.namespaceURI,'g'); G.dataset.label = label;
    const c = document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx', p.x); c.setAttribute('cy', p.y); c.setAttribute('r', '5');  c.setAttribute('fill', color);
    const t = document.createElementNS(this.el.namespaceURI,'text');   t.setAttribute('x', p.x + 6); t.setAttribute('y', p.y - 6); t.setAttribute('font-size','12'); t.setAttribute('fill', color); t.textContent = label;
    G.append(c,t); this.g.user.appendChild(G);
  }
  clearUser(){ this.g.user.innerHTML = ''; }
  coordToScreen(x,y){ const {xmin,xmax,ymin,ymax} = this.R; const X = (x-xmin)/(xmax-xmin)*420; const Y = 420 - (y-ymin)/(ymax-ymin)*420; return {x:X,y:Y}; }
  screenToCoord(X,Y){ const {xmin,xmax,ymin,ymax} = this.R; const x = xmin + X/420*(xmax-xmin); const y = ymin + (420-Y)/420*(ymax-ymin); return {x,y}; }
  _line(x1,y1,x2,y2,thick=false){ const L=document.createElementNS(this.el.namespaceURI,'line'); L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2); L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.5:1); return L; }
  redraw(){
    const g=this.g; g.grid.innerHTML=''; g.axes.innerHTML=''; g.given.innerHTML=''; g.user.innerHTML='';
    const R=this.R;
    for(let x=R.xmin; x<=R.xmax; x++){ const a=this.coordToScreen(x,R.ymin), b=this.coordToScreen(x,R.ymax); g.grid.appendChild(this._line(a.x,a.y,b.x,b.y)); }
    for(let y=R.ymin; y<=R.ymax; y++){ const a=this.coordToScreen(R.xmin,y), b=this.coordToScreen(R.xmax,y); g.grid.appendChild(this._line(a.x,a.y,b.x,b.y)); }
    const axX=this._line(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
    const axY=this._line(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
    g.axes.append(axX,axY);
    for(let x=R.xmin; x<=R.xmax; x++){ if(x===0) continue; const p=this.coordToScreen(x,0); const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',p.x+2); t.setAttribute('y',p.y-2); t.setAttribute('font-size','11'); t.textContent=String(x); g.axes.appendChild(t); }
    for(let y=R.ymin; y<=R.ymax; y++){ if(y===0) continue; const p=this.coordToScreen(0,y); const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',p.x+4); t.setAttribute('y',p.y-2); t.setAttribute('font-size','11'); t.textContent=String(y); g.axes.appendChild(t); }
    const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
    const mkPt = (pt)=>{ const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',pt.x); c.setAttribute('cy',pt.y); c.setAttribute('r','3.5'); c.setAttribute('fill','#000'); return c; };
    const mkTx = (pt,lab)=>{ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',pt.x+4); t.setAttribute('y',pt.y-4); t.setAttribute('font-size','12'); t.textContent=lab; return t; };
    g.axes.append(mkPt(O), mkTx(O,'O'), mkPt(I), mkTx(I,'I'), mkPt(J), mkTx(J,'J'));
  }
  drawGivenLine(id,color,pts){
    let L=this.g.given.querySelector(`line[data-id="${id}"]`);
    if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.g.given.appendChild(L); }
    const a=this.coordToScreen(pts[0].x,pts[0].y), b=this.coordToScreen(pts[1].x,pts[1].y);
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','3');
  }
  drawUserInfiniteLine(id,color,P,Q){
    let L=this.g.user.querySelector(`line[data-id="${id}"]`);
    if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.g.user.appendChild(L); }
    const {xmin,xmax,ymin,ymax}=this.R;
    let A,B;
    if(P.x===Q.x){ A={x:P.x,y:ymin}; B={x:P.x,y:ymax}; } /* (reste utile si l‚Äô√©l√®ve clique align√© verticalement) */
    else{
      const m=(Q.y-P.y)/(Q.x-P.x), b=P.y - m*P.x;
      A={x:xmin, y:m*xmin+b}; B={x:xmax, y:m*xmax+b};
    }
    const a=this.coordToScreen(A.x,A.y), b=this.coordToScreen(B.x,B.y);
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','2.5');
  }
}

/* ======================= Outils droites ======================= */
function clipLineOnBox(R, line){
  const XMIN=R.xmin, XMAX=R.xmax, YMIN=R.ymin, YMAX=R.ymax;
  const pts=[];
  if(line.type==='h'){ pts.push({x:XMIN,y:line.k},{x:XMAX,y:line.k}); return pts; }
  // (on ne g√©n√®re plus de 'v', mais on garde la s√©curit√©)
  if(line.type==='v'){ pts.push({x:line.k,y:YMIN},{x:line.k,y:YMAX}); return pts; }
  const m = (line.type==='aff') ? line.m : (line.p/line.q);
  const b = line.b;
  const y_xmin = m*XMIN + b; if(y_xmin>=YMIN-1e-9 && y_xmin<=YMAX+1e-9) pts.push({x:XMIN,y:y_xmin});
  const y_xmax = m*XMAX + b; if(y_xmax>=YMIN-1e-9 && y_xmax<=YMAX+1e-9) pts.push({x:XMAX,y:y_xmax});
  if(Math.abs(m)>1e-9){
    const x_ymin = (YMIN - b)/m; if(x_ymin>=XMIN-1e-9 && x_ymin<=XMAX+1e-9) pts.push({x:x_ymin,y:YMIN});
    const x_ymax = (YMAX - b)/m; if(x_ymax>=XMIN-1e-9 && x_ymax<=XMAX+1e-9) pts.push({x:x_ymax,y:YMAX});
  }
  const uniq=[]; pts.forEach(P=>{ if(!uniq.some(Q=>Math.hypot(Q.x-P.x,Q.y-P.y)<1e-6)) uniq.push(P); });
  if(uniq.length>=2) return uniq.slice(0,2);
  return [{x:XMIN,y:y_xmin},{x:XMAX,y:y_xmax}];
}

function mkPresetLines(R){
  // 6 droites exactement, sans verticales :
  // - 2 affines (m,p entiers) avec m‚â†0 et p‚â†0
  // - 1 affine (m fraction r√©duite, p entier ‚â†0)
  // - 1 lin√©aire (p=0) m entier ‚â†0
  // - 1 lin√©aire (p=0) m fraction r√©duite ‚â†0
  // - 1 constante (horizontale)

  const inner={ xmin:R.xmin+1, xmax:R.xmax-1, ymin:R.ymin+1, ymax:R.ymax-1 };
  const slopesInt=[-5,-4,-3,-2,-1,1,2,3,4,5]; // d√©j√† sans 0
  const LINES=[];
  const seen = new Set(); // √©viter doublons exacts (m,b) ou (p/q,b)

  const ri=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const gcd=(a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; };
  const simp=(p,q)=>{ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return {p:p/g, q:q/g}; };

  function add(obj){
    const sig = (obj.type==='h') ? `h:${obj.k}` :
                (obj.type==='aff') ? `a:${obj.m}:${obj.b}` :
                `f:${obj.p}/${obj.q}:${obj.b}`;
    if(seen.has(sig)) return false;
    seen.add(sig); LINES.push(obj); return true;
  }

  function pickIntSlope(except=[]){
    const pool = slopesInt.filter(m=>!except.includes(m));
    return pool[ri(0,pool.length-1)];
  }
  function pickFracSlope(){
    let tries=200;
    while(tries--){
      let p = ri(1,5)*(Math.random()<.5?-1:1);
      let q = ri(2,5);
      const S = simp(p,q);
      if(S.q===1) continue;       // √©vite entier d√©guis√©
      return {p:S.p,q:S.q};       // m ‚â† 0 garanti
    }
    return {p:1,q:2};
  }
  function pickIntIntercept(){ return ri(inner.ymin, inner.ymax); }
  function pickIntInterceptNonZero(){
    let v; do{ v = pickIntIntercept(); } while(v===0);
    return v;                     // impose p ‚â† 0 pour les affines
  }

  // 1) Deux affines m,p entiers avec m‚â†0, p‚â†0
  const m1 = pickIntSlope();
  const b1 = pickIntInterceptNonZero();
  add({type:'aff', m:m1, b:b1, kind:'aff_int'});

  const m2 = pickIntSlope([m1]);
  const b2 = pickIntInterceptNonZero();
  add({type:'aff', m:m2, b:b2, kind:'aff_int'});

  // 2) Une affine m fraction (r√©duite) & p entier ‚â†0
  const mf = pickFracSlope();
  const bf = pickIntInterceptNonZero();
  add({type:'frac', p:mf.p, q:mf.q, b:bf, kind:'aff_frac'});

  // 3) Une lin√©aire m entier (p=0), m‚â†0
  let m3 = pickIntSlope([m1,m2]);
  add({type:'aff', m:m3, b:0, kind:'lin_int'});

  // 4) Une lin√©aire m fraction (p=0), m‚â†0
  const mf2 = pickFracSlope();
  add({type:'frac', p:mf2.p, q:mf2.q, b:0, kind:'lin_frac'});

  // 5) Une constante (horizontale)
  const k = pickIntIntercept();
  add({type:'h', k, kind:'const'});

  // √©tiquettes D1..D6 + index f_i
  for(let i=0;i<LINES.length;i++){
    LINES[i].name = 'D'+(i+1);
    LINES[i].fIndex = i+1;
  }
  return LINES;
}



/* ---------- Parsing d‚Äôune √©quation √©l√®ve (sans x=) ---------- */
function parseFrac(s){
  s = String(s||'').replace(/\u2212/g,'-').replace(',','.');
  if(/^[-+]?\d+\/\d+$/.test(s)){ const [p,q]=s.split('/').map(Number); if(q===0) return null; return simp(p,q); }
  if(/^[-+]?\d+(\.\d+)?$/.test(s)){ return {p: Number(s), q:1}; }
  return null;
}
function parseStudentEquation(text){
  if(!text) return null;
  let t = String(text).replace(/\s+/g,'').replace(/\u2212/g,'-').replace(',','.');

  // tol√©rance : f(x)= ‚Ä¶ ; f3(x)= ‚Ä¶ ; f_3(x)= ‚Ä¶
  t = t.replace(/^f(?:_?\d+)?\(x\)=/i,'y=');

  if(!/^y=/.test(t)) return null;
  const rhs = t.slice(2);

  if(!/x/.test(rhs)){ const fb=parseFrac(rhs); return fb ? {type:'aff', m:0, b:fb.p/fb.q} : null; }

  function parseMXStart(s){
    if(/^\+?x/.test(s))  return { m:1,  rest:s.replace(/^\+?x/,'') };
    if(/^-x/.test(s))    return { m:-1, rest:s.slice(2) };
    const m = s.match(/^([+\-]?(?:\d+\/\d+|\d+))x/);
    if(!m) return null;
    const M=parseFrac(m[1]); if(!M) return null;
    return { m:M.p/M.q, rest:s.slice(m[0].length) };
  }
  function parseBStart(s){
    const m = s.match(/^([+\-]?(?:\d+\/\d+|\d+))(.*)$/);
    if(!m) return null;
    const B=parseFrac(m[1]); if(!B) return null;
    return { b:B.p/B.q, rest:m[2]||'' };
  }

  const r1=parseMXStart(rhs);
  if(r1){
    if(r1.rest==='') return {type:'aff', m:r1.m, b:0};
    const fb=parseFrac(r1.rest); return fb? {type:'aff', m:r1.m, b:fb.p/fb.q}:null;
  }
  const r2=parseBStart(rhs);
  if(r2){
    const mx=parseMXStart(r2.rest);
    if(mx && mx.rest==='') return {type:'aff', m:mx.m, b:r2.b};
  }
  return null;
}

function setTick(el, val){
  if(!el) return;
  el.className = 'tick ' + (val===true ? 'ok' : val===false ? 'ko' : '');
  el.textContent = (val===true ? '‚úì' : val===false ? '‚úó' : '');
}

function renderWithRepere(host,opts){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const left=document.createElement('div'); const right=document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);
  const rep=new Repere(opts.R||AMP,{}); left.appendChild(rep.el);
  const equ=document.createElement('div'); equ.className='equ'; right.appendChild(equ);
  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  return {rep,left,right,equ,actions,res};
}

/* ======================= REGISTRY ======================= */
const REGISTRY_MAP = {

  /* ---- Exercice 1 : Tracer 6 droites ---- */
  e1:{
    name:"Tracer 6 droites",
    lead:"",
 gen(){
  const R={...AMP};
  const lines = mkPresetLines(R);

  // Marquer UNE des affines enti√®res pour l'affichage "p+mx"
  const affEnt = lines.filter(L=>L.kind==='aff_int');
  if(affEnt.length){
    const idx = Math.floor(Math.random()*affEnt.length);
    affEnt[idx].displayOrder = 'p+mx';
  }
  return {R,lines};
},

    render(HOST,s){
      const ui=renderWithRepere(HOST,{R:s.R}); HOST._ui=ui;
      ui.rep.clickable=true;

      const labelPairs = [['A','B'],['C','D'],['E','F'],['G','H'],['I','J'],['K','L']];
      s.lines.forEach((L,i)=>{ L.labels = labelPairs[i]; });

      const state = { clicks: {}, byLabel:{}, done: {}, focus: s.lines[0].name, awaitLabel:null };
      s.lines.forEach((L)=>{ state.clicks[L.name]=[]; state.byLabel[L.name]={}; state.done[L.name]=false; });
      HOST._perline = state;

const eqLatex = (L)=>{
  const idx = L.fIndex || 1;

  function latexNum(n){ return (Number.isInteger(n)? String(n) : String(n).replace('.',',')); }
  function latexSignNum(n){ return n<0?` - ${latexNum(Math.abs(n))}`:` + ${latexNum(n)}`; }
  function monoX(m){
    if(m===1) return 'x';
    if(m===-1) return '‚àíx';
    return `${latexNum(m)}x`;
  }
  function frac(p,q){ const a=Math.abs(p), b=Math.abs(q); return (b===1? String(p) : `\\dfrac{${a}}{${b}}`); }

  if(L.type==='h'){
    return `\\( f_{${idx}}(x) = ${latexNum(L.k)} \\)`;
  }
  if(L.type==='aff'){
    // ordre selon displayOrder √©ventuel
    if(L.displayOrder==='p+mx'){
      const left = latexNum(L.b);
      const right = (L.m===0?'': (L.m>0?` + ${monoX(L.m)}`:` - ${monoX(-L.m)}`)).replace(/\+\s+‚àí/g,' ‚àí ');
      return `\\( f_{${idx}}(x) = ${left}${right} \\)`;
    }
    // d√©faut : mx + p
    const p = (L.b===0?'' : latexSignNum(L.b));
    return `\\( f_{${idx}}(x) = ${monoX(L.m)}${p} \\)`;
  }
  // fraction : y = (p/q)x + b
  const s = L.p<0?'-':''; const P=Math.abs(L.p), Q=Math.abs(L.q);
  const btxt = (L.b===0?'':(L.b>0?' + '+latexNum(L.b):' - '+latexNum(Math.abs(L.b))));
  return `\\( f_{${idx}}(x) = ${s}\\dfrac{${P}}{${Q}}x${btxt} \\)`;
};


      const list = s.lines.map((L,i)=>{
        const c = PALETTE[i%PALETTE.length];
        return `<div class="perline" data-line="${L.name}">
          <div class="expr code" data-focus="${L.name}">${dot(c)} <b>${L.name}</b> : <span>${eqLatex(L)}</span></div>
          <button class="btn" data-validate="${L.name}">Valider</button>
          <span class="tick" id="tick_${L.name}">‚Äî</span>
        </div>`;
      }).join('');
      ui.equ.innerHTML = `
        <div><b>Consigne :</b> Clique une <b>expression</b> pour la s√©lectionner, choisis <b>la lettre</b> du point √† placer, puis clique dans le rep√®re pour le poser. Place deux points puis ‚ÄúValider‚Äù.</div>
        <p class="hint">Rappel : \\( f_i(x)=k \\) horizontale ; \\( f_i(x)=mx+p \\) : place \\( (0;p) \\), puis applique \\( m=\\dfrac{V}{H} \\).</p>
        <div style="margin-top:8px;display:grid;gap:6px">${list}</div>
      `;
      retypeset(ui.right);

      const picker = document.createElement('div');
      picker.id = 'point-picker';
      picker.className = 'small';
      picker.style.marginTop = '10px';
      ui.equ.appendChild(picker);
      ui.pointpicker = picker;

      const syncFocus = ()=>{ $$('.expr', ui.equ).forEach(x=>x.classList.toggle('focus', x.dataset.focus===state.focus)); };
      const renderPicker = ()=>{
        const name = state.focus;
        const i = s.lines.findIndex(x=>x.name===name);
        const [L1,L2] = s.lines[i].labels;
        const pts = state.byLabel[name] || {};
        picker.innerHTML = `
          <div><b>${name}</b> ‚Äî Choisir le point √† placer :</div>
          <div class="chips" role="group" aria-label="Points √† placer">
            <span class="chip" tabindex="0" role="button" data-pick="${L1}" aria-pressed="${state.awaitLabel===L1}">${L1}</span>
            <span class="chip" tabindex="0" role="button" data-pick="${L2}" aria-pressed="${state.awaitLabel===L2}">${L2}</span>
          </div>
          <div>${L1} : ${pts[L1]?`(${Math.round(pts[L1].x)};${Math.round(pts[L1].y)})`:'‚Äî'} ¬∑
               ${L2} : ${pts[L2]?`(${Math.round(pts[L2].x)};${Math.round(pts[L2].y)})`:'‚Äî'}</div>
          <div class="hint">Clique d‚Äôabord la lettre, puis clique dans le rep√®re.</div>
        `;
      };
      const highlightSelectedPoint = ()=>{
        $$('.chip', ui.pointpicker||document).forEach(ch=>{
          ch.classList.toggle('active', ch.dataset.pick===state.awaitLabel);
        });
        const root = ui?.rep?.g?.user;
        const groups = root ? root.querySelectorAll('g[data-label]') : [];
        groups.forEach(g=>{
          const lab = g.dataset.label;
          const c = g.querySelector('circle');
          const t = g.querySelector('text');
          if(!c || !t) return;
          if(!g.dataset.baseFill){
            g.dataset.baseFill = c.getAttribute('fill') || '#0a84ff';
            t.dataset.baseFill = t.getAttribute('fill') || g.dataset.baseFill;
          }
          if(lab === state.awaitLabel){
            c.setAttribute('fill','#000'); c.setAttribute('r','6');
            t.setAttribute('fill','#000'); t.setAttribute('font-weight','700');
          }else{
            const base = g.dataset.baseFill;
            c.setAttribute('fill', base); c.setAttribute('r','5');
            t.setAttribute('fill', t.dataset.baseFill || base); t.setAttribute('font-weight','400');
          }
        });
      };

      syncFocus(); renderPicker(); highlightSelectedPoint();

      function belongsTo(L,P){
        if(L.type==='h')   return Math.abs(P.y - L.k) < 1e-9;
        if(L.type==='aff') return Math.abs(P.y - (L.m*P.x + L.b)) < 1e-9;
        if(L.type==='frac')return Math.abs(P.y - (L.p/L.q*P.x + L.b)) < 1e-9;
        return false;
      }

      function snapToGrid(P, R=AMP){
        const x = clamp(Math.round(P.x), R.xmin, R.xmax);
        const y = clamp(Math.round(P.y), R.ymin, R.ymax);
        return { x, y };
      }

      ui.rep.onClick = (P)=>{
        const name = state.focus;
        const i = s.lines.findIndex(x=>x.name===name);
        const color = PALETTE[i%PALETTE.length];
        const [L1,L2] = s.lines[i].labels;
        const lab = state.awaitLabel;
        if(!lab || (lab!==L1 && lab!==L2)) return;

        const Ps = snapToGrid(P, s.R);
        ui.rep.placeUser(lab, Ps.x, Ps.y, color);
        state.byLabel[name][lab] = {x:Ps.x, y:Ps.y};

        const P1 = state.byLabel[name][L1];
        const P2 = state.byLabel[name][L2];
        state.clicks[name] = [];
        if(P1) state.clicks[name].push(P1);
        if(P2) state.clicks[name].push(P2);
        if(P1 && P2){
          ui.rep.drawUserInfiniteLine('ul_'+name, color, P1, P2);
        }
        renderPicker();
        highlightSelectedPoint();
      };

      ui.equ.addEventListener('click', (ev)=>{
        const expr = ev.target.closest('.expr[data-focus]');
        if(expr){
          state.focus = expr.dataset.focus;
          state.awaitLabel = null;
          syncFocus();
          renderPicker();
          highlightSelectedPoint();
        }
        const chip = ev.target.closest('.chip[data-pick]');
        if(chip){
          state.awaitLabel = chip.dataset.pick;
          renderPicker();
          highlightSelectedPoint();
        }
        const b = ev.target.closest('button[data-validate]');
        if(b){
          const name = b.dataset.validate;
          const clicks = state.clicks[name]||[];
          if(clicks.length<2){ setTick($('#tick_'+name, ui.equ), null); return; }
          const L = s.lines.find(x=>x.name===name);
          const ok = clicks.every(P=>belongsTo(L,P));
          state.done[name]=ok;
          setTick($('#tick_'+name, ui.equ), ok);
          const all = Object.values(state.done).every(Boolean);
          const res = $('#res', HOST);
          res.classList.remove('steps');
          res.className = all? 'res-ok':'';
          res.textContent = all? '‚úî Toutes les droites valid√©es' : '';
        }
      });

      HOST.dataset.state=JSON.stringify(s);
      this._state = { lines: s.lines };
    },
    verify(){
      const st = HOST._perline;
      if(!st){ const res=HOST._ui?.res; if(res){res.classList.remove('steps'); res.textContent='';} return {ok:false,total:1}; }
      const all = Object.values(st.done).length && Object.values(st.done).every(v=>v);
      const res = $('#res', HOST);
      res.classList.remove('steps');
      res.className = all? 'res-ok' : '';
      res.textContent = all? '‚úî Toutes les droites valid√©es' : '';
      return {ok:all,total:1};
    },
solution(){
    const st = this._state; if(!st) return;

    // petits helpers latex
    const Lnum = n => (Number.isInteger(n)? String(n) : String(n).replace('.',','));
    const monoX = m => (m===1?'x':m===-1?'‚àíx':`${Lnum(m)}x`);
    const frac  = (p,q)=> `\\dfrac{${Math.abs(p)}}{${Math.abs(q)}}`; // signe g√©r√© √† part

    // choix ‚Äúpas trop gros‚Äù :
    const pickSmall = () => [2,3,4,5][Math.floor(Math.random()*4)];
    const pickK123  = () => [1,2,3][Math.floor(Math.random()*3)]; // pour kq (pas toujours 1)

    function blockForLine(L){
      const i   = L.fIndex || 1;
      const name= L.name || ('D'+i);
      const letters = L.labels || ['A','B'];
      const A = letters[0], B = letters[1];

      // en-t√™te : f_i(x) = ...
      let head='';
      if(L.type==='h'){
        head = `\\( f_${i}(x) = ${Lnum(L.k)} \\)`;
      }else if(L.type==='aff'){
        head = `\\( f_${i}(x) = ${monoX(L.m)}${L.b===0?'':(L.b>0?' + '+Lnum(L.b):' - '+Lnum(Math.abs(L.b)))} \\)`;
      }else{ // frac
        const s = (L.p<0?'-':'');
        head = `\\( f_${i}(x) = ${s}${frac(L.p,L.q)}x${L.b===0?'':(L.b>0?' + '+Lnum(L.b):' - '+Lnum(Math.abs(L.b)))} \\)`;
      }

      // corps selon nature
      let body = '';

      if(L.kind==='aff_int'){ // m entier, p entier (‚â†0)
        const y0 = L.b;
        const x2 = pickSmall();                 // pas toujours 1
        const y2 = L.m*x2 + L.b;
        body += `<p>‚Ä¢ \\( f_${i}(0) = ${Lnum(L.m)}\\times 0 ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y0)} \\)</p>`;
        body += `<p>\\(${A}(0\\,;\\,${Lnum(y0)})\\) \\(\\in ${name}\\)</p>`;
        body += `<p>‚Ä¢ \\( f_${i}(${Lnum(x2)}) = ${Lnum(L.m)}\\times ${Lnum(x2)} ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y2)} \\)</p>`;
        body += `<p>\\(${B}(${Lnum(x2)}\\,;\\,${Lnum(y2)})\\) \\(\\in ${name}\\)</p>`;
      }
      else if(L.kind==='aff_frac'){ // m = p/q, p entier, q entier, p‚â†0, p et q r√©duits ; p entier b entier ‚â†0
        const y0 = L.b;
        const k  = pickK123();      // 1,2,3 (souvent 2 ou 3)
        const x2 = k*Math.abs(L.q);
        const y2 = (L.p/L.q)*x2 + L.b;  // = p*k + b
        const s  = (L.p<0?'-':'');
        body += `<p>‚Ä¢ \\( f_${i}(0) = ${s}${frac(L.p,L.q)}\\times 0 ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y0)} \\)</p>`;
        body += `<p>\\(${A}(0\\,;\\,${Lnum(y0)})\\) \\(\\in ${name}\\)</p>`;
        body += `<p>‚Ä¢ \\( f_${i}(${Lnum(x2)}) = ${s}${frac(L.p,L.q)}\\times ${Lnum(x2)} ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y2)} \\)</p>`;
        body += `<p>\\(${B}(${Lnum(x2)}\\,;\\,${Lnum(y2)})\\) \\(\\in ${name}\\)</p>`;
      }
      else if(L.kind==='lin_int'){ // p=0, m entier ‚â†0
        const x1 = pickSmall();      // non nul
        const y1 = L.m*x1;
        body += `<p>\\( f_${i}(${Lnum(x1)}) = ${Lnum(L.m)}\\times ${Lnum(x1)} = ${Lnum(y1)} \\)</p>`;
        body += `<p>\\(${A}(${Lnum(x1)}\\,;\\,${Lnum(y1)})\\) \\(\\in ${name}\\)</p>`;
        body += `<p>\\(O(0\\,;\\,0)\\) \\(\\in ${name}\\)</p>`;
      }
      else if(L.kind==='lin_frac'){ // p=0, m = p/q
        const k  = pickK123();
        const x1 = k*Math.abs(L.q);  // kq
        const y1 = (L.p/L.q)*x1;     // = p*k
        const s  = (L.p<0?'-':'');
        body += `<p>\\( f_${i}(${Lnum(x1)}) = ${s}${frac(L.p,L.q)}\\times ${Lnum(x1)} = ${Lnum(y1)} \\)</p>`;
        body += `<p>\\(${A}(${Lnum(x1)}\\,;\\,${Lnum(y1)})\\) \\(\\in ${name}\\)</p>`;
        body += `<p>\\(O(0\\,;\\,0)\\) \\(\\in ${name}\\)</p>`;
      }
      else if(L.kind==='const'){ // y = k
        body += `<p>Droite horizontale passant par \\(${Lnum(L.k)}\\) sur l‚Äôaxe des ordonn√©es.</p>`;
      }

      return `<div class="box">
        <p><b>${i}.&nbsp; ${head}</b></p>
        ${body}
      </div>`;
    }

    const html = `
	  <p>R√®gles :</p>
	  <p>‚Ä¢ Pour une fonction affine avec \\(m\\) entier : On calcule l'image de deux nombres quelconques (souvent 0 et un autre "pas trop grand"). <br> On obtient ensuite deux points que l'on rejoint pour tracer la droite.</p>
      	  <p>‚Ä¢ Pour une fonction affine avec \\(m\\) en fraction : On calcule l'image de deux nombres quelconques (souvent 0 et un autre : multiple du d√©nominateur).</p>
      	  <p>‚Ä¢ Pour une fonction lin√©aire : On calcule l'image d'un nombre diff√©rent de 0 avec les m√™mes r√®gles pr√©c√©dentes. <br> On obtient ensuite un point que l'on rejoint avec l'origine \\(O\\) du rep√®re pour tracer la droite.</p>
      	  <p>‚Ä¢ Pour une fonction constante du type \\(f(x)=p\\) : On trace une droite horizontale passant par \\(p\\) sur l'axe des ordonn√©es.</p>

      <div class="grid cols-3" style="gap:12px">
	
	  ${st.lines.map(blockForLine).join('')}
      </div>
    `;
    setResHTML(html);
  },
    reset(){
      if(HOST._ui) HOST._ui.rep.clearUser();
      if(HOST._ui){ $$('.tick', HOST._ui.equ).forEach(t=>setTick(t,null)); }
      const res = $('#res',HOST); res.classList.remove('steps'); res.textContent='';
    }
  },

  /* ---- Exercice 2 : √âcrire l‚Äô√©quation des 6 droites ---- */
  e2:{
    name:"D√©terminer l‚Äô√©quation des droites",
    lead:"Donner une √©quation pour chaque droite trac√©e (formes accept√©es : \\(f(x)=mx+p\\) ou \\(f_i(x)=mx+p\\)).",
    gen(){
      const R={...AMP};
      const rep = new Repere(R);
      $('#rep-wrap',HOST).innerHTML=''; $('#rep-wrap',HOST).appendChild(rep.el);

const lines = mkPresetLines(R);
      lines.forEach((L,i)=>{
        const seg=clipLineOnBox(R,L);
        rep.drawGivenLine(L.name, PALETTE[i%PALETTE.length], seg);
        // √©tiquette D1..D6
        if (!seg || seg.length < 2) return;
        const [P0, P1] = seg;
        const minX = Math.min(P0.x, P1.x), maxX = Math.max(P0.x, P1.x);
        const minY = Math.min(P0.y, P1.y), maxY = Math.max(P0.y, P1.y);

        let xlab, ylab, anchor = 'end';
        if (L.type === 'h') {
          xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
          ylab = L.k;
          anchor = 'end';
        } else {
          const m = (L.type === 'aff') ? L.m : (L.p / L.q);
          const b = L.b;
          xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
          ylab = clamp(m * xlab + b, minY + 0.3, maxY - 0.3);
          anchor = 'end';
        }
        const S = rep.coordToScreen(xlab, ylab);
        const t = document.createElementNS(rep.el.namespaceURI, 'text');
        t.setAttribute('x', S.x); t.setAttribute('y', S.y);
        t.setAttribute('font-size', '13'); t.setAttribute('font-weight', '700');
        t.setAttribute('fill', PALETTE[i % PALETTE.length]);
        t.setAttribute('text-anchor', anchor); t.setAttribute('dominant-baseline', 'central');
        t.setAttribute('paint-order', 'stroke'); t.setAttribute('stroke', '#fff'); t.setAttribute('stroke-width', '3');
        t.style.pointerEvents = 'none'; t.textContent = L.name;
        rep.el.appendChild(t);
      });

      const list = lines.map((L,i)=>`
        <div style="display:flex;align-items:center;gap:10px;margin:4px 0">
          ${dot(PALETTE[i%PALETTE.length])}
          <b style="min-width:2.2rem">${L.name}</b>
          <span class="small">\\(f_{${L.fIndex}}(x)=\\)</span>
          <input id="ans_${L.name}" placeholder="mx+p" style="width:220px">
          <span class="tick" id="tick_${L.name}"></span>
        </div>`).join('');
      setEqu(`<div>${list}</div>`);

      this._state = { R, rep, lines };
    },
    verify(){
      const st=this._state; if(!st) return {ok:false,total:0};
      let okAll=true, tot=0;
      for(const L of st.lines){
        tot++;
        const txt = $('#ans_'+L.name,HOST)?.value||'';
        if(!txt){ okAll=false; continue; }
        const p = parseStudentEquation(txt);
        let good=false;
        if(L.type==='h'){ good = p && p.type==='aff' && Math.abs(p.m)<1e-9 && Math.abs(p.b-L.k)<1e-9; }
        else if(L.type==='aff'){ good = p && p.type==='aff' && Math.abs(p.m-L.m)<1e-9 && Math.abs(p.b-L.b)<1e-9; }
        else { good = p && p.type==='aff' && Math.abs(p.m-(L.p/L.q))<1e-9 && Math.abs(p.b-L.b)<1e-9; }
        const ti = $('#tick_'+L.name,HOST);
        if(ti){ ti.className='tick '+(good?'ok':(txt?'ko':'')); ti.textContent = good?'‚úì':(txt?'‚úó':''); }
        okAll = okAll && !!good;
      }
      const res=$('#res',HOST); res.className = okAll?'res-ok':''; res.textContent = okAll ? '‚úî' : '';
      return {ok:okAll,total:tot};
    },
    solution(){
      const st=this._state; const out=[];
      st.lines.forEach(L=>{
        const i = L.fIndex || 1;
        if(L.type==='h'){ out.push(`<p><b>${L.name}</b> : \\( f_{${i}}(x) = ${latexNum(L.k)} \\)</p>`); return; }
        if(L.type==='aff'){ out.push(`<p><b>${L.name}</b> : \\( f_{${i}}(x) = ${latexMonomeX(L.m)}${L.b===0?'':latexSignNum(L.b)} \\)</p>`); }
        else{ out.push(`<p><b>${L.name}</b> : \\( f_{${i}}(x) = ${latexFrac(L.p,L.q)}x${L.b===0?'':latexSignNum(L.b)} \\)</p>`); }
      });
      setResP(out);
    }
  }
};

/* Expose REGISTRY (s√©lecteur + PDF kit) */
/* Expose REGISTRY (s√©lecteur + PDF kit) ‚Äî pont vers REGISTRY_MAP */
const REGISTRY = Object.entries(REGISTRY_MAP).map(([id, def]) => ({
  id,
  title: def.name || id,
  lead: def.lead || '',
  gen(hostEl){ return def.gen ? def.gen.call(def, hostEl) : undefined; },
  render(hostEl, state){ return def.render ? def.render.call(def, hostEl, state) : undefined; },
  verify(){ return def.verify ? def.verify.call(def) : {ok:false,total:0}; },
  solution(){ return def.solution ? def.solution.call(def) : undefined; },
  reset(){ return def.reset ? def.reset.call(def) : undefined; }
}));
window.REGISTRY = REGISTRY;


/* ======================= Fils de l‚ÄôUI ======================= */
(function(){
  let ACTIVE = 'e1'; let SCORE_OK=0, SCORE_TOT=0;
  const sel = $('#exo-select');
  sel.innerHTML = REGISTRY.map(d=>`<option value="${d.id}">${(REGISTRY_MAP[d.id].name||d.id)}</option>`).join('');
  ACTIVE = sel.value;

  function updateScore(){ $('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }

  function buildOne(){
    mountHost();
    const cfg = REGISTRY_MAP[ACTIVE];
    $('#lead',HOST).textContent = cfg.lead || '';
    const state = cfg.gen ? cfg.gen.call(cfg) : undefined;
    if (cfg.render) cfg.render.call(cfg, HOST, state);
    retypeset(HOST);
  }

  $('#btn-new').addEventListener('click', buildOne);
  $('#btn-reset').addEventListener('click', ()=>{
    $$('#equ input',HOST).forEach(i=>i.value='');
    $('#res',HOST).innerHTML=''; $('#res',HOST).className='steps';
    $$('.tick',HOST).forEach(t=>{ t.className='tick'; t.textContent=''; });
  });
  $('#btn-check').addEventListener('click', ()=>{
    SCORE_TOT++; const ret = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE]);
    if(ret && (ret.ok===true || ret===true)) SCORE_OK++;
    updateScore();
  });
  $('#btn-solution').addEventListener('click', ()=>{ REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]); });

  sel.addEventListener('change', ()=>{ ACTIVE = sel.value; buildOne(); });

  buildOne(); updateScore();
})();

/* ======================= PDF ======================= */
document.addEventListener('DOMContentLoaded', function () {
  if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
  ExoPDF.init({
    title: document.title,
    mountAfterSelector: '#HOST',
    beforeGen(){ return {}; },
    beforeRender(def){ 
      const equ = $('#equ',HOST)?.innerHTML||'';
      const res = $('#res',HOST)?.innerHTML||'';
      const svg = $('#rep-wrap svg')?.cloneNode(true);
      let repereHTML = '';
      if(svg){
        svg.removeAttribute('style'); svg.setAttribute('width','300'); svg.setAttribute('height','300');
        svg.setAttribute('xmlns','http://www.w3.org/2000/svg'); svg.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
        if(!svg.getAttribute('viewBox')) svg.setAttribute('viewBox','0 0 420 420');
        repereHTML = svg.outerHTML;
      }
      const statement = repereHTML
        ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start"><div>${repereHTML}</div><div>${equ}</div></div>`
        : equ;
      const solution  = res;
      return Promise.resolve(`<div class="exo-block"><div class="exo-statement">${statement}</div><div style="margin-top:.8rem" class="exo-solution steps">${solution}</div></div>`);
    }
  });
});
</script>
</body>
</html>
