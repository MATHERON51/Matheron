<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Fonctions affines - Repr√©sentations graphiques : Droites</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; --tick-ok:#11823b; --tick-ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}
#res.steps{background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;}
#res.steps p{margin:.25rem 0}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
.table-black{width:100%;border-collapse:collapse;border:1.2px solid #000}
.table-black th,.table-black td{border:1.2px solid #000;padding:6px 8px;text-align:left}
.table-black thead th{background:#fff}
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.chips{display:flex;gap:.5rem;margin:.25rem 0;flex-wrap:wrap}
.chip{
  display:inline-block; padding:.2rem .5rem; border:1px solid #bbb; border-radius:999px;
  cursor:pointer; user-select:none; line-height:1; font-weight:600;
}
.chip:focus{outline:2px solid #777; outline-offset:2px}
.chip.active{background:#111;color:#fff;border-color:#111}




</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/repere_patch_0813.js' defer></script>
</head>

<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Fonctions affines - Repr√©sentations graphiques : Droites</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

<div class="controls card" id="ampbar">
      <strong>Amplitude du rep√®re (max ¬±12) :</strong>
      <span>x ‚àà [</span><input id="xmin" type="number" value="-6" min="-12" max="12" step="1"><span>;</span>
      <input id="xmax" type="number" value="6"  min="-12" max="12" step="1"><span>],</span>
      <span>y ‚àà [</span><input id="ymin" type="number" value="-6" min="-12" max="12" step="1"><span>;</span>
      <input id="ymax" type="number" value="6"  min="-12" max="12" step="1"><span>]</span>
      
  </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les √©quations : <code>f(x)=mx+p</code> ou <code>f_i(x)=mx+p</code> (fractions et virgules fran√ßaises accept√©es).</li>
        <li>Jamais de <code>1x</code> ni <code>-1x</code> attendus : on √©crit <code>x</code> ou <code>-x</code>.</li>
        <li>Aucun <code>+-</code> ; les parenth√®ses autour d‚Äôun n√©gatif n‚Äôapparaissent qu‚Äôapr√®s un ¬´ ‚àí ¬ª.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ======================= Helpers g√©n√©riques ======================= */
const $  = (s,r=document)=>r.querySelector(s);
const $$ = (s,r=document)=>[...r.querySelectorAll(s)];
function retypeset(root){ if(window.MathJax?.typesetPromise) MathJax.typesetPromise([root||document]); }

function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
function rnd(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function simp(p,q){ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return {p:p/g,q:q/g}; }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* ====== LaTeX helpers ====== */
function latexNum(n){ return (Number.isInteger(n)? String(n) : String(n).replace('.',',')); }
function latexSignNum(n){ return n<0?` - ${latexNum(Math.abs(n))}`:` + ${latexNum(n)}`; }
function latexMonomeX(m){ if(m===1) return 'x'; if(m===-1) return '‚àíx'; return `${latexNum(m)}x`; }
function latexFrac(p,q){ const S=simp(p,q); return (S.q===1? latexNum(S.p) : `\\dfrac{${S.p}}{${S.q}}`); }
function dot(c){ return `<span style="display:inline-block;width:.7rem;height:.7rem;border-radius:50%;background:${c};vertical-align:-1px;margin-right:.35rem"></span>`; }
const PALETTE = ['#007aff', // bleu
                 '#ff3b30', // rouge
                 '#34c759', // vert
                 '#af52de', // violet
                 '#ff9500', // orange
                 '#5ac8fa']; // turquoise

/* ====== Host UI scaffold ====== */
const host = $('#host');
function mountHost(){
  host.innerHTML = `
    <div id="lead" class="small"></div>
    <div class="row">
      <div id="rep-wrap"></div>
      <div>
        <div id="equ" class="eq"></div>
        <div id="res" class="steps"></div>
      </div>
    </div>
  `;
}
function setEqu(html){ $('#equ',host).innerHTML = html; retypeset(host); }
function setResHTML(html){ const r=$('#res',host); r.classList.add('steps'); r.innerHTML=html; retypeset(host); }
function setResP(lines){ setResHTML(lines.map(s=>`<p>${s}</p>`).join('')); }

/* ======================= Rep√®re minimal ======================= */
const AMP = { xmin:-6, xmax:6, ymin:-6, ymax:6 };

class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6}){
    this.R={...R}; this.g={};
    this.el = this._init();
    this.redraw();
  }
  _init(){
    const s = document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
    this.g.grid = document.createElementNS(s.namespaceURI,'g');
    this.g.axes = document.createElementNS(s.namespaceURI,'g');
    this.g.given= document.createElementNS(s.namespaceURI,'g');
    this.g.user = document.createElementNS(s.namespaceURI,'g');
    s.append(this.g.grid,this.g.axes,this.g.given,this.g.user);

    s.addEventListener('pointerdown', (ev)=>{
      if(!this.clickable || typeof this.onClick!=='function') return;
      const r = s.getBoundingClientRect();
      const X = ev.clientX - r.left, Y = ev.clientY - r.top;
      const P = this.screenToCoord(X,Y);
      this.onClick(P);
    });

    return s;
  }
  placeUser(label, x, y, color='#0a84ff'){
    const old = this.g.user.querySelector(`g[data-label="${label}"]`);
    if(old) old.remove();
    const p = this.coordToScreen(x,y);
    const G = document.createElementNS(this.el.namespaceURI,'g'); G.dataset.label = label;
    const c = document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx', p.x); c.setAttribute('cy', p.y); c.setAttribute('r', '5');  c.setAttribute('fill', color);
    const t = document.createElementNS(this.el.namespaceURI,'text');   t.setAttribute('x', p.x + 6); t.setAttribute('y', p.y - 6); t.setAttribute('font-size','12'); t.setAttribute('fill', color); t.textContent = label;
    G.append(c,t); this.g.user.appendChild(G);
  }
  clearUser(){ this.g.user.innerHTML = ''; }
  coordToScreen(x,y){ const {xmin,xmax,ymin,ymax} = this.R; const X = (x-xmin)/(xmax-xmin)*420; const Y = 420 - (y-ymin)/(ymax-ymin)*420; return {x:X,y:Y}; }
  screenToCoord(X,Y){ const {xmin,xmax,ymin,ymax} = this.R; const x = xmin + X/420*(xmax-xmin); const y = ymin + (420-Y)/420*(ymax-ymin); return {x,y}; }
  
  setRange(Rnew){
  // met √† jour la fen√™tre puis refait la grille/axes (calques "given" et "user" seront vid√©s)
  this.R = {...Rnew};
  this.redraw();
}

  
  
  
  _line(x1,y1,x2,y2,thick=false){ const L=document.createElementNS(this.el.namespaceURI,'line'); L.setAttribute('x1',x1); L.setAttribute('y1',y1); L.setAttribute('x2',x2); L.setAttribute('y2',y2); L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.5:1); return L; }
  redraw(){
    const g=this.g; g.grid.innerHTML=''; g.axes.innerHTML=''; g.given.innerHTML=''; g.user.innerHTML='';
    const R=this.R;
    for(let x=R.xmin; x<=R.xmax; x++){ const a=this.coordToScreen(x,R.ymin), b=this.coordToScreen(x,R.ymax); g.grid.appendChild(this._line(a.x,a.y,b.x,b.y)); }
    for(let y=R.ymin; y<=R.ymax; y++){ const a=this.coordToScreen(R.xmin,y), b=this.coordToScreen(R.xmax,y); g.grid.appendChild(this._line(a.x,a.y,b.x,b.y)); }
    const axX=this._line(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
    const axY=this._line(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
    g.axes.append(axX,axY);
    for(let x=R.xmin; x<=R.xmax; x++){ if(x===0) continue; const p=this.coordToScreen(x,0); const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',p.x+2); t.setAttribute('y',p.y-2); t.setAttribute('font-size','11'); t.textContent=String(x); g.axes.appendChild(t); }
    for(let y=R.ymin; y<=R.ymax; y++){ if(y===0) continue; const p=this.coordToScreen(0,y); const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',p.x+4); t.setAttribute('y',p.y-2); t.setAttribute('font-size','11'); t.textContent=String(y); g.axes.appendChild(t); }
    const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
    const mkPt = (pt)=>{ const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',pt.x); c.setAttribute('cy',pt.y); c.setAttribute('r','3.5'); c.setAttribute('fill','#000'); return c; };
    const mkTx = (pt,lab)=>{ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',pt.x+4); t.setAttribute('y',pt.y-4); t.setAttribute('font-size','12'); t.textContent=lab; return t; };
    g.axes.append(mkPt(O), mkTx(O,'O'), mkPt(I), mkTx(I,'I'), mkPt(J), mkTx(J,'J'));
  }
  drawGivenLine(id,color,pts){
    let L=this.g.given.querySelector(`line[data-id="${id}"]`);
    if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.g.given.appendChild(L); }
    const a=this.coordToScreen(pts[0].x,pts[0].y), b=this.coordToScreen(pts[1].x,pts[1].y);
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','3');
  }
  drawUserInfiniteLine(id,color,P,Q){
    let L=this.g.user.querySelector(`line[data-id="${id}"]`);
    if(!L){ L=document.createElementNS(this.el.namespaceURI,'line'); L.dataset.id=id; this.g.user.appendChild(L); }
    const {xmin,xmax,ymin,ymax}=this.R;
    let A,B;
    if(P.x===Q.x){ A={x:P.x,y:ymin}; B={x:P.x,y:ymax}; } /* (reste utile si l‚Äô√©l√®ve clique align√© verticalement) */
    else{
      const m=(Q.y-P.y)/(Q.x-P.x), b=P.y - m*P.x;
      A={x:xmin, y:m*xmin+b}; B={x:xmax, y:m*xmax+b};
    }
    const a=this.coordToScreen(A.x,A.y), b=this.coordToScreen(B.x,B.y);
    L.setAttribute('x1',a.x); L.setAttribute('y1',a.y); L.setAttribute('x2',b.x); L.setAttribute('y2',b.y);
    L.setAttribute('stroke',color); L.setAttribute('stroke-width','2.5');
  }
}

/* ======================= Outils droites ======================= */
function clipLineOnBox(R, line){
  const XMIN=R.xmin, XMAX=R.xmax, YMIN=R.ymin, YMAX=R.ymax;
  const pts=[];
  if(line.type==='h'){ pts.push({x:XMIN,y:line.k},{x:XMAX,y:line.k}); return pts; }
  // (on ne g√©n√®re plus de 'v', mais on garde la s√©curit√©)
  if(line.type==='v'){ pts.push({x:line.k,y:YMIN},{x:line.k,y:YMAX}); return pts; }
  const m = (line.type==='aff') ? line.m : (line.p/line.q);
  const b = line.b;
  const y_xmin = m*XMIN + b; if(y_xmin>=YMIN-1e-9 && y_xmin<=YMAX+1e-9) pts.push({x:XMIN,y:y_xmin});
  const y_xmax = m*XMAX + b; if(y_xmax>=YMIN-1e-9 && y_xmax<=YMAX+1e-9) pts.push({x:XMAX,y:y_xmax});
  if(Math.abs(m)>1e-9){
    const x_ymin = (YMIN - b)/m; if(x_ymin>=XMIN-1e-9 && x_ymin<=XMAX+1e-9) pts.push({x:x_ymin,y:YMIN});
    const x_ymax = (YMAX - b)/m; if(x_ymax>=XMIN-1e-9 && x_ymax<=XMAX+1e-9) pts.push({x:x_ymax,y:YMAX});
  }
  const uniq=[]; pts.forEach(P=>{ if(!uniq.some(Q=>Math.hypot(Q.x-P.x,Q.y-P.y)<1e-6)) uniq.push(P); });
  if(uniq.length>=2) return uniq.slice(0,2);
  return [{x:XMIN,y:y_xmin},{x:XMAX,y:y_xmax}];
}

function mkPresetLines(R){
  // 6 droites exactement, sans verticales :
  // - 2 affines (m,p entiers) avec m‚â†0 et p‚â†0
  // - 1 affine (m fraction r√©duite, p entier ‚â†0)
  // - 1 lin√©aire (p=0) m entier ‚â†0
  // - 1 lin√©aire (p=0) m fraction r√©duite ‚â†0
  // - 1 constante (horizontale)

  const inner={ xmin:R.xmin+1, xmax:R.xmax-1, ymin:R.ymin+1, ymax:R.ymax-1 };
  const slopesInt=[-5,-4,-3,-2,-1,1,2,3,4,5]; // d√©j√† sans 0
  const LINES=[];
  const seen = new Set(); // √©viter doublons exacts (m,b) ou (p/q,b)

  const ri=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const gcd=(a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; };
  const simp=(p,q)=>{ if(q<0){ p=-p; q=-q; } const g=gcd(p,q); return {p:p/g, q:q/g}; };

  function add(obj){
    const sig = (obj.type==='h') ? `h:${obj.k}` :
                (obj.type==='aff') ? `a:${obj.m}:${obj.b}` :
                `f:${obj.p}/${obj.q}:${obj.b}`;
    if(seen.has(sig)) return false;
    seen.add(sig); LINES.push(obj); return true;
  }

  function pickIntSlope(except=[]){
    const pool = slopesInt.filter(m=>!except.includes(m));
    return pool[ri(0,pool.length-1)];
  }
  function pickFracSlope(){
    let tries=200;
    while(tries--){
      let p = ri(1,5)*(Math.random()<.5?-1:1);
      let q = ri(2,5);
      const S = simp(p,q);
      if(S.q===1) continue;       // √©vite entier d√©guis√©
      return {p:S.p,q:S.q};       // m ‚â† 0 garanti
    }
    return {p:1,q:2};
  }
  function pickIntIntercept(){ return ri(inner.ymin, inner.ymax); }
  function pickIntInterceptNonZero(){
    let v; do{ v = pickIntIntercept(); } while(v===0);
    return v;                     // impose p ‚â† 0 pour les affines
  }

  // 1) Deux affines m,p entiers avec m‚â†0, p‚â†0
  const m1 = pickIntSlope();
  const b1 = pickIntInterceptNonZero();
  add({type:'aff', m:m1, b:b1, kind:'aff_int'});

  const m2 = pickIntSlope([m1]);
  const b2 = pickIntInterceptNonZero();
  add({type:'aff', m:m2, b:b2, kind:'aff_int'});

  // 2) Une affine m fraction (r√©duite) & p entier ‚â†0
  const mf = pickFracSlope();
  const bf = pickIntInterceptNonZero();
  add({type:'frac', p:mf.p, q:mf.q, b:bf, kind:'aff_frac'});

  // 3) Une lin√©aire m entier (p=0), m‚â†0
  let m3 = pickIntSlope([m1,m2]);
  add({type:'aff', m:m3, b:0, kind:'lin_int'});

  // 4) Une lin√©aire m fraction (p=0), m‚â†0
  const mf2 = pickFracSlope();
  add({type:'frac', p:mf2.p, q:mf2.q, b:0, kind:'lin_frac'});

  // 5) Une constante (horizontale)
  const k = pickIntIntercept();
  add({type:'h', k, kind:'const'});

  // √©tiquettes D1..D6 + index f_i
  for(let i=0;i<LINES.length;i++){
    LINES[i].name = 'D'+(i+1);
    LINES[i].fIndex = i+1;
  }
  return LINES;
}



/* ---------- Parsing d‚Äôune √©quation √©l√®ve (sans x=) ---------- */
function parseFrac(s){
  s = String(s||'').replace(/\u2212/g,'-').replace(',','.');
  if(/^[-+]?\d+\/\d+$/.test(s)){ const [p,q]=s.split('/').map(Number); if(q===0) return null; return simp(p,q); }
  if(/^[-+]?\d+(\.\d+)?$/.test(s)){ return {p: Number(s), q:1}; }
  return null;
}
function parseStudentEquation(text){
  if(!text) return null;

  // normalisation
  let t = String(text).replace(/\s+/g,'')
                      .replace(/\u2212/g,'-')
                      .replace(',', '.');

  // tol√®re f(x)=..., f3(x)=..., f_3(x)=...
  t = t.replace(/^f(?:_?\d+)?\(x\)=/i, 'y=');

  // ‚¨áÔ∏è NOUVEAU : accepte la forme nue (pas de "y=")
  const rhs = /^y=/.test(t) ? t.slice(2) : t;

  if(!/x/.test(rhs)){                          // constante
    const fb = parseFrac(rhs);
    return fb ? { type:'aff', m:0, b:fb.p/fb.q } : null;
  }

  function parseMXStart(s){
    if(/^\+?x/.test(s))  return { m:1,  rest:s.replace(/^\+?x/,'') };
    if(/^-x/.test(s))    return { m:-1, rest:s.slice(2) };
    const m = s.match(/^([+\-]?(?:\d+\/\d+|\d+))x/);
    if(!m) return null;
    const M=parseFrac(m[1]); if(!M) return null;
    return { m:M.p/M.q, rest:s.slice(m[0].length) };
  }
  function parseBStart(s){
    const m = s.match(/^([+\-]?(?:\d+\/\d+|\d+))(.*)$/);
    if(!m) return null;
    const B=parseFrac(m[1]); if(!B) return null;
    return { b:B.p/B.q, rest:m[2]||'' };
  }

  const r1 = parseMXStart(rhs);
  if(r1){
    if(r1.rest==='') return {type:'aff', m:r1.m, b:0};
    const fb=parseFrac(r1.rest); return fb? {type:'aff', m:r1.m, b:fb.p/fb.q}:null;
  }
  const r2 = parseBStart(rhs);
  if(r2){
    const mx=parseMXStart(r2.rest);
    if(mx && mx.rest==='') return {type:'aff', m:mx.m, b:r2.b};
  }
  return null;
}


function setTick(el, val){
  if(!el) return;
  el.className = 'tick ' + (val===true ? 'ok' : val===false ? 'ko' : '');
  el.textContent = (val===true ? '‚úì' : val===false ? '‚úó' : '');
}

function renderWithRepere(host,opts){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const left=document.createElement('div'); const right=document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);

  const rep=new Repere(opts.R||AMP,{}); left.appendChild(rep.el);

  const equ=document.createElement('div');
  equ.id = 'equ';              // ‚úÖ ajoute l‚Äôid attendu par le PDF
  equ.className = 'eq';        // ‚úÖ m√™me classe que partout ailleurs
  right.appendChild(equ);

  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  return {rep,left,right,equ,actions,res};
}


function applyAMPInputs(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  xi=clamp(isNaN(xi)?-6:xi,-12,12); xa=clamp(isNaN(xa)?6:xa,-12,12);
  yi=clamp(isNaN(yi)?-6:yi,-12,12); ya=clamp(isNaN(ya)?6:ya,-12,12);
  if(xi===xa) xa=clamp(xi+1,-12,12); if(yi===ya) ya=clamp(yi+1,-12,12);
  if(xi>xa) [xi,xa]=[xa,xi]; if(yi>ya) [yi,ya]=[ya,yi];
  Object.assign(AMP,{xmin:xi,xmax:xa,ymin:yi,ymax:ya});
  ['xmin','xmax','ymin','ymax'].forEach(id=>$('#'+id).value=AMP[id]);
}





/* ======================= REGISTRY ======================= */
const REGISTRY_MAP = {

  /* ---- Exercice 1 : Tracer 6 droites ---- */
  e1:{
    name:"Tracer 6 droites",
    lead:"",
 gen(){
  const R={...AMP};
  const lines = mkPresetLines(R);

  // Marquer UNE des affines enti√®res pour l'affichage "p+mx"
  const affEnt = lines.filter(L=>L.kind==='aff_int');
  if(affEnt.length){
    const idx = Math.floor(Math.random()*affEnt.length);
    affEnt[idx].displayOrder = 'p+mx';
  }
  return {R,lines};
},

render(host, s){
  const ui = renderWithRepere(host,{R:s.R}); 
  host._ui = ui;
  // ‚¨áÔ∏è e1 seulement : #res en pleine largeur sous la grille/question
  const row = host.querySelector('.row');
  if (row && ui.res && ui.res.parentNode === ui.right) {
    ui.right.removeChild(ui.res);
    row.insertAdjacentElement('afterend', ui.res);
  }

  ui.rep.clickable = true;

      const labelPairs = [['A','B'],['C','D'],['E','F'],['G','H'],['I','J'],['K','L']];
      s.lines.forEach((L,i)=>{ L.labels = labelPairs[i]; });

      const state = { clicks: {}, byLabel:{}, done: {}, focus: s.lines[0].name, awaitLabel:null };
      s.lines.forEach((L)=>{ state.clicks[L.name]=[]; state.byLabel[L.name]={}; state.done[L.name]=false; });
      host._perline = state;

const eqLatex = (L)=>{
  const idx = L.fIndex || 1;

  function latexNum(n){ return (Number.isInteger(n)? String(n) : String(n).replace('.',',')); }
  function latexSignNum(n){ return n<0?` - ${latexNum(Math.abs(n))}`:` + ${latexNum(n)}`; }
  function monoX(m){
    if(m===1) return 'x';
    if(m===-1) return '‚àíx';
    return `${latexNum(m)}x`;
  }
  function frac(p,q){ const a=Math.abs(p), b=Math.abs(q); return (b===1? String(p) : `\\dfrac{${a}}{${b}}`); }

  if(L.type==='h'){
    return `\\( f_{${idx}}(x) = ${latexNum(L.k)} \\)`;
  }
  if(L.type==='aff'){
    // ordre selon displayOrder √©ventuel
    if(L.displayOrder==='p+mx'){
      const left = latexNum(L.b);
      const right = (L.m===0?'': (L.m>0?` + ${monoX(L.m)}`:` - ${monoX(-L.m)}`)).replace(/\+\s+‚àí/g,' ‚àí ');
      return `\\( f_{${idx}}(x) = ${left}${right} \\)`;
    }
    // d√©faut : mx + p
    const p = (L.b===0?'' : latexSignNum(L.b));
    return `\\( f_{${idx}}(x) = ${monoX(L.m)}${p} \\)`;
  }
  // fraction : y = (p/q)x + b
  const s = L.p<0?'-':''; const P=Math.abs(L.p), Q=Math.abs(L.q);
  const btxt = (L.b===0?'':(L.b>0?' + '+latexNum(L.b):' - '+latexNum(Math.abs(L.b))));
  return `\\( f_{${idx}}(x) = ${s}\\dfrac{${P}}{${Q}}x${btxt} \\)`;
};


      const list = s.lines.map((L,i)=>{
        const c = PALETTE[i%PALETTE.length];
        return `<div class="perline" data-line="${L.name}">
          <div class="expr code" data-focus="${L.name}">${dot(c)} <b>${L.name}</b> : <span>${eqLatex(L)}</span>
          <button class="btn" data-validate="${L.name}">Valider</button>
          <span class="tick" id="tick_${L.name}"></span></div>
        </div>`;
      }).join('');
      ui.equ.innerHTML = `
        <div><b>Consigne :</b> Clique une <b>expression</b> pour la s√©lectionner, choisis <b>la lettre</b> du point √† placer, puis clique dans le rep√®re pour le poser. Place deux points puis ‚ÄúValider‚Äù.</div>
        <div style="margin-top:8px;display:grid;gap:6px">${list}</div>
      `;
      retypeset(ui.right);

      const picker = document.createElement('div');
      picker.id = 'point-picker';
      picker.className = 'small';
      picker.style.marginTop = '10px';
      ui.equ.appendChild(picker);
      ui.pointpicker = picker;

      const syncFocus = ()=>{ $$('.expr', ui.equ).forEach(x=>x.classList.toggle('focus', x.dataset.focus===state.focus)); };
      const renderPicker = ()=>{
        const name = state.focus;
        const i = s.lines.findIndex(x=>x.name===name);
        const [L1,L2] = s.lines[i].labels;
        const pts = state.byLabel[name] || {};
        picker.innerHTML = `<div class="pdf-hide">
          <div><b>${name}</b> ‚Äî Choisir le point √† placer :</div>
          <div class="chips" role="group" aria-label="Points √† placer">
            <span class="chip" tabindex="0" role="button" data-pick="${L1}" aria-pressed="${state.awaitLabel===L1}">${L1}</span>
            <span class="chip" tabindex="0" role="button" data-pick="${L2}" aria-pressed="${state.awaitLabel===L2}">${L2}</span>
          </div>
          <div>${L1} : ${pts[L1]?`(${Math.round(pts[L1].x)};${Math.round(pts[L1].y)})`:'‚Äî'} ¬∑
               ${L2} : ${pts[L2]?`(${Math.round(pts[L2].x)};${Math.round(pts[L2].y)})`:'‚Äî'}</div>
          <div class="hint">Clique d‚Äôabord la lettre, puis clique dans le rep√®re.</div></div>
        `;
      };
      const highlightSelectedPoint = ()=>{
        $$('.chip', ui.pointpicker||document).forEach(ch=>{
          ch.classList.toggle('active', ch.dataset.pick===state.awaitLabel);
        });
        const root = ui?.rep?.g?.user;
        const groups = root ? root.querySelectorAll('g[data-label]') : [];
        groups.forEach(g=>{
          const lab = g.dataset.label;
          const c = g.querySelector('circle');
          const t = g.querySelector('text');
          if(!c || !t) return;
          if(!g.dataset.baseFill){
            g.dataset.baseFill = c.getAttribute('fill') || '#0a84ff';
            t.dataset.baseFill = t.getAttribute('fill') || g.dataset.baseFill;
          }
          if(lab === state.awaitLabel){
            c.setAttribute('fill','#000'); c.setAttribute('r','6');
            t.setAttribute('fill','#000'); t.setAttribute('font-weight','700');
          }else{
            const base = g.dataset.baseFill;
            c.setAttribute('fill', base); c.setAttribute('r','5');
            t.setAttribute('fill', t.dataset.baseFill || base); t.setAttribute('font-weight','400');
          }
        });
      };

      syncFocus(); renderPicker(); highlightSelectedPoint();

      function belongsTo(L,P){
        if(L.type==='h')   return Math.abs(P.y - L.k) < 1e-9;
        if(L.type==='aff') return Math.abs(P.y - (L.m*P.x + L.b)) < 1e-9;
        if(L.type==='frac')return Math.abs(P.y - (L.p/L.q*P.x + L.b)) < 1e-9;
        return false;
      }

      function snapToGrid(P, R=AMP){
        const x = clamp(Math.round(P.x), R.xmin, R.xmax);
        const y = clamp(Math.round(P.y), R.ymin, R.ymax);
        return { x, y };
      }

      ui.rep.onClick = (P)=>{
        const name = state.focus;
        const i = s.lines.findIndex(x=>x.name===name);
        const color = PALETTE[i%PALETTE.length];
        const [L1,L2] = s.lines[i].labels;
        const lab = state.awaitLabel;
        if(!lab || (lab!==L1 && lab!==L2)) return;

        const Ps = snapToGrid(P, s.R);
        ui.rep.placeUser(lab, Ps.x, Ps.y, color);
        state.byLabel[name][lab] = {x:Ps.x, y:Ps.y};

        const P1 = state.byLabel[name][L1];
        const P2 = state.byLabel[name][L2];
        state.clicks[name] = [];
        if(P1) state.clicks[name].push(P1);
        if(P2) state.clicks[name].push(P2);
        if(P1 && P2){
          ui.rep.drawUserInfiniteLine('ul_'+name, color, P1, P2);
        }
        renderPicker();
        highlightSelectedPoint();
      };

      ui.equ.addEventListener('click', (ev)=>{
        const expr = ev.target.closest('.expr[data-focus]');
        if(expr){
          state.focus = expr.dataset.focus;
          state.awaitLabel = null;
          syncFocus();
          renderPicker();
          highlightSelectedPoint();
        }
        const chip = ev.target.closest('.chip[data-pick]');
        if(chip){
          state.awaitLabel = chip.dataset.pick;
          renderPicker();
          highlightSelectedPoint();
        }
        const b = ev.target.closest('button[data-validate]');
        if(b){
          const name = b.dataset.validate;
          const clicks = state.clicks[name]||[];
          if(clicks.length<2){ setTick($('#tick_'+name, ui.equ), null); return; }
          const L = s.lines.find(x=>x.name===name);
          const ok = clicks.every(P=>belongsTo(L,P));
          state.done[name]=ok;
          setTick($('#tick_'+name, ui.equ), ok);
          const all = Object.values(state.done).every(Boolean);
          const res = $('#res', host);
          res.classList.remove('steps');
          res.className = all? 'res-ok':'';
          res.textContent = all? '‚úî Toutes les droites valid√©es' : '';
        }
      });

      host.dataset.state=JSON.stringify(s);
      this._state = { lines: s.lines };
    },
	
	
	adjustLive(kind){
  if(kind!=='amp') return;
  const ui  = host._ui;
  const rep = ui?.rep;
  const st  = this._state;                // { lines: [...] }
  const per = host._perline;              // clicks & labels de l‚Äô√©l√®ve

  if(!rep || !st || !per) return;

  // 1) changer la fen√™tre du rep√®re
  rep.setRange(AMP);

  // 2) Si la solution a d√©j√† trac√© les droites (flag pos√© par solution()), on les re-trace + √©tiquettes
  if(host._e1_solution_drawn){
    // nettoie donn√©es + anciennes √©tiquettes solution
    if (rep.g?.given) rep.g.given.innerHTML = '';
    rep.el.querySelectorAll('text[data-sol-label="true"]').forEach(n=>n.remove());

    st.lines.forEach((L,i)=>{
      const color = PALETTE[i%PALETTE.length];
      const seg   = clipLineOnBox(rep.R || AMP, L);
      rep.drawGivenLine(L.name, color, seg);

      // √©tiquette Dk
      if (!seg || seg.length < 2) return;
      const [P0,P1] = seg;
      const minX=Math.min(P0.x,P1.x), maxX=Math.max(P0.x,P1.x);
      const minY=Math.min(P0.y,P1.y), maxY=Math.max(P0.y,P1.y);
      let xlab, ylab;
      if (L.type === 'h'){ xlab = clamp(rep.R.xmax - 1, minX + .3, maxX - .3); ylab = L.k; }
      else{
        const m=(L.type==='aff')?L.m:(L.p/L.q), b=L.b;
        xlab = clamp(rep.R.xmax - 1, minX + .3, maxX - .3);
        ylab = clamp(m*xlab + b,  minY + .3, maxY - .3);
      }
      const S = rep.coordToScreen(xlab, ylab);
      const t = document.createElementNS(rep.el.namespaceURI,'text');
      t.setAttribute('x',S.x); t.setAttribute('y',S.y);
      t.setAttribute('font-size','13'); t.setAttribute('font-weight','700');
      t.setAttribute('fill', PALETTE[i%PALETTE.length]);
      t.setAttribute('text-anchor','end'); t.setAttribute('dominant-baseline','central');
      t.setAttribute('paint-order','stroke'); t.setAttribute('stroke','#fff'); t.setAttribute('stroke-width','3');
      t.setAttribute('data-sol-label','true'); t.style.pointerEvents='none';
      t.textContent = L.name;
      rep.el.appendChild(t);
    });
  }

  // 3) Re-placer les points de l‚Äô√©l√®ve (stock√©s en coords) et redessiner la ligne utilisateur
  rep.g.user.innerHTML = '';
  st.lines.forEach((L,i)=>{
    const color   = PALETTE[i%PALETTE.length];
    const labels  = L.labels || [];
    const name    = L.name;
    const store   = per.byLabel?.[name] || {};
    const A       = labels[0], B = labels[1];

    if(store[A]) rep.placeUser(A, store[A].x, store[A].y, color);
    if(store[B]) rep.placeUser(B, store[B].x, store[B].y, color);

    if(store[A] && store[B]){
      rep.drawUserInfiniteLine('ul_'+name, color, store[A], store[B]);
    }
  });
},

	
	
	
	
    verify(){
      const st = host._perline;
      if(!st){ const res=host._ui?.res; if(res){res.classList.remove('steps'); res.textContent='';} return {ok:false,total:1}; }
      const all = Object.values(st.done).length && Object.values(st.done).every(v=>v);
      const res = $('#res', host);
      res.classList.remove('steps');
      res.className = all? 'res-ok' : '';
      res.textContent = all? '‚úî Toutes les droites valid√©es' : '';
      return {ok:all,total:1};
    },
solution(){
  const st = this._state; if(!st) return;

  // 1) ‚Äî Tracer les droites en couleurs dans le rep√®re de gauche
// 1) ‚Äî Tracer les droites en couleurs + √©tiquettes Dk dans le rep√®re de gauche
const ui = host._ui;
const rep = ui?.rep;
if (rep && st.lines?.length){
  // nettoie le calque des donn√©es et les √©ventuelles anciennes √©tiquettes solution
  if (rep.g?.given) rep.g.given.innerHTML = '';
  rep.el.querySelectorAll('text[data-sol-label="true"]').forEach(n=>n.remove());

  const R = rep.R || AMP;

  st.lines.forEach((L,i)=>{
    const color = PALETTE[i % PALETTE.length];

    // segment de la droite dans le cadre
    const seg = clipLineOnBox(R, L);
    rep.drawGivenLine(L.name, color, seg);

    // ‚Äî √âtiquette Dk (m√™me logique que e2/e3)
    if (!seg || seg.length < 2) return;
    const [P0, P1] = seg;
    const minX = Math.min(P0.x, P1.x), maxX = Math.max(P0.x, P1.x);
    const minY = Math.min(P0.y, P1.y), maxY = Math.max(P0.y, P1.y);

    let xlab, ylab;
    if (L.type === 'h'){
      xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
      ylab = L.k;
    }else{
      const m = (L.type === 'aff') ? L.m : (L.p / L.q);
      const b = L.b;
      xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
      ylab = clamp(m * xlab + b, minY + 0.3, maxY - 0.3);
    }

    const S = rep.coordToScreen(xlab, ylab);
    const t = document.createElementNS(rep.el.namespaceURI, 'text');
    t.setAttribute('x', S.x);
    t.setAttribute('y', S.y);
    t.setAttribute('font-size', '13');
    t.setAttribute('font-weight', '700');
    t.setAttribute('fill', color);
    t.setAttribute('text-anchor', 'end');
    t.setAttribute('dominant-baseline', 'central');
    t.setAttribute('paint-order', 'stroke');
    t.setAttribute('stroke', '#fff');
    t.setAttribute('stroke-width', '3');
    t.setAttribute('data-sol-label', 'true'); // pour pouvoir les supprimer au prochain click "Solution"
    t.style.pointerEvents = 'none';
    t.textContent = L.name; // "D1"‚Ä¶ "D6"
    rep.el.appendChild(t);
  });
}

  host._e1_solution_drawn = true; // ‚úÖ flag pour adjustLive

  // 2) ‚Äî Correction texte (inchang√© : m√™mes helpers + blocs par type)
  const Lnum = n => (Number.isInteger(n)? String(n) : String(n).replace('.',','));
  const monoX = m => (m===1?'x':m===-1?'‚àíx':`${Lnum(m)}x`);
  const frac  = (p,q)=> `\\dfrac{${Math.abs(p)}}{${Math.abs(q)}}`; // signe √† part
  const pickSmall = () => [2,3,4,5][Math.floor(Math.random()*4)];
  const pickK123  = () => [1,2,3][Math.floor(Math.random()*3)];

  function blockForLine(L){
    const i   = L.fIndex || 1;
    const name= L.name || ('D'+i);
    const letters = L.labels || ['A','B'];
    const A = letters[0], B = letters[1];

    let head='';
    if(L.type==='h'){
      head = `\\( f_${i}(x) = ${Lnum(L.k)} \\)`;
    }else if(L.type==='aff'){
      head = `\\( f_${i}(x) = ${monoX(L.m)}${L.b===0?'':(L.b>0?' + '+Lnum(L.b):' - '+Lnum(Math.abs(L.b)))} \\)`;
    }else{
      const s = (L.p<0?'-':'');
      head = `\\( f_${i}(x) = ${s}${frac(L.p,L.q)}x${L.b===0?'':(L.b>0?' + '+Lnum(L.b):' - '+Lnum(Math.abs(L.b)))} \\)`;
    }

    let body='';
    if(L.kind==='aff_int'){
      const y0 = L.b;
      const x2 = pickSmall();
      const y2 = L.m*x2 + L.b;
      body += `<p>‚Ä¢ \\( f_${i}(0) = ${Lnum(L.m)}\\times 0 ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y0)} \\)</p>`;
      body += `<p>\\(${A}(0\\,;\\,${Lnum(y0)})\\in ${name}\\)</p>`;
      body += `<p>‚Ä¢ \\( f_${i}(${Lnum(x2)}) = ${Lnum(L.m)}\\times ${Lnum(x2)} ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y2)} \\)</p>`;
      body += `<p>\\(${B}(${Lnum(x2)}\\,;\\,${Lnum(y2)})\\in ${name}\\)</p>`;
    }
    else if(L.kind==='aff_frac'){
      const y0 = L.b;
      const k  = pickK123();
      const x2 = k*Math.abs(L.q);
      const y2 = (L.p/L.q)*x2 + L.b;
      const s  = (L.p<0?'-':'');
      body += `<p>‚Ä¢ \\( f_${i}(0) = ${s}${frac(L.p,L.q)}\\times 0 ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y0)} \\)</p>`;
      body += `<p>\\(${A}(0\\,;\\,${Lnum(y0)})\\in ${name}\\)</p>`;
      body += `<p>‚Ä¢ \\( f_${i}(${Lnum(x2)}) = ${s}${frac(L.p,L.q)}\\times ${Lnum(x2)} ${L.b>=0?'+':'‚àí'} ${Lnum(Math.abs(L.b))} = ${Lnum(y2)} \\)</p>`;
      body += `<p>\\(${B}(${Lnum(x2)}\\,;\\,${Lnum(y2)})\\in ${name}\\)</p>`;
    }
    else if(L.kind==='lin_int'){
      const x1 = pickSmall();
      const y1 = L.m*x1;
      body += `<p>\\( f_${i}(${Lnum(x1)}) = ${Lnum(L.m)}\\times ${Lnum(x1)} = ${Lnum(y1)} \\)</p>`;
      body += `<p>\\(${A}(${Lnum(x1)}\\,;\\,${Lnum(y1)})\\in ${name}\\)</p>`;
      body += `<p>\\(O(0\\,;\\,0)\\in ${name}\\)</p>`;
    }
    else if(L.kind==='lin_frac'){
      const k  = pickK123();
      const x1 = k*Math.abs(L.q);
      const y1 = (L.p/L.q)*x1;
      const s  = (L.p<0?'-':'');
      body += `<p>\\( f_${i}(${Lnum(x1)}) = ${s}${frac(L.p,L.q)}\\times ${Lnum(x1)} = ${Lnum(y1)} \\)</p>`;
      body += `<p>\\(${A}(${Lnum(x1)}\\,;\\,${Lnum(y1)})\\in ${name}\\)</p>`;
      body += `<p>\\(O(0\\,;\\,0)\\in ${name}\\)</p>`;
    }
    else if(L.kind==='const'){
      body += `<p>Droite horizontale passant par \\(${Lnum(L.k)}\\) sur l‚Äôaxe des ordonn√©es.</p>`;
    }

    return `<div class="box">
      <p><b>${i}.&nbsp; ${head}</b></p>
      ${body}
    </div>`;
  }

  const html = `
 	  <p>M√©thode (sans utiliser le coefficient directeur et l'ordonn√©e √† l'origine ):</p>
	  <p>‚Ä¢ Pour une fonction affine avec \\(m\\) entier : On calcule l'image de deux nombres quelconques (souvent 0 et un autre "pas trop grand"). <br> On obtient ensuite deux points que l'on rejoint pour tracer la droite.</p>
      	  <p>‚Ä¢ Pour une fonction affine avec \\(m\\) en fraction : On calcule l'image de deux nombres quelconques (souvent 0 et un autre : multiple du d√©nominateur).</p>
      	  <p>‚Ä¢ Pour une fonction lin√©aire : On calcule l'image d'un nombre diff√©rent de 0 avec les m√™mes r√®gles pr√©c√©dentes. <br> On obtient ensuite un point que l'on rejoint avec l'origine \\(O\\) du rep√®re pour tracer la droite.</p>
      	  <p>‚Ä¢ Pour une fonction constante du type \\(f(x)=p\\) : On trace une droite horizontale passant par \\(p\\) sur l'axe des ordonn√©es.</p>
 <div class="grid cols-3" style="gap:12px">
      ${st.lines.map(blockForLine).join('')}
    </div>
  `;
  setResHTML(html);
},

    reset(){
      if(host._ui) host._ui.rep.clearUser();
      if(host._ui){ $$('.tick', host._ui.equ).forEach(t=>setTick(t,null)); }
      const res = $('#res',host); res.classList.remove('steps'); res.textContent='';
    }
  },


  /* ---- Exercice 2 : Associer les expressions aux droites ---- */
e2:{
  name:"Associer droites ‚Üî expressions",
  lead:"Les droites \\(D_1\\) √† \\(D_6\\) sont trac√©es. Pour chaque expression \\(f_i(x)\\), <b>saisir</b> le nom de la droite (ex. <code>D3</code> ou <code>3</code>) <b>ou</b> la <b>choisir</b> dans la liste.",

gen(){
  const R={...AMP};
  const rep = new Repere(R);
  $('#rep-wrap',host).innerHTML=''; $('#rep-wrap',host).appendChild(rep.el);

  // 1) reprendre exactement les droites de e2 si elles existent, sinon g√©n√©rer
  let lines;
  if (window.__E2_LINES__ && Array.isArray(window.__E2_LINES__) && window.__E2_LINES__.length===6){
    lines = window.__E2_LINES__.map(L=>({...L})); // clone l√©ger
  }else{
    lines = mkPresetLines(R);
    // si e2 n‚Äôa pas tourn√© avant, on applique aussi une permutation locale des Dk
    (function permuteDNames(){
      const names = ['D1','D2','D3','D4','D5','D6'];
      for(let i=names.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [names[i],names[j]]=[names[j],names[i]]; }
      lines.forEach((L,i)=>{ L.name = names[i]; });
    })();
  }

  // 2) tracer les droites et poser les √©tiquettes Dk (d√©j√† permut√©es)
  lines.forEach((L,i)=>{
    const seg=clipLineOnBox(R,L);
    rep.drawGivenLine(L.name, PALETTE[i%PALETTE.length], seg);
    if (!seg || seg.length < 2) return;
    const [P0, P1] = seg;
    const minX = Math.min(P0.x, P1.x), maxX = Math.max(P0.x, P1.x);
    const minY = Math.min(P0.y, P1.y), maxY = Math.max(P0.y, P1.y);
    let xlab, ylab;
    if (L.type === 'h') { xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3); ylab = L.k; }
    else { const m=(L.type==='aff')?L.m:(L.p/L.q), b=L.b;
      xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
      ylab = clamp(m*xlab + b, minY + 0.3, maxY - 0.3);
    }
    const S = rep.coordToScreen(xlab, ylab);
    const t = document.createElementNS(rep.el.namespaceURI,'text');
    t.setAttribute('x',S.x); t.setAttribute('y',S.y);
    t.setAttribute('font-size','13'); t.setAttribute('font-weight','700');
    t.setAttribute('fill', PALETTE[i%PALETTE.length]);
    t.setAttribute('text-anchor','end'); t.setAttribute('dominant-baseline','central');
    t.setAttribute('paint-order','stroke'); t.setAttribute('stroke','#fff'); t.setAttribute('stroke-width','3');
    t.style.pointerEvents='none'; t.textContent=L.name;
    rep.el.appendChild(t);
  });

  // 3) fabrique de l‚Äôexpression latex pour f_i (pas de 1x, pas de "+-")
  const Lnum = n => (Number.isInteger(n)? String(n) : String(n).replace('.',','));
  const monoX = m => (m===1?'x': m===-1?'‚àíx': `${Lnum(m)}x`);
  const frac  = (p,q)=> `\\dfrac{${Math.abs(p)}}{${Math.abs(q)}}`;
  function exprLatex(L){
    const i=L.fIndex||1;
    if(L.type==='h')  return `\\( f_{${i}}(x) = ${Lnum(L.k)} \\)`;
    if(L.type==='aff'){
      const btxt=(L.b===0?'':(L.b>0?` + ${Lnum(L.b)}`:` - ${Lnum(Math.abs(L.b))}`));
      return `\\( f_{${i}}(x) = ${monoX(L.m)}${btxt} \\)`;
    }
    const s=(L.p<0?'-':'');
    const btxt=(L.b===0?'':(L.b>0?` + ${Lnum(L.b)}`:` - ${Lnum(Math.abs(L.b))}`));
    return `\\( f_{${i}}(x) = ${s}${frac(L.p,L.q)}x${btxt} \\)`;
  }

  // 4) expressions tri√©es par fIndex croissant => f1, f2, ..., f6
  const exprs = lines
    .slice()
    .sort((a,b)=>(a.fIndex||0)-(b.fIndex||0))
    .map(L=>({ fid:L.fIndex, text:exprLatex(L), lineName:L.name }));

  const state = { R, rep, lines, exprs };
  this._state = state;
  return state;
},


  render(host, st){
    const list = st.exprs.map((E,idx)=>{
const count = st.lines.length; // 6
const names = Array.from({length: count}, (_,i) => `D${i+1}`);
const opts  = names.map(n => `<option value="${n}">${n}</option>`).join('');
      return `
        <div class="indline" data-row="${idx}">
          <span>${E.text}</span>

          

          <select id="pick_${idx}" aria-label="Choisir la droite pour f${E.fid}">
            <option value="">‚Äî choisir ‚Äî</option>
            ${opts}
          </select>

          <span class="tick" id="tick_${idx}"></span>
        </div>`;
    }).join('');

    setEqu(`
      <div><b>Consigne :</b> Associer chaque expression \\(f_i(x)\\) √† la bonne droite \\(D_k\\) (vue dans le rep√®re). Vous pouvez <b>taper</b> <code>Dk</code> (ou juste le chiffre) <b>ou</b> utiliser le <b>s√©lecteur</b>.</div>
      <div style="margin-top:8px">${list}</div>
    `);

    // Entr√©e: touche Enter d√©clenche "V√©rifier"
    st.exprs.forEach((_,idx)=>{
      const inp = document.getElementById('inp_'+idx);
      if(inp){
        inp.addEventListener('keydown', (e)=>{
          if(e.key==='Enter'){ e.preventDefault(); document.getElementById('btn-check')?.click(); }
        });
      }
    });

    retypeset(host);
  },
  
  
  adjustLive(kind){
  if(kind!=='amp') return;
  const st  = this._state; if(!st) return;
  const rep = st.rep;       if(!rep) return;

  rep.setRange(AMP);
  if (rep.g?.given) rep.g.given.innerHTML = '';
  rep.el.querySelectorAll('text[data-e3-label="true"]').forEach(n=>n.remove());

  st.lines.forEach((L,i)=>{
    const seg = clipLineOnBox(rep.R || AMP, L);
    rep.drawGivenLine(L.name, PALETTE[i%PALETTE.length], seg);

    if (!seg || seg.length < 2) return;
    const [P0,P1] = seg;
    const minX=Math.min(P0.x,P1.x), maxX=Math.max(P0.x,P1.x);
    const minY=Math.min(P0.y,P1.y), maxY=Math.max(P0.y,P1.y);
    let xlab, ylab;
    if (L.type === 'h'){ xlab = clamp(rep.R.xmax - 1, minX + .3, maxX - .3); ylab = L.k; }
    else{
      const m=(L.type==='aff')?L.m:(L.p/L.q), b=L.b;
      xlab = clamp(rep.R.xmax - 1, minX + .3, maxX - .3);
      ylab = clamp(m*xlab + b,  minY + .3, maxY - .3);
    }
    const S = rep.coordToScreen(xlab, ylab);
    const t = document.createElementNS(rep.el.namespaceURI,'text');
    t.setAttribute('x',S.x); t.setAttribute('y',S.y);
    t.setAttribute('font-size','13'); t.setAttribute('font-weight','700');
    t.setAttribute('fill', PALETTE[i%PALETTE.length]);
    t.setAttribute('text-anchor','end'); t.setAttribute('dominant-baseline','central');
    t.setAttribute('paint-order','stroke'); t.setAttribute('stroke','#fff'); t.setAttribute('stroke-width','3');
    t.setAttribute('data-e3-label','true'); t.style.pointerEvents='none';
    t.textContent = L.name;
    rep.el.appendChild(t);
  });
},

  
  

  verify(){
    const st=this._state; if(!st) return false;

    const norm = (raw)=>{
      if(!raw) return '';
      let t = String(raw).trim().toUpperCase().replace(/\s+/g,'');
      // accept "3" ‚Üí "D3", "D3" ‚Üí "D3"
      const m = t.match(/^D?([1-6])$/);
      return m ? ('D'+m[1]) : '';
    };

    let okAll=true;
    st.exprs.forEach((E,idx)=>{
      const sel = document.getElementById('pick_'+idx);
      const inp = document.getElementById('inp_'+idx);

      const fromSel = sel?.value || '';
      const fromInp = norm(inp?.value||'');

      // priorit√© √† la s√©lection si pr√©sente, sinon l‚Äôinput
      const choice = fromSel || fromInp;

      const good = (choice === E.lineName);
      setTick(document.getElementById('tick_'+idx), choice ? !!good : null);
      okAll = okAll && !!good;
    });

    const res=$('#res',host);
    res.classList.remove('steps');
    res.className = okAll?'res-ok':'';
    res.textContent = okAll ? '‚úî' : '';
    return okAll;
  },

  solution(){
  const st = this._state; if(!st) return;

  const intro = `
    <p><strong>M√©thode</strong> (sans utiliser le coefficient directeur et l‚Äôordonn√©e √† l‚Äôorigine) :</p>
    <p>On calcule l‚Äôimage de deux r√©els ; cela donne deux points √† identifier dans le rep√®re&nbsp;: on trouve ainsi la droite correspondante.</p>
    <hr class="sep">
  `;

  const rows = st.exprs.map((E)=>{
    const i = st.lines.findIndex(L => L.name === E.lineName);
    const c = PALETTE[i % PALETTE.length];
    return `<p>${E.text} ‚ü∂ ${dot(c)} <b>${E.lineName}</b></p>`;
  }).join('');

  setResHTML(intro + rows);
}
,

  reset(){
    (this._state?.exprs||[]).forEach((_,idx)=>{
      const sel = document.getElementById('pick_'+idx); if(sel) sel.value='';
      const inp = document.getElementById('inp_'+idx);  if(inp) inp.value='';
      const t   = document.getElementById('tick_'+idx); if(t)  setTick(t,null);
    });
    const r=$('#res',host); if(r){ r.classList.remove('steps'); r.textContent=''; }
  }
},




  /* ---- Exercice 3 : √âcrire l‚Äô√©quation des 6 droites ---- */
  e3:{
    name:"D√©terminer l‚Äô√©quation des droites",
    lead:"Donner une √©quation pour chaque droite trac√©e .",
    gen(){
      const R={...AMP};
      const rep = new Repere(R);
      $('#rep-wrap',host).innerHTML=''; $('#rep-wrap',host).appendChild(rep.el);

const lines = mkPresetLines(R);
      lines.forEach((L,i)=>{
        const seg=clipLineOnBox(R,L);
        rep.drawGivenLine(L.name, PALETTE[i%PALETTE.length], seg);
        // √©tiquette D1..D6
        if (!seg || seg.length < 2) return;
        const [P0, P1] = seg;
        const minX = Math.min(P0.x, P1.x), maxX = Math.max(P0.x, P1.x);
        const minY = Math.min(P0.y, P1.y), maxY = Math.max(P0.y, P1.y);

        let xlab, ylab, anchor = 'end';
        if (L.type === 'h') {
          xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
          ylab = L.k;
          anchor = 'end';
        } else {
          const m = (L.type === 'aff') ? L.m : (L.p / L.q);
          const b = L.b;
          xlab = clamp(R.xmax - 1, minX + 0.3, maxX - 0.3);
          ylab = clamp(m * xlab + b, minY + 0.3, maxY - 0.3);
          anchor = 'end';
        }
        const S = rep.coordToScreen(xlab, ylab);
        const t = document.createElementNS(rep.el.namespaceURI, 'text');
        t.setAttribute('x', S.x); t.setAttribute('y', S.y);
        t.setAttribute('font-size', '13'); t.setAttribute('font-weight', '700');
        t.setAttribute('fill', PALETTE[i % PALETTE.length]);
        t.setAttribute('text-anchor', anchor); t.setAttribute('dominant-baseline', 'central');
        t.setAttribute('paint-order', 'stroke'); t.setAttribute('stroke', '#fff'); t.setAttribute('stroke-width', '3');
        t.style.pointerEvents = 'none'; t.textContent = L.name;
        rep.el.appendChild(t);
      });

const list = lines.map((L,i)=>`
  <div style="display:flex;align-items:center;gap:10px;margin:4px 0">
    ${dot(PALETTE[i%PALETTE.length])}
    <b style="min-width:2.2rem">${L.name}</b>
    <span class="small eqonly" aria-hidden="false">\\(f_{${L.fIndex}}(x)=\\)</span>
    <input id="ans_${L.name}" placeholder="" style="width:260px" aria-label="√âquation de ${L.name}">
    <span class="tick" id="tick_${L.name}"></span>
  </div>`).join('');
setEqu(`<div>${list}</div>`);


      this._state = { R, rep, lines };
    },
	
	
	adjustLive(kind){
  if(kind!=='amp') return;
  const st  = this._state; if(!st) return;
  const rep = st.rep;       if(!rep) return;

  rep.setRange(AMP);
  // efface calque "given" + labels existants
  if (rep.g?.given) rep.g.given.innerHTML = '';
  rep.el.querySelectorAll('text[data-e2-label="true"]').forEach(n=>n.remove());

  st.lines.forEach((L,i)=>{
    const seg = clipLineOnBox(rep.R || AMP, L);
    rep.drawGivenLine(L.name, PALETTE[i%PALETTE.length], seg);

    if (!seg || seg.length < 2) return;
    const [P0,P1] = seg;
    const minX=Math.min(P0.x,P1.x), maxX=Math.max(P0.x,P1.x);
    const minY=Math.min(P0.y,P1.y), maxY=Math.max(P0.y,P1.y);
    let xlab, ylab;
    if (L.type === 'h'){ xlab = clamp(rep.R.xmax - 1, minX + .3, maxX - .3); ylab = L.k; }
    else{
      const m=(L.type==='aff')?L.m:(L.p/L.q), b=L.b;
      xlab = clamp(rep.R.xmax - 1, minX + .3, maxX - .3);
      ylab = clamp(m*xlab + b,  minY + .3, maxY - .3);
    }
    const S = rep.coordToScreen(xlab, ylab);
    const t = document.createElementNS(rep.el.namespaceURI,'text');
    t.setAttribute('x',S.x); t.setAttribute('y',S.y);
    t.setAttribute('font-size','13'); t.setAttribute('font-weight','700');
    t.setAttribute('fill', PALETTE[i%PALETTE.length]);
    t.setAttribute('text-anchor','end'); t.setAttribute('dominant-baseline','central');
    t.setAttribute('paint-order','stroke'); t.setAttribute('stroke','#fff'); t.setAttribute('stroke-width','3');
    t.setAttribute('data-e2-label','true'); t.style.pointerEvents='none';
    t.textContent = L.name;
    rep.el.appendChild(t);
  });
},

	
	
    verify(){
      const st=this._state; if(!st) return {ok:false,total:0};
      let okAll=true, tot=0;
      for(const L of st.lines){
        tot++;
        const txt = $('#ans_'+L.name,host)?.value||'';
        if(!txt){ okAll=false; continue; }
        const p = parseStudentEquation(txt);
        let good=false;
        if(L.type==='h'){ good = p && p.type==='aff' && Math.abs(p.m)<1e-9 && Math.abs(p.b-L.k)<1e-9; }
        else if(L.type==='aff'){ good = p && p.type==='aff' && Math.abs(p.m-L.m)<1e-9 && Math.abs(p.b-L.b)<1e-9; }
        else { good = p && p.type==='aff' && Math.abs(p.m-(L.p/L.q))<1e-9 && Math.abs(p.b-L.b)<1e-9; }
        const ti = $('#tick_'+L.name,host);
        if(ti){ ti.className='tick '+(good?'ok':(txt?'ko':'')); ti.textContent = good?'‚úì':(txt?'‚úó':''); }
        okAll = okAll && !!good;
      }
      const res=$('#res',host); res.className = okAll?'res-ok':''; res.textContent = okAll ? '‚úî' : '';
      return {ok:okAll,total:tot};
    },
    solution(){
      const st=this._state; const out=[];
      st.lines.forEach(L=>{
        const i = L.fIndex || 1;
        if(L.type==='h'){ out.push(`<p><b>${L.name}</b> : \\( f_{${i}}(x) = ${latexNum(L.k)} \\)</p>`); return; }
        if(L.type==='aff'){ out.push(`<p><b>${L.name}</b> : \\( f_{${i}}(x) = ${latexMonomeX(L.m)}${L.b===0?'':latexSignNum(L.b)} \\)</p>`); }
        else{ out.push(`<p><b>${L.name}</b> : \\( f_{${i}}(x) = ${latexFrac(L.p,L.q)}x${L.b===0?'':latexSignNum(L.b)} \\)</p>`); }
      });
      setResP(out);
    }
  }
};

/* === Adapter pour le kit PDF (identique √† avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;








/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
window.buildOneForPDFSync = function(defId){
  window.__PDF_BUILDING = true;           // ‚¨ÖÔ∏è d√©marre la zone neutre

  try {
    const cfg = REGISTRY_MAP[defId];
    if (!cfg) return { statement:'', solution:'' };

    const host   = document.querySelector('#host');
    const backup = host ? host.innerHTML : '';

    if (host) mountHost();
    document.querySelector('#lead').innerHTML = cfg.lead || '';

    // ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
// ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
const st = cfg.gen.call(cfg);
if (typeof cfg.render === 'function') {
  // on rend l‚Äô√©cran pour que this._state soit pos√© (e1 en a besoin)
  cfg.render.call(cfg, document.querySelector('#host') || document.body, st);
}


  // --- Restaure pour l‚Äô√©cran ---


  // ---- 1) R√©cup√©rer le rep√®re s‚Äôil existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // s√©curit√© namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) √ânonc√© texte (√©cran)
  const equHTML = (document.querySelector('#equ')||{}).innerHTML || '';

  // √ânonc√© final : grille 2 colonnes si on a un rep√®re, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction (√©cran)
const _oldRetypeset2 = window.retypeset;
  const _oldMJ2        = window.MJ;
  window.retypeset = function(){};
  window.MJ        = function(){};
  cfg.solution.call(cfg);
  
  // ---- Apr√®s cfg.solution.call(cfg); (et avant le restore) ----

// 2.1) R√©cup√©rer le SVG *corrig√©*
let corrigeRepereHTML = '';
{
  const svgSol = document.querySelector('.row svg.svgbox') || document.querySelector('svg.svgbox');
  if (svgSol){
    const clone = svgSol.cloneNode(true);
    clone.removeAttribute('style');
    clone.setAttribute('width','300');      // taille PDF
    clone.setAttribute('height','300');
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    corrigeRepereHTML = clone.outerHTML;
  }
}

// 2.2) R√©cup√©rer le HTML texte de la correction
const corrigeTexteHTML = (document.querySelector('#res')||{}).innerHTML || '';

// 2.3) Composer la *correction* pour le PDF : rep√®re + texte
const solution =
  corrigeRepereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${corrigeRepereHTML}</div>
         <div>${corrigeTexteHTML}</div>
       </div>`
    : corrigeTexteHTML;

  
  
  window.retypeset = _oldRetypeset2;
  window.MJ        = _oldMJ2;

  if (host) host.innerHTML = backup;

  

  const statementTight = statement;
  const solutionTight  = solution;
  
 function stripCHTML(html){
  if(!html) return html;
  return html
     .replace(/<mjx-container[\s\S]*?<\/mjx-container>/g, (m)=>{
       // On essaie de r√©cup√©rer le TeX source si MathJax l‚Äôa laiss√© en data-tex,
       // sinon on supprime (on n‚Äôen veut pas dans le PDF SVG).
       const tex = m.match(/data-tex="([^"]+)"/);
       return tex ? `\\(${tex[1]}\\)` : '';
     });
 }
 const statementClean = stripCHTML(statementTight);
 const solutionClean  = stripCHTML(solutionTight);

  // ‚ö†Ô∏è On wrappe ici avec .vec-tight pour activer le CSS ‚Äúresserr√©‚Äù c√¥t√© iframe PDF (SVG)
    return {
      statement: `<div class="vec-tight">${statementTight||''}</div>`,
      solution:  `<div class="vec-tight">${solutionTight||''}</div>`
    };
  } finally {
    window.__PDF_BUILDING = false;        // ‚¨ÖÔ∏è on r√©active l‚Äô√©cran quoi qu‚Äôil arrive
  }
};


function toggleAmpbar(activeId){
  const bar = document.getElementById('ampbar');
  if (!bar) return;
  const hide = (activeId === '' );
  bar.style.display = hide ? 'none' : '';
}

/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	toggleAmpbar(ACTIVE);

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){
     applyAMPInputs();          

  mountHost(); // injecte le layout par d√©faut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // √©l√©ments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', host);
  const fbEl  = $('#fb', host);
  const resEl = $('#res', host);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

// g√©n√®re l'exo (peut remplacer enti√®rement le host, ex. e3/ex4)
const state = cfg.gen.call(cfg);
if (typeof cfg.render === 'function') {
  cfg.render.call(cfg, host, state);
}





  // (re)typeset
  retypeset();
  toggleAmpbar(ACTIVE);

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
document.querySelector('#btn-reset').addEventListener('click', ()=>{
  const a=$('#ans',host); if(a) a.value='';
  document.querySelectorAll('.colvec input').forEach(i=> i.value=''); // ‚¨ÖÔ∏è AJOUT
  const f=$('#fb',host); if(f) f.textContent='';
  const r=$('#res',host); if(r) r.innerHTML='';
});
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
    document.querySelector('#btn-solution').addEventListener('click', ()=>{ REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]); });


function adjustLive(kind){
  // Route vers l‚Äôexo actif si un adjustLive est d√©fini,
  // sinon on se contente d‚Äôactualiser les bornes AMP.
  const cfg = REGISTRY_MAP[ACTIVE];
  if (cfg && typeof cfg.adjustLive === 'function') {
    cfg.adjustLive(kind);
  } else {
    applyAMPInputs();
  }
}



['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;   toggleAmpbar(ACTIVE);  buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) ‚Äî inchang√©, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);


const statementTight = statement;
const solutionTight  = solution;

          const htmlIn =
  `<div class="exo-block">
     <span class="exo-title">Exercice</span>
     <div class="exo-statement">${statementTight||''}</div>
   </div>` +
  (withSolutions
    ? `<div style="margin-top:1rem;">
         <div class="exo-block"><div class="steps" id="pdf-steps">
           <span class="exo-title">Correction</span>
           <!-- ‚¨áÔ∏è Ajout d‚Äôun conteneur .steps pour retrouver la zone grise -->
           <div class="exo-solution">${solutionTight||''}</div></div>
         </div>
       </div>`
    : '');


          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;
const css = idoc.createElement('style');
css.textContent = `
  :root{
    --ink:#111; --bg:#fafafa; --card:#fff; --line:#e5e7eb; --muted:#666;
    --steps-bg:#f3f4f6; --steps-border:#e5e7eb; --steps-left:#9aa0a6;
  }
  body{font:16px/1.55 system-ui,Segoe UI,Roboto,Arial;color:var(--ink);}
  .exo-title{display:block;font-weight:700;margin:0 0 6px}
  /* ‚öôÔ∏è Zone grise identique √† l‚Äô√©cran (#res.steps) */
  .steps{
    background:var(--steps-bg);
    border:1px solid var(--steps-border);
    border-left:4px solid var(--steps-left);
    border-radius:8px;
    padding:10px;
    margin:.45rem 0 0 .15rem;
  }
  .steps p{margin:.25rem 0}
  /* Table ‚Äúe5‚Äù compacte */
  .tbl3{border-collapse:collapse}
  .tbl3 td{padding:2px 6px;vertical-align:top}
  
  /* === Tighten parentheses around column vectors (SVG output) === */
/* CHTML (au cas o√π), agit sur les delimiters extensibles */
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:first-child { margin-right: -0.18em; }
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:last-child  { margin-left:  -0.18em; }
.vec-tight mjx-mtable mjx-mtd { padding-left: .15em; padding-right: .15em; }
.vec-tight mjx-mtable > mjx-table { margin-left: 0; margin-right: 0; }

/* SVG : d√©caler l√©g√®rement OPEN/CLOSE pour coller les parenth√®ses au tableau */
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="OPEN"]  { transform: translateX(-0.18em); }
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="CLOSE"] { transform: translateX( 0.18em); }

/* Ajustement global tr√®s l√©ger si besoin (peut √™tre mis √† 0 si tu pr√©f√®res) */
.vec-tight svg[aria-hidden="true"] { margin-left:-0.10em; margin-right:-0.10em; }
/* --- Anti "barres noires" MathJax (PDF) --- */
.exo-statement,
.exo-solution { color:#111 !important; background:transparent !important; }

/* Cas CHTML (au cas o√π) */
mjx-container { color:#111 !important; background:transparent !important; }
mjx-container svg { overflow:visible !important; }
mjx-container svg rect,
mjx-container svg path[data-mml-node="mspace"] { fill:none !important; }

/* Cas SVG standalone (ce que tu utilises dans l‚Äôiframe) */
.exo-statement svg rect,
.exo-statement svg path[data-mml-node="mspace"],
.exo-solution  svg rect,
.exo-solution  svg path[data-mml-node="mspace"] { fill:none !important; }

`;
idoc.head.appendChild(css);

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
