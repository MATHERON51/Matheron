<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2nd - Fonctions affines - D√©finitions et exemples</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
*{box-sizing:border-box}
:root{ --ink:#111; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --muted:#666; --ok:#0e7c3a; --ko:#b00020; }
html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.controls label{font-weight:600}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
.btn:hover{border-color:#bbb}
.small{color:var(--muted);font-size:.95rem}
.eq{font-size:17px}
.ok{color:var(--ok);font-weight:700}
.ko{color:var(--ko);font-weight:700}
hr.sep{border:none;border-top:1px dashed #ddd;margin:10px 0}
.steps p{margin:.25rem 0}

/* Mises en forme des solutions */
.grid{display:grid;gap:10px;align-items:start}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:auto auto 1fr}
.box{border:1px dashed #bbb;border-radius:8px;padding:8px 10px}
.box p{margin:.25rem 0}
.eqcol{display:flex;flex-direction:column;gap:.25rem}
.eqcol p{margin:0}
.eqonly{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.center{text-align:center}

/* Bloc solution (UI) */
#res.steps{
  background:#f3f4f6;border:1px solid #e5e7eb;border-left:4px solid #9aa0a6;border-radius:8px;padding:10px;
}
#res.steps p{margin:.25rem 0}

.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff; touch-action: manipulation; user-select: none;}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none;background:#fff}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
.chipwrap{display:flex;flex-direction:column;align-items:center;gap:4px}
.chipwrap .tick{height:1rem;line-height:1rem}
:root{ --tick-ok: #11823b; --tick-ko: #b00020; }
.indline{margin:4px 0; font-size:.95rem; display:flex; align-items:center; gap:6px}
.indline .lbl{min-width:2.2rem; font-weight:700}
.indline .tick{min-width:1.4rem; font-weight:900}
.indline .tick.ok{color:var(--tick-ok)}
.indline .tick.ko{color:var(--tick-ko)}
.indline .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }




/* Grille 3 colonnes pour les vecteurs √† placer (partie 3) */
.grid3 {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px 12px;           /* espace lignes/colonnes */
  align-items: start;
}
.grid3 .chipwrap { width: 100%; }

/* ---- Blocs sous le rep√®re : 2 lignes √ó 5 colonnes ---- */
.flat12-wrap{ margin-top:10px; }

.sec{ margin:10px 0; }
.sec .title{ font-weight:700; font-size:1.05rem; margin-bottom:6px; }

/* une grille de 5 colonnes */
.grid5{
  display:grid;
  grid-template-columns: repeat(5, max-content);
  gap:8px 14px;
  align-items:center;
}

/* cellules : libell√© + vecteur-colonne + tick */
.grid5 .inlinecell{ display:flex; align-items:center; gap:6px; }

/* vecteurs en colonne compacts pour tenir √† 5√ó2 */
.grid5 .colvec{
  --parenW:8px; --padX:5px; --gap:3px;
  --inW:44px; --inPy:2px; --inFs:12.5px;
}

.hidden{ display:none; }


/* ‚Äî Anti ‚Äúbarres noires‚Äù MathJax ‚Äî */
.steps mjx-container { color: #111 !important; background: transparent !important; }
.steps mjx-container svg { overflow: visible !important; }
.steps mjx-container svg rect,
.steps mjx-container svg path[data-mml-node="mspace"] { fill: none !important; }
.steps mjx-mrow, .steps mjx-mi, .steps mjx-mo, .steps mjx-mn { background: transparent !important; }

/* ==== Nom de vecteur avec fl√®che au-dessus ============================== */
.vecname{ position:relative; display:inline-block; }
.vecname input{
  width:72px; text-align:center; font-weight:700; font-size:15px;
  letter-spacing:.12em; text-transform:uppercase;
  padding:14px 10px 6px 10px; /* place pour la fl√®che au-dessus */
  border:1px solid #ddd; border-radius:8px; background:#fff;
}
.vecname::before{
  content:""; position:absolute; left:12px; right:20px; top:6px; height:2px; background:#111;
}
.vecname::after{
  content:""; position:absolute; top:2px; right:12px;
  border-left:8px solid #111; border-top:5px solid transparent; border-bottom:5px solid transparent;
}

/* Lignes compactes sous le rep√®re pour e2 */
.vecrow{ display:flex; align-items:center; gap:12px; margin:6px 0; flex-wrap:wrap; }
.vecrow .lbl{ font-weight:700; min-width:max-content; }
.vecrow .tick{ min-width:1.4rem; font-weight:900; }
.tbl-invis{border-collapse:collapse;width:100%}
.tbl-invis td{border:none;padding:6px 10px;vertical-align:top;width:50%}
.pair{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.pair .lbl{font-weight:700;min-width:1.6rem}

/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }

.table-compare {
  border-collapse: collapse;
  width: 100%;
  margin: .5rem 0 .6rem 0;
}
.table-compare td {
  vertical-align: top;
  padding: 0 .8rem;
  border: none;
}
.table-compare td:first-child {
  border-right: 2px solid #000; /* fine barre verticale */
}


 /* tableaux imprimables style PDF */
  table.pdf-tbl{ border-collapse:separate; border-spacing:0; border:none; margin:.4rem 0; }
  table.pdf-tbl th, table.pdf-tbl td{ border:none; padding:4px 6px; text-align:center; vertical-align:middle; }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* tableaux interactifs (cadre uniquement) */
  table.var{ border-collapse:separate; border-spacing:0; margin:.35rem auto }
  table.var th, table.var td{ padding:4px 6px; border:none }
  table.var tr:first-child > * { border-top:    1.5px solid #000; }
  table.var tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.var tr > *:first-child { border-left:   1.5px solid #000; }
  table.var tr > *:last-child  { border-right:  1.5px solid #000; }
  table.var tbody tr:first-child > * { border-bottom: 1.5px solid #000; }
  table.var td.bigsel{ padding:0 }
  table.var td.bigsel select{ display:block; width:100%; height:100%; background:transparent; padding:0; margin:0; text-align:center; text-align-last:center; appearance:none }
  table.var input[type="text"]{ width:110px; text-align:center }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.repere{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  
  /* S√©parateur vertical apr√®s la 1re colonne, pour tous les tableaux interactifs */
table.var tr > *:first-child{
  border-left: 1.5px solid #000;   /* bord ext√©rieur gauche (d√©j√† pr√©sent) */
  border-right: 1.5px solid #000;  /* ‚áê ajout : barre verticale apr√®s la 1re colonne */
}
/* 5) f' + variations ‚Äî trait entre f'(x) et f (√©nonc√© + PDF) */
#dv-wrap table.var tbody tr:nth-child(2) > *,
#dv-out  table.pdf-tbl tbody tr:nth-child(2) > * {
  border-bottom: 1.5px solid #000;
}
/* 5) ENONC√â : trait entre f'(x) et f */
#dv-wrap table.var tbody tr:nth-child(2) > * {
  border-bottom: 1.5px solid #000;
}

/* 5) SOLUTION (PDF) : trait entre f'(x) et f */
#dv-out table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}
/* Enlever fond/bordure sur les blocs de solution */
#v-out.steps,
#s1-out.steps,
#sf-out.steps,
#dv-out.steps,
#curve-out-var.steps,
#curve-out-sign.steps {
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}
#v-out .step, #s1-out .step, #sf-out .step,
#dv-out .step, #curve-out-var .step, #curve-out-sign .step {
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}
/* Trait entre f'(x) et f dans la solution auto */
#curve-out-deriv table.pdf-tbl tbody tr:first-child > *{
  border-bottom: 1.5px solid #000;
}

/* Pas de fond gris pour cette sortie */
#curve-out-deriv.steps { background: transparent !important; border:none !important; padding:0 !important; }
#curve-out-deriv .step  { background: transparent !important; border:none !important; padding:0 !important; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}

/* 2 barres (||) ‚Äî √©cart RESSERR√â */
table.pdf-tbl td.dbar::before,
table.pdf-tbl td.dbar::after{
  content:'';
  position:absolute;
  top:-1.5px;
  bottom:-1.5px;
  border-left:2px solid #000;
}
table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

/* === 4) TABLEAU SIGNE FACTORIS√â ‚Äî ENONC√â (grille interactive) === */
/* trait sous x (tu l'as d√©j√† via tbody tr:first-child > * { border-bottom: ... }) */
/* traits entre 'a' / facteurs / 'f(x)' */
#sf-wrap table.var tbody tr.sf-row-a > *,
#sf-wrap table.var tbody tr.sf-row-factor + tr.sf-row-factor > *,
#sf-wrap table.var tbody tr.sf-row-fx > * {
  border-top: 1.5px solid #000;
}
/* Ligne apr√®s 'a' (si la ligne 'a' est affich√©e) */
#sf-wrap table.var tbody tr.sf-row-a + tr.sf-row-factor > * {
  border-top: 1.5px solid #000;
}

/* === 4) TABLEAU SIGNE FACTORIS√â ‚Äî SOLUTION (PDF) === */
/* traits entre 'a' / facteurs / 'f(x)' */
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-a > *,
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-factor + tr.sf-pdf-row-factor > *,
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-fx > * {
  border-top: 1.5px solid #000;
}

/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* Courbes multiples : trait horizontal entre f'(x) et f dans la SOLUTION (PDF) */
#mc-out-deriv table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}

/* Gabarit SOLUTION (pdf-tbl) ‚Äî a√©ration mod√©r√©e */
.steps .pdf-tbl{
  width: auto;             /* ne force pas 100% */
  max-width: 100%;
  table-layout: auto;
}
.steps .pdf-tbl th,
.steps .pdf-tbl td{
  padding: 5px 8px;        /* l√©ger + que l'origine, moins qu'avant */
}
.steps .pdf-tbl tbody th{
  min-width: 64px;         /* libell√©s (f, f', a, ‚Ä¶) */
}
.steps .pdf-tbl td{
  min-width: 30px;         /* colonnes x / intervalles */
}
/* Fl√®ches plus grandes dans les tableaux de variations de la **solution** */
.steps .pdf-tbl td.arr{
  font-size: 1.45em;   /* taille des fl√®ches */
  line-height: 1;
  font-weight: 700;
  padding-left: 6px;
  padding-right: 6px;
}
@media print{
  .steps .pdf-tbl td.arr{ font-size: 1.6em; }
}
/* Centrage vertical (valeur unique) */
table.pdf-tbl td.mid, table.var td.mid { position: relative; }
table.pdf-tbl td.mid .midv, table.var td.mid .midv{
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  white-space:nowrap; text-align:center;
}

/* tableau de signes : colonnes sym√©triques */
.pdf-tbl.sign4 td { padding-left: 6px; padding-right: 6px; } /* optionnel, m√™me padding */
.pdf-tbl.sign4 td.L { text-align: left; }
.pdf-tbl.sign4 td.C { text-align: center; position: relative; }
.pdf-tbl.sign4 td.R { text-align: right; }

</style>

<!-- MathJax CHTML √©cran -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)'], ['$', '$']],
      displayMath: [['\\[','\\]'], ['$$','$$']],
      processEscapes: true,
      packages: { '[+]': ['bbox','ams'] },
      macros: { vec: ['\\overrightarrow{#1}',1] }
    },
    options: { skipHtmlTags: ['script','noscript','style','textarea'] },
    chtml: { matchFontHeight:false },
    startup: { typeset: true }
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<style>.MJX_Assistive_MathML, mjx-assistive-mml{display:none!important}</style>

<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/exo-pdf-kit-multiplicatif-latex-SVGCHTML.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
  <script src="../../../../js/repere_patch_0813.js" defer></script>

</head>
<body>
  <div class="header"><h1 style="margin:0;font-size:1.1rem"><strong>2nd - Fonctions affines - D√©finitions et exemples</strong></h1></div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score" style="margin-left:auto;font-weight:700">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small" id="info-saisie">
      <strong>Saisie &amp; r√©ponses accept√©es :</strong>
      <ul style="margin:.5rem 0 0 18px">
<li>Pour la question <strong>1)</strong> : saisir la solution sous la forme <code>{r√©ponse}</code> (ex. <code>{3/2}</code>). Ne pas taper <code>S=</code> dans le champ.</li>
<li>Pour plus de d√©tails dans les r√©solutions d'√©quations ou d'in√©quations : voir chapitre 1.</li>
<li>Rappel : Multiplier par un nombre n√©gatif change l'ordre de l'in√©galit√©.</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
/* ====== Mini helpers g√©n√©riques ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
const HOST = $('#host');
function retypeset(host){
  if (window.__PDF_BUILDING) return;              // ‚¨ÖÔ∏è ignore en phase PDF
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([host||document]);
}function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){const t=a%b;a=b;b=t;} return a||1; }

/* ====== Rationnels ‚Äúpropres‚Äù (pour jolies fractions dans les corrections) ====== */
function R(p,q=1){ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; }
function addR(x,y){ return R(x.p*y.q + y.p*x.q, x.q*y.q); }
function subR(x,y){ return R(x.p*y.q - y.p*x.q, x.q*y.q); }
function mulR(x,y){ return R(x.p*y.p, x.q*y.q); }
function negR(x){ return R(-x.p, x.q); }
function numR(x){ return x.p/x.q; }
function latexR(r){ if(r.q===1) return String(r.p); const s=r.p<0?'‚àí':''; const P=Math.abs(r.p); return s+'\\dfrac{'+P+'}{'+r.q+'}'; }
function textR(r){ return r.q===1 ? String(r.p) : `${r.p}/${r.q}`; }
// Retourne -\dfrac{|p|}{q} si p<0, sinon \dfrac{p}{q}; et un entier si q=1
function latexR_leadingMinus(r){
  // r = {p,q} d√©j√† r√©duit
  const p = r.p, q = r.q;
  if (q === 1) return String(p);                    // pas de /1
  const P = Math.abs(p), Q = Math.abs(q);
  const sign = (p*q < 0) ? '‚àí' : '';                // signe global
  return `${sign}\\dfrac{${P}}{${Q}}`;              // ‚àí devant \dfrac
}



/* ===== MathJax helper ===== */
function MJ(el){
  try{
    if (window.MathJax){
      if (MathJax.typesetPromise) MathJax.typesetPromise([el||document.body]).catch(()=>{});
      else if (typeof MathJax.typeset === 'function') MathJax.typeset([el||document.body]);
    }
  }catch(_){}
}


/* ====== Affichages ‚Äúcoordonn√©es‚Äù ====== */
// --- affichages points & vecteurs ---
const par = n => (n<0?`(${n})`:String(n));
/* ====== Affichages ‚Äúcoordonn√©es‚Äù ‚Äî r√®gles de parenth√®ses ====== */
// nombres "bruts" (pour les points) : JAMAIS de parenth√®ses autour d'un n√©gatif
const nPlain = n => String(n);

// nombre entre parenth√®ses UNIQUEMENT s'il suit un "‚àí" dans une diff√©rence
const nAfterMinus = n => (n < 0 ? `(${n})` : String(n));
const plusExpr = (a,b) => `${nPlain(a)} + ${b<0?`(${b})`:nPlain(b)}`;
const plusExprSimplified = (a,b) => `${nPlain(a)} ${b<0?'-':'+'} ${nPlain(Math.abs(b))}`;

// expressions "a - b" avec parenth√®ses seulement si b<0
const minusExpr = (a,b) => `${nPlain(a)} - ${nAfterMinus(b)}`;

// version simplifi√©e (pour l'√©tape -- ‚Üí +)
const minusExprSimplified = (a,b) => (b < 0 ? `${nPlain(a)} + ${Math.abs(b)}` : `${nPlain(a)} - ${nPlain(b)}`);

// Points en LIGNE, sans par autour des n√©gatifs
function fmtPtLaNum(P){ return `(${nPlain(P.a)}\\;;\\;${nPlain(P.b)})`; }
function fmtPtLaR(P){  return `(${latexR(P.a)}\\;;\\;${latexR(P.b)})`; }



// Retourne les √©tapes LaTeX pour p/q : d'abord p/q, puis (optionnel) la forme r√©duite.
function fracStepsLatex(p,q){
  // signe global devant la fraction d√®s la 1re √©tape
  const sgn = (p*q<0) ? '‚àí' : '';
  const P = Math.abs(p), Q = Math.abs(q);
  const g0 = gcd(P, Q);
  const first = `${sgn}\\dfrac{${P}}{${Q}}`;
  if (g0 > 1){
    const pr = P/g0, qr = Q/g0;
    return [first, `${sgn}\\dfrac{${pr}}{${qr}}`];
  }
  return [first];
}


/* === Helpers de comparaison (signes & doublons) ========================== */
// Normalise les signes dans les fractions pour comparer :
//  \dfrac{-a}{b}  ‚Üí  -\dfrac{a}{b}
// enl√®ve espaces superflus et normalise le "‚àí" unicode en "-"
function normalizeFracSign(s){
  return String(s)
    .replace(/\u2212/g, '-') // unicode minus ‚Üí "-"
    .replace(/\\dfrac\{\s*-\s*([^}]+)\}\{\s*([^}]+)\}/g, '-\\dfrac{$1}{$2}')
    .replace(/\(\s*-\s*\\dfrac/g, '(-\\dfrac')
    .replace(/\s+/g, ' ')
    .trim();
}


/* ====== UI host ====== */
function mountHost(){
  HOST.innerHTML = `
    <div id="lead" class="small"></div>
    <div id="equ" class="eq"></div>
    <hr class="sep">
    <div class="controls">
      <label class="input">R√©ponse <input id="ans" class="answer" type="text" inputmode="text" autocomplete="off" placeholder=""></label>
      <div id="fb"></div>
    </div>
    <hr class="sep">
    <div id="res" class="steps"></div>
  `;
}

function setEqu(html){ const box=$('#equ',HOST); if(box) box.innerHTML = html; retypeset(HOST); }
function setStepsHTML(html){ $('#res',HOST).innerHTML=html; retypeset(HOST); }
function setSteps(lines){ setStepsHTML(lines.map(L=>`<p>${L}</p>`).join('')); }
function setFB(ok, msg=''){
  const fb = $('#fb', HOST);
  if (!fb) return;
  if (ok === null){        // ‚¨ÖÔ∏è mode neutre
    fb.className = '';     // ni .ok ni .ko
    fb.innerHTML = msg;    // message libre (peut contenir du HTML)
    return;
  }
  fb.className = ok ? 'ok' : 'ko';
  fb.textContent = (ok?'‚úîÔ∏é Correct. ':'‚úó Incorrect. ') + msg;
}

/* ====== Parsing des r√©ponses u;v ====== */
function normalizeMinus(s){ return String(s||'').replace(/\u2212/g,'-').trim(); }
function parseNumber(token){
  token = token.replace(',','.');
  if (/^[-+]?\d+\/\d+$/.test(token)){ const [p,q]=token.split('/').map(Number); return p/q; }
  return token===''?NaN:Number(token);
}
function parsePairUV(s){
  s = normalizeMinus(s).replace(/\s+/g,'');
  const m = s.match(/^([^;]+);([^;]+)$/);
  if(!m) return {ok:false};
  const u=parseNumber(m[1]), v=parseNumber(m[2]);
  return (isFinite(u)&&isFinite(v)) ? {ok:true,u,v} : {ok:false};
}








function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// cellules 3√ó3 √† l'int√©rieur des limites "lim"
function makeCells(lim, rows=3, cols=3){
  const w = (lim.xmax - lim.xmin + 1), h = (lim.ymax - lim.ymin + 1);
  const cw = Math.floor(w / cols), ch = Math.floor(h / rows);
  const cells = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0 = lim.xmin + c*cw, x1 = (c===cols-1) ? lim.xmax : (x0+cw-1);
      const y0 = lim.ymin + r*ch, y1 = (r===rows-1) ? lim.ymax : (y0+ch-1);
      cells.push({xmin:x0, xmax:x1, ymin:y0, ymax:y1});
    }
  }
  return cells;
}
function randIntInCell(cell){ return { x: randInt(cell.xmin, cell.xmax), y: randInt(cell.ymin, cell.ymax) }; }
function fits(lim, x, y){ return x>=lim.xmin && x<=lim.xmax && y>=lim.ymin && y<=lim.ymax; }


// --- Unicit√© de pente : cl√© de colin√©arit√© (ignore l'√©chelle et le signe global)
function slopeKey(dx, dy){
  if (dx === 0) return 'V';     // vertical
  if (dy === 0) return 'H';     // horizontal
  // normalise le signe pour que (dx,dy) et (-dx,-dy) donnent la m√™me cl√©
  if (dx < 0){ dx = -dx; dy = -dy; }
  const g0 = gcd(Math.abs(dx), Math.abs(dy)) || 1;
  const a = dx / g0, b = dy / g0; // a = dx', b = dy' primitifs
  return b + '/' + a;             // on encode la pente (dy/dx) comme "b/a"
}


// --- Unicit√© stricte des coordonn√©es (a;b) pour la partie 3
const abKey = (a,b) => a + ';' + b;


/* ===== Utilitaire PDF : forcer la taille du SVG (300√ó300) ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }



// helpers you may already have:
const isEmptyTxt = id => !($('#'+id)?.value||'').trim();
const isEmptyCol = id => !($('#'+id+'_u')?.value||'').trim() && !($('#'+id+'_v')?.value||'').trim();

function namesArePaired(n1, n2){
  const s = v => String(v||'').toUpperCase().replace(/\s+/g,'');
  const map = { AB:'DC', BA:'CD', BC:'AD', CB:'DA' };
  const a = s(n1), b = s(n2);
  return !!(map[a] && map[a] === b);
}

function setTick(id, kind){ const el = document.getElementById(id); if(el){ el.className='tick '+(kind||''); el.textContent = kind==='ok' ? '‚úì' : kind==='ko' ? '‚úó' : ''; } }

function removeDefaultAnswerRow(){
  const ctrl = HOST.querySelector('.controls'); // le bloc "R√©ponse ‚Ä¶  #fb"
  if (ctrl) ctrl.remove();
}


// supprime un signe d‚Äôen-t√™te (prend aussi le vrai "‚àí" unicode)
function stripLeadSign(s){
  return String(s).replace(/^[\u2212\-+]\s*/,'');
}

// normalise les suites de signes: "+ ‚àí"‚Üí" ‚àí", "‚àí ‚àí"‚Üí" +", "+ +"‚Üí"+", et supprime un "+" initial
function tidySigns(s){
  return String(s)
    .replace(/\+\s*[\u2212\-]\s*/g,' ‚àí ')
    .replace(/[\u2212\-]\s*[\u2212\-]\s*/g,' + ')
    .replace(/\+\s*\+\s*/g,' + ')
    .replace(/^\s*\+\s*/,'');
}



/* ==== Tableau de signe pour u(x)=mx+p ==== */
/* mSign = +1 si m>0, -1 si m<0 ; x0Latex = racine en LaTeX (ex. -\\dfrac{4}{7}) */
function affineSignTableHTML(mSign, x0Latex){
  const sL = (mSign > 0) ? '‚àí' : '+';
  const sR = (mSign > 0) ? '+' : '‚àí';
  return `
  <table class="pdf-tbl sign4" style="width:100%;table-layout:fixed">
    <colgroup>
      <col style="width:72px">            <!-- colonne des libell√©s -->
      <col style="width:33.333%">
      <col style="width:33.333%">
      <col style="width:33.333%">
    </colgroup>
    <thead>
      <tr>
        <th>\\(x\\)</th>
        <td class="L">\\(-\\infty\\)</td>
        <td class="C">\\(${x0Latex}\\)</td>
        <td class="R">\\(+\\infty\\)</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>\\(f(x)\\)</th>
        <td class="R">${sL}</td>
        <td class="C zbar">0</td>
        <td class="L">${sR}</td>
      </tr>
    </tbody>
  </table>`;
}



/* ==== Tableau de signes INTERACTIF pour u(x)=mx+p ==== */
/* ==== Tableau de signes INTERACTIF pour u(x)=mx+p (avec saisie de x0) ==== */
function affineSignTableInteractiveHTML(){
  return `
  <table class="pdf-tbl" style="width:auto">
    <thead>
      <tr>
        <th>\\(x\\)</th>
        <td>\\(-\\infty\\)</td><td></td>
        <td style="white-space:nowrap">
          <input id="tab_x0" style="width:110px;text-align:center" placeholder="">
        </td>
        <td></td>
        <td>\\(+\\infty\\)</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="padding:4px 8px">\\(f(x)\\)</td>
        <td></td>
        <td style="text-align:center">
          <select id="tab_left">
            <option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option>
          </select>
        </td>
        <td class="zbar" style="text-align:center">0</td>
        <td style="text-align:center">
          <select id="tab_right">
            <option value=""></option><option value="+">+</option><option value="‚àí">‚àí</option>
          </select>
        </td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <div class="indline"><span class="lbl"></span><span class="tick" id="tk_tab"></span></div>`;
}

// fabrique l‚Äôintervalle en LaTeX selon le comparateur final et x0
function intervalFromCmp(finalCmp, x0Latex){
  if (finalCmp === '<')   return `\\left] -\\infty\\,;\\, ${x0Latex} \\right[`;
  if (finalCmp === '<=')  return `\\left] -\\infty\\,;\\, ${x0Latex} \\right]`;
  if (finalCmp === '>')   return `\\left] ${x0Latex} \\;;\\; +\\infty \\right[`;
  /* finalCmp === '>=' */ return `\\left[ ${x0Latex} \\;;\\; +\\infty \\right[`;
}


function dedupLines(lines){
  const out = [];
  let prev = '';
  for (const L of lines){
    if (!L) continue;                       // null/undefined/'' ‚Üí saute
    const key = String(L).replace(/\s+/g,' ').trim();
    if (key !== prev){ out.push(L); prev = key; }
  }
  return out;
}

// normalisation tr√®s agressive pour comparer 2 lignes de TeX
function _normLine(s){
  return String(s)
    .replace(/\u2212/g,'-')             // ‚àí ‚Üí -
    .replace(/\s+/g,' ')                // espaces multiples
    .replace(/\s*([=<>])\s*/g,' $1 ')   // espaces autour de = < >
    .replace(/\\ge/g,'>=')              // \ge ‚Üí >= (cl√© unique)
    .replace(/\\le/g,'<=')              // \le ‚Üí <=
    .replace(/^\s+|\s+$/g,'')           // trim
}

// pousse la ligne uniquement si elle est diff√©rente de la pr√©c√©dente
function _pushStep(arr, line){
  if (!line) return;
  const cur = _normLine(line);
  const prev = _normLine(arr.length ? arr[arr.length-1] : '');
  if (cur !== prev) arr.push(line);
}


// rend des <p>‚Ä¶</p> sans .join()
function _renderParas(lines){
  let html = '';
  for (const L of lines){ if (L) html += `<p>${L}</p>`; }
  return html;
}

function parseSingletonSet(s, parseNum){
  s = normalizeMinus(String(s||'')).trim();
  const m = s.match(/^\{\s*([^}]+)\s*\}$/);  // exige { ‚Ä¶ }
  if(!m) return {ok:false};
  const n = parseNum(m[1]);
  return (isFinite(n)) ? {ok:true, value:n} : {ok:false};
}







// ====== Fabrique commune : √âquation & In√©quation u(x)=mx+p ======
function __mkEqIneqAffineExo(opts){
  const RX_FRAC=/^[+-]?\d+\/\d+$/;
  const normMinus = s => String(s||'').replace(/\u2212/g,'-');
  const parseNum = s=>{
    s = normMinus(String(s||'')).replace(',','.');
    if(RX_FRAC.test(s)){ const [a,b]=s.split('/').map(Number); return a/b; }
    return Number(s);
  };
  const gcd=(a,b)=>{a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t;}return a||1;};
  const R=(p,q=1)=>{ if(q<0){p=-p;q=-q;} const g=gcd(p,q); return {p:p/g,q:q/g}; };
  const latexR = r => (r.q===1? String(r.p):`\\dfrac{${r.p}}{${r.q}}`);
  const latexR_leadMinus = r => (r.q===1 ? String(r.p) : (r.p<0 ? `-\\dfrac{${Math.abs(r.p)}}{${r.q}}` : `\\dfrac{${r.p}}{${r.q}}`));

  // tirages
  function ri(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function pickZ(a,b, nz=false){ let x=0; do{x=ri(a,b);}while(nz && x===0); return x; }
  function pickFrac(){
    // p ‚àà [-9,9]\{0}, q ‚àà [2,7], fraction r√©duite
    let p=0,q=1; do{ p=pickZ(-9,9); q=ri(2,7);}while(p===0);
    return R(p,q);
  }

  function drawParams(){
    let m,p; // rationnels (objet R)
    if (opts.kind==='int'){
      m = R(pickZ(-9,9,true),1);
      p = R(pickZ(-9,9,false),1);
    }else{
      // chacun soit entier soit fraction (50/50), avec m‚â†0
      const mz = Math.random()<0.5 ? R(pickZ(-9,9,true),1) : pickFrac();
      const pz = Math.random()<0.5 ? R(pickZ(-9,9,false),1) : pickFrac();
      m=mz; p=pz;
    }
    return {m,p};
  }

  function coefX(r){
    // √©crit mx sans 1x/-1x et avec fraction si besoin
    const s = r.p/r.q;
    if (Math.abs(s-1)<1e-12)  return 'x';
    if (Math.abs(s+1)<1e-12)  return '‚àíx';
    return `${latexR_leadingMinus(r)}\\,x`;

  }
  function plusC(r){
    // signe + constante (en TeX), et √©vite "+ -..."
    if (r.p===0) return '';
    const neg = r.p<0;
    const body = latexR(R(Math.abs(r.p), r.q));
    return (neg? ' ‚àí ' : ' + ') + body;
  }

  return {
    name: (opts.kind==='int'
      ? "√âquation & in√©quation ‚Äî f(x)=mx+p (m,p entiers)"
      : "√âquation & in√©quation ‚Äî f(x)=mx+p (m,p entiers ou fractions)"),
    lead: "R√©soudre l‚Äô√©quation \\(f(x)=0\\) puis l‚Äôin√©quation demand√©e pour \\(f(x)=mx+p\\).",
    gen(){
      mountHost(); removeDefaultAnswerRow(); setFB(null,'');
      // tirage
      const prm = drawParams();
      const m = prm.m, p = prm.p;

      // racine x0 = -p/m (r√©duite et ‚Äúbeau signe‚Äù devant la fraction)
      const x0 = R(-p.p*m.q, p.q*m.p); // (-p/m) = (-p/q)/(m/1) ‚Üí (-p*m.q)/(p.q*m)
      const x0simp = R(x0.p, x0.q);

      // comparateur demand√© (tir√© au hasard)
      const CMPS = ['>','<','>=','<='];
      const want = CMPS[ri(0,3)];
      const latexCmp = {'>':'\\;>\\;','<':'\\;<\\;','>=':'\\;\\ge\\;','<=':'\\;\\le\\;'}[want];

      // affichage u(x)
      const fx = `f(x)= ${coefX(m)}${plusC(p)}`;

      // UI
      let html = '';
      html += `<p><strong>Exercice.</strong> Soit la fonction \\(f\\) d√©finie sur \\(\\mathbf{R}\\) par \\(${fx}\\). <br>R√©soudre :</p>`;
     
	 html += `<ol style="margin:.35rem 0 0 0rem">
                 <li>\\(f(x)=0\\)</li>
               </ol>
               <div class="vecrow pdf-hide" style="margin:.35rem 0 .6rem 1.2rem">
                 <span>\\(S=\\)</span>
                 <input id="eq_x" style="width:120px" placeholder="">
                 <span class="tick" id="tk_eq"></span>
               </div>`;
html += `<ol start="2" style="margin:.35rem 0 0 0rem">
  <li>\\(f(x) ${latexCmp} 0\\)</li>
</ol>
<div class="vecrow pdf-hide" style="margin:.35rem 0 0 1.2rem">
  <span>\\(x\\)</span>
  <select id="ineq_cmp">
    <option value=""></option>
    <option value="<">&lt;</option>
    <option value="<=">‚â§</option>
    <option value=">">&gt;</option>
    <option value=">=">‚â•</option>
  </select>
  <span>&nbsp;</span>
  <input id="ineq_v" style="width:120px" placeholder="">
  <span class="tick" id="tk_ineq_cmp"></span>
</div>`;

			  
			   
		
			   
			   
			// ‚Ä¶ apr√®s l‚Äô√©nonc√© de a) et b)
// ‚Ä¶ apr√®s l‚Äô√©nonc√© de a) et b)
// NOTE : on n'utilise PAS this.state ici, il n'est pas encore d√©fini.
const x0Latex = latexR_leadMinus(x0simp);
html += `<p style="margin:.6rem 0 .25rem 0"><strong>Compl√®te le tableau de signes de \\(f(x)\\)</strong></p>`;
html += affineSignTableInteractiveHTML();
html += `<div class="vecrow pdf-hide" style="margin:.35rem 0 .6rem 1.2rem">
  <span>\\(S=\\)</span>
  <input id="ineq_S" style="width:180px" placeholder="">
  <span class="tick" id="tk_ineq_S"></span>
</div>`;



setEqu(html); retypeset(HOST);
   
			   
			   

      this.state = { m, p, x0:x0simp, want, parseNum };
    },

    verify(){
  const st=this.state; if(!st) return false;
  const {m,x0,parseNum} = st;
  const root = x0.p/x0.q;

// (a) √©quation ‚Äî tick tk_eq ‚Äî saisie OBLIGATOIREMENT {‚Ä¶}
const vx = ($('#eq_x')?.value||'').trim();
let aState='neutral';
if (vx!==''){
  const ps = parseSingletonSet(vx, parseNum);   // attend {r√©ponse}
  if (ps.ok){
    aState = (Math.abs(ps.value - (x0.p/x0.q)) < 1e-9) ? 'ok' : 'ko';
  }else{
    aState = 'ko'; // mal form√© (pas d'accolades, ou valeur non num√©rique)
  }
}
setTick('tk_eq', aState==='ok'?'ok':aState==='ko'?'ko':'');


 // (b) in√©quation "x ? valeur" ‚Äî NEUTRE si vide/partiel
const c  = ($('#ineq_cmp')?.value||'').trim();
const sv = ($('#ineq_v')?.value||'').trim();
let bState='neutral';
if (c!=='' && sv!==''){                 // ‚¨ÖÔ∏è on n'√©value que si les DEUX sont saisis
  const t = parseNum(sv);
  if (isFinite(t)){
    const swap = s=>({'>':'<','<':'>','>=':'<=','<=':'>='}[s]);
    const want = st.want;
    const expCmp = (m.p>0? want : swap(want));
    const okCmp = (c===expCmp);
    const okVal = Math.abs(t - (x0.p/x0.q)) < 1e-9;
    bState = (okCmp && okVal) ? 'ok' : 'ko';
  }else{
    bState = 'ko';
  }
}
setTick('tk_ineq_cmp', bState==='ok'?'ok':bState==='ko'?'ko':'');


// (c) tableau de signes ‚Äî on n'√©value QUE si les 3 champs sont remplis
const leftSel  = ($('#tab_left')?.value || '').trim();
const rightSel = ($('#tab_right')?.value || '').trim();
const x0In     = ($('#tab_x0')?.value || '').trim();

let tState = 'neutral';
if (leftSel!=='' && rightSel!=='' && x0In!=='') {
  const expL = (m.p > 0) ? '‚àí' : '+';   // m>0 : n√©gatif avant x0 ; m<0 : positif
  const expR = (m.p > 0) ? '+' : '‚àí';
  const t = parseNum(x0In);
  const okX0 = isFinite(t) && Math.abs(t - (x0.p/x0.q)) < 1e-9;
  const okSigns = (leftSel === expL && rightSel === expR);
  tState = (okX0 && okSigns) ? 'ok' : 'ko';
}
// tick neutre si au moins un champ vide
setTick('tk_tab', tState==='ok' ? 'ok' : tState==='ko' ? 'ko' : '');



  // (d) saisie finale "S = intervalle" ‚Äî tick tk_ineq_S
  function normInf(s){
    return String(s).toLowerCase()
      .replace(/\u221e/g,'oo')   // ‚àû
      .replace(/\+\s*oo/g,'+oo')
      .replace(/-\s*oo/g,'-oo')
      .trim();
  }
  function parseInterval(str){
    // accepte ]-oo; a[, ]-oo; a], [a; +oo[, etc. avec espaces optionnels
    const s = normInf(str).replace(/\s+/g,'');
    const m = s.match(/^([\[\]])(-?oo|[^\[\];]+);(-?oo|\+?oo|[^\[\];]+)([\[\]])$/);
    if(!m) return null;
    const [_, Lb, A, B, Rb] = m;
    return { Lb, A, B, Rb };
  }
  function almostEq(a,b){ return Math.abs(a-b) < 1e-9; }

  const wantFinal = (m.p>0 ? st.want : ({'>':'<','<':'>','>=':'<=','<=':'>='}[st.want]));
  const Sraw = ($('#ineq_S')?.value||'').trim();
  let sState='neutral';
  if (Sraw!==''){
    const iv = parseInterval(Sraw);
    if (!iv) sState='ko';
    else{
      const a = iv.A, b = iv.B, Lb = iv.Lb, Rb = iv.Rb;
      const okLeftInf  = (a==='-oo');
      const okRightInf = (b==='+oo' || b==='oo');
      const val = parseNum(a==='-oo'? b : a); // on regardera la borne finie
      const isVal = isFinite(val) && almostEq(val, root);

      let ok=false;
      if (wantFinal === '<')   ok = (okLeftInf && isVal && Rb==='[');      // ]-oo; x0[
      if (wantFinal === '<=')  ok = (okLeftInf && isVal && Rb===']');      // ]-oo; x0]
      if (wantFinal === '>')   ok = (okRightInf && isVal && Lb===']');     // ]x0; +oo[
      if (wantFinal === '>=')  ok = (okRightInf && isVal && Lb==='[');     // [x0; +oo[
      sState = ok ? 'ok' : 'ko';
    }
  }
  setTick('tk_ineq_S', sState==='ok'?'ok':sState==='ko'?'ko':'');

  // Score global : ne compte que ce qui est rempli
  const filled = (aState!=='neutral') || (bState!=='neutral') || (tState!=='neutral') || (sState!=='neutral');
  if (!filled){ setFB(null,''); return false; }
  const okCount  = (aState==='ok') + (bState==='ok') + (tState==='ok') + (sState==='ok');
  const totCount = (aState!=='neutral') + (bState!=='neutral') + (tState!=='neutral') + (sState!=='neutral');
  setFB(okCount===totCount, `${okCount} / ${totCount}`);
  return okCount===totCount;
}
,




   solution(){
  const st=this.state; if(!st) return;
  const {m,p,x0,want} = st;

  const latexCmpAsk = {'>':'\\;>\\;','<':'\\;<\\;','>=':'\\;\\ge\\;','<=':'\\;\\le\\;'}[want];
  const swap = s=>({'>':'<','<':'>','>=':'<=','<=':'>='}[s]);
  const finalCmp = (m.p>0? want : swap(want));
  const finalTex = {'>':'\\;>\\;','<':'\\;<\\;','>=':'\\;\\ge\\;','<=':'\\;\\le\\;'}[finalCmp];

  const fx = `${coefX(m)}${plusC(p)}`;
  const x0Latex = latexR_leadingMinus(x0);
// Valeur exacte de m, avec bon signe/forme (entier ou fraction)
const mLatex = latexR_leadingMinus(m);
// ‚Äî Texte de justification demand√© ‚Äî
const JUSTIF_TXT = (m.p>0)
  ? `car \\(m=${mLatex}\\) \\(> 0\\) `
  : `car \\(m=${mLatex}\\) \\(< 0\\)`;
const justifHTML = `<p class="hint">${JUSTIF_TXT}</p>`;



// Texte de justification AVEC la vraie valeur de m
const JUSTIF_TXT2 = (m.p > 0)
  ? `car \\(${mLatex}\\) \\(> 0\\) `
  : `car \\(${mLatex}\\) \\(< 0\\)`;

// petit helper HTML
const justifHTML2 = `${JUSTIF_TXT2}`;


  // -------- Colonne 1 : √âquation f(x)=0 (sans doublons)
  const eqSteps = [];
  _pushStep(eqSteps, `\\(f(x)=0\\)`);
  _pushStep(eqSteps, `\\(${fx}=0\\)`);
  if (p.p !== 0){
    _pushStep(eqSteps, `\\(${coefX(m)} = ${latexR_leadingMinus(R(-p.p,p.q))}\\)`);
  }
  _pushStep(eqSteps, `\\(x = ${x0Latex}\\)`);
_pushStep(eqSteps, `\\(S=\\left\\{ ${x0Latex} \\right\\}\\)`);

  const colEq = `
    <p><strong>√âquation \\(f(x)=0\\)</strong></p>
    ${_renderParas(eqSteps)}
  `;

  // -------- Colonne 2 : M√©thode alg√©brique (sans doublons)
  const ineqSteps = [];
  _pushStep(ineqSteps, `\\(f(x) ${latexCmpAsk} 0\\)`);
  _pushStep(ineqSteps, `\\(${fx} ${latexCmpAsk} 0\\)`);

  if (p.p !== 0){
    // √©tape "d√©placement du p"
    _pushStep(ineqSteps, `\\( ${coefX(m)} ${latexCmpAsk} ${latexR_leadingMinus(R(-p.p,p.q))}\\)`);
  }

  // √©tape finale "x ‚Ä¶ x0" (n'est ajout√©e que si diff√©rente de la pr√©c√©dente)
  _pushStep(ineqSteps, `\\(x ${finalTex} ${x0Latex}  \\) \\( \\) ${justifHTML2}`);

  _pushStep(ineqSteps, `\\(S = ${intervalFromCmp(finalCmp, x0Latex)}\\)`);

const colMeth1 = `
  <p><strong>1<sup>√®re</sup> m√©thode (alg√©brique)</strong></p>
  ${_renderParas(ineqSteps)}
`;


  // -------- Colonne 3 : tableau de signes (inchang√©)
  const mSign = (m.p>0) ? 1 : -1;
const colMeth2 = `
  <p><strong>2<sup>√®me</sup> m√©thode (tableau de signes)</strong></p>
  <p>\\(f(x) ${latexCmpAsk} 0\\)</p>
  ${affineSignTableHTML(mSign, x0Latex)}
  ${justifHTML}    
  R√®gle : Signe du coefficient directeur \\(m\\) "√† droite du z√©ro".
  <p>\\(S = ${intervalFromCmp(finalCmp, x0Latex)}\\)</p>
`;


  // -------- Assemblage (sans .join())
  let html = '';
  html += `<div class="steps"><table class="tbl-invis" style="width:100%"><tr>`;
  html += `<td style="width:25%; border-right:2px solid #000; padding-right:.8rem;">${colEq}</td>`;
  html += `<td style="width:30%; border-right:2px solid #000; padding:0 .8rem;">${colMeth1}</td>`;
  html += `<td style="width:40%; padding-left:.8rem;">${colMeth2}</td>`;
  html += `</tr></table></div>`;

  setStepsHTML(html);
  retypeset(HOST);
}



  };
}

/* ====== G√©n√©rateur d‚Äôexos ====== */
const REGISTRY_MAP = {





// ====== Les deux variantes demand√©es ======
e15_int:  __mkEqIneqAffineExo({kind:'int'}),
e15_frac: __mkEqIneqAffineExo({kind:'frac'}),



};

/* === Adapter pour le kit PDF (identique √† avant) === */
const REGISTRY_ARRAY = Object.entries(REGISTRY_MAP).map(([id, cfg]) => ({
  id,
  title: (cfg.name || id).replace(/\\\\/g,'\\'),
  gen(){ return { n: Math.random() }; }
}));
if (typeof window !== 'undefined') window.REGISTRY = REGISTRY_ARRAY;


// PDF-only ‚Äî resserre *pmatrix* en array compact
// PDF-only ‚Äî compacte les vecteurs-colonne sans toucher l'√©cran
function tightenVectorsForPDF(html){
  if(!html) return html;

  // (a)  \begin{pmatrix} ... \end{pmatrix}  ->  ( array{c} ) + espaces n√©gatifs
  html = html.replace(
    /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (b)  \left( \begin{array}{c} ... \end{array} \right)  -> ajoute \! et r√©duit arraycolsep
  html = html.replace(
    /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (c)  versions sans \left...\right (rare) : ( array{c} ) ‚Üí ajoute \!
  html = html.replace(
    /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  // (d)  \pmatrix{‚Ä¶} macro √©ventuelle
  html = html.replace(
    /\\pmatrix\{([\s\S]*?)\}/g,
    (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
  );

  return html;
}





/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
/* Fabrique synchrone pour PDF : r√©cup√®re l‚Äô√©cran et convertit en SVG dans beforeRender (inchang√©) */
window.buildOneForPDFSync = function(defId){
  window.__PDF_BUILDING = true;           // ‚¨ÖÔ∏è d√©marre la zone neutre

  try {
    const cfg = REGISTRY_MAP[defId];
    if (!cfg) return { statement:'', solution:'' };

    const host   = document.querySelector('#host');
    const backup = host ? host.innerHTML : '';

    if (host) mountHost();
    document.querySelector('#lead').innerHTML = cfg.lead || '';

    // ‚¨áÔ∏è on g√©n√®re l‚Äô√©cran, mais retypeset() s‚Äôauto-d√©sactivera gr√¢ce au flag
    cfg.gen.call(cfg);


  // --- Restaure pour l‚Äô√©cran ---


  // ---- 1) R√©cup√©rer le rep√®re s‚Äôil existe
  const svgEl =
    document.querySelector('.row svg.svgbox') ||
    document.querySelector('svg.svgbox');

  let repereHTML = '';
  if (svgEl){
    const clone = svgEl.cloneNode(true);
    // taille fixe (PDF)
    clone.removeAttribute('style');
    clone.setAttribute('width','300');
    clone.setAttribute('height','300');
    // s√©curit√© namespaces + viewBox
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    repereHTML = clone.outerHTML;
  }

  // ---- 2) √ânonc√© texte (√©cran)
  const equHTML = (document.querySelector('#equ')||{}).innerHTML || '';

  // √ânonc√© final : grille 2 colonnes si on a un rep√®re, sinon texte seul
  const statement = repereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${repereHTML}</div>
         <div>${equHTML}</div>
       </div>`
    : equHTML;

  // ---- 3) Correction (√©cran)
const _oldRetypeset2 = window.retypeset;
  const _oldMJ2        = window.MJ;
  window.retypeset = function(){};
  window.MJ        = function(){};
  cfg.solution.call(cfg);
  
  // ---- Apr√®s cfg.solution.call(cfg); (et avant le restore) ----

// 2.1) R√©cup√©rer le SVG *corrig√©*
let corrigeRepereHTML = '';
{
  const svgSol = document.querySelector('.row svg.svgbox') || document.querySelector('svg.svgbox');
  if (svgSol){
    const clone = svgSol.cloneNode(true);
    clone.removeAttribute('style');
    clone.setAttribute('width','300');      // taille PDF
    clone.setAttribute('height','300');
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    if (!clone.getAttribute('viewBox')) clone.setAttribute('viewBox','0 0 420 420');
    corrigeRepereHTML = clone.outerHTML;
  }
}

// 2.2) R√©cup√©rer le HTML texte de la correction
const corrigeTexteHTML = (document.querySelector('#res')||{}).innerHTML || '';

// 2.3) Composer la *correction* pour le PDF : rep√®re + texte
const solution =
  corrigeRepereHTML
    ? `<div style="display:grid;grid-template-columns:300px 1fr;gap:12px;align-items:start">
         <div>${corrigeRepereHTML}</div>
         <div>${corrigeTexteHTML}</div>
       </div>`
    : corrigeTexteHTML;

  
  
  window.retypeset = _oldRetypeset2;
  window.MJ        = _oldMJ2;

  if (host) host.innerHTML = backup;

  // ---- 4) PDF-only : resserrer les pmatrix via TeX (espace interne)
  function tightenVectorsForPDF(html){
    if(!html) return html;
    // pmatrix -> array{c} + espaces n√©gatifs
    html = html.replace(
      /\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \left( \begin{array}{c} ... \end{array} \right) -> ajoute \!
    html = html.replace(
      /\\left\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\\right\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // versions sans \left...\right
    html = html.replace(
      /\(\s*\\begin\{array\}\{c\}([\s\S]*?)\\end\{array\}\s*\)/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    // \pmatrix{‚Ä¶}
    html = html.replace(
      /\\pmatrix\{([\s\S]*?)\}/g,
      (_m, inside) => `{\\arraycolsep=1.5pt\\left(\\!\\begin{array}{c}${inside}\\end{array}\\!\\right)}`
    );
    return html;
  }

  const statementTight = statement;
  const solutionTight  = solution;
  
 function stripCHTML(html){
  if(!html) return html;
  return html
     .replace(/<mjx-container[\s\S]*?<\/mjx-container>/g, (m)=>{
       // On essaie de r√©cup√©rer le TeX source si MathJax l‚Äôa laiss√© en data-tex,
       // sinon on supprime (on n‚Äôen veut pas dans le PDF SVG).
       const tex = m.match(/data-tex="([^"]+)"/);
       return tex ? `\\(${tex[1]}\\)` : '';
     });
 }
 const statementClean = stripCHTML(statementTight);
 const solutionClean  = stripCHTML(solutionTight);

  // ‚ö†Ô∏è On wrappe ici avec .vec-tight pour activer le CSS ‚Äúresserr√©‚Äù c√¥t√© iframe PDF (SVG)
    return {
      statement: `<div class="vec-tight">${statementTight||''}</div>`,
      solution:  `<div class="vec-tight">${solutionTight||''}</div>`
    };
  } finally {
    window.__PDF_BUILDING = false;        // ‚¨ÖÔ∏è on r√©active l‚Äô√©cran quoi qu‚Äôil arrive
  }
};




/* ======== UI fil rouge ======== */
(function(){
  'use strict';
  function whenReady(cb){ if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
  whenReady(function init(){
    const sel = document.querySelector('#exo-select');
    sel.innerHTML = Object.entries(REGISTRY_MAP).map(([k,v]) => `<option value="${k}">${(v.name||'').replace(/\\\\/g,'\\')}</option>`).join('');
    let ACTIVE = sel.value || Object.keys(REGISTRY_MAP)[0];
	

    let SCORE_OK = 0, SCORE_TOT = 0;
    function updateScore(){ document.querySelector('#score').textContent = `${SCORE_OK} / ${SCORE_TOT}`; }
  



  function buildOne(){

  mountHost(); // injecte le layout par d√©faut avec #ans
  const cfg = REGISTRY_MAP[ACTIVE];

  // lead
  document.querySelector('#lead').innerHTML = cfg.lead || '';

  // √©l√©ments optionnels (#ans existe pour e1/e2, mais pas pour e3/ex4)
  const ansEl = $('#ans', HOST);
  const fbEl  = $('#fb', HOST);
  const resEl = $('#res', HOST);

  if (ansEl){
    ansEl.value = '';
    ansEl.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        $('#btn-check')?.click();
      }
    });
  }
  if (fbEl)  fbEl.textContent = '';
  if (resEl) resEl.innerHTML  = '';

  // g√©n√®re l'exo (peut remplacer enti√®rement le host, ex. e3/ex4)
  cfg.gen.call(cfg);




  // (re)typeset
  retypeset();

}

    document.querySelector('#btn-new').addEventListener('click', buildOne);
document.querySelector('#btn-reset').addEventListener('click', ()=>{
  const a=$('#ans',HOST); if(a) a.value='';
  document.querySelectorAll('.colvec input').forEach(i=> i.value=''); // ‚¨ÖÔ∏è AJOUT
  const f=$('#fb',HOST); if(f) f.textContent='';
  const r=$('#res',HOST); if(r) r.innerHTML='';
});
    document.querySelector('#btn-check').addEventListener('click', ()=>{ SCORE_TOT++; const ok = REGISTRY_MAP[ACTIVE].verify.call(REGISTRY_MAP[ACTIVE])===true; if(ok) SCORE_OK++; updateScore(); });
    document.querySelector('#btn-solution').addEventListener('click', ()=>{ REGISTRY_MAP[ACTIVE].solution.call(REGISTRY_MAP[ACTIVE]); });


function adjustLive(kind){
  const id = ACTIVE;
  if (id === 'e3'   && REGISTRY_MAP.e3.adjustLive)   REGISTRY_MAP.e3.adjustLive(kind);
  else if (id === 'ex4' && REGISTRY_MAP.ex4.adjustLive) REGISTRY_MAP.ex4.adjustLive(kind);
  else if (id === 'e5'  && REGISTRY_MAP.e5.adjustLive)  REGISTRY_MAP.e5.adjustLive(kind);
  else { applyAMPInputs(); }
}


['xmin','xmax','ymin','ymax'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ applyAMPInputs(); adjustLive('amp'); });
  el.addEventListener('change',()=>{ applyAMPInputs(); adjustLive('amp'); });
});

const nbEl   = document.getElementById('nbPts');
if (nbEl){
  nbEl.addEventListener('input',  ()=> adjustLive('n'));
  nbEl.addEventListener('change', ()=> adjustLive('n'));
}




   sel.addEventListener('change', ()=>{ ACTIVE = sel.value;     buildOne(); });
    buildOne(); updateScore();
  });
})();

/* ======== Adaptateur PDF (SVG) ‚Äî inchang√©, conserve exactement #res ======== */
(function(){
  document.addEventListener('DOMContentLoaded', function () {
    if (!(window.ExoPDF && typeof ExoPDF.init === 'function')) return;
    ExoPDF.init({
      title: document.title,
      mountAfterSelector: '#host',
      beforeGen(){ return {}; },
      beforeRender(def, _st, withSolutions){
        return (async () => {
          const defId = def?.id || '';
          const label = (window.REGISTRY_MAP?.[defId]?.name || defId || '').replace(/\\\\/g,'\\');
          const fab = (typeof window.buildOneForPDFSync==='function') ? window.buildOneForPDFSync : (_)=>({statement:'',solution:''});
          const { statement, solution } = fab(defId);
// --- PDF-only: resserre les parenth√®ses des vecteurs-colonne ---
function tightenVectorsForPDF(html){
  if(!html) return html;
  // 1) diminue l'espace colonne dans les array (√©quivalent \arraycolsep)
  html = html.replace(/\\begin\{array\}\{c\}/g, '{\\arraycolsep=1.5pt\\begin{array}{c}');
  // 2) colle les grandes parenth√®ses √† la matrice (\left( ... \right))
  //    (sans toucher le reste du doc)
  html = html
    .replace(/\\left\(\s*\\begin\{array\}\{c\}/g, '\\left(\\mkern-6mu\\begin{array}{c}')
    .replace(/\\end\{array\}\s*\\right\)/g, '\\end{array}\\mkern-6mu\\right)');
  return html;
}

const statementTight = tightenVectorsForPDF(statement);
const solutionTight  = tightenVectorsForPDF(solution);

          const htmlIn =
  `<div class="exo-block">
     <span class="exo-title">Exercice</span>
     <div class="exo-statement">${statementTight||''}</div>
   </div>` +
  (withSolutions
    ? `<div style="margin-top:1rem;">
         <div class="exo-block"><div class="steps" id="pdf-steps">
           <span class="exo-title"></span>
           <!-- ‚¨áÔ∏è Ajout d‚Äôun conteneur .steps pour retrouver la zone grise -->
           <div class="exo-solution">${solutionTight||''}</div></div>
         </div>
       </div>`
    : '');


          const iframe = document.createElement('iframe');
          Object.assign(iframe.style,{position:'fixed',left:'-10000px',top:'-10000px',width:'0',height:'0',visibility:'hidden'});
          document.body.appendChild(iframe);

          const idoc = iframe.contentDocument;
          idoc.open(); idoc.write('<!doctype html><html><head><meta charset="utf-8"><title>pdf-build</title></head><body><div id="root"></div></body></html>'); idoc.close();
          const root = idoc.getElementById('root'); root.innerHTML = htmlIn;
const css = idoc.createElement('style');
css.textContent = `
  :root{
    --ink:#111; --bg:#fafafa; --card:#fff; --line:#e5e7eb; --muted:#666;
    --steps-bg:#f3f4f6; --steps-border:#e5e7eb; --steps-left:#9aa0a6;
  }
  body{font:16px/1.55 system-ui,Segoe UI,Roboto,Arial;color:var(--ink);}
  .exo-title{display:block;font-weight:700;margin:0 0 6px}
  /* ‚öôÔ∏è Zone grise identique √† l‚Äô√©cran (#res.steps) */
  .steps{
    background:var(--steps-bg);
    border:1px solid var(--steps-border);
    border-left:4px solid var(--steps-left);
    border-radius:8px;
    padding:10px;
    margin:.45rem 0 0 .15rem;
  }
  .steps p{margin:.25rem 0}
  /* Table ‚Äúe5‚Äù compacte */
  .tbl3{border-collapse:collapse}
  .tbl3 td{padding:2px 6px;vertical-align:top}
  
  /* === Tighten parentheses around column vectors (SVG output) === */
/* CHTML (au cas o√π), agit sur les delimiters extensibles */
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:first-child { margin-right: -0.18em; }
.vec-tight mjx-mrow > mjx-mo[stretchy="true"]:last-child  { margin-left:  -0.18em; }
.vec-tight mjx-mtable mjx-mtd { padding-left: .15em; padding-right: .15em; }
.vec-tight mjx-mtable > mjx-table { margin-left: 0; margin-right: 0; }

/* SVG : d√©caler l√©g√®rement OPEN/CLOSE pour coller les parenth√®ses au tableau */
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="OPEN"]  { transform: translateX(-0.18em); }
.vec-tight svg[aria-hidden="true"] g[data-mjx-texclass="CLOSE"] { transform: translateX( 0.18em); }

/* Ajustement global tr√®s l√©ger si besoin (peut √™tre mis √† 0 si tu pr√©f√®res) */
.vec-tight svg[aria-hidden="true"] { margin-left:-0.10em; margin-right:-0.10em; }
/* --- Anti "barres noires" MathJax (PDF) --- */
.exo-statement,
.exo-solution { color:#111 !important; background:transparent !important; }

/* Cas CHTML (au cas o√π) */
mjx-container { color:#111 !important; background:transparent !important; }
mjx-container svg { overflow:visible !important; }
mjx-container svg rect,
mjx-container svg path[data-mml-node="mspace"] { fill:none !important; }

/* Cas SVG standalone (ce que tu utilises dans l‚Äôiframe) */
.exo-statement svg rect,
.exo-statement svg path[data-mml-node="mspace"],
.exo-solution  svg rect,
.exo-solution  svg path[data-mml-node="mspace"] { fill:none !important; }
/* Tableau bordur√© noir partout */
.table-black{
  width:100%;
  border-collapse:collapse;
  border:1.2px solid #000;
}
.table-black th,
.table-black td{
  border:1.2px solid #000;
  padding:6px 8px;
  text-align:left;
}
.table-black thead th{ background:#fff; }
`;
idoc.head.appendChild(css);

          const cfg = idoc.createElement('script');
          cfg.text = `
            window.MathJax = {
              loader: {load: ['input/tex','output/svg']},
              tex: { inlineMath: [['\\\\(','\\\\)'], ['$', '$']], displayMath: [['\\\\[','\\\\]'], ['$$','$$']], processEscapes:true, packages:{'[+]':['bbox','ams']} },
              svg: { fontCache: 'none' },
              options: { skipHtmlTags: ['script','noscript','style','textarea'] },
              startup: { typeset: false }
            };`;
          idoc.head.appendChild(cfg);
          const mj = idoc.createElement('script'); mj.src = new URL("../../../../es5/tex-svg.js", window.location.href).href; idoc.head.appendChild(mj);
          await new Promise(r=>{ mj.onload=r; mj.onerror=r; });

          const iwin = iframe.contentWindow;
          for (let i=0;i<300 && !(iwin.MathJax && iwin.MathJax.tex2svg); i++) await new Promise(r=>setTimeout(r,10));
          if (!(iwin.MathJax && iwin.MathJax.tex2svg)){ const out = root.innerHTML; iframe.remove(); return out; }

          const RX_INLINE=/\\\((.+?)\\\)/gs, RX_DISPLAY_BR=/\\\[(.+?)\\\]/gs, RX_DISPLAY_DOLLAR=/\$\$(.+?)\$\$/gs;
          function texToStandaloneSVG(tex, display){
            const mjx = iwin.MathJax.tex2svg(tex,{display}); const svg=mjx.querySelector('svg'); if(!svg) return idoc.createTextNode(tex);
            const out=svg.cloneNode(true); out.setAttribute('xmlns','http://www.w3.org/2000/svg'); out.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink'); out.setAttribute('overflow','visible');
            out.querySelectorAll('use').forEach(u=>{const h=u.getAttribute('href');const xh=u.getAttribute('xlink:href'); if(h && !xh) u.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',h); if(xh && !h) u.setAttribute('href',xh);});
            return out;
          }
          function replaceTeXIn(node){
            const SKIP=new Set(['SCRIPT','STYLE','CODE','PRE']); if(node.nodeType===1 && SKIP.has(node.tagName)) return;
            const children=[...node.childNodes];
            for(const ch of children){
              if(ch.nodeType===Node.TEXT_NODE){
                const text=ch.nodeValue; if(!text || !/[\\$]/.test(text)) continue;
                let parts=null;
                const consume=(re,display)=>{ re.lastIndex=0; let m,last=0,out=[]; while((m=re.exec(text))!==null){ out.push({t:'text',v:text.slice(last,m.index)}); out.push({t:'math',v:m[1],d:display}); last=re.lastIndex; } if(out.length) out.push({t:'text',v:text.slice(last)}); return out.length?out:null; };
                parts = consume(RX_DISPLAY_DOLLAR,true) || consume(RX_DISPLAY_BR,true) || consume(RX_INLINE,false);
                if(parts){ for(const p of parts){ if(p.t==='text') ch.parentNode.insertBefore(idoc.createTextNode(p.v),ch); else ch.parentNode.insertBefore(texToStandaloneSVG(p.v,p.d),ch); } ch.parentNode.removeChild(ch); }
              }else if(ch.nodeType===Node.ELEMENT_NODE){ replaceTeXIn(ch); }
            }
          }
          replaceTeXIn(root);
          const finalHTML = root.innerHTML; iframe.remove(); return finalHTML;
        })().catch(err=>{ console.error(err); return htmlIn; });
      }
    });
  });
})();
</script>
</body>
</html>
