<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Statistiques - Couple moyenne / √©cart type</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:var(--ok); }
  .tick.ko::after{ content:'‚úó'; color:var(--ko); }

  table.pdf-tbl{
    border-collapse: separate;
    border-spacing: 0;
    border:none;
    margin:.5rem 0;
    width:100%;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border:none;
    padding:4px 6px;
    text-align:center;
    vertical-align:middle;
  }
  table.pdf-tbl th{
    background:#f3f3f6;
    font-weight:600;
  }
  table.pdf-tbl tr:first-child > * { border-top:1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom:1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right:1.5px solid #000; }

  table.pdfb input[type="text"]{
    width:100%;
    max-width:90px;
    padding:4px 6px;
    border:1px solid #ddd;
    border-radius:6px;
    text-align:center;
    font-size:.95rem;
  }
  /* Ligne horizontale entre toutes les lignes du tableau */
  table.pdf-tbl tbody tr + tr > *{
    border-top:1px solid #000;
  }
  .tbl{border-collapse:collapse;width:100%;max-width:760px;margin:.25rem 0}
  .tbl th,.tbl td{border:1px solid #ddd;padding:6px 8px;text-align:center}
  .tbl th{background:#f7f7f7}

  .q-block{margin-top:.6rem}
  .q-block p{margin:.25rem 0}
  .q-block input[type="text"]{
    width:160px;
    max-width:60%;
    padding:4px 6px;
    border:1px solid #ddd;
    border-radius:6px;
    text-align:center;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

  /* === Bordures opt-in pour certains tableaux (PDF uniquement) === */
  table.pdfb{ border-collapse: collapse; }
  table.pdfb, table.pdfb th, table.pdfb td{
    border: 1px solid #000;
    padding: 4px 6px;
    vertical-align: top;
  }
  /* Tableaux "plein largeur" pour le PDF, uniquement si .pdfb est pr√©sente */
  table.pdfb{
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
  }
  table.pdfb, table.pdfb th, table.pdfb td{
    border: 1px solid #000;
    padding: 6px 8px;
    vertical-align: top;
    white-space: normal;
    word-break: break-word;
  }
  /* PDF : m√™me respiration pour la colonne 3 des tableaux de corrig√© */
  table.pdfb.corrige td:nth-child(3),
  table.pdfb.corrige th:nth-child(3){
    padding-left: 12px;
    padding-right: 12px;
  }

  .tbl-solution td.fcc-total{
    background:#e0e0e0;
  }
</style>

<script>
  // MathJax pour d'√©ventuels LaTeX simples
  window.MathJax={
    tex:{inlineMath:[['\\(','\\)'],['$','$']],processEscapes:true},
    chtml:{matchFontHeight:false},
    startup:{typeset:true}
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.multiplicatif.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Statistiques - Couple moyenne / √©cart type</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les fr√©quences, saisir un <strong>d√©cimal</strong> (ex. <code>0,12</code> ou <code>0.12</code>) ou une <strong>fraction</strong> (ex. <code>3/25</code>).</li>
        <li>On n‚Äô√©crit pas le symbole <code>%</code> : la fr√©quence d√©cimale <code>0,24</code> correspond par exemple √† <code>24&nbsp;%</code>.</li>
        <li>La somme des fr√©quences vaut 1 ; la derni√®re FCC vaut toujours 1.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ====== Utils simples ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className = 'tick '+state;
}
function clearTicks(root){
  root.querySelectorAll('.tick').forEach(t=>t.className='tick nu');
}

/* nombre al√©atoire entier */
const rint = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = arr => arr[Math.floor(Math.random()*arr.length)];

/* === Gestion globale du mode de fr√©quences par exercice === */
const FREQ_MODE_BY_EXO = {};   // ex.id -> 'arrondi' | 'calc'
function getFreqModeFor(defId){
  return FREQ_MODE_BY_EXO[defId] || 'arrondi';
}

/* G√©n√©rer des effectifs "calculables"
   - total ‚àà {100, 200}
   - tous les effectifs pairs
   - bien r√©partis (min 2 par case, pas de case √©norme)
*/
function genCalcEffectifs(n){
  const totals = [100,200];
  const total = choice(totals);
  const eff = new Array(n).fill(2);     // au moins 2 par modalit√©
  let remaining = total - 2*n;          // reste √† r√©partir, pair

  const maxPerCell = total/2;           // borne haute pour √©viter un gros pic

  while(remaining > 0){
    const i = rint(0,n-1);
    if(eff[i] < maxPerCell){
      eff[i] += 2;
      remaining -= 2;
    }
  }
  return {eff,total};
}

/* parse num√©rique tol√©rant (d√©cimal FR/US + fractions) */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.');
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const [p,q] = s.split('/').map(x=>Number(x));
    if(!q) return NaN;
    return p/q;
  }
  const n = Number(s);
  return isFinite(n) ? n : NaN;
}
function approxEqual(a,b,eps=1e-2){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}
function fmtFreq(x){
  if(!isFinite(x)) return '';
  const r = Math.round(x*100)/100;      // 2 d√©cimales max
  return String(r).replace('.',',');
}
function normalizeStr(s){
  return String(s||'')
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/<[^>]+>/g,' ')
    .replace(/[^a-z0-9]+/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}

function isCaracAnswerOk(rawValue, expectedLabel, altLabel){
  if(!rawValue) return false;
  const ans = normalizeStr(rawValue);
  if(!ans) return false;

  const exp = normalizeStr(expectedLabel || '');
  const alt = normalizeStr(altLabel || '');

  // 1) √©galit√© exacte avec le texte officiel
  if(ans === exp || (alt && ans === alt)) return true;

  // 2) r√©ponse plus courte du type "nombre de ...":
  //    on accepte si la r√©ponse est un sous-ensemble significatif
  //    du libell√© (ou l'inverse)
  const minLen = 4;
  if(ans.length >= minLen){
    if(exp.includes(ans) || (alt && alt.includes(ans))) return true;
  }
  if(exp.length >= minLen && ans.includes(exp)) return true;
  if(alt && alt.length >= minLen && ans.includes(alt)) return true;

  // 3) Fallback : au moins deux mots importants en commun
  const base = (exp + ' ' + alt).trim();
  const baseWords = new Set(
    base.split(/\s+/).filter(w => w.length >= 3)
  );
  const ansWords = ans.split(/\s+/).filter(w => w.length >= 3);

  let common = 0;
  for(const w of ansWords){
    if(baseWords.has(w)) common++;
  }
  if(common >= 2) return true;

  // cas d‚Äôun seul mot significatif qui matche (ex : "taille")
  if(ansWords.length === 1 && baseWords.has(ansWords[0])) return true;

  return false;
}



function typeset(root){
  if(window.MathJax && MathJax.typesetPromise){
    MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  }
}

/* s√©lecteur interne : fr√©quence arrondie / calculable */
function attachFreqModeSelector(host){
  const sel = host.querySelector('select[data-freq-mode]');
  if(!sel) return;
  const defId = host.dataset.active;
  if(!defId) return;

  sel.value = getFreqModeFor(defId);

  sel.onchange = ()=>{
    FREQ_MODE_BY_EXO[defId] = sel.value;       // on m√©morise le mode
    const def = getDefById(defId);
    const st  = def.gen();                     // reg√©n√®re avec ce mode
    host.dataset.state = JSON.stringify(st);
    def.render(host,st);
    try{
      if(window.MathKbd?.attachAllInputs){
        MathKbd.attachAllInputs(host);
      }
    }catch(_){}
  };
}

/* ====== Aide pour la population √©tudi√©e ====== */
const POP_RULES = [
  { keyword:'jeunes',    label:'les jeunes de 16 √† 25 ans' },
  { keyword:'lyceens',   label:'les lyc√©ens' },
  { keyword:'eleves',    label:'les √©l√®ves' },
  { keyword:'lyc√©ens',   label:'les lyc√©ens' },
  { keyword:'√©l√®ves',    label:'les √©l√®ves' },

  { keyword:'patients',  label:'les patients' },
  { keyword:'patient',   label:'le patient suivi' },

  { keyword:'clients',   label:'les clients' },
  { keyword:'abonnes',   label:'les abonn√©s' },
  { keyword:'abonn√©s',   label:'les abonn√©s' },
  { keyword:'adherents', label:'les adh√©rents' },
  { keyword:'adh√©rents', label:'les adh√©rents' },

  { keyword:'familles',  label:'les familles' },
  { keyword:'licencies', label:'les licenci√©s' },
  { keyword:'licenci√©s', label:'les licenci√©s' },
  { keyword:'membres',   label:'les membres' },
  { keyword:'personnes', label:'les personnes interrog√©es' },

  { keyword:'lapins',    label:'les lapins de l‚Äô√©levage' },
  { keyword:'voitures',  label:'les voitures contr√¥l√©es' },
  { keyword:'bagages',   label:'les bagages enregistr√©s' },

  { keyword:'eleve',     label:'l‚Äô√©l√®ve suivi' },
  { keyword:'√©l√®ve',     label:'l‚Äô√©l√®ve suivi' }
];

function getPopRuleFromIntro(intro){
  const plain = normalizeStr(intro);
  for(const rule of POP_RULES){
    const key = normalizeStr(rule.keyword);
    if(!key) continue;
    if (plain.includes(key)) return rule;
    if (key.endsWith('s')) {
      const sing = key.slice(0,-1);
      if (plain.includes(sing)) return rule;
    }
  }
  return null;
}

function getPopulationLabel(intro){
  const r = getPopRuleFromIntro(intro);
  if (r) return r.label;
  return 'la population d√©crite dans l‚Äô√©nonc√©';
}

function checkPopulationAnswer(inputValue,intro){
  const ans = normalizeStr(inputValue);
  if (!ans) return null;

  const r = getPopRuleFromIntro(intro);
  if (r) {
    const key = normalizeStr(r.keyword || r.label);
    return ans.includes(key);
  }

  const plainIntro = normalizeStr(intro);
  const wordsIntro = new Set(plainIntro.split(/\s+/));
  const wordsAns   = ans.split(/\s+/);
  const hasCommon  = wordsAns.some(w => wordsIntro.has(w));

  return hasCommon;
}


function isExactRatio(num, den){
  // vrai si num/den donne un pourcentage entier (2 d√©cimales max pour la fr√©quence)
  if(!Number.isFinite(num) || !Number.isFinite(den) || den === 0) return false;
  return (num * 100) % den === 0;   // √©quivaut √† : num/den = k/100
}


function getTotalRangeForCompDiscrete(ctx){
  const s = normalizeStr(ctx.intro);

  // Cas "une classe", "les √©l√®ves d‚Äôune classe"
  if (s.includes('classe') && s.includes('eleves') || s.includes('classe') && s.includes('√©l√®ves')) {
    return {min:24, max:32};     // une classe raisonnable
  }

  // Cas "les √©l√®ves de deux classes" -> chaque s√©rie = une classe
  if (s.includes('deux classes') || s.includes('2 classes')) {
    return {min:24, max:32};
  }

  // Cas o√π l‚Äôeffectif correspond √† des √©l√®ves mais pas forc√©ment une seule classe
  if (s.includes('eleves') || s.includes('√©l√®ves')) {
    return {min:20, max:35};
  }

  // Cas dict√©e, quiz, copies de contr√¥le...
  if (s.includes('dict√©e') || s.includes('dictee') ||
      s.includes('quiz')   || s.includes('controle') || s.includes('contr√¥le')) {
    return {min:15, max:35};
  }

  // Cas "pendant un mois" avec nombre de jours
  if (s.includes('pendant un mois') && (s.includes('jour') || s.includes('jours') || s.includes('quotidien'))) {
    return {min:25, max:31};     // nombre de jours d‚Äôun mois
  }

  // Cas "pendant plusieurs semaines" avec jours
  if (s.includes('semaines') && (s.includes('jour') || s.includes('jours'))) {
    return {min:15, max:35};     // nombre de jours observ√©s r√©aliste
  }

  // Cas "matchs", "rencontres", "parties"
  if (s.includes('match') || s.includes('matchs') || s.includes('rencontres') || s.includes('parties')) {
    return {min:10, max:30};
  }

  // Valeur par d√©faut raisonnable si rien de sp√©cial
  return {min:20, max:40};
}

function getTotalRangeForCompContinu(ctx){
  const s = normalizeStr(ctx.intro);

  // Dur√©es / grandeurs mesur√©es "pendant un mois" (jours)
  if (s.includes('pendant un mois') && (s.includes('jour') || s.includes('jours'))) {
    return {min:25, max:31};
  }

  // Grandeurs mesur√©es "chaque jour", "quotidien"
  if (s.includes('jour') || s.includes('jours') || s.includes('quotidien') || s.includes('quotidienne')) {
    return {min:20, max:40};
  }

  // Grandeurs mesur√©es sur des √©l√®ves
  if (s.includes('eleves') || s.includes('√©l√®ves') || s.includes('classe')) {
    return {min:20, max:35};
  }

  // Cas g√©n√©riques (temps, distances, temp√©ratures, etc.)
  return {min:20, max:40};
}


/* ====== Contextes ====== */

/* 20 contextes quantitatif discret */
const CTX_QDISCRET = [
  {intro:`Une soci√©t√© de pr√™t-√†-porter √©tudie le <strong>nombre de jeans achet√©s en un an</strong> par des jeunes de 16 √† 25 ans.`, varName:`nombre de jeans achet√©s`, xLabel:`Nombre de jeans achet√©s`, min:0, max:6},
  {intro:`Un cin√©ma fait une enqu√™te sur le <strong>nombre de s√©ances vues en un mois</strong> par des lyc√©ens.`, varName:`nombre de s√©ances de cin√©ma vues en un mois`, xLabel:`Nombre de s√©ances`, min:0, max:6},
  {intro:`Un professeur de math√©matiques s‚Äôint√©resse au <strong>nombre d‚Äôexercices de maths faits par semaine</strong> par ses √©l√®ves.`, varName:`nombre d‚Äôexercices faits par semaine`, xLabel:`Nombre d‚Äôexercices`, min:0, max:7},
  {intro:`Un club de sport √©tudie le <strong>nombre d‚Äôentra√Ænements hebdomadaires</strong> de ses adh√©rents.`, varName:`nombre d‚Äôentra√Ænements par semaine`, xLabel:`Nombre d‚Äôentra√Ænements`, min:0, max:5},
  {intro:`Une m√©diath√®que observe le <strong>nombre de livres emprunt√©s en un trimestre</strong> par ses abonn√©s.`, varName:`nombre de livres emprunt√©s en un trimestre`, xLabel:`Nombre de livres`, min:0, max:6},
  {intro:`Un lyc√©e √©tudie le <strong>nombre de correspondants par messages instantan√©s</strong> qu‚Äôont les √©l√®ves chaque jour.`, varName:`nombre de correspondants par jour`, xLabel:`Nombre de correspondants`, min:0, max:5},
  {intro:`Une agence de voyage √©tudie le <strong>nombre de voyages √† l‚Äô√©tranger effectu√©s en 3 ans</strong> par des familles.`, varName:`nombre de voyages √† l‚Äô√©tranger en 3 ans`, xLabel:`Nombre de voyages`, min:0, max:4},
  {intro:`Un club de lecture compte le <strong>nombre de r√©unions auxquelles participent les membres dans le mois</strong>.`, varName:`nombre de r√©unions de lecture dans le mois`, xLabel:`Nombre de r√©unions`, min:0, max:6},
  {intro:`Une association sportive √©tudie le <strong>nombre de comp√©titions auxquelles participent les licenci√©s dans l‚Äôann√©e</strong>.`, varName:`nombre de comp√©titions dans l‚Äôann√©e`, xLabel:`Nombre de comp√©titions`, min:0, max:7},
  {intro:`Une salle de jeux vid√©o observe le <strong>nombre de visites par mois</strong> de ses abonn√©s.`, varName:`nombre de visites de la salle par mois`, xLabel:`Nombre de visites`, min:0, max:6},
  {intro:`Une auto-√©cole observe le <strong>nombre de le√ßons de conduite suivies par semaine</strong> par ses √©l√®ves.`, varName:`nombre de le√ßons de conduite par semaine`, xLabel:`Nombre de le√ßons`, min:0, max:5},
  {intro:`Un club de natation √©tudie le <strong>nombre de fois o√π les adh√©rents vont √† la piscine par semaine</strong>.`, varName:`nombre de s√©ances de piscine par semaine`, xLabel:`Nombre de s√©ances`, min:0, max:6},
  {intro:`Une plateforme de streaming √©tudie le <strong>nombre de s√©ries diff√©rentes regard√©es dans le mois</strong> par ses abonn√©s.`, varName:`nombre de s√©ries regard√©es dans le mois`, xLabel:`Nombre de s√©ries`, min:0, max:7},
  {intro:`Un lyc√©e √©tudie le <strong>nombre de clubs ou activit√©s p√©riscolaires</strong> auxquels participent les √©l√®ves.`, varName:`nombre de clubs ou activit√©s p√©riscolaires suivis`, xLabel:`Nombre d‚Äôactivit√©s`, min:0, max:5},
  {intro:`Un magasin de sport s‚Äôint√©resse au <strong>nombre de paires de chaussures de sport poss√©d√©es</strong> par ses clients.`, varName:`nombre de paires de chaussures de sport`, xLabel:`Nombre de paires`, min:0, max:6},
  {intro:`Une biblioth√®que scolaire compte le <strong>nombre de fois o√π les √©l√®ves viennent travailler sur place dans le mois</strong>.`, varName:`nombre de visites au CDI dans le mois`, xLabel:`Nombre de visites`, min:0, max:6},
  {intro:`Un coach scolaire rel√®ve le <strong>nombre de s√©ances de r√©vision organis√©es chaque semaine</strong> par ses √©l√®ves.`, varName:`nombre de s√©ances de r√©vision par semaine`, xLabel:`Nombre de s√©ances`, min:0, max:5},
  {intro:`Une association de musique observe le <strong>nombre de concerts assist√©s dans l‚Äôann√©e</strong> par ses adh√©rents.`, varName:`nombre de concerts vus dans l‚Äôann√©e`, xLabel:`Nombre de concerts`, min:0, max:6},
  {intro:`Une √©cole de danse √©tudie le <strong>nombre de cours suivis par semaine</strong> par ses √©l√®ves.`, varName:`nombre de cours de danse par semaine`, xLabel:`Nombre de cours`, min:0, max:5},
  {intro:`Un club de randonn√©e observe le <strong>nombre de sorties effectu√©es dans le trimestre</strong> par ses membres.`, varName:`nombre de sorties de randonn√©e dans le trimestre`, xLabel:`Nombre de sorties`, min:0, max:7}
];

/* 20 contextes qualitatif */
const CTX_QUALI = [
  {intro:`Voici un sondage concernant le <strong>moyen de transport</strong> utilis√© par les √©l√®ves pour venir au lyc√©e.`, varName:`moyen de transport`, categories:['√† pied','en v√©lo','en bus','dans la voiture des parents']},
  {intro:`On interroge une classe sur leur <strong>boisson pr√©f√©r√©e au petit-d√©jeuner</strong>.`, varName:`boisson pr√©f√©r√©e au petit-d√©jeuner`, categories:['lait','caf√©','th√©','jus de fruits']},
  {intro:`Un club sportif demande aux licenci√©s leur <strong>sport pr√©f√©r√© √† pratiquer</strong>.`, varName:`sport pr√©f√©r√©`, categories:['football','basket-ball','tennis','natation']},
  {intro:`Une enqu√™te porte sur le <strong>r√©seau social le plus utilis√©</strong> par les √©l√®ves.`, varName:`r√©seau social le plus utilis√©`, categories:['Instagram','TikTok','Snapchat','Autre']},
  {intro:`On interroge des √©l√®ves sur leur <strong>mati√®re pr√©f√©r√©e</strong> au lyc√©e.`, varName:`mati√®re pr√©f√©r√©e`, categories:['Math√©matiques','Fran√ßais','Histoire-G√©ographie','EPS']},
  {intro:`Une cantine scolaire demande aux √©l√®ves leur <strong>plat pr√©f√©r√©</strong>.`, varName:`plat pr√©f√©r√©`, categories:['p√¢tes','pizza','poisson','salade']},
  {intro:`Une biblioth√®que interroge des lyc√©ens sur leur <strong>type de livre pr√©f√©r√©</strong>.`, varName:`type de livre pr√©f√©r√©`, categories:['roman','manga','BD','documentaire']},
  {intro:`Un sondage porte sur le <strong>mode de logement</strong> des √©l√®ves.`, varName:`mode de logement`, categories:['chez les parents','en internat','en colocation','autre']},
  {intro:`On interroge des √©l√®ves sur leur <strong>activit√© principale apr√®s les cours</strong>.`, varName:`activit√© principale apr√®s les cours`, categories:['devoirs','sport','√©crans','sorties entre amis']},
  {intro:`Une association culturelle demande aux √©l√®ves leur <strong>type de film pr√©f√©r√©</strong>.`, varName:`type de film pr√©f√©r√©`, categories:['com√©die','action','science-fiction','animation']},
  {intro:`On demande aux √©l√®ves leur <strong>animal de compagnie pr√©f√©r√©</strong>.`, varName:`animal de compagnie pr√©f√©r√©`, categories:['chien','chat','rongeur','aucun']},
  {intro:`Un sondage porte sur le <strong>repas pr√©f√©r√© de la journ√©e</strong>.`, varName:`repas pr√©f√©r√© de la journ√©e`, categories:['petit-d√©jeuner','d√©jeuner','go√ªter','d√Æner']},
  {intro:`Une association √©tudie le <strong>type de musique le plus √©cout√©</strong> par les √©l√®ves.`, varName:`type de musique le plus √©cout√©`, categories:['rap','pop','rock','classique']},
  {intro:`On interroge des √©l√®ves sur leur <strong>moment pr√©f√©r√© de la semaine</strong>.`, varName:`moment pr√©f√©r√© de la semaine`, categories:['d√©but de semaine','milieu de semaine','vendredi','week-end']},
  {intro:`Un sondage porte sur la <strong>fa√ßon de r√©viser pr√©f√©r√©e</strong> des √©l√®ves.`, varName:`fa√ßon de r√©viser pr√©f√©r√©e`, categories:['seul','en groupe','avec un professeur','je ne r√©vise pas']},
  {intro:`On demande aux √©l√®ves par quel <strong>moyen de communication</strong> ils contactent le plus leurs amis.`, varName:`moyen de communication principal`, categories:['messages','appels','r√©seaux sociaux','en face √† face']},
  {intro:`Une enqu√™te porte sur la <strong>langue vivante pr√©f√©r√©e</strong> parmi celles √©tudi√©es au lyc√©e.`, varName:`langue vivante pr√©f√©r√©e`, categories:['anglais','espagnol','allemand','autre']},
  {intro:`On interroge des √©l√®ves sur leur <strong>moment pr√©f√©r√© de la journ√©e</strong>.`, varName:`moment pr√©f√©r√© de la journ√©e`, categories:['matin','apr√®s-midi','soir','nuit']},
  {intro:`Une √©tude porte sur le <strong>type de support utilis√© pour lire</strong>.`, varName:`support de lecture pr√©f√©r√©`, categories:['livre papier','tablette','t√©l√©phone','ordinateur']},
  {intro:`On demande √† des lyc√©ens quel est leur <strong>mode de travail pr√©f√©r√© en classe</strong>.`, varName:`mode de travail pr√©f√©r√© en classe`, categories:['seul','en bin√¥me','en petits groupes','en classe enti√®re']},
];

/* 20 contextes quantitatif continu */
const CTX_QCONTINU = [
  {intro:`Le taux de calcium dans le sang d‚Äôun patient (en mg/L) est surveill√© chaque jour pendant deux mois.`, varName:`taux de calcium dans le sang`, unit:`mg/L`, min:70, max:120, step:10},
  {intro:`On mesure chaque jour la <strong>temp√©rature ext√©rieure maximale</strong> (en ¬∞C) pendant un mois d‚Äôhiver.`, varName:`temp√©rature maximale ext√©rieure`, unit:`¬∞C`, min:-5, max:15, step:5},
  {intro:`Un professeur note la <strong>dur√©e de r√©vision quotidienne</strong> (en minutes) d‚Äôun √©l√®ve pendant 6 semaines.`, varName:`dur√©e de r√©vision quotidienne`, unit:`minutes`, min:0, max:180, step:30},
  {intro:`On mesure la <strong>dur√©e d‚Äôappel t√©l√©phonique</strong> (en minutes) de clients dans une journ√©e.`, varName:`dur√©e d‚Äôappel t√©l√©phonique`, unit:`minutes`, min:0, max:30, step:5},
  {intro:`Dans une salle de sport, on rel√®ve la <strong>dur√©e d‚Äôun entra√Ænement</strong> (en minutes) pour plusieurs adh√©rents.`, varName:`dur√©e d‚Äôun entra√Ænement`, unit:`minutes`, min:30, max:120, step:15},
  {intro:`Un laboratoire mesure la <strong>glyc√©mie √† jeun</strong> (en mg/dL) de patients.`, varName:`glyc√©mie √† jeun`, unit:`mg/dL`, min:60, max:140, step:20},
  {intro:`Un radar enregistre la <strong>vitesse de voitures</strong> (en km/h) sur une portion de route limit√©e √† 90 km/h.`, varName:`vitesse de voitures`, unit:`km/h`, min:40, max:120, step:10},
  {intro:`On mesure la <strong>taille d‚Äô√©l√®ves</strong> (en cm) d‚Äôune classe de seconde.`, varName:`taille des √©l√®ves`, unit:`cm`, min:140, max:200, step:10},
  {intro:`Un √©leveur note le <strong>poids de lapins</strong> (en kg) dans son √©levage.`, varName:`poids de lapins`, unit:`kg`, min:1, max:6, step:1},
  {intro:`Une station m√©t√©o mesure la <strong>quantit√© de pluie tomb√©e</strong> (en mm) chaque jour pendant 2 mois.`, varName:`quantit√© de pluie tomb√©e`, unit:`mm`, min:0, max:50, step:10},
  {intro:`On mesure la <strong>dur√©e de trajet domicile‚Äìlyc√©e</strong> (en minutes) d‚Äô√©l√®ves.`, varName:`dur√©e du trajet domicile‚Äìlyc√©e`, unit:`minutes`, min:0, max:60, step:10},
  {intro:`Un cardiologue rel√®ve la <strong>fr√©quence cardiaque au repos</strong> (en battements par minute) de patients.`, varName:`fr√©quence cardiaque au repos`, unit:`bpm`, min:40, max:100, step:10},
  {intro:`Un fabricant mesure la <strong>masse de barres de chocolat</strong> (en g).`, varName:`masse de barres de chocolat`, unit:`g`, min:80, max:140, step:10},
  {intro:`On mesure la <strong>consommation √©lectrique quotidienne</strong> d‚Äôun logement (en kWh) sur deux mois.`, varName:`consommation √©lectrique quotidienne`, unit:`kWh`, min:4, max:16, step:2},
  {intro:`Une compagnie a√©rienne rel√®ve le <strong>poids des bagages en soute</strong> (en kg) sur un vol.`, varName:`poids des bagages en soute`, unit:`kg`, min:5, max:30, step:5},
  {intro:`On mesure la <strong>dur√©e de visionnage de vid√©os</strong> (en minutes) sur une plateforme en ligne.`, varName:`dur√©e de visionnage d‚Äôune vid√©o`, unit:`minutes`, min:0, max:50, step:10},
  {intro:`Un m√©decin suit la <strong>temp√©rature d‚Äôun patient</strong> (en ¬∞C) toutes les 6 heures.`, varName:`temp√©rature du patient`, unit:`¬∞C`, min:35, max:41, step:1},
  {intro:`Une entreprise mesure le <strong>temps de traitement</strong> (en secondes) d‚Äôun programme informatique.`, varName:`temps de traitement d‚Äôun programme`, unit:`secondes`, min:0, max:10, step:2},
  {intro:`On mesure la <strong>distance parcourue lors d‚Äôun footing</strong> (en km) pour plusieurs personnes.`, varName:`distance parcourue lors d‚Äôun footing`, unit:`km`, min:0, max:20, step:4},
  {intro:`Une √©tude note le <strong>temps pass√© chaque jour sur les √©crans</strong> (en heures) par des lyc√©ens.`, varName:`temps pass√© sur les √©crans par jour`, unit:`heures`, min:0, max:8, step:1}
];

/* 20 contextes : moyenne d'une liste de valeurs */
const CTX_MOY_LIST = [
  {intro:`On rel√®ve la <strong>dur√©e (en minutes)</strong> de r√©vision en math√©matiques d‚Äôun √©l√®ve chaque soir pendant une semaine.`, varName:`dur√©e de r√©vision en math√©matiques (en minutes)`, min:10, max:80},
  {intro:`Un sportif note la <strong>distance (en km)</strong> de ses footing sur plusieurs sorties.`, varName:`distance d‚Äôun footing (en km)`, min:2, max:15},
  {intro:`Une enseignante note la <strong>note (sur 20)</strong> obtenue par un √©l√®ve √† plusieurs √©valuations.`, varName:`note obtenue (sur 20)`, min:5, max:20},
  {intro:`On mesure la <strong>dur√©e (en minutes)</strong> des trajets domicile‚Äìlyc√©e d‚Äôun √©l√®ve sur plusieurs jours.`, varName:`dur√©e du trajet domicile‚Äìlyc√©e (en minutes)`, min:5, max:60},
  {intro:`Un joueur de jeux vid√©o note le <strong>temps pass√© (en minutes)</strong> chaque jour sur sa console pendant une semaine.`, varName:`temps pass√© sur la console (en minutes)`, min:10, max:180},
  {intro:`On rel√®ve la <strong>temp√©rature (en ¬∞C)</strong> dans la chambre d‚Äôun √©l√®ve √† diff√©rentes heures de la journ√©e.`, varName:`temp√©rature de la chambre (en ¬∞C)`, min:16, max:26},
  {intro:`Une √©l√®ve note la <strong>dur√©e (en minutes)</strong> de ses s√©ances de sport sur plusieurs jours.`, varName:`dur√©e d‚Äôune s√©ance de sport (en minutes)`, min:20, max:120},
  {intro:`On mesure la <strong>masse (en kg)</strong> de plusieurs sacs de courses au retour du supermarch√©.`, varName:`masse d‚Äôun sac de courses (en kg)`, min:2, max:20},
  {intro:`Un professeur rel√®ve le <strong>nombre de messages envoy√©s</strong> chaque jour par un √©l√®ve pendant une semaine.`, varName:`nombre de messages envoy√©s par jour`, min:10, max:200},
  {intro:`On note la <strong>dur√©e (en minutes)</strong> de plusieurs appels t√©l√©phoniques pass√©s par une personne.`, varName:`dur√©e d‚Äôun appel t√©l√©phonique (en minutes)`, min:1, max:40},
  {intro:`Une salle de sport mesure le <strong>nombre de personnes pr√©sentes</strong> √† diff√©rents cr√©neaux horaires.`, varName:`nombre de personnes pr√©sentes`, min:3, max:30},
  {intro:`On rel√®ve la <strong>taille (en cm)</strong> de plusieurs plantes d‚Äôune exp√©rience.`, varName:`taille d‚Äôune plante (en cm)`, min:10, max:80},
  {intro:`Un √©l√®ve note le <strong>temps pass√© (en minutes)</strong> √† faire ses devoirs chaque jour sur une semaine.`, varName:`temps pass√© √† faire les devoirs (en minutes)`, min:15, max:150},
  {intro:`On mesure la <strong>distance (en km)</strong> parcourue chaque jour par un livreur pendant plusieurs jours.`, varName:`distance parcourue (en km)`, min:5, max:60},
  {intro:`Une association rel√®ve le <strong>montant (en ‚Ç¨)</strong> de plusieurs dons effectu√©s lors d‚Äôune collecte.`, varName:`montant d‚Äôun don (en euros)`, min:5, max:100},
  {intro:`On note le <strong>nombre de pages lues</strong> chaque jour par un √©l√®ve pendant les vacances.`, varName:`nombre de pages lues par jour`, min:5, max:80},
  {intro:`Une station-service mesure le <strong>nombre de litres d‚Äôessence</strong> achet√©s par diff√©rents clients.`, varName:`nombre de litres d‚Äôessence achet√©s`, min:10, max:70},
  {intro:`On rel√®ve la <strong>dur√©e (en minutes)</strong> de plusieurs √©pisodes d‚Äôune s√©rie regard√©s par un √©l√®ve.`, varName:`dur√©e d‚Äôun √©pisode (en minutes)`, min:20, max:60},
  {intro:`Un club de natation note le <strong>temps (en secondes)</strong> mis par un nageur pour parcourir une distance fixe lors de plusieurs essais.`, varName:`temps pour parcourir la distance (en secondes)`, min:30, max:120},
  {intro:`On mesure la <strong>hauteur (en cm)</strong> de plusieurs sauts en longueur r√©alis√©s √† l‚Äôentra√Ænement.`, varName:`longueur d‚Äôun saut (en cm)`, min:250, max:600}
];

/* 20 contextes : comparaison de deux s√©ries (quantitatif discret) */
/* Ici l'effectif = nombre de matchs / jours / √©l√®ves, etc.       */
const CTX_COMP_QDISCRET = [
  {
    intro:`On suit pendant une saison le <strong>nombre de buts marqu√©s par match</strong> par deux √©quipes de handball, not√©es A et B. Pour chaque valeur possible, on a compt√© le nombre de matchs correspondants.`,
    varName:`nombre de buts marqu√©s par match`,
    min:10,max:40
  },
  {
    intro:`On observe pendant plusieurs semaines le <strong>nombre de minutes de r√©vision en math√©matiques par jour</strong> pour deux classes A et B. Le tableau donne, pour chaque dur√©e, le nombre de jours correspondants.`,
    varName:`nombre de minutes de r√©vision par jour`,
    min:0,max:120
  },
  {
    intro:`On mesure sur un trimestre le <strong>nombre de pages lues chaque soir</strong> par les √©l√®ves d‚Äôun groupe A et d‚Äôun groupe B. Le tableau donne, pour chaque nombre de pages, le nombre de soirs correspondants.`,
    varName:`nombre de pages lues par soir`,
    min:0,max:60
  },
  {
    intro:`On suit pendant un mois le <strong>nombre de messages envoy√©s par jour</strong> sur un r√©seau social par deux √©l√®ves A et B. Le tableau donne, pour chaque nombre de messages, le nombre de jours correspondants.`,
    varName:`nombre de messages envoy√©s par jour`,
    min:0,max:150
  },
  {
    intro:`On observe pendant plusieurs semaines le <strong>nombre de minutes pass√©es chaque jour devant les √©crans</strong> pour deux groupes d‚Äô√©l√®ves A et B. Le tableau donne, pour chaque dur√©e, le nombre de jours correspondants.`,
    varName:`nombre de minutes d‚Äô√©cran par jour`,
    min:0,max:360
  },
  {
    intro:`Lors d‚Äôentra√Ænements de basket, on note le <strong>nombre de paniers marqu√©s sur une s√©rie de 20 tirs</strong> par les joueurs de deux √©quipes A et B. Le tableau donne, pour chaque r√©sultat possible, le nombre de joueurs correspondants.`,
    varName:`nombre de paniers marqu√©s sur 20 tirs`,
    min:0,max:20
  },
  {
    intro:`On suit pendant plusieurs semaines le <strong>nombre d‚Äôexercices de math√©matiques faits chaque jour</strong> par les √©l√®ves de deux classes A et B. Le tableau donne, pour chaque nombre d‚Äôexercices, le nombre de jours correspondants.`,
    varName:`nombre d‚Äôexercices faits par jour`,
    min:0,max:25
  },
  {
    intro:`On mesure sur un trimestre le <strong>nombre de fautes d‚Äôorthographe par dict√©e</strong> pour les √©l√®ves de deux classes A et B. Le tableau donne, pour chaque nombre de fautes, le nombre d‚Äô√©l√®ves correspondants.`,
    varName:`nombre de fautes par dict√©e`,
    min:0,max:15
  },
  {
    intro:`On suit pendant un mois le <strong>nombre de trajets en transports en commun par jour</strong> effectu√©s par les √©l√®ves de deux lyc√©es A et B. Le tableau donne, pour chaque nombre de trajets, le nombre de jours correspondants.`,
    varName:`nombre de trajets en transports en commun par jour`,
    min:0,max:10
  },
  {
    intro:`On √©tudie, sur une s√©rie de contr√¥les, le <strong>nombre de points sur 20</strong> obtenus par les √©l√®ves de deux classes A et B. Le tableau donne, pour chaque note enti√®re, le nombre de copies correspondantes.`,
    varName:`note sur 20`,
    min:0,max:20
  },
  {
    intro:`On observe pendant plusieurs jours le <strong>nombre de clients servis par heure</strong> dans deux caisses A et B d‚Äôune m√™me sup√©rette. Le tableau donne, pour chaque nombre de clients, le nombre d‚Äôheures correspondantes.`,
    varName:`nombre de clients servis par heure`,
    min:0,max:40
  },
  {
    intro:`On suit pendant plusieurs jours le <strong>nombre de verres d‚Äôeau bus dans la journ√©e</strong> par les √©l√®ves de deux classes A et B. Le tableau donne, pour chaque nombre de verres, le nombre de jours correspondants.`,
    varName:`nombre de verres d‚Äôeau bus par jour`,
    min:0,max:15
  },
  {
    intro:`On enregistre pendant un mois le <strong>nombre d‚Äôappels t√©l√©phoniques re√ßus chaque jour</strong> par deux services A et B. Le tableau donne, pour chaque nombre d‚Äôappels, le nombre de jours correspondants.`,
    varName:`nombre d‚Äôappels re√ßus par jour`,
    min:0,max:80
  },
  {
    intro:`On √©tudie pendant plusieurs semaines le <strong>nombre de kilom√®tres parcourus chaque jour</strong> par deux groupes de coureurs A et B. Le tableau donne, pour chaque distance (arrondie au km), le nombre de jours correspondants.`,
    varName:`nombre de kilom√®tres parcourus par jour`,
    min:0,max:20
  },
  {
    intro:`On suit pendant un trimestre le <strong>nombre d‚Äôabsences par √©l√®ve</strong> dans deux classes A et B. Le tableau donne, pour chaque nombre d‚Äôabsences, le nombre d‚Äô√©l√®ves correspondants.`,
    varName:`nombre d‚Äôabsences par √©l√®ve`,
    min:0,max:15
  },
  {
    intro:`On observe pendant plusieurs semaines le <strong>nombre de minutes de sommeil de sieste</strong> prises par les √©l√®ves de deux groupes A et B. Le tableau donne, pour chaque dur√©e, le nombre de jours correspondants.`,
    varName:`dur√©e de la sieste (en minutes)`,
    min:0,max:90
  },
  {
    intro:`On √©tudie le <strong>nombre de questions correctement r√©pondues</strong> lors d‚Äôun quiz de 20 questions pour deux classes A et B. Le tableau donne, pour chaque score possible, le nombre d‚Äô√©l√®ves correspondants.`,
    varName:`nombre de bonnes r√©ponses sur 20`,
    min:0,max:20
  },
  {
    intro:`On suit pendant plusieurs semaines le <strong>nombre de trajets effectu√©s √† v√©lo par jour</strong> par deux √©l√®ves A et B. Le tableau donne, pour chaque nombre de trajets, le nombre de jours correspondants.`,
    varName:`nombre de trajets √† v√©lo par jour`,
    min:0,max:8
  },
  {
    intro:`On observe le <strong>nombre d‚Äôexercices de sport r√©alis√©s √† la maison par jour</strong> par deux groupes d‚Äô√©l√®ves A et B. Le tableau donne, pour chaque nombre d‚Äôexercices, le nombre de jours correspondants.`,
    varName:`nombre d‚Äôexercices de sport par jour`,
    min:0,max:25
  },
  {
    intro:`On mesure le <strong>nombre de minutes d‚Äôattente √† la cantine</strong> pour les √©l√®ves de deux classes A et B sur plusieurs jours. Le tableau donne, pour chaque dur√©e (arrondie √† la minute), le nombre d‚Äô√©l√®ves correspondants.`,
    varName:`dur√©e d‚Äôattente √† la cantine (en minutes)`,
    min:0,max:30
  }
];

/* 20 contextes : comparaison de deux s√©ries (quantitatif continu) */
/* Effectif = nombre de jours / √©l√®ves / mesures dans chaque classe. */
const CTX_COMP_QCONTINU = [
  {
    intro:`On mesure pendant un mois la <strong>dur√©e d‚Äôensoleillement quotidien</strong> (en heures) dans deux villes A et B. Les dur√©es sont regroup√©es en classes, et le tableau donne pour chaque classe le nombre de jours correspondants.`,
    varName:`dur√©e d‚Äôensoleillement quotidien`,
    unit:`h`,
    a0:0,width:2
  },
  {
    intro:`On enregistre pendant un mois la <strong>dur√©e du trajet domicile‚Äìlyc√©e</strong> (en minutes) pour les √©l√®ves de deux classes A et B. Les dur√©es sont regroup√©es en classes, et le tableau donne pour chaque classe le nombre de trajets correspondants.`,
    varName:`dur√©e du trajet domicile‚Äìlyc√©e`,
    unit:`min`,
    a0:0,width:10
  },
  {
    intro:`On mesure pendant plusieurs semaines le <strong>temps pass√© chaque jour sur les √©crans</strong> (en heures) par les √©l√®ves de deux classes A et B. Les temps sont regroup√©s en classes, et le tableau donne le nombre de jours correspondants.`,
    varName:`temps pass√© sur les √©crans par jour`,
    unit:`h`,
    a0:0,width:1
  },
  {
    intro:`On observe pendant une p√©riode de r√©vision la <strong>dur√©e quotidienne de r√©vision</strong> (en minutes) de deux groupes d‚Äô√©l√®ves A et B. Les dur√©es sont regroup√©es en classes, et le tableau donne pour chaque classe le nombre de jours correspondants.`,
    varName:`dur√©e quotidienne de r√©vision`,
    unit:`min`,
    a0:0,width:20
  },
  {
    intro:`On mesure la <strong>dur√©e d‚Äôun entra√Ænement sportif</strong> (en minutes) dans deux clubs A et B pour plusieurs s√©ances. Les dur√©es sont regroup√©es en classes, et le tableau donne le nombre de s√©ances correspondantes.`,
    varName:`dur√©e d‚Äôun entra√Ænement`,
    unit:`min`,
    a0:30,width:15
  },
  {
    intro:`On mesure la <strong>vitesse moyenne</strong> (en km/h) de coureurs appartenant √† deux clubs A et B lors d‚Äôune m√™me √©preuve. Les vitesses sont regroup√©es en classes, et le tableau donne le nombre de coureurs correspondants.`,
    varName:`vitesse moyenne de course`,
    unit:`km/h`,
    a0:6,width:2
  },
  {
    intro:`On mesure la <strong>taille (en cm)</strong> d‚Äô√©l√®ves de deux classes A et B. Les tailles sont regroup√©es en classes, et le tableau donne le nombre d‚Äô√©l√®ves correspondants.`,
    varName:`taille des √©l√®ves`,
    unit:`cm`,
    a0:140,width:5
  },
  {
    intro:`On mesure la <strong>masse (en kg)</strong> de bagages enregistr√©s par des passagers de deux vols A et B. Les masses sont regroup√©es en classes, et le tableau donne le nombre de bagages correspondants.`,
    varName:`masse des bagages`,
    unit:`kg`,
    a0:5,width:5
  },
  {
    intro:`On note la <strong>dur√©e de sommeil par nuit</strong> (en heures) pour les √©l√®ves de deux classes A et B pendant plusieurs jours. Les dur√©es sont regroup√©es en classes, et le tableau donne le nombre de nuits correspondantes.`,
    varName:`dur√©e de sommeil par nuit`,
    unit:`h`,
    a0:4,width:1
  },
  {
    intro:`On mesure la <strong>quantit√© de pluie tomb√©e</strong> (en mm) chaque jour dans deux villes A et B sur un m√™me mois. Les quantit√©s sont regroup√©es en classes, et le tableau donne le nombre de jours correspondants.`,
    varName:`quantit√© de pluie tomb√©e`,
    unit:`mm`,
    a0:0,width:10
  },
  {
    intro:`On observe la <strong>dur√©e d‚Äôun appel t√©l√©phonique</strong> (en minutes) dans deux centres d‚Äôappel A et B. Les dur√©es sont regroup√©es en classes, et le tableau donne le nombre d‚Äôappels correspondants.`,
    varName:`dur√©e d‚Äôun appel t√©l√©phonique`,
    unit:`min`,
    a0:0,width:5
  },
  {
    intro:`On mesure la <strong>distance parcourue lors d‚Äôun footing</strong> (en km) pour des coureurs appartenant √† deux groupes A et B. Les distances sont regroup√©es en classes, et le tableau donne le nombre de footings correspondants.`,
    varName:`distance parcourue lors d‚Äôun footing`,
    unit:`km`,
    a0:0,width:2
  },
  {
    intro:`On mesure la <strong>temp√©rature ext√©rieure √† midi</strong> (en ¬∞C) dans deux villes A et B pendant plusieurs jours d‚Äôhiver. Les temp√©ratures sont regroup√©es en classes, et le tableau donne le nombre de jours correspondants.`,
    varName:`temp√©rature ext√©rieure √† midi`,
    unit:`¬∞C`,
    a0:-5,width:5
  },
  {
    intro:`On mesure la <strong>dur√©e de visionnage de vid√©os</strong> (en minutes par jour) pour deux groupes d‚Äô√©l√®ves A et B. Les dur√©es sont regroup√©es en classes, et le tableau donne le nombre de jours correspondants.`,
    varName:`dur√©e de visionnage de vid√©os par jour`,
    unit:`min`,
    a0:0,width:15
  },
  {
    intro:`On mesure la <strong>consommation √©lectrique quotidienne</strong> (en kWh) de deux logements A et B sur un mois. Les consommations sont regroup√©es en classes, et le tableau donne le nombre de jours correspondants.`,
    varName:`consommation √©lectrique quotidienne`,
    unit:`kWh`,
    a0:4,width:2
  },
  {
    intro:`On mesure le <strong>temps mis pour r√©soudre un exercice</strong> (en minutes) par les √©l√®ves de deux classes A et B. Les temps sont regroup√©s en classes, et le tableau donne le nombre d‚Äô√©l√®ves correspondants.`,
    varName:`temps pour r√©soudre l‚Äôexercice`,
    unit:`min`,
    a0:0,width:5
  },
  {
    intro:`On mesure la <strong>longueur de sauts en longueur</strong> (en cm) pour deux athl√®tes A et B sur plusieurs essais. Les longueurs sont regroup√©es en classes, et le tableau donne le nombre de sauts correspondants.`,
    varName:`longueur de saut en longueur`,
    unit:`cm`,
    a0:400,width:20
  },
  {
    intro:`On observe la <strong>dur√©e d‚Äôun trajet en train</strong> (en minutes) entre deux villes, pour deux lignes A et B, sur plusieurs jours. Les dur√©es sont regroup√©es en classes, et le tableau donne le nombre de trajets correspondants.`,
    varName:`dur√©e du trajet en train`,
    unit:`min`,
    a0:40,width:10
  },
  {
    intro:`On mesure la <strong>temp√©rature d‚Äôune salle de classe</strong> (en ¬∞C) dans deux b√¢timents A et B √† diff√©rents moments de la journ√©e. Les temp√©ratures sont regroup√©es en classes, et le tableau donne le nombre de mesures correspondantes.`,
    varName:`temp√©rature de la salle`,
    unit:`¬∞C`,
    a0:15,width:2
  },
  {
    intro:`On observe la <strong>dur√©e quotidienne de pratique musicale</strong> (en minutes) pour des √©l√®ves d‚Äôun groupe A et d‚Äôun groupe B. Les dur√©es sont regroup√©es en classes, et le tableau donne le nombre de jours correspondants.`,
    varName:`dur√©e quotidienne de pratique musicale`,
    unit:`min`,
    a0:0,width:15
  }
];



/* ====== G√©n√©ration de tableaux fr√©quences/FCC ====== */
function pickInnerIndex(n){
  const cand = [];
  for(let i=0;i<n;i++){
    if(i>=2 && i<=n-3) cand.push(i);
  }
  if(cand.length) return choice(cand);

  const cand2 = [];
  for(let i=1;i<=n-2;i++) cand2.push(i);
  if(cand2.length) return choice(cand2);

  return 0;
}

function genEffectifsFromMinMax(minVal,maxVal,mode){
  const values=[];
  for(let v=minVal; v<=maxVal; v++) values.push(v);
  const n = values.length;

  let eff = [];
  let tot = 0;

  if(mode === 'calc'){
    const r = genCalcEffectifs(n);
    eff = r.eff;
    tot = r.total;
  }else{
    for(let i=0;i<n;i++){
      const e = rint(5,80);
      eff.push(e); tot+=e;
    }
  }
  return {values, eff, total:tot};
}

function genEffectifsFromLabels(labels,mode){
  const n = labels.length;
  let eff = [];
  let tot = 0;

  if(mode === 'calc'){
    const r = genCalcEffectifs(n);
    eff = r.eff;
    tot = r.total;
  }else{
    for(let i=0;i<n;i++){
      const e = rint(5,60);
      eff.push(e); tot+=e;
    }
  }
  return {eff, total:tot};
}

function genFreqAndFCC(eff,total){
  const n = eff.length;
  const freqRaw = eff.map(e=>e/total);
  const freq = new Array(n);
  let sum = 0;
  for(let i=0;i<n;i++){
    if(i<n-1){
      const r = Math.round(freqRaw[i]*100)/100;
      freq[i]=r;
      sum+=r;
    }else{
      freq[i] = Math.round((1-sum)*100)/100;
    }
  }
  const fcc = new Array(n);
  let c = 0;
  for(let i=0;i<n;i++){
    c += freq[i];
    if(i<n-1) fcc[i] = Math.round(c*100)/100;
    else fcc[i] = 1;
  }
  return {freq,fcc};
}


/* ====== Exercice 4 : moyenne d'une liste de nombres ====== */
const ex4 = {
  id:'stat_moyenne_liste',
  title:'Moyenne d‚Äôune liste de valeurs',
  gen(){
    const ctx = choice(CTX_MOY_LIST);

    // longueur de la liste (entre 5 et 8 valeurs)
    const n = rint(5,8);

    const values = [];
    for(let i=0;i<n;i++){
      values.push(rint(ctx.min, ctx.max));   // valeurs non tri√©es
    }

    const sum  = values.reduce((a,b)=>a+b,0);
    const mean = sum / n;

    return {
      kind:'moy_list',
      ctx,
      values,
      sum,
      mean
    };
  },
  render(host,st){
    const ctx = st.ctx;

    host.innerHTML = `
      <p>${ctx.intro}</p>

      <p>On a relev√© les valeurs suivantes (dans le d√©sordre)&nbsp;:</p>
      <p><strong>${st.values.join(';&nbsp; ')}</strong></p>

      <div class="q-block">
        <p><strong>Calculer la moyenne de <em>${ctx.varName}</em> (au centi√®me pr√®s).</strong></p>
        <p>Moyenne : <input type="text" id="q4-moy"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
  },
  correct(host,st){
    let ok = 0, tot = 0;

    const moyInp = $('#q4-moy',host);
    if(moyInp){
      const s = moyInp.value.trim();
      if(!s){
        setTick(moyInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v, st.mean)){   // tol√©rance 10^-2
          ok++; setTick(moyInp,'ok');
        }else{
          setTick(moyInp,'ko');
        }
      }
    }

    return {ok,total:tot};
  },
  solution(host,st){
    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML = html);
    typeset(host);
  },

  printSolutionHTML(st){
    const n     = st.values.length;
    const sum   = st.sum;
    const terms = st.values.join(' + ');
    const decMoy   = fmtFreq(st.mean);          // 2 d√©cimales avec virgule
    const exactMoy = isExactRatio(sum, n);
    const signMoy  = exactMoy ? '=' : '\\approx';

    return `
      <div class="step"><strong>Calcul de la moyenne :</strong><br>
      On calcule la moyenne des ${n} valeurs :<br>
      \\[
        \\overline{x}
        = \\dfrac{${terms}}{${n}}
        = \\dfrac{${sum}}{${n}}
        ${signMoy} ${decMoy}
      \\]
      </div>
    `;
  },

  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};




/* ====== Exercice 1 : quantitatif discret ====== */
const ex1 = {
  id:'stat_qdiscret',
  title:'Caract√®re quantitatif discret',
    gen(){
    const ctx = choice(CTX_QDISCRET);
    const freqMode = getFreqModeFor(this.id);    // 'arrondi' ou 'calc'
    const base = genEffectifsFromMinMax(ctx.min, ctx.max, freqMode);
    const ff  = genFreqAndFCC(base.eff, base.total);
    const n = base.values.length;

    const idxFreq = pickInnerIndex(n);
    const idxFCC  = pickInnerIndex(n);

    // ‚¨áÔ∏è NOUVEAU : calcul de la moyenne
    let sumXE = 0;
    for(let i=0;i<n;i++){
      sumXE += base.values[i] * base.eff[i];
    }
    const mean = sumXE / base.total;

    return {
      kind:'qdiscret',
      ctx,
      values: base.values,
      eff: base.eff,
      total: base.total,
      freq: ff.freq,
      fcc: ff.fcc,
      qFreqIndex: idxFreq,
      qFCCIndex: idxFCC,
      freqMode,
      mean   // ‚¨ÖÔ∏è stock√© dans l‚Äô√©tat
    };
  },
  render(host,st){
    const ctx = st.ctx;
    const n = st.values.length;
    let thVals = '';
    let tdEff  = '';
    let tdFreq = '';
    let tdFCC  = '';
    for(let i=0;i<n;i++){
      thVals += `<th>${st.values[i]}</th>`;
      tdEff  += `<td>${st.eff[i]}</td>`;
      tdFreq += `<td><input type="text" data-role="freq" data-i="${i}"></td>`;
      tdFCC  += `<td><input type="text" data-role="fcc" data-i="${i}"></td>`;
    }
    thVals += `<th>Total</th>`;
    tdEff  += `<td><input type="text" data-role="effTot"></td>`;
    tdFreq += `<td><input type="text" data-role="freqTot"></td>`;
    tdFCC  += `<td class="fcc-total"></td>`;

    const vFreq = st.values[st.qFreqIndex];
    const vFCC  = st.values[st.qFCCIndex];

    host.innerHTML = `

      <p class="screen-only" style="margin:.3rem 0 .6rem 0">
        <label><strong>Mode de fr√©quences :</strong>
          <select data-freq-mode>
            <option value="arrondi">Fr√©quences arrondies</option>
            <option value="calc">Fr√©quences calculables</option>
          </select>
        </label>
      </p>

      <p>${ctx.intro}</p>

      <table class="tbl-solution pdfb">
        <thead>
          <tr>
            <th>${ctx.xLabel}</th>
            ${thVals}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Effectif</td>
            ${tdEff}
          </tr>
          <tr>
            <td>Fr√©quence</td>
            ${tdFreq}
          </tr>
          <tr>
            <td>FCC</td>
            ${tdFCC}
          </tr>
        </tbody>
      </table>

      <div class="q-block">
        <p><strong>1.</strong> Donner la population √©tudi√©e, le caract√®re √©tudi√© ainsi que son type (quantitatif discret, quantitatif continu ou qualitatif).</p>
        <p>Population √©tudi√©e : <input type="text" id="q1-pop"></p>
        <p>Caract√®re √©tudi√© : <input type="text" id="q1-carac"></p>
        <p>Type de caract√®re : <input type="text" id="q1-type"></p>

        <p><strong>2.</strong> Compl√©ter la ligne des fr√©quences (valeurs d√©cimales) puis la ligne des fr√©quences cumul√©es croissantes (FCC).</p>
        <p><strong>3.</strong> Quelle est la fr√©quence des individus pour lesquels le <em>${ctx.varName}</em> est √©gal √† <strong>${vFreq}</strong> ? 
        <input type="text" id="q1-freq"></p>
        <p><strong>4.</strong> D√©terminer la proportion d‚Äôindividus pour lesquels le <em>${ctx.varName}</em> est inf√©rieure ou √©gale √† <strong>${vFCC}</strong>. 
        <input type="text" id="q1-fcc"></p>
        <p><strong>5.</strong> Calculer la moyenne du <em>${ctx.varName}</em> (au centi√®me pr√®s). 
        <input type="text" id="q1-moy"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
    attachFreqModeSelector(host);
  },
  correct(host,st){
    let ok=0, tot=0;

    const popInp = $('#q1-pop',host);
    if(popInp){
      const val = popInp.value.trim();
      if(!val){
        setTick(popInp,'nu');
      }else{
        const good = checkPopulationAnswer(val, st.ctx.intro);
        tot++;
        if(good){ ok++; setTick(popInp,'ok'); } else setTick(popInp,'ko');
      }
    }
// Q1 : caract√®re
const caracInp = $('#q1-carac',host);
if(caracInp){
  const val = caracInp.value.trim();
  if(!val){
    setTick(caracInp,'nu');
  }else{
    // ici on accepte soit le texte "officiel", soit un libell√© plus court du tableau (ctx.xLabel)
    const good = isCaracAnswerOk(val, st.ctx.varName, st.ctx.xLabel);
    tot++;
    if(good){ ok++; setTick(caracInp,'ok'); } else setTick(caracInp,'ko');
  }
}

    const typeInp = $('#q1-type',host);
    if(typeInp){
      const raw = typeInp.value.trim();
      if(!raw){
        setTick(typeInp,'nu');
      }else{
        const norm = normalizeStr(raw);
        const exp = normalizeStr('quantitatif discret');
        tot++;
        if(norm === exp){ ok++; setTick(typeInp,'ok'); } else setTick(typeInp,'ko');
      }
    }

    const n = st.values.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v, st.freq[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });
    const fTotInp = host.querySelector('input[data-role="freqTot"]');
    if(fTotInp){
      const s = fTotInp.value.trim();
      if(!s){
        setTick(fTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,1)){ ok++; setTick(fTotInp,'ok'); } else setTick(fTotInp,'ko');
      }
    }

    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v, st.fcc[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });

    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp){
      const s = effTotInp.value.trim();
      if(!s){
        setTick(effTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,st.total)){ ok++; setTick(effTotInp,'ok'); } else setTick(effTotInp,'ko');
      }
    }

    const q1 = $('#q1-freq',host);
    if(q1){
      const s = q1.value.trim();
      if(!s){
        setTick(q1,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.freq[st.qFreqIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q1,'ok'); } else setTick(q1,'ko');
      }
    }

        const q2 = $('#q1-fcc',host);
    if(q2){
      const s = q2.value.trim();
      if(!s){
        setTick(q2,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.fcc[st.qFCCIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q2,'ok'); } else setTick(q2,'ko');
      }
    }

    // ‚¨áÔ∏è NOUVEAU : question 5 ‚Äì moyenne
    const qM = $('#q1-moy',host);
    if(qM){
      const s = qM.value.trim();
      if(!s){
        setTick(qM,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v, st.mean)){   // tol√©rance 10^-2
          ok++; setTick(qM,'ok');
        }else{
          setTick(qM,'ko');
        }
      }
    }

    return {ok,total:tot};
  },


  solution(host,st){


    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>{ s.innerHTML = html; });
    typeset(host);
  },

printSolutionHTML(st){
  const ctx   = st.ctx;
  const n     = st.values.length;
  const vFreq = st.values[st.qFreqIndex];
  const vFCC  = st.values[st.qFCCIndex];

  const popSol   = getPopulationLabel(st.ctx.intro);
  const caracSol = st.ctx.varName;
  const typeSol  = 'quantitatif discret';

  const isCalc = st.freqMode === 'calc';

  // --- bloc "calcul des fr√©quences" ---
  const expFreq = st.values.map((v,i)=>{
    const dec  = fmtFreq(st.freq[i]);
    const pct  = Math.round(st.freq[i]*100);
    const exactHere = isCalc || isExactRatio(st.eff[i], st.total);
    const sign = exactHere ? '=' : '\\approx';
    return `\\(f(${v}) =  \\dfrac{${st.eff[i]}}{${st.total}} ${sign} ${dec} \\), soit \\(${pct} \\)%.`;
  });

  // --- Q3/Q4 : d√©cider si c'est exact ou approximatif ---
  const decQ3 = fmtFreq(st.freq[st.qFreqIndex]);
  const pctQ3 = Math.round(st.freq[st.qFreqIndex]*100);

  const exactQ3 = isCalc || isExactRatio(st.eff[st.qFreqIndex], st.total);
  const approxWordQ3 = exactQ3 ? '' : ' environ';

  const decQ4 = fmtFreq(st.fcc[st.qFCCIndex]);
  const pctQ4 = Math.round(st.fcc[st.qFCCIndex]*100);

  const cumEffQ4 = st.eff.slice(0, st.qFCCIndex+1).reduce((a,b)=>a+b,0);
  const exactQ4 = isCalc || isExactRatio(cumEffQ4, st.total);
  const approxWordQ4 = exactQ4 ? '' : ' environ';

  // --- tableau compl√©t√© ---
  let hHead = `<tr><th>${st.ctx.xLabel}</th>`;
  for(let i=0;i<n;i++) hHead += `<th>${st.values[i]}</th>`;
  hHead += `<th>Total</th></tr>`;

  let rowEff  = `<tr><td>Effectif</td>`;
  let rowFreq = `<tr><td>Fr√©quence</td>`;
  let rowFCC  = `<tr><td>FCC</td>`;
  for(let i=0;i<n;i++){
    rowEff  += `<td>${st.eff[i]}</td>`;
    rowFreq += `<td>${fmtFreq(st.freq[i])}</td>`;
    rowFCC  += `<td>${fmtFreq(st.fcc[i])}</td>`;
  }
  rowEff  += `<td>${st.total}</td></tr>`;
  rowFreq += `<td>${fmtFreq(1)}</td></tr>`;
  rowFCC  += `<td class="fcc-total"></td></tr>`;

  const tblHtml = `
    <table class="tbl-solution pdfb">
      <thead>${hHead}</thead>
      <tbody>${rowEff}${rowFreq}${rowFCC}</tbody>
    </table>
  `;

  // --- moyenne ---
  const numMoy = st.values.reduce((S,x,i)=>S + x*st.eff[i], 0);
  const termsMoy = st.values.map((x,i)=>`${x}\\times ${st.eff[i]}`).join(' + ');
  const decMoy = fmtFreq(numMoy / st.total);
  const exactMoy = isExactRatio(numMoy, st.total);
  const signMoy = exactMoy ? '=' : '\\approx';


    return `
    <div class="step"><strong>R√©ponse √† la question 1 :</strong><br>
    Population √©tudi√©e : ${popSol}.<br>
    Caract√®re √©tudi√© : ${caracSol}.<br>
    Type : ${typeSol}.</div>

    <div class="step"><strong>Calcul des fr√©quences :</strong></div>
    <div class="step">${expFreq.join('<br>')}</div>

    <div class="step"><strong>R√©ponse √† la question 2 :</strong><br>
    On obtient le tableau compl√©t√© suivant :</div>
    <div class="step">${tblHtml}</div>

    <div class="step"><strong>R√©ponse √† la question 3 :</strong><br>
    La fr√©quence des individus pour lesquels le <em>${ctx.varName}</em> est √©gal √† <strong>${vFreq}</strong> vaut \\(${decQ3}\\), soit${approxWordQ3} \\(${pctQ3} \\) %.</div>

    <div class="step"><strong>R√©ponse √† la question 4 :</strong><br>
    La proportion d‚Äôindividus pour lesquels le <em>${ctx.varName}</em> est inf√©rieure ou √©gale √† <strong>${vFCC}</strong> vaut \\(${decQ4}\\), soit${approxWordQ4} \\(${pctQ4}\\) %.</div>

    <div class="step"><strong>R√©ponse √† la question 5 :</strong><br>
    La moyenne du caract√®re est donn√©e par :<br>
    \\[
      \\overline{x}
      = \\dfrac{${termsMoy}}{${st.total}}
      ${signMoy} ${decMoy}
    \\]
    </div>
  `;
},




  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};


/* ====== Exercice 2 : qualitatif ====== */
const ex2 = {
  id:'stat_qualitatif',
  title:'Caract√®re qualitatif',
  gen(){
    const ctx = choice(CTX_QUALI);
    const freqMode = getFreqModeFor(this.id);
    const effData = genEffectifsFromLabels(ctx.categories, freqMode);
    const ff = genFreqAndFCC(effData.eff, effData.total);
    const n = ctx.categories.length;

    const idxFreq = pickInnerIndex(n);
    const idxFCC  = pickInnerIndex(n);

    return {
      kind:'qualitatif',
      ctx,
      categories: ctx.categories,
      eff: effData.eff,
      total: effData.total,
      freq: ff.freq,
      fcc: ff.fcc,
      qFreqIndex: idxFreq,
      qFCCIndex: idxFCC,
      freqMode
    };
  },
  render(host,st){
    const ctx = st.ctx;
    const n = st.categories.length;
    let thVals='', tdEff='', tdFreq='', tdFCC='';
    for(let i=0;i<n;i++){
      thVals += `<th>${st.categories[i]}</th>`;
      tdEff  += `<td>${st.eff[i]}</td>`;
      tdFreq += `<td><input type="text" data-role="freq" data-i="${i}"></td>`;
      tdFCC  += `<td><input type="text" data-role="fcc" data-i="${i}"></td>`;
    }
    thVals += `<th>Total</th>`;
    tdEff  += `<td><input type="text" data-role="effTot"></td>`;
    tdFreq += `<td><input type="text" data-role="freqTot"></td>`;
    tdFCC  += `<td class="fcc-total"></td>`;

    const cFreq = st.categories[st.qFreqIndex];
    const upTo  = st.categories.slice(0, st.qFCCIndex+1);

    host.innerHTML = `

      <p class="screen-only" style="margin:.3rem 0 .6rem 0">
        <label><strong>Mode de fr√©quences :</strong>
          <select data-freq-mode>
            <option value="arrondi">Fr√©quences arrondies</option>
            <option value="calc">Fr√©quences calculables</option>
          </select>
        </label>
      </p>

      <p>${ctx.intro}</p>

      <table class="tbl-solution pdfb">
        <thead>
          <tr>
            <th>${ctx.varName}</th>
            ${thVals}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Effectif</td>
            ${tdEff}
          </tr>
          <tr>
            <td>Fr√©quence</td>
            ${tdFreq}
          </tr>
          <tr>
            <td>FCC</td>
            ${tdFCC}
          </tr>
        </tbody>
      </table>

      <div class="q-block">
        <p><strong>1.</strong> Donner la population √©tudi√©e, le caract√®re √©tudi√© ainsi que son type (quantitatif discret, quantitatif continu ou qualitatif).</p>
        <p>Population √©tudi√©e : <input type="text" id="q1-pop"></p>
        <p>Caract√®re √©tudi√© : <input type="text" id="q1-carac"></p>
        <p>Type de caract√®re : <input type="text" id="q1-type"></p>

        <p><strong>2.</strong> Compl√©ter la ligne des fr√©quences puis la ligne des fr√©quences cumul√©es croissantes (FCC).</p>
        <p><strong>3.</strong> Quelle est la fr√©quence des individus dont le <em>${ctx.varName}</em> est <strong>${cFreq}</strong> ? 
        <input type="text" id="q2-freq"></p>
        <p><strong>4.</strong> D√©terminer la fr√©quence des individus dont le <em>${ctx.varName}</em> appartient √† l‚Äôun des cas suivants : <strong>${upTo.join(', ')}</strong>. 
        <input type="text" id="q2-fcc"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
    attachFreqModeSelector(host);
  },
  correct(host,st){
    let ok=0, tot=0;

    const popInp = $('#q1-pop',host);
    if(popInp){
      const val = popInp.value.trim();
      if(!val){
        setTick(popInp,'nu');
      }else{
        const good = checkPopulationAnswer(val, st.ctx.intro);
        tot++;
        if(good){ ok++; setTick(popInp,'ok'); } else setTick(popInp,'ko');
      }
    }
// Q1 caract√®re
const caracInp = $('#q1-carac',host);
if(caracInp){
  const val = caracInp.value.trim();
  if(!val){
    setTick(caracInp,'nu');
  }else{
    const good = isCaracAnswerOk(val, st.ctx.varName, st.ctx.varName);
    tot++;
    if(good){ ok++; setTick(caracInp,'ok'); } else setTick(caracInp,'ko');
  }
}

    const typeInp = $('#q1-type',host);
    if(typeInp){
      const raw = typeInp.value.trim();
      if(!raw){
        setTick(typeInp,'nu');
      }else{
        const norm = normalizeStr(raw);
        const exp = normalizeStr('qualitatif');
        tot++;
        if(norm === exp){ ok++; setTick(typeInp,'ok'); } else setTick(typeInp,'ko');
      }
    }

    const n = st.categories.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.freq[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });
    const fTot = host.querySelector('input[data-role="freqTot"]');
    if(fTot){
      const s = fTot.value.trim();
      if(!s){
        setTick(fTot,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,1)){ ok++; setTick(fTot,'ok'); } else setTick(fTot,'ko');
      }
    }

    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.fcc[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });

    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp){
      const s = effTotInp.value.trim();
      if(!s){
        setTick(effTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,st.total)){ ok++; setTick(effTotInp,'ok'); } else setTick(effTotInp,'ko');
      }
    }

    const q1 = $('#q2-freq',host);
    if(q1){
      const s = q1.value.trim();
      if(!s){
        setTick(q1,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.freq[st.qFreqIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q1,'ok'); } else setTick(q1,'ko');
      }
    }

    const q2 = $('#q2-fcc',host);
    if(q2){
      const s = q2.value.trim();
      if(!s){
        setTick(q2,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.fcc[st.qFCCIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q2,'ok'); } else setTick(q2,'ko');
      }
    }

    return {ok,total:tot};
  },
  solution(host,st){
   

    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML=html);
    typeset(host);
  },

printSolutionHTML(st){
  const ctx   = st.ctx;
  const n     = st.categories.length;
  const cFreq = st.categories[st.qFreqIndex];
  const upTo  = st.categories.slice(0, st.qFCCIndex+1);

  const popSol   = getPopulationLabel(st.ctx.intro);
  const caracSol = st.ctx.varName;
  const typeSol  = 'qualitatif';

  const isCalc = st.freqMode === 'calc';

  const expFreq = st.categories.map((c,i)=>{
    const dec  = fmtFreq(st.freq[i]);
    const pct  = Math.round(st.freq[i]*100);
    const exactHere = isCalc || isExactRatio(st.eff[i], st.total);
    const sign = exactHere ? '=' : '\\approx';
    return `Pour ¬´ ${c} ¬ª : \\( f = \\dfrac{${st.eff[i]}}{${st.total}} ${sign} ${dec} \\), soit \\(${pct}\\) %.`;
  });

  const decQ3 = fmtFreq(st.freq[st.qFreqIndex]);
  const pctQ3 = Math.round(st.freq[st.qFreqIndex]*100);
  const exactQ3 = isCalc || isExactRatio(st.eff[st.qFreqIndex], st.total);
  const approxWordQ3 = exactQ3 ? '' : ' environ';

  const decQ4 = fmtFreq(st.fcc[st.qFCCIndex]);
  const pctQ4 = Math.round(st.fcc[st.qFCCIndex]*100);
  const cumEffQ4 = st.eff.slice(0, st.qFCCIndex+1).reduce((a,b)=>a+b,0);
  const exactQ4 = isCalc || isExactRatio(cumEffQ4, st.total);
  const approxWordQ4 = exactQ4 ? '' : ' environ';

  let hHead = `<tr><th>${st.ctx.varName}</th>`;
  for(let i=0;i<n;i++) hHead += `<th>${st.categories[i]}</th>`;
  hHead += `<th>Total</th></tr>`;

  let rowEff  = `<tr><td>Effectif</td>`;
  let rowFreq = `<tr><td>Fr√©quence</td>`;
  let rowFCC  = `<tr><td>FCC</td>`;
  for(let i=0;i<n;i++){
    rowEff  += `<td>${st.eff[i]}</td>`;
    rowFreq += `<td>${fmtFreq(st.freq[i])}</td>`;
    rowFCC  += `<td>${fmtFreq(st.fcc[i])}</td>`;
  }
  rowEff  += `<td>${st.total}</td></tr>`;
  rowFreq += `<td>${fmtFreq(1)}</td></tr>`;
  rowFCC  += `<td class="fcc-total"></td></tr>`;

  const tblHtml = `
    <table class="tbl-solution pdfb">
      <thead>${hHead}</thead>
      <tbody>${rowEff}${rowFreq}${rowFCC}</tbody>
    </table>
  `;

  return `
    <div class="step"><strong>R√©ponse √† la question 1 :</strong><br>
    Population √©tudi√©e : ${popSol}.<br>
    Caract√®re √©tudi√© : ${caracSol}.<br>
    Type : ${typeSol}.</div>

    <div class="step"><strong>Calcul des fr√©quences :</strong></div>
    <div class="step">${expFreq.join('<br>')}</div>

    <div class="step"><strong>R√©ponse √† la question 2 :</strong><br>
    On obtient le tableau compl√©t√© suivant :</div>
    <div class="step">${tblHtml}</div>

    <div class="step"><strong>R√©ponse √† la question 3 :</strong><br>
    La fr√©quence des individus dont le <em>${ctx.varName}</em> est <strong>${cFreq}</strong> vaut \\(${decQ3}\\), soit${approxWordQ3} \\(${pctQ3}\\) %.</div>

    <div class="step"><strong>R√©ponse √† la question 4 :</strong><br>
    La fr√©quence des individus dont le <em>${ctx.varName}</em> appartient √† l‚Äôun des cas suivants : <strong>${upTo.join(', ')}</strong> vaut \\(${decQ4}\\), soit${approxWordQ4} \\(${pctQ4}\\) %.</div>
  `;
},



  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};


/* ====== Exercice 3 : quantitatif continu ====== */
const ex3 = {
  id:'stat_qcontinu',
  title:'Caract√®re quantitatif continu',
gen(){
    const ctx = choice(CTX_QCONTINU);
    const intervals = [];
    for(let a=ctx.min; a<ctx.max; a+=ctx.step){
      intervals.push({a,b:a+ctx.step});
    }
    const freqMode = getFreqModeFor(this.id);
    const effData = genEffectifsFromLabels(intervals, freqMode);
    const ff = genFreqAndFCC(effData.eff, effData.total);
    const n = intervals.length;

    const idxFreq = pickInnerIndex(n);
    const idxFCC  = pickInnerIndex(n);

    // ‚¨áÔ∏è NOUVEAU : calcul de la moyenne par centres de classes
    let sumXE = 0;
    for(let i=0;i<n;i++){
      const I = intervals[i];
      const centre = (I.a + I.b) / 2;
      sumXE += centre * effData.eff[i];
    }
    const mean = sumXE / effData.total;

    return {
      kind:'qcontinu',
      ctx,
      intervals,
      eff: effData.eff,
      total: effData.total,
      freq: ff.freq,
      fcc: ff.fcc,
      qFreqIndex: idxFreq,
      qFCCIndex: idxFCC,
      freqMode,
      mean   // ‚¨ÖÔ∏è on stocke la moyenne
    };
  },
  render(host,st){
    const ctx = st.ctx;
    const n   = st.intervals.length;
    let thVals='', tdEff='', tdFreq='', tdFCC='';
    for(let i=0;i<n;i++){
      const I = st.intervals[i];
      thVals += `<th>[${I.a} ; ${I.b}[</th>`;
      tdEff  += `<td>${st.eff[i]}</td>`;
      tdFreq += `<td><input type="text" data-role="freq" data-i="${i}"></td>`;
      tdFCC  += `<td><input type="text" data-role="fcc" data-i="${i}"></td>`;
    }
    thVals += `<th>Total</th>`;
    tdEff  += `<td><input type="text" data-role="effTot"></td>`;
    tdFreq += `<td><input type="text" data-role="freqTot"></td>`;
    tdFCC  += `<td class="fcc-total"></td>`;

    const Iq = st.intervals[st.qFreqIndex];
    const Jq = st.intervals[st.qFCCIndex];

    host.innerHTML = `

      <p class="screen-only" style="margin:.3rem 0 .6rem 0">
        <label><strong>Mode de fr√©quences :</strong>
          <select data-freq-mode>
            <option value="arrondi">Fr√©quences arrondies</option>
            <option value="calc">Fr√©quences calculables</option>
          </select>
        </label>
      </p>

      <p>${ctx.intro}</p>

      <table class="tbl-solution pdfb">
        <thead>
          <tr>
            <th>${ctx.varName} (${ctx.unit})</th>
            ${thVals}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Nombre d‚Äôobservations</td>
            ${tdEff}
          </tr>
          <tr>
            <td>Fr√©quence</td>
            ${tdFreq}
          </tr>
          <tr>
            <td>FCC</td>
            ${tdFCC}
          </tr>
        </tbody>
      </table>

      <div class="q-block">
        <p><strong>1.</strong> Donner la population √©tudi√©e, le caract√®re √©tudi√© ainsi que son type (quantitatif discret, quantitatif continu ou qualitatif).</p>
        <p>Population √©tudi√©e : <input type="text" id="q1-pop"></p>
        <p>Caract√®re √©tudi√© : <input type="text" id="q1-carac"></p>
        <p>Type de caract√®re : <input type="text" id="q1-type"></p>

        <p><strong>2.</strong> Compl√©ter la ligne des fr√©quences (valeurs d√©cimales) puis la ligne des fr√©quences cumul√©es croissantes (FCC).</p>
        <p><strong>3.</strong> Quelle est la fr√©quence correspondant √† une valeur de <em>${ctx.varName}</em> comprise entre <strong>${Iq.a}</strong> et <strong>${Iq.b}</strong> ${ctx.unit} ? 
        <input type="text" id="q3-freq"></p>
        <p><strong>4.</strong> Donner (√† 10<sup>-2</sup> pr√®s) la proportion d‚Äôobservations pour lesquelles <em>${ctx.varName}</em> est strictement inf√©rieure √† <strong>${Jq.b}</strong> ${ctx.unit}. 
        <input type="text" id="q3-fcc"></p>
		        <p><strong>5.</strong> En utilisant le centre de chaque classe, calculer la moyenne de <em>${ctx.varName}</em> (au centi√®me pr√®s). 
        <input type="text" id="q3-moy"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
    attachFreqModeSelector(host);
  },
  correct(host,st){
    let ok=0, tot=0;

    const popInp = $('#q1-pop',host);
    if(popInp){
      const val = popInp.value.trim();
      if(!val){
        setTick(popInp,'nu');
      }else{
        const good = checkPopulationAnswer(val, st.ctx.intro);
        tot++;
        if(good){ ok++; setTick(popInp,'ok'); } else setTick(popInp,'ko');
      }
    }
// Q1 caract√®re
const caracInp = $('#q1-carac',host);
if(caracInp){
  const val = caracInp.value.trim();
  if(!val){
    setTick(caracInp,'nu');
  }else{
    const good = isCaracAnswerOk(val, st.ctx.varName, st.ctx.varName);
    tot++;
    if(good){ ok++; setTick(caracInp,'ok'); } else setTick(caracInp,'ko');
  }
}

    const typeInp = $('#q1-type',host);
    if(typeInp){
      const raw = typeInp.value.trim();
      if(!raw){
        setTick(typeInp,'nu');
      }else{
        const norm = normalizeStr(raw);
        const exp = normalizeStr('quantitatif continu');
        tot++;
        if(norm === exp){ ok++; setTick(typeInp,'ok'); } else setTick(typeInp,'ko');
      }
    }

    const n = st.intervals.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.freq[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });
    const fTot = host.querySelector('input[data-role="freqTot"]');
    if(fTot){
      const s = fTot.value.trim();
      if(!s){
        setTick(fTot,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,1)){ ok++; setTick(fTot,'ok'); } else setTick(fTot,'ko');
      }
    }

    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.fcc[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });

    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp){
      const s = effTotInp.value.trim();
      if(!s){
        setTick(effTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,st.total)){ ok++; setTick(effTotInp,'ok'); } else setTick(effTotInp,'ko');
      }
    }

    const q1 = $('#q3-freq',host);
    if(q1){
      const s = q1.value.trim();
      if(!s){
        setTick(q1,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.freq[st.qFreqIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q1,'ok'); } else setTick(q1,'ko');
      }
    }

    const q2 = $('#q3-fcc',host);
    if(q2){
      const s = q2.value.trim();
      if(!s){
        setTick(q2,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.fcc[st.qFCCIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q2,'ok'); } else setTick(q2,'ko');
      }
    }

    // ‚¨áÔ∏è NOUVEAU : question 5 ‚Äì moyenne
    const qM = $('#q3-moy',host);
    if(qM){
      const s = qM.value.trim();
      if(!s){
        setTick(qM,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v, st.mean)){   // tol√©rance 10^-2
          ok++; setTick(qM,'ok');
        }else{
          setTick(qM,'ko');
        }
      }
    }

    return {ok,total:tot};
  },

  solution(host,st){
   

    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML=html);
    typeset(host);
  },

printSolutionHTML(st){
  const ctx = st.ctx;
  const n   = st.intervals.length;
  const Iq  = st.intervals[st.qFreqIndex];
  const Jq  = st.intervals[st.qFCCIndex];

  const popSol   = getPopulationLabel(st.ctx.intro);
  const caracSol = st.ctx.varName;
  const typeSol  = 'quantitatif continu';

  const isCalc = st.freqMode === 'calc';

  const expFreq = st.intervals.map((I,i)=>{
    const dec  = fmtFreq(st.freq[i]);
    const pct  = Math.round(st.freq[i]*100);
    const exactHere = isCalc || isExactRatio(st.eff[i], st.total);
    const sign = exactHere ? '=' : '\\approx';
    return `Pour la classe [${I.a};${I.b}[ : \\( f = \\dfrac{${st.eff[i]}}{${st.total}} ${sign} ${dec} \\), soit \\(${pct}\\) %.`;
  });

  const decQ3 = fmtFreq(st.freq[st.qFreqIndex]);
  const pctQ3 = Math.round(st.freq[st.qFreqIndex]*100);
  const exactQ3 = isCalc || isExactRatio(st.eff[st.qFreqIndex], st.total);
  const approxWordQ3 = exactQ3 ? '' : ' environ';

  const decQ4 = fmtFreq(st.fcc[st.qFCCIndex]);
  const pctQ4 = Math.round(st.fcc[st.qFCCIndex]*100);
  const cumEffQ4 = st.eff.slice(0, st.qFCCIndex+1).reduce((a,b)=>a+b,0);
  const exactQ4 = isCalc || isExactRatio(cumEffQ4, st.total);
  const approxWordQ4 = exactQ4 ? '' : ' environ';

  let hHead = `<tr><th>${st.ctx.varName} (${st.ctx.unit})</th>`;
  for(let i=0;i<n;i++){
    const I = st.intervals[i];
    hHead += `<th>[${I.a} ; ${I.b}[</th>`;
  }
  hHead += `<th>Total</th></tr>`;

  let rowEff  = `<tr><td>Nombre d‚Äôobservations</td>`;
  let rowFreq = `<tr><td>Fr√©quence</td>`;
  let rowFCC  = `<tr><td>FCC</td>`;
  for(let i=0;i<n;i++){
    rowEff  += `<td>${st.eff[i]}</td>`;
    rowFreq += `<td>${fmtFreq(st.freq[i])}</td>`;
    rowFCC  += `<td>${fmtFreq(st.fcc[i])}</td>`;
  }
  rowEff  += `<td>${st.total}</td></tr>`;
  rowFreq += `<td>${fmtFreq(1)}</td></tr>`;
  rowFCC  += `<td class="fcc-total"></td></tr>`;

  const tblHtml = `
    <table class="tbl-solution pdfb">
      <thead>${hHead}</thead>
      <tbody>${rowEff}${rowFreq}${rowFCC}</tbody>
    </table>
  `;

  // --- moyenne par classes ---
  const numMoy = st.intervals.reduce((S, I, i)=>{
    const centre = (I.a + I.b) / 2;
    return S + centre * st.eff[i];
  }, 0);
  const termsMoy = st.intervals.map((I,i)=>{
    const centre = (I.a + I.b) / 2;
    return `${centre}\\times ${st.eff[i]}`;
  }).join(' + ');
  const decMoy = fmtFreq(numMoy / st.total);
  const exactMoy = isExactRatio(numMoy, st.total);
  const signMoy = exactMoy ? '=' : '\\approx';


  return `
    <div class="step"><strong>R√©ponse √† la question 1 :</strong><br>
    Population √©tudi√©e : ${popSol}.<br>
    Caract√®re √©tudi√© : ${caracSol}.<br>
    Type : ${typeSol}.</div>

    <div class="step"><strong>Calcul des fr√©quences :</strong></div>
    <div class="step">${expFreq.join('<br>')}</div>

    <div class="step"><strong>R√©ponse √† la question 2 :</strong><br>
    On obtient le tableau compl√©t√© suivant :</div>
    <div class="step">${tblHtml}</div>

    <div class="step"><strong>R√©ponse √† la question 3 :</strong><br>
    La fr√©quence correspondant √† une valeur de <em>${ctx.varName}</em> comprise entre <strong>${Iq.a}</strong> et <strong>${Iq.b}</strong> ${ctx.unit} vaut \\(${decQ3}\\), soit${approxWordQ3} \\(${pctQ3}\\) %.</div>

    <div class="step"><strong>R√©ponse √† la question 4 :</strong><br>
    La proportion d‚Äôobservations pour lesquelles <em>${ctx.varName}</em> est strictement inf√©rieure √† <strong>${Jq.b}</strong> ${ctx.unit} vaut \\(${decQ4}\\), soit${approxWordQ4} \\(${pctQ4}\\) %.</div>

    <div class="step"><strong>R√©ponse √† la question 5 :</strong><br>
    On approche la moyenne en utilisant le centre de chaque classe :<br>
    \\[
      \\overline{x}
      = \\dfrac{${termsMoy}}{${st.total}}
      ${signMoy} ${decMoy}
    \\]
    </div>
  `;
},




  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};

const PATTERNS_QDISCRET = [
  // N = 30
  { N:30, A:[2, 6,14, 6, 2], B:[6, 4,10, 4, 6] },
  // N = 32
  { N:32, A:[2, 7,14, 7, 2], B:[6, 5,10, 5, 6] },
  // N = 36
  { N:36, A:[3, 7,16, 7, 3], B:[7, 5,12, 5, 7] },
  // N = 40
  { N:40, A:[3, 9,16, 9, 3], B:[7, 7,12, 7, 7] }
];


const ex5 = {
  id: 'stat_comp_qdiscret',
  title: 'Comparer deux s√©ries ‚Äì Quantitatif discret',

  gen() {
    // valeurs enti√®res centr√©es sur m : (m-2, m-1, m, m+1, m+2)
    const m = rint(5, 20);
    const values = [m - 2, m - 1, m, m + 1, m + 2];

    let lastState = null;

    for (let attempt = 0; attempt < 400; attempt++) {
      // --- 1) Choix d‚Äôun total commun N ---
      const N = rint(25, 70);
      const minEff = 3;
      const maxEff = Math.floor(N / 2);

      // --- 2) Construire effA non sym√©trique mais "√©quilibr√©" ---
      let effA = null;

      for (let innerA = 0; innerA < 400; innerA++) {
        const base = Math.floor(N / 5);
        const di = [];
        let sumD = 0;

        // on choisit d0..d3 et on impose d4 pour avoir somme(di)=0
        for (let i = 0; i < 4; i++) {
          const d = rint(-4, 4);
          di.push(d);
          sumD += d;
        }
        di.push(-sumD); // assure somme(di) = 0

        const candidate = di.map(d => base + d);
        const totCheck = candidate.reduce((S, e) => S + e, 0);
        if (totCheck !== N) continue;

        const minA = Math.min(...candidate);
        const maxA = Math.max(...candidate);

        // pas de case ridiculement petite ou gigantesque
        if (minA < minEff || maxA > maxEff) continue;
        // vraie variation interne
        if (maxA - minA < 4) continue;
        // √©viter un monstre
        if (maxA / minA > 3) continue;

        effA = candidate;
        break;
      }

      if (!effA) continue;

      // --- 3) D√©terminer effB : m√™me N et m√™me moyenne ---
      const S1 = effA.reduce((S, n_i, i) => S + n_i * values[i], 0); // somme pond√©r√©e => moyenne_A = S1/N

      let effB = null;

      for (let innerB = 0; innerB < 800; innerB++) {
        // on va choisir b0, b1, b2 puis calculer b3, b4
        const b0 = rint(minEff, maxEff);
        const b1 = rint(minEff, maxEff);
        const b2 = rint(minEff, maxEff);

        const S0p = N - (b0 + b1 + b2); // reste √† r√©partir sur b3, b4
        if (S0p < 2 * minEff || S0p > 2 * maxEff) continue;

        const S1p = S1 - (b0 * values[0] + b1 * values[1] + b2 * values[2]);

        // R√©solution du syst√®me :
        // b3 + b4 = S0p
        // b3*v3 + b4*v4 = S1p
        const v3 = values[3];
        const v4 = values[4];

        const denom = (v3 - v4);
        if (denom === 0) continue;

        const b3 = (S1p - S0p * v4) / denom;
        const b4 = S0p - b3;

        if (!Number.isInteger(b3) || !Number.isInteger(b4)) continue;
        if (b3 < minEff || b3 > maxEff || b4 < minEff || b4 > maxEff) continue;

        const candidateB = [b0, b1, b2, b3, b4];

        const minB = Math.min(...candidateB);
        const maxB = Math.max(...candidateB);
        if (maxB - minB < 4) continue;
        if (maxB / minB > 3) continue;

        // √©viter une s√©rie B trop proche de A
        let diffCount3 = 0;
        let l1 = 0;
        for (let i = 0; i < 5; i++) {
          const d = Math.abs(candidateB[i] - effA[i]);
          l1 += d;
          if (d >= 3) diffCount3++;
        }
        if (diffCount3 < 3) continue;     // au moins 3 cases vraiment diff√©rentes
        if (l1 < N * 0.4) continue;       // profil global diff√©rent

        effB = candidateB;
        break;
      }

      if (!effB) continue;

      // --- 4) Calcul des stats ---
      const arrA = [];
      const arrB = [];
      for (let i = 0; i < values.length; i++) {
        for (let k = 0; k < effA[i]; k++) arrA.push(values[i]);
        for (let k = 0; k < effB[i]; k++) arrB.push(values[i]);
      }

      const sumA = arrA.reduce((S, x) => S + x, 0);
      const sumB = arrB.reduce((S, x) => S + x, 0);

      const meanA = sumA / N;
      const meanB = sumB / N;

      const sigmaA = Math.sqrt(arrA.reduce((S, x) => S + (x - meanA) ** 2, 0) / N);
      const sigmaB = Math.sqrt(arrB.reduce((S, x) => S + (x - meanB) ** 2, 0) / N);

      const state = {
        values,
        effA,
        effB,
        sumA,
        sumB,
        totA: N,
        totB: N,
        meanA,
        meanB,
        sigmaA,
        sigmaB
      };
      lastState = state;

      // on veut des √©carts-types vraiment diff√©rents
      if (Math.abs(sigmaA - sigmaB) > 0.7) {
        return state;
      }
    }

    // fallback (au cas o√π les crit√®res sont trop stricts)
    return lastState;
  },

  render(host, st) {
    const n = st.values.length;
    let head = '<th>Valeur du caract√®re (u)</th>';
    let rowA = '<td>Effectif s√©rie A</td>';
    let rowB = '<td>Effectif s√©rie B</td>';

    for (let i = 0; i < n; i++) {
      head += `<th>${st.values[i]}</th>`;
      rowA += `<td>${st.effA[i]}</td>`;
      rowB += `<td>${st.effB[i]}</td>`;
    }

    host.innerHTML = `
      <p>On √©tudie un m√™me caract√®re quantitatif discret dans deux s√©ries statistiques, not√©es A et B. 
      Pour chaque valeur du caract√®re, le tableau ci-dessous donne l‚Äôeffectif correspondant dans chaque s√©rie.</p>

      <table class="tbl-solution pdfb">
        <thead><tr>${head}</tr></thead>
        <tbody>
          <tr>${rowA}</tr>
          <tr>${rowB}</tr>
        </tbody>
      </table>

      <p><strong>√âcarts-types :</strong> œÉ<sub>A</sub> = ${fmtFreq(st.sigmaA)}, 
      œÉ<sub>B</sub> = ${fmtFreq(st.sigmaB)}</p>

      <div class="q-block">
        <p><strong>1.</strong> Calculer la moyenne de la s√©rie A. 
        <input type="text" id="mA"></p>

        <p><strong>2.</strong> Calculer la moyenne de la s√©rie B. 
        <input type="text" id="mB"></p>

        <p><strong>3.</strong> Comparer les deux s√©ries (niveau moyen et dispersion).<br>



      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
    typeset(host);
  },

  correct(host, st) {
    let ok = 0, tot = 0;

    const inpA = $('#mA', host);
    const inpB = $('#mB', host);

    // moyenne A
    if (inpA) {
      const raw = inpA.value.trim();
      if (!raw) {
        setTick(inpA, 'nu');
      } else {
        const v = parseNumber(raw);
        tot++;
        if (approxEqual(v, st.meanA)) { ok++; setTick(inpA, 'ok'); }
        else setTick(inpA, 'ko');
      }
    }

    // moyenne B
    if (inpB) {
      const raw = inpB.value.trim();
      if (!raw) {
        setTick(inpB, 'nu');
      } else {
        const v = parseNumber(raw);
        tot++;
        if (approxEqual(v, st.meanB)) { ok++; setTick(inpB, 'ok'); }
        else setTick(inpB, 'ko');
      }
    }

    // comparaison r√©dig√©e non not√©e
    const cmp = $('#cmp', host);
    if (cmp) setTick(cmp, 'nu');

    return { ok, total: tot };
  },

  solution(host, st) {
    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s => { s.innerHTML = html; });
    typeset(host);
  },

printSolutionHTML(st) {
  const mA = fmtFreq(st.meanA);
  const mB = fmtFreq(st.meanB);
  const sA = fmtFreq(st.sigmaA);
  const sB = fmtFreq(st.sigmaB);

  // Sommes par x_i * n_i (moyennes)
  const termsA = st.values.map((x, i) => `${x}\\times ${st.effA[i]}`).join(' + ');
  const termsB = st.values.map((x, i) => `${x}\\times ${st.effB[i]}`).join(' + ');

  const sumA = st.sumA ?? st.values.reduce((S, x, i) => S + x * st.effA[i], 0);
  const sumB = st.sumB ?? st.values.reduce((S, x, i) => S + x * st.effB[i], 0);
  const totA = st.totA ?? st.effA.reduce((S, e) => S + e, 0);
  const totB = st.totB ?? st.effB.reduce((S, e) => S + e, 0);

  const signA = isExactRatio(sumA, totA) ? '=' : '\\approx';
  const signB = isExactRatio(sumB, totB) ? '=' : '\\approx';

  // --- √âcarts-types (num√©rateur d√©taill√©) ---
  const termsSigmaA = st.values
    .map((x, i) => `(${x}-${mA})^2\\times ${st.effA[i]}`)
    .join(' + ');
  const termsSigmaB = st.values
    .map((x, i) => `(${x}-${mB})^2\\times ${st.effB[i]}`)
    .join(' + ');

  const numSigmaA = st.values.reduce(
    (S, x, i) => S + (x - st.meanA) ** 2 * st.effA[i],
    0
  );
  const numSigmaB = st.values.reduce(
    (S, x, i) => S + (x - st.meanB) ** 2 * st.effB[i],
    0
  );

  const numSigmaAtex = fmtFreq(numSigmaA);
  const numSigmaBtex = fmtFreq(numSigmaB);

  // --- Comparaison des moyennes ---
  let meanComment;
  const eps = 1e-6;

  if (Math.abs(st.meanA - st.meanB) < eps) {
    meanComment =
      `Les deux s√©ries ont la <strong>m√™me moyenne</strong>, √©gale √† \\(${mA}\\). 
      Le <strong>niveau moyen</strong> est donc identique.`;
  } else if (st.meanA > st.meanB) {
    meanComment =
      `La s√©rie A a une <strong>moyenne plus √©lev√©e</strong> que la s√©rie B :
       \\(\\bar{x}_A \\approx ${mA}\\) contre \\(\\bar{x}_B \\approx ${mB}\\).`;
  } else {
    meanComment =
      `La s√©rie B a une <strong>moyenne plus √©lev√©e</strong> que la s√©rie A :
       \\(\\bar{x}_B \\approx ${mB}\\) contre \\(\\bar{x}_A \\approx ${mA}\\).`;
  }

  // --- Comparaison des dispersions ---
  let sigmaComment;
  if (Math.abs(st.sigmaA - st.sigmaB) < eps) {
    sigmaComment =
      `Les deux s√©ries ont des √©carts-types tr√®s proches (œÉ ‚âà ${sA}).<br>
       La dispersion autour de la moyenne est similaire.`;
  } else if (st.sigmaA > st.sigmaB) {
    sigmaComment =
      `L‚Äô√©cart-type de la s√©rie A est plus grand que celui de la s√©rie B 
       (œÉ<sub>A</sub> \\(\\approx ${sA}\\), œÉ<sub>B</sub> \\(\\approx ${sB}\\)).<br>
       Les valeurs de <strong>A</strong> sont donc plus dispers√©es autour de la moyenne, 
       et la moyenne de A est moins repr√©sentative.`;
  } else {
    sigmaComment =
      `L‚Äô√©cart-type de la s√©rie B est plus grand que celui de la s√©rie A 
       (œÉ<sub>B</sub> \\(\\approx ${sB}\\), œÉ<sub>A</sub> \\(\\approx ${sA}\\)).<br>
       Les valeurs de <strong>B</strong> sont donc plus dispers√©es autour de la moyenne, 
       et la moyenne de B est moins repr√©sentative.`;
  }

  return `
    <div class="step"><strong>Calcul de la moyenne de la s√©rie A :</strong><br>
    On note \\(\\bar{x}_A\\) la moyenne de la s√©rie A.<br>
    \\[
      \\bar{x}_A
      = \\dfrac{${termsA}}{${totA}}
      = \\dfrac{${sumA}}{${totA}}
      ${signA} ${mA}
    \\]
    </div>

    <div class="step"><strong>Calcul de la moyenne de la s√©rie B :</strong><br>
    On note \\(\\bar{x}_B\\) la moyenne de la s√©rie B.<br>
    \\[
      \\bar{x}_B
      = \\dfrac{${termsB}}{${totB}}
      = \\dfrac{${sumB}}{${totB}}
      ${signB} ${mB}
    \\]
    </div>

    <div class="step"><strong>Calcul de l‚Äô√©cart-type de la s√©rie A :</strong><br>
    On note \\(V_A\\) la variance et \\(\\sigma_A\\) l'√©cart-type de la s√©rie \\(A\\) et on utilise la formule : 
    \\[
      V_A = \\dfrac{1}{${totA}} \\sum_i (x_i-\\bar{x}_A)^2\\,n_i
    \\]
    Ici :<br>
    \\[
      \\sum_i (x_i-\\bar{x}_A)^2\\,n_i
      = ${termsSigmaA}
      \\approx ${numSigmaAtex}
    \\]
    donc<br>
    \\[
      \\sigma_A
	  =\\sqrt{V_A}
      = \\sqrt{\\dfrac{${numSigmaAtex}}{${totA}}}
      \\approx ${sA}
    \\]
    </div>

    <div class="step"><strong>Calcul de l‚Äô√©cart-type de la s√©rie B :</strong><br>
	    On note \\(V_B\\) la variance et \\(\\sigma_B\\) l'√©cart-type de la s√©rie \\(B\\) et on utilise la formule : 

    \\[
      V_B = \\dfrac{1}{${totB}} \\sum_i (x_i-\\bar{x}_B)^2\\,n_i
    \\]
    Ici :<br>
    \\[
      \\sum_i (x_i-\\bar{x}_B)^2\\,n_i
      = ${termsSigmaB}
      \\approx ${numSigmaBtex}
    \\]
    donc<br>
    \\[
      \\sigma_B
	  	  =\\sqrt{V_B}
      = \\sqrt{\\dfrac{${numSigmaBtex}}{${totB}}}
      \\approx ${sB}
    \\]
    </div>

    <div class="step"><strong>Comparaison des moyennes :</strong><br>
    ${meanComment}
    </div>

    <div class="step"><strong>Comparaison des dispersions :</strong><br>
    ${sigmaComment}
    </div>


  `;
},


  reset(host) {
    host.querySelectorAll('input,textarea').forEach(i => i.value = '');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s => s.innerHTML = '');
  }
};


/* ====== Exercice 6 : Comparer deux s√©ries (quantitatif continu) ====== */
const PATTERNS_QCONTINU = [
  // N = 60
  { N:60, A:[ 4,10,32,10, 4], B:[12, 8,20, 8,12] },
  // N = 50
  { N:50, A:[ 3, 8,28, 8, 3], B:[10, 7,16, 7,10] },
  // N = 72
  { N:72, A:[ 6,10,40,10, 6], B:[14,10,24,10,14] }
];



const ex6 = {
  id: 'stat_comp_qcontinu',
  title: 'Comparer deux s√©ries ‚Äì Quantitatif continu',

  gen() {
    // 5 classes contigu√´s [a0;a0+w[, ..., [a0+4w;a0+5w[
    const k = 5;
    const a0 = 0;
    const width = 10;
    const classes = [];
    for (let i = 0; i < k; i++) {
      classes.push({ a: a0 + i * width, b: a0 + (i + 1) * width });
    }
    const centers = classes.map(I => (I.a + I.b) / 2); // 5,15,25,35,45

    let lastState = null;

    for (let attempt = 0; attempt < 400; attempt++) {
      // --- 1) Choix d‚Äôun total N ---
      const N = rint(25, 80);
      const minEff = 3;
      const maxEff = Math.floor(N / 2);

      // --- 2) Construire effA non sym√©trique mais √©quilibr√© ---
      let effA = null;

      for (let innerA = 0; innerA < 400; innerA++) {
        const base = Math.floor(N / 5);
        const di = [];
        let sumD = 0;

        for (let i = 0; i < 4; i++) {
          const d = rint(-4, 4);
          di.push(d);
          sumD += d;
        }
        di.push(-sumD);

        const candidate = di.map(d => base + d);
        const totCheck = candidate.reduce((S, e) => S + e, 0);
        if (totCheck !== N) continue;

        const minA = Math.min(...candidate);
        const maxA = Math.max(...candidate);
        if (minA < minEff || maxA > maxEff) continue;
        if (maxA - minA < 4) continue;
        if (maxA / minA > 3) continue;

        effA = candidate;
        break;
      }

      if (!effA) continue;

      // --- 3) effB : m√™me N et m√™me moyenne (par centres de classes) ---
      const S1 = effA.reduce((S, n_i, i) => S + n_i * centers[i], 0);

      let effB = null;

      for (let innerB = 0; innerB < 800; innerB++) {
        const b0 = rint(minEff, maxEff);
        const b1 = rint(minEff, maxEff);
        const b2 = rint(minEff, maxEff);

        const S0p = N - (b0 + b1 + b2);
        if (S0p < 2 * minEff || S0p > 2 * maxEff) continue;

        const S1p = S1 - (b0 * centers[0] + b1 * centers[1] + b2 * centers[2]);

        const v3 = centers[3];
        const v4 = centers[4];
        const denom = (v3 - v4);
        if (denom === 0) continue;

        const b3 = (S1p - S0p * v4) / denom;
        const b4 = S0p - b3;

        if (!Number.isInteger(b3) || !Number.isInteger(b4)) continue;
        if (b3 < minEff || b3 > maxEff || b4 < minEff || b4 > maxEff) continue;

        const candidateB = [b0, b1, b2, b3, b4];

        const minB = Math.min(...candidateB);
        const maxB = Math.max(...candidateB);
        if (maxB - minB < 4) continue;
        if (maxB / minB > 3) continue;

        let diffCount3 = 0;
        let l1 = 0;
        for (let i = 0; i < 5; i++) {
          const d = Math.abs(candidateB[i] - effA[i]);
          l1 += d;
          if (d >= 3) diffCount3++;
        }
        if (diffCount3 < 3) continue;
        if (l1 < N * 0.4) continue;

        effB = candidateB;
        break;
      }

      if (!effB) continue;

      // --- 4) Statistiques (par centres de classes) ---
      const sumA = centers.reduce((S, c, i) => S + c * effA[i], 0);
      const sumB = centers.reduce((S, c, i) => S + c * effB[i], 0);

      const meanA = sumA / N;
      const meanB = sumB / N;

      const sigmaA = Math.sqrt(
        centers.reduce((S, c, i) => S + effA[i] * (c - meanA) ** 2, 0) / N
      );
      const sigmaB = Math.sqrt(
        centers.reduce((S, c, i) => S + effB[i] * (c - meanB) ** 2, 0) / N
      );

      const state = {
        classes,
        centers,
        effA,
        effB,
        sumA,
        sumB,
        totA: N,
        totB: N,
        meanA,
        meanB,
        sigmaA,
        sigmaB
      };
      lastState = state;

      if (Math.abs(sigmaA - sigmaB) > 0.7) {
        return state;
      }
    }

    return lastState;
  },

  render(host, st) {
    let head = `<th>Valeur du caract√®re (u)</th>`;
    let rowA = '<td>Effectif s√©rie A</td>';
    let rowB = '<td>Effectif s√©rie B</td>';

    for (let i = 0; i < st.classes.length; i++) {
      const I = st.classes[i];
      head += `<th>[${I.a} ; ${I.b}[</th>`;
      rowA += `<td>${st.effA[i]}</td>`;
      rowB += `<td>${st.effB[i]}</td>`;
    }

    host.innerHTML = `
      <p>On √©tudie un m√™me caract√®re quantitatif continu dans deux s√©ries statistiques, not√©es A et B. 
      Les valeurs ont √©t√© regroup√©es en classes d‚Äôamplitude constante, et le tableau ci-dessous indique 
      pour chaque classe le nombre d‚Äôobservations dans chaque s√©rie.</p>

      <table class="tbl-solution pdfb">
        <thead><tr>${head}</tr></thead>
        <tbody>
          <tr>${rowA}</tr>
          <tr>${rowB}</tr>
        </tbody>
      </table>

      <p><strong>√âcarts-types :</strong> œÉ<sub>A</sub> = ${fmtFreq(st.sigmaA)}, 
      œÉ<sub>B</sub> = ${fmtFreq(st.sigmaB)}</p>

      <div class="q-block">
        <p><strong>1.</strong> En utilisant les centres de classes, calculer la moyenne de la s√©rie A. 
        <input type="text" id="mA"></p>

        <p><strong>2.</strong> En utilisant les centres de classes, calculer la moyenne de la s√©rie B. 
        <input type="text" id="mB"></p>

        <p><strong>3.</strong> Comparer les deux s√©ries (niveau moyen et dispersion).<br>



      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
    typeset(host);
  },

  correct(host, st) {
    let ok = 0, tot = 0;

    const inpA = $('#mA', host);
    const inpB = $('#mB', host);

    if (inpA) {
      const raw = inpA.value.trim();
      if (!raw) {
        setTick(inpA, 'nu');
      } else {
        const v = parseNumber(raw);
        tot++;
        if (approxEqual(v, st.meanA)) { ok++; setTick(inpA, 'ok'); }
        else setTick(inpA, 'ko');
      }
    }

    if (inpB) {
      const raw = inpB.value.trim();
      if (!raw) {
        setTick(inpB, 'nu');
      } else {
        const v = parseNumber(raw);
        tot++;
        if (approxEqual(v, st.meanB)) { ok++; setTick(inpB, 'ok'); }
        else setTick(inpB, 'ko');
      }
    }

    const cmp = $('#cmp', host);
    if (cmp) setTick(cmp, 'nu');

    return { ok, total: tot };
  },

  solution(host, st) {
    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s => { s.innerHTML = html; });
    typeset(host);
  },

  printSolutionHTML(st) {
    const mA = fmtFreq(st.meanA);
    const mB = fmtFreq(st.meanB);
    const sA = fmtFreq(st.sigmaA);
    const sB = fmtFreq(st.sigmaB);

    const centers = st.centers || st.classes.map(I => (I.a + I.b) / 2);

    const termsA = centers.map((c, i) => `${c}\\times ${st.effA[i]}`).join(' + ');
    const termsB = centers.map((c, i) => `${c}\\times ${st.effB[i]}`).join(' + ');

    const sumA = st.sumA ?? centers.reduce((S, c, i) => S + c * st.effA[i], 0);
    const sumB = st.sumB ?? centers.reduce((S, c, i) => S + c * st.effB[i], 0);
    const totA = st.totA ?? st.effA.reduce((S, x) => S + x, 0);
    const totB = st.totB ?? st.effB.reduce((S, x) => S + x, 0);

    const signA = isExactRatio(sumA, totA) ? '=' : '\\approx';
    const signB = isExactRatio(sumB, totB) ? '=' : '\\approx';

    const eps = 1e-6;

    let meanComment;
    if (Math.abs(st.meanA - st.meanB) < eps) {
      meanComment =
        `Les deux s√©ries ont la <strong>m√™me moyenne</strong>, √©gale √† \\(${mA}\\). 
        Le <strong>niveau moyen</strong> est donc identique.`;
    } else if (st.meanA > st.meanB) {
      meanComment =
        `La s√©rie A a une <strong>moyenne plus √©lev√©e</strong> que la s√©rie B :
         \\(\\bar{x}_A \\approx ${mA}\\) contre \\(\\bar{x}_B \\approx ${mB}\\).`;
    } else {
      meanComment =
        `La s√©rie B a une <strong>moyenne plus √©lev√©e</strong> que la s√©rie A :
         \\(\\bar{x}_B \\approx ${mB}\\) contre \\(\\bar{x}_A \\approx ${mA}\\).`;
    }

    let sigmaComment;
    if (Math.abs(st.sigmaA - st.sigmaB) < eps) {
      sigmaComment =
        `Les deux s√©ries ont des √©carts-types tr√®s proches (œÉ ‚âà ${sA}).<br>
         La dispersion autour de la moyenne est donc comparable.`;
    } else if (st.sigmaA > st.sigmaB) {
      sigmaComment =
        `L‚Äô√©cart-type de la s√©rie A est plus grand que celui de la s√©rie B 
         (œÉ<sub>A</sub> \\(\\approx ${sA}\\), œÉ<sub>B</sub> \\(\\approx ${sB}\\)).<br>
         Les valeurs de <strong>A</strong> sont donc plus dispers√©es autour de la moyenne, 
         et la moyenne de A est moins repr√©sentative.`;
    } else {
      sigmaComment =
        `L‚Äô√©cart-type de la s√©rie B est plus grand que celui de la s√©rie A 
         (œÉ<sub>B</sub> \\(\\approx ${sB}\\), œÉ<sub>A</sub> \\(\\approx ${sA}\\)).<br>
         Les valeurs de <strong>B</strong> sont donc plus dispers√©es autour de la moyenne, 
         et la moyenne de B est moins repr√©sentative.`;
    }

    return `
      <div class="step"><strong>Calcul de la moyenne de la s√©rie A (par centres de classes) :</strong><br>
    On note \\(\\bar{x}_A\\) la moyenne de la s√©rie A.<br>
      \\[
        \\bar{x}_A
        = \\dfrac{${termsA}}{${totA}}
        = \\dfrac{${sumA}}{${totA}}
        ${signA} ${mA}
      \\]
      </div>

      <div class="step"><strong>Calcul de la moyenne de la s√©rie B (par centres de classes) :</strong><br>
         On note \\(\\bar{x}_B\\) la moyenne de la s√©rie B.<br>

	 \\[
        \\bar{x}_B
        = \\dfrac{${termsB}}{${totB}}
        = \\dfrac{${sumB}}{${totB}}
        ${signB} ${mB}
      \\]
      </div>

      <div class="step"><strong>Comparaison des moyennes :</strong><br>
      ${meanComment}
      </div>

      <div class="step"><strong>Comparaison des dispersions :</strong><br>
      ${sigmaComment}
      </div>
    `;
  },

  reset(host) {
    host.querySelectorAll('input,textarea').forEach(i => i.value = '');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s => s.innerHTML = '');
  }
};


/* ====== Registre & navigation ====== */
const REGISTRY = [ex4,ex1,ex3,ex5,ex6];
window.REGISTRY = REGISTRY;

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = def.gen();                 // lit le mode courant dans FREQ_MODE_BY_EXO
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host,st);
  try{
    if(window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}

function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK = r.ok;
  scoreTot = r.total;
  updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host);
  scoreOK = 0;
  scoreTot = 0;
  updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

/* init s√©lecteur + PDF */
(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;

  sel.value = REGISTRY[0].id;
  buildOne();
})();

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Statistiques - Couple moyenne / √©cart type',
      mountAfterSelector: '.card.small',
      beforeRender(def, st, isSolution){
        if (isSolution && typeof def.printSolutionHTML === 'function') {
          return { solution: def.printSolutionHTML(st) };
        }
        return null;
      }
    });
  } else {
    setTimeout(waitExoPDF, 80);
  }
})();

})();
</script>


</body>
</html>
