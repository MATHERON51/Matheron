<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Statistiques - Effectifs et fr√©quences</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.45rem 0 0 .15rem;padding:.45rem .6rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:var(--ok); }
  .tick.ko::after{ content:'‚úó'; color:var(--ko); }

  table.pdf-tbl{
    border-collapse: separate;
    border-spacing: 0;
    border:none;
    margin:.5rem 0;
    width:100%;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border:none;
    padding:4px 6px;
    text-align:center;
    vertical-align:middle;
  }
  table.pdf-tbl th{
    background:#f3f3f6;
    font-weight:600;
  }
  table.pdf-tbl tr:first-child > * { border-top:1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom:1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right:1.5px solid #000; }

  table.pdfb input[type="text"]{
    width:100%;
    max-width:90px;
    padding:4px 6px;
    border:1px solid #ddd;
    border-radius:6px;
    text-align:center;
    font-size:.95rem;
  }
/* Ligne horizontale entre toutes les lignes du tableau */
table.pdf-tbl tbody tr + tr > *{
  border-top:1px solid #000;
}
.tbl{border-collapse:collapse;width:100%;max-width:760px;margin:.25rem 0}
.tbl th,.tbl td{border:1px solid #ddd;padding:6px 8px;text-align:center}
.tbl th{background:#f7f7f7}


  .q-block{margin-top:.6rem}
  .q-block p{margin:.25rem 0}
  .q-block input[type="text"]{
    width:160px;
    max-width:60%;
    padding:4px 6px;
    border:1px solid #ddd;
    border-radius:6px;
    text-align:center;
  }

  @media screen { .screen-only{display:block!important} .print-only{display:none!important} }
  @media print  { .screen-only{display:none!important} .print-only{display:block!important} }

/* === Bordures opt-in pour certains tableaux (PDF uniquement) === */
table.pdfb{ border-collapse: collapse; }
table.pdfb, table.pdfb th, table.pdfb td{
  border: 1px solid #000;
  padding: 4px 6px;
  vertical-align: top;
}
/* Tableaux "plein largeur" pour le PDF, uniquement si .pdfb est pr√©sente */
table.pdfb{
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;          /* r√©partit la largeur sur toute la page */
}
table.pdfb, table.pdfb th, table.pdfb td{
  border: 1px solid #000;
  padding: 6px 8px;
  vertical-align: top;
  white-space: normal;          /* pour que le contenu aille √† la ligne */
  word-break: break-word;
}
/* PDF : m√™me respiration pour la colonne 3 des tableaux de corrig√© */
table.pdfb.corrige td:nth-child(3),
table.pdfb.corrige th:nth-child(3){
  padding-left: 12px;
  padding-right: 12px;
}

.tbl-solution td.fcc-total{
  background:#e0e0e0;
}


</style>

<script>
  // MathJax pour d'√©ventuels LaTeX simples
  window.MathJax={
    tex:{inlineMath:[['\\(','\\)'],['$','$']],processEscapes:true},
    chtml:{matchFontHeight:false},
    startup:{typeset:true}
  };
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>
<script src='../../../../js/algebra-eval-patch.js' defer></script>
<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Statistiques : Effectifs, fr√©quences et FCC</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>

      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Pour les fr√©quences, saisir un <strong>d√©cimal</strong> (ex. <code>0,12</code> ou <code>0.12</code>) ou une <strong>fraction</strong> (ex. <code>3/25</code>).</li>
        <li>On n‚Äô√©crit pas le symbole <code>%</code> : la fr√©quence d√©cimale <code>0,24</code> correspond par exemple √† <code>24&nbsp;%</code>.</li>
        <li>La somme des fr√©quences vaut 1 ; la derni√®re FCC vaut toujours 1.</li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ====== Utils simples ====== */
const $ = (sel,root=document)=>root.querySelector(sel);
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function ensureTickAfter(el){
  if(!el) return null;
  let s = el.nextElementSibling;
  if (s && s.classList && s.classList.contains('tick')) return s;
  s = document.createElement('span');
  s.className = 'tick nu';
  el.insertAdjacentElement('afterend', s);
  return s;
}
function setTick(el, state){
  if(!el) return;
  ensureTickAfter(el).className = 'tick '+state;
}
function clearTicks(root){
  root.querySelectorAll('.tick').forEach(t=>t.className='tick nu');
}

/* nombre al√©atoire entier */
const rint = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = arr => arr[Math.floor(Math.random()*arr.length)];

function pickInnerIndex(n){
  // on √©vite si possible les 2 premi√®res et 2 derni√®res cases
  const cand = [];
  for(let i=0;i<n;i++){
    if(i>=2 && i<=n-3) cand.push(i);
  }
  if(cand.length) return choice(cand);

  // sinon, on √©vite au moins les extr√™mes
  const cand2 = [];
  for(let i=1;i<=n-2;i++) cand2.push(i);
  if(cand2.length) return choice(cand2);

  // cas vraiment d√©g√©n√©r√© (quasi impossible ici)
  return 0;
}



/* parse num√©rique tol√©rant (d√©cimal FR/US + fractions) */
function parseNumber(str){
  if(str==null) return NaN;
  let s = String(str).trim();
  if(!s) return NaN;
  s = s.replace(/\u2212/g,'-').replace(/,/g,'.'); // signe ‚àí, virgule
  // fraction simple a/b
  if(/^[+-]?\d+\s*\/\s*[+-]?\d+$/.test(s)){
    const [p,q] = s.split('/').map(x=>Number(x));
    if(!q) return NaN;
    return p/q;
  }
  const n = Number(s);
  return isFinite(n) ? n : NaN;
}
function approxEqual(a,b,eps=1e-2){
  if(!isFinite(a) || !isFinite(b)) return false;
  return Math.abs(a-b)<=eps;
}
function fmtFreq(x){
  if(!isFinite(x)) return '';
  const r = Math.round(x*100)/100;
  return String(r).replace('.',',');
}
function normalizeStr(s){
  return String(s||'')
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')   // accents
    .replace(/<[^>]+>/g,' ')                           // balises HTML
    .replace(/[^a-z0-9]+/g,' ')                        // tout le reste -> espace
    .replace(/\s+/g,' ')
    .trim();
}

function typeset(root){
  if(window.MathJax && MathJax.typesetPromise){
    MathJax.typesetPromise(root ? [root] : undefined).catch(()=>{});
  }
}

/* ====== Aide pour la population √©tudi√©e (jamais "individus de l'√©tude") ====== */
const POP_RULES = [
  // On ne se base plus sur "match" mais sur un mot-cl√© pr√©sent dans l‚Äôintro
  { keyword:'jeunes',    label:'les jeunes de 16 √† 25 ans' },
  { keyword:'lyceens',   label:'les lyc√©ens' },
  { keyword:'eleves',    label:'les √©l√®ves' },
  { keyword:'lyc√©ens',   label:'les lyc√©ens' }, // au cas o√π, m√™me si normalis√©
  { keyword:'√©l√®ves',    label:'les √©l√®ves' },

  { keyword:'patients',  label:'les patients' },
  { keyword:'patient',   label:'le patient suivi' },

  { keyword:'clients',   label:'les clients' },
  { keyword:'abonnes',   label:'les abonn√©s' },
  { keyword:'abonn√©s',   label:'les abonn√©s' },
  { keyword:'adherents', label:'les adh√©rents' },
  { keyword:'adh√©rents', label:'les adh√©rents' },

  { keyword:'familles',  label:'les familles' },
  { keyword:'licencies', label:'les licenci√©s' },
  { keyword:'licenci√©s', label:'les licenci√©s' },
  { keyword:'membres',   label:'les membres' },
  { keyword:'personnes', label:'les personnes interrog√©es' },

  // Q-continu : animaux / objets
  { keyword:'lapins',    label:'les lapins de l‚Äô√©levage' },
  { keyword:'voitures',  label:'les voitures contr√¥l√©es' },
  { keyword:'bagages',   label:'les bagages enregistr√©s' },

  // cas "√©l√®ve unique" ‚Üí on garde √©l√®ve comme population
  { keyword:'eleve',     label:'l‚Äô√©l√®ve suivi' },
  { keyword:'√©l√®ve',     label:'l‚Äô√©l√®ve suivi' }
];

function getPopRuleFromIntro(intro){
  const plain = normalizeStr(intro);       // texte "plat" sans accents
  for(const rule of POP_RULES){
    const key = normalizeStr(rule.keyword);
    if(!key) continue;

    // on teste le mot-cl√©, puis sa version singulier si elle finit par "s"
    if (plain.includes(key)) return rule;
    if (key.endsWith('s')) {
      const sing = key.slice(0,-1);
      if (plain.includes(sing)) return rule;
    }
  }
  return null;
}

function getPopulationLabel(intro){
  const r = getPopRuleFromIntro(intro);
  if (r) return r.label;

  // Fallback "propre" : plus jamais "les individus de l‚Äô√©tude"
  return 'la population d√©crite dans l‚Äô√©nonc√©';
}

function checkPopulationAnswer(inputValue,intro){
  const ans = normalizeStr(inputValue);
  if (!ans) return null; // on ne compte pas si vide

  const r = getPopRuleFromIntro(intro);
  if (r) {
    const key = normalizeStr(r.keyword || r.label);
    // on exige que la r√©ponse contienne le mot-cl√©
    return ans.includes(key);
  }

  // Fallback : on demande au moins que la r√©ponse reprenne un mot "important"
  // de l‚Äôintro ‚Üí on regarde si un des mots de la r√©ponse appara√Æt dans l‚Äôintro.
  const plainIntro = normalizeStr(intro);
  const wordsIntro = new Set(plainIntro.split(/\s+/));
  const wordsAns   = ans.split(/\s+/);
  const hasCommon  = wordsAns.some(w => wordsIntro.has(w));

  return hasCommon;
}


/* ====== Contextes ====== */

/* 20 contextes quantitatif discret */
const CTX_QDISCRET = [
  {intro:`Une soci√©t√© de pr√™t-√†-porter √©tudie le <strong>nombre de jeans achet√©s en un an</strong> par des jeunes de 16 √† 25 ans.`, varName:`nombre de jeans achet√©s`, xLabel:`Nombre de jeans achet√©s`, min:0, max:6},
  {intro:`Un cin√©ma fait une enqu√™te sur le <strong>nombre de s√©ances vues en un mois</strong> par des lyc√©ens.`, varName:`nombre de s√©ances de cin√©ma vues en un mois`, xLabel:`Nombre de s√©ances`, min:0, max:6},
  {intro:`Un professeur de math√©matiques s‚Äôint√©resse au <strong>nombre d‚Äôexercices de maths faits par semaine</strong> par ses √©l√®ves.`, varName:`nombre d‚Äôexercices faits par semaine`, xLabel:`Nombre d‚Äôexercices`, min:0, max:7},
  {intro:`Un club de sport √©tudie le <strong>nombre d‚Äôentra√Ænements hebdomadaires</strong> de ses adh√©rents.`, varName:`nombre d‚Äôentra√Ænements par semaine`, xLabel:`Nombre d‚Äôentra√Ænements`, min:0, max:5},
  {intro:`Une m√©diath√®que observe le <strong>nombre de livres emprunt√©s en un trimestre</strong> par ses abonn√©s.`, varName:`nombre de livres emprunt√©s en un trimestre`, xLabel:`Nombre de livres`, min:0, max:6},
  {intro:`Un lyc√©e √©tudie le <strong>nombre de correspondants par messages instantan√©s</strong> qu‚Äôont les √©l√®ves chaque jour.`, varName:`nombre de correspondants par jour`, xLabel:`Nombre de correspondants`, min:0, max:5},
  {intro:`Une agence de voyage √©tudie le <strong>nombre de voyages √† l‚Äô√©tranger effectu√©s en 3 ans</strong> par des familles.`, varName:`nombre de voyages √† l‚Äô√©tranger en 3 ans`, xLabel:`Nombre de voyages`, min:0, max:4},
  {intro:`Un club de lecture compte le <strong>nombre de r√©unions auxquelles participent les membres dans le mois</strong>.`, varName:`nombre de r√©unions de lecture dans le mois`, xLabel:`Nombre de r√©unions`, min:0, max:6},
  {intro:`Une association sportive √©tudie le <strong>nombre de comp√©titions auxquelles participent les licenci√©s dans l‚Äôann√©e</strong>.`, varName:`nombre de comp√©titions dans l‚Äôann√©e`, xLabel:`Nombre de comp√©titions`, min:0, max:7},
  {intro:`Une salle de jeux vid√©o observe le <strong>nombre de visites par mois</strong> de ses abonn√©s.`, varName:`nombre de visites de la salle par mois`, xLabel:`Nombre de visites`, min:0, max:6},
  {intro:`Une auto-√©cole observe le <strong>nombre de le√ßons de conduite suivies par semaine</strong> par ses √©l√®ves.`, varName:`nombre de le√ßons de conduite par semaine`, xLabel:`Nombre de le√ßons`, min:0, max:5},
  {intro:`Un club de natation √©tudie le <strong>nombre de fois o√π les adh√©rents vont √† la piscine par semaine</strong>.`, varName:`nombre de s√©ances de piscine par semaine`, xLabel:`Nombre de s√©ances`, min:0, max:6},
  {intro:`Une plateforme de streaming √©tudie le <strong>nombre de s√©ries diff√©rentes regard√©es dans le mois</strong> par ses abonn√©s.`, varName:`nombre de s√©ries regard√©es dans le mois`, xLabel:`Nombre de s√©ries`, min:0, max:7},
  {intro:`Un lyc√©e √©tudie le <strong>nombre de clubs ou activit√©s p√©riscolaires</strong> auxquels participent les √©l√®ves.`, varName:`nombre de clubs ou activit√©s p√©riscolaires suivis`, xLabel:`Nombre d‚Äôactivit√©s`, min:0, max:5},
  {intro:`Un magasin de sport s‚Äôint√©resse au <strong>nombre de paires de chaussures de sport poss√©d√©es</strong> par ses clients.`, varName:`nombre de paires de chaussures de sport`, xLabel:`Nombre de paires`, min:0, max:6},
  {intro:`Une biblioth√®que scolaire compte le <strong>nombre de fois o√π les √©l√®ves viennent travailler sur place dans le mois</strong>.`, varName:`nombre de visites au CDI dans le mois`, xLabel:`Nombre de visites`, min:0, max:6},
  {intro:`Un coach scolaire rel√®ve le <strong>nombre de s√©ances de r√©vision organis√©es chaque semaine</strong> par ses √©l√®ves.`, varName:`nombre de s√©ances de r√©vision par semaine`, xLabel:`Nombre de s√©ances`, min:0, max:5},
  {intro:`Une association de musique observe le <strong>nombre de concerts assist√©s dans l‚Äôann√©e</strong> par ses adh√©rents.`, varName:`nombre de concerts vus dans l‚Äôann√©e`, xLabel:`Nombre de concerts`, min:0, max:6},
  {intro:`Une √©cole de danse √©tudie le <strong>nombre de cours suivis par semaine</strong> par ses √©l√®ves.`, varName:`nombre de cours de danse par semaine`, xLabel:`Nombre de cours`, min:0, max:5},
  {intro:`Un club de randonn√©e observe le <strong>nombre de sorties effectu√©es dans le trimestre</strong> par ses membres.`, varName:`nombre de sorties de randonn√©e dans le trimestre`, xLabel:`Nombre de sorties`, min:0, max:7}
];

/* 20 contextes qualitatif */
const CTX_QUALI = [
  {intro:`Voici un sondage concernant le <strong>moyen de transport</strong> utilis√© par les √©l√®ves pour venir au lyc√©e.`, varName:`moyen de transport`, categories:['√† pied','en v√©lo','en bus','dans la voiture des parents']},
  {intro:`On interroge une classe sur leur <strong>boisson pr√©f√©r√©e au petit-d√©jeuner</strong>.`, varName:`boisson pr√©f√©r√©e au petit-d√©jeuner`, categories:['lait','caf√©','th√©','jus de fruits']},
  {intro:`Un club sportif demande aux licenci√©s leur <strong>sport pr√©f√©r√© √† pratiquer</strong>.`, varName:`sport pr√©f√©r√©`, categories:['football','basket-ball','tennis','natation']},
  {intro:`Une enqu√™te porte sur le <strong>r√©seau social le plus utilis√©</strong> par les √©l√®ves.`, varName:`r√©seau social le plus utilis√©`, categories:['Instagram','TikTok','Snapchat','Autre']},
  {intro:`On interroge des √©l√®ves sur leur <strong>mati√®re pr√©f√©r√©e</strong> au lyc√©e.`, varName:`mati√®re pr√©f√©r√©e`, categories:['Math√©matiques','Fran√ßais','Histoire-G√©ographie','EPS']},
  {intro:`Une cantine scolaire demande aux √©l√®ves leur <strong>plat pr√©f√©r√©</strong>.`, varName:`plat pr√©f√©r√©`, categories:['p√¢tes','pizza','poisson','salade']},
  {intro:`Une biblioth√®que interroge des lyc√©ens sur leur <strong>type de livre pr√©f√©r√©</strong>.`, varName:`type de livre pr√©f√©r√©`, categories:['roman','manga','BD','documentaire']},
  {intro:`Un sondage porte sur le <strong>mode de logement</strong> des √©l√®ves.`, varName:`mode de logement`, categories:['chez les parents','en internat','en colocation','autre']},
  {intro:`On interroge des √©l√®ves sur leur <strong>activit√© principale apr√®s les cours</strong>.`, varName:`activit√© principale apr√®s les cours`, categories:['devoirs','sport','√©crans','sorties entre amis']},
  {intro:`Une association culturelle demande aux √©l√®ves leur <strong>type de film pr√©f√©r√©</strong>.`, varName:`type de film pr√©f√©r√©`, categories:['com√©die','action','science-fiction','animation']},
  {intro:`On demande aux √©l√®ves leur <strong>animal de compagnie pr√©f√©r√©</strong>.`, varName:`animal de compagnie pr√©f√©r√©`, categories:['chien','chat','rongeur','aucun']},
  {intro:`Un sondage porte sur le <strong>repas pr√©f√©r√© de la journ√©e</strong>.`, varName:`repas pr√©f√©r√© de la journ√©e`, categories:['petit-d√©jeuner','d√©jeuner','go√ªter','d√Æner']},
  {intro:`Une association √©tudie le <strong>type de musique le plus √©cout√©</strong> par les √©l√®ves.`, varName:`type de musique le plus √©cout√©`, categories:['rap','pop','rock','classique']},
  {intro:`On interroge des √©l√®ves sur leur <strong>moment pr√©f√©r√© de la semaine</strong>.`, varName:`moment pr√©f√©r√© de la semaine`, categories:['d√©but de semaine','milieu de semaine','vendredi','week-end']},
  {intro:`Un sondage porte sur la <strong>fa√ßon de r√©viser pr√©f√©r√©e</strong> des √©l√®ves.`, varName:`fa√ßon de r√©viser pr√©f√©r√©e`, categories:['seul','en groupe','avec un professeur','je ne r√©vise pas']},
  {intro:`On demande aux √©l√®ves par quel <strong>moyen de communication</strong> ils contactent le plus leurs amis.`, varName:`moyen de communication principal`, categories:['messages','appels','r√©seaux sociaux','en face √† face']},
  {intro:`Une enqu√™te porte sur la <strong>langue vivante pr√©f√©r√©e</strong> parmi celles √©tudi√©es au lyc√©e.`, varName:`langue vivante pr√©f√©r√©e`, categories:['anglais','espagnol','allemand','autre']},
  {intro:`On interroge des √©l√®ves sur leur <strong>moment pr√©f√©r√© de la journ√©e</strong>.`, varName:`moment pr√©f√©r√© de la journ√©e`, categories:['matin','apr√®s-midi','soir','nuit']},
  {intro:`Une √©tude porte sur le <strong>type de support utilis√© pour lire</strong>.`, varName:`support de lecture pr√©f√©r√©`, categories:['livre papier','tablette','t√©l√©phone','ordinateur']},
  {intro:`On demande √† des lyc√©ens quel est leur <strong>mode de travail pr√©f√©r√© en classe</strong>.`, varName:`mode de travail pr√©f√©r√© en classe`, categories:['seul','en bin√¥me','en petits groupes','en classe enti√®re']},
];

/* 20 contextes quantitatif continu */
const CTX_QCONTINU = [
  {intro:`Le taux de calcium dans le sang d‚Äôun patient (en mg/L) est surveill√© chaque jour pendant deux mois.`, varName:`taux de calcium dans le sang`, unit:`mg/L`, min:70, max:120, step:10},
  {intro:`On mesure chaque jour la <strong>temp√©rature ext√©rieure maximale</strong> (en ¬∞C) pendant un mois d‚Äôhiver.`, varName:`temp√©rature maximale ext√©rieure`, unit:`¬∞C`, min:-5, max:15, step:5},
  {intro:`Un professeur note la <strong>dur√©e de r√©vision quotidienne</strong> (en minutes) d‚Äôun √©l√®ve pendant 6 semaines.`, varName:`dur√©e de r√©vision quotidienne`, unit:`minutes`, min:0, max:180, step:30},
  {intro:`On mesure la <strong>dur√©e d‚Äôappel t√©l√©phonique</strong> (en minutes) de clients dans une journ√©e.`, varName:`dur√©e d‚Äôappel t√©l√©phonique`, unit:`minutes`, min:0, max:30, step:5},
  {intro:`Dans une salle de sport, on rel√®ve la <strong>dur√©e d‚Äôun entra√Ænement</strong> (en minutes) pour plusieurs adh√©rents.`, varName:`dur√©e d‚Äôun entra√Ænement`, unit:`minutes`, min:30, max:120, step:15},
  {intro:`Un laboratoire mesure la <strong>glyc√©mie √† jeun</strong> (en mg/dL) de patients.`, varName:`glyc√©mie √† jeun`, unit:`mg/dL`, min:60, max:140, step:20},
  {intro:`Un radar enregistre la <strong>vitesse de voitures</strong> (en km/h) sur une portion de route limit√©e √† 90 km/h.`, varName:`vitesse de voitures`, unit:`km/h`, min:40, max:120, step:10},
  {intro:`On mesure la <strong>taille d‚Äô√©l√®ves</strong> (en cm) d‚Äôune classe de seconde.`, varName:`taille des √©l√®ves`, unit:`cm`, min:140, max:200, step:10},
  {intro:`Un √©leveur note le <strong>poids de lapins</strong> (en kg) dans son √©levage.`, varName:`poids de lapins`, unit:`kg`, min:1, max:6, step:1},
  {intro:`Une station m√©t√©o mesure la <strong>quantit√© de pluie tomb√©e</strong> (en mm) chaque jour pendant 2 mois.`, varName:`quantit√© de pluie tomb√©e`, unit:`mm`, min:0, max:50, step:10},
  {intro:`On mesure la <strong>dur√©e de trajet domicile‚Äìlyc√©e</strong> (en minutes) d‚Äô√©l√®ves.`, varName:`dur√©e du trajet domicile‚Äìlyc√©e`, unit:`minutes`, min:0, max:60, step:10},
  {intro:`Un cardiologue rel√®ve la <strong>fr√©quence cardiaque au repos</strong> (en battements par minute) de patients.`, varName:`fr√©quence cardiaque au repos`, unit:`bpm`, min:40, max:100, step:10},
  {intro:`Un fabricant mesure la <strong>masse de barres de chocolat</strong> (en g).`, varName:`masse de barres de chocolat`, unit:`g`, min:80, max:140, step:10},
  {intro:`On mesure la <strong>consommation √©lectrique quotidienne</strong> d‚Äôun logement (en kWh) sur deux mois.`, varName:`consommation √©lectrique quotidienne`, unit:`kWh`, min:4, max:16, step:2},
  {intro:`Une compagnie a√©rienne rel√®ve le <strong>poids des bagages en soute</strong> (en kg) sur un vol.`, varName:`poids des bagages en soute`, unit:`kg`, min:5, max:30, step:5},
  {intro:`On mesure la <strong>dur√©e de visionnage de vid√©os</strong> (en minutes) sur une plateforme en ligne.`, varName:`dur√©e de visionnage d‚Äôune vid√©o`, unit:`minutes`, min:0, max:50, step:10},
  {intro:`Un m√©decin suit la <strong>temp√©rature d‚Äôun patient</strong> (en ¬∞C) toutes les 6 heures.`, varName:`temp√©rature du patient`, unit:`¬∞C`, min:35, max:41, step:1},
  {intro:`Une entreprise mesure le <strong>temps de traitement</strong> (en secondes) d‚Äôun programme informatique.`, varName:`temps de traitement d‚Äôun programme`, unit:`secondes`, min:0, max:10, step:2},
  {intro:`On mesure la <strong>distance parcourue lors d‚Äôun footing</strong> (en km) pour plusieurs personnes.`, varName:`distance parcourue lors d‚Äôun footing`, unit:`km`, min:0, max:20, step:4},
  {intro:`Une √©tude note le <strong>temps pass√© chaque jour sur les √©crans</strong> (en heures) par des lyc√©ens.`, varName:`temps pass√© sur les √©crans par jour`, unit:`heures`, min:0, max:8, step:1}
];

/* ====== G√©n√©ration de tableaux fr√©quences/FCC ====== */
function genEffectifsFromMinMax(minVal,maxVal){
  const values=[];
  for(let v=minVal; v<=maxVal; v++) values.push(v);
  const n = values.length;
  const eff = [];
  let tot = 0;
  for(let i=0;i<n;i++){
    const e = rint(5,80);
    eff.push(e); tot+=e;
  }
  return {values, eff, total:tot};
}
function genEffectifsFromLabels(labels){
  const n = labels.length;
  const eff = [];
  let tot = 0;
  for(let i=0;i<n;i++){
    const e = rint(5,60);
    eff.push(e); tot+=e;
  }
  return {eff, total:tot};
}
function genFreqAndFCC(eff,total){
  const n = eff.length;
  const freqRaw = eff.map(e=>e/total);
  const freq = new Array(n);
  let sum = 0;
  for(let i=0;i<n;i++){
    if(i<n-1){
      const r = Math.round(freqRaw[i]*100)/100;
      freq[i]=r;
      sum+=r;
    }else{
      freq[i] = Math.round((1-sum)*100)/100;
    }
  }
  const fcc = new Array(n);
  let c = 0;
  for(let i=0;i<n;i++){
    c += freq[i];
    if(i<n-1) fcc[i] = Math.round(c*100)/100;
    else fcc[i] = 1;
  }
  return {freq,fcc};
}

/* ====== Exercice 1 : quantitatif discret ====== */
const ex1 = {
  id:'stat_qdiscret',
  title:'Caract√®re quantitatif discret',
  gen(){
    const ctx = choice(CTX_QDISCRET);
    const base = genEffectifsFromMinMax(ctx.min, ctx.max);
    const ff  = genFreqAndFCC(base.eff, base.total);
    const n = base.values.length;

    const idxFreq = pickInnerIndex(n);
    const idxFCC  = pickInnerIndex(n);

    return {
      kind:'qdiscret',
      ctx,
      values: base.values,
      eff: base.eff,
      total: base.total,
      freq: ff.freq,
      fcc: ff.fcc,
      qFreqIndex: idxFreq,
      qFCCIndex: idxFCC
    };
  },
  render(host,st){
    const ctx = st.ctx;
    const n = st.values.length;
    let thVals = '';
    let tdEff  = '';
    let tdFreq = '';
    let tdFCC  = '';
    for(let i=0;i<n;i++){
      thVals += `<th>${st.values[i]}</th>`;
      tdEff  += `<td>${st.eff[i]}</td>`;
      tdFreq += `<td><input type="text" data-role="freq" data-i="${i}"></td>`;
      tdFCC  += `<td><input type="text" data-role="fcc" data-i="${i}"></td>`;
    }
    thVals += `<th>Total</th>`;
    tdEff  += `<td><input type="text" data-role="effTot"></td>`;
    tdFreq += `<td><input type="text" data-role="freqTot"></td>`;
    // case FCC totale gris√©es, sans nombre √† √©crire :
    tdFCC  += `<td class="fcc-total"></td>`;

    const vFreq = st.values[st.qFreqIndex];
    const vFCC  = st.values[st.qFCCIndex];

    host.innerHTML = `
      <p>${ctx.intro}</p>
      <p>On a relev√©, pour chaque valeur possible du caract√®re <em>${ctx.varName}</em>, le nombre d‚Äôindividus correspondants.</p>

      <table class="tbl-solution pdfb">
        <thead>
          <tr>
            <th>${ctx.xLabel}</th>
            ${thVals}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Effectif</td>
            ${tdEff}
          </tr>
          <tr>
            <td>Fr√©quence</td>
            ${tdFreq}
          </tr>
          <tr>
            <td>FCC</td>
            ${tdFCC}
          </tr>
        </tbody>
      </table>

      <div class="q-block">
        <p><strong>1.</strong> Donner la population √©tudi√©e, le caract√®re √©tudi√© ainsi que son type (quantitatif discret, quantitatif continu ou qualitatif).</p>
        <p>Population √©tudi√©e : <input type="text" id="q1-pop"></p>
        <p>Caract√®re √©tudi√© : <input type="text" id="q1-carac"></p>
        <p>Type de caract√®re : <input type="text" id="q1-type"></p>

        <p><strong>2.</strong> Compl√©ter la ligne des fr√©quences (valeurs d√©cimales) puis la ligne des fr√©quences cumul√©es croissantes (FCC).</p>
        <p><strong>3.</strong> Quelle est la fr√©quence des individus pour lesquels le <em>${ctx.varName}</em> est √©gal √† <strong>${vFreq}</strong> ? 
        <input type="text" id="q1-freq"></p>
        <p><strong>4.</strong> D√©terminer la proportion d‚Äôindividus pour lesquels le <em>${ctx.varName}</em> est inf√©rieure ou √©gale √† <strong>${vFCC}</strong>. 
        <input type="text" id="q1-fcc"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
  },
  correct(host,st){
    let ok=0, tot=0;

    // Q1 : population
    const popInp = $('#q1-pop',host);
    if(popInp){
      const val = popInp.value.trim();
      if(!val){
        setTick(popInp,'nu');
      }else{
        const good = checkPopulationAnswer(val, st.ctx.intro);
        tot++;
        if(good){ ok++; setTick(popInp,'ok'); } else setTick(popInp,'ko');
      }
    }
    // Q1 : caract√®re
    const caracInp = $('#q1-carac',host);
    if(caracInp){
      const val = caracInp.value.trim();
      if(!val){
        setTick(caracInp,'nu');
      }else{
        const ans = normalizeStr(val);
        const exp = normalizeStr(st.ctx.varName);
        tot++;
        if(ans === exp){ ok++; setTick(caracInp,'ok'); } else setTick(caracInp,'ko');
      }
    }
    // Q1 : type
    const typeInp = $('#q1-type',host);
    if(typeInp){
      const raw = typeInp.value.trim();
      if(!raw){
        setTick(typeInp,'nu');
      }else{
        const norm = normalizeStr(raw);
        const exp = normalizeStr('quantitatif discret');
        tot++;
        if(norm === exp){ ok++; setTick(typeInp,'ok'); } else setTick(typeInp,'ko');
      }
    }

    const n = st.values.length;

    // fr√©quences
    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v, st.freq[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });
    const fTotInp = host.querySelector('input[data-role="freqTot"]');
    if(fTotInp){
      const s = fTotInp.value.trim();
      if(!s){
        setTick(fTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,1)){ ok++; setTick(fTotInp,'ok'); } else setTick(fTotInp,'ko');
      }
    }

    // FCC (sans total)
    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v, st.fcc[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });

    // effectif total
    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp){
      const s = effTotInp.value.trim();
      if(!s){
        setTick(effTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,st.total)){ ok++; setTick(effTotInp,'ok'); } else setTick(effTotInp,'ko');
      }
    }

    // Q3 : fr√©quence
    const q1 = $('#q1-freq',host);
    if(q1){
      const s = q1.value.trim();
      if(!s){
        setTick(q1,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.freq[st.qFreqIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q1,'ok'); } else setTick(q1,'ko');
      }
    }

    // Q4 : proportion via FCC
    const q2 = $('#q1-fcc',host);
    if(q2){
      const s = q2.value.trim();
      if(!s){
        setTick(q2,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.fcc[st.qFCCIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q2,'ok'); } else setTick(q2,'ko');
      }
    }

    return {ok,total:tot};
  },
    solution(host,st){
    const popSol   = getPopulationLabel(st.ctx.intro);
    const caracSol = st.ctx.varName;
    const typeSol  = 'quantitatif discret';

    // on remplit les inputs pour l‚Äô√©l√®ve (√©cran)
    const popInp = $('#q1-pop',host);
    if(popInp) popInp.value = popSol;
    const caracInp = $('#q1-carac',host);
    if(caracInp) caracInp.value = caracSol;
    const typeInp = $('#q1-type',host);
    if(typeInp) typeInp.value = typeSol;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const i = Number(inp.dataset.i);
      inp.value = fmtFreq(st.freq[i]);
    });
    const fTotInp = host.querySelector('input[data-role="freqTot"]');
    if(fTotInp) fTotInp.value = fmtFreq(1);

    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const i = Number(inp.dataset.i);
      inp.value = fmtFreq(st.fcc[i]);
    });

    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp) effTotInp.value = st.total;

    $('#q1-freq',host).value = fmtFreq(st.freq[st.qFreqIndex]);
    $('#q1-fcc',host).value  = fmtFreq(st.fcc[st.qFCCIndex]);

    // bloc explicatif (utilis√© aussi par le PDF)
    const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>{ s.innerHTML = html; });
    typeset(host);
  },

  printSolutionHTML(st){
    const ctx   = st.ctx;
    const n     = st.values.length;
    const vFreq = st.values[st.qFreqIndex];
    const vFCC  = st.values[st.qFCCIndex];

    const popSol   = getPopulationLabel(st.ctx.intro);
    const caracSol = st.ctx.varName;
    const typeSol  = 'quantitatif discret';

    // explications des fr√©quences + %
    const expFreq = st.values.map((v,i)=>{
      const dec = fmtFreq(st.freq[i]);
      const pct = Math.round(st.freq[i]*100);
      return `\\(f(${v}) =  \\dfrac{${st.eff[i]}}{${st.total}} \\approx ${dec} \\), soit \\(${pct} \\)%.`;
    });

    const decQ3 = fmtFreq(st.freq[st.qFreqIndex]);
    const pctQ3 = Math.round(st.freq[st.qFreqIndex]*100);
    const decQ4 = fmtFreq(st.fcc[st.qFCCIndex]);
    const pctQ4 = Math.round(st.fcc[st.qFCCIndex]*100);

    // tableau compl√©t√©
    let hHead = `<tr><th>${st.ctx.xLabel}</th>`;
    for(let i=0;i<n;i++) hHead += `<th>${st.values[i]}</th>`;
    hHead += `<th>Total</th></tr>`;

    let rowEff  = `<tr><td>Effectif</td>`;
    let rowFreq = `<tr><td>Fr√©quence</td>`;
    let rowFCC  = `<tr><td>FCC</td>`;
    for(let i=0;i<n;i++){
      rowEff  += `<td>${st.eff[i]}</td>`;
      rowFreq += `<td>${fmtFreq(st.freq[i])}</td>`;
      rowFCC  += `<td>${fmtFreq(st.fcc[i])}</td>`;
    }
    rowEff  += `<td>${st.total}</td></tr>`;
    rowFreq += `<td>${fmtFreq(1)}</td></tr>`;
    rowFCC  += `<td class="fcc-total"></td></tr>`;

    const tblHtml = `
      <table class="tbl-solution pdfb">
        <thead>${hHead}</thead>
        <tbody>${rowEff}${rowFreq}${rowFCC}</tbody>
      </table>
    `;

    return `
      <div class="step"><strong>R√©ponse √† la question 1 :</strong><br>
      Population √©tudi√©e : ${popSol}.<br>
      Caract√®re √©tudi√© : ${caracSol}.<br>
      Type : ${typeSol}.</div>

      <div class="step"><strong>Calcul des fr√©quences :</strong></div>
      <div class="step">${expFreq.join('<br>')}</div>

      <div class="step"><strong>R√©ponse √† la question 2 :</strong><br>
      On obtient le tableau compl√©t√© suivant :</div>
      <div class="step">${tblHtml}</div>

      <div class="step"><strong>R√©ponse √† la question 3 :</strong><br>
      La fr√©quence des individus pour lesquels le <em>${ctx.varName}</em> est √©gal √† <strong>${vFreq}</strong> vaut \\(${decQ3}\\), soit \\(${pctQ3} \\) %.</div>

      <div class="step"><strong>R√©ponse √† la question 4 :</strong><br>
      La proportion d‚Äôindividus pour lesquels le <em>${ctx.varName}</em> est inf√©rieure ou √©gale √† <strong>${vFCC}</strong> vaut \\(${decQ4}\\), soit environ \\(${pctQ4}\\) %.</div>
    `;
  },


  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};


/* ====== Exercice 2 : qualitatif ====== */
const ex2 = {
  id:'stat_qualitatif',
  title:'Caract√®re qualitatif',
  gen(){
    const ctx = choice(CTX_QUALI);
    const effData = genEffectifsFromLabels(ctx.categories);
    const ff = genFreqAndFCC(effData.eff, effData.total);
    const n = ctx.categories.length;

    const idxFreq = pickInnerIndex(n);
    const idxFCC  = pickInnerIndex(n);

    return {
      kind:'qualitatif',
      ctx,
      categories: ctx.categories,
      eff: effData.eff,
      total: effData.total,
      freq: ff.freq,
      fcc: ff.fcc,
      qFreqIndex: idxFreq,
      qFCCIndex: idxFCC
    };
  },
  render(host,st){
    const ctx = st.ctx;
    const n = st.categories.length;
    let thVals='', tdEff='', tdFreq='', tdFCC='';
    for(let i=0;i<n;i++){
      thVals += `<th>${st.categories[i]}</th>`;
      tdEff  += `<td>${st.eff[i]}</td>`;
      tdFreq += `<td><input type="text" data-role="freq" data-i="${i}"></td>`;
      tdFCC  += `<td><input type="text" data-role="fcc" data-i="${i}"></td>`;
    }
    thVals += `<th>Total</th>`;
    tdEff  += `<td><input type="text" data-role="effTot"></td>`;
    tdFreq += `<td><input type="text" data-role="freqTot"></td>`;
    tdFCC  += `<td class="fcc-total"></td>`;

    const cFreq = st.categories[st.qFreqIndex];
    const upTo  = st.categories.slice(0, st.qFCCIndex+1);

    host.innerHTML = `
      <p>${ctx.intro}</p>
      <p>On obtient les effectifs suivants en fonction du <em>${ctx.varName}</em> :</p>

      <table class="tbl-solution pdfb">
        <thead>
          <tr>
            <th>${ctx.varName}</th>
            ${thVals}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Effectif</td>
            ${tdEff}
          </tr>
          <tr>
            <td>Fr√©quence</td>
            ${tdFreq}
          </tr>
          <tr>
            <td>FCC</td>
            ${tdFCC}
          </tr>
        </tbody>
      </table>

      <div class="q-block">
        <p><strong>1.</strong> Donner la population √©tudi√©e, le caract√®re √©tudi√© ainsi que son type (quantitatif discret, quantitatif continu ou qualitatif).</p>
        <p>Population √©tudi√©e : <input type="text" id="q1-pop"></p>
        <p>Caract√®re √©tudi√© : <input type="text" id="q1-carac"></p>
        <p>Type de caract√®re : <input type="text" id="q1-type"></p>

        <p><strong>2.</strong> Compl√©ter la ligne des fr√©quences puis la ligne des fr√©quences cumul√©es croissantes (FCC).</p>
        <p><strong>3.</strong> Quelle est la fr√©quence des individus dont le <em>${ctx.varName}</em> est <strong>${cFreq}</strong> ? 
        <input type="text" id="q2-freq"></p>
        <p><strong>4.</strong> D√©terminer la fr√©quence des individus dont le <em>${ctx.varName}</em> appartient √† l‚Äôun des cas suivants : <strong>${upTo.join(', ')}</strong>. 
        <input type="text" id="q2-fcc"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
  },
  correct(host,st){
    let ok=0, tot=0;

    // Q1 population
    const popInp = $('#q1-pop',host);
    if(popInp){
      const val = popInp.value.trim();
      if(!val){
        setTick(popInp,'nu');
      }else{
        const good = checkPopulationAnswer(val, st.ctx.intro);
        tot++;
        if(good){ ok++; setTick(popInp,'ok'); } else setTick(popInp,'ko');
      }
    }
    // Q1 caract√®re
    const caracInp = $('#q1-carac',host);
    if(caracInp){
      const val = caracInp.value.trim();
      if(!val){
        setTick(caracInp,'nu');
      }else{
        const ans = normalizeStr(val);
        const exp = normalizeStr(st.ctx.varName);
        tot++;
        if(ans === exp){ ok++; setTick(caracInp,'ok'); } else setTick(caracInp,'ko');
      }
    }
    // Q1 type
    const typeInp = $('#q1-type',host);
    if(typeInp){
      const raw = typeInp.value.trim();
      if(!raw){
        setTick(typeInp,'nu');
      }else{
        const norm = normalizeStr(raw);
        const exp = normalizeStr('qualitatif');
        tot++;
        if(norm === exp){ ok++; setTick(typeInp,'ok'); } else setTick(typeInp,'ko');
      }
    }

    const n = st.categories.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.freq[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });
    const fTot = host.querySelector('input[data-role="freqTot"]');
    if(fTot){
      const s = fTot.value.trim();
      if(!s){
        setTick(fTot,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,1)){ ok++; setTick(fTot,'ok'); } else setTick(fTot,'ko');
      }
    }

    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.fcc[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });

    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp){
      const s = effTotInp.value.trim();
      if(!s){
        setTick(effTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,st.total)){ ok++; setTick(effTotInp,'ok'); } else setTick(effTotInp,'ko');
      }
    }

    const q1 = $('#q2-freq',host);
    if(q1){
      const s = q1.value.trim();
      if(!s){
        setTick(q1,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.freq[st.qFreqIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q1,'ok'); } else setTick(q1,'ko');
      }
    }

    const q2 = $('#q2-fcc',host);
    if(q2){
      const s = q2.value.trim();
      if(!s){
        setTick(q2,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.fcc[st.qFCCIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q2,'ok'); } else setTick(q2,'ko');
      }
    }

    return {ok,total:tot};
  },
  solution(host,st){
      const ctx = st.ctx;
    const cFreq = st.categories[st.qFreqIndex];
    const upTo  = st.categories.slice(0, st.qFCCIndex+1);
	
    const popSol = getPopulationLabel(st.ctx.intro);
    const caracSol = st.ctx.varName;
    const typeSol = 'qualitatif';

    const popInp = $('#q1-pop',host);
    if(popInp) popInp.value = popSol;
    const caracInp = $('#q1-carac',host);
    if(caracInp) caracInp.value = caracSol;
    const typeInp = $('#q1-type',host);
    if(typeInp) typeInp.value = typeSol;

    const n = st.categories.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const i = Number(inp.dataset.i);
      inp.value = fmtFreq(st.freq[i]);
    });
    const fTot=host.querySelector('input[data-role="freqTot"]');
    if(fTot) fTot.value = fmtFreq(1);
    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const i = Number(inp.dataset.i);
      inp.value = fmtFreq(st.fcc[i]);
    });
    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp) effTotInp.value = st.total;

    $('#q2-freq',host).value = fmtFreq(st.freq[st.qFreqIndex]);
    $('#q2-fcc',host).value  = fmtFreq(st.fcc[st.qFCCIndex]);

     const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML=html);
    typeset(host);
  },

  printSolutionHTML(st){
    const ctx   = st.ctx;
    const n     = st.categories.length;
    const cFreq = st.categories[st.qFreqIndex];
    const upTo  = st.categories.slice(0, st.qFCCIndex+1);

    const popSol   = getPopulationLabel(st.ctx.intro);
    const caracSol = st.ctx.varName;
    const typeSol  = 'qualitatif';

    const expFreq = st.categories.map((c,i)=>{
      const dec = fmtFreq(st.freq[i]);
      const pct = Math.round(st.freq[i]*100);
      return `Pour ¬´ ${c} ¬ª : \\( f = \\dfrac{${st.eff[i]}}{${st.total}} \\approx ${dec} \\), soit \\(${pct}\\) %.`;
    });

    const decQ3 = fmtFreq(st.freq[st.qFreqIndex]);
    const pctQ3 = Math.round(st.freq[st.qFreqIndex]*100);
    const decQ4 = fmtFreq(st.fcc[st.qFCCIndex]);
    const pctQ4 = Math.round(st.fcc[st.qFCCIndex]*100);

    let hHead = `<tr><th>${st.ctx.varName}</th>`;
    for(let i=0;i<n;i++) hHead += `<th>${st.categories[i]}</th>`;
    hHead += `<th>Total</th></tr>`;

    let rowEff  = `<tr><td>Effectif</td>`;
    let rowFreq = `<tr><td>Fr√©quence</td>`;
    let rowFCC  = `<tr><td>FCC</td>`;
    for(let i=0;i<n;i++){
      rowEff  += `<td>${st.eff[i]}</td>`;
      rowFreq += `<td>${fmtFreq(st.freq[i])}</td>`;
      rowFCC  += `<td>${fmtFreq(st.fcc[i])}</td>`;
    }
    rowEff  += `<td>${st.total}</td></tr>`;
    rowFreq += `<td>${fmtFreq(1)}</td></tr>`;
    rowFCC  += `<td class="fcc-total"></td></tr>`;

    const tblHtml = `
      <table class="tbl-solution pdfb">
        <thead>${hHead}</thead>
        <tbody>${rowEff}${rowFreq}${rowFCC}</tbody>
      </table>
    `;

    return `
      <div class="step"><strong>R√©ponse √† la question 1 :</strong><br>
      Population √©tudi√©e : ${popSol}.<br>
      Caract√®re √©tudi√© : ${caracSol}.<br>
      Type : ${typeSol}.</div>

      <div class="step"><strong>Calcul des fr√©quences :</strong></div>
      <div class="step">${expFreq.join('<br>')}</div>

      <div class="step"><strong>R√©ponse √† la question 2 :</strong><br>
      On obtient le tableau compl√©t√© suivant :</div>
      <div class="step">${tblHtml}</div>

      <div class="step"><strong>R√©ponse √† la question 3 :</strong><br>
      La fr√©quence des individus dont le <em>${ctx.varName}</em> est <strong>${cFreq}</strong> vaut \\(${decQ3}\\), soit \\(${pctQ3}\\) %.</div>

      <div class="step"><strong>R√©ponse √† la question 4 :</strong><br>
      La fr√©quence des individus dont le <em>${ctx.varName}</em> appartient √† l‚Äôun des cas suivants : <strong>${upTo.join(', ')}</strong> vaut \\(${decQ4}\\), soit environ \\(${pctQ4}\\) %.</div>
    `;
  },


  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};


/* ====== Exercice 3 : quantitatif continu ====== */
const ex3 = {
  id:'stat_qcontinu',
  title:'Caract√®re quantitatif continu',
  gen(){
    const ctx = choice(CTX_QCONTINU);
    const intervals = [];
    for(let a=ctx.min; a<ctx.max; a+=ctx.step){
      intervals.push({a,b:a+ctx.step});
    }
    const effData = genEffectifsFromLabels(intervals);
    const ff = genFreqAndFCC(effData.eff, effData.total);
    const n = intervals.length;

    const idxFreq = pickInnerIndex(n);
    const idxFCC  = pickInnerIndex(n);

    return {
      kind:'qcontinu',
      ctx,
      intervals,
      eff: effData.eff,
      total: effData.total,
      freq: ff.freq,
      fcc: ff.fcc,
      qFreqIndex: idxFreq,
      qFCCIndex: idxFCC
    };
  },
  render(host,st){
    const ctx = st.ctx;
    const n   = st.intervals.length;
    let thVals='', tdEff='', tdFreq='', tdFCC='';
    for(let i=0;i<n;i++){
      const I = st.intervals[i];
      thVals += `<th>[${I.a} ; ${I.b}[</th>`;
      tdEff  += `<td>${st.eff[i]}</td>`;
      tdFreq += `<td><input type="text" data-role="freq" data-i="${i}"></td>`;
      tdFCC  += `<td><input type="text" data-role="fcc" data-i="${i}"></td>`;
    }
    thVals += `<th>Total</th>`;
    tdEff  += `<td><input type="text" data-role="effTot"></td>`;
    tdFreq += `<td><input type="text" data-role="freqTot"></td>`;
    tdFCC  += `<td class="fcc-total"></td>`;

    const Iq = st.intervals[st.qFreqIndex];
    const Jq = st.intervals[st.qFCCIndex];

    host.innerHTML = `
      <p>${ctx.intro}</p>
      <p>On regroupe les valeurs du caract√®re <em>${ctx.varName}</em> (en ${ctx.unit}) par classes d‚Äôamplitude r√©guli√®re :</p>

      <table class="tbl-solution pdfb">
        <thead>
          <tr>
            <th>${ctx.varName} (${ctx.unit})</th>
            ${thVals}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Nombre d‚Äôobservations</td>
            ${tdEff}
          </tr>
          <tr>
            <td>Fr√©quence</td>
            ${tdFreq}
          </tr>
          <tr>
            <td>FCC</td>
            ${tdFCC}
          </tr>
        </tbody>
      </table>

      <div class="q-block">
        <p><strong>1.</strong> Donner la population √©tudi√©e, le caract√®re √©tudi√© ainsi que son type (quantitatif discret, quantitatif continu ou qualitatif).</p>
        <p>Population √©tudi√©e : <input type="text" id="q1-pop"></p>
        <p>Caract√®re √©tudi√© : <input type="text" id="q1-carac"></p>
        <p>Type de caract√®re : <input type="text" id="q1-type"></p>

        <p><strong>2.</strong> Compl√©ter la ligne des fr√©quences (valeurs d√©cimales) puis la ligne des fr√©quences cumul√©es croissantes (FCC).</p>
        <p><strong>3.</strong> Quelle est la fr√©quence correspondant √† une valeur de <em>${ctx.varName}</em> comprise entre <strong>${Iq.a}</strong> et <strong>${Iq.b}</strong> ${ctx.unit} ? 
        <input type="text" id="q3-freq"></p>
        <p><strong>4.</strong> Donner (√† 10<sup>-2</sup> pr√®s) la proportion d‚Äôobservations pour lesquelles <em>${ctx.varName}</em> est strictement inf√©rieure √† <strong>${Jq.b}</strong> ${ctx.unit}. 
        <input type="text" id="q3-fcc"></p>
      </div>

      <div class="steps screen-only"></div>
      <div class="steps print-only"></div>
    `;
    clearTicks(host);
  },
  correct(host,st){
    let ok=0, tot=0;

    // Q1 population
    const popInp = $('#q1-pop',host);
    if(popInp){
      const val = popInp.value.trim();
      if(!val){
        setTick(popInp,'nu');
      }else{
        const good = checkPopulationAnswer(val, st.ctx.intro);
        tot++;
        if(good){ ok++; setTick(popInp,'ok'); } else setTick(popInp,'ko');
      }
    }
    // Q1 caract√®re
    const caracInp = $('#q1-carac',host);
    if(caracInp){
      const val = caracInp.value.trim();
      if(!val){
        setTick(caracInp,'nu');
      }else{
        const ans = normalizeStr(val);
        const exp = normalizeStr(st.ctx.varName);
        tot++;
        if(ans === exp){ ok++; setTick(caracInp,'ok'); } else setTick(caracInp,'ko');
      }
    }
    // Q1 type
    const typeInp = $('#q1-type',host);
    if(typeInp){
      const raw = typeInp.value.trim();
      if(!raw){
        setTick(typeInp,'nu');
      }else{
        const norm = normalizeStr(raw);
        const exp = normalizeStr('quantitatif continu');
        tot++;
        if(norm === exp){ ok++; setTick(typeInp,'ok'); } else setTick(typeInp,'ko');
      }
    }

    const n = st.intervals.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.freq[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });
    const fTot = host.querySelector('input[data-role="freqTot"]');
    if(fTot){
      const s = fTot.value.trim();
      if(!s){
        setTick(fTot,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,1)){ ok++; setTick(fTot,'ok'); } else setTick(fTot,'ko');
      }
    }

    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const s = inp.value.trim();
      if(!s){
        setTick(inp,'nu');
        return;
      }
      const i = Number(inp.dataset.i);
      const v = parseNumber(s);
      tot++;
      if(approxEqual(v,st.fcc[i])){ ok++; setTick(inp,'ok'); }
      else setTick(inp,'ko');
    });

    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp){
      const s = effTotInp.value.trim();
      if(!s){
        setTick(effTotInp,'nu');
      }else{
        const v = parseNumber(s);
        tot++;
        if(approxEqual(v,st.total)){ ok++; setTick(effTotInp,'ok'); } else setTick(effTotInp,'ko');
      }
    }

    const q1 = $('#q3-freq',host);
    if(q1){
      const s = q1.value.trim();
      if(!s){
        setTick(q1,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.freq[st.qFreqIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q1,'ok'); } else setTick(q1,'ko');
      }
    }

    const q2 = $('#q3-fcc',host);
    if(q2){
      const s = q2.value.trim();
      if(!s){
        setTick(q2,'nu');
      }else{
        const v = parseNumber(s);
        const exp = st.fcc[st.qFCCIndex];
        tot++;
        if(approxEqual(v,exp)){ ok++; setTick(q2,'ok'); } else setTick(q2,'ko');
      }
    }

    return {ok,total:tot};
  },
  solution(host,st){
      const ctx = st.ctx;
    const Iq = st.intervals[st.qFreqIndex];
    const Jq = st.intervals[st.qFCCIndex];
	
    const popSol = getPopulationLabel(st.ctx.intro);
    const caracSol = st.ctx.varName;
    const typeSol = 'quantitatif continu';

    const popInp = $('#q1-pop',host);
    if(popInp) popInp.value = popSol;
    const caracInp = $('#q1-carac',host);
    if(caracInp) caracInp.value = caracSol;
    const typeInp = $('#q1-type',host);
    if(typeInp) typeInp.value = typeSol;

    const n = st.intervals.length;

    host.querySelectorAll('input[data-role="freq"]').forEach(inp=>{
      const i = Number(inp.dataset.i);
      inp.value = fmtFreq(st.freq[i]);
    });
    const fTot = host.querySelector('input[data-role="freqTot"]');
    if(fTot) fTot.value = fmtFreq(1);
    host.querySelectorAll('input[data-role="fcc"]').forEach(inp=>{
      const i = Number(inp.dataset.i);
      inp.value = fmtFreq(st.fcc[i]);
    });
    const effTotInp = host.querySelector('input[data-role="effTot"]');
    if(effTotInp) effTotInp.value = st.total;

    $('#q3-freq',host).value = fmtFreq(st.freq[st.qFreqIndex]);
    $('#q3-fcc',host).value  = fmtFreq(st.fcc[st.qFCCIndex]);

       const html = this.printSolutionHTML(st);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML=html);
    typeset(host);
  },

  printSolutionHTML(st){
    const ctx = st.ctx;
    const n   = st.intervals.length;
    const Iq  = st.intervals[st.qFreqIndex];
    const Jq  = st.intervals[st.qFCCIndex];

    const popSol   = getPopulationLabel(st.ctx.intro);
    const caracSol = st.ctx.varName;
    const typeSol  = 'quantitatif continu';

    const expFreq = st.intervals.map((I,i)=>{
      const dec = fmtFreq(st.freq[i]);
      const pct = Math.round(st.freq[i]*100);
      return `Pour la classe [${I.a};${I.b}[ : \\( f = \\dfrac{${st.eff[i]}}{${st.total}} \\approx ${dec} \\), soit \\(${pct}\\) %.`;
    });

    const decQ3 = fmtFreq(st.freq[st.qFreqIndex]);
    const pctQ3 = Math.round(st.freq[st.qFreqIndex]*100);
    const decQ4 = fmtFreq(st.fcc[st.qFCCIndex]);
    const pctQ4 = Math.round(st.fcc[st.qFCCIndex]*100);

    let hHead = `<tr><th>${st.ctx.varName} (${st.ctx.unit})</th>`;
    for(let i=0;i<n;i++){
      const I = st.intervals[i];
      hHead += `<th>[${I.a} ; ${I.b}[</th>`;
    }
    hHead += `<th>Total</th></tr>`;

    let rowEff  = `<tr><td>Nombre d‚Äôobservations</td>`;
    let rowFreq = `<tr><td>Fr√©quence</td>`;
    let rowFCC  = `<tr><td>FCC</td>`;
    for(let i=0;i<n;i++){
      rowEff  += `<td>${st.eff[i]}</td>`;
      rowFreq += `<td>${fmtFreq(st.freq[i])}</td>`;
      rowFCC  += `<td>${fmtFreq(st.fcc[i])}</td>`;
    }
    rowEff  += `<td>${st.total}</td></tr>`;
    rowFreq += `<td>${fmtFreq(1)}</td></tr>`;
    rowFCC  += `<td class="fcc-total"></td></tr>`;

    const tblHtml = `
      <table class="tbl-solution pdfb">
        <thead>${hHead}</thead>
        <tbody>${rowEff}${rowFreq}${rowFCC}</tbody>
      </table>
    `;

    return `
      <div class="step"><strong>R√©ponse √† la question 1 :</strong><br>
      Population √©tudi√©e : ${popSol}.<br>
      Caract√®re √©tudi√© : ${caracSol}.<br>
      Type : ${typeSol}.</div>

      <div class="step"><strong>Calcul des fr√©quences :</strong></div>
      <div class="step">${expFreq.join('<br>')}</div>

      <div class="step"><strong>R√©ponse √† la question 2 :</strong><br>
      On obtient le tableau compl√©t√© suivant :</div>
      <div class="step">${tblHtml}</div>

      <div class="step"><strong>R√©ponse √† la question 3 :</strong><br>
      La fr√©quence correspondant √† une valeur de <em>${ctx.varName}</em> comprise entre <strong>${Iq.a}</strong> et <strong>${Iq.b}</strong> ${ctx.unit} vaut \\(${decQ3}\\), soit \\(${pctQ3}\\) %.</div>

      <div class="step"><strong>R√©ponse √† la question 4 :</strong><br>
      La proportion d‚Äôobservations pour lesquelles <em>${ctx.varName}</em> est strictement inf√©rieure √† <strong>${Jq.b}</strong> ${ctx.unit} vaut \\(${decQ4}\\), soit environ \\(${pctQ4}\\) %.</div>
    `;
  },


  reset(host){
    host.querySelectorAll('input[type="text"]').forEach(i=>i.value='');
    clearTicks(host);
    host.querySelectorAll('.steps').forEach(s=>s.innerHTML='');
  }
};


/* ====== Registre & navigation ====== */
const REGISTRY = [ex1,ex2,ex3];
window.REGISTRY = REGISTRY;

function getDefById(id){
  return REGISTRY.find(d=>d.id===id)||REGISTRY[0];
}

function buildOne(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host,st);
  try{
    if(window.MathKbd?.attachAllInputs){
      MathKbd.attachAllInputs(host);
    }
  }catch(_){}
}

function checkAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  const r    = def.correct(host,st)||{ok:0,total:0};
  scoreOK = r.ok;
  scoreTot = r.total;
  updateScore();
}
function showSolution(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  const st   = JSON.parse(host.dataset.state||'{}');
  def.solution(host,st);
}
function resetAll(){
  const def  = getDefById($("#exo-select").value);
  const host = $("#host");
  def.reset(host);
  scoreOK = 0;
  scoreTot = 0;
  updateScore();
}

document.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    checkAll();
  }
});

/* init s√©lecteur + PDF */
(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Statistiques : Effectifs et fr√©quences',
      mountAfterSelector: '.card.small',

      // ‚ûú On force le kit √† utiliser printSolutionHTML(s)
      beforeRender(def, st, isSolution){
        if (isSolution && typeof def.printSolutionHTML === 'function') {
          return { solution: def.printSolutionHTML(st) };
        }
        // sinon comportement normal
        return null;
      }
    });
  } else {
    setTimeout(waitExoPDF, 80);
  }
})();

})();
</script>


</body>
</html>
