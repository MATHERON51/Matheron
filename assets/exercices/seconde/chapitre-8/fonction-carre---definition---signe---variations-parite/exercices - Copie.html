<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Fonction carr√© - D√©finition - Signe - Variations ‚Äì Parit√©</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* √©crase le gras inline sur les z√©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }


/* Variante "grille compl√®te" pour les tableaux d'images f(x) */
table.pdf-tbl.fullgrid{
  border-collapse:collapse;
  border-spacing:0;
}

table.pdf-tbl.fullgrid th,
table.pdf-tbl.fullgrid td{
  border:1.5px solid #000;      /* toutes les bordures visibles */
  padding:8px 10px;
}
.graph svg.grid{
  width:100%;
  height:auto;
}


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Fonction carr√© - D√©finition - Signe - Variations ‚Äì Parit√©</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, √©crire une liste. Exemple : -3;2</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;


function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;

  const { xmin, xmax, ymin, ymax } = opts;

  // nombre de carreaux par unit√© (x et y peuvent √™tre diff√©rents)
  const subDivX = opts.subDivX || 1;   // ex : 3, 4 ou 5
  const subDivY = opts.subDivY || 1;   // ici : 1

  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  // 1) √âtendue en unit√©s
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;

  // 2) Taille d'un carreau en pixels (m√™me pour x et y ‚Üí carr√©s)
  //    Rx * subDivX = nb total de carreaux horizontaux
  //    Ry * subDivY = nb total de carreaux verticaux
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );

  // px par unit√© en x / y
  const sX = cell * subDivX;
  const sY = cell * subDivY;

  // 3) Taille de la zone de trac√© en pixels
  const w = sX * Rx;
  const h = sY * Ry;

  // 4) Centrage de la fen√™tre de trac√©
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;

  // 5) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
svg.setAttribute('width', W);
svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  // fl√®ches
  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  // clip plot
  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  // conversions unit√©s ‚Üí pixels
  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  // cadre
  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // position des axes
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  // grille + graduations
  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', '‚àí');

    // pas en unit√©s pour dessiner chaque carreau
    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    // verticales tous les 1/subDivX
    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      // graduation uniquement si xv entier
      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    // horizontales tous les 1/subDivY
    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  // axes fl√©ch√©s
  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  // inverses (si tu en as besoin ailleurs)
  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}


// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}






const ex1 = {
  id: "images_fonction_carree",
  title: "Images par la fonction carr√©",

  // petite fraction irr√©ductible
  randFracCoprime() {
    const gcd = (a,b)=>{
      a=Math.abs(a); b=Math.abs(b);
      while (b){ const t=b; b=a%b; a=t; }
      return a;
    };
    while (true) {
      const num = rint(1,9);
      const den = rint(2,9);
      if (gcd(num,den) === 1) return {num,den};
    }
  },

  gen() {
    const items = [];

    // 1) Fraction positive
    const fp = this.randFracCoprime();
    items.push({
      kind:"fracPos",
      latex:`\\dfrac{${fp.num}}{${fp.den}}`,
      num:fp.num,
      den:fp.den,
      val:(fp.num*fp.num)/(fp.den*fp.den),
      ansTex:`\\dfrac{${fp.num*fp.num}}{${fp.den*fp.den}}`
    });

    // 2) Fraction n√©gative
    const fn = this.randFracCoprime();
    items.push({
      kind:"fracNeg",
      latex:`-\\dfrac{${fn.num}}{${fn.den}}`,
      num:fn.num,
      den:fn.den,
      val:(fn.num*fn.num)/(fn.den*fn.den),   // image > 0
      ansTex:`\\dfrac{${fn.num*fn.num}}{${fn.den*fn.den}}`
    });

    // 3) Entier n√©gatif
    const k = rint(2,12);
    items.push({
      kind:"entNeg",
      latex:`-${k}`,
      k,
      val:k*k,
      ansTex:`${k*k}`
    });

// 4) racine(a) : a‚àöb
const a = rint(2,9);
const b = rint(2,15);

items.push({
  kind: "rac",
  latex: `${a}\\sqrt{${b}}`,
  a,                    // <-- on stocke a
  b,                    // <-- on stocke b
  val: a * a * b,       // valeur num√©rique de l'image
  ansTex: `${a*a*b}`    // forme finale attendue
});

    // 5) puissance de 10
    const exps = [-3,-2,-1,1,2,3];      // on √©vite 0 pour que ce soit int√©ressant
    const e = choice(exps);
    items.push({
      kind:"pow10",
      latex:`10^{${e}}`,
      exp:e,
      powExp:2*e,
      val:10**(2*e),
      ansTex:`10^{${2*e}}`
    });

    // 6) somme / diff√©rence avec racine (identit√© remarquable)
    const A = rint(1,4);
    const B = rint(2,7);
    const sign = choice(["+","-"]); // a ¬± ‚àöb
    const txt = `${A}${sign}\\sqrt{${B}}`;
    const cst = A*A + B;
    const cross = 2*A;
    const main = (sign==="+")
      ? `${cst} + ${cross}\\sqrt{${B}}`
      : `${cst} - ${cross}\\sqrt{${B}}`;
    const alt  = (sign==="+")
      ? `${A*A} + ${B} + ${cross}\\sqrt{${B}}`
      : `${A*A} + ${B} - ${cross}\\sqrt{${B}}`;

    items.push({
      kind:"idR",
      latex:txt,
      A,B,sign,
      ansList:[main,alt],
      ansTex:main
    });

    // M√©lange de l‚Äôordre des 6 nombres
    items.sort(()=>Math.random()-0.5);

    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>Calculer l‚Äôimage des nombres suivants par la fonction carr√© \\(f(x)=x^2\\) :</div>
      <div class="var-wrap">
        <table class="pdf-tbl fullgrid" style="width:100%;margin-top:8px">
          <tbody>
            ${[0,1].map(row => `
              <tr>
                ${[0,1,2].map(col => {
                  const idx = 3*row+col;
                  const it = st.items[idx];
                  return `
                  <td style="width:33%;vertical-align:top;padding:8px 10px">
                    <div>\\(${it.latex} :\\)</div>
                    <div style="margin-top:10px">
                      <input class="img" data-i="${idx}" type="text"
                             style="width:90%;max-width:180px;text-align:center">
                      <span class="tick nu"></span>
                    </div>
                  </td>`;
                }).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
      <div id="res" class="steps small"></div>
    `;
    host.querySelectorAll('input.img').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const normBasic = s => (s||"")
      .trim()
      .replace(/\u2212/g,"-")       // moins unicode ‚Üí '-'
      .replace(/,/g,".")            // virgule ‚Üí point
      .replace(/\s+/g,"");          // supprime les espaces

    // nombre / fraction / sqrt(...) avec rac / ‚àö
    const parseNumRoot = s => {
      s = (s || "").trim();
      if (!s) return NaN;

      // normalisation de base
      s = s
        .replace(/\u2212/g,"-")     // moins unicode
        .replace(/,/g,".")          // virgule ‚Üí point
        .replace(/\s+/g,"")         // espaces
        .replace(/rac/gi,"sqrt")    // rac(...) ‚Üí sqrt(...)
        .replace(/‚àö/g,"sqrt");      // racine unicode ‚Üí sqrt

      let sign = 1;
      if (s[0] === '+') {
        s = s.slice(1);
      } else if (s[0] === '-') {
        sign = -1;
        s = s.slice(1);
      }

      // forme ¬±sqrt(...)
      if (s.startsWith("sqrt(") && s.endsWith(")")) {
        let inside = s.slice(5, -1);  // contenu des parenth√®ses

        let base;
        if (inside.includes("/")) {
          const [na, da] = inside.split("/");
          const n = Number(na), d = Number(da);
          if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
          base = n / d;
        } else {
          base = Number(inside);
          if (Number.isNaN(base)) return NaN;
        }
        if (base < 0) return NaN;  // on √©vite sqrt de n√©gatif
        return sign * Math.sqrt(base);
      }

      // sinon : nombre / fraction classique
      if (s.includes("/")) {
        const [na, da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d) return NaN;
        return n / d;
      }
      const x = Number(s);
      return Number.isNaN(x) ? NaN : x;
    };

    // normalisation "symbolique" pour les expressions du type 14+6‚àö5
    const normalizeRootStr = s => normBasic(s)
      .toLowerCase()
      .replace(/rac/gi,"sqrt")      // rac ‚Üí sqrt
      .replace(/‚àö/g,"sqrt")        // racine unicode ‚Üí sqrt
      .replace(/\\sqrt\{/g,"sqrt(") // \sqrt{5} ‚Üí sqrt(5
      .replace(/\}/g,"")           // enl√®ve la } finale
      .replace(/\*/g,"");          // tol√®re 6*sqrt(5)

    let ok = 0, tot = 0;   // tot = seulement les champs REMPLIS

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.img[data-i="${i}"]`);
      const raw = inp.value;
      const v = normBasic(raw);

      if (!v) {
        // champ vide ‚Üí tick neutre, pas compt√©
        setTick(inp,"nu");
        return;
      }

      tot++;

      let good = false;

      if (it.kind === "fracPos" || it.kind === "fracNeg" ||
          it.kind === "entNeg"  || it.kind === "rac") {
        const val = parseNumRoot(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - it.val) < 1e-9;
        }
      } else if (it.kind === "pow10") {
        // soit nombre (avec √©ventuellement sqrt), soit √©criture 10^k
        const val = parseNumRoot(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - it.val) < 1e-9;
        } else {
          const w = normBasic(raw);
          if (w.startsWith("10^")) {
            let kStr = w.slice(3);
            if (kStr.startsWith("{") && kStr.endsWith("}")) {
              kStr = kStr.slice(1,-1);
            }
            const k = Number(kStr);
            if (Number.isInteger(k)) good = (k === it.powExp);
          }
        }
      } else if (it.kind === "idR") {
        // Normalisation sp√©ciale pour a + b‚àöc
        const normId = s => (s || "")
          .trim()
          .replace(/\u2212/g, "-")        // moins unicode
          .replace(/,/g, ".")             // virgule
          .replace(/\s+/g, "")            // espaces
          .toLowerCase()
          .replace(/rac/gi, "‚àö")          // rac(...) -> ‚àö(...)
          .replace(/\\sqrt\{([^}]*)\}/g, "‚àö$1") // \sqrt{7} -> ‚àö7
          .replace(/\\sqrt/g, "‚àö")        // \sqrt7 -> ‚àö7
          .replace(/‚àö\(/g, "‚àö")           // ‚àö(7) -> ‚àö7
          .replace(/\)/g, "")             // enl√®ve parenth√®ses restantes
          .replace(/\*/g, "");            // tol√®re 2*‚àö7

        // Parse une expression du type constante + coeff * ‚àö(rad)
        // en (constant, coef, rad). Retourne null si √ßa ne colle pas.
        function parseAplusBrootC(raw) {
          let s = normId(raw);
          if (!s) return null;

          // on transforme les "-" internes en "+-" pour pouvoir splitter sur "+"
          if (s.startsWith("-")) {
            s = "-" + s.slice(1).replace(/-/g, "+-");
          } else {
            s = s.replace(/-/g, "+-");
          }

          const terms = [];
          let cur = "";
          for (let i = 0; i < s.length; i++) {
            const ch = s[i];
            if (ch === "+" && i > 0) {
              terms.push(cur);
              cur = "";
            } else {
              cur += ch;
            }
          }
          if (cur) terms.push(cur);

          let rad = null;
          let coef = 0;
          let constant = 0;

          for (const t0 of terms) {
            const t = t0;
            if (!t) continue;

            if (t.includes("‚àö")) {
              const parts = t.split("‚àö");
              let aStr = parts[0];
              const cStr = parts[1];

              if (aStr === "" || aStr === "+") aStr = "1";
              if (aStr === "-") aStr = "-1";

              const a = Number(aStr);
              const c = Number(cStr);
              if (!Number.isFinite(a) || !Number.isFinite(c)) return null;

              if (rad === null) rad = c;
              else if (Math.abs(rad - c) > 1e-9) return null; // deux racines diff√©rentes ‚Üí on refuse

              coef += a;
            } else {
              const k = Number(t);
              if (!Number.isFinite(k)) return null;
              constant += k;
            }
          }

          if (rad === null) return null;  // pas de ‚àö ‚Üí on refuse
          return { constant, coef, rad };
        }

        const parsed = parseAplusBrootC(raw);

        if (!parsed) {
          good = false;
        } else {
          const A = it.A;
          const B = it.B;
          const expectedConst = A * A + B;
          const expectedCoef  = (it.sign === "+") ? 2 * A : -2 * A;

          good =
            Math.abs(parsed.rad      - B)           < 1e-9 &&
            Math.abs(parsed.constant - expectedConst) < 1e-9 &&
            Math.abs(parsed.coef     - expectedCoef)  < 1e-9;
        }
      }




      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    $("#res",host).textContent = "";
    return { ok, total: tot };
  },



  solution(host, st) {
    const box = $("#res",host);

    const solBlock = (it) => {
      let lhs = "";
      const rhsSteps = [];

      if (it.kind === "fracPos" || it.kind === "fracNeg") {
        const n = it.num, d = it.den;
        const N = n*n, D = d*d;
        const arg = (it.kind==="fracPos")
          ? `\\dfrac{${n}}{${d}}`
          : `-\\dfrac{${n}}{${d}}`;

        lhs = `f\\left(${arg}\\right)`;
        rhsSteps.push(
          `\\left(${arg}\\right)^2`,
          `\\dfrac{${n}^2}{${d}^2}`,
          `\\dfrac{${N}}{${D}}`
        );
      }
      else if (it.kind === "entNeg") {
        const k = it.k;
        lhs = `f(-${k})`;
        rhsSteps.push(
          `(-${k})^2`,
          `${k}^2`,
          `${k*k}`
        );
      }
      else if (it.kind === "rac") {
        const a = it.a, b = it.b;
        lhs = `f\\left(${a}\\sqrt{${b}}\\right)`;
        rhsSteps.push(
          `\\left(${a}\\sqrt{${b}}\\right)^2`,
          `${a}^2\\times (\\sqrt{${b}})^2`,
          `${a*a} \\times ${b}`,
          `${a*a*b}`
        );
      }
      else if (it.kind === "pow10") {
        const e  = it.exp;
        const e2 = it.powExp;
        lhs = `f\\left(10^{${e}}\\right)`;
        rhsSteps.push(
          `\\left(10^{${e}}\\right)^2`,
          `10^{${e}\\times 2}`,
          `10^{${e2}}`
        );
      }
      else if (it.kind === "idR") {
        const A = it.A, B = it.B;
        const pm = it.sign === "+" ? "+" : "-";
        const pmWord = pm;
        const cross = 2*A;
        const cst1 = A*A;
        const cst2 = A*A + B;
        const arg = `${A}${pm}\\sqrt{${B}}`;

        lhs = `f\\left(${arg}\\right)`;
        rhsSteps.push(
          `\\left(${arg}\\right)^2`,
          `${A}^2 ${pmWord} 2 \\times ${A} \\times \\sqrt{${B}} + (\\sqrt{${B}})^2`,
          `${cst1} ${pmWord} ${cross}\\sqrt{${B}} + ${B}`,
          `${cst2} ${pmWord} ${cross}\\sqrt{${B}}`
        );
      }

      const rows = rhsSteps.map((tex, idx) => {
        // on regarde s'il y a une fraction dans cette ligne
        const hasFrac = /\\dfrac|\\frac|\//.test(tex);
        const vAlign3 = hasFrac ? 'top' : 'middle';

        return `
          <tr>
            <!-- 1 ≥·µâ colonne : f(...) uniquement sur la 1 ≥·µâ ligne -->
            <td style="border:none;padding:0 4px 0 0;white-space:nowrap;vertical-align:middle;line-height:1;min-width:0.8em">
              ${idx === 0 ? `\\(${lhs}\\)` : ""}
            </td>
            <!-- 2·µâ colonne : signe = -->
            <td style="border:none;padding:0 4px 0 0;white-space:nowrap;vertical-align:middle;line-height:1;min-width:0.6em">
              \\(=\\)
            </td>
            <!-- 3·µâ colonne : √©tape -->
            <td style="border:none;padding:0;vertical-align:${vAlign3};text-align:left">
              \\(${tex}\\)
            </td>
          </tr>`;
      }).join("");

      return `
        <table style="border-collapse:collapse;border:none;margin-top:4px">
          <tbody>
            ${rows}
          </tbody>
        </table>`;
    };

    const cell = (idx) => {
      const it = st.items[idx];
      return `
        <td style="vertical-align:top;padding:8px 10px">
          ${solBlock(it)}
        </td>`;
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;margin-top:4px">
        <tbody>
          <tr>
            ${cell(0)}${cell(1)}${cell(2)}
          </tr>
          <tr>
            ${cell(3)}${cell(4)}${cell(5)}
          </tr>
        </tbody>
      </table>
    `;
    typesetAll(box);
  },


  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.img").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};

const ex2 = {
  id: "var_carre_interval",
  title: "Tableau de variations de la fonction carr√© sur un intervalle",

  gen() {
    // 30% intervalle positif, 30% n√©gatif, 40% contenant 0
    const r = Math.random();
    let type, a, b;

    if (r < 0.3) {
      // [a;b] enti√®rement positif
      type = "pos";
      a = rint(1, 5);
      b = rint(a + 1, Math.min(a + 4, 9));
    } else if (r < 0.6) {
      // [a;b] enti√®rement n√©gatif
      type = "neg";
      const A = rint(1, 5);
      const B = rint(A + 1, Math.min(A + 4, 9));
      b = -A;
      a = -B;
    } else {
      // [a;b] contenant 0
      type = "zero";
      do {
        a = -rint(1, 6);
        b =  rint(1, 6);
      } while (Math.abs(a) === b); // on √©vite |a| = b
    }

    const fa = a * a;
    const fb = b * b;

    const extrema = [];
    if (type === "pos") {
      extrema.push({ x: a, y: fa, type: "min" });
      extrema.push({ x: b, y: fb, type: "max" });
    } else if (type === "neg") {
      extrema.push({ x: a, y: fa, type: "max" });
      extrema.push({ x: b, y: fb, type: "min" });
    } else { // zero
      extrema.push({ x: 0, y: 0, type: "min" });
      if (fa > fb) {
        extrema.push({ x: a, y: fa, type: "max" });
      } else if (fb > fa) {
        extrema.push({ x: b, y: fb, type: "max" });
      } else {
        extrema.push({ x: a, y: fa, type: "max" });
        extrema.push({ x: b, y: fb, type: "max" });
      }
    }

    return { type, a, b, fa, fb, extrema };
  },

  render(host, st) {
    const { type, a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;

    // Colonnes de x en fonction du type
    let colsX = [];
    if (type === "pos" || type === "neg") {
      colsX = [a, null, b];           // null = colonne fl√®che
    } else { // zero
      colsX = [a, null, 0, null, b];
    }

    const rowX = `
      <tr>
        <th>\\(x\\)</th>
        ${colsX.map(x =>
          x === null ? `<td></td>` : `<td>\\(${x}\\)</td>`
        ).join("")}
      </tr>`;

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        ${colsX.map((x, idx) => {
          if (x === null) {
            // colonne fl√®che
            return `
              <td class="bigsel">
                <select class="dir" data-i="${idx}"
                        style="display:block;width:100%;height:100%">
                  <option value=""></option>
                  <option>‚Üò</option>
                  <option>‚Üó</option>
                </select>
              </td>`;
          }
          // colonne valeur avec 2 lignes max/min comme dans l'exo 1
          return `
            <td>
              <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
                <input class="ymax" data-x="${x}" type="text" style="width:80px;text-align:center">
                <input class="ymin" data-x="${x}" type="text" style="width:80px;text-align:center">
              </div>
            </td>`;
        }).join("")}
      </tr>`;

    host.innerHTML = `
      <div><b>1.</b> Donner le <b>tableau de variations</b> de la fonction carr√© d√©finie par : \\(f(x)=x^2\\) sur \\(${Itex}\\).</div>


      <div style="margin-top:.6rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> Le <b>minimum</b> de la fonction carr√© sur \\(${Itex}\\) est :</label>
          <input class="qminy" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qminx" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
        </div>
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>3.</b>. Le <b>maximum</b> de la fonction carr√© sur \\(${Itex}\\) est :</label>
          <input class="qmaxy" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <label>atteint en \\(x=\\)</label>
          <input class="qmaxx" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ymax,input.ymin,input.qminy,input.qminx,input.qmaxy,input.qmaxx,select.dir')
        .forEach(ensureTickAfter);

    typesetAll(host);
  },

    correct(host, st) {
    const { type, a, b, fa, fb } = st;

    const norm = s => (s || "").trim().replace(/\u2212/g, "-").replace(/,/g, ".");
    const num  = s => {
      const v = Number(norm(s));
      return Number.isFinite(v) ? v : null;
    };

    // min / max th√©oriques
    let minVal, minX, maxVal, maxX;
    if (type === "pos") {
      minVal = fa; minX = a;
      maxVal = fb; maxX = b;
    } else if (type === "neg") {
      minVal = fb; minX = b;
      maxVal = fa; maxX = a;
    } else {
      minVal = 0;  minX = 0;
      if (Math.abs(a) > Math.abs(b)) {
        maxVal = fa; maxX = a;
      } else {
        maxVal = fb; maxX = b;
      }
    }

    let ok = 0, tot = 0;

    const checkNumInput = (sel, expected) => {
      const inp = host.querySelector(sel);
      if (!inp) return;
      const v = inp.value.trim();
      if (!v) { setTick(inp,"nu"); return; }
      tot++;
      const n = num(v);
      const good = (n !== null && Math.abs(n - expected) < 1e-9);
      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    };

    checkNumInput('.qminy', minVal);
    checkNumInput('.qminx', minX);
    checkNumInput('.qmaxy', maxVal);
    checkNumInput('.qmaxx', maxX);

    return { ok, total: tot };
  },


  solution(host, st) {
  const { type, a, b, fa, fb, extrema } = st;
  const extAt = x => extrema.filter(e => e.x === x);

  const Itex = `[${a}\\,;\\,${b}]`;

  let xs, dirs;
  if (type === "pos" || type === "neg") {
    xs   = [a, b];
    dirs = [type === "pos" ? "‚Üó" : "‚Üò"];
  } else {
    xs   = [a, 0, b];
    dirs = ["‚Üò", "‚Üó"];
  }

  // bloc valeur avec DEUX lignes (haut = max, bas = min) 
  // tout en affichant toujours f(x)
  const valBlock = x => {
    const y = x * x;           // f(x) = x¬≤
    const E = extAt(x);        // liste des extr√©mums √©ventuels en x
    let up = "&nbsp;", dn = "&nbsp;";

    if (E.length) {
      // s'il y a un extremum en x, on place la valeur au bon endroit
      E.forEach(e => {
        if (e.type === "max") up = `\\(${y}\\)`;
        if (e.type === "min") dn = `\\(${y}\\)`;
      });
    } else {
      // pas extremum : on affiche quand m√™me l'image, sur la ligne du bas
      up = `\\(${y}\\)`;
    }

    return `
      <td>
        <div style="text-align:center">${up}</div>
        <div style="height:6px"></div>
        <div style="text-align:center">${dn}</div>
      </td>`;
  };

  // ---- ligne x ----
  let rowX = '<tr><th>\\(x\\)</th>';
  xs.forEach((x, i) => {
    rowX += `<td>\\(${x}\\)</td>`;
    if (i < xs.length - 1) rowX += '<td></td>';  // colonne fl√®che
  });
  rowX += '</tr>';

  // ---- ligne f ----
  let rowF = '<tr><th>\\(f\\)</th>';
  xs.forEach((x, i) => {
    rowF += valBlock(x);
    if (i < xs.length - 1) {
      rowF += `<td>${dirs[i]}</td>`;
    }
  });
  rowF += '</tr>';

  // ---- min / max pour les phrases ----
  let minVal, minX, maxVal, maxX;
  if (type === "pos") {
    minVal = fa; minX = a;
    maxVal = fb; maxX = b;
  } else if (type === "neg") {
    minVal = fb; minX = b;
    maxVal = fa; maxX = a;
  } else {
    minVal = 0;  minX = 0;
    if (Math.abs(a) > Math.abs(b)) {
      maxVal = fa; maxX = a;
    } else {
      maxVal = fb; maxX = b;
    }
  }

  const box = $("#res",host);
  box.innerHTML = `
    <div class="step">
      <b>1.</b> Tableau de variations de la fonction carr√© d√©finie par : \\(f(x)=x^2\\) sur \\(${Itex}\\) :
      <div class="var-wrap" style="margin-top:.4rem">
        <table class="pdf-tbl">
          <thead>${rowX}</thead>
          <tbody>
            ${rowF}
          </tbody>
        </table>
      </div>
    </div>
    <div class="step" style="margin-top:6px">
      <b>2.</b> Sur \\(${Itex}\\), le <b>minimum</b> de la fonction carr√© est
      \\(${minVal}\\), atteint en \\(x=${minX}\\).
    </div>
    <div class="step">
      <b>3.</b> Sur \\(${Itex}\\), le <b>maximum</b> de la fonction carr√© est
      \\(${maxVal}\\), atteint en \\(x=${maxX}\\).
    </div>
  `;
  typesetAll(box);
}
,
  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ymax,input.ymin,input.qminy,input.qminx,input.qmaxy,input.qmaxx,select.dir")
        .forEach(el => {
          if (el.tagName === "INPUT") el.value = "";
          setTick(el,"nu");
        });
  }
};



const ex3 = {
  id: "trace_carre_reperes",
  title: "Tracer la fonction carr√© dans un rep√®re",

  gen() {
    // 3, 4 ou 5 carreaux par unit√© en abscisse
    const subDivX = choice([3,4,5]);
    const k = subDivX;

    // image de ¬± a/k avec a non multiple de k, et |a/k| ‚â§ 3
    let a;
    do {
      a = rint(6, 3 * k);      // 1 .. 3k
    } while (a % k === 0);     // pas multiple de k

    const sign = choice([-1, 1]);
    const xImg = sign * (a / k);
    const yImg = xImg * xImg;

 let yAnte;
    do {
      const idx = rint(3, 16);   // 1..16 ‚Üí 0,5 .. 8
      yAnte = idx * 0.5;
    } while (Math.abs(yAnte - yImg) < 2);  // au moins 2 d'√©cart en ordonn√©e


    return {
      subDivX,
      k,
      a,
      sign,
      xImg,
      yImg,
      yAnte,
      points: [],         // liste de {x,y} sur la courbe
      imagePlaced: false,
      antePlaced: false
    };
  },

  render(host, st) {
    const Itex = "[-3\\,;\\,3]";
    const subDivX = st.subDivX || 3;
    const k       = st.k || subDivX;
    const a       = st.a;
    const sign    = st.sign;
    const xImg    = st.xImg;
    const yImg    = st.yImg;
    const yAnte   = st.yAnte;

    const fracTex = (sign < 0)
      ? `-\\dfrac{${a}}{${k}}`
      : `\\dfrac{${a}}{${k}}`;

    const decFR = x => String(x).replace('.',',');

    host.innerHTML = `
      <ol style="margin:0 0 .4rem 1.2rem;padding:0">
        <li>Dans le rep√®re ci-dessous, repr√©senter graphiquement la fonction carr√©
            \\( f(x) = x^2 \\) sur \\(${Itex}\\).</li>
        <li>En laissant appara√Ætre les traits de construction, indiquer graphiquement&nbsp;:
          <ul style="margin:.3rem 0 .2rem 1.2rem">
            <li>comment d√©terminer l'image de \\(${fracTex}\\)&nbsp;;</li>
            <li>comment d√©terminer les ant√©c√©dents de \\(${decFR(yAnte)}\\).</li>
          </ul>
        </li>
      </ol>

      <div style="margin-top:.4rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label>3.a) Les valeurs exactes des ant√©c√©dents de \\(${decFR(yAnte)}\\) sont :</label>
          <input class="q3a1" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
          <input class="q3a2" type="text" style="width:110px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div style="margin-top:.4rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label>3.b) Ces nombres sont solutions de l‚Äô√©quation :</label>
          <input class="q3b" type="text" style="width:180px;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div class="graph" style="margin-top:.8rem">
        <div id="rep-trace-carre"></div>
      </div>

      <div style="text-align:center;margin-top:.4rem">
        <button type="button" class="btn btn-trace" disabled>Tracer la courbe</button>
        <button type="button" class="btn btn-clear">Enlever les points</button>
        <span class="pt-info" style="margin-left:.5rem;font-size:.9rem">
          Points plac√©s : 0
        </span>
      </div>

      <div style="text-align:center;margin-top:.3rem">
        <button type="button" class="btn btn-img">Placer l'image</button>
        <button type="button" class="btn btn-ante">Placer l'ant√©c√©dent</button>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    // ======= Construction du rep√®re =======
    const mount = $("#rep-trace-carre", host);
    const rep = buildRepereSVG({
      xmin: -3, xmax: 3,
      ymin: -2, ymax: 13,
      grid: true,
      arrows: true,
      subDivX: subDivX, // 3, 4 ou 5 carreaux / unit√© en x
      subDivY: 1        // 1 carreau / unit√© en y
    });
    mount.appendChild(rep.svg);
    // ======================================

    // √©tat interne
    st.points      = Array.isArray(st.points) ? st.points : [];
    st.imagePlaced = !!st.imagePlaced;
    st.antePlaced  = !!st.antePlaced;

    function syncState(){
      // on ne s√©rialise que des donn√©es simples (pas les √©l√©ments DOM)
      const light = {
        subDivX: st.subDivX,
        k:       st.k,
        a:       st.a,
        sign:    st.sign,
        xImg:    st.xImg,
        yImg:    st.yImg,
        yAnte:   st.yAnte,
        points:  st.points,
        imagePlaced: st.imagePlaced,
        antePlaced:  st.antePlaced
      };
      $("#host").dataset.state = JSON.stringify(light);
    }
    syncState();

    const svg      = rep.svg;
    const btnTrace = $(".btn-trace", host);
    const btnClear = $(".btn-clear", host);
    const btnImg   = $(".btn-img", host);
    const btnAnte  = $(".btn-ante", host);
    const ptInfo   = $(".pt-info", host);

    const stepX = 1 / subDivX;       // pas autoris√© en abscisse
    let mode   = "points";           // "points" | "img" | "ante"

    // on garde les cercles dans un tableau s√©par√© (non s√©rialis√©)
    const gPoints = [];

    function updateInfo(){
      ptInfo.textContent = "Points plac√©s : " + st.points.length;
      btnTrace.disabled = st.points.length < 5;
    }
    updateInfo();

    // input ticks
    host.querySelectorAll("input.q3a1,input.q3a2,input.q3b").forEach(ensureTickAfter);

    // --- cr√©ation d‚Äôun point cliquable sur la courbe ---
    function addGraphPoint(x, y){
      const c = document.createElementNS(svg.namespaceURI,"circle");
      c.setAttribute("cx", rep.X(x));
      c.setAttribute("cy", rep.Y(y));
      c.setAttribute("r", 3);
      c.setAttribute("class","g-pt");
      rep.plot.appendChild(c);

      const pt = { x, y };
      st.points.push(pt);
      gPoints.push({ x, y, el: c });

      c.addEventListener("click", ev => {
        ev.stopPropagation();
        // suppression dans st.points
        st.points = st.points.filter(p =>
          Math.abs(p.x - x) > 1e-9 || Math.abs(p.y - y) > 1e-9
        );
        // suppression visuelle
        const idx = gPoints.findIndex(p =>
          Math.abs(p.x - x) < 1e-9 && Math.abs(p.y - y) < 1e-9
        );
        if (idx >= 0) gPoints.splice(idx,1);
        c.remove();
        updateInfo();
        syncState();
      });

      updateInfo();
      syncState();
    }

    // --- bouton "Enlever les points" ---
    btnClear.addEventListener("click", () => {
      st.points = [];
      gPoints.splice(0, gPoints.length);
      rep.plot.querySelectorAll("circle.g-pt").forEach(c => c.remove());
      updateInfo();
      syncState();
    });

    // --- boutons de mode "image" / "ant√©c√©dent" ---
    btnImg.addEventListener("click", () => { mode = "img"; });
    btnAnte.addEventListener("click", () => { mode = "ante"; });

    // --- clic dans la zone du rep√®re ---
    rep.hit.addEventListener("click", e => {
      const rect = svg.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;

      const xReal = rep.Xi(px);
      const yReal = rep.Yi(py);

      // ------- MODE : Placer l'image -------
      if (mode === "img") {
        if (Math.abs(yReal - 0) <= 0.3 && Math.abs(xReal - xImg) <= 0.2) {
          const v = document.createElementNS(svg.namespaceURI,'line');
          v.setAttribute('x1', rep.X(xImg));
          v.setAttribute('x2', rep.X(xImg));
          v.setAttribute('y1', rep.Y(0));
          v.setAttribute('y2', rep.Y(yImg));
          v.setAttribute('stroke', '#1d4ed8');
          v.setAttribute('stroke-width', '1.8');
          v.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(v);

          const h = document.createElementNS(svg.namespaceURI,'line');
          h.setAttribute('x1', rep.X(0));
          h.setAttribute('x2', rep.X(xImg));
          h.setAttribute('y1', rep.Y(yImg));
          h.setAttribute('y2', rep.Y(yImg));
          h.setAttribute('stroke', '#1d4ed8');
          h.setAttribute('stroke-width', '1.8');
          h.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(h);

          st.imagePlaced = true;
          syncState();
        }
        mode = "points";
        return;
      }

      // ------- MODE : Placer l'ant√©c√©dent -------
      if (mode === "ante") {
        const frac = Math.abs(yAnte - Math.round(yAnte)); // ‚âÉ 0,5 ?
        const tolY = (Math.abs(frac - 0.5) < 1e-9) ? 0.1 : 0.2;

        if (Math.abs(xReal - 0) <= 0.3 && Math.abs(yReal - yAnte) <= tolY) {
          const sqrtY = Math.sqrt(yAnte);
          const x1 = -sqrtY;
          const x2 = +sqrtY;

          const h = document.createElementNS(svg.namespaceURI,'line');
          h.setAttribute('x1', rep.X(x1));
          h.setAttribute('x2', rep.X(x2));
          h.setAttribute('y1', rep.Y(yAnte));
          h.setAttribute('y2', rep.Y(yAnte));
          h.setAttribute('stroke', '#b91c1c');
          h.setAttribute('stroke-width', '1.8');
          h.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(h);

          const v1 = document.createElementNS(svg.namespaceURI,'line');
          v1.setAttribute('x1', rep.X(x1));
          v1.setAttribute('x2', rep.X(x1));
          v1.setAttribute('y1', rep.Y(0));
          v1.setAttribute('y2', rep.Y(yAnte));
          v1.setAttribute('stroke', '#b91c1c');
          v1.setAttribute('stroke-width', '1.8');
          v1.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(v1);

          const v2 = document.createElementNS(svg.namespaceURI,'line');
          v2.setAttribute('x1', rep.X(x2));
          v2.setAttribute('x2', rep.X(x2));
          v2.setAttribute('y1', rep.Y(0));
          v2.setAttribute('y2', rep.Y(yAnte));
          v2.setAttribute('stroke', '#b91c1c');
          v2.setAttribute('stroke-width', '1.8');
          v2.setAttribute('stroke-dasharray', '4 3');
          rep.plot.appendChild(v2);

          st.antePlaced = true;
          syncState();
        }
        mode = "points";
        return;
      }

      // ------- MODE : Points de la courbe (trac√©) -------
      const idxX  = Math.round(xReal / stepX);
      const xSnap = idxX * stepX;

      if (xSnap < -3 - 1e-9 || xSnap > 3 + 1e-9) return;
      if (Math.abs(xReal - xSnap) > 0.2) return;

      const yTarget = xSnap * xSnap;
      if (Math.abs(yReal - yTarget) > 0.4) return;

      // toggle : si un point existe d√©j√† tr√®s proche, on le supprime
      const existing = gPoints.find(p =>
        Math.abs(p.x - xSnap) < stepX/2 &&
        Math.abs(p.y - yTarget) < 0.5
      );
      if (existing) {
        existing.el.remove();
        st.points = st.points.filter(p =>
          Math.abs(p.x - existing.x) > 1e-9 || Math.abs(p.y - existing.y) > 1e-9
        );
        const i2 = gPoints.indexOf(existing);
        if (i2 >= 0) gPoints.splice(i2,1);
        updateInfo();
        syncState();
        return;
      }

      addGraphPoint(xSnap, yTarget);
    });

    // bouton "Tracer la courbe" : on trace y = x¬≤
    btnTrace.addEventListener("click", () => {
      if (btnTrace.disabled) return;
      let d = "";
      for (let x = -3; x <= 3.0001; x += 0.03){
        const Xp = rep.X(x);
        const Yp = rep.Y(x*x);
        d += (d ? " L " : "M ") + Xp + " " + Yp;
      }
      addPath(rep.plot, d, { stroke:"#111", "stroke-width":2.2 });
      btnTrace.disabled = true;
    });

    typesetAll(host);
  },

correct(host, st) {
  const yAnte = st.yAnte;   // le nombre dont on cherche les ant√©c√©dents (3, 3.5, 4, ...)

  const norm = s => (s || "")
    .trim()
    .replace(/\s+/g,"")
    .replace(/\u2212/g,"-")   // moins unicode
    .replace(/,/g,".")        // virgule ‚Üí point
    .replace(/‚àö/g,"sqrt")     // racine unicode
    .replace(/rac/gi,"sqrt")  // rac ‚Üí sqrt
    .replace(/¬≤/g,"^2")
    .toLowerCase();

  // extrait (sign, radicande) d‚Äôune √©criture ¬±sqrt(...)
  function parseRootExpr(raw) {
    let s = norm(raw);
    if (!s) return null;

    let sign = +1;
    if (s.startsWith("+")) {
      s = s.slice(1);
    } else if (s.startsWith("-")) {
      sign = -1;
      s = s.slice(1);
    }

    if (!s.startsWith("sqrt(") || !s.endsWith(")")) return null;
    let inside = s.slice(5, -1); // contenu entre parenth√®ses

    let val;
    if (inside.includes("/")) {
      const [na, da] = inside.split("/");
      const n = parseFloat(na), d = parseFloat(da);
      if (!d || isNaN(n) || isNaN(d)) return null;
      val = n / d;
    } else {
      const v = parseFloat(inside);
      if (isNaN(v)) return null;
      val = v;
    }
    return { sign, value: val };
  }

  // parse un nombre ou une fraction (utile pour 3b et pour les entiers des ant√©c√©dents)
  const parseNumberOrFrac = s => {
    s = norm(s);
    if (!s) return null;
    if (s.includes("/")) {
      const [na, da] = s.split("/");
      const n = parseFloat(na), d = parseFloat(da);
      if (!d || isNaN(n) || isNaN(d)) return null;
      return n / d;
    }
    const v = parseFloat(s);
    return isNaN(v) ? null : v;
  };

  // pour 3a) : accepter soit ¬±sqrt(yAnte), soit ¬±‚àö(yAnte), soit ¬± entier si yAnte est un carr√© parfait
  function parseAnteExpr(raw) {
    const EPS = 1e-6;

    // 1) tentative forme racine : ¬±sqrt(...)
    const r = parseRootExpr(raw);
    if (r && Math.abs(r.value - yAnte) < EPS) {
      // on a bien ¬±sqrt(yAnte)
      return { sign: r.sign };
    }

    // 2) tentative forme "entier ou fraction"
    const v = parseNumberOrFrac(raw);
    if (v === null) return null;

    // si v¬≤ = yAnte (au signe pr√®s), c'est un ant√©c√©dent valide
    if (Math.abs(v * v - yAnte) < EPS) {
      const sign = (v > 0) ? +1 : (v < 0 ? -1 : 0);
      if (sign === 0) return null; // 0 ne convient pas sauf si yAnte=0, mais ce cas n'est pas utilis√© ici
      return { sign };
    }

    return null;
  }

  const checkEqInput = sel => {
    const inp = host.querySelector(sel);
    if (!inp) return { ok:false, counted:false };
    const raw = inp.value;
    if (!raw.trim()) { setTick(inp,"nu"); return {ok:false,counted:false}; }

    const s = norm(raw);
    const parts = s.split("=");
    if (parts.length !== 2) { setTick(inp,"ko"); return {ok:false,counted:true}; }

    const left = parts[0], right = parts[1];
    if (left !== "x^2") { setTick(inp,"ko"); return {ok:false,counted:true}; }

    const val = parseNumberOrFrac(right);
    const good = (val !== null && Math.abs(val - yAnte) < 1e-6);

    setTick(inp, good ? "ok" : "ko");
    return { ok:good, counted:true };
  };

  let ok = 0, tot = 0;

  // ========= 3a) PAIRE D‚ÄôANT√âC√âDENTS =========
  const inp1 = host.querySelector(".q3a1");
  const inp2 = host.querySelector(".q3a2");

  const raw1 = inp1 ? inp1.value.trim() : "";
  const raw2 = inp2 ? inp2.value.trim() : "";

  const filled1 = !!raw1;
  const filled2 = !!raw2;

  if (!filled1 && !filled2) {
    // rien rempli ‚Üí tout neutre
    if (inp1) setTick(inp1,"nu");
    if (inp2) setTick(inp2,"nu");
  } else if (filled1 && filled2) {
    // on ne corrige QUE si les deux champs sont remplis
    tot += 2;

    const A1 = parseAnteExpr(raw1);
    const A2 = parseAnteExpr(raw2);

    const valid1 = !!A1;
    const valid2 = !!A2;

    let bothGood = false;
    if (valid1 && valid2 && A1.sign * A2.sign === -1) {
      // un positif et un n√©gatif
      bothGood = true;
    }

    if (bothGood) {
      if (inp1) setTick(inp1,"ok");
      if (inp2) setTick(inp2,"ok");
      ok += 2;
    } else {
      if (inp1) setTick(inp1,"ko");
      if (inp2) setTick(inp2,"ko");
    }
  } else {
    // un seul champ rempli ‚Üí on ne met rien (nu) et on ne compte pas
    if (inp1) setTick(inp1,"nu");
    if (inp2) setTick(inp2,"nu");
  }

  // ========= 3b) √âQUATION =========
  {
    const r = checkEqInput(".q3b");
    if (r.counted) { tot++; if (r.ok) ok++; }
  }

  // ========= PARTIE GRAPHIQUE (points + traits) =========
  // 1 point si ‚â• 5 points sur la courbe
  if (Array.isArray(st.points)) {
    tot++;
    if (st.points.length >= 5) ok++;
  }
  // 1 point si image ET ant√©c√©dent plac√©s
  tot++;
  if (st.imagePlaced && st.antePlaced) ok++;

  const box = $("#res", host);
  if (box) {
    box.innerHTML = `
      <div class="step">
        <b>Partie graphique :</b>
        ${st.points.length >= 5 ? "‚úì" : "‚úó"} au moins 5 points correctement plac√©s,
        ${st.imagePlaced && st.antePlaced ? "‚úì" : "‚úó"} traits de construction de l'image et des ant√©c√©dents plac√©s.
      </div>
    `;
  }

  return { ok, total: tot };
}
,

solution(host, st) {
  const Itex = "[-3\\,;\\,3]";

  const subDivX = st.subDivX || 3;
  const k       = st.k || subDivX;
  const a       = st.a;
  const sign    = st.sign;
  const xImg    = st.xImg;
  const yImg    = st.yImg;
  const yAnte   = st.yAnte;
  const sqrtY   = Math.sqrt(yAnte);

  const fracTex = (sign < 0)
    ? `-\\dfrac{${a}}{${k}}`
    : `\\dfrac{${a}}{${k}}`;

  const decFR = x => String(x).replace('.',',');

  function texFromNumberFr(x) {
    // on veut 3,5 en TeX, etc.
    const rounded = Math.round(x * 10) / 10; // pas de 0,5
    const s = String(rounded);
    if (s.includes(".")) {
      const [a, b] = s.split(".");
      return `${a}{,}${b}`;
    }
    return s;
  }

  const yAnteTex   = texFromNumberFr(yAnte);

  const sqrtYA     = Math.sqrt(yAnte);
  const isPerfect  = Number.isInteger(sqrtYA);
  const k1         = Math.round(sqrtYA);

  const extraPerfect = isPerfect ? `
        \\[
           x = -${k1} \\quad \\text{ou} \\quad x = ${k1}.
        \\]
  ` : "";

  const box = $("#res", host);
  box.innerHTML = `
      <div class="step">
        <b>1.</b> Courbe repr√©sentative de \\(f(x)=x^2\\) sur \\(${Itex}\\), avec traits de construction :
        <div class="graph" style="margin-top:.4rem">
          <div id="rep-trace-carre-sol"></div>
        </div>
      </div>
      <div class="step" style="margin-top:.6rem">
        <b>2.a)</b> Pour d√©terminer \\(f\\left(${fracTex}\\right)\\), on place \\(${fracTex}\\) sur l'axe des abscisses,
        on monte verticalement jusqu'√† la courbe, puis on lit l'ordonn√©e du point obtenu :
        \\[
          f\\left(${fracTex}\\right)
          = \\left(${fracTex}\\right)^2
          = \\dfrac{${a}^2}{${k}^2}
          = \\dfrac{${a*a}}{${k*k}}.
        \\]
      </div>
      <div class="step">
        <b>2.b)</b> Pour d√©terminer les ant√©c√©dents de \\(${decFR(yAnte)}\\), on trace la droite horizontale d'ordonn√©e
        \\(${decFR(yAnte)}\\) ; elle coupe la courbe en deux points. On lit leurs abscisses sur l'axe :
        ce sont les ant√©c√©dents cherch√©s.
      </div>
      <div class="step">
        <b>3.a)</b> Les ant√©c√©dents de \\(${decFR(yAnte)}\\) sont les nombres \\(x\\) tels que
        \\(x^2 = ${decFR(yAnte)}\\). On obtient :
        \\[
          x = -\\sqrt{${decFR(yAnte)}} \\quad \\text{ou} \\quad x = \\sqrt{${decFR(yAnte)}}.
        \\]<br>
        ${extraPerfect}
      </div>
      <div class="step">
        <b>3.b)</b> Ces nombres sont donc les solutions de l'√©quation
        \\[
          x^2 = ${decFR(yAnte)}.
        \\]      
      </div>
    `;

  // ----- Rep√®re de la solution : m√™me subDivX que dans le render -----
  const mount = $("#rep-trace-carre-sol", box);
  mount.style.position = "relative"; // pour l'overlay HTML

  const rep = buildRepereSVG({
    xmin: -3, xmax: 3,
    ymin: -2, ymax: 13,
    grid: true,
    arrows: true,
    subDivX: subDivX,
    subDivY: 1
  });
  mount.appendChild(rep.svg);

  // ----- Courbe f(x) = x¬≤ -----
  let d = "";
  for (let x = -3; x <= 3.0001; x += 0.03){
    const Xp = rep.X(x), Yp = rep.Y(x*x);
    d += (d ? " L " : "M ") + Xp + " " + Yp;
  }
  addPath(rep.plot, d, { stroke:'#111', 'stroke-width':2.2 });

  // =========================
  //  Traits de construction
  // =========================

  // --- 1) Image de xImg : traits en BLEU ---
  (function drawImageConstruction(){
    const x = xImg;
    const y = yImg;

    const v = document.createElementNS(rep.svg.namespaceURI,'line');
    v.setAttribute('x1', rep.X(x));
    v.setAttribute('x2', rep.X(x));
    v.setAttribute('y1', rep.Y(0));
    v.setAttribute('y2', rep.Y(y));
    v.setAttribute('stroke', '#1d4ed8');
    v.setAttribute('stroke-width', '1.8');
    v.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(v);

    const h = document.createElementNS(rep.svg.namespaceURI,'line');
    h.setAttribute('x1', rep.X(0));
    h.setAttribute('x2', rep.X(x));
    h.setAttribute('y1', rep.Y(y));
    h.setAttribute('y2', rep.Y(y));
    h.setAttribute('stroke', '#1d4ed8');
    h.setAttribute('stroke-width', '1.8');
    h.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(h);
  })();

  // --- 2) Ant√©c√©dents de yAnte : traits en ROUGE ---
  (function drawAnteConstruction(){
    const y = yAnte;
    const x1 = -sqrtY;
    const x2 = +sqrtY;

    const h = document.createElementNS(rep.svg.namespaceURI,'line');
    h.setAttribute('x1', rep.X(x1));
    h.setAttribute('x2', rep.X(x2));
    h.setAttribute('y1', rep.Y(y));
    h.setAttribute('y2', rep.Y(y));
    h.setAttribute('stroke', '#b91c1c');
    h.setAttribute('stroke-width', '1.8');
    h.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(h);

    const v1 = document.createElementNS(rep.svg.namespaceURI,'line');
    v1.setAttribute('x1', rep.X(x1));
    v1.setAttribute('x2', rep.X(x1));
    v1.setAttribute('y1', rep.Y(0));
    v1.setAttribute('y2', rep.Y(y));
    v1.setAttribute('stroke', '#b91c1c');
    v1.setAttribute('stroke-width', '1.8');
    v1.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(v1);

    const v2 = document.createElementNS(rep.svg.namespaceURI,'line');
    v2.setAttribute('x1', rep.X(x2));
    v2.setAttribute('x2', rep.X(x2));
    v2.setAttribute('y1', rep.Y(0));
    v2.setAttribute('y2', rep.Y(y));
    v2.setAttribute('stroke', '#b91c1c');
    v2.setAttribute('stroke-width', '1.8');
    v2.setAttribute('stroke-dasharray', '4 3');
    rep.plot.appendChild(v2);
  })();

  // =========================
  //  OVERLAY HTML AVEC VRAI LaTeX
  // =========================
  (function addLatexOverlay(){
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.pointerEvents = 'none'; // pour ne pas g√™ner le SVG
    mount.appendChild(overlay);

    // helper : place un span LaTeX √† la position (xData, yData)
    function addLabel(tex, xData, yData, opts = {}){
      const span = document.createElement('span');
      span.className = 'latex-overlay-label';
      span.style.position = 'absolute';
      span.style.fontSize = '12px';
      span.style.pointerEvents = 'none';
      span.innerHTML = `\\(${tex}\\)`;

      const pt = rep.svg.createSVGPoint();
      pt.x = rep.X(xData);
      pt.y = rep.Y(yData);
      const screen = pt.matrixTransform(rep.svg.getScreenCTM());

      const rect = mount.getBoundingClientRect();
      let x = screen.x - rect.left + (opts.offsetX || 0);
      let y = screen.y - rect.top  + (opts.offsetY || 0);

      span.style.left = x + 'px';
      span.style.top  = y + 'px';

      // alignements simples
      if (opts.align === 'below-center') {
        span.style.transform = 'translate(-50%, 0)';
      } else if (opts.align === 'above-center') {
        span.style.transform = 'translate(-50%, -100%)';
      } else if (opts.align === 'right-middle') {
        span.style.transform = 'translate(0, -50%)';
      }

      overlay.appendChild(span);
    }

    // 1) Abscisse de l‚Äôimage : ¬±a/k (en vraie fraction)
    const fracImgTex = (sign < 0)
      ? `-\\dfrac{${a}}{${k}}`
      : `\\dfrac{${a}}{${k}}`;
    addLabel(fracImgTex, xImg, 0, {
      align: 'below-center',
      offsetY: 4   // sous l'axe des abscisses
    });

    // 2) Ordonn√©e de l‚Äôimage : a¬≤/k¬≤ (√† DROITE de l‚Äôaxe des ordonn√©es)
    const fracOrdTex = `\\dfrac{${a*a}}{${k*k}}`;
    addLabel(fracOrdTex, 0, yImg, {
      align: 'right-middle',
      offsetX: 6   // √† droite de l'axe
    });

    // 3) Ant√©c√©dents : -‚àö(yAnte) et ‚àö(yAnte), AU-DESSUS de l‚Äôaxe des abscisses
    const numFr = yAnteTex;  // ex : 3{,}5
    const leftTex  = `-\\sqrt{${numFr}}`;
    const rightTex = `\\sqrt{${numFr}}`;

    addLabel(leftTex, -sqrtY, 0, {
      align: 'above-center',
      offsetY: -4  // au-dessus de l'axe
    });

    addLabel(rightTex, +sqrtY, 0, {
      align: 'above-center',
      offsetY: -4
    });
  })();

  typesetAll(box);
},




  reset(host) {
    const box = $("#res", host);
    if (box) box.textContent = "";
    host.querySelectorAll("textarea.ans3a,textarea.ans3b").forEach(t => t.value = "");

    // on nettoie aussi les points si l'exercice est encore affich√©
    const mount = $("#rep-trace-carre", host);
    if (mount) {
      mount.querySelectorAll("circle.g-pt").forEach(c => c.remove());
    }
    const s = JSON.parse(host.dataset.state || '{}');
    s.points = [];
    host.dataset.state = JSON.stringify(s);
  }
};


const ex4 = {
  id: "antecedents_carre",
  title: "Ant√©c√©dents par la fonction carr√©",

  gen() {
    const gcd = (a,b)=>{
      a = Math.abs(a); b = Math.abs(b);
      while(b){ const t=b; b=a%b; a=t; }
      return a || 1;
    };
    const isSquare = n => {
      const r = Math.round(Math.sqrt(n));
      return r*r === n;
    };

    // 1) carr√© parfait entier
    const m = rint(1, 8);
    const intPerfVal = m*m;

    // 2) carr√© non parfait
    let n;
    do {
      n = rint(2, 20);
    } while (isSquare(n));

    // 3) carr√© parfait fraction : (p/q)^2
    let p,q;
    do {
      p = rint(1, 6);
      q = rint(2, 8);
    } while (gcd(p,q) !== 1);
    const fracPerfVal = (p*p)/(q*q);

    // 4) nombre n√©gatif
    const negVal = -rint(1, 10);

    const items = [
      { kind:"intPerfect",  y:intPerfVal,   latex:`${intPerfVal}` },
      { kind:"nonPerfect",  y:n,           latex:`${n}` },
      { kind:"fracPerfect", y:fracPerfVal, p, q,        latex:`\\dfrac{${p*p}}{${q*q}}` },
      { kind:"negative",    y:negVal,      latex:`${negVal}` }
    ];

    // m√©lange des lignes
    items.sort(()=>Math.random()-0.5);

    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>
        On consid√®re la fonction carr√© \\(f(x)=x^2\\). Pour chacun des nombres suivants, 
        donner l‚Äôensemble de ses ant√©c√©dents r√©els par \\(f\\).<br>
        <em>Si plusieurs ant√©c√©dents, les √©crire sous la forme d‚Äôune liste s√©par√©e par un point-virgule, par exemple :</em>
        \\(-3;3\\).<br>
        <em>S‚Äôil n‚Äôy a aucun ant√©c√©dent r√©el, √©crire \\(\\varnothing\\) ou ¬´ aucun ¬ª.</em>
      </div>

      <div class="var-wrap" style="margin-top:.5rem">
        <table class="pdf-tbl fullgrid" style="width:100%;max-width:650px">
          <thead>
            <tr>
              <th>Nombre \\(y\\)</th>
              <th>Ant√©c√©dent(s) r√©el(s) par \\(f(x)=x^2\\)</th>
            </tr>
          </thead>
          <tbody>
            ${st.items.map((it,i)=>`
              <tr>
                <td style="width:35%">\\(${it.latex}\\)</td>
                <td>
                  <input class="ante" data-i="${i}" type="text"
                         style="width:95%;max-width:280px;text-align:center">
                  <span class="tick nu"></span>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ante').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const norm = s => (s || "")
      .trim()
      .replace(/\u2212/g,"-")   // moins unicode
      .replace(/,/g,".")        // virgule ‚Üí point
      .replace(/\s+/g,"");      // espaces

    // parse un nombre avec √©ventuellement sqrt / rac / ‚àö
    const parseValue = raw => {
      let s = (raw||"").trim();
      if (!s) return NaN;

      s = s
        .replace(/\u2212/g,"-")
        .replace(/,/g,".")
        .replace(/\s+/g,"")
        .replace(/rac/gi,"sqrt")
        .replace(/‚àö/g,"sqrt");

      let sign = 1;
      if (s[0] === "+") {
        s = s.slice(1);
      } else if (s[0] === "-") {
        sign = -1;
        s = s.slice(1);
      }

      if (s.startsWith("sqrt(") && s.endsWith(")")) {
        let inside = s.slice(5,-1);
        let base;
        if (inside.includes("/")) {
          const [na,da] = inside.split("/");
          const n = Number(na), d = Number(da);
          if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
          base = n/d;
        } else {
          base = Number(inside);
          if (Number.isNaN(base)) return NaN;
        }
        if (base < 0) return NaN;
        return sign * Math.sqrt(base);
      }

      if (s.includes("/")) {
        const [na,da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        return sign * (n/d);
      }

      const x = Number(s);
      return Number.isNaN(x) ? NaN : sign * x;
    };

    const parseListValues = raw => {
      const parts = (raw || "")
        .replace(/,/g,";")
        .split(";")
        .map(t => t.trim())
        .filter(t => t !== "");
      if (!parts.length) return null;
      const vals = [];
      for (const t of parts) {
        const v = parseValue(t);
        if (Number.isNaN(v)) return null;
        vals.push(v);
      }
      return vals;
    };

    let ok = 0, tot = 0;

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.ante[data-i="${i}"]`);
      if (!inp) return;
      const raw = inp.value;
      const trimmed = raw.trim();

      if (!trimmed) {
        setTick(inp,"nu");
        return;
      }

      tot++;

      let good = false;

      if (it.kind === "negative") {
        const s = trimmed.toLowerCase().replace(/\s+/g,"");
        if (
          s === "‚àÖ" || s === "√∏" ||
          s === "vide" || s === "rien" ||
          s.includes("aucun") || s.includes("aucune") ||
          s.includes("pasd")   // "pas d'..."
        ) {
          good = true;
        }
      } else {
        const y = it.y;
        const vals = parseListValues(raw);
        if (vals && vals.length === 2) {
          const v1 = vals[0], v2 = vals[1];
          const eps = 1e-6;
          const ok1 = Math.abs(v1*v1 - y) < eps;
          const ok2 = Math.abs(v2*v2 - y) < eps;
          const opp = Math.sign(v1) === -Math.sign(v2) && Math.abs(v1) > eps && Math.abs(v2) > eps;
          if (ok1 && ok2 && opp) good = true;
        }
      }

      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    const box = $("#res",host);
    if (box) {
      box.innerHTML = `
        <div class="step">
         </div>
      `;
    }

    return { ok, total: tot };
  },

  solution(host, st) {
    const box = $("#res",host);

    const solTex = it => {
      const y = it.y;
      if (it.kind === "intPerfect") {
        const m = Math.round(Math.sqrt(y));
        return `
\\[
\\begin{aligned}
x^2 &= ${y} \\\\
x &= -\\sqrt{${y}} \\quad \\text{ou} \\quad x = \\sqrt{${y}} \\\\
x &= -${m} \\quad \\text{ou} \\quad x = ${m}
\\end{aligned}
\\]`;
      }

      if (it.kind === "nonPerfect") {
        return `
\\[
\\begin{aligned}
x^2 &= ${y} \\\\
x &= -\\sqrt{${y}} \\quad \\text{ou} \\quad x = \\sqrt{${y}}.
\\end{aligned}
\\]`;
      }

      if (it.kind === "fracPerfect") {
        const p = it.p, q = it.q;
        const num = p*p, den = q*q;
        return `
\\[
\\begin{aligned}
x^2 &= \\dfrac{${num}}{${den}} \\\\
x &= -\\sqrt{\\dfrac{${num}}{${den}}} \\quad \\text{ou} \\quad x = \\sqrt{\\dfrac{${num}}{${den}}} \\\\
    &= -\\dfrac{${p}}{${q}} \\quad \\text{ou} \\quad x = \\dfrac{${p}}{${q}}.
\\end{aligned}
\\]`;
      }

      // n√©gatif
      return `
\\[
x^2 = ${y}
\\]
n'admet <b>aucune solution r√©elle</b>, car le carr√© d'un nombre r√©el est toujours positif ou nul.
Il n‚Äôy a donc <b>aucun ant√©c√©dent r√©el</b> de \\(${y}\\) par la fonction carr√©.`;
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;max-width:750px">
        <thead>
          <tr>
            <th>Nombre \\(y\\)</th>
            <th>Correction</th>
          </tr>
        </thead>
        <tbody>
          ${st.items.map(it => `
            <tr>
              <td style="width:30%">\\(${it.latex}\\)</td>
              <td style="vertical-align:top;padding:6px 10px">
                ${solTex(it)}
              </td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;

    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ante").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};


/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2,ex3,ex4];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Fonction carr√© - D√©finition - Signe - Variations ‚Äì Parit√©',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
