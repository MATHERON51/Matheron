<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Fonction carr√© - √âquations - Encadrement ‚Äì In√©quations</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* √©crase le gras inline sur les z√©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }


/* Variante "grille compl√®te" pour les tableaux d'images f(x) */
table.pdf-tbl.fullgrid{
  border-collapse:collapse;
  border-spacing:0;
}

table.pdf-tbl.fullgrid th,
table.pdf-tbl.fullgrid td{
  border:1.5px solid #000;      /* toutes les bordures visibles */
  padding:8px 10px;
}
.graph svg.grid{
  width:100%;
  height:auto;
}


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Fonction carr√© - √âquations - Encadrement ‚Äì In√©quations</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, √©crire une liste. Exemple : -3;2</li>
        <li><b>R√©ponse attendue dans l'exercice 3:</b> √©crire l‚Äôensemble des solutions sous forme
        d‚Äôintervalle(s), par exemple :
        <div style="margin-top:4px;margin-left:10px">
           [-2;2] ou ]-oo;-4]U[4;+oo[.
        </div></li>
      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;


function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;

  const { xmin, xmax, ymin, ymax } = opts;

  // nombre de carreaux par unit√© (x et y peuvent √™tre diff√©rents)
  const subDivX = opts.subDivX || 1;   // ex : 3, 4 ou 5
  const subDivY = opts.subDivY || 1;   // ici : 1

  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  // 1) √âtendue en unit√©s
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;

  // 2) Taille d'un carreau en pixels (m√™me pour x et y ‚Üí carr√©s)
  //    Rx * subDivX = nb total de carreaux horizontaux
  //    Ry * subDivY = nb total de carreaux verticaux
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );

  // px par unit√© en x / y
  const sX = cell * subDivX;
  const sY = cell * subDivY;

  // 3) Taille de la zone de trac√© en pixels
  const w = sX * Rx;
  const h = sY * Ry;

  // 4) Centrage de la fen√™tre de trac√©
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;

  // 5) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
svg.setAttribute('width', W);
svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  // fl√®ches
  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  // clip plot
  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  // conversions unit√©s ‚Üí pixels
  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  // cadre
  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // position des axes
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  // grille + graduations
  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', '‚àí');

    // pas en unit√©s pour dessiner chaque carreau
    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    // verticales tous les 1/subDivX
    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      // graduation uniquement si xv entier
      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    // horizontales tous les 1/subDivY
    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  // axes fl√©ch√©s
  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  // inverses (si tu en as besoin ailleurs)
  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}


// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}


const ex1 = {
  id: "equations_carre",
  title: "R√©soudre des √©quations du type x^2 = a",

  // petits helpers de mise en forme
  fmtAx2(a){
    if (a === 1)  return "x^2";
    if (a === -1) return "-x^2";
    return `${a}x^2`;
  },
  fmtAx(a){
    if (a === 1)  return "x";
    if (a === -1) return "-x";
    return `${a}x`;
  },
  fmtSignedConst(b){
    if (b > 0)  return `+ ${b}`;
    if (b < 0)  return `- ${-b}`;
    return "";             // 0 -> rien
  },
  fmtAxPlusB(a,b){
    const ax = this.fmtAx(a);
    const sc = this.fmtSignedConst(b);
    return sc ? `${ax} ${sc}` : ax;
  },

  gen() {
    const gcd = (a,b)=>{
      a = Math.abs(a); b = Math.abs(b);
      while (b){ const t=b; b=a%b; a=t; }
      return a || 1;
    };
    const isSquare = n => {
      const r = Math.round(Math.sqrt(n));
      return r*r === n;
    };

    // 1) x¬≤ = a positif (parfois carr√© parfait, parfois non)
    let aPos;
    if (Math.random() < 0.5) {
      const m = rint(1,9);         // carr√© parfait
      aPos = m*m;
    } else {
      do {                         // non parfait
        aPos = rint(2,30);
      } while (isSquare(aPos));
    }

    // 2) x¬≤ = a n√©gatif
    const aNeg = -rint(1,10);

    // 3) ax¬≤ + b = c  ‚Üí x¬≤ = (p¬≤)/(q¬≤) avec p,q premiers entre eux
    let p3,q3;
    do {
      p3 = rint(1,6);
      q3 = rint(2,8);
    } while (gcd(p3,q3) !== 1);
    const num3 = p3*p3;      // num√©rateur de k
    const den3 = q3*q3;      // d√©nominateur de k
    const m3   = rint(1,3);  // facteur pour a
    const a3   = m3 * den3;  // a multiple de q¬≤
    let b3;
    do {                     // b ‚â† 0 pour √©viter "+0"
      b3 = rint(-8,8);
    } while (b3 === 0);
    const c3   = b3 + m3*num3;  // pour avoir x¬≤ = num3/den3

    // Latex propre pour a3 x^2 + b3 = c3
    const left3 = `${this.fmtAx2(a3)} ${this.fmtSignedConst(b3)}`.trim();

    // 4) (ax + b)¬≤ = k avec k>0
    const a4  = rint(1,4);
    let b4;
    do { b4 = rint(-5,5); } while (b4 === 0);
    const p4  = rint(1,6);           // ‚àök
    const k4  = p4*p4;               // k
    const inner4 = this.fmtAxPlusB(a4,b4);

    const items = [
      { eqType:"x2_pos",  latex:`x^2 = ${aPos}`, a: aPos },
      { eqType:"x2_neg",  latex:`x^2 = ${aNeg}`, a: aNeg },
      { eqType:"ax2_lin", latex:`${left3} = ${c3}`, a:a3, b:b3, c:c3, p:p3, q:q3, num:num3, den:den3 },
      { eqType:"axp_b_sq", latex:`(${inner4})^2 = ${k4}`, a:a4, b:b4, k:k4, p:p4 }
    ];

    items.sort(()=>Math.random()-0.5);
    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>
        R√©soudre dans \\(\\mathbb{R}\\) les √©quations suivantes.<br>
        <em>√âcrire les solutions sous forme de liste s√©par√©e par un point-virgule.</em><br>
        Exemples : \\(-3;3\\) ou \\(-\\dfrac{2}{5};\\dfrac{2}{5}\\).<br>
        <em>S‚Äôil n‚Äôy a aucune solution r√©elle, √©crire \\(\\varnothing\\) ou ¬´ aucun ¬ª.</em>
      </div>

      <div class="var-wrap" style="margin-top:.5rem">
        <table class="pdf-tbl fullgrid" style="width:100%;max-width:700px">
          <thead>
            <tr>
              <th>√âquation</th>
              <th>Solution(s) r√©elle(s)</th>
            </tr>
          </thead>
          <tbody>
            ${st.items.map((it,i)=>`
              <tr>
                <td style="width:40%">\\(${it.latex}\\)</td>
                <td>
                  <input class="solx" data-i="${i}" type="text"
                         style="width:95%;max-width:280px;text-align:center">
                  <span class="tick nu"></span>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;
    host.querySelectorAll('input.solx').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const norm = s => (s || "")
      .trim()
      .replace(/\u2212/g,"-")
      .replace(/,/g,".")
      .replace(/\s+/g,"")
      .replace(/rac/gi,"sqrt")
      .replace(/‚àö/g,"sqrt");

    const parseValue = raw => {
      let s = norm(raw);
      if (!s) return NaN;

      let sign = 1;
      if (s[0] === "+") {
        s = s.slice(1);
      } else if (s[0] === "-") {
        sign = -1;
        s = s.slice(1);
      }

      if (s.startsWith("sqrt(") && s.endsWith(")")) {
        let inside = s.slice(5,-1);
        let base;
        if (inside.includes("/")) {
          const [na,da] = inside.split("/");
          const n = Number(na), d = Number(da);
          if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
          base = n/d;
        } else {
          base = Number(inside);
          if (Number.isNaN(base)) return NaN;
        }
        if (base < 0) return NaN;
        return sign * Math.sqrt(base);
      }

      if (s.includes("/")) {
        const [na,da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        return sign * (n/d);
      }

      const x = Number(s);
      return Number.isNaN(x) ? NaN : sign * x;
    };

    const parseListValues = raw => {
      const parts = (raw || "")
        .replace(/,/g,";")
        .split(";")
        .map(t => t.trim())
        .filter(t => t !== "");
      if (!parts.length) return null;
      const vals = [];
      for (const t of parts) {
        const v = parseValue(t);
        if (Number.isNaN(v)) return null;
        vals.push(v);
      }
      return vals;
    };

    let ok = 0, tot = 0;

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.solx[data-i="${i}"]`);
      if (!inp) return;
      const raw = inp.value.trim();

      if (!raw) {
        setTick(inp,"nu");
        return;
      }

      tot++;

      const eqType = it.eqType;
      let good = false;
      const EPS = 1e-6;

      if (eqType === "x2_neg") {
        const s = raw.toLowerCase().replace(/\s+/g,"");
        if (
          s === "‚àÖ" || s === "√∏" ||
          s === "vide" || s === "rien" ||
          s.includes("aucun") || s.includes("aucune") ||
          s.includes("pasd")
        ) {
          good = true;
        }
      } else if (eqType === "x2_pos") {
        const a = it.a;
        const vals = parseListValues(raw);
        if (vals && vals.length === 2) {
          const v1 = vals[0], v2 = vals[1];
          const ok1 = Math.abs(v1*v1 - a) < EPS;
          const ok2 = Math.abs(v2*v2 - a) < EPS;
          const opp = Math.sign(v1) === -Math.sign(v2) && Math.abs(v1) > EPS && Math.abs(v2) > EPS;
          if (ok1 && ok2 && opp) good = true;
        }
      } else if (eqType === "ax2_lin") {
        const {a,b,c} = it;
        const vals = parseListValues(raw);
        if (vals && vals.length === 2) {
          const v1 = vals[0], v2 = vals[1];
          const ok1 = Math.abs(a*v1*v1 + b - c) < EPS;
          const ok2 = Math.abs(a*v2*v2 + b - c) < EPS;
          const opp = Math.sign(v1) === -Math.sign(v2) && Math.abs(v1) > EPS && Math.abs(v2) > EPS;
          if (ok1 && ok2 && opp) good = true;
        }
      } else if (eqType === "axp_b_sq") {
        const {a,b,k} = it;
        const vals = parseListValues(raw);
        if (vals && vals.length === 2) {
          const v1 = vals[0], v2 = vals[1];
          const ok1 = Math.abs((a*v1 + b)**2 - k) < EPS;
          const ok2 = Math.abs((a*v2 + b)**2 - k) < EPS;
          const diff = Math.abs(v1 - v2) > EPS;
          if (ok1 && ok2 && diff) good = true;
        }
      }

      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    const box = $("#res",host);
    if (box) {
      box.innerHTML = `
        <div class="step">
          Chaque ligne correctement r√©solue rapporte un point. Pour les √©quations avec \\(x^2\\) ou \\((ax+b)^2\\),
          il fallait trouver toutes les solutions r√©elles. Si le second membre est n√©gatif, il n'y a aucune solution r√©elle.
        </div>
      `;
    }

    return { ok, total: tot };
  },

  solution(host, st) {
  const gcd = (a,b)=>{
    a=Math.abs(a); b=Math.abs(b);
    while (b){ const t=b; b=a%b; a=t; }
    return a||1;
  };
  const fracTex = (num,den) => {
    if (den === 0) return "\\text{ind√©fini}";
    let n=num, d=den;
    const g = gcd(n,d);
    n /= g; d /= g;
    const sign = (d<0 ? -1 : 1);
    n *= sign; d *= sign;
    if (d === 1)  return `${n}`;
    if (d === -1) return `${-n}`;
    return `\\dfrac{${n}}{${d}}`;
  };

  // -------- d√©doublonnage : supprime lignes cons√©cutives identiques --------
  function dedupeRows(rows){
    const out = [];
    for (const row of rows || []) {
      if (!row) continue;
      const lhs = row.lhs || "";
      const rhs = row.rhs || "";
      const last = out[out.length - 1];
      if (last && last.lhs === lhs && last.rhs === rhs) continue;
      out.push({ lhs, rhs });
    }
    return out;
  }

  // -------- petit tableau 3 colonnes : LHS | = | RHS --------
  function makeEqTable(rows){
    const cleaned = dedupeRows(rows);
    const trs = cleaned.map(({lhs, rhs}) => {
      const hasFrac = /\\dfrac|\\frac|\//.test(rhs || "");
      const vAlign3 = hasFrac ? 'top' : 'middle';
      return `
        <tr>
          <td style="border:none;padding:0 4px 0 0;white-space:nowrap;vertical-align:middle;line-height:1;min-width:1.2em;text-align:right">
            ${lhs ? `\\(${lhs}\\)` : ""}
          </td>
          <td style="border:none;padding:0 4px 0 0;white-space:nowrap;vertical-align:middle;line-height:1;min-width:0.6em">
            \\(=\\)
          </td>
          <td style="border:none;padding:0;vertical-align:${vAlign3};text-align:left">
            \\(${rhs}\\)
          </td>
        </tr>`;
    }).join("");

    return `
      <table style="border-collapse:collapse;border:none;margin-top:4px">
        <tbody>
          ${trs}
        </tbody>
      </table>`;
  }

  const solTex = it => {
    const eqType = it.eqType;

    /* ===== 1) x¬≤ = a, a>0 ===== */
    if (eqType === "x2_pos") {
      const a = it.a;
      const r = Math.sqrt(a);
      const isPerf = Number.isInteger(r);

      if (isPerf) {
        const m = r;
        const rows = [
          { lhs: "x^2", rhs: `${a}` },
          { lhs: "x",   rhs: `-\\sqrt{${a}} \\quad \\text{ou} \\quad x = \\sqrt{${a}}` },
          { lhs: "x",   rhs: `-${m} \\quad \\text{ou} \\quad x = ${m}` },
          { lhs: "S",   rhs: `\\left\\{ -${m};${m}\\right\\}` }
        ];
        return makeEqTable(rows);
      }

      const rows = [
        { lhs: "x^2", rhs: `${a}` },
        { lhs: "x",   rhs: `-\\sqrt{${a}} \\quad \\text{ou} \\quad x = \\sqrt{${a}}` },
        { lhs: "S",   rhs: `\\left\\{ -\\sqrt{${a}};\\sqrt{${a}}\\right\\}` }
      ];
      return makeEqTable(rows);
    }

    /* ===== 2) x¬≤ = a, a<0 ===== */
    if (eqType === "x2_neg") {
      const a = it.a;
      return `
\\[
x^2 = ${a}
\\]
n'admet <b>aucune solution r√©elle</b>, car le carr√© d'un nombre r√©el est toujours positif ou nul.
<br> \\(S=\\emptyset\\)
`;
    }

    /* ===== 3) ax¬≤ + b = c  ===== */
    if (eqType === "ax2_lin") {
      const {a,b,c,num,den,p,q} = it;
      const left1 = `${ex1.fmtAx2(a)} ${ex1.fmtSignedConst(b)}`.trim();
      const rhs1  = c - b;   // on √©vite 7-(-5)

      const rows = [
        { lhs: left1,            rhs: `${c}` },
        { lhs: ex1.fmtAx2(a),    rhs: `${rhs1}` },
        { lhs: "x^2",            rhs: `\\dfrac{${rhs1}}{${a}}` },
        { lhs: "x^2",            rhs: `\\dfrac{${num}}{${den}}` },
        { lhs: "x",              rhs: `-\\sqrt{\\dfrac{${num}}{${den}}} \\quad \\text{ou} \\quad x = \\sqrt{\\dfrac{${num}}{${den}}}` },
        { lhs: "x",              rhs: `-\\dfrac{${p}}{${q}} \\quad \\text{ou} \\quad x = \\dfrac{${p}}{${q}}` },
        { lhs: "S",              rhs: `\\left\\{ -\\dfrac{${p}}{${q}};\\dfrac{${p}}{${q}}\\right\\}` }
      ];
      return makeEqTable(rows);
    }

    /* ===== 4) (ax+b)¬≤ = k  ===== */
    if (eqType === "axp_b_sq") {
      const {a,b,k,p} = it;
      const inner = ex1.fmtAxPlusB(a,b);
      const x1Tex = fracTex(-b-p,a);
      const x2Tex = fracTex(-b+p,a);
      const diff1 = -p - b;
      const diff2 =  p - b;

      if (a === 1) {
        // CAS PARTICULIER a = 1 : pas de "1x = ..."
        const rows = [
          { lhs: `(${inner})^2`, rhs: `${k}` },
          { lhs: inner,          rhs: `-\\sqrt{${k}} \\quad \\text{ou} \\quad ${inner} = \\sqrt{${k}}` },
          { lhs: inner,          rhs: `-${p} \\quad \\text{ou} \\quad ${inner} = ${p}` },
          { lhs: "x",            rhs: `${diff1} \\quad \\text{ou} \\quad x = ${diff2}` },
          { lhs: "S",            rhs: `\\left\\{ ${x1Tex};${x2Tex} \\right\\}` }
        ];
        return makeEqTable(rows);
      }

      // CAS G√âN√âRAL a ‚â† 1 : on garde la ligne "ax = ..."
      const rows = [
        { lhs: `(${inner})^2`, rhs: `${k}` },
        { lhs: inner,          rhs: `-\\sqrt{${k}} \\quad \\text{ou} \\quad ${inner} = \\sqrt{${k}}` },
        { lhs: inner,          rhs: `-${p} \\quad \\text{ou} \\quad ${inner} = ${p}` },
        { lhs: `${a}x`,        rhs: `${diff1} \\quad \\text{ou} \\quad ${a}x = ${diff2}` },
        { lhs: "x",            rhs: `${x1Tex} \\quad \\text{ou} \\quad x = ${x2Tex}` },
        { lhs: "S",            rhs: `\\left\\{ ${x1Tex};${x2Tex} \\right\\}` }
      ];
      return makeEqTable(rows);
    }

    return "";
  };

  const box = $("#res",host);
  box.innerHTML = `
    <table class="pdf-tbl fullgrid" style="width:100%;max-width:780px">
      <thead>
        <tr>
          <th>√âquation</th>
          <th>Correction</th>
        </tr>
      </thead>
      <tbody>
        ${st.items.map(it => `
          <tr>
            <td style="width:35%">\\(${it.latex}\\)</td>
            <td style="vertical-align:top;padding:6px 10px">
              ${solTex(it)}
            </td>
          </tr>
        `).join("")}
      </tbody>
    </table>
  `;
  typesetAll(box);
},


  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.solx").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};



const ex2 = {
  id: "var_carre_interval",
  title: "Tableau de variations de la fonction carr√© sur un intervalle",

  gen() {
    // 30% intervalle positif, 30% n√©gatif, 40% contenant 0
    const r = Math.random();
    let type, a, b;

    if (r < 0.3) {
      // [a;b] enti√®rement positif
      type = "pos";
      a = rint(1, 5);
      b = rint(a + 1, Math.min(a + 4, 9));
    } else if (r < 0.6) {
      // [a;b] enti√®rement n√©gatif
      type = "neg";
      const A = rint(1, 5);
      const B = rint(A + 1, Math.min(A + 4, 9));
      b = -A;
      a = -B;
    } else {
      // [a;b] contenant 0
      type = "zero";
      do {
        a = -rint(1, 6);
        b =  rint(1, 6);
      } while (Math.abs(a) === b); // on √©vite |a| = b
    }

    const fa = a * a;
    const fb = b * b;

    const extrema = [];
    if (type === "pos") {
      extrema.push({ x: a, y: fa, type: "min" });
      extrema.push({ x: b, y: fb, type: "max" });
    } else if (type === "neg") {
      extrema.push({ x: a, y: fa, type: "max" });
      extrema.push({ x: b, y: fb, type: "min" });
    } else { // zero
      extrema.push({ x: 0, y: 0, type: "min" });
      if (fa > fb) {
        extrema.push({ x: a, y: fa, type: "max" });
      } else if (fb > fa) {
        extrema.push({ x: b, y: fb, type: "max" });
      } else {
        extrema.push({ x: a, y: fa, type: "max" });
        extrema.push({ x: b, y: fb, type: "max" });
      }
    }

    return { type, a, b, fa, fb, extrema };
  },

  render(host, st) {
    const { type, a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;

    // Colonnes de x en fonction du type
    let colsX = [];
    if (type === "pos" || type === "neg") {
      colsX = [a, null, b];           // null = colonne fl√®che
    } else { // zero
      colsX = [a, null, 0, null, b];
    }

    const rowX = `
      <tr>
        <th>\\(x\\)</th>
        ${colsX.map(x =>
          x === null ? `<td></td>` : `<td>\\(${x}\\)</td>`
        ).join("")}
      </tr>`;

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        ${colsX.map((x, idx) => {
          if (x === null) {
            // colonne fl√®che
            return `
              <td class="bigsel">
                <select class="dir" data-i="${idx}"
                        style="display:block;width:100%;height:100%">
                  <option value=""></option>
                  <option>‚Üò</option>
                  <option>‚Üó</option>
                </select>
              </td>`;
          }
          // colonne valeur avec 2 lignes max/min comme dans l'exo 1
          return `
            <td>
              <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
                <input class="ymax" data-x="${x}" type="text" style="width:80px;text-align:center">
                <input class="ymin" data-x="${x}" type="text" style="width:80px;text-align:center">
              </div>
            </td>`;
        }).join("")}
      </tr>`;

        host.innerHTML = `
      <div><b>1.</b> Donner le <b>tableau de variations</b> de la fonction carr√© d√©finie par : \\(f(x)=x^2\\) sur \\(${Itex}\\).</div>

      <div style="margin-top:.6rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> En d√©duire un <b>encadrement</b> de \\(f(x)=x^2\\) sur \\(${Itex}\\) :</label>
        </div>
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <span>Pour tout \\(x\\in ${Itex}\\),</span>
          <input class="qEncMin" type="text" style="width:90px;text-align:center">
          <span>\\(\\le x^2 \\le\\)</span>
          <input class="qEncMax" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll(
      'input.ymax,input.ymin,input.qEncMin,input.qEncMax,select.dir'
    ).forEach(ensureTickAfter);

    typesetAll(host);
  },


     correct(host, st) {
    const { type, a, b, fa, fb } = st;

    const norm = s => (s || "").trim().replace(/\u2212/g, "-").replace(/,/g, ".");
    const num  = s => {
      const v = Number(norm(s));
      return Number.isFinite(v) ? v : null;
    };

    // min / max th√©oriques sur l'intervalle
    let minVal, maxVal;
    if (type === "pos") {
      minVal = fa;
      maxVal = fb;
    } else if (type === "neg") {
      minVal = fb;
      maxVal = fa;
    } else {
      minVal = 0;
      if (Math.abs(a) > Math.abs(b)) {
        maxVal = fa;
      } else {
        maxVal = fb;
      }
    }

    let ok = 0, tot = 0;

    const checkNumInput = (inp, expected) => {
      const v = inp.value.trim();
      if (!v) { setTick(inp, "nu"); return; }
      tot++;
      const n = num(v);
      const good = (n !== null && Math.abs(n - expected) < 1e-9);
      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    };

    const iMin = host.querySelector('.qEncMin');
    const iMax = host.querySelector('.qEncMax');
    if (iMin) checkNumInput(iMin, minVal);
    if (iMax) checkNumInput(iMax, maxVal);

    return { ok, total: tot };
  },



    solution(host, st) {
    const { type, a, b, fa, fb, extrema } = st;
    const extAt = x => extrema.filter(e => e.x === x);

    const Itex = `[${a}\\,;\\,${b}]`;

    let xs, dirs;
    if (type === "pos" || type === "neg") {
      xs   = [a, b];
      dirs = [type === "pos" ? "‚Üó" : "‚Üò"];
    } else {
      xs   = [a, 0, b];
      dirs = ["‚Üò", "‚Üó"];
    }

    const valBlock = x => {
      const y = x * x;
      const E = extAt(x);
      let up = "&nbsp;", dn = "&nbsp;";

      if (E.length) {
        E.forEach(e => {
          if (e.type === "max") up = `\\(${y}\\)`;
          if (e.type === "min") dn = `\\(${y}\\)`;
        });
      } else {
        up = `\\(${y}\\)`;
      }

      return `
        <td>
          <div style="text-align:center">${up}</div>
          <div style="height:6px"></div>
          <div style="text-align:center">${dn}</div>
        </td>`;
    };

    let rowX = '<tr><th>\\(x\\)</th>';
    xs.forEach((x, i) => {
      rowX += `<td>\\(${x}\\)</td>`;
      if (i < xs.length - 1) rowX += '<td></td>';
    });
    rowX += '</tr>';

    let rowF = '<tr><th>\\(f\\)</th>';
    xs.forEach((x, i) => {
      rowF += valBlock(x);
      if (i < xs.length - 1) {
        rowF += `<td>${dirs[i]}</td>`;
      }
    });
    rowF += '</tr>';

    // min / max pour l'encadrement
    let minVal, maxVal;
    if (type === "pos") {
      minVal = fa;
      maxVal = fb;
    } else if (type === "neg") {
      minVal = fb;
      maxVal = fa;
    } else {
      minVal = 0;
      if (Math.abs(a) > Math.abs(b)) {
        maxVal = fa;
      } else {
        maxVal = fb;
      }
    }

    const box = $("#res",host);
    box.innerHTML = `
      <div class="step">
        <b>1.</b> Tableau de variations de la fonction carr√© d√©finie par : \\(f(x)=x^2\\) sur \\(${Itex}\\) :
        <div class="var-wrap" style="margin-top:.4rem">
          <table class="pdf-tbl">
            <thead>${rowX}</thead>
            <tbody>
              ${rowF}
            </tbody>
          </table>
        </div>
      </div>
      <div class="step" style="margin-top:6px">
        <b>2.</b> On lit sur le tableau que, sur \\(${Itex}\\),
        le minimum de \\(f\\) vaut \\(${minVal}\\) et le maximum vaut \\(${maxVal}\\).<br>
        On en d√©duit l'encadrement :
        \\[
          \\forall x \\in ${Itex},\\quad ${minVal} \\le x^2 \\le ${maxVal}.
        \\]
      </div>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ymax,input.ymin,input.qminy,input.qminx,input.qmaxy,input.qmaxx,select.dir")
        .forEach(el => {
          if (el.tagName === "INPUT") el.value = "";
          setTick(el,"nu");
        });
  }
};

const ex3 = {
  id: "ineq_x2_graph",
  title: "In√©quations du type x^2 ‚Ä¶ (lecture graphique)",

  /* ========= 1. G√©n√©ration de l‚Äô√©nonc√© ========= */
    gen() {
    // valeurs possibles pour x¬≤ (on autorise des carr√©s parfaits ET des non-carr√©s)
    const MAX_LVL = 30;
    const POS = [];
    for (let n = 1; n <= MAX_LVL; n++) POS.push(n);

    const kind = choice(["inside", "outside", "between"]);
    const data = { kind };

    if (kind === "inside") {
      // 0 < x¬≤ ‚â§ c ou 0 ‚â§ x¬≤ < c etc.
      const basePool = POS.filter(n => n >= 1 && n <= 25);
      const c = choice(basePool);            // pas forc√©ment carr√© parfait
      const strict0 = Math.random() < 0.5;   // 0 < x¬≤ ou 0 ‚â§ x¬≤
      const strictC = Math.random() < 0.5;   // < c ou ‚â§ c
      data.c = c;
      data.strict0 = strict0;
      data.strictC = strictC;

      const s0 = strict0 ? "<" : "\\le";
      const sC = strictC ? "<" : "\\le";
      data.ineqTex = `0 ${s0} x^2 ${sC} ${c}`;
    } else if (kind === "outside") {
      // x¬≤ ‚â• c ou x¬≤ > c
      const basePool = POS.filter(n => n >= 2); // on √©vite juste 1 pour ne pas √™tre trop "petit"
      const c = choice(basePool);
      const strict = Math.random() < 0.5;
      data.c = c;
      data.strict = strict;
      data.ineqTex = strict ? `x^2 > ${c}` : `x^2 \\ge ${c}`;
    } else {
      // a ‚â§ x¬≤ ‚â§ b ou variantes
      let a, b;
      do {
        a = choice(POS);
        b = choice(POS);
      } while (a === b);
      if (a > b) [a, b] = [b, a];

      const pattern = choice([
        "closed",      // a ‚â§ x¬≤ ‚â§ b
        "openLower",   // a < x¬≤ ‚â§ b
        "openUpper",   // a ‚â§ x¬≤ < b
        "openBoth"     // a < x¬≤ < b
      ]);

      data.a = a;
      data.b = b;
      data.pattern = pattern;

      const sL = (pattern === "closed" || pattern === "openUpper") ? "\\le" : "<";
      const sR = (pattern === "closed" || pattern === "openLower") ? "\\le" : "<";

      data.ineqTex = `${a} ${sL} x^2 ${sR} ${b}`;
    }

    // racines pour la solution (m√™me si non enti√®res)
    if (data.c != null) {
      data.root = Math.sqrt(data.c);
    }
    if (data.a != null && data.b != null) {
      data.rootA = Math.sqrt(data.a);
      data.rootB = Math.sqrt(data.b);
    }

    return data;
  },

  /* ========= 2. Petit helper de dessin ¬´ fa√ßon screen ¬ª ========= */

 buildSketch(st, showSolution) {
  const NS  = "http://www.w3.org/2000/svg";
  const W   = 260;
  const H   = 260;
  const x0  = 30;
  const x1  = W - 30;
  const mid = W / 2;
  const yAx = 210;
  const yTop = 35;

  const svg = document.createElementNS(NS, "svg");
  svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  svg.setAttribute("width", W);
  svg.setAttribute("height", H);
  svg.setAttribute("class", "grid");

  /* === AXES === */
  const axX = document.createElementNS(NS, "line");
  axX.setAttribute("x1", x0);
  axX.setAttribute("x2", x1);
  axX.setAttribute("y1", yAx);
  axX.setAttribute("y2", yAx);
  axX.setAttribute("stroke", "#000");
  axX.setAttribute("stroke-width", "1.6");
  svg.appendChild(axX);

  const axY = document.createElementNS(NS, "line");
  axY.setAttribute("x1", mid);
  axY.setAttribute("x2", mid);
  axY.setAttribute("y1", yAx);
  axY.setAttribute("y2", yTop);
  axY.setAttribute("stroke", "#000");
  axY.setAttribute("stroke-width", "1.6");
  svg.appendChild(axY);

  /* === PARABOLE y = k (x-mid)¬≤ + yAx === */
  const targetEdgeY = yTop + 70;      // points extr√™mes
  const dx = x1 - mid;
  const k = (targetEdgeY - yAx) / (dx * dx); // k > 0
  const parabolaY = X => yAx + k * (X - mid) * (X - mid);

  const drawParabola = () => {
    const p = document.createElementNS(NS, "path");
    let d = "";
    const steps = 150;
    for (let i = 0; i <= steps; i++) {
      const X = x0 + (x1 - x0) * (i / steps);
      const Y = parabolaY(X);
      d += (i === 0 ? "M" : "L") + " " + X + " " + Y + " ";
    }
    p.setAttribute("d", d);
    p.setAttribute("stroke", "#000");
    p.setAttribute("stroke-width", "2.3");
    p.setAttribute("fill", "none");
    svg.appendChild(p);
  };

  drawParabola();

  /* === HELPERS === */
  const addText = (x, y, txt, anchor="middle") => {
    const t = document.createElementNS(NS, "text");
    t.setAttribute("x", x);
    t.setAttribute("y", y);
    t.setAttribute("font-size", "12");
    t.setAttribute("text-anchor", anchor);
    t.textContent = txt;
    svg.appendChild(t);
  };

  const dashH = y => {
    const L = document.createElementNS(NS, "line");
    L.setAttribute("x1", x0+5);
    L.setAttribute("x2", x1-5);
    L.setAttribute("y1", y);
    L.setAttribute("y2", y);
    L.setAttribute("stroke", "#b91c1c");
    L.setAttribute("stroke-width", "1.4");
    L.setAttribute("stroke-dasharray", "5 4");
    svg.appendChild(L);
  };

  const vertBlue = (x, yA, yB) => {
    const L = document.createElementNS(NS, "line");
    L.setAttribute("x1", x);
    L.setAttribute("x2", x);
    L.setAttribute("y1", yA);
    L.setAttribute("y2", yB);
    L.setAttribute("stroke", "#2563eb");
    L.setAttribute("stroke-width", "2");
    svg.appendChild(L);
  };

  const fillBetween = (xa, xb) => {
    const path = document.createElementNS(NS, "path");
    let d = `M ${xa} ${yAx}`;
    const steps = 80;
    for (let i = 0; i <= steps; i++) {
      const X = xa + (xb - xa) * (i / steps);
      const Y = parabolaY(X);
      d += ` L ${X} ${Y}`;
    }
    d += ` L ${xb} ${yAx} Z`;
    path.setAttribute("d", d);
    path.setAttribute("fill", "#6366f144");
    path.setAttribute("stroke", "none");
    svg.appendChild(path);
  };

  const solveIntersections = (yC) => {
    const r = Math.sqrt((yC - yAx) / k);
    return [mid - r, mid + r];
  };

  const lab = n => {
    const r = Math.sqrt(n);
    return Number.isInteger(r) ? String(r) : `‚àö${n}`;
  };

  if (!showSolution) return svg;

  /* =====================================================
        MODE SOLUTION : on place les niveaux, ant√©c√©dents,
        bo√Ætes verticales, et zones color√©es.
     ===================================================== */

  if (st.kind === "inside") {
    const yC = 120;
    dashH(yC);
    addText(mid + 12, yC - 5, String(st.c), "start");

    const [xL, xR] = solveIntersections(yC);

    vertBlue(xL, parabolaY(xL), yAx);
    vertBlue(xR, parabolaY(xR), yAx);

    fillBetween(xL, xR);

    addText(xL, yAx + 15, "-" + lab(st.c));
    addText(xR, yAx + 15, lab(st.c));
    addText(mid + 8, yAx + 15, "0", "start");
  }

  else if (st.kind === "outside") {
const yC = yAx - 50;  // par exemple toujours 50px au-dessus du sommet
    dashH(yC);
    addText(mid + 12, yC - 5, String(st.c), "start");

    const [xL, xR] = solveIntersections(yC);

    vertBlue(xL, parabolaY(xL), yAx);
    vertBlue(xR, parabolaY(xR), yAx);

    fillBetween(x0+5, xL);
    fillBetween(xR, x1-5);





    addText(xL, yAx + 15, "-" + lab(st.c));
    addText(xR, yAx + 15, lab(st.c));
    addText(mid + 8, yAx + 15, "0", "start");
  }

  else { // BETWEEN a ‚â§ x¬≤ ‚â§ b
    const yA = 180; // pour a
    const yB = 110; // pour b

    dashH(yA);
    dashH(yB);

    addText(mid + 12, yA - 4, String(st.a), "start");
    addText(mid + 12, yB - 4, String(st.b), "start");

    const [xA_L, xA_R] = solveIntersections(yA);
    const [xB_L, xB_R] = solveIntersections(yB);

    // niveaux b (haut)
    vertBlue(xB_L, parabolaY(xB_L), yAx);
    vertBlue(xB_R, parabolaY(xB_R), yAx);

    // niveaux a (bas)
    vertBlue(xA_L, parabolaY(xA_L), yAx);
    vertBlue(xA_R, parabolaY(xA_R), yAx);

    fillBetween(xB_L, xA_L);
    fillBetween(xA_R, xB_R);

    addText(xB_L, yAx + 15, "-" + lab(st.b));
    addText(xA_L, yAx + 15, "-" + lab(st.a));
    addText(xA_R, yAx + 15, lab(st.a));
    addText(xB_R, yAx + 15, lab(st.b));
    addText(mid + 8, yAx + 15, "0", "start");
  }

  return svg;
}
,


  /* ========= 3. Render : graphe + zone de saisie en intervalles ========= */

  render(host, st) {
    const { ineqTex } = st;

    host.innerHTML = `
      <div>
        √Ä l'aide de la repr√©sentation graphique de la fonction carr√© \\(f(x)=x^2\\),
        d√©terminer l'<b>ensemble des solutions</b> de l‚Äôin√©quation suivante.
      </div>

      <div style="margin-top:.35rem">
        <b>In√©quation :</b> \\(${ineqTex}\\)
      </div>

      <div class="graph" style="margin-top:.45rem">
        <div class="ineq-g"></div>
      </div>

      <div style="margin-top:.6rem">

        <div style="margin-top:.4rem;display:flex;flex-wrap:wrap;gap:8px;align-items:center">
          <span>Ensemble des solutions : \\(S =\\)</span>
          <input class="ineq-set" type="text"
                 style="width:230px;max-width:90%;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.7rem"></div>
    `;

    const box = host.querySelector('.ineq-g');
    box.appendChild(this.buildSketch(st, false));

    host.querySelectorAll('input.ineq-set').forEach(ensureTickAfter);

    typesetAll(host);
  },

  /* ========= 4. Correction : parseur d‚Äôintervalles ========= */

   correct(host, st) {
    const inp = host.querySelector('.ineq-set');
    const tickEl = inp ? ensureTickAfter(inp) : null;
    const raw = (inp?.value || "").trim();

    if (!raw) {
      if (tickEl) tickEl.className = "tick nu";
      return { ok: 0, total: 0 };
    }

    /* ---------- 1) Parseur d'intervalles ---------- */

           function parseIntervals(txt) {
      if (!txt) return null;

      let s = txt.trim();

      // normalisation globale
      s = s
        .replace(/\s+/g, "")       // espaces
        .replace(/\u2212/g, "-")   // ‚àí -> -
        .replace(/‚àû/g, "oo")       // ‚àû -> oo
        .replace(/\\,/g, "")       // √©ventuels \,
        .replace(/\\;/g, "");      // √©ventuels \;

      s = s.replace(/‚à™/gi, "U").replace(/u/g, "U");

      const parts = s.split(/U+/).filter(Boolean);
      if (!parts.length) return null;

      // ----- parse des bornes (nombre, rac, sqrt, ‚àö, ¬±oo) -----
      const parseBound = (t) => {
        if (!t) return NaN;
        t = t.trim().replace(/\u2212/g, "-");

        // infinis
        let low = t.toLowerCase().replace(/,/g, ".");
        if (low === "-oo" || low === "-inf") return -Infinity;
        if (low === "oo" || low === "inf" || low === "+oo" || low === "+inf") return +Infinity;

        // signe
        let sign = 1;
        if (t[0] === "+") {
          t = t.slice(1);
        } else if (t[0] === "-") {
          sign = -1;
          t = t.slice(1);
        }

        let core = t.trim().replace(/\u2212/g, "-");
        let coreLower = core.toLowerCase().replace(/,/g, ".");

        // rac -> sqrt, ‚àö -> sqrt(
        coreLower = coreLower.replace(/^rac\(/, "sqrt(").replace(/‚àö/g, "sqrt(");

        // cas sqrt(...)
        if (coreLower.startsWith("sqrt")) {
          // tol√®re "sqrt13" ‚Üí "sqrt(13)"
          if (!coreLower.includes("(")) coreLower = coreLower.replace(/^sqrt/, "sqrt(") + ")";
          if (!coreLower.endsWith(")")) coreLower += ")";

          if (coreLower.startsWith("sqrt(") && coreLower.endsWith(")")) {
            const inside = coreLower.slice(5, -1);
            let base;
            if (inside.includes("/")) {
              const [na, da] = inside.split("/");
              const n = Number(na), d = Number(da);
              if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
              base = n / d;
            } else {
              base = Number(inside);
              if (Number.isNaN(base)) return NaN;
            }
            if (base < 0) return NaN;
            return sign * Math.sqrt(base);
          }
        }

        // nombre "simple"
        const v = Number(coreLower);
        return Number.isFinite(v) ? sign * v : NaN;
      };

      const intervals = [];

      for (const part of parts) {
        if (part.length < 4) return null;

        const L = part[0];
        const R = part[part.length - 1];
        if (!"[]()".includes(L) || !"[]()".includes(R)) return null;

        const inside = part.slice(1, -1);
        const sepIdx = inside.indexOf(";") >= 0 ? inside.indexOf(";") : inside.indexOf(",");
        if (sepIdx < 0) return null;

        const aStr = inside.slice(0, sepIdx);
        const bStr = inside.slice(sepIdx + 1);

        const a = parseBound(aStr);
        const b = parseBound(bStr);
        if (Number.isNaN(a) || Number.isNaN(b)) return null;

        // ordre coh√©rent (sauf infinis)
        if (Number.isFinite(a) && Number.isFinite(b) && a > b + 1e-9) return null;

        // crochets / parenth√®ses -> ouvert / ferm√©
        const openL = (L === ']' || L === '('); // [ ferm√©, ] / ( ouverts
        const openR = (R === '[' || R === ')'); // ] ferm√©, [ / ) ouverts

        intervals.push({ a, b, openL, openR });
      }

      // tri pour comparer ind√©pendamment de l'ordre de saisie
      intervals.sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      return intervals;
    }



    /* ---------- 2) Ensemble attendu en fonction du cas ---------- */

    const EPS = 1e-6;
    const kind = st.kind;

    const expected = (() => {
      // petits helpers pour les racines (toujours des carr√©s parfaits ici)
      const r  = st.c  != null ? Math.sqrt(st.c)  : null;
      const rA = st.a  != null ? Math.sqrt(st.a)  : null;
      const rB = st.b  != null ? Math.sqrt(st.b)  : null;

      if (kind === "inside") {
        const strict0 = !!st.strict0; // 0 < ... ?
        const strictC = !!st.strictC; // ... < c ?

        if (!strict0) {
          // 0 ‚â§ x¬≤ ‚Ä¶  ‚áí intervalle unique [-r ; r] ou ]-r ; r[
          return [{
            a: -r,
            b:  r,
            openL: strictC,   // < c  ‚áí bornes ouvertes
            openR: strictC
          }];
        }

        // 0 < x¬≤ ‚Ä¶  ‚áí deux intervalles, trou en 0
        if (!strictC) {
          // 0 < x¬≤ ‚â§ c  ‚áí [-r;0[ ‚à™ ]0;r]
          return [
            { a: -r, b: 0, openL: false, openR: true  },
            { a:  0, b: r, openL: true,  openR: false }
          ];
        }
        // 0 < x¬≤ < c  ‚áí ]-r;0[ ‚à™ ]0;r[
        return [
          { a: -r, b: 0, openL: true, openR: true },
          { a:  0, b: r, openL: true, openR: true }
        ];
      }

      if (kind === "outside") {
        const r = Math.sqrt(st.c);
        const strict = !!st.strict;   // > c ou ‚â• c
        return [
          { a: -Infinity, b: -r, openL: true,  openR: strict },   // ]-oo ; -r] ou ]-oo ; -r[
          { a:  r,        b: +Infinity, openL: strict, openR: true } // [r ; +oo[ ou ]r ; +oo[
        ];
      }

      // between : a ‚Ä¶ x¬≤ ‚Ä¶ b

      const p  = st.pattern; // "closed", "openLower", "openUpper", "openBoth"

      if (p === "closed") {
        // a ‚â§ x¬≤ ‚â§ b
        return [
          { a: -rB, b: -rA, openL: false, openR: false },
          { a:  rA, b:  rB, openL: false, openR: false }
        ];
      }
      if (p === "openLower") {
        // a < x¬≤ ‚â§ b
        return [
          { a: -rB, b: -rA, openL: false, openR: true  }, // [-rB ; -rA[
          { a:  rA, b:  rB, openL: true,  openR: false }  // ]rA ; rB]
        ];
      }
      if (p === "openUpper") {
        // a ‚â§ x¬≤ < b
        return [
          { a: -rB, b: -rA, openL: true,  openR: false }, // ]-rB ; -rA]
          { a:  rA, b:  rB, openL: false, openR: true  }  // [rA ; rB[
        ];
      }
      // openBoth : a < x¬≤ < b
      return [
        { a: -rB, b: -rA, openL: true, openR: true },    // ]-rB ; -rA[
        { a:  rA, b:  rB, openL: true, openR: true }     // ]rA ; rB[
      ];
    })();

    /* ---------- 3) Comparaison user / attendu ---------- */

    const got = parseIntervals(raw);
    let ok = 0, tot = 1;
    let good = false;

    if (got && got.length === expected.length) {
      const numEq = (x, y) => {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return x === y;
        return Math.abs(x - y) < EPS;
      };

      // on trie expected aussi, pour tol√©rer l'ordre d'√©criture
      const expSorted = expected.slice().sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      good = true;
      for (let i = 0; i < got.length; i++) {
        const g = got[i];
        const e = expSorted[i];
        if (!numEq(g.a, e.a) || !numEq(g.b, e.b) ||
            g.openL !== e.openL || g.openR !== e.openR) {
          good = false;
          break;
        }
      }
    }

    if (tickEl) tickEl.className = "tick " + (good ? "ok" : "ko");
    if (good) ok = 1;

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">
          On lit sur le graphique les abscisses limites (par exemple \\(-6\\) et \\(6\\)),
          puis on √©crit l‚Äôensemble des solutions sous forme d‚Äôintervalle(s),
          en utilisant \\([\\,]\\) pour une borne incluse et \\(]\\,[\\) pour une borne exclue,
          ainsi que \\(-\\infty\\) et \\(+\\infty\\) si n√©cessaire.
        </div>
      `;
      typesetAll(box);
    }

    return { ok, total: tot };
  },


  /* ========= 5. Solution : m√™me dessin mais avec parabole remplie ========= */

   solution(host, st) {
    const sqrtTex = n => {
      const r = Math.sqrt(n);
      return Number.isInteger(r) ? String(r) : `\\sqrt{${n}}`;
    };

    const kind = st.kind;

    // 1) Graphe interactif : on remplace la parabole vierge par la version "corrig√©e"
    const gHost = host.querySelector('.ineq-g');
    if (gHost) {
      gHost.innerHTML = "";
      gHost.appendChild(this.buildSketch(st, true)); // parabole remplie avec zones
    }

    // 2) Texte + graphe corrig√© dans le bloc de solution (pour le PDF)
    let solTex = "";

    if (kind === "inside") {
      const c   = st.c;
      const rT  = sqrtTex(c);
      const s0  = st.strict0 ? "<" : "\\le";
      const sC  = st.strictC ? "<" : "\\le";

      if (!st.strict0) {
        // 0 ‚â§ x¬≤ ‚Ä¶  ‚áí intervalle unique
        const Itex = st.strictC ? `]-${rT};${rT}[` : `[-${rT};${rT}]`;
        solTex = `
\\[
0 ${s0} x^2 ${sC} ${c}
\\iff -${rT} ${st.strictC ? "<" : "\\le"} x ${st.strictC ? "<" : "\\le"} ${rT}
\\]
L‚Äôensemble des solutions est donc : \\(${Itex}\\).
`;
      } else {
        // 0 < x¬≤ ‚Ä¶  ‚áí trou en 0 (r√©union de deux intervalles)
        const I1 = st.strictC ? `]-${rT};0[` : `[-${rT};0[`;
        const I2 = st.strictC ? `]0;${rT}[` : `]0;${rT}]`;
        solTex = `
\\[
0 ${s0} x^2 ${sC} ${c}
\\iff x \\neq 0 \\;\\text{et}\\; ${ (st.strictC ? `|x| < ${rT}` : `|x| \\le ${rT}`) }
\\]
L‚Äôensemble des solutions est donc :
\\(${I1} \\cup ${I2}\\).
`;
      }
    }
    else if (kind === "outside") {
      const c   = st.c;
      const rT  = sqrtTex(c);
      const strict = !!st.strict;
      const leftInt  = strict ? `]-\\infty;-${rT}[` : `]-\\infty;-${rT}]`;
      const rightInt = strict ? `]${rT};+\\infty[` : `[${rT};+\\infty[`;
      const sSym = strict ? ">" : "\\ge";
      const sL   = strict ? "<" : "\\le";
      const sR   = strict ? ">" : "\\ge";

      solTex = `
\\[
x^2 ${sSym} ${c}
\\iff x ${sL} -${rT} \\quad \\text{ou} \\quad x ${sR} ${rT}
\\]
L‚Äôensemble des solutions est donc
\\(${leftInt} \\cup ${rightInt}\\).
`;
    }
    else {
      const a   = st.a, b = st.b;
      const rA  = sqrtTex(a);
      const rB  = sqrtTex(b);
      const p   = st.pattern;

      const sL = (p === "closed" || p === "openUpper") ? "\\le" : "<";
      const sR = (p === "closed" || p === "openLower") ? "\\le" : "<";

      let I1, I2;
      if (p === "closed") {
        I1 = `[-${rB};-${rA}]`;
        I2 = `[${rA};${rB}]`;
      } else if (p === "openLower") {
        I1 = `[-${rB};-${rA}[`;
        I2 = `]${rA};${rB}]`;
      } else if (p === "openUpper") {
        I1 = `]-${rB};-${rA}]`;
        I2 = `[${rA};${rB}[`;
      } else {
        I1 = `]-${rB};-${rA}[`;
        I2 = `]${rA};${rB}[`;
      }

      solTex = `
\\[
${a} ${sL} x^2 ${sR} ${b}
\\]
L‚Äôensemble des solutions est donc :
\\(
 ${I1} \\cup ${I2}.
\\)
`;
    }

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">

        </div>
        <div class="step" style="margin-top:.4rem">
          <!-- Graphe corrig√© pour la solution / le PDF -->
          <div class="graph" style="margin-bottom:.5rem">
            <div class="ineq-sol-graph"></div>
          </div>
          ${solTex}
        </div>
      `;

      // On ins√®re une copie de la parabole corrig√©e dans la zone "solution"
      const solG = box.querySelector('.ineq-sol-graph');
      if (solG) {
        solG.appendChild(this.buildSketch(st, true));
      }
    }
    typesetAll(box);
  },


  /* ========= 6. Reset ========= */

  reset(host) {
    const box = $("#res", host);
    if (box) box.textContent = "";
    const inp = host.querySelector('.ineq-set');
    if (inp) {
      inp.value = "";
      setTick(inp, "nu");
    }
    const gHost = host.querySelector('.ineq-g');
    if (gHost) gHost.innerHTML = "";
  }
};




/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2,ex3];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Fonction carr√© - √âquations - Encadrement ‚Äì In√©quations',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
