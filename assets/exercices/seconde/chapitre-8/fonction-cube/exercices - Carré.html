<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äì Fonction cube</title>

<link rel="stylesheet" href="../../../../css/math-kbd.css">
<link rel="stylesheet" href="../../../../css/espace-latex.css">
<link rel="stylesheet" href="../../../../css/espace-gras.css">
<link rel="stylesheet" href="../../../../css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .score{margin-left:auto}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .step{margin:.2rem 0}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* mini tableaux ‚ÄúPDF-like‚Äù (cadre ext√©rieur) */
  table.pdf-tbl{
    border-collapse: separate; border-spacing: 0; border: none; margin:.4rem 0;
  }
  table.pdf-tbl th, table.pdf-tbl td{
    border: none; padding: 4px 6px; text-align: center; vertical-align: middle;
  }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* variation table (interactive) */
  .var-wrap{display:flex;justify-content:center}
  table.var{width:max-content;border-collapse:separate;border-spacing:0;margin:.35rem auto}
  table.var th, table.var td{padding:4px 6px;border:1.5px solid #000}
  table.var th{background:#f3f3f6}
  table.var .bigsel select{font-size:28px;line-height:1;height:2.1em}
  table.var .bigsel{padding:0 4px}
  table.var input[type="text"]{width:110px;text-align:center}
  table.var .thin td{ border-top:none; border-left:none; border-right:none; padding-top:2px; }
  table.var .gaprow td{ border:none !important; height:8px; padding:0; }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.grid{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  .g-ax{stroke:#000;stroke-width:1.4}
  .g-grid{stroke:#a78bfa22}
  .g-curve{stroke:#111;stroke-width:2.2;fill:none}
  .g-pt{fill:#111}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  
  
  /* Tableau de variations : uniquement le cadre + s√©parations x/f et labels */
table.var.frame-only{
  border-collapse: separate;
  border-spacing: 0;
}
table.var.frame-only th,
table.var.frame-only td{
  border: none;                 /* pas de bordures int√©rieures */
  padding: 6px 8px;
  text-align: center;
  vertical-align: middle;
}

/* Cadre ext√©rieur */
table.var.frame-only tr:first-child > * { border-top:    1.5px solid #000; }
table.var.frame-only tr:last-child  > * { border-bottom: 1.5px solid #000; }
table.var.frame-only tr > *:first-child { border-left:   1.5px solid #000; }
table.var.frame-only tr > *:last-child  { border-right:  1.5px solid #000; }

/* S√©paration verticale apr√®s la 1re colonne (labels x / f) */
table.var.frame-only tbody tr > *:first-child { border-right: 1.5px solid #000; }

/* S√©paration horizontale entre la ligne x et la ligne f */
table.var.frame-only tbody tr:first-child > * { border-bottom: 1.5px solid #000; }

/* cellule fl√®che pleine hauteur */
table.var.frame-only td.bigsel{ padding:0 }

/* le select occupe 100% et centre la fl√®che */
table.var.frame-only td.bigsel select{
  display:block;
  width:100%;
  height:100%;
  border:1;
  background:transparent;
  padding:0;
  margin:0;
  text-align:center;         /* Chrome/Edge */
  text-align-last:center;    /* Firefox */
  appearance:none;           /* enl√®ve le chevron natif */
  -webkit-appearance:none;
  -moz-appearance:none;
}
table.var.frame-only td.bigsel option{ font-size:inherit; line-height:inherit; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}
/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* √©crase le gras inline sur les z√©ros */
table.pdf-tbl td.zbar { font-weight:400 !important; }


/* Variante "grille compl√®te" pour les tableaux d'images f(x) */
table.pdf-tbl.fullgrid{
  border-collapse:collapse;
  border-spacing:0;
}

table.pdf-tbl.fullgrid th,
table.pdf-tbl.fullgrid td{
  border:1.5px solid #000;      /* toutes les bordures visibles */
  padding:8px 10px;
}
.graph svg.grid{
  width:100%;
  height:auto;
}


</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[['\\(','\\)'],['$','$']],displayMath:[['\\[','\\]'],['$$','$$']],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="../../../../es5/tex-chtml.js"></script>
<script src='../../../../js/math-kbd.js' defer></script>

<script src='../../../../js/exo-pdf-kit.multiplicatif-latex.js' defer></script>

</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äì Fonction cube</h1>
  </div>

  <div class="wrap">
    <div class="controls card">
      <label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
      <select id="exo-select"></select>
      <button id="btn-new" class="btn">üîÑ Nouvel √©nonc√©</button>
      <button id="btn-check" class="btn">‚úÖ V√©rifier</button>
      <button id="btn-solution" class="btn">üí° Solution</button>
      <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
      <span class="score">Score : <span id="score">0 / 0</span></span>
    </div>

    <div class="card" id="host"></div>

    <div class="card small">
      <strong>Consignes de saisie</strong>
      <ul style="margin:.5rem 0 0 18px">
        <li>Extremums (tableau) : remplisser dans la saisie du haut si maximum et dans la saisie du bas si minimum.</li>
        <li>Fl√®ches : choisissez ‚Üò ou ‚Üó.</li>
		        <li>Extremums (phrase) : Si l'extremum est atteint plusieurs fois, √©crire une liste. Exemple : -3;2</li>

      </ul>
    </div>

    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

  <!-- m√™me emplacement que dans ton mod√®le -->

<script>
(function(){
'use strict';

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî‚Äî‚Äî */
const $=(s,r)=> (r||document).querySelector(s);
let scoreOK=0, scoreTot=0;
const UMIN='‚àí';
function updateScore(){ $("#score").textContent=scoreOK+" / "+scoreTot; }
function L(s){return '\\( '+s+' \\)';}
function ensureTickAfter(el){ let s=el?.nextElementSibling; if(!s||!s.classList?.contains('tick')){ s=document.createElement('span'); s.className='tick nu'; el.insertAdjacentElement('afterend',s);} return s; }
function setTick(el, state){ if(!el) return; ensureTickAfter(el).className='tick '+state; }
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
const choice=a=>a[Math.floor(Math.random()*a.length)];
const rint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;


function buildRepereSVG(opts){
  // Zone "utile" max (hors marges)
  const Wmax = 520, Hmax = 300,
        mL = 28, mT = 8, mR = 8, mB = 28;

  const { xmin, xmax, ymin, ymax } = opts;

  // nombre de carreaux par unit√© (x et y peuvent √™tre diff√©rents)
  const subDivX = opts.subDivX || 1;   // ex : 3, 4 ou 5
  const subDivY = opts.subDivY || 1;   // ici : 1

  const AR = Math.max(3.5, Math.min(8, opts.arrowSize || 7));

  // 1) √âtendue en unit√©s
  const Rx = xmax - xmin;
  const Ry = ymax - ymin;

  // 2) Taille d'un carreau en pixels (m√™me pour x et y ‚Üí carr√©s)
  //    Rx * subDivX = nb total de carreaux horizontaux
  //    Ry * subDivY = nb total de carreaux verticaux
  const cell = Math.min(
    Wmax / (Rx * subDivX),
    Hmax / (Ry * subDivY)
  );

  // px par unit√© en x / y
  const sX = cell * subDivX;
  const sY = cell * subDivY;

  // 3) Taille de la zone de trac√© en pixels
  const w = sX * Rx;
  const h = sY * Ry;

  // 4) Centrage de la fen√™tre de trac√©
  const x0 = mL + (Wmax - w) / 2;
  const y0 = mT + (Hmax - h) / 2;

  // 5) Dimensions totales du SVG
  const W = mL + Wmax + mR;
  const H = mT + Hmax + mB;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('class','grid');
svg.setAttribute('width', W);
svg.setAttribute('height', H);

  const defs = document.createElementNS(svg.namespaceURI,'defs');

  // fl√®ches
  const mark = document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow');
  mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth', AR);
  mark.setAttribute('markerHeight', AR);
  mark.setAttribute('viewBox', `0 0 ${AR} ${AR}`);
  mark.setAttribute('refX', AR);
  mark.setAttribute('refY', AR/2);
  mark.setAttribute('orient','auto');
  const tri = document.createElementNS(svg.namespaceURI,'path');
  tri.setAttribute('d', `M0 0 L${AR} ${AR/2} L0 ${AR} Z`);
  tri.setAttribute('fill','#111');
  mark.appendChild(tri);
  defs.appendChild(mark);

  // clip plot
  const clip = document.createElementNS(svg.namespaceURI,'clipPath');
  clip.setAttribute('id','clip-v1');
  const crect = document.createElementNS(svg.namespaceURI,'rect');
  crect.setAttribute('x',x0);
  crect.setAttribute('y',y0);
  crect.setAttribute('width',w);
  crect.setAttribute('height',h);
  clip.appendChild(crect);
  defs.appendChild(clip);
  svg.appendChild(defs);

  const axes = document.createElementNS(svg.namespaceURI,'g');
  const plot = document.createElementNS(svg.namespaceURI,'g');
  plot.classList.add('plot');
  plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes);
  svg.appendChild(plot);

  // conversions unit√©s ‚Üí pixels
  const X = x => x0 + (x - xmin) * sX;
  const Y = y => y0 + h - (y - ymin) * sY;

  // cadre
  const frame = document.createElementNS(svg.namespaceURI,'rect');
  frame.setAttribute('x',x0);
  frame.setAttribute('y',y0);
  frame.setAttribute('width',w);
  frame.setAttribute('height',h);
  frame.setAttribute('fill','none');
  frame.setAttribute('stroke','#111');
  frame.setAttribute('class','frame');
  axes.appendChild(frame);

  // position des axes
  const yAxisY = Math.max(y0+10, Math.min(y0+h-10, Y(0)));
  const xAxisX = Math.max(x0+10, Math.min(x0+w-10, X(0)));

  // grille + graduations
  if (opts.grid){
    const g  = document.createElementNS(svg.namespaceURI,'g');
    g.setAttribute('stroke','#000');
    g.setAttribute('stroke-width','0.7');
    g.setAttribute('class','thin-grid');

    const tx = document.createElementNS(svg.namespaceURI,'g');
    const ty = document.createElementNS(svg.namespaceURI,'g');

    const fmt = n => String(n).replace('-', '‚àí');

    // pas en unit√©s pour dessiner chaque carreau
    const stepX = 1 / subDivX;
    const stepY = 1 / subDivY;

    // verticales tous les 1/subDivX
    for (let xv = Math.ceil(xmin*subDivX)/subDivX; xv <= xmax+1e-9; xv += stepX){
      const xx = X(xv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',xx);
      l.setAttribute('y1',y0);
      l.setAttribute('x2',xx);
      l.setAttribute('y2',y0+h);
      g.appendChild(l);

      // graduation uniquement si xv entier
      if (Math.abs(xv - Math.round(xv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(xv));
        t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx)));
        t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','middle');
        tx.appendChild(t);
      }
    }

    // horizontales tous les 1/subDivY
    for (let yv = Math.ceil(ymin*subDivY)/subDivY; yv <= ymax+1e-9; yv += stepY){
      const yy = Y(yv);
      const l  = document.createElementNS(svg.namespaceURI,'line');
      l.setAttribute('x1',x0);
      l.setAttribute('y1',yy);
      l.setAttribute('x2',x0+w);
      l.setAttribute('y2',yy);
      g.appendChild(l);

      if (Math.abs(yv - Math.round(yv)) < 1e-9){
        const t = document.createElementNS(svg.namespaceURI,'text');
        t.textContent = fmt(Math.round(yv));
        t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6)));
        t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4)));
        t.setAttribute('font-size','12');
        t.setAttribute('text-anchor','end');
        ty.appendChild(t);
      }
    }

    axes.appendChild(g);
    axes.appendChild(tx);
    axes.appendChild(ty);
  }

  // axes fl√©ch√©s
  const axX = document.createElementNS(svg.namespaceURI,'line');
  axX.setAttribute('x1', x0);
  axX.setAttribute('x2', x0 + w);
  axX.setAttribute('y1', yAxisY);
  axX.setAttribute('y2', yAxisY);
  axX.setAttribute('stroke', '#111');
  axX.setAttribute('stroke-width', '2.2');
  axX.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axX.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axX);

  const axY = document.createElementNS(svg.namespaceURI,'line');
  axY.setAttribute('x1', xAxisX);
  axY.setAttribute('x2', xAxisX);
  axY.setAttribute('y1', y0 + h);
  axY.setAttribute('y2', y0);
  axY.setAttribute('stroke', '#111');
  axY.setAttribute('stroke-width', '2.2');
  axY.setAttribute('stroke-linecap', 'butt');
  if (opts.arrows) axY.setAttribute('marker-end','url(#arrow)');
  axes.appendChild(axY);

  // inverses (si tu en as besoin ailleurs)
  const Xi = px => xmin + (px - x0) / sX;
  const Yi = py => ymin + (y0 + h - py) / sY;

  const hit = document.createElementNS(svg.namespaceURI,'rect');
  hit.setAttribute('x', x0);
  hit.setAttribute('y', y0);
  hit.setAttribute('width', w);
  hit.setAttribute('height', h);
  hit.setAttribute('fill', 'transparent');
  hit.style.pointerEvents = 'all';
  plot.appendChild(hit);

  return { svg, plot, axes, X, Y, Xi, Yi, hit, xmin, xmax, ymin, ymax };
}


// utilitaires trac√©
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d);
  p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4);
  p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
// lissage type Hermite monotone (comme dans le fichier RG)
function pathFromGridSmooth(rep, grid){
  const X=rep.X,Y=rep.Y,Xs=grid.Xs,Ys=grid.Ys,n=Xs.length; if(n<2) return '';
  const s=new Array(n-1); for(let i=0;i<n-1;i++) s[i]=Ys[i+1]-Ys[i];
  const d=new Array(n); d[0]=s[0]; d[n-1]=s[n-2];
  for(let i=1;i<n-1;i++){ const s0=s[i-1],s1=s[i];
    if(s0*s1<=0) d[i]=0; else{ const a=Math.abs(s0),b=Math.abs(s1); d[i]=(Math.sign(s0)+Math.sign(s1))*Math.min(a,b,0.5*(a+b)); }
  }
  let D=`M ${X(Xs[0])} ${Y(Ys[0])}`;
  for(let i=0;i<n-1;i++){ const x0=Xs[i],x1=Xs[i+1],y0=Ys[i],y1=Ys[i+1],h=x1-x0;
    const c1x=X(x0+h/3), c1y=Y(y0 + d[i]*h/3), c2x=X(x1-h/3), c2y=Y(y1 - d[i+1]*h/3);
    D+=` C ${c1x} ${c1y} ${c2x} ${c2y} ${X(x1)} ${Y(y1)}`;
  }
  return D;
}

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Petits rendus de tableaux ‚Äî‚Äî‚Äî‚Äî‚Äî */


function pickExtremaCountWeighted(){
  const r = Math.random()*100;
  if (r < 15) return 1;
  if (r < 55) return 2;
  if (r < 90) return 3;
  return 4;
}

// Cubique de Hermite -> points de contr√¥le B√©zier (pour <path d="C ...">)
function hermiteToBezier(P0, P1, m0, m1){
  const [x0,y0]=P0, [x1,y1]=P1, h=x1-x0;
  return {
    C1:[x0 + h/3, y0 + m0*h/3],
    C2:[x1 - h/3, y1 - m1*h/3],
  };
}

// Durcit les segments qui croisent y=0 : croisement net (pas de "kiss"), pas d'ondulation
function hardenZeroCrossings(K){
  // K : [{x,y,m}] tri√©s
  // 1) √âcarter les voisins d'un z√©ro et imposer une pente minimale au z√©ro
  const MIN_SLOPE = 0.35;  // pente minimale au z√©ro (croisement visible)
  const MIN_AWAY  = 1;     // √©cart minimal |y| des voisins

  for(let i=1;i<K.length-1;i++){
    if(K[i].y===0){
      // voisins de signes oppos√©s et "√©loign√©s" de 0
      if(Math.abs(K[i-1].y) < MIN_AWAY) K[i-1].y = (K[i-1].y<=0 ? -MIN_AWAY : +MIN_AWAY);
      if(Math.abs(K[i+1].y) < MIN_AWAY) K[i+1].y = (K[i+1].y<=0 ? -MIN_AWAY : +MIN_AWAY);

      const dir = Math.sign(K[i+1].y - K[i-1].y) || 1;
      K[i].m = dir * MIN_SLOPE; // croisement assur√© (pente non nulle)
    }
  }

  // 2) Pour chaque segment qui change de signe, on "d√©-ondulationne"
  //    en bornant les pentes √† proximit√© de la s√©cante (√©vite les bosses parasites).
  for(let i=0;i<K.length-1;i++){
    const P0=K[i], P1=K[i+1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    if(P0.y === 0 || P1.y === 0 || (P0.y*P1.y < 0)){
      const target = 0.8 * (dy/dx);    // pentes cal√©es sur ~80% de la s√©cante
      P0.m = (P0.m===0 ? 0 : target);
      P1.m = (P1.m===0 ? 0 : target);
    }
  }
}

function pathFromKnots(rep, K){
  const X=rep.X, Y=rep.Y;
  let d = '';
  for (let i=0; i<K.length-1; i++){
    const A=K[i], B=K[i+1];
    if (!Number.isFinite(A.x) || !Number.isFinite(A.y) ||
        !Number.isFinite(B.x) || !Number.isFinite(B.y)) continue;
    if (d==='') d = `M ${X(A.x)} ${Y(A.y)}`;
    const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m,B.m);
    d += ` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`;
  }
  return d;
}


// Trouve les indices des "ancres de variation" dans K : [borne gauche], extr√©mums, [borne droite]
function getAnchorIdx(K, extremaXs){
  const set = new Set([K[0].x, ...extremaXs, K[K.length-1].x]);
  const idx = [];
  for (let i=0;i<K.length;i++) if (set.has(K[i].x)) idx.push(i);
  return idx;
}

// Oriente les pentes des racines selon le sens du segment (borne/extr√©mum √† extr√©mum/borne)
function alignRootSlopes(K, anchorIdx, minSlope=0.35){
  const idxOf = new Map(K.map((p,i)=>[p.x,i]));
  for (let s=0; s<anchorIdx.length-1; s++){
    const i0 = anchorIdx[s], i1 = anchorIdx[s+1];
    const P0 = K[i0], P1 = K[i1];
    const dx = (P1.x - P0.x) || 1;
    const dy = P1.y - P0.y;
    const trend = Math.sign(dy) || 1;          // sens de variation sur ce segment
    const target = (dy/dx) * 0.9;              // pente "douce" de r√©f√©rence

    for (let i=i0+1; i<i1; i++){
      if (K[i].y === 0 && K[i].m !== 0){       // racine (non extr√©mum)
        let m = target;
        if (Math.abs(m) < minSlope) m = trend * minSlope; // croisement visible
        K[i].m = m;
      }
    }
  }
}

// Clamp monotone de Fritsch‚ÄìCarlson pour chaque segment (√©vite les ondulations)
function clampMonotone(K){
  // 1) construire deltas
  const n = K.length-1, dx=[], dy=[], delta=[];
  for (let i=0;i<n;i++){
    dx[i] = (K[i+1].x - K[i].x) || 1;
    dy[i] =  K[i+1].y - K[i].y;
    delta[i] = dy[i]/dx[i];
  }
  // 2) si m non d√©fini (undefined), initialiser par moyenne des deltas voisines
  for (let i=0;i<=n;i++){
    if (K[i].m === undefined){
      if (i===0) K[i].m = delta[0];
      else if (i===n) K[i].m = delta[n-1];
      else {
        // moyenne pond√©r√©e classique
        const w1 = 2*dx[i-1] + dx[i];
        const w2 = dx[i-1] + 2*dx[i];
        K[i].m = (w1 + w2) ? ( (w1 + w2) / (w1/delta[i-1] + w2/delta[i]) ) : 0;
      }
    }
  }
  // 3) Fritsch‚ÄìCarlson : imposer monotonicit√© par segment
  for (let i=0;i<n;i++){
    if (Math.abs(dy[i]) < 1e-12){
      // segment plat ‚Üí pentes nulles
      K[i].m = 0; K[i+1].m = 0; continue;
    }
    // si changement de signe, on met m_i=0
    if (i>0 && delta[i-1]*delta[i] <= 0){ K[i].m = 0; }

    const a = K[i].m / delta[i];
    const b = K[i+1].m / delta[i];
    if (a < 0) K[i].m = 0;
    if (b < 0) K[i+1].m = 0;

    const S = a*a + b*b;
    if (S > 9){ // norme > 3 ‚Üí on scale
      const t = 3 / Math.sqrt(S);
      K[i].m     = t * a * delta[i];
      K[i+1].m   = t * b * delta[i];
    }
  }
}

// Fabrique d‚Äôune courbe lisse avec n extr√©mums (entiers), sans plateau, + padding vertical
// ‚Äî‚Äî‚Äî remplace enti√®rement la fonction ‚Äî‚Äî‚Äî
// --- Fabrique au propre : courbe lisse + racines enti√®res (z√©ros sur des entiers) ---
// --- Courbe lisse : extr√©mums entiers (comme avant), + racines SIMPLES √† x entiers (‚â† extr√©mums) ---
function makeSmoothCurveKnots(nExt){
  const halfX = choice([5,6,7]);
  const xmin = -halfX, xmax = +halfX;

  // candidats entiers internes
  const Xcand=[]; for(let x=xmin+1; x<=xmax-1; x++) Xcand.push(x);

  // √©chantillonnage avec √©cart ‚â• 2 entre extr√©mums et ‚â• 2 des bornes
  function sampleExtPositions(n){
    const pick=[];
    const pool=[...Xcand];
    const ok = x => Math.abs(x-xmin)>=2 && Math.abs(x-xmax)>=2 && pick.every(u=>Math.abs(u-x)>=2);
    let guard=1000;
    while(pick.length<n && pool.length && guard--){
      const i=Math.floor(Math.random()*pool.length), x=pool.splice(i,1)[0];
      if(ok(x)) pick.push(x);
    }
    pick.sort((a,b)=>a-b);
    if(pick.length<n){ // secours : rel√¢che √† √©cart ‚â•1 si trop serr√©
      const need=n-pick.length;
      const rest=Xcand.filter(x=>!pick.includes(x));
      rest.sort(()=>Math.random()-0.5);
      for(const x of rest){ if(!pick.includes(x)){ pick.push(x); if(pick.length===n) break; } }
      pick.sort((a,b)=>a-b);
    }
    return pick;
  }

  const n = Math.min(Math.max(1,nExt|0),4);
  const Xext = sampleExtPositions(n);

  const startIsMin = Math.random()<0.5;
  const levels=[];
  if(startIsMin){
    const baseMin = rint(-2, 1);
    const baseMax = rint(baseMin+2, 5);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMin+Math.floor(i/2) : baseMax+Math.floor(i/2));
  }else{
    const baseMax = rint(1, 5);
    const baseMin = rint(-2, baseMax-2);
    for(let i=0;i<n;i++) levels.push(i%2===0 ? baseMax+Math.floor(i/2) : baseMin+Math.floor(i/2));
  }

  // bornes (pas d‚Äôextremum)
  const yFirst=levels[0], yLast=levels[n-1];
  const yL = startIsMin ? rint(yFirst+1, yFirst+3) : rint(yFirst-3, yFirst-1);
  const yR = ((startIsMin && (n%2===1)) || (!startIsMin && (n%2===0)))
            ? rint(yLast+1, yLast+3) : rint(yLast-3, yLast-1);

  // n≈ìuds initiaux : borne, extr√©mums, borne
  const K=[{x:xmin,y:yL,m:undefined}];
  for(let i=0;i<n;i++) K.push({x:Xext[i], y:levels[i], m:0});
  K.push({x:xmax,y:yR,m:undefined});

// ‚Äî‚Äî‚Äî INS√âRER DES RACINES UNIQUEMENT √Ä DES ENTIERS ‚Äî‚Äî‚Äî
const roots = [];
for (let i = 0; i < K.length - 1; i++) {
  const a = K[i], b = K[i+1];
  if (a.y === 0 || b.y === 0) continue;
  if (a.y * b.y < 0) {
    const ints = [];
    for (let x = a.x + 1; x <= b.x - 1; x++) ints.push(x);
    if (ints.length) {
      const r = choice(ints);
      K.splice(i + 1, 0, { x: r, y: 0, m: undefined }); // z√©ro interne √† entier
      i++;
    } else {
      // largeur 1 : placer le z√©ro sur une ancre, en √©vitant un extr√©mum si possible
      const prefer = [a, b].filter(pt => pt.m !== 0);       // m=0 ‚áí extr√©mum
      const end = (prefer.length ? prefer : [a, b])
                  .reduce((best, pt) => Math.abs(pt.y) < Math.abs(best.y) ? pt : best);
      end.y = 0; // z√©ro sur l‚Äôancre
    }
  }
}
// Nettoyage de s√©curit√© : retirer tout n≈ìud non fini (ne devrait plus arriver)
for (let i = K.length - 1; i >= 0; i--) {
  if (!Number.isFinite(K[i].x) || !Number.isFinite(K[i].y)) K.splice(i, 1);
}


  // pentes aux bornes
  const leftNext = K[1], rightPrev = K[K.length-2];
  const sL = 0.6 * (leftNext.y - yL) / (leftNext.x - xmin);
  const sR = 0.6 * (yR - rightPrev.y) / (xmax - rightPrev.x);
  K[0].m = sL; K[K.length-1].m = sR;

  // initialisation douce des autres pentes (sauf extr√©mums m=0)
  for(let i=1;i<K.length-1;i++){
    if(K[i].m===0) continue;
    if(K[i].m!==undefined) continue;
    const prev=K[i-1], next=K[i+1];
    const dx=(next.x - prev.x)||1;
    K[i].m = (next.y - prev.y)/dx * 0.9;
  }

  // ‚Äî‚Äî‚Äî ORIENTER les pentes des racines et CLAMP monotone (helpers d√©j√† fournis) ‚Äî‚Äî‚Äî
  const extremaXs = Xext.slice();
  const anchors   = getAnchorIdx(K, extremaXs);
  alignRootSlopes(K, anchors, 0.35);
  clampMonotone(K);

  // rep√®re sym√©trique + marge
  const PAD=2;
  const yMinData = Math.min(...K.map(p=>p.y));
  const yMaxData = Math.max(...K.map(p=>p.y));
  const halfY = Math.ceil(Math.max(Math.abs(yMinData - PAD), Math.abs(yMaxData + PAD))) + 1;
  const R = { xmin: xmin - 1, xmax: xmax + 1, ymin: -halfY, ymax: +halfY };

  const extrema = Xext.map((x,i)=>({x, y:levels[i], type: ((startIsMin ? i%2===0 : i%2===1) ? 'min':'max')}));

// Racines pour le tableau : tous les x internes o√π y=0 (uniques, tri√©s)
const rootsForTable = Array.from(
  new Set(K.filter(p => p.y === 0 && p.x > xmin && p.x < xmax).map(p => p.x))
).sort((u,v)=>u-v);

// Xs/Ys pour les signes (inchang√©)
const Ymap = new Map(K.map(p=>[p.x, p.y]));
const inner = Array.from(new Set([...Xext, ...rootsForTable])).sort((a,b)=>a-b);
const Xs = [R.xmin+1, ...inner, R.xmax-1];
const Ys = Xs.map(x => (Ymap.has(x)? Ymap.get(x) : 0)); Ys[0]=K[0].y; Ys[Ys.length-1]=K[K.length-1].y;

return {
  knots: K,
  extrema,
  R,
  roots: rootsForTable,   // ‚Üê d√©sormais toujours complet (inclut le 2 dans ton exemple)
  Xs, Ys
};

}






const ex1 = {
  id: "images_fonction_carree",
  title: "Images par la fonction carr√©",

  // petite fraction irr√©ductible
  randFracCoprime() {
    const gcd = (a,b)=>{
      a=Math.abs(a); b=Math.abs(b);
      while (b){ const t=b; b=a%b; a=t; }
      return a;
    };
    while (true) {
      const num = rint(1,9);
      const den = rint(2,9);
      if (gcd(num,den) === 1) return {num,den};
    }
  },

  gen() {
    const items = [];

    // 1) Fraction positive
    const fp = this.randFracCoprime();
    items.push({
      kind:"fracPos",
      latex:`\\dfrac{${fp.num}}{${fp.den}}`,
      num:fp.num,
      den:fp.den,
      val:(fp.num*fp.num)/(fp.den*fp.den),
      ansTex:`\\dfrac{${fp.num*fp.num}}{${fp.den*fp.den}}`
    });

    // 2) Fraction n√©gative
    const fn = this.randFracCoprime();
    items.push({
      kind:"fracNeg",
      latex:`-\\dfrac{${fn.num}}{${fn.den}}`,
      num:fn.num,
      den:fn.den,
      val:(fn.num*fn.num)/(fn.den*fn.den),   // image > 0
      ansTex:`\\dfrac{${fn.num*fn.num}}{${fn.den*fn.den}}`
    });

    // 3) Entier n√©gatif
    const k = rint(2,12);
    items.push({
      kind:"entNeg",
      latex:`-${k}`,
      k,
      val:k*k,
      ansTex:`${k*k}`
    });

// 4) racine(a) : a‚àöb
const a = rint(2,9);
const b = rint(2,15);

items.push({
  kind: "rac",
  latex: `${a}\\sqrt{${b}}`,
  a,                    // <-- on stocke a
  b,                    // <-- on stocke b
  val: a * a * b,       // valeur num√©rique de l'image
  ansTex: `${a*a*b}`    // forme finale attendue
});

    // 5) puissance de 10
    const exps = [-3,-2,-1,1,2,3];      // on √©vite 0 pour que ce soit int√©ressant
    const e = choice(exps);
    items.push({
      kind:"pow10",
      latex:`10^{${e}}`,
      exp:e,
      powExp:2*e,
      val:10**(2*e),
      ansTex:`10^{${2*e}}`
    });

    // 6) somme / diff√©rence avec racine (identit√© remarquable)
    const A = rint(1,4);
    const B = rint(2,7);
    const sign = choice(["+","-"]); // a ¬± ‚àöb
    const txt = `${A}${sign}\\sqrt{${B}}`;
    const cst = A*A + B;
    const cross = 2*A;
    const main = (sign==="+")
      ? `${cst} + ${cross}\\sqrt{${B}}`
      : `${cst} - ${cross}\\sqrt{${B}}`;
    const alt  = (sign==="+")
      ? `${A*A} + ${B} + ${cross}\\sqrt{${B}}`
      : `${A*A} + ${B} - ${cross}\\sqrt{${B}}`;

    items.push({
      kind:"idR",
      latex:txt,
      A,B,sign,
      ansList:[main,alt],
      ansTex:main
    });

    // M√©lange de l‚Äôordre des 6 nombres
    items.sort(()=>Math.random()-0.5);

    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>Calculer l‚Äôimage des nombres suivants par la fonction carr√© \\(f(x)=x^2\\) :</div>
      <div class="var-wrap">
        <table class="pdf-tbl fullgrid" style="width:100%;margin-top:8px">
          <tbody>
            ${[0,1].map(row => `
              <tr>
                ${[0,1,2].map(col => {
                  const idx = 3*row+col;
                  const it = st.items[idx];
                  return `
                  <td style="width:33%;vertical-align:top;padding:8px 10px">
                    <div>\\(${it.latex} :\\)</div>
                    <div style="margin-top:10px">
                      <input class="img" data-i="${idx}" type="text"
                             style="width:90%;max-width:180px;text-align:center">
                      <span class="tick nu"></span>
                    </div>
                  </td>`;
                }).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
      <div id="res" class="steps small"></div>
    `;
    host.querySelectorAll('input.img').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const normBasic = s => (s||"")
      .trim()
      .replace(/\u2212/g,"-")       // moins unicode ‚Üí '-'
      .replace(/,/g,".")            // virgule ‚Üí point
      .replace(/\s+/g,"");          // supprime les espaces

    // nombre / fraction / sqrt(...) avec rac / ‚àö
    const parseNumRoot = s => {
      s = (s || "").trim();
      if (!s) return NaN;

      // normalisation de base
      s = s
        .replace(/\u2212/g,"-")     // moins unicode
        .replace(/,/g,".")          // virgule ‚Üí point
        .replace(/\s+/g,"")         // espaces
        .replace(/rac/gi,"sqrt")    // rac(...) ‚Üí sqrt(...)
        .replace(/‚àö/g,"sqrt");      // racine unicode ‚Üí sqrt

      let sign = 1;
      if (s[0] === '+') {
        s = s.slice(1);
      } else if (s[0] === '-') {
        sign = -1;
        s = s.slice(1);
      }

      // forme ¬±sqrt(...)
      if (s.startsWith("sqrt(") && s.endsWith(")")) {
        let inside = s.slice(5, -1);  // contenu des parenth√®ses

        let base;
        if (inside.includes("/")) {
          const [na, da] = inside.split("/");
          const n = Number(na), d = Number(da);
          if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
          base = n / d;
        } else {
          base = Number(inside);
          if (Number.isNaN(base)) return NaN;
        }
        if (base < 0) return NaN;  // on √©vite sqrt de n√©gatif
        return sign * Math.sqrt(base);
      }

      // sinon : nombre / fraction classique
      if (s.includes("/")) {
        const [na, da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d) return NaN;
        return n / d;
      }
      const x = Number(s);
      return Number.isNaN(x) ? NaN : x;
    };

    // normalisation "symbolique" pour les expressions du type 14+6‚àö5
    const normalizeRootStr = s => normBasic(s)
      .toLowerCase()
      .replace(/rac/gi,"sqrt")      // rac ‚Üí sqrt
      .replace(/‚àö/g,"sqrt")        // racine unicode ‚Üí sqrt
      .replace(/\\sqrt\{/g,"sqrt(") // \sqrt{5} ‚Üí sqrt(5
      .replace(/\}/g,"")           // enl√®ve la } finale
      .replace(/\*/g,"");          // tol√®re 6*sqrt(5)

    let ok = 0, tot = 0;   // tot = seulement les champs REMPLIS

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.img[data-i="${i}"]`);
      const raw = inp.value;
      const v = normBasic(raw);

      if (!v) {
        // champ vide ‚Üí tick neutre, pas compt√©
        setTick(inp,"nu");
        return;
      }

      tot++;

      let good = false;

      if (it.kind === "fracPos" || it.kind === "fracNeg" ||
          it.kind === "entNeg"  || it.kind === "rac") {
        const val = parseNumRoot(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - it.val) < 1e-9;
        }
      } else if (it.kind === "pow10") {
        // soit nombre (avec √©ventuellement sqrt), soit √©criture 10^k
        const val = parseNumRoot(raw);
        if (!Number.isNaN(val)) {
          good = Math.abs(val - it.val) < 1e-9;
        } else {
          const w = normBasic(raw);
          if (w.startsWith("10^")) {
            let kStr = w.slice(3);
            if (kStr.startsWith("{") && kStr.endsWith("}")) {
              kStr = kStr.slice(1,-1);
            }
            const k = Number(kStr);
            if (Number.isInteger(k)) good = (k === it.powExp);
          }
        }
      } else if (it.kind === "idR") {
        // Normalisation sp√©ciale pour a + b‚àöc
        const normId = s => (s || "")
          .trim()
          .replace(/\u2212/g, "-")        // moins unicode
          .replace(/,/g, ".")             // virgule
          .replace(/\s+/g, "")            // espaces
          .toLowerCase()
          .replace(/rac/gi, "‚àö")          // rac(...) -> ‚àö(...)
          .replace(/\\sqrt\{([^}]*)\}/g, "‚àö$1") // \sqrt{7} -> ‚àö7
          .replace(/\\sqrt/g, "‚àö")        // \sqrt7 -> ‚àö7
          .replace(/‚àö\(/g, "‚àö")           // ‚àö(7) -> ‚àö7
          .replace(/\)/g, "")             // enl√®ve parenth√®ses restantes
          .replace(/\*/g, "");            // tol√®re 2*‚àö7

        // Parse une expression du type constante + coeff * ‚àö(rad)
        // en (constant, coef, rad). Retourne null si √ßa ne colle pas.
        function parseAplusBrootC(raw) {
          let s = normId(raw);
          if (!s) return null;

          // on transforme les "-" internes en "+-" pour pouvoir splitter sur "+"
          if (s.startsWith("-")) {
            s = "-" + s.slice(1).replace(/-/g, "+-");
          } else {
            s = s.replace(/-/g, "+-");
          }

          const terms = [];
          let cur = "";
          for (let i = 0; i < s.length; i++) {
            const ch = s[i];
            if (ch === "+" && i > 0) {
              terms.push(cur);
              cur = "";
            } else {
              cur += ch;
            }
          }
          if (cur) terms.push(cur);

          let rad = null;
          let coef = 0;
          let constant = 0;

          for (const t0 of terms) {
            const t = t0;
            if (!t) continue;

            if (t.includes("‚àö")) {
              const parts = t.split("‚àö");
              let aStr = parts[0];
              const cStr = parts[1];

              if (aStr === "" || aStr === "+") aStr = "1";
              if (aStr === "-") aStr = "-1";

              const a = Number(aStr);
              const c = Number(cStr);
              if (!Number.isFinite(a) || !Number.isFinite(c)) return null;

              if (rad === null) rad = c;
              else if (Math.abs(rad - c) > 1e-9) return null; // deux racines diff√©rentes ‚Üí on refuse

              coef += a;
            } else {
              const k = Number(t);
              if (!Number.isFinite(k)) return null;
              constant += k;
            }
          }

          if (rad === null) return null;  // pas de ‚àö ‚Üí on refuse
          return { constant, coef, rad };
        }

        const parsed = parseAplusBrootC(raw);

        if (!parsed) {
          good = false;
        } else {
          const A = it.A;
          const B = it.B;
          const expectedConst = A * A + B;
          const expectedCoef  = (it.sign === "+") ? 2 * A : -2 * A;

          good =
            Math.abs(parsed.rad      - B)           < 1e-9 &&
            Math.abs(parsed.constant - expectedConst) < 1e-9 &&
            Math.abs(parsed.coef     - expectedCoef)  < 1e-9;
        }
      }




      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    $("#res",host).textContent = "";
    return { ok, total: tot };
  },



  solution(host, st) {
    const box = $("#res",host);

    const solTex = it => {
      if (it.kind === "fracPos" || it.kind === "fracNeg") {
        const n = it.num, d = it.den;
        const N = n*n, D = d*d;
        const arg = (it.kind==="fracPos")
          ? `\\dfrac{${n}}{${d}}`
          : `-\\dfrac{${n}}{${d}}`;
        return `
\\[
\\begin{aligned}
f\\left(${arg}\\right) &= \\left(${arg}\\right)^2\\\\
&= \\dfrac{${n}^2}{${d}^2}\\\\
&= \\dfrac{${N}}{${D}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "entNeg") {
        const k = it.k;
        return `
\\[
\\begin{aligned}
f(-${k}) &= (-${k})^2\\\\
&= ${k}^2\\\\
&= ${k*k}
\\end{aligned}
\\]`;
      }

if (it.kind === "rac") {
  const a = it.a, b = it.b;
  return `
\\[
\\begin{aligned}
f\\left(${a}\\sqrt{${b}}\\right)
&= \\left(${a}\\sqrt{${b}}\\right)^2\\\\
&= ${a}^2 \\times (\\sqrt{${b}})^2\\\\
&= ${a*a} \\times ${b}\\\\
&= ${a*a*b}
\\end{aligned}
\\]`;
}


      if (it.kind === "pow10") {
        const e = it.exp;
        const e2 = it.powExp;
        return `
\\[
\\begin{aligned}
f\\left(10^{${e}}\\right) &= \\left(10^{${e}}\\right)^2\\\\
&= 10^{${e}\\times 2}\\\\
&= 10^{${e2}}
\\end{aligned}
\\]`;
      }

      if (it.kind === "idR") {
        const A = it.A, B = it.B;
        const pm = it.sign === "+" ? "+" : "-";
        const pmWord = it.sign === "+" ? "+" : "-";
        const cross = 2*A;
        const cst1 = A*A;
        const cst2 = A*A + B;
        const arg = `${A}${pm}\\sqrt{${B}}`;
        return `
\\[
\\begin{aligned}
f\\left(${arg}\\right) &= \\left(${arg}\\right)^2\\\\
&= ${A}^2 ${pmWord} 2 \\times ${A} \\times \\sqrt{${B}} + (\\sqrt{${B}})^2\\\\
&= ${cst1} ${pmWord} ${cross}\\sqrt{${B}} + ${B}\\\\
&= ${cst2} ${pmWord} ${cross}\\sqrt{${B}}
\\end{aligned}
\\]`;
      }

      return "";
    };

    const cells = idx => {
      const it = st.items[idx];
      return `
<td style="vertical-align:top;padding:8px 10px">
  <div style="margin-top:6px">${solTex(it)}</div>
</td>`;
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;margin-top:4px">
        <tbody>
          <tr>
            ${cells(0)}${cells(1)}${cells(2)}
          </tr>
          <tr>
            ${cells(3)}${cells(4)}${cells(5)}
          </tr>
        </tbody>
      </table>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.img").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};

const ex2 = {
  id: "var_carre_interval",
  title: "Tableau de variations de la fonction carr√© sur un intervalle",

  gen() {
    // 30% intervalle positif, 30% n√©gatif, 40% contenant 0
    const r = Math.random();
    let type, a, b;

    if (r < 0.3) {
      // [a;b] enti√®rement positif
      type = "pos";
      a = rint(1, 5);
      b = rint(a + 1, Math.min(a + 4, 9));
    } else if (r < 0.6) {
      // [a;b] enti√®rement n√©gatif
      type = "neg";
      const A = rint(1, 5);
      const B = rint(A + 1, Math.min(A + 4, 9));
      b = -A;
      a = -B;
    } else {
      // [a;b] contenant 0
      type = "zero";
      do {
        a = -rint(1, 6);
        b =  rint(1, 6);
      } while (Math.abs(a) === b); // on √©vite |a| = b
    }

    const fa = a * a;
    const fb = b * b;

    const extrema = [];
    if (type === "pos") {
      extrema.push({ x: a, y: fa, type: "min" });
      extrema.push({ x: b, y: fb, type: "max" });
    } else if (type === "neg") {
      extrema.push({ x: a, y: fa, type: "max" });
      extrema.push({ x: b, y: fb, type: "min" });
    } else { // zero
      extrema.push({ x: 0, y: 0, type: "min" });
      if (fa > fb) {
        extrema.push({ x: a, y: fa, type: "max" });
      } else if (fb > fa) {
        extrema.push({ x: b, y: fb, type: "max" });
      } else {
        extrema.push({ x: a, y: fa, type: "max" });
        extrema.push({ x: b, y: fb, type: "max" });
      }
    }

    return { type, a, b, fa, fb, extrema };
  },

  render(host, st) {
    const { type, a, b } = st;
    const Itex = `[${a}\\,;\\,${b}]`;

    // Colonnes de x en fonction du type
    let colsX = [];
    if (type === "pos" || type === "neg") {
      colsX = [a, null, b];           // null = colonne fl√®che
    } else { // zero
      colsX = [a, null, 0, null, b];
    }

    const rowX = `
      <tr>
        <th>\\(x\\)</th>
        ${colsX.map(x =>
          x === null ? `<td></td>` : `<td>\\(${x}\\)</td>`
        ).join("")}
      </tr>`;

    const rowF = `
      <tr>
        <th>\\(f\\)</th>
        ${colsX.map((x, idx) => {
          if (x === null) {
            // colonne fl√®che
            return `
              <td class="bigsel">
                <select class="dir" data-i="${idx}"
                        style="display:block;width:100%;height:100%">
                  <option value=""></option>
                  <option>‚Üò</option>
                  <option>‚Üó</option>
                </select>
              </td>`;
          }
          // colonne valeur avec 2 lignes max/min comme dans l'exo 1
          return `
            <td>
              <div class="ycol" style="display:flex;flex-direction:column;gap:6px;align-items:center">
                <input class="ymax" data-x="${x}" type="text" style="width:80px;text-align:center">
                <input class="ymin" data-x="${x}" type="text" style="width:80px;text-align:center">
              </div>
            </td>`;
        }).join("")}
      </tr>`;

        host.innerHTML = `
      <div><b>1.</b> Donner le <b>tableau de variations</b> de la fonction carr√© d√©finie par : \\(f(x)=x^2\\) sur \\(${Itex}\\).</div>

      <div style="margin-top:.6rem">
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <label><b>2.</b> En d√©duire un <b>encadrement</b> de \\(f(x)=x^2\\) sur \\(${Itex}\\) :</label>
        </div>
        <div class="row" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px">
          <span>Pour tout \\(x\\in ${Itex}\\),</span>
          <input class="qEncMin" type="text" style="width:90px;text-align:center">
          <span>\\(\\le x^2 \\le\\)</span>
          <input class="qEncMax" type="text" style="width:90px;text-align:center">
          <span class="tick nu"></span>
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll(
      'input.ymax,input.ymin,input.qEncMin,input.qEncMax,select.dir'
    ).forEach(ensureTickAfter);

    typesetAll(host);
  },


     correct(host, st) {
    const { type, a, b, fa, fb } = st;

    const norm = s => (s || "").trim().replace(/\u2212/g, "-").replace(/,/g, ".");
    const num  = s => {
      const v = Number(norm(s));
      return Number.isFinite(v) ? v : null;
    };

    // min / max th√©oriques sur l'intervalle
    let minVal, maxVal;
    if (type === "pos") {
      minVal = fa;
      maxVal = fb;
    } else if (type === "neg") {
      minVal = fb;
      maxVal = fa;
    } else {
      minVal = 0;
      if (Math.abs(a) > Math.abs(b)) {
        maxVal = fa;
      } else {
        maxVal = fb;
      }
    }

    let ok = 0, tot = 0;

    const checkNumInput = (inp, expected) => {
      const v = inp.value.trim();
      if (!v) { setTick(inp, "nu"); return; }
      tot++;
      const n = num(v);
      const good = (n !== null && Math.abs(n - expected) < 1e-9);
      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    };

    const iMin = host.querySelector('.qEncMin');
    const iMax = host.querySelector('.qEncMax');
    if (iMin) checkNumInput(iMin, minVal);
    if (iMax) checkNumInput(iMax, maxVal);

    return { ok, total: tot };
  },



    solution(host, st) {
    const { type, a, b, fa, fb, extrema } = st;
    const extAt = x => extrema.filter(e => e.x === x);

    const Itex = `[${a}\\,;\\,${b}]`;

    let xs, dirs;
    if (type === "pos" || type === "neg") {
      xs   = [a, b];
      dirs = [type === "pos" ? "‚Üó" : "‚Üò"];
    } else {
      xs   = [a, 0, b];
      dirs = ["‚Üò", "‚Üó"];
    }

    const valBlock = x => {
      const y = x * x;
      const E = extAt(x);
      let up = "&nbsp;", dn = "&nbsp;";

      if (E.length) {
        E.forEach(e => {
          if (e.type === "max") up = `\\(${y}\\)`;
          if (e.type === "min") dn = `\\(${y}\\)`;
        });
      } else {
        up = `\\(${y}\\)`;
      }

      return `
        <td>
          <div style="text-align:center">${up}</div>
          <div style="height:6px"></div>
          <div style="text-align:center">${dn}</div>
        </td>`;
    };

    let rowX = '<tr><th>\\(x\\)</th>';
    xs.forEach((x, i) => {
      rowX += `<td>\\(${x}\\)</td>`;
      if (i < xs.length - 1) rowX += '<td></td>';
    });
    rowX += '</tr>';

    let rowF = '<tr><th>\\(f\\)</th>';
    xs.forEach((x, i) => {
      rowF += valBlock(x);
      if (i < xs.length - 1) {
        rowF += `<td>${dirs[i]}</td>`;
      }
    });
    rowF += '</tr>';

    // min / max pour l'encadrement
    let minVal, maxVal;
    if (type === "pos") {
      minVal = fa;
      maxVal = fb;
    } else if (type === "neg") {
      minVal = fb;
      maxVal = fa;
    } else {
      minVal = 0;
      if (Math.abs(a) > Math.abs(b)) {
        maxVal = fa;
      } else {
        maxVal = fb;
      }
    }

    const box = $("#res",host);
    box.innerHTML = `
      <div class="step">
        <b>1.</b> Tableau de variations de la fonction carr√© d√©finie par : \\(f(x)=x^2\\) sur \\(${Itex}\\) :
        <div class="var-wrap" style="margin-top:.4rem">
          <table class="pdf-tbl">
            <thead>${rowX}</thead>
            <tbody>
              ${rowF}
            </tbody>
          </table>
        </div>
      </div>
      <div class="step" style="margin-top:6px">
        <b>2.</b> On lit sur le tableau que, sur \\(${Itex}\\),
        le minimum de \\(f\\) vaut \\(${minVal}\\) et le maximum vaut \\(${maxVal}\\).<br>
        On en d√©duit l'encadrement :
        \\[
          \\forall x \\in ${Itex},\\quad ${minVal} \\le f(x) \\le ${maxVal}.
        \\]
      </div>
    `;
    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ymax,input.ymin,input.qminy,input.qminx,input.qmaxy,input.qmaxx,select.dir")
        .forEach(el => {
          if (el.tagName === "INPUT") el.value = "";
          setTick(el,"nu");
        });
  }
};






const ex3 = {
  id: "antecedents_carre",
  title: "Ant√©c√©dents par la fonction carr√©",

  gen() {
    const gcd = (a,b)=>{
      a = Math.abs(a); b = Math.abs(b);
      while(b){ const t=b; b=a%b; a=t; }
      return a || 1;
    };
    const isSquare = n => {
      const r = Math.round(Math.sqrt(n));
      return r*r === n;
    };

    // 1) carr√© parfait entier
    const m = rint(1, 8);
    const intPerfVal = m*m;

    // 2) carr√© non parfait
    let n;
    do {
      n = rint(2, 20);
    } while (isSquare(n));

    // 3) carr√© parfait fraction : (p/q)^2
    let p,q;
    do {
      p = rint(1, 6);
      q = rint(2, 8);
    } while (gcd(p,q) !== 1);
    const fracPerfVal = (p*p)/(q*q);

    // 4) nombre n√©gatif
    const negVal = -rint(1, 10);

    const items = [
      { kind:"intPerfect",  y:intPerfVal,   latex:`${intPerfVal}` },
      { kind:"nonPerfect",  y:n,           latex:`${n}` },
      { kind:"fracPerfect", y:fracPerfVal, p, q,        latex:`\\dfrac{${p*p}}{${q*q}}` },
      { kind:"negative",    y:negVal,      latex:`${negVal}` }
    ];

    // m√©lange des lignes
    items.sort(()=>Math.random()-0.5);

    return { items };
  },

  render(host, st) {
    host.innerHTML = `
      <div>
        On consid√®re la fonction carr√© \\(f(x)=x^2\\). Pour chacun des nombres suivants, 
        donner l‚Äôensemble de ses ant√©c√©dents r√©els par \\(f\\).<br>
        <em>Si plusieurs ant√©c√©dents, les √©crire sous la forme d‚Äôune liste s√©par√©e par un point-virgule, par exemple :</em>
        \\(-3;3\\).<br>
        <em>S‚Äôil n‚Äôy a aucun ant√©c√©dent r√©el, √©crire \\(\\varnothing\\) ou ¬´ aucun ¬ª.</em>
      </div>

      <div class="var-wrap" style="margin-top:.5rem">
        <table class="pdf-tbl fullgrid" style="width:100%;max-width:650px">
          <thead>
            <tr>
              <th>Nombre \\(y\\)</th>
              <th>Ant√©c√©dent(s) r√©el(s) par \\(f(x)=x^2\\)</th>
            </tr>
          </thead>
          <tbody>
            ${st.items.map((it,i)=>`
              <tr>
                <td style="width:35%">\\(${it.latex}\\)</td>
                <td>
                  <input class="ante" data-i="${i}" type="text"
                         style="width:95%;max-width:280px;text-align:center">
                  <span class="tick nu"></span>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>

      <div id="res" class="steps small" style="margin-top:.6rem"></div>
    `;

    host.querySelectorAll('input.ante').forEach(ensureTickAfter);
    typesetAll(host);
  },

  correct(host, st) {
    const norm = s => (s || "")
      .trim()
      .replace(/\u2212/g,"-")   // moins unicode
      .replace(/,/g,".")        // virgule ‚Üí point
      .replace(/\s+/g,"");      // espaces

    // parse un nombre avec √©ventuellement sqrt / rac / ‚àö
    const parseValue = raw => {
      let s = (raw||"").trim();
      if (!s) return NaN;

      s = s
        .replace(/\u2212/g,"-")
        .replace(/,/g,".")
        .replace(/\s+/g,"")
        .replace(/rac/gi,"sqrt")
        .replace(/‚àö/g,"sqrt");

      let sign = 1;
      if (s[0] === "+") {
        s = s.slice(1);
      } else if (s[0] === "-") {
        sign = -1;
        s = s.slice(1);
      }

      if (s.startsWith("sqrt(") && s.endsWith(")")) {
        let inside = s.slice(5,-1);
        let base;
        if (inside.includes("/")) {
          const [na,da] = inside.split("/");
          const n = Number(na), d = Number(da);
          if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
          base = n/d;
        } else {
          base = Number(inside);
          if (Number.isNaN(base)) return NaN;
        }
        if (base < 0) return NaN;
        return sign * Math.sqrt(base);
      }

      if (s.includes("/")) {
        const [na,da] = s.split("/");
        const n = Number(na), d = Number(da);
        if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
        return sign * (n/d);
      }

      const x = Number(s);
      return Number.isNaN(x) ? NaN : sign * x;
    };

    const parseListValues = raw => {
      const parts = (raw || "")
        .replace(/,/g,";")
        .split(";")
        .map(t => t.trim())
        .filter(t => t !== "");
      if (!parts.length) return null;
      const vals = [];
      for (const t of parts) {
        const v = parseValue(t);
        if (Number.isNaN(v)) return null;
        vals.push(v);
      }
      return vals;
    };

    let ok = 0, tot = 0;

    st.items.forEach((it,i)=>{
      const inp = host.querySelector(`input.ante[data-i="${i}"]`);
      if (!inp) return;
      const raw = inp.value;
      const trimmed = raw.trim();

      if (!trimmed) {
        setTick(inp,"nu");
        return;
      }

      tot++;

      let good = false;

      if (it.kind === "negative") {
        const s = trimmed.toLowerCase().replace(/\s+/g,"");
        if (
          s === "‚àÖ" || s === "√∏" ||
          s === "vide" || s === "rien" ||
          s.includes("aucun") || s.includes("aucune") ||
          s.includes("pasd")   // "pas d'..."
        ) {
          good = true;
        }
      } else {
        const y = it.y;
        const vals = parseListValues(raw);
        if (vals && vals.length === 2) {
          const v1 = vals[0], v2 = vals[1];
          const eps = 1e-6;
          const ok1 = Math.abs(v1*v1 - y) < eps;
          const ok2 = Math.abs(v2*v2 - y) < eps;
          const opp = Math.sign(v1) === -Math.sign(v2) && Math.abs(v1) > eps && Math.abs(v2) > eps;
          if (ok1 && ok2 && opp) good = true;
        }
      }

      setTick(inp, good ? "ok" : "ko");
      if (good) ok++;
    });

    const box = $("#res",host);
    if (box) {
      box.innerHTML = `
        <div class="step">
         </div>
      `;
    }

    return { ok, total: tot };
  },

  solution(host, st) {
    const box = $("#res",host);

    const solTex = it => {
      const y = it.y;
      if (it.kind === "intPerfect") {
        const m = Math.round(Math.sqrt(y));
        return `
\\[
\\begin{aligned}
x^2 &= ${y} \\\\
x &= -\\sqrt{${y}} \\quad \\text{ou} \\quad x = \\sqrt{${y}} \\\\
x &= -${m} \\quad \\text{ou} \\quad x = ${m}
\\end{aligned}
\\]`;
      }

      if (it.kind === "nonPerfect") {
        return `
\\[
\\begin{aligned}
x^2 &= ${y} \\\\
x &= -\\sqrt{${y}} \\quad \\text{ou} \\quad x = \\sqrt{${y}}.
\\end{aligned}
\\]`;
      }

      if (it.kind === "fracPerfect") {
        const p = it.p, q = it.q;
        const num = p*p, den = q*q;
        return `
\\[
\\begin{aligned}
x^2 &= \\dfrac{${num}}{${den}} \\\\
x &= -\\sqrt{\\dfrac{${num}}{${den}}} \\quad \\text{ou} \\quad x = \\sqrt{\\dfrac{${num}}{${den}}} \\\\
    &= -\\dfrac{${p}}{${q}} \\quad \\text{ou} \\quad x = \\dfrac{${p}}{${q}}.
\\end{aligned}
\\]`;
      }

      // n√©gatif
      return `
\\[
x^2 = ${y}
\\]
n'admet <b>aucune solution r√©elle</b>, car le carr√© d'un nombre r√©el est toujours positif ou nul.
Il n‚Äôy a donc <b>aucun ant√©c√©dent r√©el</b> de \\(${y}\\) par la fonction carr√©.`;
    };

    box.innerHTML = `
      <table class="pdf-tbl fullgrid" style="width:100%;max-width:750px">
        <thead>
          <tr>
            <th>Nombre \\(y\\)</th>
            <th>Correction</th>
          </tr>
        </thead>
        <tbody>
          ${st.items.map(it => `
            <tr>
              <td style="width:30%">\\(${it.latex}\\)</td>
              <td style="vertical-align:top;padding:6px 10px">
                ${solTex(it)}
              </td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;

    typesetAll(box);
  },

  reset(host) {
    const box = $("#res",host);
    if (box) box.textContent = "";
    host.querySelectorAll("input.ante").forEach(inp => {
      inp.value = "";
      setTick(inp,"nu");
    });
  }
};


const ex4 = {
  id: "ineq_x2_graph",
  title: "In√©quations du type x^2 ‚Ä¶ (lecture graphique)",

  /* ========= 1. G√©n√©ration de l‚Äô√©nonc√© ========= */
    gen() {
    // valeurs possibles pour x¬≤ (on autorise des carr√©s parfaits ET des non-carr√©s)
    const MAX_LVL = 30;
    const POS = [];
    for (let n = 1; n <= MAX_LVL; n++) POS.push(n);

    const kind = choice(["inside", "outside", "between"]);
    const data = { kind };

    if (kind === "inside") {
      // 0 < x¬≤ ‚â§ c ou 0 ‚â§ x¬≤ < c etc.
      const basePool = POS.filter(n => n >= 1 && n <= 25);
      const c = choice(basePool);            // pas forc√©ment carr√© parfait
      const strict0 = Math.random() < 0.5;   // 0 < x¬≤ ou 0 ‚â§ x¬≤
      const strictC = Math.random() < 0.5;   // < c ou ‚â§ c
      data.c = c;
      data.strict0 = strict0;
      data.strictC = strictC;

      const s0 = strict0 ? "<" : "\\le";
      const sC = strictC ? "<" : "\\le";
      data.ineqTex = `0 ${s0} x^2 ${sC} ${c}`;
    } else if (kind === "outside") {
      // x¬≤ ‚â• c ou x¬≤ > c
      const basePool = POS.filter(n => n >= 2); // on √©vite juste 1 pour ne pas √™tre trop "petit"
      const c = choice(basePool);
      const strict = Math.random() < 0.5;
      data.c = c;
      data.strict = strict;
      data.ineqTex = strict ? `x^2 > ${c}` : `x^2 \\ge ${c}`;
    } else {
      // a ‚â§ x¬≤ ‚â§ b ou variantes
      let a, b;
      do {
        a = choice(POS);
        b = choice(POS);
      } while (a === b);
      if (a > b) [a, b] = [b, a];

      const pattern = choice([
        "closed",      // a ‚â§ x¬≤ ‚â§ b
        "openLower",   // a < x¬≤ ‚â§ b
        "openUpper",   // a ‚â§ x¬≤ < b
        "openBoth"     // a < x¬≤ < b
      ]);

      data.a = a;
      data.b = b;
      data.pattern = pattern;

      const sL = (pattern === "closed" || pattern === "openUpper") ? "\\le" : "<";
      const sR = (pattern === "closed" || pattern === "openLower") ? "\\le" : "<";

      data.ineqTex = `${a} ${sL} x^2 ${sR} ${b}`;
    }

    // racines pour la solution (m√™me si non enti√®res)
    if (data.c != null) {
      data.root = Math.sqrt(data.c);
    }
    if (data.a != null && data.b != null) {
      data.rootA = Math.sqrt(data.a);
      data.rootB = Math.sqrt(data.b);
    }

    return data;
  },

  /* ========= 2. Petit helper de dessin ¬´ fa√ßon screen ¬ª ========= */

 buildSketch(st, showSolution) {
  const NS  = "http://www.w3.org/2000/svg";
  const W   = 260;
  const H   = 260;
  const x0  = 30;
  const x1  = W - 30;
  const mid = W / 2;
  const yAx = 210;
  const yTop = 35;

  const svg = document.createElementNS(NS, "svg");
  svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
  svg.setAttribute("width", W);
  svg.setAttribute("height", H);
  svg.setAttribute("class", "grid");

  /* === AXES === */
  const axX = document.createElementNS(NS, "line");
  axX.setAttribute("x1", x0);
  axX.setAttribute("x2", x1);
  axX.setAttribute("y1", yAx);
  axX.setAttribute("y2", yAx);
  axX.setAttribute("stroke", "#000");
  axX.setAttribute("stroke-width", "1.6");
  svg.appendChild(axX);

  const axY = document.createElementNS(NS, "line");
  axY.setAttribute("x1", mid);
  axY.setAttribute("x2", mid);
  axY.setAttribute("y1", yAx);
  axY.setAttribute("y2", yTop);
  axY.setAttribute("stroke", "#000");
  axY.setAttribute("stroke-width", "1.6");
  svg.appendChild(axY);

  /* === PARABOLE y = k (x-mid)¬≤ + yAx === */
  const targetEdgeY = yTop + 70;      // points extr√™mes
  const dx = x1 - mid;
  const k = (targetEdgeY - yAx) / (dx * dx); // k > 0
  const parabolaY = X => yAx + k * (X - mid) * (X - mid);

  const drawParabola = () => {
    const p = document.createElementNS(NS, "path");
    let d = "";
    const steps = 150;
    for (let i = 0; i <= steps; i++) {
      const X = x0 + (x1 - x0) * (i / steps);
      const Y = parabolaY(X);
      d += (i === 0 ? "M" : "L") + " " + X + " " + Y + " ";
    }
    p.setAttribute("d", d);
    p.setAttribute("stroke", "#000");
    p.setAttribute("stroke-width", "2.3");
    p.setAttribute("fill", "none");
    svg.appendChild(p);
  };

  drawParabola();

  /* === HELPERS === */
  const addText = (x, y, txt, anchor="middle") => {
    const t = document.createElementNS(NS, "text");
    t.setAttribute("x", x);
    t.setAttribute("y", y);
    t.setAttribute("font-size", "12");
    t.setAttribute("text-anchor", anchor);
    t.textContent = txt;
    svg.appendChild(t);
  };

  const dashH = y => {
    const L = document.createElementNS(NS, "line");
    L.setAttribute("x1", x0+5);
    L.setAttribute("x2", x1-5);
    L.setAttribute("y1", y);
    L.setAttribute("y2", y);
    L.setAttribute("stroke", "#b91c1c");
    L.setAttribute("stroke-width", "1.4");
    L.setAttribute("stroke-dasharray", "5 4");
    svg.appendChild(L);
  };

  const vertBlue = (x, yA, yB) => {
    const L = document.createElementNS(NS, "line");
    L.setAttribute("x1", x);
    L.setAttribute("x2", x);
    L.setAttribute("y1", yA);
    L.setAttribute("y2", yB);
    L.setAttribute("stroke", "#2563eb");
    L.setAttribute("stroke-width", "2");
    svg.appendChild(L);
  };

  const fillBetween = (xa, xb) => {
    const path = document.createElementNS(NS, "path");
    let d = `M ${xa} ${yAx}`;
    const steps = 80;
    for (let i = 0; i <= steps; i++) {
      const X = xa + (xb - xa) * (i / steps);
      const Y = parabolaY(X);
      d += ` L ${X} ${Y}`;
    }
    d += ` L ${xb} ${yAx} Z`;
    path.setAttribute("d", d);
    path.setAttribute("fill", "#6366f144");
    path.setAttribute("stroke", "none");
    svg.appendChild(path);
  };

  const solveIntersections = (yC) => {
    const r = Math.sqrt((yC - yAx) / k);
    return [mid - r, mid + r];
  };

  const lab = n => {
    const r = Math.sqrt(n);
    return Number.isInteger(r) ? String(r) : `‚àö${n}`;
  };

  if (!showSolution) return svg;

  /* =====================================================
        MODE SOLUTION : on place les niveaux, ant√©c√©dents,
        bo√Ætes verticales, et zones color√©es.
     ===================================================== */

  if (st.kind === "inside") {
    const yC = 120;
    dashH(yC);
    addText(mid + 12, yC - 5, String(st.c), "start");

    const [xL, xR] = solveIntersections(yC);

    vertBlue(xL, parabolaY(xL), yAx);
    vertBlue(xR, parabolaY(xR), yAx);

    fillBetween(xL, xR);

    addText(xL, yAx + 15, "-" + lab(st.c));
    addText(xR, yAx + 15, lab(st.c));
    addText(mid + 8, yAx + 15, "0", "start");
  }

  else if (st.kind === "outside") {
const yC = yAx - 50;  // par exemple toujours 50px au-dessus du sommet
    dashH(yC);
    addText(mid + 12, yC - 5, String(st.c), "start");

    const [xL, xR] = solveIntersections(yC);

    vertBlue(xL, parabolaY(xL), yAx);
    vertBlue(xR, parabolaY(xR), yAx);

    fillBetween(x0+5, xL);
    fillBetween(xR, x1-5);





    addText(xL, yAx + 15, "-" + lab(st.c));
    addText(xR, yAx + 15, lab(st.c));
    addText(mid + 8, yAx + 15, "0", "start");
  }

  else { // BETWEEN a ‚â§ x¬≤ ‚â§ b
    const yA = 180; // pour a
    const yB = 110; // pour b

    dashH(yA);
    dashH(yB);

    addText(mid + 12, yA - 4, String(st.a), "start");
    addText(mid + 12, yB - 4, String(st.b), "start");

    const [xA_L, xA_R] = solveIntersections(yA);
    const [xB_L, xB_R] = solveIntersections(yB);

    // niveaux b (haut)
    vertBlue(xB_L, parabolaY(xB_L), yAx);
    vertBlue(xB_R, parabolaY(xB_R), yAx);

    // niveaux a (bas)
    vertBlue(xA_L, parabolaY(xA_L), yAx);
    vertBlue(xA_R, parabolaY(xA_R), yAx);

    fillBetween(xB_L, xA_L);
    fillBetween(xA_R, xB_R);

    addText(xB_L, yAx + 15, "-" + lab(st.b));
    addText(xA_L, yAx + 15, "-" + lab(st.a));
    addText(xA_R, yAx + 15, lab(st.a));
    addText(xB_R, yAx + 15, lab(st.b));
    addText(mid + 8, yAx + 15, "0", "start");
  }

  return svg;
}
,


  /* ========= 3. Render : graphe + zone de saisie en intervalles ========= */

  render(host, st) {
    const { ineqTex } = st;

    host.innerHTML = `
      <div>
        √Ä l'aide de la repr√©sentation graphique de la fonction carr√© \\(f(x)=x^2\\),
        d√©terminer l'<b>ensemble des solutions</b> de l‚Äôin√©quation suivante.
      </div>

      <div style="margin-top:.35rem">
        <b>In√©quation :</b> \\(${ineqTex}\\)
      </div>

      <div class="graph" style="margin-top:.45rem">
        <div class="ineq-g"></div>
      </div>

      <div style="margin-top:.6rem">

        <div style="margin-top:.4rem;display:flex;flex-wrap:wrap;gap:8px;align-items:center">
          <span>Ensemble des solutions : \\(S =\\)</span>
          <input class="ineq-set" type="text"
                 style="width:230px;max-width:90%;text-align:center">
          <span class="tick nu"></span>
        </div>
      </div>

      <div id="res" class="steps small" style="margin-top:.7rem"></div>
    `;

    const box = host.querySelector('.ineq-g');
    box.appendChild(this.buildSketch(st, false));

    host.querySelectorAll('input.ineq-set').forEach(ensureTickAfter);

    typesetAll(host);
  },

  /* ========= 4. Correction : parseur d‚Äôintervalles ========= */

   correct(host, st) {
    const inp = host.querySelector('.ineq-set');
    const tickEl = inp ? ensureTickAfter(inp) : null;
    const raw = (inp?.value || "").trim();

    if (!raw) {
      if (tickEl) tickEl.className = "tick nu";
      return { ok: 0, total: 0 };
    }

    /* ---------- 1) Parseur d'intervalles ---------- */

           function parseIntervals(txt) {
      if (!txt) return null;

      let s = txt.trim();

      // normalisation globale
      s = s
        .replace(/\s+/g, "")       // espaces
        .replace(/\u2212/g, "-")   // ‚àí -> -
        .replace(/‚àû/g, "oo")       // ‚àû -> oo
        .replace(/\\,/g, "")       // √©ventuels \,
        .replace(/\\;/g, "");      // √©ventuels \;

      s = s.replace(/‚à™/gi, "U").replace(/u/g, "U");

      const parts = s.split(/U+/).filter(Boolean);
      if (!parts.length) return null;

      // ----- parse des bornes (nombre, rac, sqrt, ‚àö, ¬±oo) -----
      const parseBound = (t) => {
        if (!t) return NaN;
        t = t.trim().replace(/\u2212/g, "-");

        // infinis
        let low = t.toLowerCase().replace(/,/g, ".");
        if (low === "-oo" || low === "-inf") return -Infinity;
        if (low === "oo" || low === "inf" || low === "+oo" || low === "+inf") return +Infinity;

        // signe
        let sign = 1;
        if (t[0] === "+") {
          t = t.slice(1);
        } else if (t[0] === "-") {
          sign = -1;
          t = t.slice(1);
        }

        let core = t.trim().replace(/\u2212/g, "-");
        let coreLower = core.toLowerCase().replace(/,/g, ".");

        // rac -> sqrt, ‚àö -> sqrt(
        coreLower = coreLower.replace(/^rac\(/, "sqrt(").replace(/‚àö/g, "sqrt(");

        // cas sqrt(...)
        if (coreLower.startsWith("sqrt")) {
          // tol√®re "sqrt13" ‚Üí "sqrt(13)"
          if (!coreLower.includes("(")) coreLower = coreLower.replace(/^sqrt/, "sqrt(") + ")";
          if (!coreLower.endsWith(")")) coreLower += ")";

          if (coreLower.startsWith("sqrt(") && coreLower.endsWith(")")) {
            const inside = coreLower.slice(5, -1);
            let base;
            if (inside.includes("/")) {
              const [na, da] = inside.split("/");
              const n = Number(na), d = Number(da);
              if (!d || Number.isNaN(n) || Number.isNaN(d)) return NaN;
              base = n / d;
            } else {
              base = Number(inside);
              if (Number.isNaN(base)) return NaN;
            }
            if (base < 0) return NaN;
            return sign * Math.sqrt(base);
          }
        }

        // nombre "simple"
        const v = Number(coreLower);
        return Number.isFinite(v) ? sign * v : NaN;
      };

      const intervals = [];

      for (const part of parts) {
        if (part.length < 4) return null;

        const L = part[0];
        const R = part[part.length - 1];
        if (!"[]()".includes(L) || !"[]()".includes(R)) return null;

        const inside = part.slice(1, -1);
        const sepIdx = inside.indexOf(";") >= 0 ? inside.indexOf(";") : inside.indexOf(",");
        if (sepIdx < 0) return null;

        const aStr = inside.slice(0, sepIdx);
        const bStr = inside.slice(sepIdx + 1);

        const a = parseBound(aStr);
        const b = parseBound(bStr);
        if (Number.isNaN(a) || Number.isNaN(b)) return null;

        // ordre coh√©rent (sauf infinis)
        if (Number.isFinite(a) && Number.isFinite(b) && a > b + 1e-9) return null;

        // crochets / parenth√®ses -> ouvert / ferm√©
        const openL = (L === ']' || L === '('); // [ ferm√©, ] / ( ouverts
        const openR = (R === '[' || R === ')'); // ] ferm√©, [ / ) ouverts

        intervals.push({ a, b, openL, openR });
      }

      // tri pour comparer ind√©pendamment de l'ordre de saisie
      intervals.sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      return intervals;
    }



    /* ---------- 2) Ensemble attendu en fonction du cas ---------- */

    const EPS = 1e-6;
    const kind = st.kind;

    const expected = (() => {
      // petits helpers pour les racines (toujours des carr√©s parfaits ici)
      const r  = st.c  != null ? Math.sqrt(st.c)  : null;
      const rA = st.a  != null ? Math.sqrt(st.a)  : null;
      const rB = st.b  != null ? Math.sqrt(st.b)  : null;

      if (kind === "inside") {
        const strict0 = !!st.strict0; // 0 < ... ?
        const strictC = !!st.strictC; // ... < c ?

        if (!strict0) {
          // 0 ‚â§ x¬≤ ‚Ä¶  ‚áí intervalle unique [-r ; r] ou ]-r ; r[
          return [{
            a: -r,
            b:  r,
            openL: strictC,   // < c  ‚áí bornes ouvertes
            openR: strictC
          }];
        }

        // 0 < x¬≤ ‚Ä¶  ‚áí deux intervalles, trou en 0
        if (!strictC) {
          // 0 < x¬≤ ‚â§ c  ‚áí [-r;0[ ‚à™ ]0;r]
          return [
            { a: -r, b: 0, openL: false, openR: true  },
            { a:  0, b: r, openL: true,  openR: false }
          ];
        }
        // 0 < x¬≤ < c  ‚áí ]-r;0[ ‚à™ ]0;r[
        return [
          { a: -r, b: 0, openL: true, openR: true },
          { a:  0, b: r, openL: true, openR: true }
        ];
      }

      if (kind === "outside") {
        const r = Math.sqrt(st.c);
        const strict = !!st.strict;   // > c ou ‚â• c
        return [
          { a: -Infinity, b: -r, openL: true,  openR: strict },   // ]-oo ; -r] ou ]-oo ; -r[
          { a:  r,        b: +Infinity, openL: strict, openR: true } // [r ; +oo[ ou ]r ; +oo[
        ];
      }

      // between : a ‚Ä¶ x¬≤ ‚Ä¶ b

      const p  = st.pattern; // "closed", "openLower", "openUpper", "openBoth"

      if (p === "closed") {
        // a ‚â§ x¬≤ ‚â§ b
        return [
          { a: -rB, b: -rA, openL: false, openR: false },
          { a:  rA, b:  rB, openL: false, openR: false }
        ];
      }
      if (p === "openLower") {
        // a < x¬≤ ‚â§ b
        return [
          { a: -rB, b: -rA, openL: false, openR: true  }, // [-rB ; -rA[
          { a:  rA, b:  rB, openL: true,  openR: false }  // ]rA ; rB]
        ];
      }
      if (p === "openUpper") {
        // a ‚â§ x¬≤ < b
        return [
          { a: -rB, b: -rA, openL: true,  openR: false }, // ]-rB ; -rA]
          { a:  rA, b:  rB, openL: false, openR: true  }  // [rA ; rB[
        ];
      }
      // openBoth : a < x¬≤ < b
      return [
        { a: -rB, b: -rA, openL: true, openR: true },    // ]-rB ; -rA[
        { a:  rA, b:  rB, openL: true, openR: true }     // ]rA ; rB[
      ];
    })();

    /* ---------- 3) Comparaison user / attendu ---------- */

    const got = parseIntervals(raw);
    let ok = 0, tot = 1;
    let good = false;

    if (got && got.length === expected.length) {
      const numEq = (x, y) => {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return x === y;
        return Math.abs(x - y) < EPS;
      };

      // on trie expected aussi, pour tol√©rer l'ordre d'√©criture
      const expSorted = expected.slice().sort((u, v) => {
        if (u.a === v.a) {
          if (u.b === v.b) return 0;
          return u.b < v.b ? -1 : 1;
        }
        return u.a < v.a ? -1 : 1;
      });

      good = true;
      for (let i = 0; i < got.length; i++) {
        const g = got[i];
        const e = expSorted[i];
        if (!numEq(g.a, e.a) || !numEq(g.b, e.b) ||
            g.openL !== e.openL || g.openR !== e.openR) {
          good = false;
          break;
        }
      }
    }

    if (tickEl) tickEl.className = "tick " + (good ? "ok" : "ko");
    if (good) ok = 1;

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">
          On lit sur le graphique les abscisses limites (par exemple \\(-6\\) et \\(6\\)),
          puis on √©crit l‚Äôensemble des solutions sous forme d‚Äôintervalle(s),
          en utilisant \\([\\,]\\) pour une borne incluse et \\(]\\,[\\) pour une borne exclue,
          ainsi que \\(-\\infty\\) et \\(+\\infty\\) si n√©cessaire.
        </div>
      `;
      typesetAll(box);
    }

    return { ok, total: tot };
  },


  /* ========= 5. Solution : m√™me dessin mais avec parabole remplie ========= */

   solution(host, st) {
    const sqrtTex = n => {
      const r = Math.sqrt(n);
      return Number.isInteger(r) ? String(r) : `\\sqrt{${n}}`;
    };

    const kind = st.kind;

    // 1) Graphe interactif : on remplace la parabole vierge par la version "corrig√©e"
    const gHost = host.querySelector('.ineq-g');
    if (gHost) {
      gHost.innerHTML = "";
      gHost.appendChild(this.buildSketch(st, true)); // parabole remplie avec zones
    }

    // 2) Texte + graphe corrig√© dans le bloc de solution (pour le PDF)
    let solTex = "";

    if (kind === "inside") {
      const c   = st.c;
      const rT  = sqrtTex(c);
      const s0  = st.strict0 ? "<" : "\\le";
      const sC  = st.strictC ? "<" : "\\le";

      if (!st.strict0) {
        // 0 ‚â§ x¬≤ ‚Ä¶  ‚áí intervalle unique
        const Itex = st.strictC ? `]-${rT};${rT}[` : `[-${rT};${rT}]`;
        solTex = `
\\[
0 ${s0} x^2 ${sC} ${c}
\\iff -${rT} ${st.strictC ? "<" : "\\le"} x ${st.strictC ? "<" : "\\le"} ${rT}
\\]
L‚Äôensemble des solutions est donc : \\(${Itex}\\).
`;
      } else {
        // 0 < x¬≤ ‚Ä¶  ‚áí trou en 0 (r√©union de deux intervalles)
        const I1 = st.strictC ? `]-${rT};0[` : `[-${rT};0[`;
        const I2 = st.strictC ? `]0;${rT}[` : `]0;${rT}]`;
        solTex = `
\\[
0 ${s0} x^2 ${sC} ${c}
\\iff x \\neq 0 \\;\\text{et}\\; ${ (st.strictC ? `|x| < ${rT}` : `|x| \\le ${rT}`) }
\\]
L‚Äôensemble des solutions est donc :
\\(${I1} \\cup ${I2}\\).
`;
      }
    }
    else if (kind === "outside") {
      const c   = st.c;
      const rT  = sqrtTex(c);
      const strict = !!st.strict;
      const leftInt  = strict ? `]-\\infty;-${rT}[` : `]-\\infty;-${rT}]`;
      const rightInt = strict ? `]${rT};+\\infty[` : `[${rT};+\\infty[`;
      const sSym = strict ? ">" : "\\ge";
      const sL   = strict ? "<" : "\\le";
      const sR   = strict ? ">" : "\\ge";

      solTex = `
\\[
x^2 ${sSym} ${c}
\\iff x ${sL} -${rT} \\quad \\text{ou} \\quad x ${sR} ${rT}
\\]
L‚Äôensemble des solutions est donc
\\(${leftInt} \\cup ${rightInt}\\).
`;
    }
    else {
      const a   = st.a, b = st.b;
      const rA  = sqrtTex(a);
      const rB  = sqrtTex(b);
      const p   = st.pattern;

      const sL = (p === "closed" || p === "openUpper") ? "\\le" : "<";
      const sR = (p === "closed" || p === "openLower") ? "\\le" : "<";

      let I1, I2;
      if (p === "closed") {
        I1 = `[-${rB};-${rA}]`;
        I2 = `[${rA};${rB}]`;
      } else if (p === "openLower") {
        I1 = `[-${rB};-${rA}[`;
        I2 = `]${rA};${rB}]`;
      } else if (p === "openUpper") {
        I1 = `]-${rB};-${rA}]`;
        I2 = `[${rA};${rB}[`;
      } else {
        I1 = `]-${rB};-${rA}[`;
        I2 = `]${rA};${rB}[`;
      }

      solTex = `
\\[
${a} ${sL} x^2 ${sR} ${b}
\\]
L‚Äôensemble des solutions est donc :
\\(
 ${I1} \\cup ${I2}.
\\)
`;
    }

    const box = $("#res", host);
    if (box) {
      box.innerHTML = `
        <div class="step">

        </div>
        <div class="step" style="margin-top:.4rem">
          <!-- Graphe corrig√© pour la solution / le PDF -->
          <div class="graph" style="margin-bottom:.5rem">
            <div class="ineq-sol-graph"></div>
          </div>
          ${solTex}
        </div>
      `;

      // On ins√®re une copie de la parabole corrig√©e dans la zone "solution"
      const solG = box.querySelector('.ineq-sol-graph');
      if (solG) {
        solG.appendChild(this.buildSketch(st, true));
      }
    }
    typesetAll(box);
  },


  /* ========= 6. Reset ========= */

  reset(host) {
    const box = $("#res", host);
    if (box) box.textContent = "";
    const inp = host.querySelector('.ineq-set');
    if (inp) {
      inp.value = "";
      setTick(inp, "nu");
    }
    const gHost = host.querySelector('.ineq-g');
    if (gHost) gHost.innerHTML = "";
  }
};

/* ‚Äî‚Äî‚Äî‚Äî‚Äî Registre & UI ‚Äî‚Äî‚Äî‚Äî‚Äî */
const REGISTRY=[ex1,ex2,ex3,ex4];
window.REGISTRY = REGISTRY; // pour le kit PDF

(function waitExoPDF(){
  if (window.ExoPDF && typeof ExoPDF.init === 'function') {
    ExoPDF.init({
      title: 'Seconde ‚Äì Fonction cube',
      mountAfterSelector: '.card.small',
    });
  } else {
    setTimeout(waitExoPDF, 50);
  }
})();

function getDefById(id){ return REGISTRY.find(d=>d.id===id)||REGISTRY[0]; }

function buildOne(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st);
  def.render(host,st);
  try{ if(window.MathKbd?.attachAllInputs){ MathKbd.attachAllInputs(host);} }catch(_){}
}
function checkAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}');
  const r=def.correct(host,st)||{ok:0,total:0};
  scoreOK=r.ok; scoreTot=r.total; updateScore();
}
function showSolution(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st);
}
function resetAll(){
  const def=getDefById($("#exo-select").value), host=$("#host");
  def.reset(host); scoreOK=0; scoreTot=0; updateScore();
}

document.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); checkAll(); } });

(function init(){
  const sel=$("#exo-select");
  sel.innerHTML = REGISTRY.map((ex,idx)=>`<option value="${ex.id}">${idx+1} ‚Äî ${ex.title}</option>`).join('');
  sel.onchange = buildOne;
  $("#btn-new").onclick=buildOne;
  $("#btn-check").onclick=checkAll;
  $("#btn-solution").onclick=showSolution;
  $("#btn-reset").onclick=resetAll;
  sel.value = REGISTRY[0].id;
  buildOne();
})();

})();
</script>
</body>
</html>
