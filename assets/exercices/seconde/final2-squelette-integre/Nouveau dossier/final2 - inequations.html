<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Seconde ‚Äì Chapitre 1 ‚Äì In√©quations (1er degr√©) ‚Äì Exercices</title>
<link href="../../../../css/math-kbd.css" rel="stylesheet"/>
<style>
  :root{ --card-bg:#fff; --card-bd:#e6e6e6; --muted:#6b7280; }
  *{box-sizing:border-box} html,body{margin:0;padding:0}
  body{font-family:system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#fafafa; color:#111; line-height:1.55}

  .header{position:sticky; top:0; background:#fff; border-bottom:1px solid #eee}
  .header .wrap{padding:12px 16px}

  .wrap{max-width:1100px; margin:0 auto; padding:16px; display:flex; flex-direction:column; gap:12px}
  .card{background:var(--card-bg); border:1px solid var(--card-bd); border-radius:12px; padding:14px}

  .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  #exo-select{min-width:320px}
  select,button,input[type=text]{font-size:15px}
  .btn{padding:8px 12px; border:1px solid #dadada; border-radius:10px; background:#f7f7f7; cursor:pointer}
  .btn:hover{background:#efefef}

  .row{display:grid; grid-template-columns:1fr; gap:12px; align-items:start}
  .statement .consigne{opacity:.85; margin-bottom:6px}
  .ans-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .ans-row input[type=text]{flex:1; min-width:240px}
  .steps{background:#f6f7f8; border:1px dashed #cfd3d7; border-radius:10px; padding:.7rem .8rem; min-height:52px}
  .steps .line{white-space:pre-wrap; color:var(--muted)}

  .accept .title{font-weight:600}
  .kbd-wrap{display:flex; justify-content:center}
</style>
<style>
*{box-sizing:border-box}
body{font-family:system-ui, Segoe UI, Roboto, Arial; margin:0; background:#fafafa; color:#111; line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:nowrap;gap:8px;align-items:center;overflow-x:auto}
select,input[type=text]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer;white-space:nowrap}
.btn:hover{background:#efefef}
.score{font-weight:700;white-space:nowrap}
.small{font-size:.92rem;color:#666}
.row{display:grid;grid-template-columns:1fr auto 260px;gap:8px;align-items:center}
.row .label{font-weight:600}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.equ{font-weight:700}

/* Fractions ‚Äúpile‚Äù (sans LaTeX) */
.frac{display:inline-flex;flex-direction:column;align-items:center;vertical-align:middle;line-height:1}
.frac .num,.frac .den{padding:0 .2em; white-space:nowrap}
.frac .bar{border-top:1.6px solid currentColor;align-self:stretch;margin:.06em 0}
.frac-sign{margin-right:.15em}

/* √âtapes (une seule relation par ligne) */
.steps{margin:.5rem 0 0 .15rem;padding:.35rem .5rem;background:#fafafa;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.2rem 0}
.hint{color:#444}
</style></head>
<body>
<!-- En-t√™te -->
<div class="header">
<div class="wrap">
<div class="controls">
<label for="exo-select"><strong>Type d‚Äôexercice :</strong></label>
<select id="exo-select"></select>
<button class="btn" id="btn-new">üîÑ Nouvel √©nonc√©</button>
<button class="btn" id="btn-check">‚úÖ V√©rifier</button>
<button class="btn" id="btn-solution">üí° Solution</button>
<button class="btn" id="btn-reset">üßπ R√©initialiser</button>
<span class="score">Score : <span id="score">0 / 0</span></span><span class="small" id="status"></span></div>
</div>
</div>
<!-- Corps -->
<div class="wrap">
<!-- √ânonc√© + saisie + corrig√© -->
<div class="card" id="host"></div>
<!-- Saisie & r√©ponses accept√©es (volontairement vide) -->
<div class="card accept" id="accept"><div class="title">Saisie &amp; r√©ponses accept√©es :</div></div>
<!-- L‚ÄôUI PDF se montera ici (apr√®s #accept) -->
<!-- Clavier math (auto-mount par la lib) -->
<div class="card kbd-wrap">
<div data-math-kbd=""></div>
</div>
</div>
<!-- JS (versions *.multiplicatif uniquement) -->
<script defer="" src="../../../../js/ch0-mul-clean.multiplicatif.js"></script>
<script defer="" src="../../../../js/dev-rules-clean.dedup.js"></script>
<script defer="" src="../../../../js/algebra-eval-patch.multiplicatif.js"></script>
<script defer="" src="../../../../js/exo-pdf-kit.multiplicatif.js"></script>
<script defer="" src="../../../../js/math-kbd.multiplicatif.js"></script>
<!-- Orchestration minimale (sans exercices) -->
<script>
  (function(){
    'use strict';
    const $ = (s,r=document)=>r.querySelector(s);

    /* Cadre g√©n√©rique √ânonc√©/Saisie/Corrig√© */
    function mkFrame(host, {consigneHTML='', enonceHTML='', placeholder='‚Ä¶'}={}){
      host.innerHTML = `
        <div class="row">
          <div class="statement">
            ${consigneHTML ? `<div class="consigne">${consigneHTML}</div>` : ''}
            ${enonceHTML ? `<div class="equ">${enonceHTML}</div>` : ''}
            <div class="ans-row" style="margin-top:.5rem">
              <label for="reponse"><strong>R√©ponse :</strong></label>
              <input type="text" id="reponse" placeholder="${placeholder}">
            </div>
            <div id="res" class="small" aria-live="polite"></div>
          </div>
          <div id="sol" class="steps"><div class="line">Le corrig√© s‚Äôaffichera ici.</div></div>
        </div>`;
      const ip=$("#reponse",host);
      ip && ip.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); check(); } });
    }

    /* Catalogue vide (√† remplir plus tard) */
    const REGISTRY = (window.REGISTRY = []);

    /* Actions boutons */
    function buildOne(){
      const sel=$("#exo-select"), host=$("#host");
      const def = REGISTRY.find(e=>e.id===sel.value);
      if(!def){
        mkFrame(host,{consigneHTML:'S√©lectionnez un type d‚Äôexercice.', placeholder:'‚Ä¶'});
        $("#res",host).textContent = 'Aucun exercice charg√© (squelette).';
        return;
      }
      const st = def.gen ? def.gen() : {};
      host.dataset.active = def.id;
      host.dataset.state = JSON.stringify(st);
      (def.render || mkFrame)(host, st);
    }
    function check(){
      const host=$("#host");
      const def = REGISTRY.find(e=>e.id===host.dataset.active);
      if(def && typeof def.correct==='function'){
        const st = JSON.parse(host.dataset.state||'{}');
        def.correct(host, st);
      }
    }
    function solution(){
      const host=$("#host");
      const def = REGISTRY.find(e=>e.id===host.dataset.active);
      if(def && typeof def.solution==='function'){
        const st = JSON.parse(host.dataset.state||'{}');
        def.solution(host, st);
      }
    }
    function resetAll(){
      const host=$("#host");
      const ip=$("#reponse",host); if(ip) ip.value='';
      $("#res",host).textContent='';
      $("#sol",host).innerHTML='<div class="line">Le corrig√© s‚Äôaffichera ici.</div>';
    }

    /* Init */
    document.addEventListener('DOMContentLoaded', function(){
      // s√©lecteur (reste vide si REGISTRY vide)
      $("#exo-select").innerHTML = REGISTRY.map(e=>`<option value="${e.id}">${e.title}</option>`).join('');
      $("#exo-select").addEventListener('change', buildOne);

      $("#btn-new").addEventListener('click', buildOne);
      $("#btn-check").addEventListener('click', check);
      $("#btn-solution").addEventListener('click', solution);
      $("#btn-reset").addEventListener('click', resetAll);

      // Pas d'appel √† MathKbd.autoMount() -> √©vite le double clavier

      // PDF (UI apr√®s #accept)
      if (window.ExoPDF?.init){
        ExoPDF.init({
          title: 'Seconde ‚Äî Squelette d‚Äôexercices',
          mountAfterSelector: '#accept',
          max: 50,
          lead: ''
        });
      }

      buildOne(); // cadre ‚Äúpr√™t‚Äù
    });
  })();
  </script>
<script>
(function(){'use strict';
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=a=>a[Math.floor(Math.random()*a.length)];

/* ========= Fractions ‚Äúpile‚Äù ========= */
function fracHTML(p,q){
  const sign = (p<0) ? '‚àí' : '';
  p = Math.abs(p); q = Math.abs(q);
  if(q===1) return sign + String(p);
  return (sign ? `<span class="frac-sign">${sign}</span>` : '') +
         `<span class="frac"><span class="num">${p}</span><span class="bar"></span><span class="den">${q}</span></span>`;
}
function fracExprHTML(numerHTML, den){
  return `<span class="frac"><span class="num">${numerHTML}</span><span class="bar"></span><span class="den">${den}</span></span>`;
}

/* ========= Rationnels ========= */
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function norm(p,q){ if(q===0) throw new Error("denominator 0"); let g=gcd(p,q); p/=g; q/=g; if(q<0){ p=-p; q=-q; } return {p,q}; }
function addR(A,B){ return norm(A.p*B.q + B.p*A.q, A.q*B.q); }
function subR(A,B){ return norm(A.p*B.q - B.p*A.q, A.q*B.q); }
function mulR(A,B){ return norm(A.p*B.p, A.q*B.q); }
function divR(A,B){ if(B.p===0) throw new Error("div by 0"); return norm(A.p*B.q, A.q*B.p); }
function isZero(R){ return R.p===0; }
function toNumber(R){ return R.p / R.q; }
function makeR(p,q){ return norm(p,q||1); }
function absR(R){ return makeR(Math.abs(R.p), R.q); }
function quotientRaw(N,D){ // N/D brut, signe sur le num√©rateur
  let num = N.p * D.q, den = N.q * D.p;
  if(den<0){ num = -num; den = -den; }
  return {p:num, q:den};
}
function needsSimplify(fr){ return gcd(Math.abs(fr.p), Math.abs(fr.q)) > 1; }

/* ========= Affichage √©quations/coeffs ========= */
function isOne(R){ return R.q===1 && R.p===1; }
function isNegOne(R){ return R.q===1 && R.p===-1; }
function fmtCoeffXHTML(A){
  if(isOne(A)) return "x";
  if(isNegOne(A)) return "‚àíx";
  return `${fracHTML(A.p,A.q)}x`;
}
function fmtConstHTML(B){ return (B.q===1? String(B.p) : fracHTML(B.p,B.q)); }
function fmtSignedConstHTML(B){
  if(isZero(B)) return "";
  const abs = absR(B);
  const core = fmtConstHTML(abs);
  return (B.p>0? " + " : " ‚àí ") + core;
}
function sideHTML(A,B){ return fmtCoeffXHTML(A) + fmtSignedConstHTML(B); }

/* ========= Nettoyage signes pour les √©tapes ========= */
function normalizeSigns(html){
  return html
    .replace(/\+\s*[‚àí-]/g, ' ‚àí ')
    .replace(/[‚àí-]\s*\+/g, ' ‚àí ')
    .replace(/[‚àí-]\s*[‚àí-]/g, ' + ')
    .replace(/\+\s*\+/g, ' + ')
    .replace(/\s{2,}/g, ' ');
}

/* ========= Parsing r√©ponses ========= */
function parseNumberOrFrac(str){
  if(!str) return null;
  let s = str.trim().replace(/\u2212/g,'-');
  if(/^[-+]?(\d+([.,]\d+)?|\d*[.,]\d+)$/.test(s)){ s=s.replace(',','.'); return parseFloat(s); }
  const m = s.match(/^([-+]?\d+)\s*\/\s*([-+]?\d+)$/);
  if(m){ const p = parseInt(m[1],10), q = parseInt(m[2],10); if(q===0) return null; return p/q; }
  return null;
}
function sameNumber(a,b){ const na=parseFloat(a), nb=parseFloat(b); if(Number.isNaN(na)||Number.isNaN(nb)) return false; return Math.abs(na-nb)<1e-9; }

function parseIneq(str){
  if(!str) return null;
  let s = str.trim().replace(/\s+/g,'').replace(/^x=/i,'').replace(/^x/i,'x');
  s = s.replace(/<=/g,'‚â§').replace(/>=/g,'‚â•');
  const m = s.match(/^x(‚â§|‚â•|<|>)(.+)$/i);
  if(!m) return null;
  const op = m[1];
  const v  = parseNumberOrFrac(m[2]); if(v===null) return null;
  return {op, val: v};
}
function parseInterval(str){
  if(!str) return null;
  let s = str.trim().replace(/\s+/g,'');
  s = s.replace(/^S=/i,'');
  s = s.replace(/\(/g,']').replace(/\)/g,'['); // accepte () aussi
  // normalise s√©parateurs
  s = s.replace(/,/g,';');
  // infinis
  s = s.replace(/\+?‚àû/g,'+‚àû').replace(/-‚àû/g,'‚àí‚àû').replace(/-\s*oo/gi,'‚àí‚àû').replace(/\+\s*oo/gi,'+‚àû').replace(/oo/gi,'‚àû');
  const m = s.match(/^([\[\]])([^;]+);([^ \[\]]+)([\[\]])$/);
  if(!m) return null;
  const leftB  = m[1], a = m[2], b = m[3], rightB = m[4];
  const leftOpen  = (leftB === ']');
  const rightOpen = (rightB === '[');
  const leftInf   = (a === '‚àí‚àû');
  const rightInf  = (b === '+‚àû');
  let leftVal = null, rightVal = null;
  if(!leftInf){ const v = parseNumberOrFrac(a); if(v===null) return null; leftVal = v; }
  if(!rightInf){ const v = parseNumberOrFrac(b); if(v===null) return null; rightVal = v; }
  return {leftOpen, rightOpen, leftInf, rightInf, leftVal, rightVal};
}

/* ========= Construction solution canonique ========= */
const invert = {'<':'>','>':'<','‚â§':'‚â•','‚â•':'‚â§'};
function cmpIneq(a,b){ return a && b && a.op===b.op && sameNumber(a.val,b.val); }

function canonFromBound(op, R){
  // renvoie {ineqHTML, ineqObj, intervalHTML, intervalObj}
  const ineqHTML = `x ${op} ${R.q===1? R.p : fracHTML(R.p,R.q)}`;
  let intervalHTML, intervalObj;
  if(op==='>' ){ intervalHTML = `S = ]${R.q===1? R.p : (fracHTML(R.p,R.q))} ; +‚àû[`; intervalObj = {leftOpen:true,  leftInf:false, leftVal:toNumber(R), rightOpen:true,  rightInf:true}; }
  if(op==='‚â•'){ intervalHTML = `S = [${R.q===1? R.p : (fracHTML(R.p,R.q))} ; +‚àû[`; intervalObj = {leftOpen:false, leftInf:false, leftVal:toNumber(R), rightOpen:true,  rightInf:true}; }
  if(op==='<' ){ intervalHTML = `S = ]‚àí‚àû ; ${R.q===1? R.p : (fracHTML(R.p,R.q))}[`; intervalObj = {leftOpen:true,  leftInf:true,  rightOpen:true,  rightInf:false, rightVal:toNumber(R)}; }
  if(op==='‚â§'){ intervalHTML = `S = ]‚àí‚àû ; ${R.q===1? R.p : (fracHTML(R.p,R.q))}]`; intervalObj = {leftOpen:true,  leftInf:true,  rightOpen:false, rightInf:false, rightVal:toNumber(R)}; }
  return {ineqHTML, ineqObj:{op, val:toNumber(R)}, intervalHTML, intervalObj};
}
function intervalToString(obj){
  const L = obj.leftInf ? '‚àí‚àû' : (Number.isInteger(obj.leftVal)? String(obj.leftVal): String(obj.leftVal));
  const R = obj.rightInf? '+‚àû' : (Number.isInteger(obj.rightVal)? String(obj.rightVal): String(obj.rightVal));
  const lb = obj.leftOpen? ']' : '[';
  const rb = obj.rightOpen? '[' : ']';
  return `S = ${lb}${L} ; ${R}${rb}`;
}
function cmpInterval(ans, exp){
  if(!ans || !exp) return false;
  if(!!ans.leftInf !== !!exp.leftInf) return false;
  if(!!ans.rightInf !== !!exp.rightInf) return false;
  if(!ans.leftInf && !sameNumber(ans.leftVal, exp.leftVal)) return false;
  if(!ans.rightInf && !sameNumber(ans.rightVal, exp.rightVal)) return false;
  return (ans.leftOpen===exp.leftOpen) && (ans.rightOpen===exp.rightOpen);
}

/* ========= Gabarit rendu / correction ========= */
function renderTwoAnswers(host, htmlIneq){
  host.innerHTML="";
  // Enonc√©
  const row0=document.createElement("div"); row0.className="row";
  const lab0=document.createElement("div"); lab0.className="equ"; lab0.innerHTML=htmlIneq; row0.appendChild(lab0);
  const spacer=document.createElement("div"); spacer.textContent=""; row0.appendChild(spacer);
  const res0=document.createElement("div"); res0.textContent=""; row0.appendChild(res0);
  host.appendChild(row0);

  // R√©ponse 1 : in√©galit√©
  const row1=document.createElement("div"); row1.className="row";
  const lab1=document.createElement("div"); lab1.className="label"; lab1.textContent="R√©ponse in√©galit√©";
  const inp1=document.createElement("input"); inp1.type="text"; inp1.id="reponseIneq"; inp1.placeholder="ex.  x ‚â• -2/3  ou  x > 1.5";
  const res1=document.createElement("div"); res1.id="resIneq";
  row1.appendChild(lab1); row1.appendChild(inp1); row1.appendChild(res1);
  host.appendChild(row1);

  // R√©ponse 2 : ensemble
  const row2=document.createElement("div"); row2.className="row";
  const lab2=document.createElement("div"); lab2.className="label"; lab2.textContent="R√©ponse ensemble";
  const inp2=document.createElement("input"); inp2.type="text"; inp2.id="reponseSet"; inp2.placeholder="ex.  S = ]-‚àû ; -2/3]  ou  S=[a ; +‚àû[";
  const res2=document.createElement("div"); res2.id="resSet";
  row2.appendChild(lab2); row2.appendChild(inp2); row2.appendChild(res2);
  host.appendChild(row2);

  return {inp1, inp2, res1, res2};
}

/* ========= Types d‚Äôexercices (solutions = seuil unique x ? k) ========= */
function randOp(){ return choice(['<','>','‚â§','‚â•']); }

/* 1) ax + b ? c (entiers, a ‚â† 0) */
const ex1 = {
  id:"ineq_simple",
  title:"R√©soudre : ax + b ? c",
  gen(){
    let a=0; while(a===0) a=rnd(-9,9);
    const b=rnd(-12,12), c=rnd(-12,12), op=randOp();
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1);
    const rhs = subR(C,B); // c - b
    let finalOp = (A.p<0? invert[op]:op);
    const frac = quotientRaw(rhs, A);
    const solR = divR(rhs, A);
    const canon = canonFromBound(finalOp, solR);
    return {A,B,C,op, rhs, Aneg:(A.p<0), finalOp, frac, solR, canon};
  },
  text(st){ return `${sideHTML(st.A,st.B)} ${st.op} ${fmtConstHTML(st.C)}`; },
  render(host, st){ renderTwoAnswers(host, this.text(st)); },
  correct(host, st){
    const ie = parseIneq($("#reponseIneq",host).value);
    const se = parseInterval($("#reponseSet",host).value);
    const okI = cmpIneq(ie, st.canon.ineqObj);
    const okS = cmpInterval(se, st.canon.intervalObj);
    $("#resIneq",host).innerHTML = okI? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.ineqHTML})`;
    $("#resIneq",host).className = okI? "res-ok":"res-ko";
    $("#resSet",host).innerHTML  = okS? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.intervalHTML})`;
    $("#resSet",host).className  = okS? "res-ok":"res-ko";
    return {ok: okI && okS, total: 2};
  },
  solution(host, st){
    const steps=[];
    steps.push(`${sideHTML(st.A,st.B)} ${st.op} ${fmtConstHTML(st.C)}`);
    steps.push(`${fmtCoeffXHTML(st.A)} ${st.op} ${fmtConstHTML(st.C)} ‚àí ${fmtConstHTML(st.B)}`);
    steps.push(`${fmtCoeffXHTML(st.A)} ${st.op} ${fmtConstHTML(st.rhs)}`);
    if(st.Aneg) steps.push(`<span class="hint">Comme ${fmtConstHTML(st.A)} &lt; 0, on inverse le sens de l‚Äôin√©galit√©.</span>`);
    const rawLine = `x ${st.finalOp} ${fracHTML(st.frac.p, st.frac.q)}`;
    steps.push(rawLine);
    if(needsSimplify(st.frac)) steps.push(`x ${st.finalOp} ${st.solR.q===1? st.solR.p : fracHTML(st.solR.p, st.solR.q)}`);
    steps.push(st.canon.intervalHTML);
    const html = `<div class="steps">${steps.map(s=>`<div class="step">${normalizeSigns(s)}</div>`).join("")}</div>`;
    $("#resSet",host).innerHTML = html;
    $("#reponseIneq",host).value = st.canon.ineqObj.op + " " + (st.solR.q===1? st.solR.p : `${st.solR.p}/${st.solR.q}`); // pour que l‚Äô√©l√®ve voie le format
    $("#reponseIneq",host).value = `x ${st.canon.ineqObj.op} ${st.solR.q===1? st.solR.p : `${st.solR.p}/${st.solR.q}`}`;
    $("#reponseSet",host).value  = st.canon.intervalHTML.replace(/<[^>]*>/g,'');
  },
  reset(host){ $("#reponseIneq",host).value=""; $("#reponseSet",host).value=""; $("#resIneq",host).textContent=""; $("#resSet",host).textContent=""; }
};

/* 2) ax + b ? cx + d (entiers, a ‚â† c) */
const ex2 = {
  id:"ineq_two_sides",
  title:"R√©soudre : ax + b ? cx + d",
  gen(){
    let a=0,c=0; while(a===0) a=rnd(-8,8); while(c===0||c===a) c=rnd(-8,8);
    const b=rnd(-12,12), d=rnd(-12,12), op=randOp();
    const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1), D=makeR(d,1);
    const L = subR(A,C);     // a-c
    const Rr= subR(D,B);     // d-b
    let finalOp = (L.p<0? invert[op]:op);
    const frac = quotientRaw(Rr, L);
    const solR = divR(Rr, L);
    const canon = canonFromBound(finalOp, solR);
    return {A,B,C,D,op,L,Rr, Lneg:(L.p<0), finalOp, frac, solR, canon};
  },
  text(st){ return `${sideHTML(st.A,st.B)} ${st.op} ${sideHTML(st.C,st.D)}`; },
  render(host, st){ renderTwoAnswers(host, this.text(st)); },
  correct(host, st){
    const ie = parseIneq($("#reponseIneq",host).value);
    const se = parseInterval($("#reponseSet",host).value);
    const okI = cmpIneq(ie, st.canon.ineqObj);
    const okS = cmpInterval(se, st.canon.intervalObj);
    $("#resIneq",host).innerHTML = okI? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.ineqHTML})`;
    $("#resIneq",host).className = okI? "res-ok":"res-ko";
    $("#resSet",host).innerHTML  = okS? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.intervalHTML})`;
    $("#resSet",host).className  = okS? "res-ok":"res-ko";
    return {ok: okI && okS, total: 2};
  },
  solution(host, st){
    const steps=[];
    steps.push(`${sideHTML(st.A,st.B)} ${st.op} ${sideHTML(st.C,st.D)}`);
    steps.push(`${fmtCoeffXHTML(st.A)} ‚àí ${fmtCoeffXHTML(st.C)} ${st.op} ${fmtConstHTML(st.D)} ‚àí ${fmtConstHTML(st.B)}`);
    steps.push(`${fmtCoeffXHTML(st.L)} ${st.op} ${fmtConstHTML(st.Rr)}`);
    if(st.Lneg) steps.push(`<span class="hint">Comme ${fmtConstHTML(st.L)} &lt; 0, on inverse le sens de l‚Äôin√©galit√©.</span>`);
    const rawLine = `x ${st.finalOp} ${fracHTML(st.frac.p, st.frac.q)}`;
    steps.push(rawLine);
    if(needsSimplify(st.frac)) steps.push(`x ${st.finalOp} ${st.solR.q===1? st.solR.p : fracHTML(st.solR.p, st.solR.q)}`);
    steps.push(st.canon.intervalHTML);
    const html = `<div class="steps">${steps.map(s=>`<div class="step">${normalizeSigns(s)}</div>`).join("")}</div>`;
    $("#resSet",host).innerHTML = html;
    $("#reponseIneq",host).value = `x ${st.canon.ineqObj.op} ${st.solR.q===1? st.solR.p : `${st.solR.p}/${st.solR.q}`}`;
    $("#reponseSet",host).value  = st.canon.intervalHTML.replace(/<[^>]*>/g,'');
  },
  reset(host){ $("#reponseIneq",host).value=""; $("#reponseSet",host).value=""; $("#resIneq",host).textContent=""; $("#resSet",host).textContent=""; }
};

/* 3) a(x+b) ? c   et   a(x+b) ? c(x+d)+e  (entiers) */
const ex3 = {
  id:"ineq_parentheses",
  title:"R√©soudre avec parenth√®ses",
  gen(){
    const mode = choice(['one','two']);
    const op=randOp();
    if(mode==='one'){
      let a=0; while(a===0) a=rnd(-6,6);
      const b=rnd(-6,6), c=rnd(-18,18);
      const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1);
      const ab = mulR(A,B);
      const rhs = subR(C, ab);          // c - ab
      let finalOp = (A.p<0? invert[op]:op);
      const frac = quotientRaw(rhs, A);
      const solR = divR(rhs, A);
      const canon = canonFromBound(finalOp, solR);
      return {fmt:'one', A,B,C, op, ab, rhs, Aneg:(A.p<0), finalOp, frac, solR, canon};
    } else {
      let a=0,c=0; while(a===0) a=rnd(-6,6); while(c===0||c===a) c=rnd(-6,6);
      const b=rnd(-6,6), d=rnd(-6,6), e=rnd(-10,10);
      const A=makeR(a,1), B=makeR(b,1), C=makeR(c,1), D=makeR(d,1), E=makeR(e,1);
      const left  = mulR(A,B);           // ab
      const cd    = mulR(C,D);
      const right = addR(cd, E);         // cd + e
      const L = subR(A,C);               // a-c
      const Rr= subR(right, left);       // (cd+e) - ab
      let finalOp = (L.p<0? invert[op]:op);
      const frac = quotientRaw(Rr, L);
      const solR = divR(Rr, L);
      const canon = canonFromBound(finalOp, solR);
      return {fmt:'two', A,B,C,D,E, left, cd, right, L, Rr, op, Lneg:(L.p<0), finalOp, frac, solR, canon};
    }
  },
  text(st){
    if(st.fmt==='one') return `${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)}) ${st.op} ${fmtConstHTML(st.C)}`;
    const left = `${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)})`;
    const right = `${st.C.p}(x ${st.D.p>=0?'+':'-'} ${Math.abs(st.D.p)})${st.E.p===0?'':(st.E.p>0?' + '+st.E.p:' - '+Math.abs(st.E.p))}`;
    return `${left} ${st.op} ${right}`;
  },
  render(host, st){ renderTwoAnswers(host, this.text(st)); },
  correct(host, st){
    const ie = parseIneq($("#reponseIneq",host).value);
    const se = parseInterval($("#reponseSet",host).value);
    const okI = cmpIneq(ie, st.canon.ineqObj);
    const okS = cmpInterval(se, st.canon.intervalObj);
    $("#resIneq",host).innerHTML = okI? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.ineqHTML})`;
    $("#resIneq",host).className = okI? "res-ok":"res-ko";
    $("#resSet",host).innerHTML  = okS? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.intervalHTML})`;
    $("#resSet",host).className  = okS? "res-ok":"res-ko";
    return {ok: okI && okS, total: 2};
  },
  solution(host, st){
    const steps=[];
    if(st.fmt==='one'){
      steps.push(`${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)}) ${st.op} ${fmtConstHTML(st.C)}`);
      steps.push(`${fmtCoeffXHTML(st.A)} + ${fmtConstHTML(mulR(st.A,st.B))} ${st.op} ${fmtConstHTML(st.C)}`);
      steps.push(`${fmtCoeffXHTML(st.A)} ${st.op} ${fmtConstHTML(st.C)} ‚àí ${fmtConstHTML(mulR(st.A,st.B))}`);
      steps.push(`${fmtCoeffXHTML(st.A)} ${st.op} ${fmtConstHTML(st.rhs)}`);
      if(st.Aneg) steps.push(`<span class="hint">Comme ${fmtConstHTML(st.A)} &lt; 0, on inverse le sens de l‚Äôin√©galit√©.</span>`);
      const raw = `x ${st.finalOp} ${fracHTML(st.frac.p, st.frac.q)}`;
      steps.push(raw);
      if(needsSimplify(st.frac)) steps.push(`x ${st.finalOp} ${st.solR.q===1? st.solR.p : fracHTML(st.solR.p, st.solR.q)}`);
    } else {
      steps.push(`${st.A.p}(x ${st.B.p>=0?'+':'-'} ${Math.abs(st.B.p)}) ${st.op} ${st.C.p}(x ${st.D.p>=0?'+':'-'} ${Math.abs(st.D.p)})${st.E.p===0?'':(st.E.p>0?' + '+st.E.p:' - '+Math.abs(st.E.p))}`);
      steps.push(`${fmtCoeffXHTML(st.A)} + ${fmtConstHTML(st.left)} ${st.op} ${fmtCoeffXHTML(st.C)} + ${fmtConstHTML(st.cd)} ${st.E.p===0?'':(st.E.p>0?' + '+fmtConstHTML(st.E):' ‚àí '+fmtConstHTML(absR(st.E)))}`);
      steps.push(`${fmtCoeffXHTML(subR(st.A,st.C))} ${st.op} ${fmtConstHTML(st.cd)} ${st.E.p===0?'':(st.E.p>0?' + '+fmtConstHTML(st.E):' ‚àí '+fmtConstHTML(absR(st.E)))} ‚àí ${fmtConstHTML(st.left)}`);
      steps.push(`${fmtCoeffXHTML(st.L)} ${st.op} ${fmtConstHTML(st.Rr)}`);
      if(st.Lneg) steps.push(`<span class="hint">Comme ${fmtConstHTML(st.L)} &lt; 0, on inverse le sens de l‚Äôin√©galit√©.</span>`);
      const raw = `x ${st.finalOp} ${fracHTML(st.frac.p, st.frac.q)}`;
      steps.push(raw);
      if(needsSimplify(st.frac)) steps.push(`x ${st.finalOp} ${st.solR.q===1? st.solR.p : fracHTML(st.solR.p, st.solR.q)}`);
    }
    const canon = st.canon.intervalHTML;
    steps.push(canon);
    const html = `<div class="steps">${steps.map(s=>`<div class="step">${normalizeSigns(s)}</div>`).join("")}</div>`;
    $("#resSet",host).innerHTML = html;
    $("#reponseIneq",host).value = `x ${st.canon.ineqObj.op} ${st.solR.q===1? st.solR.p : `${st.solR.p}/${st.solR.q}`}`;
    $("#reponseSet",host).value  = canon.replace(/<[^>]*>/g,'');
  },
  reset(host){ $("#reponseIneq",host).value=""; $("#reponseSet",host).value=""; $("#resIneq",host).textContent=""; $("#resSet",host).textContent=""; }
};

/* 4) (px+q)/m ? (rx+s)/n (entiers, m,n‚àà{2..6}) */
const ex4 = {
  id:"ineq_fractions",
  title:"In√©quations avec fractions (formes rationnelles)",
  gen(){
    const m=choice([2,3,4,5,6]), n=choice([2,3,4,5,6]), op=randOp();
    let p=0,r=0; while(p===0) p=rnd(-6,6); while(r===0) r=rnd(-6,6);
    const q=rnd(-8,8), s=rnd(-8,8);
    const M=makeR(m,1), N=makeR(n,1), P=makeR(p,1), Q=makeR(q,1), R=makeR(r,1), S0=makeR(s,1);
    const L = subR( mulR(N,P), mulR(M,R) ); // Np - Mr
    const Rr= subR( mulR(M,S0), mulR(N,Q) ); // Ms - Nq
    let finalOp = (L.p<0? invert[op]:op);
    const solR = divR(Rr, L);
    const frac = quotientRaw(Rr, L);
    const canon = canonFromBound(finalOp, solR);
    return {M,N,P,Q,R,S0, op, L,Rr, Lneg:(L.p<0), finalOp, solR, frac, canon};
  },
  text(st){
    const leftNum  = st.Q.p===0 ? fmtCoeffXHTML(st.P) : (fmtCoeffXHTML(st.P) + (st.Q.p>0? " + "+fmtConstHTML(st.Q) : " ‚àí "+fmtConstHTML(absR(st.Q))));
    const rightNum = st.S0.p===0? fmtCoeffXHTML(st.R) : (fmtCoeffXHTML(st.R) + (st.S0.p>0? " + "+fmtConstHTML(st.S0) : " ‚àí "+fmtConstHTML(absR(st.S0))));
    return `${fracExprHTML(leftNum, st.M.p)} ${st.op} ${fracExprHTML(rightNum, st.N.p)}`;
  },
  render(host, st){ renderTwoAnswers(host, this.text(st)); },
  correct(host, st){
    const ie = parseIneq($("#reponseIneq",host).value);
    const se = parseInterval($("#reponseSet",host).value);
    const okI = cmpIneq(ie, st.canon.ineqObj);
    const okS = cmpInterval(se, st.canon.intervalObj);
    $("#resIneq",host).innerHTML = okI? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.ineqHTML})`;
    $("#resIneq",host).className = okI? "res-ok":"res-ko";
    $("#resSet",host).innerHTML  = okS? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.intervalHTML})`;
    $("#resSet",host).className  = okS? "res-ok":"res-ko";
    return {ok: okI && okS, total: 2};
  },
  solution(host, st){
    const steps=[];
    steps.push(this.text(st));
    steps.push(`${st.N.p}( ${fmtCoeffXHTML(st.P)} ${st.Q.p===0?'':(st.Q.p>0?' + ':' ‚àí ')+fmtConstHTML(absR(st.Q))} ) ${st.op} ${st.M.p}( ${fmtCoeffXHTML(st.R)} ${st.S0.p===0?'':(st.S0.p>0?' + ':' ‚àí ')+fmtConstHTML(absR(st.S0))} )`);
    steps.push(`${fmtConstHTML(mulR(st.N,st.P))}x ${fmtSignedConstHTML(mulR(st.N,st.Q))} ${st.op} ${fmtConstHTML(mulR(st.M,st.R))}x ${fmtSignedConstHTML(mulR(st.M,st.S0))}`);
    steps.push(`${fmtCoeffXHTML(st.L)} ${st.op} ${fmtConstHTML(st.Rr)}`);
    if(st.Lneg) steps.push(`<span class="hint">Comme ${fmtConstHTML(st.L)} &lt; 0, on inverse le sens de l‚Äôin√©galit√©.</span>`);
    const raw = `x ${st.finalOp} ${fracHTML(st.frac.p, st.frac.q)}`;
    steps.push(raw);
    if(needsSimplify(st.frac)) steps.push(`x ${st.finalOp} ${st.solR.q===1? st.solR.p : fracHTML(st.solR.p, st.solR.q)}`);
    steps.push(st.canon.intervalHTML);
    const html = `<div class="steps">${steps.map(s=>`<div class="step">${normalizeSigns(s)}</div>`).join("")}</div>`;
    $("#resSet",host).innerHTML = html;
    $("#reponseIneq",host).value = `x ${st.canon.ineqObj.op} ${st.solR.q===1? st.solR.p : `${st.solR.p}/${st.solR.q}`}`;
    $("#reponseSet",host).value  = st.canon.intervalHTML.replace(/<[^>]*>/g,'');
  },
  reset(host){ $("#reponseIneq",host).value=""; $("#reponseSet",host).value=""; $("#resIneq",host).textContent=""; $("#resSet",host).textContent=""; }
};

/* 5) ax + b ? cx + d (coeffs entiers OU fractions ; a ‚â† c) */
const ex5 = {
  id:"ineq_two_sides_rational",
  title:"ax + b ? cx + d (coefficients entiers ou fractions)",
  gen(){
    function randRational(opts={allowZero:true}){
      const isFrac = Math.random()<0.45;
      if(!isFrac){
        let v = opts.allowZero ? rnd(-9,9) : (function(){let x=0;while(x===0) x=rnd(-9,9); return x;})();
        return makeR(v,1);
      }
      const d = choice([2,3,4,5,6]);
      const n = opts.allowZero ? rnd(-9,9) : (function(){let x=0;while(x===0) x=rnd(-9,9); return x;})();
      return makeR(n,d);
    }
    let A=randRational({allowZero:false}), C=randRational({allowZero:false});
    while(A.p===C.p && A.q===C.q){ C=randRational({allowZero:false}); }
    const B=randRational(), D=randRational(), op=randOp();
    const L=subR(A,C), Rr=subR(D,B);
    let finalOp = (L.p<0? invert[op]:op);
    const solR = divR(Rr, L);
    const frac = quotientRaw(Rr, L);
    const canon = canonFromBound(finalOp, solR);
    return {A,B,C,D,op,L,Rr, Lneg:(L.p<0), finalOp, solR, frac, canon};
  },
  text(st){ return `${sideHTML(st.A,st.B)} ${st.op} ${sideHTML(st.C,st.D)}`; },
  render(host, st){ renderTwoAnswers(host, this.text(st)); },
  correct(host, st){
    const ie = parseIneq($("#reponseIneq",host).value);
    const se = parseInterval($("#reponseSet",host).value);
    const okI = cmpIneq(ie, st.canon.ineqObj);
    const okS = cmpInterval(se, st.canon.intervalObj);
    $("#resIneq",host).innerHTML = okI? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.ineqHTML})`;
    $("#resIneq",host).className = okI? "res-ok":"res-ko";
    $("#resSet",host).innerHTML  = okS? "‚úî" : `‚úò (attendu&nbsp;: ${st.canon.intervalHTML})`;
    $("#resSet",host).className  = okS? "res-ok":"res-ko";
    return {ok: okI && okS, total: 2};
  },
  solution(host, st){
    const steps=[];
    steps.push(`${sideHTML(st.A,st.B)} ${st.op} ${sideHTML(st.C,st.D)}`);
    steps.push(`${fmtCoeffXHTML(st.A)} ‚àí ${fmtCoeffXHTML(st.C)} ${st.op} ${fmtConstHTML(st.D)} ‚àí ${fmtConstHTML(st.B)}`);
    steps.push(`${fmtCoeffXHTML(st.L)} ${st.op} ${fmtConstHTML(st.Rr)}`);
    if(st.Lneg) steps.push(`<span class="hint">Comme ${fmtConstHTML(st.L)} &lt; 0, on inverse le sens de l‚Äôin√©galit√©.</span>`);
    const raw = `x ${st.finalOp} ${fracHTML(st.frac.p, st.frac.q)}`;
    steps.push(raw);
    if(needsSimplify(st.frac)) steps.push(`x ${st.finalOp} ${st.solR.q===1? st.solR.p : fracHTML(st.solR.p, st.solR.q)}`);
    steps.push(st.canon.intervalHTML);
    const html = `<div class="steps">${steps.map(s=>`<div class="step">${normalizeSigns(s)}</div>`).join("")}</div>`;
    $("#resSet",host).innerHTML = html;
    $("#reponseIneq",host).value = `x ${st.canon.ineqObj.op} ${st.solR.q===1? st.solR.p : `${st.solR.p}/${st.solR.q}`}`;
    $("#reponseSet",host).value  = st.canon.intervalHTML.replace(/<[^>]*>/g,'');
  },
  reset(host){ $("#reponseIneq",host).value=""; $("#reponseSet",host).value=""; $("#resIneq",host).textContent=""; $("#resSet",host).textContent=""; }
};

const REGISTRY = [ex1, ex2, ex3, ex4, ex5];
window.REGISTRY = REGISTRY; // pour exo-pdf-kit

/* ========= Score & actions ========= */
let scoreOK=0, scoreTot=0;
function updateScore(){ $("#score").textContent = scoreOK+" / "+scoreTot; }

function buildOne(){
  const sel=$("#exo-select"), host=$("#host");
  const def=REGISTRY.find(e=>e.id===sel.value); if(!def) return;
  const st=def.gen();
  host.dataset.active = def.id;
  host.dataset.state  = JSON.stringify(st);
  def.render(host, st);
  const inp = $("#reponseIneq",host); if(inp) inp.focus();
}
function check(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  const r=def.correct(host, st);
  if(r){ scoreOK += (r.ok?1:0); scoreTot += (r.total||1); updateScore(); }
}
function solution(){
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||"{}");
  def.solution(host, st);
}
function resetAll(){
  scoreOK=0; scoreTot=0; updateScore();
  const host=$("#host");
  const def=REGISTRY.find(e=>e.id===host.dataset.active);
  if(def){ def.reset(host); }
}

document.addEventListener("DOMContentLoaded", function(){
  const sel=$("#exo-select");
  REGISTRY.forEach(e=>{ const o=document.createElement("option"); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
  sel.addEventListener("change", buildOne);
  $("#btn-new").addEventListener("click", buildOne);
  $("#btn-check").addEventListener("click", check);
  $("#btn-solution").addEventListener("click", solution);
  $("#btn-reset").addEventListener("click", resetAll);
  sel.value = REGISTRY[0].id;
  buildOne(); updateScore();
});
})();
</script><script defer="" src="../../../../js/math-kbd.js"></script><script defer="" src="../../../../js/exo-pdf-kit.js"></script><script>
document.addEventListener('DOMContentLoaded', function(){
  ExoPDF.init({
    title: 'Seconde ‚Äì Chapitre 1 ‚Äì In√©quations',
    lead:  'R√©soudre l‚Äôin√©quation :',
    max: 50
  });
});
</script><script defer="" src="../../../../js/algebra-eval-patch.js"></script></body>
</html>
