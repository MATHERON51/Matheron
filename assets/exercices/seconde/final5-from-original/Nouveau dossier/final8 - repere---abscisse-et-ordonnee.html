<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Seconde – Repère : Abscisse et ordonnée</title>
<link href="../../../../css/math-kbd.css" rel="stylesheet"/>
<style>
  :root{ --card-bg:#fff; --card-bd:#e6e6e6; --muted:#6b7280; }
  *{box-sizing:border-box} html,body{margin:0;padding:0}
  body{font-family:system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#fafafa; color:#111; line-height:1.55}

  .header{position:sticky; top:0; background:#fff; border-bottom:1px solid #eee}
  .header .wrap{padding:12px 16px}

  .wrap{max-width:1100px; margin:0 auto; padding:16px; display:flex; flex-direction:column; gap:12px}
  .card{background:var(--card-bg); border:1px solid var(--card-bd); border-radius:12px; padding:14px}

  .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  #exo-select{min-width:320px}
  select,button,input[type=text]{font-size:15px}
  .btn{padding:8px 12px; border:1px solid #dadada; border-radius:10px; background:#f7f7f7; cursor:pointer}
  .btn:hover{background:#efefef}

  .row{display:grid; grid-template-columns:1fr; gap:12px; align-items:start}
  .statement .consigne{opacity:.85; margin-bottom:6px}
  .ans-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .ans-row input[type=text]{flex:1; min-width:240px}
  .steps{background:#f6f7f8; border:1px dashed #cfd3d7; border-radius:10px; padding:.7rem .8rem; min-height:52px}
  .steps .line{white-space:pre-wrap; color:var(--muted)}

  .accept .title{font-weight:600}
  .kbd-wrap{display:flex; justify-content:center}
</style>
<style>
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#fafafa;color:#111;line-height:1.5}
.header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
.wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
.card{background:#fff;border:1px solid #e6e6e6;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,input[type=text],input[type=number]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
.btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid #dadada;background:#f7f7f7;border-radius:10px;cursor:pointer}
.btn:hover{background:#efefef}
.score{font-weight:700}
.small{font-size:.92rem;color:#666}
.row{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.row.norepere{grid-template-columns:1fr}
.res-ok{color:#11823b;font-weight:700}
.res-ko{color:#b00020;font-weight:700}
.code{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f7f7f7;border:1px dashed #ddd;border-radius:8px;padding:2px 6px}
.kbd{padding:.06rem .35rem;border:1px solid #ccc;border-radius:6px;background:#fff}
.steps{margin:.45rem 0 0 .15rem;padding:.5rem .6rem;background:#f6f6f6;border:1px dashed #e3e3e3;border-radius:8px}
.step{margin:.25rem 0}
.hint{color:#444;font-style:italic;margin:.25rem 0}
.svgbox{width:420px;height:420px;border:1px solid #ddd;border-radius:8px;background:#fff}
.optionline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chips{display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.chip{border:1px solid #bbb;border-radius:999px;padding:.2rem .55rem;cursor:pointer;user-select:none}
.chip.active{border-color:#111;box-shadow:inset 0 0 0 1px #111}
.chip .dot{display:inline-block;width:.7rem;height:.7rem;border-radius:50%;margin-right:.3rem;vertical-align:middle}
@media print{ .controls,.header,.kbd-host,.hide-print{display:none!important} .card{box-shadow:none} }
</style></head>
<body>
<!-- En-tête -->
<div class="header">
<div class="wrap">
<div class="controls"><div class="controls card">
<label for="exo-select"><strong>Type d’exercice :</strong></label>
<select id="exo-select"></select>
<button class="btn" id="btn-new">🔄 Nouvel énoncé</button>
<button class="btn" id="btn-check">✅ Vérifier</button>
<button class="btn" id="btn-solution">💡 Solution</button>
<button class="btn" id="btn-reset">🧹 Réinitialiser</button>
<span class="score">Score : <span id="score">0 / 0</span></span>
<span class="small" id="status"></span>
</div></div>
</div>
</div>
<!-- Corps -->
<div class="wrap">
<!-- Énoncé + saisie + corrigé -->
<div class="controls card" id="ampbar">
<strong>Amplitude du repère (max ±12) :</strong>
<span>x ∈ [</span><input id="xmin" max="12" min="-12" step="1" type="number" value="-6"/><span>;</span>
<input id="xmax" max="12" min="-12" step="1" type="number" value="6"/><span>],</span>
<span>y ∈ [</span><input id="ymin" max="12" min="-12" step="1" type="number" value="-6"/><span>;</span>
<input id="ymax" max="12" min="-12" step="1" type="number" value="6"/><span>]</span>
<button class="btn" id="amp-apply">↴ Appliquer</button>
<label class="small" style="margin-left:10px"><input checked="" id="pdfRand" type="checkbox"/> PDF : amplitude aléatoire (par énoncé)</label>
<span style="margin-left:16px"></span>
<strong>Nombre de points (exos 6–9) :</strong>
<input id="nbPts" max="10" min="3" step="1" style="width:80px" type="number" value="3"/>
</div><div class="card" id="host"><div aria-live="polite" class="card" id="host"></div><div class="card small">
<strong>Règles de saisie :</strong>
<ul style="margin:8px 0 0 18px">
<li>Coordonnées au format <span class="code">(x;y)</span> (ex. <span class="code">(3;−2)</span>). Le <span class="code">-</span> ASCII est normalisé en « − » (U+2212).</li>
<li>Abscisse / ordonnée : entier ou fraction <span class="code">a/b</span>.</li>
</ul>
</div></div>
<!-- Saisie & réponses acceptées (volontairement vide) -->
<div class="card accept" id="accept"><div class="title">Saisie &amp; réponses acceptées :</div></div>
<!-- L’UI PDF se montera ici (après #accept) -->
<!-- Clavier math (auto-mount par la lib) -->
<div class="card kbd-wrap">
<div data-math-kbd=""></div>
</div>
</div>
<!-- JS (versions *.multiplicatif uniquement) -->





<!-- Orchestration minimale (sans exercices) -->

<script defer="" src="../../../../js/exo-pdf-kit.js"></script><script>
(function(){'use strict';
/* ================= Utils ================= */
const $=(s,r=document)=>r.querySelector(s);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const UMINUS='−';
const normalizeMinus = s => String(s||'').split('-').join(UMINUS).replace(/\s+/g,' ').trim();
const uminusStr = n => (n<0?UMINUS:'')+Math.abs(n);
const coordToText = (x,y) => `(${uminusStr(x)};${uminusStr(y)})`;
const clip12 = v => Math.max(-12, Math.min(12, v));
const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
const PALETTE = ['#2e7d32','#1565c0','#6a1b9a','#ef6c00','#00897b','#c62828','#6d4c41','#ad1457','#283593','#0277bd'];
const colorOf = L => PALETTE[LETTERS.indexOf(L)%PALETTE.length];

function parseCoord(txt){
  txt=normalizeMinus(txt);
  const re = new RegExp('^\\(\\s*([0-9]+|(?:\\u2212[0-9]+))\\s*;\\s*([0-9]+|(?:\\u2212[0-9]+))\\s*\\)$');
  const m=txt.match(re);
  if(!m) return null;
  return { x:parseInt(m[1].replace(UMINUS,'-'),10), y:parseInt(m[2].replace(UMINUS,'-'),10) };
}
function parseNumberLike(s){
  s = normalizeMinus(s);
  const reInt = new RegExp('^[\\u2212-]?\\d+$');
  if(reInt.test(s)) return {type:'int', n:parseInt(s.replace(UMINUS,'-'),10)};
  const reFrac = new RegExp('^([\\u2212-]?\\d+)\\s*\\/\\s*([\\u2212-]?\\d+)$');
  const m = s.match(reFrac);
  if(m){ const n=parseInt(m[1].replace(UMINUS,'-'),10), d=parseInt(m[2].replace(UMINUS,'-'),10); if(d!==0) return {type:'frac', n,d}; }
  return null;
}
function equalsInt(val,I){ if(!val) return false; if(val.type==='int') return val.n===I; if(val.type==='frac') return val.n===I*val.d; return false; }

/* RNG */
function seedPRNG(seed){ let t=Math.imul(1779033703 ^ seed,3432918353); t=(t<<13)|(t>>>19);
  return function(){ t=Math.imul(t^(t>>>16),2246822507); t=Math.imul(t^(t>>>13),3266489909); t^=t>>>16; return (t>>>0)/4294967296; }; }
const seededRndInt=(rng,a,b)=>a+Math.floor(rng()*(b-a+1));

/* =============== Amplitude (UI) =============== */
const AMP = { xmin:-6, xmax:6, ymin:-6, ymax:6 };
const getNbPts = () => {
  const n = parseInt($('#nbPts')?.value??'3',10);
  return clamp(isNaN(n)?3:n,3,10);
};
function applyAMPInputs(){
  let xi=+$('#xmin').value, xa=+$('#xmax').value, yi=+$('#ymin').value, ya=+$('#ymax').value;
  xi=clamp(isNaN(xi)?-6:xi,-12,12); xa=clamp(isNaN(xa)?6:xa,-12,12);
  yi=clamp(isNaN(yi)?-6:yi,-12,12); ya=clamp(isNaN(ya)?6:ya,12);
  if(xi===xa) xa=clamp(xi+1,-12,12); if(yi===ya) ya=clamp(yi+1,-12,12);
  if(xi>xa) [xi,xa]=[xa,xi]; if(yi>ya) [yi,ya]=[ya,yi];
  Object.assign(AMP,{xmin:xi,xmax:xa,ymin:yi,ymax:ya});
  ['xmin','xmax','ymin','ymax'].forEach(id=>$('#'+id).value=AMP[id]);
  buildOne();
}

/* ========= Amplitudes PDF : origine visible + au moins [-6;6] ========= */
function ensureCoverMin6Origin(R){
  let xmin = Math.min(R.xmin, -6);
  let xmax = Math.max(R.xmax,  6);
  let ymin = Math.min(R.ymin, -6);
  let ymax = Math.max(R.ymax,  6);
  return { xmin:clip12(xmin), xmax:clip12(xmax), ymin:clip12(ymin), ymax:clip12(ymax) };
}
function randAMPWithOriginMin6(){
  const xmin = rnd(-12, -6);
  const xmax = rnd(  6, 12);
  const ymin = rnd(-12, -6);
  const ymax = rnd(  6, 12);
  return { xmin, xmax, ymin, ymax };
}

/* =============== Repère =============== */
class Repere{
  constructor(R={xmin:-6,xmax:6,ymin:-6,ymax:6},{ticks=true,quadrants=false,orth=true,norm=true}={}){
    this.R={...R}; this.ticks=ticks; this.quadrants=quadrants; this.orth=orth; this.norm=norm;
    this.points=[]; this.user=[]; this.clickable=false; this.onClick=null;
    this.el=this._makeSVG(); this.redraw();
  }
  _makeSVG(){
    const s=document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('class','svgbox'); s.setAttribute('viewBox','0 0 420 420');
    const defs=document.createElementNS(s.namespaceURI,'defs');
    const marker=document.createElementNS(s.namespaceURI,'marker');
    marker.setAttribute('id','arrow'); marker.setAttribute('orient','auto');
    marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8');
    marker.setAttribute('refX','0'); marker.setAttribute('refY','3');
    const path=document.createElementNS(s.namespaceURI,'path');
    path.setAttribute('d','M0,0 L0,6 L8,3 z'); path.setAttribute('fill','#000');
    marker.appendChild(path); defs.appendChild(marker); s.appendChild(defs);
    this.gGrid=document.createElementNS(s.namespaceURI,'g');
    this.gAxes=document.createElementNS(s.namespaceURI,'g');
    this.gQ=document.createElementNS(s.namespaceURI,'g');
    this.gPts=document.createElementNS(s.namespaceURI,'g');
    this.gUser=document.createElementNS(s.namespaceURI,'g');
    [this.gGrid,this.gAxes,this.gQ,this.gPts,this.gUser].forEach(g=>s.appendChild(g));
    s.addEventListener('click',ev=>{
      if(!this.clickable||!this.onClick) return;
      const r=s.getBoundingClientRect(), x=ev.clientX-r.left, y=ev.clientY-r.top;
      const c=this.screenToCoord(x,y);
      const lim=this.innerLimits(), xi=Math.round(c.x), yi=Math.round(c.y);
      if(xi<lim.xmin||xi>lim.xmax||yi<lim.ymin||yi>lim.ymax) return;
      this.onClick({x:xi,y:yi});
    });
    return s;
  }
  innerLimits(){ return { xmin:this.R.xmin+1, xmax:this.R.xmax-1, ymin:this.R.ymin+1, ymax:this.R.ymax-1 }; }
  basis(){
    const w=420,h=420,m=20, X=this.R.xmax-this.R.xmin, Y=this.R.ymax-this.R.ymin;
    const maxW=w-2*m, maxH=h-2*m;
    const k = this.orth ? 0 : 0.35;
    let Sx, Sy;
    if(this.norm){ const S = Math.min( maxW/(X + Math.abs(k)*Y), maxH/Y ); Sx=S; Sy=S; }
    else{ Sy=maxH/Y; Sx=Math.min( maxW/(X + Math.abs(k)*Y), (w-2*m)/X ); }
    const e1={x:Sx, y:0}, e2={x:k*Sx, y:-Sy};
    const O0={x:m,y:h-m};
    const O={ x:O0.x - this.R.xmin*e1.x - this.R.ymin*e2.x, y:O0.y - this.R.xmin*e1.y - this.R.ymin*e2.y };
    return {O,e1,e2,w,h,m,k};
  }
  coordToScreen(x,y){ const {O,e1,e2}=this.basis(); return {x:O.x+x*e1.x+y*e2.x, y:O.y+x*e1.y+y*e2.y}; }
  screenToCoord(px,py){ const {O,e1,e2}=this.basis(), a=e1.x,b=e2.x,c=e1.y,d=e2.y,det=a*d-b*c||1e-9; const dx=px-O.x, dy=py-O.y;
    return {x:(d*dx-b*dy)/det, y:(-c*dx+a*dy)/det}; }
  set({R,ticks,quadrants,orth,norm}={}){ if(R) this.R={...R}; if(ticks!=null) this.ticks=!!ticks; if(quadrants!=null) this.quadrants=!!quadrants; if(orth!=null) this.orth=!!orth; if(norm!=null) this.norm=!!norm; this.redraw(); }
  setPoints(arr){ this.points=arr||[]; this.redraw(); }
  clearUser(){ this.user=[]; this.gUser.innerHTML=''; }
  placeUser(label,x,y,color='#0a84ff'){
    let g=this.gUser.querySelector(`g[data-label="${label}"]`);
    if(!g){ g=document.createElementNS(this.el.namespaceURI,'g'); g.dataset.label=label;
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('r','5'); c.setAttribute('fill',color);
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('font-size','13'); t.textContent=label; g.appendChild(c); g.appendChild(t); this.gUser.appendChild(g); }
    const P=this.coordToScreen(x,y), c=g.querySelector('circle'), t=g.querySelector('text');
    c.setAttribute('cx',P.x); c.setAttribute('cy',P.y); t.setAttribute('x',P.x+6); t.setAttribute('y',P.y-6);
    const i=this.user.findIndex(p=>p.label===label); if(i>=0) this.user[i]={label,x,y}; else this.user.push({label,x,y});
  }
  redraw(){
    const R=this.R; this.gGrid.innerHTML=''; this.gAxes.innerHTML=''; this.gQ.innerHTML=''; this.gPts.innerHTML='';
    const mkLine=(x1,y1,x2,y2,thick=false)=>{ const L=document.createElementNS(this.el.namespaceURI,'line');
      L.setAttribute('x1',x1);L.setAttribute('y1',y1);L.setAttribute('x2',x2);L.setAttribute('y2',y2);
      L.setAttribute('stroke','#000'); L.setAttribute('stroke-width',thick?2.5:1); return L; };
    for(let t=R.xmin;t<=R.xmax;t++){ const p1=this.coordToScreen(t,R.ymin), p2=this.coordToScreen(t,R.ymax); this.gGrid.appendChild(mkLine(p1.x,p1.y,p2.x,p2.y)); }
    for(let t=R.ymin;t<=R.ymax;t++){ const q1=this.coordToScreen(R.xmin,t), q2=this.coordToScreen(R.xmax,t); this.gGrid.appendChild(mkLine(q1.x,q1.y,q2.x,q2.y)); }
    const axX=mkLine(this.coordToScreen(R.xmin,0).x,this.coordToScreen(R.xmin,0).y,this.coordToScreen(R.xmax,0).x,this.coordToScreen(R.xmax,0).y,true);
    const axY=mkLine(this.coordToScreen(0,R.ymin).x,this.coordToScreen(0,R.ymin).y,this.coordToScreen(0,R.ymax).x,this.coordToScreen(0,R.ymax).y,true);
    axX.setAttribute('marker-end','url(#arrow)'); axY.setAttribute('marker-end','url(#arrow)'); this.gAxes.appendChild(axX); this.gAxes.appendChild(axY);
    if(this.ticks){
      for(let t=R.xmin;t<=R.xmax;t++){ if(t===0) continue;
        const P=this.coordToScreen(t,0), u=this.coordToScreen(t,(R.ymin+R.ymax)/2+0.15), v=this.coordToScreen(t,(R.ymin+R.ymax)/2-0.15);
        const tickX=mkLine(u.x,u.y,v.x,v.y); this.gAxes.appendChild(tickX);
        if(t!==1){ const tx=document.createElementNS(this.el.namespaceURI,'text'); tx.setAttribute('x',P.x+3); tx.setAttribute('y',P.y-4); tx.setAttribute('font-size','11'); tx.textContent=uminusStr(t); this.gAxes.appendChild(tx); }
      }
      for(let t=R.ymin;t<=R.ymax;t++){ if(t===0) continue;
        const Q=this.coordToScreen(0,t), u2=this.coordToScreen((R.xmin+R.xmax)/2+0.15,t), v2=this.coordToScreen((R.xmin+R.xmax)/2-0.15,t);
        const tickY=mkLine(u2.x,u2.y,v2.x,v2.y); this.gAxes.appendChild(tickY);
        if(t!==1){ const ty=document.createElementNS(this.el.namespaceURI,'text'); ty.setAttribute('x',Q.x+6); ty.setAttribute('y',Q.y-2); ty.setAttribute('font-size','11'); ty.textContent=uminusStr(t); this.gAxes.appendChild(ty); }
      }
    }
    const dot=(px,py,label)=>{ const g=document.createElementNS(this.el.namespaceURI,'g');
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',px); c.setAttribute('cy',py); c.setAttribute('r',3.2); c.setAttribute('fill','#000');
      const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',px+6); t.setAttribute('y',py-6); t.setAttribute('font-size','12'); t.textContent=label; g.appendChild(c); g.appendChild(t); return g; };
    const O=this.coordToScreen(0,0), I=this.coordToScreen(1,0), J=this.coordToScreen(0,1);
    this.gAxes.appendChild(dot(O.x,O.y,'O'));
    this.gAxes.appendChild(dot(I.x,I.y,'I'));
    this.gAxes.appendChild(dot(J.x,J.y,'J'));
    if(this.quadrants){
      const mid=(a,b)=> (a+b)/2;
      const addLab=(x,y,txt)=>{ const p=this.coordToScreen(x,y); const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',p.x); t.setAttribute('y',p.y); t.setAttribute('font-size','18'); t.setAttribute('font-weight','700'); t.setAttribute('fill','#c21807'); t.textContent=txt; this.gQ.appendChild(t); };
      addLab( mid(0,R.xmax), mid(0,R.ymax), 'I');
      addLab( mid(R.xmin,0), mid(0,R.ymax), 'II');
      addLab( mid(R.xmin,0), mid(R.ymin,0), 'III');
      addLab( mid(0,R.xmax), mid(R.ymin,0), 'IV');
    }
    for(const p of this.points){
      const S=this.coordToScreen(p.x,p.y); const g=document.createElementNS(this.el.namespaceURI,'g');
      const c=document.createElementNS(this.el.namespaceURI,'circle'); c.setAttribute('cx',S.x); c.setAttribute('cy',S.y); c.setAttribute('r',4.2); c.setAttribute('fill',p.fill||'#000'); g.appendChild(c);
      if(p.label){ const t=document.createElementNS(this.el.namespaceURI,'text'); t.setAttribute('x',S.x+6); t.setAttribute('y',S.y-6); t.setAttribute('font-size','13'); t.textContent=p.label; g.appendChild(t); }
      this.gPts.appendChild(g);
    }
  }
  outerHTML(){ return this.el.outerHTML; }
}

/* =============== Points & aide =============== */
function innerRandomPoint(R){ const lim={xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; return {x:rnd(lim.xmin,lim.xmax), y:rnd(lim.ymin,lim.ymax)}; }
function innerRandomPointSeeded(R,rng){ const lim={xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; return {x:seededRndInt(rng,lim.xmin,lim.xmax), y:seededRndInt(rng,lim.ymin,lim.ymax)}; }
function distinctPoints(R,n=3){ const set=new Set(), out=[]; while(out.length<n){ const p=innerRandomPoint(R), key=p.x+','+p.y; if(!set.has(key)){ set.add(key); out.push(p); } } return out; }
function distinctPointsSeeded(R,rng,n=3){ const set=new Set(), out=[]; while(out.length<n){ const p=innerRandomPointSeeded(R,rng), key=p.x+','+p.y; if(!set.has(key)){ set.add(key); out.push(p); } } return out; }
const quadrantOf = p => (p.x===0&&p.y===0)?'Origine' : (p.y===0?'Axe des abscisses' : (p.x===0?'Axe des ordonnées' : (p.x>0&&p.y>0?'I':(p.x<0&&p.y>0?'II':(p.x<0&&p.y<0?'III':'IV')))));
function genPointAxisOrOrigin(R){ const lim={xmin:R.xmin+1,xmax:R.xmax-1,ymin:R.ymin+1,ymax:R.ymax-1}; const r=rnd(0,2);
  if(r===0) return {x:0,y:0,place:'Origine'};
  if(r===1){ let x=0; while(x===0) x=rnd(lim.xmin,lim.xmax); return {x,y:0,place:'Axe des abscisses'}; }
  let y=0; while(y===0) y=rnd(lim.ymin,lim.ymax); return {x:0,y,place:'Axe des ordonnées'}; }

/* =============== Vues UI =============== */
function renderNoRepere(host){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row norepere';
  const right=document.createElement('div'); row.appendChild(right); host.appendChild(row);
  const equ=document.createElement('div'); right.appendChild(equ);
  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  return {equ,actions,res};
}
function renderWithRepere(host,opts){
  host.innerHTML='';
  const row=document.createElement('div'); row.className='row';
  const left=document.createElement('div'); const right=document.createElement('div');
  row.appendChild(left); row.appendChild(right); host.appendChild(row);
  const rep=new Repere(opts.R||AMP,{ticks:opts.ticks,quadrants:opts.quadrants,orth:opts.orth,norm:opts.norm}); left.appendChild(rep.el);
  const opt=document.createElement('div'); opt.className='optionline';
  if(opts.enableOrth){
    const lbO=document.createElement('label'); const cbO=document.createElement('input'); cbO.type='checkbox'; cbO.checked=!!opts.orth; lbO.appendChild(cbO); lbO.append(' Orthogonal'); opt.appendChild(lbO);
    const lbN=document.createElement('label'); const cbN=document.createElement('input'); cbN.type='checkbox'; cbN.checked=!!opts.norm; lbN.appendChild(cbN); lbN.append(' Normé (OI = OJ)'); opt.appendChild(lbN);
    opt.cbOrth=cbO; opt.cbNorm=cbN;
  }
  right.appendChild(opt);
  const equ=document.createElement('div'); right.appendChild(equ);
  const actions=document.createElement('div'); actions.className='optionline'; right.appendChild(actions);
  const res=document.createElement('div'); res.id='res'; right.appendChild(res);
  if(opt.cbOrth){ opt.cbOrth.addEventListener('change', ()=>{ rep.set({orth:opt.cbOrth.checked}); }); }
  if(opt.cbNorm){ opt.cbNorm.addEventListener('change', ()=>{ rep.set({norm:opt.cbNorm.checked}); }); }
  return {rep,left,right,equ,actions,res,opt};
}
function normalizeWhere(s){
  s = (s||'').trim().toLowerCase();
  s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  if(['i','ii','iii','iv'].includes(s)) return s.toUpperCase();
  if(s.includes('axe des abscisses')) return 'Axe des abscisses';
  if(s.includes('axe des ordonnees')) return 'Axe des ordonnées';
  if(s==='o' || s.includes('origine')) return 'Origine';
  if(s==='1') return 'I'; if(s==='2') return 'II'; if(s==='3') return 'III'; if(s==='4') return 'IV';
  return s.toUpperCase();
}

/* ===== Helper PDF : réduire taille SVG ===== */
function shrinkSVG(html,size){ return html.replace('class="svgbox"','class="svgbox" style="width:'+size+'px;height:'+size+'px"'); }

/* ========= Helpers points (labels & listes) ========= */
function buildLabelList(n){ return LETTERS.slice(0,n); }
function textCoordList(pts){ return pts.map(p=>`${p.label}${coordToText(p.x,p.y)}`).join(', '); }
function inputsForPoints(container, labels){
  for(const L of labels){
    const inp=document.createElement('input');
    inp.id='ans_'+L; inp.type='text'; inp.placeholder=L+' : (x;y)';
    inp.addEventListener('input',e=>e.target.value=normalizeMinus(e.target.value));
    container.appendChild(inp);
  }
}

/* =============== Exercices =============== */
function makeExos(){ const L=[];

/* 1) Abscisse */
L.push({ id:'abs_M', title:'Donner l’abscisse de M',
  gen(){ const R={...AMP}; const M=innerRandomPoint(R); return {R,M}; },
  render(host,s){ const ui=renderNoRepere(host);
    ui.equ.innerHTML=`<p>Soit <b>M${coordToText(s.M.x,s.M.y)}</b>. Donner l’abscisse de <b>M</b>.</p>`;
    const input=document.createElement('input'); input.id='reponse'; input.type='text'; input.placeholder='abscisse de M (ex. 3/2)'; ui.actions.appendChild(input);
    host.dataset.state=JSON.stringify(s); host._ui=ui; },
  correct(host,s){ const want=s.M.x; const val=parseNumberLike($('#reponse',host).value);
    const ok=equalsInt(val,want); host._ui.res.textContent= ok?'✔':'✘ (attendu : '+uminusStr(want)+')'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step"><strong>Solution.</strong> x<sub>M</sub> = ${uminusStr(s.M.x)}</div></div>`; const inp=$('#reponse',host); if(inp) inp.value=uminusStr(s.M.x); },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ return `<div><div class="hint">Soit <b>M${coordToText(s.M.x,s.M.y)}</b>. Donner l’abscisse de <b>M</b>.</div></div>`; },
  pdfSolution(s){ return `<div><div class="hint">Soit M${coordToText(s.M.x,s.M.y)}.</div><div class="steps"><div class="step">x<sub>M</sub> = ${uminusStr(s.M.x)}</div></div></div>`; }
});

/* 2) Ordonnée */
L.push({ id:'ord_M', title:'Donner l’ordonnée de M',
  gen(){ const R={...AMP}; const M=innerRandomPoint(R); return {R,M}; },
  render(host,s){ const ui=renderNoRepere(host);
    ui.equ.innerHTML=`<p>Soit <b>M${coordToText(s.M.x,s.M.y)}</b>. Donner l’ordonnée de <b>M</b>.</p>`;
    const input=document.createElement('input'); input.id='reponse'; input.type='text'; input.placeholder='ordonnée de M (ex. −4/3)'; ui.actions.appendChild(input);
    host.dataset.state=JSON.stringify(s); host._ui=ui; },
  correct(host,s){ const want=s.M.y; const val=parseNumberLike($('#reponse',host).value);
    const ok=equalsInt(val,want); host._ui.res.textContent= ok?'✔':'✘ (attendu : '+uminusStr(want)+')'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step"><strong>Solution.</strong> y<sub>M</sub> = ${uminusStr(s.M.y)}</div></div>`; const inp=$('#reponse',host); if(inp) inp.value=uminusStr(s.M.y); },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ return `<div><div class="hint">Soit <b>M${coordToText(s.M.x,s.M.y)}</b>. Donner l’ordonnée de <b>M</b>.</div></div>`; },
  pdfSolution(s){ return `<div><div class="hint">Soit M${coordToText(s.M.x,s.M.y)}.</div><div class="steps"><div class="step">y<sub>M</sub> = ${uminusStr(s.M.y)}</div></div></div>`; }
});

/* 3) Symétrique (origine / axes) */
L.push({ id:'sym_M', title:'Coordonnées du symétrique de M',
  gen(){ const R={...AMP}; const M=innerRandomPoint(R); return {R,M,mode:'origine'}; },
  render(host,s){ const ui=renderNoRepere(host);
    const modeSel=document.createElement('select'); modeSel.id='mode'; modeSel.innerHTML='<option value="origine">Origine</option><option value="x">axe des abscisses</option><option value="y">axe des ordonnées</option>';
    modeSel.value=s.mode; const span=document.createElement('span'); span.textContent=' Symétrie par rapport à : '; ui.equ.append(span,modeSel);
    const p=document.createElement('p'); p.innerHTML=`Soit <b>M${coordToText(s.M.x,s.M.y)}</b>. Donner les coordonnées du symétrique demandé. Répondre au format <span class="code">(x;y)</span>.`; ui.equ.append(p);
    const input=document.createElement('input'); input.id='reponse'; input.type='text'; input.placeholder='(x;y)'; ui.actions.appendChild(input);
    host.dataset.state=JSON.stringify(s); host._ui=ui;
    modeSel.addEventListener('change',()=>{ s.mode=modeSel.value; host.dataset.state=JSON.stringify(s); });
  },
  correct(host,s){ const want = (s.mode==='origine') ? {x:-s.M.x,y:-s.M.y} : (s.mode==='x'? {x:s.M.x,y:-s.M.y}:{x:-s.M.x,y:s.M.y});
    const got=parseCoord($('#reponse',host).value); const ok=!!got && got.x===want.x && got.y===want.y;
    const modeTxt = s.mode==='origine'?'l’origine':(s.mode==='x'?'l’axe des abscisses':'l’axe des ordonnées');
    host._ui.res.textContent = ok ? '✔' : '✘ (attendu : '+coordToText(want.x,want.y)+' par rapport à '+modeTxt+')'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ const want = (s.mode==='origine') ? {x:-s.M.x,y:-s.M.y} : (s.mode==='x'? {x:s.M.x,y:-s.M.y}:{x:-s.M.x,y:s.M.y});
    host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step"><strong>Solution.</strong> ${coordToText(want.x,want.y)}</div></div>`;
    const inp=$('#reponse',host); if(inp) inp.value=coordToText(want.x,want.y); },
  reset(host){ const i=$('#reponse',host); if(i) i.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ const mode = s.mode || 'origine';
    const txt = mode==='origine' ? 'à l’origine' : (mode==='x' ? 'à l’axe des abscisses' : 'à l’axe des ordonnées');
    return `<div><div class="hint">Soit <b>M${coordToText(s.M.x,s.M.y)}</b>. Donner le symétrique de <b>M</b> par rapport ${txt}.</div></div>`; },
  pdfSolution(s){ const mode = s.mode||'origine'; const want = (mode==='origine') ? {x:-s.M.x,y:-s.M.y} : (mode==='x'? {x:s.M.x,y:-s.M.y}:{x:-s.M.x,y:s.M.y});
    return `<div><div class="hint">Symétrie par rapport à ${mode==='origine'?'l’origine':(mode==='x'?'l’axe des abscisses':'l’axe des ordonnées')}.</div><div class="steps"><div class="step">${coordToText(want.x,want.y)}</div></div></div>`; }
});

/* 4) Cadran / axe / origine */
L.push({ id:'quadrant', title:'Indiquer le cadran / l’axe / l’origine',
  gen(){ const R={...AMP}; const P=innerRandomPoint(R); const mode=rnd(0,4); if(mode===0){P.x=0;P.y=0;} else if(mode===1){P.y=0;} else if(mode===2){P.x=0;} return {R,P,where:quadrantOf(P)}; },
  render(host,s){
    const ui = renderWithRepere(host,{R:s.R,ticks:true,quadrants:true,orth:true,norm:true});
    ui.rep.setPoints([]);
    ui.equ.innerHTML = `<p>Où se situe <b>M${coordToText(s.P.x,s.P.y)}</b> ? Réponses : <b>I</b>, <b>II</b>, <b>III</b>, <b>IV</b>, <b>axe des abscisses</b>, <b>axe des ordonnées</b> ou <b>origine</b>.</p>`;
    const input = document.createElement('input'); input.id='reponse'; input.type='text'; input.placeholder='ex. II ou axe des ordonnées';
    ui.actions.appendChild(input);
    host.dataset.state = JSON.stringify(s);
    host._ui = ui;
  },
  correct(host,s){ const v=normalizeWhere($('#reponse',host).value);
    const ok = (v===s.where) || (v && v.toUpperCase()===s.where.toUpperCase());
    host._ui.res.textContent= ok?'✔':'✘ (attendu : '+s.where+')'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step"><strong>Solution.</strong> ${s.where}</div></div>`; },
  reset(host){ const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ const r=new Repere(s.R,{ticks:true,quadrants:true}); const html=shrinkSVG(r.outerHTML(),300); const txt=`Où se situe M${coordToText(s.P.x,s.P.y)} ? (I, II, III, IV, axe des abscisses, axe des ordonnées, origine)`; return `<div><div class="hint">${txt}</div>${html}</div>`; },
  pdfSolution(s){ const r=new Repere(s.R,{ticks:true,quadrants:true}); r.setPoints([{x:s.P.x,y:s.P.y,label:'M'}]); const html=shrinkSVG(r.outerHTML(),300); const txt=`Où se situe M${coordToText(s.P.x,s.P.y)} ?`; return `<div><div class="hint">${txt}</div>${html}<div class="steps"><div class="step">${s.where}</div></div></div>`; }
});

/* 5) Axe / origine — texte seul */
L.push({ id:'axe_M', title:'Sur quel axe (ou à l’origine) se situe M ?',
  gen(){ const R={...AMP}; const M=genPointAxisOrOrigin(R); return {R,M}; },
  render(host,s){ const ui=renderNoRepere(host);
    ui.equ.innerHTML=`<p>Déterminer la position de <b>M${coordToText(s.M.x,s.M.y)}</b> : <b>axe des abscisses</b>, <b>axe des ordonnées</b> ou <b>origine</b>.</p>`;
    const input=document.createElement('input'); input.id='reponse'; input.type='text'; input.placeholder='ex. axe des abscisses'; ui.actions.appendChild(input);
    host.dataset.state=JSON.stringify(s); host._ui=ui; },
  correct(host,s){ const v=normalizeWhere($('#reponse',host).value); const ok = v===s.M.place;
    host._ui.res.textContent= ok?'✔':'✘ (attendu : '+s.M.place+')'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step"><strong>Solution.</strong> ${s.M.place}</div></div>`; },
  reset(host){ const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ return `<div><div class="hint">Déterminer la position de M${coordToText(s.M.x,s.M.y)} : axe des abscisses, axe des ordonnées ou origine.</div></div>`; },
  pdfSolution(s){ return `<div><div class="hint">Déterminer la position de M${coordToText(s.M.x,s.M.y)}.</div><div class="steps"><div class="step">${s.M.place}</div></div></div>`; }
});

/* ======= Exercices 6–9 : nombre de points variable ======= */
function genPtsState(R, n){
  const P = distinctPoints(R,n);
  const labels = buildLabelList(n);
  return labels.map((L,i)=>({label:L,x:P[i].x,y:P[i].y,fill:colorOf(L)}));
}

/* 6) Placer points (orthonormé) */
L.push({ id:'placer_ABC', title:'Placer A, B et C (orthogonal normé)',
  gen(){ const R={...AMP}; const n=getNbPts(); return {R,PTS:genPtsState(R,n)}; },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R,ticks:true,orth:true,norm:true});
    ui.rep.setPoints([]); const labels=s.PTS.map(p=>p.label);
    ui.equ.innerHTML=`<p>Placer sur le repère : ${textCoordList(s.PTS)}.<br><span class="small"><b>Astuce :</b> clique d’abord sur le bouton du point, puis clique sur le repère.</span></p>`;
    const chips=document.createElement('div'); chips.className='chips'; chips.innerHTML='<span>À placer :</span>';
    ui.actions.appendChild(chips);
    let current=labels[0]; const chipEls=[];
    for(const L of labels){
      const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=L; sp.innerHTML=`<span class="dot" style="background:${colorOf(L)}"></span>${L}`; chips.appendChild(sp); chipEls.push(sp);
    }
    function setCurrent(l){ current=l; chipEls.forEach(c=>c.classList.toggle('active',c.dataset.l===l)); }
    chipEls.forEach(c=>c.addEventListener('click',()=>setCurrent(c.dataset.l))); setCurrent(current);
    ui.rep.clickable=true; ui.rep.onClick=({x,y})=>{ ui.rep.placeUser(current,x,y,colorOf(current)); };
    host.dataset.state=JSON.stringify(s); host._ui=ui; },
  correct(host,s){ const ui=host._ui; let ok=true;
    for(const w of s.PTS){ const g=ui.rep.gUser.querySelector(`g[data-label="${w.label}"]`); if(!g){ok=false;break;}
      const cx=+g.querySelector('circle').getAttribute('cx'), cy=+g.querySelector('circle').getAttribute('cy'); const pos=ui.rep.screenToCoord(cx,cy), xi=Math.round(pos.x), yi=Math.round(pos.y); if(xi!==w.x||yi!==w.y){ok=false;break;} }
    ui.res.textContent=ok?'✔':'✘'; ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ const ui=host._ui; ui.res.className='small'; ui.rep.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill}))); },
  reset(host){ const r=$('#res',host); if(r) r.textContent=''; host._ui?.rep?.clearUser?.(); },
  pdfStatement(s){ const r=new Repere(s.R,{ticks:true}); const html=shrinkSVG(r.outerHTML(),300); return `<div><div class="hint">Placer : ${textCoordList(s.PTS)}.</div>${html}</div>`; },
  pdfSolution(s){ const r=new Repere(s.R,{ticks:true}); r.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill}))); const html=shrinkSVG(r.outerHTML(),300); return `<div><div class="hint">Placer : ${textCoordList(s.PTS)}.</div>${html}<div class="steps"><div class="step">Positions exactes ci-dessus.</div></div></div>`; }
});

/* 7) Lire points */
L.push({ id:'lire_ABC', title:'Lire les coordonnées de A, B et C',
  gen(){ const R={...AMP}; const n=getNbPts(); return {R,PTS:genPtsState(R,n)}; },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R,ticks:true,orth:true,norm:true});
    ui.rep.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill})));
    ui.equ.innerHTML=`<p>Lire et écrire au format <span class="code">(x;y)</span> : <b>${s.PTS.map(p=>p.label).join(', ')}</b>.</p>`;
    inputsForPoints(ui.actions, s.PTS.map(p=>p.label));
    host.dataset.state=JSON.stringify(s); host._ui=ui; },
  correct(host,s){ let ok=true;
    for(const p of s.PTS){ const A=parseCoord($('#ans_'+p.label,host).value); if(!(A && A.x===p.x && A.y===p.y)){ ok=false; break; } }
    host._ui.res.textContent=ok?'✔':'✘'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step">${s.PTS.map(p=>p.label+coordToText(p.x,p.y)).join(' ; ')}</div></div>`; },
  reset(host){ for(const el of host.querySelectorAll('input[id^="ans_"]')) el.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ const r=new Repere(s.R,{ticks:true}); r.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill}))); const html=shrinkSVG(r.outerHTML(),300); const names=s.PTS.map(p=>p.label).join(', '); return `<div><div class="hint">Lire les coordonnées des points ${names}.</div>${html}</div>`; },
  pdfSolution(s){ const names=s.PTS.map(p=>p.label).join(', '); const sol=s.PTS.map(p=>p.label+coordToText(p.x,p.y)).join(' ; '); return `<div><div class="hint">Lire les coordonnées des points ${names}.</div><div class="steps"><div class="step">${sol}</div></div></div>`; }
});

/* 8) Placer points — modes */
L.push({ id:'placer_ABC_mode', title:'Placer A, B et C (orthogonal/quelconque ; normé ou non)',
  gen(){ const R={...AMP}; const n=getNbPts(); return {R,PTS:genPtsState(R,n),orth:true,norm:false}; },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R,ticks:true,orth:s.orth,norm:s.norm,enableOrth:true});
    ui.rep.setPoints([]); const labels=s.PTS.map(p=>p.label);
    ui.equ.innerHTML=`<p>Placer <b>${labels.join(', ')}</b> : ${textCoordList(s.PTS)}.<br><span class="small"><b>Astuce :</b> clique d’abord sur le bouton du point, puis clique sur le repère.</span><br><span class="small">Choisis le type de repère : <b>Orthogonal</b> / <b>Quelconque</b> et <b>Normé</b> (OI=OJ) ou non.</span></p>`;
    const chips=document.createElement('div'); chips.className='chips'; chips.innerHTML='<span>À placer :</span>';
    ui.actions.appendChild(chips);
    let current=labels[0]; const chipEls=[];
    for(const L of labels){
      const sp=document.createElement('span'); sp.className='chip'; sp.dataset.l=L; sp.innerHTML=`<span class="dot" style="background:${colorOf(L)}"></span>${L}`; chips.appendChild(sp); chipEls.push(sp);
    }
    function setCurrent(l){ current=l; chipEls.forEach(c=>c.classList.toggle('active',c.dataset.l===l)); }
    chipEls.forEach(c=>c.addEventListener('click',()=>setCurrent(c.dataset.l))); setCurrent(current);
    ui.rep.clickable=true; ui.rep.onClick=({x,y})=>{ ui.rep.placeUser(current,x,y,colorOf(current)); };
    host.dataset.state=JSON.stringify(s); host._ui=ui;
    ui.opt.cbOrth.addEventListener('change',()=>{ s.orth=ui.opt.cbOrth.checked; ui.rep.set({orth:s.orth}); });
    ui.opt.cbNorm.addEventListener('change',()=>{ s.norm=ui.opt.cbNorm.checked; ui.rep.set({norm:s.norm}); });
  },
  correct(host,s){ const ui=host._ui; let ok=true;
    for(const w of s.PTS){ const g=ui.rep.gUser.querySelector(`g[data-label="${w.label}"]`); if(!g){ok=false;break;}
      const cx=+g.querySelector('circle').getAttribute('cx'), cy=+g.querySelector('circle').getAttribute('cy'); const pos=ui.rep.screenToCoord(cx,cy), xi=Math.round(pos.x), yi=Math.round(pos.y); if(xi!==w.x||yi!==w.y){ok=false;break;} }
    ui.res.textContent=ok?'✔':'✘'; ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ const ui=host._ui; ui.res.className='small'; ui.res.innerHTML=`<div class="steps"><div class="step"><strong>Solution.</strong> Repère ${(s.orth?'orthogonal':'quelconque')}, ${(s.norm?'normé (OI=OJ)':'non normé (OI≠OJ)')}.</div></div>`; ui.rep.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill}))); },
  reset(host){ const r=$('#res',host); if(r) r.textContent=''; host._ui?.rep?.clearUser?.(); },
  pdfStatement(s){ const r=new Repere(s.R,{ticks:true,orth:s.orth,norm:s.norm}); const html=shrinkSVG(r.outerHTML(),300); return `<div><div class="hint">Placer : ${textCoordList(s.PTS)} (${s.orth?'orthogonal':'quelconque'} ; ${s.norm?'normé':'non normé'}).</div>${html}</div>`; },
  pdfSolution(s){ const r=new Repere(s.R,{ticks:true,orth:s.orth,norm:s.norm}); r.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill}))); const html=shrinkSVG(r.outerHTML(),300); return `<div><div class="hint">Placer : ${textCoordList(s.PTS)}.</div>${html}<div class="steps"><div class="step">Positions exactes ci-dessus.</div></div></div>`; }
});

/* 9) Lire points — modes */
L.push({ id:'lire_ABC_mode', title:'Lire les coordonnées de A, B, C (orthogonal/quelconque ; normé ou non)',
  gen(){ const R={...AMP}; const n=getNbPts(); return {R,PTS:genPtsState(R,n),orth:true,norm:false}; },
  render(host,s){ const ui=renderWithRepere(host,{R:s.R,ticks:true,orth:s.orth,norm:s.norm,enableOrth:true});
    ui.rep.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill})));
    ui.equ.innerHTML=`<p>Dans un repère ${(s.orth?'orthogonal':'quelconque')}, ${(s.norm?'normé (OI=OJ)':'non normé (OI≠OJ)')}, lire les coordonnées de <b>${s.PTS.map(p=>p.label).join(', ')}</b>.</p>`;
    inputsForPoints(ui.actions, s.PTS.map(p=>p.label));
    host.dataset.state=JSON.stringify(s); host._ui=ui;
    ui.opt.cbOrth.addEventListener('change',()=>{ s.orth=ui.opt.cbOrth.checked; ui.rep.set({orth:s.orth}); });
    ui.opt.cbNorm.addEventListener('change',()=>{ s.norm=ui.opt.cbNorm.checked; ui.rep.set({norm:s.norm}); });
  },
  correct(host,s){ let ok=true;
    for(const p of s.PTS){ const A=parseCoord($('#ans_'+p.label,host).value); if(!(A && A.x===p.x && A.y===p.y)){ ok=false; break; } }
    host._ui.res.textContent=ok?'✔':'✘'; host._ui.res.className= ok?'res-ok':'res-ko'; return {ok,total:1}; },
  solution(host,s){ host._ui.res.className='small'; host._ui.res.innerHTML=`<div class="steps"><div class="step">${s.PTS.map(p=>p.label+coordToText(p.x,p.y)).join(' ; ')}</div></div>`; },
  reset(host){ for(const el of host.querySelectorAll('input[id^="ans_"]')) el.value=''; const r=$('#res',host); if(r) r.textContent=''; },
  pdfStatement(s){ const r=new Repere(s.R,{ticks:true,orth:s.orth,norm:s.norm}); r.setPoints(s.PTS.map(p=>({x:p.x,y:p.y,label:p.label,fill:p.fill}))); const html=shrinkSVG(r.outerHTML(),300); const names=s.PTS.map(p=>p.label).join(', '); return `<div><div class="hint">Lire les coordonnées des points ${names}.</div>${html}</div>`; },
  pdfSolution(s){ const names=s.PTS.map(p=>p.label).join(', '); const sol=s.PTS.map(p=>p.label+coordToText(p.x,p.y)).join(' ; '); return `<div><div class="hint">Lire les coordonnées des points ${names}.</div><div class="steps"><div class="step">${sol}</div></div></div>`; }
});

return L; }

/* =============== Score & init UI =============== */
let scoreOK=0, scoreTot=0; const updateScore=()=>$('#score').textContent=`${scoreOK} / ${scoreTot}`;
function buildOne(){ const sel=$('#exo-select'), host=$('#host'); const def=REGISTRY.find(e=>e.id===sel.value);
  if(!def){ host.textContent='(Aucun exercice)'; return; }
  const st=def.gen(); host.dataset.active=def.id; host.dataset.state=JSON.stringify(st); def.render(host,st); }
function check(){ const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return;
  const st=JSON.parse(host.dataset.state||'{}'); const r=def.correct(host,st); if(r){ scoreOK+=r.ok?1:0; scoreTot+=(r.total||1); updateScore(); }}
function solution(){ const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(!def) return; const st=JSON.parse(host.dataset.state||'{}'); def.solution(host,st); }
function resetAll(){ scoreOK=0; scoreTot=0; updateScore(); const host=$('#host'); const def=REGISTRY.find(e=>e.id===host.dataset.active); if(def) def.reset(host); }

/* Globals pour le kit PDF */
let REGISTRY=[];                  
window.REGISTRY = [];             
window.pickDef = id => (window.REGISTRY||[]).find(d=>d.id===id) || null;

document.addEventListener('DOMContentLoaded',function(){
  try{
    REGISTRY = makeExos();
    window.REGISTRY = REGISTRY;
    const sel=$('#exo-select');
    if(!REGISTRY || !REGISTRY.length){ $('#status').textContent='(Init: aucune entrée)'; return; }
    REGISTRY.forEach(e=>{ const o=document.createElement('option'); o.value=e.id; o.textContent=e.title; sel.appendChild(o); });
    sel.addEventListener('change',buildOne);
    $('#btn-new').addEventListener('click',buildOne);
    $('#btn-check').addEventListener('click',check);
    $('#btn-solution').addEventListener('click',solution);
    $('#btn-reset').addEventListener('click',resetAll);
    $('#amp-apply').addEventListener('click',applyAMPInputs);
    $('#nbPts').addEventListener('change',()=>{ buildOne(); });
    sel.value=REGISTRY[0].id; buildOne(); updateScore(); $('#status').textContent='(OK)';
  }catch(err){
    console.error(err);
    $('#status').textContent='Erreur d’init : '+(err?.message||err);
  }
});

/* =============== PDF via exo-pdf-kit (hooks) =============== */
window.addEventListener('load',function(){
  if(!(window.ExoPDF && ExoPDF.init)) return;

  /* anti-duplication (par session de génération) */
  const seen = new Set();
  const defSeedBase = id => Array.from(id||'x').reduce((h,c)=>(Math.imul(h^c.charCodeAt(0),16777619))>>>0,2166136261>>>0);

  function sigPts(list){ return list.map(p=>p.label+':'+p.x+','+p.y).join('|'); }
  function signature(def,S){
    switch(def.id){
      case 'abs_M':  return `abs|${S.M.x},${S.M.y}`;
      case 'ord_M':  return `ord|${S.M.x},${S.M.y}`;
      case 'sym_M':  return `sym|${S.mode}|${S.M.x},${S.M.y}`;
      case 'quadrant': return `quad|${S.P.x},${S.P.y}`;
      case 'axe_M':  return `axe|${S.M.x},${S.M.y}`;
      case 'placer_ABC': return `pl|${sigPts(S.PTS)}`;
      case 'lire_ABC':   return `lr|${sigPts(S.PTS)}`;
      case 'placer_ABC_mode': return `plm|${+!!S.orth}${+!!S.norm}|${sigPts(S.PTS)}`;
      case 'lire_ABC_mode':   return `lrm|${+!!S.orth}${+!!S.norm}|${sigPts(S.PTS)}`;
      default: return def.id+'|'+JSON.stringify(S);
    }
  }

  ExoPDF.init({
    title:'Seconde – Repère : Abscisse et ordonnée',
    lead:'\u200B', // neutralise “Résoudre”

    beforeGen(def, st, ctx){
      const wantRand = !!document.querySelector('#pdfRand')?.checked;

      // Amplitude tirée / reprise, puis forçage : englober au moins [-6;6]
      let R = wantRand ? randAMPWithOriginMin6() : ensureCoverMin6Origin({...AMP});

      // seed unique par occurrence, avec tentative si duplication détectée
      const base = defSeedBase(def.id);
      let tries=0, S=null, sig='';
      while(tries<60){
        const seed = (base ^ (ctx.index*2654435761) ^ ((Date.now()>>>0)&0xffff) ^ tries)>>>0;
        const rng = seedPRNG(seed);
        const p = ()=>innerRandomPointSeeded(R,rng);
        S = {R};

        switch(def.id){
          case 'abs_M': S.M=p(); break;
          case 'ord_M': S.M=p(); break;
          case 'sym_M': S.M=p(); S.mode=['origine','x','y'][seededRndInt(rng,0,2)]; break;
          case 'quadrant': {
            S.P=p(); const m=seededRndInt(rng,0,4);
            if(m===0){S.P.x=0;S.P.y=0;} else if(m===1){S.P.y=0;} else if(m===2){S.P.x=0;}
            S.where=quadrantOf(S.P);
          } break;
          case 'axe_M': {
            const r=seededRndInt(rng,0,2);
            if(r===0){S.M={x:0,y:0,place:'Origine'};}
            else if(r===1){ let x=0; while(x===0) x=seededRndInt(rng,R.xmin+1,R.xmax-1); S.M={x,y:0,place:'Axe des abscisses'}; }
            else { let y=0; while(y===0) y=seededRndInt(rng,R.ymin+1,R.ymax-1); S.M={x:0,y,place:'Axe des ordonnées'}; }
          } break;
          case 'placer_ABC':
          case 'lire_ABC':
          case 'placer_ABC_mode':
          case 'lire_ABC_mode': {
            const n = seededRndInt(rng,3,10);          // ← nombre de points aléatoire au PDF
            const labels = LETTERS.slice(0,n);
            const P = distinctPointsSeeded(R,rng,n);
            S.PTS = labels.map((L,i)=>({label:L,x:P[i].x,y:P[i].y,fill:colorOf(L)}));
            if(def.id==='placer_ABC_mode' || def.id==='lire_ABC_mode'){
              S.orth = !!seededRndInt(rng,0,1);
              S.norm = !!seededRndInt(rng,0,1);
            }
          } break;
        }

        sig = signature(def,S);
        if(!seen.has(sig)){ seen.add(sig); break; }
        tries++;
      }
      return S;
    },

    beforeRender(def, S, withSolutions){
      return withSolutions ? def.pdfSolution(S) : def.pdfStatement(S);
    }
  });
});
})();
</script><script defer="True" src="../../../../js/math-kbd.multiplicatif.js"></script><script id="move-exopdf-ui">window.addEventListener('load',function(){var ui=document.querySelector('.exopdf-ui');var acc=document.getElementById('accept');if(ui&&acc){acc.parentNode.insertBefore(ui, acc.nextSibling);}});</script><script id="fix-spaces-robust">(function(){function f(e){var h=e.innerHTML;h=h.replace(/([A-Za-zÀ-ÖØ-öø-ÿ0-9])\(/g,'$1 (');h=h.replace(/\)(?=[A-Za-zÀ-ÖØ-öø-ÿ0-9])/g,') ');h=h.replace(/([A-Za-zÀ-ÖØ-öø-ÿ])([A-Za-z])\(/g,'$1 $2(');h=h.replace(/,\s*/g,', ');h=h.replace(/\s{2,}/g,' ');e.innerHTML=h.trim()}function r(){['.equ','.statement','.consigne','.hint','#res','#resSet','.steps','.step','.legend'].forEach(function(s){document.querySelectorAll(s).forEach(f)})}document.addEventListener('DOMContentLoaded',function(){r();['#btn-new','#btn-solution','#btn-check','#btn-reset'].forEach(function(id){var b=document.querySelector(id);if(b)b.addEventListener('click',function(){setTimeout(r,0)});});var sel=document.querySelector('#exo-select');if(sel)sel.addEventListener('change',function(){setTimeout(r,0)});});})();</script><script defer="True" src="../../../../js/repere_patch_0813.js"></script><script id="repere-amp-fallback">(function(){window.AMP=window.AMP||{xmin:-6,xmax:6,ymin:-6,ymax:6};function g(id){var el=document.getElementById(id);return el?parseInt(el.value,10):null;}if(typeof window.applyAMPInputs!=='function'){window.applyAMPInputs=function(){var xm=g('xmin'),xM=g('xmax'),ym=g('ymin'),yM=g('ymax');if([xm,xM,ym,yM].every(function(x){return typeof x==='number'&&!isNaN(x);})){window.AMP={xmin:xm,xmax:xM,ymin:ym,ymax:yM};}if(typeof window.buildOne==='function')window.buildOne();};}document.addEventListener('DOMContentLoaded',function(){var b=document.getElementById('amp-apply');if(b){b.addEventListener('click',function(e){e.preventDefault();window.applyAMPInputs();});}});})();</script></body>
</html>
