<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Seconde ‚Äî G√©n√©rateurs (courbe, variations, signes, d√©riv√©e)</title>

<link rel="stylesheet" href="../assets/css/math-kbd.css">
<link rel="stylesheet" href="../assets/css/espace-latex.css">
<link rel="stylesheet" href="../assets/css/espace-gras.css">
<link rel="stylesheet" href="../assets/css/mobile.css">

<style>
  *{box-sizing:border-box}
  :root{--ink:#111;--bg:#fafafa;--card:#fff;--line:#e6e6e6;--ok:#11823b;--ko:#b00020}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 18px;z-index:5}
  .wrap{max-width:1200px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  select,input[type="text"],input[type="number"]{padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:15px}
  .btn{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:8px;cursor:pointer}
  .btn:hover{background:#f6f6f6}
  .legend{display:flex;gap:12px;justify-content:center;font-size:.92rem}
  .legend span{display:inline-flex;align-items:center;gap:6px}
  .grid{display:grid;gap:12px}
  .g2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .small{font-size:.92rem;color:#555}
  .steps{margin:.35rem 0 0 .15rem;padding:.35rem .5rem;background:#f2f2f2;border:1px dashed #bbb;border-radius:8px}
  .tick{ display:inline-block; min-width:1.15em; text-align:center; margin-left:.35rem; font-weight:700 }
  .tick.nu::after{ content:''; }
  .tick.ok::after{ content:'‚úì'; color:#11823b; }
  .tick.ko::after{ content:'‚úó'; color:#b00020; }

  /* tableaux imprimables style PDF */
  table.pdf-tbl{ border-collapse:separate; border-spacing:0; border:none; margin:.4rem 0; }
  table.pdf-tbl th, table.pdf-tbl td{ border:none; padding:4px 6px; text-align:center; vertical-align:middle; }
  table.pdf-tbl th{ background:#f3f3f6 }
  table.pdf-tbl tr:first-child > * { border-top:    1.5px solid #000; }
  table.pdf-tbl tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.pdf-tbl tr > *:first-child { border-left:   1.5px solid #000; }
  table.pdf-tbl tr > *:last-child  { border-right:  1.5px solid #000; }
  table.pdf-tbl thead tr > *:first-child,
  table.pdf-tbl tbody tr > *:first-child{ border-right: 1.5px solid #000; }

  /* tableaux interactifs (cadre uniquement) */
  table.var{ border-collapse:separate; border-spacing:0; margin:.35rem auto }
  table.var th, table.var td{ padding:4px 6px; border:none }
  table.var tr:first-child > * { border-top:    1.5px solid #000; }
  table.var tr:last-child  > * { border-bottom: 1.5px solid #000; }
  table.var tr > *:first-child { border-left:   1.5px solid #000; }
  table.var tr > *:last-child  { border-right:  1.5px solid #000; }
  table.var tbody tr:first-child > * { border-bottom: 1.5px solid #000; }
  table.var td.bigsel{ padding:0 }
  table.var td.bigsel select{ display:block; width:100%; height:100%; background:transparent; padding:0; margin:0; text-align:center; text-align-last:center; appearance:none }
  table.var input[type="text"]{ width:110px; text-align:center }

  /* zone courbes */
  .graph{display:flex;justify-content:center;margin:.4rem 0}
  svg.repere{background:#fff;border:1px solid #e5e5e5;border-radius:8px}
  
  /* S√©parateur vertical apr√®s la 1re colonne, pour tous les tableaux interactifs */
table.var tr > *:first-child{
  border-left: 1.5px solid #000;   /* bord ext√©rieur gauche (d√©j√† pr√©sent) */
  border-right: 1.5px solid #000;  /* ‚áê ajout : barre verticale apr√®s la 1re colonne */
}
/* 5) f' + variations ‚Äî trait entre f'(x) et f (√©nonc√© + PDF) */
#dv-wrap table.var tbody tr:nth-child(2) > *,
#dv-out  table.pdf-tbl tbody tr:nth-child(2) > * {
  border-bottom: 1.5px solid #000;
}
/* 5) ENONC√â : trait entre f'(x) et f */
#dv-wrap table.var tbody tr:nth-child(2) > * {
  border-bottom: 1.5px solid #000;
}

/* 5) SOLUTION (PDF) : trait entre f'(x) et f */
#dv-out table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}
/* Enlever fond/bordure sur les blocs de solution */
#v-out.steps,
#s1-out.steps,
#sf-out.steps,
#dv-out.steps,
#curve-out-var.steps,
#curve-out-sign.steps {
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}
#v-out .step, #s1-out .step, #sf-out .step,
#dv-out .step, #curve-out-var .step, #curve-out-sign .step {
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}
/* Trait entre f'(x) et f dans la solution auto */
#curve-out-deriv table.pdf-tbl tbody tr:first-child > *{
  border-bottom: 1.5px solid #000;
}

/* Pas de fond gris pour cette sortie */
#curve-out-deriv.steps { background: transparent !important; border:none !important; padding:0 !important; }
#curve-out-deriv .step  { background: transparent !important; border:none !important; padding:0 !important; }

/* B√ÇTONS UNIQUEMENT DANS LES TABLEAUX DE SOLUTION (PDF) */
table.pdf-tbl td.sbar,
table.pdf-tbl td.zbar,
table.pdf-tbl td.dbar { position: relative; }

/* 1 barre centrale (vide ou avec 0) */
table.pdf-tbl td.sbar::before,
table.pdf-tbl td.zbar::before{
  content:'';
  position:absolute;
  top:-1.5px;               /* colle aux lignes horizontales */
  bottom:-1.5px;
  left:50%;
  transform:translateX(-50%);
  border-left:2px solid #000;
}

/* 2 barres (||) ‚Äî √©cart RESSERR√â */
table.pdf-tbl td.dbar::before,
table.pdf-tbl td.dbar::after{
  content:'';
  position:absolute;
  top:-1.5px;
  bottom:-1.5px;
  border-left:2px solid #000;
}
table.pdf-tbl td.dbar::before{ left: calc(50% - 2px); }
table.pdf-tbl td.dbar::after { left: calc(50% + 2px); }

/* === 4) TABLEAU SIGNE FACTORIS√â ‚Äî ENONC√â (grille interactive) === */
/* trait sous x (tu l'as d√©j√† via tbody tr:first-child > * { border-bottom: ... }) */
/* traits entre 'a' / facteurs / 'f(x)' */
#sf-wrap table.var tbody tr.sf-row-a > *,
#sf-wrap table.var tbody tr.sf-row-factor + tr.sf-row-factor > *,
#sf-wrap table.var tbody tr.sf-row-fx > * {
  border-top: 1.5px solid #000;
}
/* Ligne apr√®s 'a' (si la ligne 'a' est affich√©e) */
#sf-wrap table.var tbody tr.sf-row-a + tr.sf-row-factor > * {
  border-top: 1.5px solid #000;
}

/* === 4) TABLEAU SIGNE FACTORIS√â ‚Äî SOLUTION (PDF) === */
/* traits entre 'a' / facteurs / 'f(x)' */
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-a > *,
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-factor + tr.sf-pdf-row-factor > *,
#sf-out table.pdf-tbl tbody tr.sf-pdf-row-fx > * {
  border-top: 1.5px solid #000;
}

/* 0 plus grand mais moins √©pais */
table.pdf-tbl td.zbar,
table.var td.zbar {
  font-size: 1.35em;     /* plus grand */
  font-weight: 400;      /* poids normal, plus fin */
  line-height: 1;        /* √©vite que √ßa d√©borde verticalement */
}
/* Courbes multiples : trait horizontal entre f'(x) et f dans la SOLUTION (PDF) */
#mc-out-deriv table.pdf-tbl tbody tr:first-child > * {
  border-bottom: 1.5px solid #000;
}

/* Gabarit SOLUTION (pdf-tbl) ‚Äî a√©ration mod√©r√©e */
.steps .pdf-tbl{
  width: auto;             /* ne force pas 100% */
  max-width: 100%;
  table-layout: auto;
}
.steps .pdf-tbl th,
.steps .pdf-tbl td{
  padding: 5px 8px;        /* l√©ger + que l'origine, moins qu'avant */
}
.steps .pdf-tbl tbody th{
  min-width: 64px;         /* libell√©s (f, f', a, ‚Ä¶) */
}
.steps .pdf-tbl td{
  min-width: 30px;         /* colonnes x / intervalles */
}
/* Fl√®ches plus grandes dans les tableaux de variations de la **solution** */
.steps .pdf-tbl td.arr{
  font-size: 1.45em;   /* taille des fl√®ches */
  line-height: 1;
  font-weight: 700;
  padding-left: 6px;
  padding-right: 6px;
}
@media print{
  .steps .pdf-tbl td.arr{ font-size: 1.6em; }
}
/* Centrage vertical (valeur unique) */
table.pdf-tbl td.mid, table.var td.mid { position: relative; }
table.pdf-tbl td.mid .midv, table.var td.mid .midv{
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  white-space:nowrap; text-align:center;
}

</style>

<!-- MathJax -->
<script>
  window.MathJax={tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]],processEscapes:true},chtml:{matchFontHeight:false},startup:{typeset:true}};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script src='../assets/js/math-kbd.js' defer></script>
</head>
<body>
  <div class="header">
    <h1 style="margin:0;font-size:1.1rem">Seconde ‚Äî G√©n√©rateurs (courbe, variations, signes, d√©riv√©e)</h1>
  </div>

  <div class="wrap">
<div class="controls card">
  <label for="tool-select"><strong>G√©n√©rateur :</strong></label>
  <select id="tool-select"></select>
  <button id="btn-action" class="btn" style="display:none"></button>
  <button id="btn-action2" class="btn" style="display:none"></button>
  <!-- AJOUTE ICI -->
  <button class="btn" id="mc-label" style="display:none">Placer Cf sur la courbe</button>
  <!-- /AJOUT -->
  <button id="btn-make" class="btn" style="display:none">üß© Cr√©er le tableau</button>
  <button id="btn-reset" class="btn">üßπ R√©initialiser</button>
</div>


    <div class="card" id="host"></div>

    <div class="card small">
  <strong>Notes</strong>

  <div style="margin:.5rem 0 0 0">
    <p><b>Dans le fichier 1 et 2 :</b></p>
	<b>Pour tracer une courbe :</b>
    <ul style="margin:.25rem 0 0 18px">
      <li>Placer les points o√π vous voulez (coordonn√©es enti√®res dans le fichier 1 et √† 0,5 pr√®s dans le fichier 2).</li>
      <li>Pour faire disparaitre un point d√©j√† plac√©, il suffit de cliquer dessus.</li>
      <li>Cliquer sur : <em>Tracer la courbe</em>.</li>
      <li>Vous pouvez faire disparaitre/r√©apparaitre les points de construction en cliquant sur : <em>Enlever/Remettre les points</em>.</li>
    </ul>

    <p style="margin-top:.5rem"><b>Dans le deuxi√®me fichier :</b></p>
    <ul style="margin:.25rem 0 0 18px">
      <li>Vous pouvez construire plusieurs courbes en cliquant sur les boutons de couleurs.</li>
      <li>Vous pouvez placer/d√©placer le nom des courbes sur le rep√®re en cliquant sur : <em>Placer Cf sur la courbe</em>. 
	  <br>Attention il faudra recliquer sur les boutons de couleurs Cf/Cg... pour pouvoir replacer des points.
	  <br>Pour faire disparaitre le nom de la courbe, double-cliquez sur le nom.</li>
    </ul>
  </div>
</div>


    <div class="card"><div data-math-kbd style="display:flex;justify-content:center"></div></div>
  </div>

<script>
(function(){
'use strict';

/* ===== Utilitaires g√©n√©riques ===== */
const $=(s,r)=> (r||document).querySelector(s);
const $$=(s,r)=> Array.from((r||document).querySelectorAll(s));
const UMIN='‚àí';
function typesetAll(root){ const run=()=>MathJax.typesetPromise(root?[root]:undefined).catch(()=>{}); if(MathJax?.startup?.promise){ MathJax.startup.promise.then(run);} else { const t=setInterval(()=>{ if(MathJax?.typesetPromise){ clearInterval(t); run(); }},60);} }
/* ==== Infinity ‚Üí LaTeX ==== */
function stripMathDelims(s){
  return (s||'')
    .replace(/^\\\(|\\\)$/g,'')   // enl√®ve \( \)
    .replace(/^\$+|\$+$/g,'')     // enl√®ve $...$
    .trim();
}
function toLatexInfinityToken(s){
  // accepte: -oo, +oo, oo, -‚àû, +‚àû, ‚àû, -inf, +inf, infty (avec espaces, minus unicode‚Ä¶)
  const t = stripMathDelims(s).toLowerCase()
              .replace(/\s+/g,'')
              .replace(/‚àí/g,'-');               // unicode minus ‚Üí ASCII
  const m = t.match(/^([+-])?(?:oo|‚àû|inf|infty)$/);
  if(!m) return null;
  const sign = (m[1]==='-' ? '-' : m[1]==='+' ? '+' : '');
  return `${sign}\\infty`;                       // <-- √† utiliser DANS LaTeX
}
/* Emballe une valeur dans \( ... \) avec gestion ‚àû.
   NB: si ce n'est PAS une ‚àû, on garde ton rendu visuel avec le '‚àí' unicode. */
function Lx(s){
  if(!s) return '\\(\\)';
  const tok = toLatexInfinityToken(s);
  if(tok) return `\\(${tok}\\)`;
  return `\\(${String(s).replace(/-/g, UMIN)}\\)`;
}

/* ===== Rep√®re & trac√©s (reprend l'esprit Ex.1/2) ===== */
function buildRepereSVG(opts){
  const Wmax=520, Hmax=300, mL=28, mT=8, mR=8, mB=28;
  const {xmin,xmax,ymin,ymax}=opts;
  const AR = Math.max(3.5, Math.min(8, opts.arrowSize||7));
  const Rx=xmax-xmin, Ry=ymax-ymin, s=Math.min(Wmax/Rx,Hmax/Ry); const w=s*Rx, h=s*Ry;
  const x0=mL+(Wmax-w)/2, y0=mT+(Hmax-h)/2; const W=mL+Wmax+mR, H=mT+Hmax+mB;
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('class','repere');
  const defs=document.createElementNS(svg.namespaceURI,'defs');
  const mark=document.createElementNS(svg.namespaceURI,'marker');
  mark.setAttribute('id','arrow'); mark.setAttribute('markerUnits','userSpaceOnUse');
  mark.setAttribute('markerWidth',AR); mark.setAttribute('markerHeight',AR);
  mark.setAttribute('viewBox',`0 0 ${AR} ${AR}`); mark.setAttribute('refX',AR); mark.setAttribute('refY',AR/2); mark.setAttribute('orient','auto');
  const tri=document.createElementNS(svg.namespaceURI,'path'); tri.setAttribute('d',`M0 0 L${AR} ${AR/2} L0 ${AR} Z`); tri.setAttribute('fill','#111');
  mark.appendChild(tri); defs.appendChild(mark);
  const clip=document.createElementNS(svg.namespaceURI,'clipPath'); clip.setAttribute('id','clip-v1');
  const crect=document.createElementNS(svg.namespaceURI,'rect'); crect.setAttribute('x',x0); crect.setAttribute('y',y0); crect.setAttribute('width',w); crect.setAttribute('height',h);
  clip.appendChild(crect); defs.appendChild(clip); svg.appendChild(defs);
  const axes=document.createElementNS(svg.namespaceURI,'g'); const plot=document.createElementNS(svg.namespaceURI,'g'); plot.classList.add('plot'); plot.setAttribute('clip-path','url(#clip-v1)');
  svg.appendChild(axes); svg.appendChild(plot);
  const X=x=>x0+(x-xmin)*s, Y=y=>y0+h-(y-ymin)*s;
  const frame=document.createElementNS(svg.namespaceURI,'rect'); frame.setAttribute('x',x0); frame.setAttribute('y',y0); frame.setAttribute('width',w); frame.setAttribute('height',h); frame.setAttribute('fill','none'); frame.setAttribute('stroke','#111'); frame.setAttribute('class','frame'); axes.appendChild(frame);
  const yAxisY=Math.max(y0+10, Math.min(y0+h-10, Y(0))); const xAxisX=Math.max(x0+10, Math.min(x0+w-10, X(0)));
  if(opts.grid){
    const g=document.createElementNS(svg.namespaceURI,'g'); g.setAttribute('stroke','#000'); g.setAttribute('stroke-width','0.7');
    const tx=document.createElementNS(svg.namespaceURI,'g'); const ty=document.createElementNS(svg.namespaceURI,'g');
    const fmt=n=>String(n).replace('-',UMIN);
    for(let xv=Math.ceil(xmin); xv<=xmax+1e-9; xv+=1){ const xx=X(xv); const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',xx); l.setAttribute('y1',y0); l.setAttribute('x2',xx); l.setAttribute('y2',y0+h); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmt(xv); t.setAttribute('x', Math.max(x0+5, Math.min(x0+w-5, xx))); t.setAttribute('y', Math.max(y0+2, Math.min(y0+h+12, yAxisY+14))); t.setAttribute('font-size','12'); t.setAttribute('text-anchor','middle'); tx.appendChild(t); }
    for(let yv=Math.ceil(ymin); yv<=ymax+1e-9; yv+=1){ const yy=Y(yv); const l=document.createElementNS(svg.namespaceURI,'line'); l.setAttribute('x1',x0); l.setAttribute('y1',yy); l.setAttribute('x2',x0+w); l.setAttribute('y2',yy); g.appendChild(l);
      const t=document.createElementNS(svg.namespaceURI,'text'); t.textContent=fmt(yv); t.setAttribute('x', Math.max(x0+6, Math.min(x0+w-8, xAxisX-6))); t.setAttribute('y', Math.max(y0+10, Math.min(y0+h-6, yy+4))); t.setAttribute('font-size','12'); t.setAttribute('text-anchor','end'); ty.appendChild(t); }
    axes.appendChild(g); axes.appendChild(tx); axes.appendChild(ty);
  }
  const axX=document.createElementNS(svg.namespaceURI,'line'); axX.setAttribute('x1',x0); axX.setAttribute('x2',x0+w); axX.setAttribute('y1',yAxisY); axX.setAttribute('y2',yAxisY); axX.setAttribute('stroke','#111'); axX.setAttribute('stroke-width','2.2'); axX.setAttribute('stroke-linecap','butt'); if(opts.arrows) axX.setAttribute('marker-end','url(#arrow)'); axes.appendChild(axX);
  const axY=document.createElementNS(svg.namespaceURI,'line'); axY.setAttribute('x1',xAxisX); axY.setAttribute('x2',xAxisX); axY.setAttribute('y1',y0+h); axY.setAttribute('y2',y0); axY.setAttribute('stroke','#111'); axY.setAttribute('stroke-width','2.2'); axY.setAttribute('stroke-linecap','butt'); if(opts.arrows) axY.setAttribute('marker-end','url(#arrow)'); axes.appendChild(axY);
  const Xi=px=>xmin+(px-x0)/s, Yi=py=>ymin+(y0+h-py)/s;
  const hit=document.createElementNS(svg.namespaceURI,'rect'); hit.setAttribute('x',x0); hit.setAttribute('y',y0); hit.setAttribute('width',w); hit.setAttribute('height',h); hit.setAttribute('fill','transparent'); hit.style.pointerEvents='all'; plot.appendChild(hit);
  return {svg,plot,axes,X,Y,Xi,Yi,hit,xmin,xmax,ymin,ymax};
}
function addPath(g,d,st){ const p=document.createElementNS(g.namespaceURI,'path'); p.setAttribute('d',d); p.setAttribute('fill','none'); p.setAttribute('stroke',st?.stroke||'#111'); p.setAttribute('stroke-width',st?.['stroke-width']||2.4); p.setAttribute('stroke-linejoin','round'); p.setAttribute('stroke-linecap','round'); g.appendChild(p); return p; }
function hermiteToBezier(P0,P1,m0,m1){ const [x0,y0]=P0,[x1,y1]=P1,h=x1-x0; return { C1:[x0+h/3, y0+m0*h/3], C2:[x1-h/3, y1-m1*h/3] }; }
function pathFromKnots(rep,K){ const X=rep.X, Y=rep.Y; let d=''; for(let i=0;i<K.length-1;i++){ const A=K[i], B=K[i+1]; if(!isFinite(A.x)||!isFinite(A.y)||!isFinite(B.x)||!isFinite(B.y)) continue; if(d==='') d=`M ${X(A.x)} ${Y(A.y)}`; const {C1,C2}=hermiteToBezier([A.x,A.y],[B.x,B.y],A.m??0,B.m??0); d+=` C ${X(C1[0])} ${Y(C1[1])} ${X(C2[0])} ${Y(C2[1])} ${X(B.x)} ${Y(B.y)}`; } return d; }

// === Helpers courbe (Hermite -> B√©zier -> √©valuation) ===
// √âvalue y(t) sur l'arc [P0,P1] d√©fini par (x,y) et pentes m0,m1 (pentes en dy/dx)
function hermiteY(P0,P1,m0,m1,t){
  const y0=P0.y, y1=P1.y, h=(P1.x-P0.x);
  const tt=t*t, t3=tt*t;
  const h00=2*t3-3*tt+1, h10=t3-2*tt+t, h01=-2*t3+3*tt, h11=t3-tt;
  return h00*y0 + h10*h*m0 + h01*y1 + h11*h*m1;
}
function hermiteX(P0,P1,t){ return P0.x + (P1.x-P0.x)*t; }

// Racines de y'(t)=0 sur un arc Hermite : renvoie t‚àà(0,1)
function hermiteExtremaT(P0,P1,m0,m1){
  const y0=P0.y, y1=P1.y, h=(P1.x-P0.x);
  // y'(t) = (6t^2-6t)*y0 + (3t^2-4t+1)*h m0 + (-6t^2+6t)*y1 + (3t^2-2t)*h m1
  const A =  6*y0 + 3*h*m0 - 6*y1 + 3*h*m1;
  const B = -6*y0 - 4*h*m0 + 6*y1 - 2*h*m1;
  const C =  h*m0;
  const T=[];
  const eps=1e-12;
  if(Math.abs(A) < 1e-12){
    if(Math.abs(B) > 1e-12){
      const t = -C/B; if(t>0 && t<1) T.push(t);
    }
  }else{
    const D = B*B - 4*A*C;
    if(D >= -1e-12){
      const s = Math.sqrt(Math.max(0,D));
      const t1 = (-B - s)/(2*A), t2 = (-B + s)/(2*A);
      if(t1>0 && t1<1) T.push(t1);
      if(t2>0 && t2<1) T.push(t2);
    }
  }
  return T.sort((a,b)=>a-b);
}

// √âvalue f(x) sur la courbe (liste de n≈ìuds K)
function valueOnCurve(K, x){
  for(let i=0;i<K.length-1;i++){
    const A=K[i], B=K[i+1];
    if(x < A.x || x > B.x) continue;
    const t=(x-A.x)/((B.x-A.x)||1);
    return hermiteY(A,B,A.m||0,B.m||0,t);
  }
  return (x<=K[0].x)? K[0].y : K.at(-1).y;
}

// Racines y(t)=0 sur t‚àà[0,1] par subdivision + bissection
function rootsOnArc(P0,P1,m0,m1){
  const f = t => hermiteY(P0,P1,m0,m1,t);
  const T = []; const N = 200; // √©chantillonnage fin
  let tPrev=0, yPrev=f(0);
  // d√©tecte aussi les touches (y‚âà0 sans changement de signe)
  const eps = 1e-6;
  for(let i=1;i<=N;i++){
    const t=i/N, y=f(t);
    if (Math.abs(y) < eps){ T.push(t); }            // racine "touch√©e"
    if (yPrev === 0) { T.push(tPrev); }             // pr√©cision sur point exact
    if (yPrev*y < 0){                               // changement de signe -> bissection
      let a=tPrev, b=t, fa=yPrev, fb=y;
      for(let k=0;k<40;k++){
        const c=(a+b)/2, fc=f(c);
        if(Math.abs(fc)<1e-9) { a=b=c; break; }
        if(fa*fc<=0){ b=c; fb=fc; } else { a=c; fa=fc; }
      }
      T.push((a+b)/2);
    }
    tPrev=t; yPrev=y;
  }
  // d√©doublonne / range
  T.sort((a,b)=>a-b);
  const out=[];
  for(const u of T){ if(out.length===0 || Math.abs(u-out[out.length-1])>1e-3) out.push(u); }
  return out;
}
// Formattage jolis x (entiers ‚Üí sans .0, sinon 2 d√©cimales)
// Affichage : entier si |x - round(x)| < 0.1, sinon arrondi au dixi√®me
function fmtX(x){
  const r = Math.round(x);
  if (Math.abs(x - r) < 0.1) return String(r);        // snap √† l'entier
  const v = Math.round(x * 10) / 10;                  // arrondi 0,1
  return String(v).replace('.', ',');                 // virgule fran√ßaise
}
// Active/MAJ l'effet "double barre" en fonction de la valeur du <select>
function wireBarCells(scope){
  const sels = $$('.s1z,.sfz,.sfz-fx,.dvz,.vbar,.vfmark', scope || document);
  const update = sel => {
    const td = sel.closest('td');
    if(!td) return;
    td.classList.remove('sbar','zbar','dbar');
    if(sel.value === '||')      td.classList.add('dbar');  // ||
    else if(sel.value === '0')  td.classList.add('zbar');  // 0 + |
    else                        td.classList.add('sbar');  // | par d√©faut (int√©rieur)
  };
  sels.forEach(sel=>{ sel.addEventListener('change', ()=>update(sel)); update(sel); });
}


// Fabrique la cellule "barre" pour la SOLUTION.
// role = 'xmin'|'xmax'|'r1'...'c1'...
function pdfBarCell(value, role){
  const edge = (role === 'xmin' || role === 'xmax');
  if (value === '0')  return `<td class="zbar">0</td>`;   // 0 + barre partout
  if (value === '||') return `<td class="dbar"></td>`;    // || partout, y compris bords
  if (!value && !edge) return `<td class="sbar"></td>`;   // barre simple uniquement int√©rieur
  return `<td></td>`;
}



/* ===== 1) G√©n√©rateur de courbe : placer points ‚Üí tracer / enlever points ===== */
const toolCurve = {
  id:'curve', title:'Courbe : placer des points, tracer la courbe',
  build(host){
    host.innerHTML = `
  <div class="small">Clique dans le rep√®re pour placer/supprimer des points (accrochage aux entiers). Puis utilise les boutons.</div>
  <div class="graph"></div>
  <div class="row" style="margin-top:6px">
    <label>Amplitude :</label>
    <label>x ‚àà [<input id="cxmin" type="number" value="-7" style="width:70px"> ; <input id="cxmax" type="number" value="7" style="width:70px">]</label>
    <label>y ‚àà [<input id="cymin" type="number" value="-6" style="width:70px"> ; <input id="cymax" type="number" value="6" style="width:70px">]</label>
  </div>

  <div class="row" style="margin-top:8px;gap:8px">
  <button class="btn" id="btn-var-tab">üìä Tableau de variation</button>
  <button class="btn" id="btn-sign-tab">‚ûï/‚ûñ Tableau de signe</button>
  <button class="btn" id="btn-deriv-tab">f‚Ä≤(x) & variations de f</button> <!-- NEW -->
</div>

<div class="steps small" id="note"></div>
<div class="steps" id="curve-out-var"></div>
<div class="steps" id="curve-out-sign"></div>
<div class="steps" id="curve-out-deriv"></div> <!-- NEW -->

`;

    this.makeRep(host);
  },
  makeRep(host){
  const xmin=+$('#cxmin',host).value, xmax=+$('#cxmax',host).value, ymin=+$('#cymin',host).value, ymax=+$('#cymax',host).value;
  const graph=$('.graph',host); graph.innerHTML='';
  const rep=buildRepereSVG({xmin,xmax,ymin,ymax,grid:true,arrows:true}); graph.appendChild(rep.svg);
const layerPts = document.createElementNS(rep.svg.namespaceURI,'g');
const layerCur = document.createElementNS(rep.svg.namespaceURI,'g');
rep.plot.appendChild(layerPts);
rep.plot.appendChild(layerCur);

// ‚ö†Ô∏è pour que le clic sur un point ‚Äútraverse‚Äù et touche le rectangle 'hit'
layerPts.style.pointerEvents = 'none';
layerCur.style.pointerEvents = 'none';


// points pos√©s (conserv√©s m√™me si on "enl√®ve" visuellement)
const placed = [];
let Klast = null;

// √©tat d‚Äôaffichage des points
let pointsHidden = false;

// cache/affiche les points ET met √† jour le libell√© du bouton
function setPointsHidden(h){
  pointsHidden = !!h;
  layerPts.style.display = pointsHidden ? 'none' : '';
  if (!pointsHidden) redrawPts();
  const b = $('#btn-action2');
  if (b) b.textContent = pointsHidden ? '‚Ü© Remettre les points' : '‚®Ç Enlever les points';
}

function redrawPts(){
  if (pointsHidden) return;          // ne dessine pas si masqu√©
  layerPts.innerHTML = '';
  placed.forEach(p=>{
    const c=document.createElementNS(rep.svg.namespaceURI,'circle');
    c.setAttribute('cx',rep.X(p.x)); c.setAttribute('cy',rep.Y(p.y));
    c.setAttribute('r',4.2); c.setAttribute('fill','#111');
    layerPts.appendChild(c);
  });
}

function togglePoint(p){
  if(p.x<xmin||p.x>xmax||p.y<ymin||p.y>ymax) return;
  const k = placed.findIndex(q=>q.x===p.x && q.y===p.y);
  if(k>=0) placed.splice(k,1); else placed.push(p);
  redrawPts();                       // affichage si non masqu√©
}


  function computeKnots(){
  if(placed.length < 2) return null;
  const sorted = [...placed].sort((a,b)=> a.x - b.x);

  // N≈ìuds (x,y) + pente m
  const K = sorted.map(p => ({ x:p.x, y:p.y, m:0 }));

  // Pentes "douces" (cardinal) comme avant
  for(let i=0;i<K.length;i++){
    if(i===0){
      const dx = (K[1].x - K[0].x) || 1;
      K[i].m = (K[1].y - K[0].y) / dx * 0.9;
    }else if(i===K.length-1){
      const dx = (K[i].x - K[i-1].x) || 1;
      K[i].m = (K[i].y - K[i-1].y) / dx * 0.9;
    }else{
      const dx = (K[i+1].x - K[i-1].x) || 1;
      K[i].m = (K[i+1].y - K[i-1].y) / dx * 0.9;
    }
  }

  // ‚üµ NOUVEAU : impose m=0 aux points o√π la variation change (max/min discrets)
  for(let i=1;i<K.length-1;i++){
    const dyL = K[i].y - K[i-1].y;
    const dyR = K[i+1].y - K[i].y;
    if (dyL * dyR < 0) {
      // changement de signe ‚Üí extremum
      K[i].m = 0;
    }
  }

  return K;
}


  function drawCurve(useExisting=false){
    // si useExisting et Klast dispo, on retrace sans recalcul
    const K = useExisting && Klast ? Klast : computeKnots();
    if(!K) return;
    layerCur.innerHTML='';
    addPath(layerCur, pathFromKnots(rep,K), {stroke:'#111','stroke-width':2.6});
    Klast = K; // m√©morise la courbe
  }



  function toSvgPoint(evt){ const pt=rep.svg.createSVGPoint(); pt.x=(evt.touches?evt.touches[0].clientX:evt.clientX); pt.y=(evt.touches?evt.touches[0].clientY:evt.clientY); return pt.matrixTransform(rep.svg.getScreenCTM().inverse()); }
  function snap(svgPt){ return {x:Math.round(rep.Xi(svgPt.x)), y:Math.round(rep.Yi(svgPt.y))}; }
  const onClick=e=>{ e.preventDefault(); togglePoint( snap(toSvgPoint(e)) ); };
  rep.hit.addEventListener('click', onClick); rep.hit.addEventListener('touchstart', onClick, {passive:false});

  // === Analyse depuis courbe (K) ===
  function ensureCurve(){
    if(Klast) return Klast;
    const K = computeKnots();
    if(K){ Klast=K; drawCurve(true); }
    return Klast;
  }

  // Racines de f (toutes, non enti√®res) depuis la courbe
  function getAllRootsFromCurve(){
    const K = ensureCurve(); if(!K) return [];
    const roots=[];
    for(let i=0;i<K.length-1;i++){
      const P0=K[i], P1=K[i+1], m0=P0.m||0, m1=P1.m||0;
      const Ts = rootsOnArc(P0,P1,m0,m1);
      Ts.forEach(t=>{
        const x = hermiteX(P0,P1,t);
        const y = hermiteY(P0,P1,m0,m1,t);
        // borne dans la fen√™tre + y‚âà0
        if(x>=xmin-1e-6 && x<=xmax+1e-6 && Math.abs(y)<1e-3) roots.push(x);
      });
    }
    // tri + d√©doublonnage
    roots.sort((a,b)=>a-b);
    const out=[];
    for(const x of roots){ if(out.length===0 || Math.abs(x-out[out.length-1])>1e-3) out.push(x); }
    return out;
  }

  // Variations depuis la courbe (√©chantillonnage pour rep√©rer extremums)
function analyzeVariationFromCurve(){
  if(!Klast) return null;
  const K = Klast;

  // bornes "utiles"
  const a2 = Math.max(+$('#cxmin',host).value + 1, K[0].x);
  const b2 = Math.min(+$('#cxmax',host).value - 1, K.at(-1).x);

  const crit = [];

  // 1) Racines de y'(t) sur chaque arc (0<t<1)
  for(let i=0;i<K.length-1;i++){
    const A=K[i], B=K[i+1], m0=A.m||0, m1=B.m||0;
    const Ts = hermiteExtremaT(A,B,m0,m1);
    for(const t of Ts){
      const x = hermiteX(A,B,t);
      if(x>a2-1e-9 && x<b2+1e-9) crit.push(x);
    }
  }

  // 2) N≈ìuds "extremums" : pente nulle au n≈ìud + comparaison des voisins
  const SLOPE_EPS = 1e-9;
  for(let i=1;i<K.length-1;i++){
    const L=K[i-1], M=K[i], R=K[i+1];
    if(M.x<=a2 || M.x>=b2) continue;
    const mi = M.m || 0;
    const isZeroSlope = Math.abs(mi) < SLOPE_EPS;
    const isMax = (M.y > L.y && M.y > R.y);
    const isMin = (M.y < L.y && M.y < R.y);
    if(isZeroSlope && (isMax || isMin)) crit.push(M.x);
  }

  // D√©dup + tri
  crit.sort((a,b)=>a-b);
  const colsX = [a2];
  for(const x of crit){
    if(Math.abs(x - colsX.at(-1)) > 1e-3) colsX.push(x);
  }
  colsX.push(b2);

  // Valeurs, fl√®ches et √©tiquettes max/min
  const colsY = colsX.map(x=> valueOnCurve(K,x));
  const dirs = [];
  for(let j=0;j<colsX.length-1;j++){
    dirs.push( colsY[j+1] > colsY[j] ? '‚Üó' : (colsY[j+1] < colsY[j] ? '‚Üò' : '‚Üí') );
  }

  const yMarks = colsX.map((xk,idx)=>{
    if(idx===0 || idx===colsX.length-1) return {yM:'', ym:''};
    const yL=colsY[idx-1], y0=colsY[idx], yR=colsY[idx+1];
    if(y0>yL && y0>yR) return {yM:fmtX(y0), ym:''};   // max
    if(y0<yL && y0<yR) return {yM:'', ym:fmtX(y0)};   // min
    return {yM:'', ym:''};
  });

  return { colsX, colsY, dirs, yMarks };
}


  // === Sorties tableaux ===
 function makeVarTable(){
  // priorit√© aux points si Klast absent
  if(!Klast){ const K=computeKnots(); if(K){ Klast=K; drawCurve(true); } }
  const A = analyzeVariationFromCurve();
  if(!A){ $('#curve-out-var',host).innerHTML='<div class="step small">Trace d‚Äôabord une courbe (‚â• 2 points) pour extraire les variations.</div>'; return; }

  const {colsX, colsY, dirs, yMarks}=A;

  const head=['<tr><th>\\(x\\)</th>'];
  colsX.forEach((x,j)=>{ head.push(`<td>\\(${fmtX(x).replace('-',UMIN)}\\)</td>`); if(j<colsX.length-1) head.push('<td></td>'); });
  head.push('</tr>');

  function L(s){ return s? `\\(${String(s).replace('.',',').replace('-',UMIN)}\\)` : '&nbsp;'; }
  function cellVal(v,top){ const up=top?L(v):'&nbsp;'; const dn=!top?L(v):'&nbsp;'; return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`; }
  function cellValMidVar(v){ return `<td class="mid"><div class="midv">${L(v)}</div></td>`; }

  const body=['<tr><th>\\(f\\)</th>'];
  for(let idx=0; idx<colsX.length; idx++){
    if(idx===0){
      const d=dirs[0];
      if(d==='‚Üó') body.push(cellVal(fmtX(colsY[0]),false));
      else if(d==='‚Üò') body.push(cellVal(fmtX(colsY[0]),true));
      else if(d==='‚Üí') body.push(cellValMidVar(fmtX(colsY[0])));
     else body.push(cellVal('',true));

    }else if(idx===colsX.length-1){
    const d=dirs.at(-1);
      if(d==='‚Üó') body.push(cellVal(fmtX(colsY.at(-1)),true));
      else if(d==='‚Üò') body.push(cellVal(fmtX(colsY.at(-1)),false));
      else if(d==='‚Üí') body.push(cellValMidVar(fmtX(colsY.at(-1))));
      else body.push(cellVal('',true));
    }else{
      const {yM,ym}=yMarks[idx];
      if(yM) body.push(cellVal(yM,true));
      else if(ym) body.push(cellVal(ym,false));
      else body.push(cellVal('',true));
    }
    if(idx<colsX.length-1) body.push(`<td class="arr">${dirs[idx]||''}</td>`);
  }
  body.push('</tr>');

  $('#curve-out-var',host).innerHTML =
    `<div class="step"><div><b>Tableau de variations (depuis la courbe) :</b></div>
      <div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${body.join('')}</tbody></table></div>
    </div>`;
  typesetAll($('#curve-out-var',host));
}


  function makeSignTable(){
  if(!Klast){ const K=computeKnots(); if(K){ Klast=K; drawCurve(true); } }
  const K = Klast;
  if(!K){ $('#curve-out-sign',host).innerHTML='<div class="step small">Trace la courbe pour extraire le tableau de signes.</div>'; return; }

  // m√™mes bornes que variations : [max(xmin+1, x0) ; min(xmax-1, xN)]
  const a2 = Math.max(+$('#cxmin',host).value + 1, K[0].x);
  const b2 = Math.min(+$('#cxmax',host).value - 1, K.at(-1).x);

  // Toutes les racines sur chaque arc, filtr√©es dans [a2,b2]
  const roots=[];
  for(let i=0;i<K.length-1;i++){
    const A=K[i], B=K[i+1], m0=A.m||0, m1=B.m||0;
    // r√©utilise la routine robustes (subdivision+bissection) que tu avais, ou celle-ci :
    const Ts = rootsOnArc(A,B,m0,m1);
    Ts.forEach(t=>{
      const x = hermiteX(A,B,t);
      const y = hermiteY(A,B,m0,m1,t);
      if(x>=a2-1e-6 && x<=b2+1e-6 && Math.abs(y)<1e-3) roots.push(x);
    });
  }
  // Apr√®s avoir rempli `roots` (toutes les racines de chaque arc)
roots.sort((a,b)=>a-b);

// d√©doublonnage global (tol√©rance coh√©rente avec l‚Äôarrondi au dixi√®me)
const EPS = 0.05;             // la moiti√© d‚Äôun dixi√®me
const uniq = [];
for (const x of roots) {
  if (uniq.length === 0 || Math.abs(x - uniq[uniq.length-1]) > EPS) {
    uniq.push(x);
  }
}

// Construit les colonnes avec racines uniques
const xCols = [a2, ...uniq, b2];


  // Head x (avec intercalaires)
  const head=['<tr><th>\\(x\\)</th>'];
  xCols.forEach((x,j)=>{ head.push(`<td>\\(${fmtX(x).replace('-',UMIN)}\\)</td>`); if(j<xCols.length-1) head.push('<td></td>'); });
  head.push('</tr>');

  // Signe par intervalle : on √©value f au milieu
  const sgnInt=[];
  for(let j=0;j<xCols.length-1;j++){
    const mid=(xCols[j]+xCols[j+1])/2;
    const y=valueOnCurve(K,mid);
    sgnInt.push( y>0? '+' : (y<0? UMIN : '') );
  }

// Ligne f(x) : 0 sous chaque racine (pas sous a2/b2) + barres
let rowF = '<tr><th>\\(f(x)\\)</th>';
for (let j = 0; j < xCols.length; j++) {
  const isEdge = (j === 0 || j === xCols.length - 1);
  const isRootCol = (j > 0 && j < xCols.length - 1);

  if (isRootCol) {
    rowF += `<td class="zbar" style="text-align:center">0</td>`;
  } else if (!isEdge) {
    rowF += `<td class="sbar"></td>`;
  } else {
    rowF += `<td></td>`;
  }

  if (j < xCols.length - 1) {
    rowF += `<td style="text-align:center">${sgnInt[j] || ''}</td>`;
  }
}
rowF += '</tr>';



  $('#curve-out-sign',host).innerHTML =
    `<div class="step"><div><b>Tableau de signes (depuis la courbe) :</b> <span class="small">(racines ‚âà)</span></div>
      <div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowF}</tbody></table></div>
    </div>`;
  typesetAll($('#curve-out-sign',host));
}
function makeDerivVarTable(){
  // Assure une courbe
  if(!Klast){ const K=computeKnots(); if(K){ Klast=K; drawCurve(true); } }
  const A = analyzeVariationFromCurve();
  if(!A){ $('#curve-out-deriv',host).innerHTML = '<div class="step small">Trace d‚Äôabord une courbe (‚â• 2 points) pour extraire f‚Ä≤ et les variations.</div>'; return; }

  const { colsX, colsY, dirs, yMarks } = A;

  // THEAD : ligne des x
  const head = ['<tr><th>\\(x\\)</th>'];
  colsX.forEach((x,j)=>{ head.push(`<td>\\(${fmtX(x).replace('-',UMIN)}\\)</td>`); if(j<colsX.length-1) head.push('<td></td>'); });
  head.push('</tr>');

 // Ligne f'(x) : 0 sur colonnes int√©rieures + barres (zbar pour 0, sbar pour colonnes int√©rieures sans 0)
const signFromDir = d => d==='‚Üó' ? '+' : (d==='‚Üò' ? UMIN : '');

let rowFp = `<tr><th>\\(f'(x)\\)</th>`;
for (let j = 0; j < colsX.length; j++) {
  const isEdge = (j === 0 || j === colsX.length - 1);
  if (!isEdge) rowFp += `<td class="zbar" style="text-align:center">0</td>`;
  else         rowFp += `<td></td>`;

  if (j < colsX.length - 1) {
    rowFp += `<td style="text-align:center">${signFromDir(dirs[j])}</td>`;
  }
}
rowFp += '</tr>';



  // Ligne f : m√™mes r√®gles que le tableau de variation
  const L = s => s ? `\\(${String(s).replace('.',',').replace('-',UMIN)}\\)` : '&nbsp;';
  const cellVal = (v,top)=> {
    const up = top ? L(v) : '&nbsp;';
    const dn = !top ? L(v) : '&nbsp;';
    return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`;
  };
  const cellValMidVar = v => `<td class="mid"><div class="midv">${L(v)}</div></td>`;

  const bodyF = ['<tr><th>\\(f\\)</th>'];
  for(let i=0;i<colsX.length;i++){
    if(i===0){
      const d=dirs[0];
      if(d==='‚Üó') bodyF.push(cellVal(fmtX(colsY[0]),false));
     else if(d==='‚Üò') bodyF.push(cellVal(fmtX(colsY[0]),true));
      else if(d==='‚Üí') bodyF.push(cellValMidVar(fmtX(colsY[0])));
      else bodyF.push(cellVal('',true));
    }else if(i===colsX.length-1){
      const d=dirs.at(-1);
      if(d==='‚Üó') bodyF.push(cellVal(fmtX(colsY.at(-1)),true));
      else if(d==='‚Üò') bodyF.push(cellVal(fmtX(colsY.at(-1)),false));
      else if(d==='‚Üí') bodyF.push(cellValMidVar(fmtX(colsY.at(-1))));
     else bodyF.push(cellVal('',true));
    }else{
      const {yM,ym} = yMarks[i];
      if(yM) bodyF.push(cellVal(yM,true));
      else if(ym) bodyF.push(cellVal(ym,false));
      else bodyF.push(cellVal('',true));
    }
    if(i<colsX.length-1) bodyF.push(`<td class="arr">${dirs[i]||''}</td>`);
  }
  bodyF.push('</tr>');

  $('#curve-out-deriv',host).innerHTML =
    `<div class="step"><div><b>Tableau \\(f'(x)\\) et variations de \\(f\\) (depuis la courbe) :</b></div>
       <div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowFp}${bodyF.join('')}</tbody></table></div>
     </div>`;
  typesetAll($('#curve-out-deriv',host));
}


  // === API expos√©e (une seule fois) ===
host._curve_api = {
  trace: ()=> drawCurve(false),

  // bascule "enlever/remettre" (utilis√© par le bouton)
  togglePts: ()=> setPointsHidden(!pointsHidden),

  // alias si tu en as besoin ailleurs :
  clearPts: ()=> setPointsHidden(true),
  showPts : ()=> setPointsHidden(false),

  // reset total
  fullReset: ()=>{
    placed.splice(0, placed.length);
    layerPts.innerHTML = '';
    layerCur.innerHTML = '';
    Klast = null;
    $('#note',host).textContent = '';
    $('#curve-out-var',host).innerHTML  = '';
    $('#curve-out-sign',host).innerHTML = '';

    setPointsHidden(false); // r√©tablit libell√© "‚®Ç Enlever les points"
  },

  remake: ()=> this.makeRep(host),

  makeVarTable,
  makeSignTable,
  makeDerivVarTable
};

setPointsHidden(false); // √©tat initial : points visibles + texte "‚®Ç Enlever les points"


  // Boutons locaux (s‚Äôils existent)
  $('#btn-var-tab',host)?.addEventListener('click', ()=> host._curve_api.makeVarTable());
  $('#btn-sign-tab',host)?.addEventListener('click', ()=> host._curve_api.makeSignTable());
  	$('#btn-deriv-tab',host)?.addEventListener('click', ()=> host._curve_api.makeDerivVarTable());

  
}
,
  wireButtons(){
    const host = $('#host');
$('#btn-action').style.display='inline-block';
$('#btn-action').textContent='‚úèÔ∏è Tracer la courbe';

$('#btn-action2').style.display='inline-block';
$('#btn-action2').textContent='‚®Ç Enlever les points';
$('#btn-action2').onclick = ()=> host._curve_api?.togglePts();  // ‚üµ bascule

$('#btn-make').style.display='none';
$('#btn-action').onclick = ()=> host._curve_api?.trace();

// reconstruire le rep√®re si amplitude change
['cxmin','cxmax','cymin','cymax'].forEach(id=>{
  $('#'+id).onchange = ()=> host._curve_api?.remake();
});
const labBtn = $('#mc-label');
  if (labBtn) labBtn.style.display = 'none';
  },
reset(){
  const host = $('#host');
  if(host && host._curve_api){
    host._curve_api.fullReset();   // tout vider
    host._curve_api.remake();      // reconstruire un rep√®re propre
  }
}
};

/* ===== 1b) Courbes multiples (jusqu'√† 5) ===== */
const toolMultiCurve = {
  id: 'curvemulti',
  title: 'Courbes multiples',
  build(host){
    host.innerHTML = `
      <div class="small">Choisis le nombre de courbes (max 5), s√©lectionne Cf/Cg/Ch/Ck/Cl, puis clique dans le rep√®re pour placer/supprimer des points pour la courbe active.</div>

      <div class="row" style="gap:8px;margin-top:6px">
        <label>Nombre de courbes :</label>
        <input id="mc-n" type="number" min="1" max="5" value="2" style="width:70px">
        <button id="mc-apply" class="btn">Appliquer</button>

        <div id="mc-tabs" class="row" style="gap:6px;margin-left:12px"></div>
      </div>

      <div class="row" style="margin-top:6px">
        <label>Amplitude :</label>
        <label>x ‚àà [<input id="mcxmin" type="number" value="-7" style="width:70px"> ; <input id="mcxmax" type="number" value="7" style="width:70px">]</label>
        <label>y ‚àà [<input id="mcymin" type="number" value="-6" style="width:70px"> ; <input id="mcymax" type="number" value="6" style="width:70px">]</label>
      </div>

      <div class="graph" id="mc-graph"></div>

      <div class="row" style="margin-top:8px;gap:8px">
        <button class="btn" id="mc-btn-var">üìä Tableau de variation</button>
        <button class="btn" id="mc-btn-sign">‚ûï/‚ûñ Tableau de signe</button>
        <button class="btn" id="mc-btn-deriv">f‚Ä≤(x) & variations de f</button>
      </div>

      <div class="steps" id="mc-out-var"></div>
      <div class="steps" id="mc-out-sign"></div>
      <div class="steps" id="mc-out-deriv"></div>
    `;
    this.makeRep(host);
    this.wireLocal(host);
  },

  makeRep(host){
  // ====== Param√©trage et √©tat local ======
  const MAX = 5;
  const labels = ['f','g','h','k','l'];
  const btnLbl = ['Cf','Cg','Ch','Ck','Cl'];
  const colors = ['#3b82f6','#ef4444','#10b981','#a855f7','#f59e0b']; // bleu/rouge/vert/violet/orange

  const graph = $('#mc-graph',host);
  graph.innerHTML = '';

  const xmin = +$('#mcxmin',host).value, xmax = +$('#mcxmax',host).value,
        ymin = +$('#mcymin',host).value, ymax = +$('#mcymax',host).value;

  let rep = buildRepereSVG({ xmin, xmax, ymin, ymax, grid:true, arrows:true });
  graph.appendChild(rep.svg);

  const tabs = $('#mc-tabs',host);
  let curves = [];                       // stockera jusqu'√† 5 courbes
  let count  = Math.min(MAX, Math.max(1, +$('#mc-n',host).value || 2)); // nb visible
  let active = 0;                        // index courbe active
let labelMode = false;                  // mode placement d'√©tiquettes

let drag = { curveIdx:-1, labelIdx:-1 };

function beginDrag(curveIdx, labelIdx, e, span){
  e.preventDefault();
  drag = { curveIdx, labelIdx };
  span.style.cursor = 'grabbing';
  window.addEventListener('mousemove', onDrag);
  window.addEventListener('mouseup', endDrag);
  window.addEventListener('touchmove', onDrag, {passive:false});
  window.addEventListener('touchend', endDrag);
}
function onDrag(e){
  if (drag.curveIdx < 0) return;
  const c = curves[drag.curveIdx];
  const pt = toSvgPoint(e.touches ? e.touches[0] : e);
  const p  = snapPt(pt);            // accrochage 0,5 d√©j√† en place
  c.labels[drag.labelIdx] = { x:p.x, y:p.y };
  redrawLabels(c);
}
function endDrag(){
  drag = { curveIdx:-1, labelIdx:-1 };
  window.removeEventListener('mousemove', onDrag);
  window.removeEventListener('mouseup', endDrag);
  window.removeEventListener('touchmove', onDrag);
  window.removeEventListener('touchend', endDrag);
}


function setLabelMode(on){
  labelMode = !!on;
  const b = $('#mc-label',host);
  if(!b) return;
  b.classList.toggle('is-active', labelMode);
  b.textContent = (labelMode ? '‚úì ' : '') + 'Placer ' + curves[active].btn + ' sur la courbe';
}

  // ====== Fabrique une courbe si elle n'existe pas encore ======
function createCurve(i){
  const layerPts=document.createElementNS(rep.svg.namespaceURI,'g');
  const layerCur=document.createElementNS(rep.svg.namespaceURI,'g');
  const layerLbl=document.createElementNS(rep.svg.namespaceURI,'g');   // ‚Üê nouveau
  layerPts.style.pointerEvents='none';
  layerCur.style.pointerEvents='none';
  // labels: pas d'interaction ‚Üí laisse pointerEvents par d√©faut
  rep.plot.appendChild(layerPts);
  rep.plot.appendChild(layerCur);
  rep.plot.appendChild(layerLbl);                                     // ‚Üê nouveau
  return {
    i, name: labels[i], btn: btnLbl[i], color: colors[i],
    placed: [], Klast:null, pointsHidden:false,
    layerPts, layerCur, layerLbl,                                     // ‚Üê nouveau
    labels: [],                                                        // ‚Üê nouveau
    outs:{var:'',sign:'',deriv:''}
  };
}
function ensureCurve(i){
  if (!curves[i]) curves[i] = createCurve(i);
  return curves[i];
}


  // ====== Rendu des onglets Cf/Cg/... & visibilit√© des calques ======
  function renderTabs(){
    tabs.innerHTML = '';
    const upto = Math.max(count, curves.length);
    for (let i=0; i<upto; i++){
      if (!curves[i]) curves[i] = createCurve(i);
      const c = curves[i];

      // bouton
      const b = document.createElement('button');
      b.className = 'btn mc-tab';
      b.textContent = c.btn;
      b.style.borderColor = c.color;
      b.style.color = c.color;
      b.dataset.idx = String(i);
      b.style.display = (i < count) ? '' : 'none';
      tabs.appendChild(b);

      // calques affich√©s si i<count
     c.layerCur.style.display = (i < count) ? '' : 'none';
c.layerPts.style.display = (i < count) ? (c.pointsHidden ? 'none' : '') : 'none';
c.layerLbl.style.display = (i < count) ? '' : 'none';   // ‚Üê nouveau

    }
  }

  // ====== Outils graphiques ======
  const X = rep.X, Y = rep.Y;
  function redrawPts(c){
    c.layerPts.innerHTML = '';
    if (c.pointsHidden) return;
    c.placed.forEach(p=>{
      const dot = document.createElementNS(rep.svg.namespaceURI,'circle');
      dot.setAttribute('cx', X(p.x));
      dot.setAttribute('cy', Y(p.y));
      dot.setAttribute('r', 4.2);
      dot.setAttribute('fill', c.color);
      c.layerPts.appendChild(dot);
    });
  }
  function computeKnots(c){
    if (c.placed.length < 2) return null;
    const sorted = [...c.placed].sort((a,b)=>a.x-b.x);
    const K = sorted.map(p=>({x:p.x,y:p.y,m:0}));

    // pentes "douces"
    for(let i=0;i<K.length;i++){
      if(i===0){ const dx=(K[1].x-K[0].x)||1; K[i].m=(K[1].y-K[0].y)/dx*0.9; }
      else if(i===K.length-1){ const dx=(K[i].x-K[i-1].x)||1; K[i].m=(K[i].y-K[i-1].y)/dx*0.9; }
      else{ const dx=(K[i+1].x-K[i-1].x)||1; K[i].m=(K[i+1].y-K[i-1].y)/dx*0.9; }
    }
    // m=0 aux changements de variation
    for(let i=1;i<K.length-1;i++){
      const dyL = K[i].y - K[i-1].y, dyR = K[i+1].y - K[i].y;
      if (dyL * dyR < 0) K[i].m = 0;
    }
    return K;
  }
  function drawCurve(c, useExisting=false){
    const K = (useExisting && c.Klast) ? c.Klast : computeKnots(c);
    if(!K) return;
    c.layerCur.innerHTML = '';
    addPath(c.layerCur, pathFromKnots(rep, K), { stroke:c.color, 'stroke-width':2.6 });
    c.Klast = K;
  }
function redrawLabels(c){
  c.layerLbl.innerHTML = '';
    if (c.labels.length > 1) c.labels = c.labels.slice(0,1); // garde 1 seul

  c.labels.forEach((lbl, idx)=>{
    const fo = document.createElementNS(rep.svg.namespaceURI,'foreignObject');
    fo.setAttribute('x', rep.X(lbl.x) + 4);
    fo.setAttribute('y', rep.Y(lbl.y) - 14);
    fo.setAttribute('width', 60);
    fo.setAttribute('height', 24);
    fo.style.overflow = 'visible';

    const span = document.createElement('div');
    span.setAttribute('xmlns','http://www.w3.org/1999/xhtml');
    span.style.fontSize = '14px';
    span.style.lineHeight = '1';
    span.style.color = c.color;
    span.style.cursor = 'grab';
    span.style.userSelect = 'none';
    span.innerHTML = `\\(C_${c.name}\\)`;

    // drag (souris + tactile)
    span.addEventListener('mousedown', ev => beginDrag(c.i, idx, ev, span));
    span.addEventListener('touchstart', ev => beginDrag(c.i, idx, ev, span), {passive:false});

    // suppression: double-clic OU clic droit
    span.addEventListener('dblclick', ev => { ev.preventDefault(); c.labels.splice(idx,1); redrawLabels(c); });
    span.addEventListener('contextmenu', ev => { ev.preventDefault(); c.labels.splice(idx,1); redrawLabels(c); });

    fo.appendChild(span);
    c.layerLbl.appendChild(fo);
    typesetAll(span);
  });
}


function placeLabelAt(c, x, y){
  if (c.labels.length === 0) c.labels.push({ x, y });
  else                       c.labels[0] = { x, y }; // remplace / d√©place l‚Äôunique label
  redrawLabels(c);
}


  // ====== Analyse variation / signe pour UNE courbe ======
  function valueOnCurveK(K, x){
    for(let i=0;i<K.length-1;i++){
      const A=K[i], B=K[i+1];
      if (x<A.x || x>B.x) continue;
      const t=(x-A.x)/((B.x-A.x)||1);
      return hermiteY(A,B,A.m||0,B.m||0,t);
    }
    return (x<=K[0].x)? K[0].y : K.at(-1).y;
  }
  function analyzeVariationFromCurve(c){
    if(!c.Klast) return null;
    const K = c.Klast;
    const a2 = Math.max(+$('#mcxmin',host).value + 1, K[0].x);
    const b2 = Math.min(+$('#mcxmax',host).value - 1, K.at(-1).x);

    const crit = [];
    for(let i=0;i<K.length-1;i++){
      const A=K[i], B=K[i+1], m0=A.m||0, m1=B.m||0;
      const Ts = hermiteExtremaT(A,B,m0,m1);
      for(const t of Ts){
        const x = hermiteX(A,B,t);
        if(x>a2-1e-9 && x<b2+1e-9) crit.push(x);
      }
    }
    // n≈ìuds √† pente nulle & extremum
    const SLOPE_EPS = 1e-9;
    for(let i=1;i<K.length-1;i++){
      const L=K[i-1], M=K[i], R=K[i+1];
      if(M.x<=a2 || M.x>=b2) continue;
      const mi = M.m || 0;
      const isZero = Math.abs(mi) < SLOPE_EPS;
      const isMax = (M.y>L.y && M.y>R.y);
      const isMin = (M.y<L.y && M.y<R.y);
      if(isZero && (isMax || isMin)) crit.push(M.x);
    }

    crit.sort((a,b)=>a-b);
    const colsX=[a2]; for(const x of crit){ if(Math.abs(x-colsX.at(-1))>1e-3) colsX.push(x); } colsX.push(b2);
    const colsY=colsX.map(x=> valueOnCurveK(K,x));
const dirs=[]; for(let j=0;j<colsX.length-1;j++){
    const yL = colsY[j], yR = colsY[j+1];
    dirs.push( yR > yL ? '‚Üó' : (yR < yL ? '‚Üò' : '‚Üí') );
  }    const yMarks=colsX.map((xk,idx)=>{
      if(idx===0 || idx===colsX.length-1) return {yM:'', ym:''};
      const yL=colsY[idx-1], y0=colsY[idx], yR=colsY[idx+1];
      if(y0>yL && y0>yR) return {yM:fmtX(y0), ym:''};
      if(y0<yL && y0<yR) return {yM:'', ym:fmtX(y0)};
      return {yM:'', ym:''};
    });
    return { colsX, colsY, dirs, yMarks, K };
  }

  // ====== S√©lection d'onglet & sorties ======
  function paintTabs(){
    $$('.mc-tab',host).forEach(b=>{
      const idx = +b.dataset.idx;
      const c = curves[idx];
      const on = (idx === active);
      b.style.background = on ? c.color + '22' : '#fff';
      b.style.boxShadow  = on ? `0 0 0 2px ${c.color}33 inset` : '';
      b.style.borderWidth= on ? '2px' : '1px';
    });
    // MAJ libell√©s boutons globaux
    const a = curves[active];
const lb = $('#mc-label');
if (lb){
  const hasLabel = (a.labels && a.labels.length > 0);
  const verb = hasLabel ? 'Replacer ' : 'Placer ';
  lb.textContent = (labelMode ? '‚úì ' : '') + verb + a.btn + ' sur la courbe';
}


    $('#btn-action').textContent  = '‚úèÔ∏è Tracer '  + a.btn;
    $('#btn-action2').textContent = (a.pointsHidden? '‚Ü© Remettre les points ' : '‚®Ç Enlever les points ') + a.btn;

    // restaurer les sorties de la courbe active
    $('#mc-out-var',host).innerHTML   = a.outs.var   || '';
    $('#mc-out-sign',host).innerHTML  = a.outs.sign  || '';
    $('#mc-out-deriv',host).innerHTML = a.outs.deriv || '';
    typesetAll($('#mc-out-var',host)); typesetAll($('#mc-out-sign',host)); typesetAll($('#mc-out-deriv',host));
  }

  tabs.addEventListener('click', e=>{
    const b = e.target.closest('.mc-tab'); if(!b) return;
    active = +b.dataset.idx;
    if (active >= count) active = count - 1;
    paintTabs();
  });

  // ====== Placement des points sur la courbe active ======
  function toSvgPoint(evt){ const pt=rep.svg.createSVGPoint(); pt.x=(evt.touches?evt.touches[0].clientX:evt.clientX); pt.y=(evt.touches?evt.touches[0].clientY:evt.clientY); return pt.matrixTransform(rep.svg.getScreenCTM().inverse()); }
// remplace l‚Äôancienne snapPt(...)
function snapPt(svgPt){
  const q = v => Math.round(v * 2) / 2;   // pas = 0,5
  return { x: q(rep.Xi(svgPt.x)), y: q(rep.Yi(svgPt.y)) };
}
 
function togglePointActive(p){
  const c = ensureCurve(active);
  if(p.x<xmin||p.x>xmax||p.y<ymin||p.y>ymax) return;
  const k = c.placed.findIndex(q=> q.x===p.x && q.y===p.y);
  if(k>=0) c.placed.splice(k,1); else c.placed.push(p);
  redrawPts(c);
}

const onClick = e => {
  e.preventDefault();
  const pt = snapPt(toSvgPoint(e));
  const c  = ensureCurve(active);
  if (labelMode){
  const c = curves[active];
  if (c.labels.length === 0) placeLabelAt(c, pt.x, pt.y);   // premi√®re pose
  else { c.labels[0] = { x: pt.x, y: pt.y }; redrawLabels(c); }  // d√©place l‚Äôunique label
  return;
}
 else {
    togglePointActive(pt);
  }
};

rep.hit.addEventListener('click', onClick);
rep.hit.addEventListener('touchstart', onClick, {passive:false});


  // ====== API expos√©e ======
  function clampCount(k){ return Math.min(MAX, Math.max(1, k|0)); }

  host._mc_api = {
    // tracer la courbe active
    trace: ()=> { drawCurve(curves[active], false); },

    // afficher/masquer les points de la courbe active
    togglePts: ()=>{
      const c = curves[active];
      c.pointsHidden = !c.pointsHidden;
      redrawPts(c);
      paintTabs();
    },

    // modifier le nombre de courbes visibles sans reset
    applyCount: (k)=>{
      count = clampCount(k);
      if (curves.length < count){
        // cr√©er les nouvelles courbes si besoin
        for(let i=curves.length; i<count; i++) curves[i] = createCurve(i);
      }
      if (active >= count) active = count - 1;
      renderTabs();
      paintTabs();
    },

    // remake PR√âSERVANT l'√©tat quand on change amplitude
    remake: ()=>{
      // 1) snapshot
      const snap = {
  count, active,
  curves: curves.map(c=>({
    placed: c.placed.map(p=>({x:p.x,y:p.y})),
    pointsHidden: c.pointsHidden,
    outs: {...c.outs},
    labels: (c.labels||[]).map(L=>({x:L.x,y:L.y})),   // ‚Üê nouveau
    color: c.color, name: c.name, btn: c.btn
  }))
};


      // 2) nouvelles bornes
      const aX = +$('#mcxmin',host).value, bX = +$('#mcxmax',host).value,
            aY = +$('#mcymin',host).value, bY = +$('#mcymax',host).value;

      // 3) reconstruire le rep√®re
      $('#mc-graph',host).innerHTML='';
      rep = buildRepereSVG({ xmin:aX, xmax:bX, ymin:aY, ymax:bY, grid:true, arrows:true });
      $('#mc-graph',host).appendChild(rep.svg);

      // 4) r√©installer calques pour toutes les courbes existantes
      curves.forEach((c,i)=>{
  c.layerPts = document.createElementNS(rep.svg.namespaceURI,'g');
  c.layerCur = document.createElementNS(rep.svg.namespaceURI,'g');
  c.layerLbl = document.createElementNS(rep.svg.namespaceURI,'g');     // ‚Üê nouveau
  c.layerPts.style.pointerEvents='none';
  c.layerCur.style.pointerEvents='none';
  rep.plot.appendChild(c.layerPts);
  rep.plot.appendChild(c.layerCur);
  rep.plot.appendChild(c.layerLbl);                                    // ‚Üê nouveau

  const s = snap.curves[i] || {};
  c.placed       = s.placed || [];
  c.pointsHidden = !!s.pointsHidden;
  c.outs         = s.outs || {var:'',sign:'',deriv:''};
  c.labels       = s.labels || [];                                     // ‚Üê nouveau

  redrawPts(c);
  drawCurve(c, false);
  redrawLabels(c);                                                     // ‚Üê nouveau
});


      // 5) reco des clics
const onClick2 = e => {
  e.preventDefault();
  const pt = snapPt(toSvgPoint(e));
  const c  = ensureCurve(active);
  if (labelMode){
    placeLabelAt(c, pt.x, pt.y);
  } else {
    togglePointActive(pt);
  }
};
rep.hit.addEventListener('click', onClick2);
rep.hit.addEventListener('touchstart', onClick2, {passive:false});


      // 6) restaurer nombre et active
      count  = clampCount(snap.count);
      active = Math.min(snap.active, Math.max(0, count-1));
      renderTabs();
      paintTabs();
    },

    // reset total
    fullReset: ()=>{
      curves.forEach(c=>{
        c.placed.length=0; c.Klast=null; c.pointsHidden=false;
        c.layerPts.innerHTML=''; c.layerCur.innerHTML='';
        c.outs = {var:'',sign:'',deriv:''};
      });
      $('#mc-out-var',host).innerHTML='';
      $('#mc-out-sign',host).innerHTML='';
      $('#mc-out-deriv',host).innerHTML='';
      paintTabs();
    },

    // === Tableaux pour la courbe active ===
    makeVarTable: ()=>{
      const a = curves[active];
      if(!a.Klast){ const K=computeKnots(a); if(K){ a.Klast=K; drawCurve(a,true);} }
      const A = analyzeVariationFromCurve(a);
      if(!A){ $('#mc-out-var',host).innerHTML='<div class="step small">Trace d‚Äôabord la courbe '+a.btn+' (‚â• 2 points).</div>'; return; }
      const {colsX, colsY, dirs, yMarks} = A;

      const head=['<tr><th>\\(x\\)</th>'];
      colsX.forEach((x,j)=>{ head.push(`<td>\\(${fmtX(x).replace('-',UMIN)}\\)</td>`); if(j<colsX.length-1) head.push('<td></td>'); });
      head.push('</tr>');

      const L = s => s? `\\(${String(s).replace('.',',').replace('-',UMIN)}\\)` : '&nbsp;';
      const cellVal=(v,top)=>{ const up=top?L(v):'&nbsp;', dn=!top?L(v):'&nbsp;'; return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`; };
      const body=['<tr><th>\\('+a.name+'\\)</th>'];
	const cellValMidVar = v => `<td class="mid"><div class="midv">${L(v)}</div></td>`;

      for(let i=0;i<colsX.length;i++){
        if(i===0){
          const d=dirs[0];
          if(d==='‚Üó') body.push(cellVal(fmtX(colsY[0]),false));
          else if(d==='‚Üò') body.push(cellVal(fmtX(colsY[0]),true));
          else if(d==='‚Üí') body.push(cellValMidVar(fmtX(colsY[0])));
          else body.push(cellVal('',true));
        }else if(i===colsX.length-1){
         const d=dirs.at(-1);
          if(d==='‚Üó') body.push(cellVal(fmtX(colsY.at(-1)),true));
          else if(d==='‚Üò') body.push(cellVal(fmtX(colsY.at(-1)),false));
          else if(d==='‚Üí') body.push(cellValMidVar(fmtX(colsY.at(-1))));
          else body.push(cellVal('',true));
        }else{
          const {yM,ym}=yMarks[i]; if(yM) body.push(cellVal(yM,true)); else if(ym) body.push(cellVal(ym,false)); else body.push(cellVal('',true));
        }
        if(i<colsX.length-1) body.push(`<td class="arr">${dirs[i]||''}</td>`);
      }
      body.push('</tr>');

      const html = `<div class="step"><div><b>${a.btn} ‚Äî Tableau de variations :</b></div><div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${body.join('')}</tbody></table></div></div>`;
      a.outs.var = html; $('#mc-out-var',host).innerHTML = html; typesetAll($('#mc-out-var',host));
    },

    makeSignTable: ()=>{
      const a = curves[active];
      if(!a.Klast){ const K=computeKnots(a); if(K){ a.Klast=K; drawCurve(a,true);} }
      const K=a.Klast; if(!K){ $('#mc-out-sign',host).innerHTML='<div class="step small">Trace la courbe '+a.btn+' (‚â• 2 points).</div>'; return; }

      const a2 = Math.max(+$('#mcxmin',host).value + 1, K[0].x);
      const b2 = Math.min(+$('#mcxmax',host).value - 1, K.at(-1).x);

      const roots=[];
      for(let i=0;i<K.length-1;i++){
        const A=K[i], B=K[i+1], m0=A.m||0, m1=B.m||0;
        const Ts = rootsOnArc(A,B,m0,m1);
        Ts.forEach(t=>{
          const x=hermiteX(A,B,t); const y=hermiteY(A,B,m0,m1,t);
          if(x>=a2-1e-6 && x<=b2+1e-6 && Math.abs(y)<1e-3) roots.push(x);
        });
      }
      roots.sort((a,b)=>a-b);
      const EPS=0.05, uniq=[]; for(const x of roots){ if(uniq.length===0 || Math.abs(x-uniq.at(-1))>EPS) uniq.push(x); }
      const xCols=[a2, ...uniq, b2];

      const head=['<tr><th>\\(x\\)</th>'];
      xCols.forEach((x,j)=>{ head.push(`<td>\\(${fmtX(x).replace('-',UMIN)}\\)</td>`); if(j<xCols.length-1) head.push('<td></td>'); });
      head.push('</tr>');

      const sgnInt=[];
      for(let j=0;j<xCols.length-1;j++){
        const mid=(xCols[j]+xCols[j+1])/2;
        const y=valueOnCurveK(K,mid);
        sgnInt.push( y>0? '+' : (y<0? UMIN : '') );
      }

      let rowF=`<tr><th>\\(${a.name}(x)\\)</th>`;
      for(let j=0;j<xCols.length;j++){
        const isEdge = (j===0 || j===xCols.length-1);
        const isRootCol = (j>0 && j<xCols.length-1);
        if(isRootCol) rowF += `<td class="zbar" style="text-align:center">0</td>`;
        else if(!isEdge) rowF += `<td class="sbar"></td>`;
        else rowF += `<td></td>`;
        if(j<xCols.length-1) rowF += `<td style="text-align:center">${sgnInt[j]||''}</td>`;
      }
      rowF += '</tr>';

      const html = `<div class="step"><div><b>${a.btn} ‚Äî Tableau de signes :</b> <span class="small">(racines ‚âà)</span></div><div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowF}</tbody></table></div></div>`;
      a.outs.sign = html; $('#mc-out-sign',host).innerHTML = html; typesetAll($('#mc-out-sign',host));
    },

    makeDerivVarTable: ()=>{
      const a = curves[active];
      if(!a.Klast){ const K=computeKnots(a); if(K){ a.Klast=K; drawCurve(a,true);} }
      const A = analyzeVariationFromCurve(a);
      if(!A){ $('#mc-out-deriv',host).innerHTML='<div class="step small">Trace d‚Äôabord la courbe '+a.btn+' (‚â• 2 points).</div>'; return; }

      const {colsX, colsY, dirs, yMarks} = A;

      const head=['<tr><th>\\(x\\)</th>'];
      colsX.forEach((x,j)=>{ head.push(`<td>\\(${fmtX(x).replace('-',UMIN)}\\)</td>`); if(j<colsX.length-1) head.push('<td></td>'); });
      head.push('</tr>');

      const signFromDir = d => d==='‚Üó' ? '+' : (d==='‚Üò' ? UMIN : '');
      let rowFp = `<tr><th>\\(${a.name}'(x)\\)</th>`;
      for(let j=0;j<colsX.length;j++){
        const isEdge = (j===0 || j===colsX.length-1);
        if(!isEdge) rowFp += `<td class="zbar" style="text-align:center">0</td>`;
        else rowFp += `<td></td>`;
        if(j<colsX.length-1) rowFp += `<td style="text-align:center">${signFromDir(dirs[j])}</td>`;
      }
      rowFp += '</tr>';

      const L = s => s? `\\(${String(s).replace('.',',').replace('-',UMIN)}\\)` : '&nbsp;';
      const cellVal=(v,top)=>{ const up=top?L(v):'&nbsp;', dn=!top?L(v):'&nbsp;'; return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`; };
      const bodyF=['<tr><th>\\('+a.name+'\\)</th>'];
	  const cellValMidVar = v => `<td class="mid"><div class="midv">${L(v)}</div></td>`;

      for(let i=0;i<colsX.length;i++){
        if(i===0){
         const d=dirs[0];
         if(d==='‚Üó') bodyF.push(cellVal(fmtX(colsY[0]),false));
         else if(d==='‚Üò') bodyF.push(cellVal(fmtX(colsY[0]),true));
         else if(d==='‚Üí') bodyF.push(cellValMidVar(fmtX(colsY[0])));
          else bodyF.push(cellVal('',true));
       } else if(i===colsX.length-1){
          const d=dirs.at(-1);
          if(d==='‚Üó') bodyF.push(cellVal(fmtX(colsY.at(-1)),true));
          else if(d==='‚Üò') bodyF.push(cellVal(fmtX(colsY.at(-1)),false));
          else if(d==='‚Üí') bodyF.push(cellValMidVar(fmtX(colsY.at(-1))));
          else bodyF.push(cellVal('',true));
        } else { const {yM,ym}=yMarks[i]; if(yM) bodyF.push(cellVal(yM,true)); else if(ym) bodyF.push(cellVal(ym,false)); else bodyF.push(cellVal('',true)); }
        if(i<colsX.length-1) bodyF.push(`<td class="arr">${dirs[i]||''}</td>`);
      }
      bodyF.push('</tr>');

      const html = `<div class="step"><div><b>${a.btn} ‚Äî Tableau \\(${a.name}'(x)\\) et variations de \\(${a.name}\\) :</b></div><div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowFp}${bodyF.join('')}</tbody></table></div></div>`;
      a.outs.deriv = html; $('#mc-out-deriv',host).innerHTML = html; typesetAll($('#mc-out-deriv',host));
    }
  };

  // ====== Brancher les boutons globaux ======
// ====== Brancher les boutons globaux ======
$('#btn-action').style.display = 'inline-block';
$('#btn-action2').style.display = 'inline-block';
$('#btn-action').onclick  = ()=> host._mc_api?.trace();
$('#btn-action2').onclick = ()=> host._mc_api?.togglePts();

// ‚á©‚á©‚á© bouton "Placer Cf sur la courbe"
const lblBtn = $('#mc-label'); // PAS de ",host"
if (lblBtn){
  lblBtn.style.display = 'inline-block';
  lblBtn.onclick = ()=> setLabelMode(!labelMode);
  // libell√© provisoire (paintTabs fera le bon libell√© apr√®s renderTabs)
  lblBtn.textContent = (labelMode ? '‚úì ' : '') + 'Placer Cf sur la courbe';
}



  // Amplitude ‚Üí remake pr√©serv√©
  ['mcxmin','mcxmax','mcymin','mcymax'].forEach(id=>{
    $('#'+id,host).onchange = ()=> host._mc_api?.remake();
  });

  // Appliquer (nombre de courbes) ‚Üí ajoute/affiche sans reset
  $('#mc-apply',host).onclick = ()=> host._mc_api?.applyCount(+$('#mc-n',host).value || 1);

  // ====== Initialisation visuelle ======
  renderTabs();
  paintTabs();
},



      

  wireLocal(host){
    $('#mc-btn-var',host).onclick   = ()=> host._mc_api?.makeVarTable();
    $('#mc-btn-sign',host).onclick  = ()=> host._mc_api?.makeSignTable();
    $('#mc-btn-deriv',host).onclick = ()=> host._mc_api?.makeDerivVarTable();
    // masque le bouton "Cr√©er le tableau" g√©n√©rique
    $('#btn-make').style.display='none';
  },

  wireButtons(){
    // les boutons globaux sont d√©j√† c√¢bl√©s dans makeRep()
  },

  reset(){
    const host=$('#host');
    if(host && host._mc_api){
      host._mc_api.fullReset();
      host._mc_api.remake();
    }
  }
};



/* ===== 2) G√©n√©rateur de tableau de variations (n extr√©mums) ===== */
const toolVar = {
  id:'var', title:'Tableau de variations (inputs ‚Üí tableau PDF)',
  build(host){
    host.innerHTML = `
      <div class="row">
        <label>Nombre d‚Äôextr√©mums :</label>
        <input id="v-n" type="number" min="1" max="4" value="2" style="width:70px">
        <button id="v-gen" class="btn">G√©n√©rer la grille</button>
      </div>
      <div id="v-wrap" style="margin-top:.5rem"></div>
      <div class="steps" id="v-out"></div>
    `;
    $('#v-gen',host).onclick=()=> this.makeGrid(host);
  },
  makeGrid(host){
    const n=Math.min(4, Math.max(1, +$('#v-n',host).value||2));
    const cols=['xmin', ...Array.from({length:n},(_,i)=>'x'+(i+1)), 'xmax'];
    function xCell(role){ return `<td><input class="vx" data-role="${role}" type="text" placeholder="${role}"></td>`; }
    function arrowCell(i){ return `<td class="bigsel"><select class="vdir" data-i="${i}">  <option></option><option>‚Üò</option><option>‚Üó</option><option>‚Üí</option></select></td>`; }
// Ligne x ‚Äî en-t√™te √©ditable
let rowX = '<tr><th><input class="v-hx" type="text" value="x" style="width:70px;text-align:center"></th>';
cols.forEach((c,j)=>{ 
  rowX += xCell(c);                         // inchang√©
  if(j < cols.length-1) rowX += '<td></td>'; // s√©parateur d‚Äôintervalle
});
rowX += '</tr>';

// Ligne f ‚Äî en-t√™te √©ditable
function yBlock(role){
  return `<div style="display:flex;flex-direction:column;gap:6px;align-items:center">
            <input class="vy-max" data-role="${role}" type="text" placeholder="max">
            <input class="vy-min" data-role="${role}" type="text" placeholder="min">
          </div>`;
}
// cellule f avec s√©lecteur racine/|| + max/min
function fCell(role){
  return `<td>
    <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
      <select class="vfmark" data-role="${role}">
        <option value=""></option>
        <option value="||">||</option>
      </select>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
        <input class="vy-max" data-role="${role}" type="text" placeholder="max">
        <input class="vy-min" data-role="${role}" type="text" placeholder="min">
      </div>
    </div>
  </td>`;
}


let rowF = '<tr><th><input class="v-hf" type="text" value="f" style="width:70px;text-align:center"></th>';
cols.forEach((c,j)=>{
  rowF += fCell(c);
  if(j < cols.length-1) rowF += `<td class="bigsel"><select class="vdir" data-i="${j}">  <option></option><option>‚Üò</option><option>‚Üó</option><option>‚Üí</option></select></td>`;
});
rowF += '</tr>';

$('#v-wrap',host).innerHTML =
  `<div class="var-wrap"><table class="var"><tbody>${rowX}${rowF}</tbody></table></div>`;
wireBarCells($('#v-wrap',host));
typesetAll($('#v-wrap',host));
$('#btn-make').style.display='inline-block';
$('#btn-action').style.display='none';
$('#btn-action2').style.display='none';

typesetAll($('#v-wrap',host)); // pour les √©ventuels LaTeX saisis par l'utilisateur

  },
/* ========= 2) Tableau de variations ‚Äî makeTable(host) ========= */
/* ========= 2) Tableau de variations ‚Äî makeTable(host) ========= */
makeTable(host){
  const clean = s => (s||'')
    .replace(/^\\\(|\\\)$/g,'').replace(/^\$+|\$+$/g,'').trim();
  const L = s => `\\(${s}\\)`;

  const labelX = clean($('.v-hx',host)?.value || 'x');
  const labelF = clean($('.v-hf',host)?.value || 'f');

  // r√¥les & entr√©es utilisateur
  const roles = $$('.vx',host).map(inp => inp.dataset.role);                // ['xmin','x1',‚Ä¶,'xmax']
  const xs    = $$('.vx',host).map(inp => inp.value.trim().replace('\u2212','-'));
  const dirs  = $$('.vdir',host).map(sel => sel.value || '');               // entre colonnes

  // valeurs "max/min" saisies par colonne
  const vals = roles.map(r => ({
    yM: $(`.vy-max[data-role="${r}"]`,host)?.value.trim() || '',
    ym: $(`.vy-min[data-role="${r}"]`,host)?.value.trim() || ''
  }));

  // marquage (vide | '||')
  const vmark = {};
  $$('.vfmark', host).forEach(sel => { vmark[sel.dataset.role] = sel.value || ''; });

  // --- pr√©paration des affichages "classiques" (hors ||) ---
  const topArr = new Array(roles.length).fill('');
  const botArr = new Array(roles.length).fill('');
  const overrideCore = new Array(roles.length).fill(null); // si ‚Üí : cellule mid


  roles.forEach((r, idx) => {
    const { yM, ym } = vals[idx];
    const isFirst = (idx === 0), isLast = (idx === roles.length - 1);
    if (isFirst){
           const d = dirs[0] || '';
      if      (d === '‚Üó') botArr[idx] = ym || '';
      else if (d === '‚Üò') topArr[idx] = yM || '';
      else if (d === '‚Üí') overrideCore[idx] = cellValMid( ym || yM || '' );
     
    } else if (isLast){
       const d = dirs.at(-1) || '';
      if      (d === '‚Üó') topArr[idx] = yM || '';
      else if (d === '‚Üò') botArr[idx] = ym || '';
      else if (d === '‚Üí') overrideCore[idx] = cellValMid( yM || ym || '' );
    
    } else {
      if      (yM) topArr[idx] = yM;
      else if (ym) botArr[idx] = ym;
    }
  });

  // helper rendu
  function cellValRaw(topText, bottomText){
    const up = topText ? Lx(topText) : '&nbsp;';
    const dn = bottomText ? Lx(bottomText) : '&nbsp;';
    return `<td><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`;
  }
function cellValMid(v){
  // Valeur unique, centr√©e verticalement au milieu de la cellule
  return `<td class="mid"><div class="midv">${Lx(v)}</div></td>`;
}

  // === NOUVEAU : mod√®le de colonnes "√©tendu" autour des || ===
  // Chaque r√¥le produit: [limL?] + core + [limR?] puis (s‚Äôil n‚Äôest pas le dernier) un s√©parateur d‚Äôintervalle.
  const exp = []; // {kind:'limL'|'core'|'limR'|'sep', idx, role}
  roles.forEach((r, k) => {
    const isBar = (vmark[r] === '||');
    const isFirst = (k === 0), isLast = (k === roles.length - 1);

    if (isBar && !isFirst) exp.push({ kind:'limL', idx:k, role:r });
    exp.push({ kind:'core', idx:k, role:r });
    if (isBar && !isLast)  exp.push({ kind:'limR', idx:k, role:r });

    if (k < roles.length - 1) exp.push({ kind:'sep', idx:k });
  });

  // THEAD √©tendu (cases vides au-dessus des nouvelles colonnes)
  const head = ['<tr><th>'+L(labelX)+'</th>'];
  exp.forEach(e => {
    if (e.kind === 'core') head.push(`<td>${Lx(xs[e.idx])}</td>`);
    else                   head.push('<td></td>'); // limL/limR/sep
  });
  head.push('</tr>');

  // TBODY ‚Äî ligne f
  let rowF = '<tr><th>'+L(labelF)+'</th>';
  exp.forEach(e => {
    if (e.kind === 'sep'){
      rowF += `<td class="arr">${dirs[e.idx] || ''}</td>`;
      return;
    }
    if (e.kind === 'core'){
     const role = roles[e.idx];
      const isBar = (vmark[role] === '||');
      const leftConst  = (e.idx > 0 && dirs[e.idx - 1] === '‚Üí');
      const rightConst = (e.idx < roles.length - 1 && dirs[e.idx] === '‚Üí');
      const vCore = vals[e.idx].yM || vals[e.idx].ym || '';

      if (isBar){
        // || : juste la double barre
        rowF += '<td class="dbar"></td>';
      } else if (overrideCore[e.idx]){
        // extr√©mit√©s d√©j√† surclass√©es (‚Üí)
        rowF += overrideCore[e.idx];
      } else if (leftConst || rightConst){
        // ‚üµ NOUVEAU : si un des intervalles adjacents est ‚Üí, on centre la valeur
        rowF += cellValMid(vCore);
      } else {
        // cas ‚Üó / ‚Üò classique (haut/bas)
        rowF += cellValRaw(topArr[e.idx], botArr[e.idx]);
     }
       return;
    }
    // ---- colonne limite GAUCHE d'une double barre ----
if (e.kind === 'limL') {
  // priorit√© yM (max = limite gauche), sinon retombe sur ym pour dupliquer
  const vRaw = vals[e.idx].yM || vals[e.idx].ym || '';
  const dL   = dirs[e.idx - 1] || ''; // sens de l'intervalle de gauche
  if (!vRaw) { rowF += '<td class="lim"></td>'; return; }
  if (dL === '‚Üí') { rowF += cellValMid(vRaw); return; }
  // ‚Üó (vers la barre) finit en HAUT √† gauche ; ‚Üò finit en BAS √† gauche
  rowF += (dL === '‚Üó') ? cellValRaw(vRaw, '') 
       : (dL === '‚Üò') ? cellValRaw('', vRaw)
                     : cellValRaw(vRaw, '');  // d√©faut: en haut
  return;
}

// ---- colonne limite DROITE d'une double barre ----
if (e.kind === 'limR') {
  // priorit√© ym (min = limite droite), sinon retombe sur yM pour dupliquer
  const vRaw = vals[e.idx].ym || vals[e.idx].yM || '';
  const dR   = dirs[e.idx] || ''; // sens de l'intervalle de droite
 if (!vRaw) { rowF += '<td class="lim"></td>'; return; }
  if (dR === '‚Üí') { rowF += cellValMid(vRaw); return; }
  // ‚Üó (en repartant) d√©marre en BAS √† droite ; ‚Üò d√©marre en HAUT √† droite
  rowF += (dR === '‚Üó') ? cellValRaw('', vRaw)
       : (dR === '‚Üò') ? cellValRaw(vRaw, '')
                      : cellValRaw('', vRaw);  // d√©faut: en bas
  return;
}

  });
  rowF += '</tr>';

  // Injection
  $('#v-out',host).innerHTML =
    `<div class="step"><div><b>Tableau de variations :</b></div>
       <div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowF}</tbody></table></div>
     </div>`;
  typesetAll($('#v-out',host));
}
,

  wireButtons(){ $('#btn-make').onclick=()=> this.makeTable($('#host')); $('#btn-action').style.display='none'; $('#btn-action2').style.display='none'; const labBtn = $('#mc-label');
  if (labBtn) labBtn.style.display = 'none';},
  reset(){ $('#v-out') && ($('#v-out').innerHTML=''); }
};

/* ===== 3) Tableau de signes (1 ligne) ===== */
const toolSign1 = {
  id:'sign1', title:'Tableau de signes (1 ligne)',
  build(host){
    host.innerHTML = `
      <div class="row">
        <label>Nombre de racines :</label>
        <input id="s1-k" type="number" min="0" max="6" value="2" style="width:70px">
        <button id="s1-gen" class="btn">G√©n√©rer la grille</button>
      </div>
      <div id="s1-wrap" style="margin-top:.5rem"></div>
      <div class="steps" id="s1-out"></div>`;
    $('#s1-gen',host).onclick=()=> this.makeGrid(host);
  },
  makeGrid(host){
    const k=Math.max(0, Math.min(6, +$('#s1-k',host).value||0));
    const cols = ['xmin', ...Array.from({length:k},(_,i)=>'r'+(i+1)), 'xmax'];
    function xCell(role){ return `<td><input class="s1x" data-role="${role}" type="text" placeholder="${role}"></td>`; }
    function gapCell(i){ return `<td class="bigsel"><select class="s1sgn" data-i="${i}"><option></option><option value="+">+</option><option value="${UMIN}">${UMIN}</option></select></td>`; }
function zeroCell(role){
  return `<td class="bigsel">
    <select class="s1z" data-role="${role}">
      <option value=""></option>
      <option value="0">0</option>
      <option value="||">||</option>
    </select>
  </td>`;
}
// Ligne x (en-t√™te √©ditable)
let rowX = '<tr><th><input class="s1-hx" type="text" value="x" style="width:70px;text-align:center"></th>';
cols.forEach((c,j)=>{ rowX += xCell(c); if(j<cols.length-1) rowX+='<td></td>'; });
rowX += '</tr>';

// Ligne f(x) (en-t√™te √©ditable)
let rowF = '<tr><th><input class="s1-hf" type="text" value="f(x)" style="width:70px;text-align:center"></th>';
cols.forEach((c,j)=>{
  if(c==='xmin'||c==='xmax') rowF+=zeroCell(c);
  else if(c[0]==='r') rowF+=zeroCell(c);
  else rowF+='<td></td>';
  if(j<cols.length-1) rowF+=gapCell(j);
});
rowF+='</tr>';
    $('#s1-wrap',host).innerHTML = `<div class="var-wrap"><table class="var"><tbody>${rowX}${rowF}</tbody></table></div>`;
    wireBarCells($('#s1-wrap',host));
	$('#btn-make').style.display='inline-block'; $('#btn-action').style.display='none'; $('#btn-action2').style.display='none';
    typesetAll($('#s1-wrap',host));
        // ‚üµ AJOUT

  },
  makeTable(host){
    const xs=$$('.s1x',host).map(i=>i.value.trim());
    const sgn=$$('.s1sgn',host).map(s=>s.value||'');
const zmap = {};
$$('.s1z',host).forEach(sel=>{
  zmap[sel.dataset.role] = sel.value || '';
});
const clean = s => (s||'').replace(/^\\\(|\\\)$/g,'').replace(/^\$+|\$+$/g,'').trim();
const L = s => `\\(${s}\\)`;

const labelX = clean($('.s1-hx',host)?.value || 'x');
const labelF = clean($('.s1-hf',host)?.value || 'f(x)');
const head=['<tr><th>'+L(labelX)+'</th>'];
xs.forEach((x,j)=>{ head.push(`<td>${Lx(x)}</td>`); if(j<xs.length-1) head.push('<td></td>'); });
head.push('</tr>');
const roles = ['xmin', ...$$('.s1x',host).slice(1,-1).map((_,i)=>'r'+(i+1)), 'xmax'];

let rowF = '<tr><th>'+L(labelF)+'</th>';
roles.forEach((role, j)=>{
  rowF += pdfBarCell(zmap[role] || '', role);
  if (j < roles.length-1) rowF += `<td style="font-weight:700">${sgn[j]||''}</td>`;
});
rowF += '</tr>';

    $('#s1-out',host).innerHTML = `<div class="step"><div><b>Tableau de signes :</b></div><div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowF}</tbody></table></div></div>`;
    typesetAll($('#s1-out',host));
  },
  wireButtons(){ $('#btn-make').onclick=()=> this.makeTable($('#host')); $('#btn-action').style.display='none'; $('#btn-action2').style.display='none'; const labBtn = $('#mc-label');
  if (labBtn) labBtn.style.display = 'none';},
  reset(){ $('#s1-out') && ($('#s1-out').innerHTML=''); }
};

/* ===== 4) Tableau de signes factoris√© (plusieurs lignes) ===== */
const toolSignFact = {
  id:'signF', title:'Tableau de signes (forme factoris√©e, multi-lignes)',
  build(host){
    host.innerHTML = `
      <div class="row">
        <label>Nombre de racines :</label>
        <input id="sf-k" type="number" min="0" max="6" value="2" style="width:70px">
        <label>Valeur de a :</label>
        <input id="sf-a" type="text" value="1" style="width:80px">
        <label>Nombre de facteurs :</label>
        <input id="sf-m" type="number" min="1" max="6" value="2" style="width:70px">
        <button id="sf-gen" class="btn">G√©n√©rer la grille</button>
      </div>
      <div id="sf-wrap" style="margin-top:.5rem"></div>
      <div class="steps" id="sf-out"></div>`;
    $('#sf-gen',host).onclick=()=> this.makeGrid(host);
  },
  makeGrid(host){
  const k = Math.max(0, Math.min(6, +$('#sf-k',host).value || 0));   // nb de racines
  const m = Math.max(1, Math.min(6, +$('#sf-m',host).value || 1));   // nb de facteurs
  const showA = ($('#sf-a',host).value.trim() !== '1');               // afficher ligne "a" ?
  const cols = ['xmin', ...Array.from({length:k}, (_,i)=> 'r'+(i+1)), 'xmax'];

  // helpers cellules
  const xCell = (role)=> `<td><input class="sf-x" data-role="${role}" type="text" placeholder="${role}"></td>`;
  const signCell = (cls,i)=> `<td class="bigsel">
    <select class="sf-sgn ${cls}" data-i="${i}">
      <option></option><option>+</option><option>${UMIN}</option>
    </select>
  </td>`;
  const zeroSelector = (f, role)=> `<td class="bigsel">
    <select class="sfz" data-factor="${f}" data-role="${role}">
      <option value=""></option>
      <option value="0">0</option>
      <option value="||">||</option>
    </select>
  </td>`;

 

 // Ligne x
let rowX = '<tr class="sf-row-x"><th><input class="sf-hx" type="text" value="x" style="width:70px;text-align:center"></th>';
cols.forEach((c,j)=>{ rowX += xCell(c); if(j<cols.length-1) rowX+='<td></td>'; });
rowX+='</tr>';
let rows=rowX;

// Ligne a
if(showA){
  let r = '<tr class="sf-row-a"><th><input class="sf-ha" type="text" value="a" style="width:70px;text-align:center"></th>';
  cols.forEach((_,j)=>{ r+='<td></td>'; if(j<cols.length-1) r+=signCell('sf-a',j); });
  r+='</tr>'; rows+=r;
}

// Lignes Facteur i
for(let f=1; f<=m; f++){
  // (dans for f=1..m)
  let r = `<tr class="sf-row-factor" data-factor="${f}"><th><input class="sf-hf" data-factor="${f}" type="text" value="" style="width:110px;text-align:center"></th>`;
cols.forEach((c,j)=>{
  // ‚üµ d√©sormais: s√©lecteur 0/|| sur xmin, r_i, xmax
  if (c === 'xmin' || c === 'xmax' || c[0] === 'r') {
    r += `<td class="bigsel">
            <select class="sfz" data-factor="${f}" data-role="${c}">
              <option value=""></option>
              <option value="0">0</option>
              <option value="||">||</option>
            </select>
          </td>`;
  } else {
    r += '<td></td>';
  }
  if (j < cols.length-1) {
    r += `<td class="bigsel">
            <select class="sf-sgn sf-f${f}" data-i="${j}">
              <option></option><option>+</option><option>${UMIN}</option>
            </select>
          </td>`;
  }
});
r += '</tr>';
rows += r;

}

// Ligne f(x)
// 4) Derni√®re ligne : f(x) ‚Äî avec s√©lecteurs 0/||
let rF = '<tr class="sf-row-fx"><th><input class="sf-hfx" type="text" value="f(x)" style="width:70px;text-align:center"></th>';
cols.forEach((role, j) => {
  rF += `<td class="bigsel">
          <select class="sfz-fx" data-role="${role}">
            <option value=""></option>
            <option value="0">0</option>
            <option value="||">||</option>
          </select>
        </td>`;
  if (j < cols.length - 1) {
    rF += `<td class="bigsel"><select class="sf-sgn-fx" data-i="${j}">
             <option></option><option>+</option><option>${UMIN}</option>
           </select></td>`;
  }
});
rF += '</tr>';
rows += rF;


  // 5) Injection + UI + MathJax
  $('#sf-wrap',host).innerHTML = `<div class="var-wrap"><table class="var"><tbody>${rows}</tbody></table></div>`;
  wireBarCells($('#sf-wrap',host));
  $('#btn-make').style.display = 'inline-block';
  $('#btn-action').style.display = 'none';
  $('#btn-action2').style.display = 'none';
  typesetAll($('#sf-wrap',host));
},

  makeTable(host){
    const xs=$$('.sf-x',host).map(i=>i.value.trim());
    const cols=xs.length;
	// R√©cup√®re les 0/|| choisis pour chaque facteur et chaque colonne (xmin, r_i, xmax)
const Z = {}; // Z[factorIndex][role] = "0" | "||" | ""
$$('.sfz',host).forEach(sel => {
  const f = +sel.dataset.factor; const role = sel.dataset.role;
  if (!Z[f]) Z[f] = {};
  Z[f][role] = sel.value || '';
});
// 0/|| choisis sur la derni√®re ligne f(x)
const Zfx = {};  // Zfx[role] = "0" | "||" | ""
$$('.sfz-fx', host).forEach(sel => {
  Zfx[sel.dataset.role] = sel.value || '';
});

    const intervals=cols-1;
    const signRows = [];
    if($$('.sf-a',host).length){ signRows.push({label:'a', signs:$$('.sf-a',host).map(s=>s.value||'')}); }
    let fIdx=1; while($$('.sf-f'+fIdx,host).length){ signRows.push({label:'Facteur '+fIdx, signs:$$('.sf-f'+fIdx,host).map(s=>s.value||'')}); fIdx++; }
    const fx = $$('.sf-sgn-fx',host).map(s=>s.value||'');
   const clean = s => (s||'').replace(/^\\\(|\\\)$/g,'').replace(/^\$+|\$+$/g,'').trim();
const L = s => `\\(${s}\\)`;

const labelX  = clean($('.sf-hx',host )?.value || 'x');
const labelA  = clean($('.sf-ha',host )?.value || 'a');
const labelFx = clean($('.sf-hfx',host)?.value || 'f(x)');

const factLabels = $$('.sf-hf',host).map(inp=> clean(inp.value||'') );

// En-t√™te x
const head=['<tr><th>'+L(labelX)+'</th>'];
xs.forEach((x,j)=>{ head.push(`<td>${Lx(x)}</td>`); if(j<xs.length-1) head.push('<td></td>'); });
head.push('</tr>');

// Lignes a + Facteurs
const body=[];
// Ligne a (SOLUTION PDF) : barres verticales entre les signes
if ($$('.sf-a', host).length) {
  let tr = '<tr class="sf-pdf-row-a"><th>' + L(labelA) + '</th>';
  for (let j = 0; j < cols; j++) {
    const isEdge = (j === 0 || j === cols - 1);
    tr += isEdge ? '<td></td>' : '<td class="sbar"></td>'; // ‚Üê barre verticale
    if (j < cols - 1) {
      tr += `<td style="font-weight:700;text-align:center">${$$('.sf-a', host)[j]?.value || ''}</td>`;
    }
  }
  tr += '</tr>';
  body.push(tr);
}

// factLabels = labels des facteurs (d√©j√† r√©cup√©r√©s)
const roleSeq = ['xmin', ...Array.from({length: cols-2},(_,i)=>'r'+(i+1)), 'xmax'];

factLabels.forEach((lab, idx)=>{
  const f = idx+1;
  let tr = '<tr class="sf-pdf-row-a"><th>'+L(lab)+'</th>';
  for (let j=0; j<cols; j++){
    const role = roleSeq[j];
    const v = (Z[f] && Z[f][role]) || '';
    tr += pdfBarCell(v, role);
    if (j < cols-1) tr += `<td style="font-weight:700">${$$('.sf-f'+f,host)[j]?.value || ''}</td>`;
  }
  tr += '</tr>';
  body.push(tr);
});



// Ligne f(x) ‚Äî valeurs 0/|| sous colonnes + signes par intervalles
let trF = '<tr class="sf-pdf-row-fx"><th>'+ L(labelFx) +'</th>';
for (let j = 0; j < cols; j++) {
  const role = roleSeq[j];
  trF += pdfBarCell(Zfx[role] || '', role);
  if (j < cols - 1) trF += `<td style="font-weight:700">${fx[j] || ''}</td>`;
}
trF += '</tr>';
body.push(trF);


    $('#sf-out',host).innerHTML = `<div class="step"><div><b>Tableau de signes (forme factoris√©e) :</b></div><div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${body.join('')}</tbody></table></div></div>`;
    typesetAll($('#sf-out',host));
  },
  wireButtons(){ $('#btn-make').onclick=()=> this.makeTable($('#host')); $('#btn-action').style.display='none'; $('#btn-action2').style.display='none'; const labBtn = $('#mc-label');
  if (labBtn) labBtn.style.display = 'none';},
  reset(){ $('#sf-out') && ($('#sf-out').innerHTML=''); }
};

/* ===== 5) Tableau f' + variations ===== */
const toolDerivVar = {
  id:'deriv', title:"Tableau f' (signe) + variations de f",
  build(host){
    host.innerHTML = `
      <div class="row">
        <label>Nombre d‚Äôextr√©mums :</label>
        <input id="dv-n" type="number" min="0" max="6" value="2" style="width:70px">
        <button id="dv-gen" class="btn">G√©n√©rer la grille</button>
      </div>
      <div id="dv-wrap" style="margin-top:.5rem"></div>
      <div class="steps" id="dv-out"></div>`;
    $('#dv-gen',host).onclick=()=> this.makeGrid(host);
  },
makeGrid(host){
  const n = Math.min(6, Math.max(0, +$('#dv-n',host).value || 0));
  const cols = ['xmin', ...Array.from({length:n}, (_,i)=> 'c'+(i+1)), 'xmax'];

  const xCell   = role => `<td><input class="dvx" data-role="${role}" type="text" placeholder="${role}"></td>`;
  const sCell   = i    => `<td class="bigsel"><select class="dvs" data-i="${i}"><option></option><option>+</option><option>${UMIN}</option></select></td>`;
  const dirCell = i    => `<td class="bigsel"><select class="dvd" data-i="${i}">  <option></option><option>‚Üò</option><option>‚Üó</option><option>‚Üí</option></select></td>`;
  const yBlock  = role => `<td><div style="display:flex;flex-direction:column;gap:6px;align-items:center">
                             <input class="dvYmax" data-role="${role}" type="text" placeholder="max">
                             <input class="dvYmin" data-role="${role}" type="text" placeholder="min">
                           </div></td>`;
  const zeroCell= role => `<td class="bigsel">
      <select class="dvz" data-role="${role}">
        <option value=""></option>
        <option value="0">0</option>
        <option value="||">||</option>
      </select>
    </td>`;

  // Ligne x
  let rX = '<tr><th>\\(x\\)</th>';
  cols.forEach((c,j)=>{ rX += xCell(c); if(j<cols.length-1) rX += '<td></td>'; });
  rX += '</tr>';

  // Ligne f'(x) : 0/|| sous chaque colonne + signe sur chaque intervalle
  let rS = `<tr><th>\\(f'(x)\\)</th>`;
  cols.forEach((c,j)=>{ rS += zeroCell(c); if(j<cols.length-1) rS += sCell(j); });
  rS += '</tr>';

function fCell(role){
  return `<td>
    <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
      <select class="vfmark" data-role="${role}">
        <option value=""></option>
        <option value="||">||</option>
      </select>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:center">
        <input class="dvYmax" data-role="${role}" type="text" placeholder="max">
        <input class="dvYmin" data-role="${role}" type="text" placeholder="min">
      </div>
    </div>
  </td>`;
}


let rF = '<tr><th>\\(f\\)</th>';
cols.forEach((c,j)=>{
  rF += fCell(c);
  if(j<cols.length-1) rF += `<td class="bigsel"><select class="dvd" data-i="${j}">  <option></option><option>‚Üò</option><option>‚Üó</option><option>‚Üí</option></select></td>`;
});
rF += '</tr>';

$('#dv-wrap',host).innerHTML = `<div class="var-wrap"><table class="var"><tbody>${rX}${rS}${rF}</tbody></table></div>`;
wireBarCells($('#dv-wrap',host));
typesetAll($('#dv-wrap',host));
$('#btn-make').style.display='inline-block';
$('#btn-action').style.display='none';
$('#btn-action2').style.display='none';

},

makeTable(host){
  const xs   = $$('.dvx',host).map(i=> i.value.trim());
  const sgn  = $$('.dvs',host).map(s=> s.value || '');      // signes de f'
  let   dirs = $$('.dvd',host).map(s=> s.value || '');      // ‚Üò/‚Üó pour f
  if(dirs.every(v=>!v)) dirs = sgn.map(s=> s==='+' ? '‚Üó' : (s ? '‚Üò' : ''));

  const roles = ['xmin', ...$$('.dvx',host).slice(1,-1).map((_,i)=> 'c'+(i+1)), 'xmax'];

  // 0/|| sous chaque colonne de f'(x)
  const zmap = {};
  $$('.dvz',host).forEach(sel => { zmap[sel.dataset.role] = sel.value || ''; });

  const L = s => `\\(${String(s).replace('-',''+UMIN)}\\)`;
  const cellValMid = v => `<td class="mid"><div class="midv">${Lx(v)}</div></td>`;

  // --- valeurs limites saisies dans la ligne f (max/min par colonne) ---
  const vals = roles.map(r => ({
    yM: $(`.dvYmax[data-role="${r}"]`,host)?.value.trim() || '',   // "max" = limite gauche
    ym: $(`.dvYmin[data-role="${r}"]`,host)?.value.trim() || ''    // "min" = limite droite
  }));
  // marquage "||" sur f (dans la grille d‚Äô√©dition)
  const vmarkF = {};
  $$('.vfmark', host).forEach(sel => { vmarkF[sel.dataset.role] = sel.value || ''; });

  // THEAD (x) ‚Äî mod√®le √©tendu autour des || (sur f uniquement)
  const exp = []; // {kind:'limL'|'core'|'limR'|'sep', idx}
  roles.forEach((r,k)=>{
    const isBar = (vmarkF[r] === '||');
    const isFirst = (k === 0), isLast = (k === roles.length - 1);
    if (isBar && !isFirst) exp.push({kind:'limL', idx:k});
    exp.push({kind:'core', idx:k});
    if (isBar && !isLast)  exp.push({kind:'limR', idx:k});
    if (k < roles.length-1) exp.push({kind:'sep', idx:k});
  });

  const head = ['<tr><th>\\(x\\)</th>'];
  exp.forEach(e=>{
    if (e.kind === 'core') head.push(`<td>${Lx(xs[e.idx])}</td>`); else head.push('<td></td>');
  });
  head.push('</tr>');

  // ===== Ligne f'(x) : 0/|| sur colonnes "core", vide sur limL/limR, signe sur sep =====
  let rowFp = `<tr><th>\\(f'(x)\\)</th>`;
    const overrideCore = new Array(roles.length).fill(null);

  exp.forEach(e=>{
    if (e.kind === 'sep'){ rowFp += `<td style="font-weight:700;text-align:center">${sgn[e.idx]||''}</td>`; return; }
    if (e.kind === 'core'){ rowFp += pdfBarCell(zmap[roles[e.idx]] || '', roles[e.idx]); return; }
    // limL/limR : cellule vide (juste l‚Äôespace de la limite visuelle)
    rowFp += `<td class="lim"></td>`;
  });
  rowFp += '</tr>';

  // ===== Ligne f : m√™me logique que l‚Äôexercice 2, avec colonnes √©tendues =====
  // Pr√©paration top/bottom ‚Äúclassique‚Äù (hors ||)
  const topArr = new Array(roles.length).fill('');
  const botArr = new Array(roles.length).fill('');
  roles.forEach((r, idx) => {
    const { yM, ym } = vals[idx];
    const isFirst = (idx === 0), isLast = (idx === roles.length - 1);
    if (isFirst){
      const d = dirs[0] || '';
        if      (d === '‚Üó') botArr[idx] = ym || '';
      else if (d === '‚Üò') topArr[idx] = yM || '';
      else if (d === '‚Üí') overrideCore[idx] = cellValMid( ym || yM || '' );
    
    } else if (isLast){
      const d = dirs.at(-1) || '';
         if      (d === '‚Üó') topArr[idx] = yM || '';
      else if (d === '‚Üò') botArr[idx] = ym || '';
      else if (d === '‚Üí') overrideCore[idx] = cellValMid( yM || ym || '' );
    
    } else {
      if      (yM) topArr[idx] = yM;
      else if (ym) botArr[idx] = ym;
    }
  });

  function cellValRaw(topText, bottomText){
    const up = topText ? Lx(topText) : '&nbsp;';
    const dn = bottomText ? Lx(bottomText) : '&nbsp;';
    return `<td class="lim"><div style="text-align:center">${up}</div><div style="height:6px"></div><div style="text-align:center">${dn}</div></td>`;
  }

  let rowF = '<tr><th>\\(f\\)</th>';
  exp.forEach(e=>{
    if (e.kind === 'sep'){ rowF += `<td class="arr">${dirs[e.idx]||''}</td>`; return; }
    if (e.kind === 'core'){
      const role = roles[e.idx];
      const isBar = (vmarkF[role] === '||');
      const leftConst  = (e.idx > 0 && dirs[e.idx - 1] === '‚Üí');
      const rightConst = (e.idx < roles.length - 1 && dirs[e.idx] === '‚Üí');
      const vCore = vals[e.idx].yM || vals[e.idx].ym || '';

      if (isBar){
        rowF += '<td class="dbar"></td>';
      } else if (overrideCore[e.idx]){
        rowF += overrideCore[e.idx];
      } else if (leftConst || rightConst){
        rowF += cellValMid(vCore);
      } else {
       rowF += cellValRaw(topArr[e.idx], botArr[e.idx]);
      }
      return;
    }
    // Colonnes limites (autour d'une ||) ‚Äî duplication si une seule limite
    const k = e.idx, isLeft = (e.kind==='limL'), isRight = !isLeft;
    if (isLeft){
      // priorit√© yM (limite gauche), sinon duplique ym
      const v = vals[k].yM || vals[k].ym || '';
      const dL = dirs[k-1] || '';
      if (!v){ rowF += '<td class="lim"></td>'; return; }
 if (dL==='‚Üí') { rowF += cellValMid(v); return; }
      rowF += (dL==='‚Üó') ? cellValRaw(v,'')
           : (dL==='‚Üò') ? cellValRaw('',v)    // finit en bas √† gauche
                         : cellValRaw(v,'');
      return;
    }
    if (isRight){
      // priorit√© ym (limite droite), sinon duplique yM
      const v = vals[k].ym || vals[k].yM || '';
      const dR = dirs[k] || '';
      if (!v){ rowF += '<td class="lim"></td>'; return; }
if (dR==='‚Üí') { rowF += cellValMid(v); return; }
      rowF += (dR==='‚Üó') ? cellValRaw('',v)           : (dR==='‚Üò') ? cellValRaw(v,'')    // d√©marre en haut √† droite
                         : cellValRaw('',v);
      return;
    }
  });
  rowF += '</tr>';

  // Injection + rendu
  $('#dv-out',host).innerHTML =
    `<div class="step"><div><b>Tableau f' et variations de f :</b></div>
      <div class="var-wrap"><table class="pdf-tbl"><thead>${head.join('')}</thead><tbody>${rowFp}${rowF}</tbody></table></div>
    </div>`;
  typesetAll($('#dv-out',host));
},

  wireButtons(){ $('#btn-make').onclick=()=> this.makeTable($('#host')); $('#btn-action').style.display='none'; $('#btn-action2').style.display='none';const labBtn = $('#mc-label');
  if (labBtn) labBtn.style.display = 'none'; },
  reset(){ $('#dv-out') && ($('#dv-out').innerHTML=''); }
};

/* ===== Registre outils ===== */
const TOOLS=[toolCurve, toolMultiCurve, toolVar, toolSign1, toolSignFact, toolDerivVar];

function buildTool(){ const sel=$('#tool-select').value; const t=TOOLS.find(u=>u.id===sel)||TOOLS[0]; const host=$('#host'); t.build(host); typesetAll(host); t.wireButtons?.(); }
function resetTool(){ const sel=$('#tool-select').value; const t=TOOLS.find(u=>u.id===sel)||TOOLS[0]; t.reset?.(); }

// UI
(function init(){
  const sel = $('#tool-select');
  sel.innerHTML = TOOLS.map((t,i)=>`<option value="${t.id}">${i+1} ‚Äî ${t.title}</option>`).join('');
  sel.onchange = buildTool;
  // retire cette ligne :
  // $('#btn-build').onclick = buildTool;
  $('#btn-reset').onclick = resetTool;
  sel.value = TOOLS[0].id;
  buildTool();
})();

/* PDF kit (optionnel) */
(function waitExoPDF(){
  if(window.ExoPDF && typeof ExoPDF.init==='function'){
    ExoPDF.init({ title:'Seconde ‚Äî G√©n√©rateurs (courbe, variations, signes, d√©riv√©e)', mountAfterSelector:'.card.small' });
  } else setTimeout(waitExoPDF, 100);
})();

})();
</script>
</body>
</html>